- en: Chapter 11. Things That Go Bump – Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十一章：碰撞事件——第二部分
- en: The collision detection in this game is much more complex than the previous
    two. For this reason, the code will be quite heavily commented. Sometimes the
    comments will explain things in a bit more detail or in a slightly different way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏中的碰撞检测比前两款要复杂得多。因此，代码将会有很多注释。有时注释会详细解释一些内容，或者用稍微不同的方式解释。
- en: However, that doesn't mean it needs to be hard work. What we need to do is take
    a moment to consider a strategy that will work for us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着它需要艰苦的工作。我们需要做的是花点时间考虑一个适合我们的策略。
- en: Hopefully, this approach will mean that by the end of the chapter, our collision
    detection solutions will appear straightforward.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这种方法意味着在本章结束时，我们的碰撞检测解决方案将显得直接明了。
- en: Planning for collision detection
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测的规划
- en: 'What we are trying to achieve can be put into the following two categories:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的目标可以分为以下两类：
- en: 'What we want for the border:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望边界能做到：
- en: Asteroids, bullets, and the ship need to know when they have collided with the
    border
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小行星、子弹和船只需要在它们与边界碰撞时知道这一点
- en: Asteroids should reverse and head back into the game area when they touch the
    border
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小行星在接触到边界时应反转并返回游戏区域
- en: A bullet should reset itself at the border
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹在接触到边界时应重置自己
- en: The ship should subtract a life and then respawn in the centre
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 船只需要减去一条生命，然后在中心重新生成
- en: 'What we want for the asteroids. We need to know and respond when:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望小行星能做到什么。我们需要知道并在以下情况下做出响应：
- en: The ship touches an asteroid
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 船只接触到小行星
- en: When a bullet touches an asteroid
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一颗子弹接触到小行星时
- en: As in the original Asteroids game, we will not respond to asteroids bumping
    into each other
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始的《小行星》游戏一样，我们将不对小行星之间的相互碰撞做出响应
- en: Although we will not be detecting an asteroid on asteroid collisions, you will
    see that when our collision detection nears completion, achieving asteroid on
    asteroid collision detection will not present much of an extra challenge. However,
    it will put extra strain on the device's CPU.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会检测小行星之间的碰撞，但当我们的碰撞检测接近完成时，你会发现实现小行星之间的碰撞检测并不会带来太大的额外挑战。然而，这会对设备的CPU造成额外的压力。
- en: We know that we have object on border collisions to detect and object on asteroid
    collisions to detect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要检测的对象有边界碰撞和小行星碰撞。
- en: Colliding with the border
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与边界的碰撞
- en: It may sound obvious, but the border is simply four static straight lines. This
    makes a border collision a different problem to an asteroid collision.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很明显，但边界仅仅是由四条静态直线组成。这使得边界碰撞与小行星碰撞是不同的问题。
- en: All of the objects that we are interested in have vertices (or one vertex in
    the case of a bullet). This may at first suggest that we can simply compute the
    world location of each vertex from the model space and the centre of the object
    stored in `worldLocation`. We can, but this overlooks the fact that the asteroids
    and the ship rotate, which constantly causes a variation in the actual world locations
    of all the vertices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的所有对象都有顶点（子弹的情况就是一个顶点）。这最初可能意味着我们可以简单地从模型空间和存储在`worldLocation`中的对象中心计算每个顶点的世界位置。我们可以这样做，但这忽略了小行星和船只的旋转，这导致所有顶点的实际世界位置不断变化。
- en: We will need to translate and rotate the model space vertices, and then test
    if any of them have touched the border. We can do this in the object's `update`
    method for each frame, but we only need the rotated coordinates occasionally,
    when the object is very close to the border.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将模型空间的顶点进行平移和旋转，然后测试它们是否触碰到边界。我们可以在每个帧的对象的`update`方法中这样做，但我们只需要在对象非常接近边界时偶尔获取旋转后的坐标。
- en: The first phase of border collision detection
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界碰撞检测的第一阶段
- en: This suggests that a preliminary check, a first phase of collision detection,
    is more efficient. It implies that the translation and rotation of the vertices
    will need to take place outside of the object itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明初步检查，即碰撞检测的第一阶段，效率更高。这意味着顶点的平移和旋转需要发生在对象本身之外。
- en: What we will do is use a simple rectangle intersect check based on the centre
    of the object and its width and height. If this cheap method returns a hit, we
    will then rotate and translate each vertex and check their real-world coordinates
    individually against the location of the border.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个基于对象中心和宽高的简单矩形相交检查。如果这个低成本的方法返回一个命中，我们然后将每个顶点进行旋转和平移，并单独检查它们的世界坐标是否与边界位置相撞。
- en: Once the rotated game world locations of the vertices are calculated, the collision
    detection is simple.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出顶点的旋转后游戏世界位置后，碰撞检测就变得简单了。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we will see, a two-stage solution is appropriate for the asteroid detection
    as well. Also, rotation and translation is involved but it is far less important.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，两阶段解决方案也适用于小行星检测。尽管涉及到旋转和平移，但这要次要得多。
- en: Colliding with an asteroid
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与小行星碰撞
- en: Testing for collision with an asteroid is similar in some respects. We need
    to find out if any single vertex from the ship or a bullet crosses into the space
    contained by the vertices of the asteroid.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与小行星的碰撞测试在某些方面是相似的。我们需要找出船或子弹的任何一个顶点是否进入了由小行星顶点所围成的空间。
- en: The first problem is that the asteroid is not only a moving target, but also
    a rotating one. We will not only have to rotate and translate all the vertices
    of the objects, but the asteroids as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题在于小行星不仅是一个移动目标，而且还在旋转。我们不仅要旋转和平移物体的所有顶点，还要对小行星进行同样的操作。
- en: We also need to calculate the line made between each pair of vertices on the
    asteroid. Fortunately, at this point, we can fall back on a clever algorithm devised
    and refined by mathematicians far greater than myself. We will use the crossing
    number algorithm. This is how it works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要计算小行星上每对顶点之间的线段。幸运的是，在这个阶段，我们可以依赖一个比我更伟大的数学家设计并完善的巧妙算法。我们将使用交叉数算法。这是它的工作原理。
- en: The crossing number
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉数
- en: We compute the line made by a pair of vertices and use the crossing number algorithm
    to see if a particular vertex from the object being tested crossed that line.
    If it did, we increment a variable from 0 to 1.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算一对顶点形成的线段，并使用交叉数算法查看被测试物体的某个特定顶点是否穿过了该线段。如果穿过了，我们将一个变量从0增加到1。
- en: We test the same point against each and every line made by each vertex pair
    from an asteroid, incrementing our variable each time it does. If our variable
    is odd after testing the vertex against every line with the crossing number algorithm,
    we have a hit. If it is even, no collision has occurred.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用交叉数算法测试同一个点与由小行星的每对顶点形成的每一条线，每次它穿过就增加我们的变量。如果在对顶点与每条线进行测试后，我们的变量是奇数，那么就表示有碰撞发生。如果是偶数，则没有发生碰撞。
- en: Of course if no collision has occurred, we must proceed to test each and every
    vertex from the object being tested against each and every line formed out of
    the vertex pairs on the asteroid.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有发生碰撞，我们必须继续测试被测试物体的每个顶点与由小行星上的顶点对形成的每条线。
- en: Here is a visual representation of the crossing number algorithm in action.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张交叉数算法工作过程的视觉表示图。
- en: '![The crossing number](img/B043422_11_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![交叉数](img/B043422_11_01.jpg)'
- en: Of course with all these complex calculations going on, we will definitely want
    to do a simple first phase test to see if it is likely there has been a collision
    before doing the complex tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在进行所有这些复杂的计算时，我们肯定想要先做一个简单的第一阶段测试，以查看是否可能发生了碰撞，然后再进行复杂的测试。
- en: The first phase and overview of asteroid collision detection
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小行星碰撞检测的第一阶段和概述
- en: The radius overlap test is quite appropriate when testing a single vertex, such
    as a bullet, a spinning triangle like a ship, or a rotating asteroid.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试单个顶点，如子弹、像船一样的旋转三角形或旋转小行星时，半径重叠测试非常合适。
- en: 'This is an overview of the whole process we will use for testing the collisions
    against asteroids:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于测试与 小行星碰撞的整个过程的概述：
- en: Is the radius of the object being tested overlapped with the radius of an asteroid?
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被测试物体的半径是否与小行星的半径重叠？
- en: If yes, has the first vertex of the object crossed the first line of the asteroid?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，物体的第一个顶点是否穿过了小行星的第一条线？
- en: If yes, `crossingNumber ++`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，`crossingNumber ++`。
- en: Repeat step 2 with each line on the object.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个物体的每行重复步骤2。
- en: If `crossingNumber` is odd, return true to calling code because a collision
    has occurred.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`crossingNumber`是奇数，返回给调用代码true，因为已经发生了碰撞。
- en: If `crossingNumber` is even, no collision has occurred (yet) repeat steps 2,
    3, and 4 with the next vertex of the object being tested.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`crossingNumber`是偶数，则尚未发生碰撞，用被测试物体的下一个顶点重复步骤2、3和4。
- en: If all vertices tested and we reached here then no collision has occurred.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有顶点都已测试并且我们到达这里，则没有发生碰撞。
- en: We will set up a collision detection class called `CD` with two static methods.
    The `detect` method will test for collisions with asteroids and be called for
    each bullet and ship against each and every asteroid in each frame.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个名为`CD`的碰撞检测类，其中包含两个静态方法。`detect`方法将测试与小行星的碰撞，并且每一帧对每个子弹和飞船调用，针对每一个小行星。
- en: The `contain` method will check for collisions with every asteroid, bullet,
    and ship against the border.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`contain`方法将检查每个小行星、子弹和飞船与边界的碰撞情况。'
- en: Doing the calculations outside the objects themselves means that we will need
    a whole bunch of data for the objects we will be testing, and the ones made accessible
    to the new `CD` class's methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象外部进行计算意味着我们将需要大量我们正在测试的对象的数据，以及那些可供新的`CD`类方法访问的数据。
- en: The CollisionPackage class
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CollisionPackage`类'
- en: We know that we need a certain set of data to carry out detections properly.
    This next class will hold all the data that our collision detection class's methods
    will need in order to do its job, and every object that we need to detect collisions
    for will have one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，为了正确执行检测，我们需要一组特定的数据。接下来的这个类将保存碰撞检测类方法执行任务所需的所有数据，而每个需要检测碰撞的对象都将拥有这样一个类。
- en: When the time comes to rotate all the points to their real-world location, our
    collision package will need to know which way the object is facing. We have a
    float called `facingAngle`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将所有点旋转到它们在现实世界中的位置时，我们的碰撞包需要知道物体面向哪个方向。我们有一个名为`facingAngle`的浮点数。
- en: We will obviously need a copy of the model space vertices. As with the rotated
    location, we will not go through the trouble of updating every frame and will
    do so only after the first phase of collision detection shows that a collision
    is likely.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要模型空间顶点的副本。与旋转位置一样，我们不会在每一帧都麻烦地更新，而是在碰撞检测的第一阶段显示可能发生碰撞后这样做。
- en: We will also hold the precomputed value for the length of the array that holds
    these vertices. It can potentially save time in the collision detection process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将保存一个预计算的值，即保存这些顶点的数组的长度。它可以在碰撞检测过程中潜在地节省时间。
- en: Therefore, we will also need the world coordinates of the object. This, we will
    update every frame.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要物体的世界坐标。这个坐标我们将每一帧更新。
- en: Each object will have a precomputed `radius` variable, which is the size of
    the object from its centre to its furthest vertex. This will be used in our `detect`
    method for radius overlapping, phase one detection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象将有一个预计算的`radius`变量，这是从对象中心到最远顶点的距离，即对象的大小。这将在我们的`detect`方法中用于第一阶段检测的半径重叠。
- en: We will also have a couple of `PointF` objects, `currentPoint`, and `currentPoint2,`
    which are just handy objects that will avoid us potentially summoning the garbage
    collector during an intensive part of the two collision detection methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有两个`PointF`对象，`currentPoint`和`currentPoint2`，它们只是方便的对象，可以避免在我们两个碰撞检测方法中的密集部分可能调用垃圾收集器。
- en: 'Create a new class, call it `CollisionPackage`, and implement the members we
    have just discussed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CollisionPackage`的新类，并实现我们刚刚讨论过的成员：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we have a simple constructor that will receive all the necessary data
    from each object at the end of each object''s constructor. Implement the `CollisionPackage`
    constructor as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个简单的构造函数，它将在每个对象的构造函数末尾接收来自每个对象的所有必要数据。按照如下所示实现`CollisionPackage`构造函数：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all the data we need for advanced collision detection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们进行高级碰撞检测所需的所有数据。
- en: Adding collision packages to the objects and making them accessible
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向对象添加碰撞包并使它们可访问
- en: Now, we have our `CollisionPackage` class. We will see how to add one to each
    object we need to monitor.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了`CollisionPackage`类。我们将看到如何向每个需要监控的对象添加一个。
- en: Adding a collision package to the Bullet class
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向`Bullet`类添加一个碰撞包
- en: Open up the `Bullet` class, and we will see how to make use of our `CollisionPackage`
    constructor on the simplest case (just a point). Add a new member for the collision
    package.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Bullet`类，我们将看到如何在我们最简单的情况（只是一个点）上使用`CollisionPackage`构造函数。为碰撞包添加一个新成员。
- en: 'Add a new member of type `CollisionPackage` to the `Bullet` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bullet`类中添加一个类型为`CollisionPackage`的新成员：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we create a structure to pass in to our `CollisionPackage` constructor
    and initialize the collision package. Note that we send in a single element array
    with the model space coordinates that will be 0,0,0\. Then, we send in the world
    location, 1, for the radius and the angle the bullet is facing. Enter the following
    code at the end of the `Bullet` class''s constructor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个结构，将其传递给我们的`CollisionPackage`构造函数，并初始化碰撞包。注意，我们传递一个只包含模型空间坐标0,0,0的单元素数组。然后，我们传递子弹面向的世界位置、半径1和角度。在`Bullet`类的构造函数的最后输入以下代码：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally for the `Bullet` class, we update the collision package in each frame
    by adding this code to the very end of the `Bullet` class''s `update` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Bullet`类，我们通过在`Bullet`类的`update`方法的最后添加以下代码，在每一帧更新碰撞包：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, our bullets are all set for detection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的子弹都已准备好进行检测。
- en: Adding a collision package to the SpaceShip class
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向SpaceShip类添加碰撞包
- en: 'Open up the `SpaceShip` class and add these members. We will then see how to
    use them in the `SpaceShip` constructor:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`SpaceShip`类并添加这些成员。然后我们将在`SpaceShip`构造函数中看到如何使用它们：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we do something extra compared to the `Bullet` class. We add three more
    model space coordinates. OpenGL will not know about these and doesn''t need them.
    They are positioned in the middle of each of the three lines, which make the ship.
    We do this to make it harder for a vertex of an asteroid to drift inside the ship
    without a vertex of the ship being inside the asteroid. This is a visual representation
    of the problem that we are solving. The ships vertices are heavily emphasized
    to highlight the problem. Refer to the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与`Bullet`类相比，我们做了一些额外的工作。我们增加了三个额外的模型空间坐标。OpenGL不需要知道这些，也不需要它们。它们位于构成飞船的每条线的中间。我们这样做是为了使小行星的顶点更难在没有飞船顶点位于小行星内部的情况下漂入飞船内部。这是我们正在解决的问题的视觉表示。飞船的顶点被重点强调，以突出这个问题。参考以下图表：
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![向SpaceShip类添加碰撞包](img/B043422_11_02.jpg)'
- en: 'We can completely solve this problem by testing all the asteroids vertices
    against all of the ship''s lines as well as what we are planning to do; test all
    the ship''s vertices against all the asteroids lines. However, just adding a few
    extra points to the ship does produce near-perfect detection as shown next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测试所有小行星的顶点与所有飞船的线，以及我们计划要做的事情；测试所有飞船的顶点与所有小行星的线，完全解决这个问题。然而，仅向飞船添加几个额外的点确实可以产生近乎完美的检测，如下所示：
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![向SpaceShip类添加碰撞包](img/B043422_11_03.jpg)'
- en: 'Now, right after the call to `setVertices()` in the `SpaceShip` constructor
    implement the code we just discussed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`SpaceShip`构造函数中`setVertices()`调用之后，立即实现我们刚才讨论的代码：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next as we did for the `Bullet` class, we synchronize the collision package
    each frame in the `SpaceShip` class's `update` method. We do this at the very
    end of the method after the call to `move()` has updated the ship's coordinates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像对`Bullet`类所做的那样，我们在`SpaceShip`类的`update`方法中每帧同步碰撞包。在`move()`调用更新飞船坐标后，我们会在方法的最后这样做。
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, we will add a collision package to the asteroids.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在小行星上添加一个碰撞包。
- en: Adding a collision package to the Asteroid class
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向Asteroid类添加碰撞包
- en: 'Open up the `Asteroid` class and add a `CollisionPackage` member:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Asteroid`类并添加一个`CollisionPackage`成员：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the end of the `Asteroid` constructor, just after the call to `generatePoints()`,
    we initialize the `CollisionPackage` object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Asteroid`构造函数的最后，紧接在`generatePoints()`调用之后，我们初始化了`CollisionPackage`对象：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we add a helper method that reverses the direction of travel and *bounces*
    the asteroid back by a few pixels when a collision has been detected. We will
    call this method when we detect a collision with the border. Add the `bounce`
    method to the `Asteroid` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个辅助方法，当检测到碰撞时，这个方法会反转旅行方向，并将小行星通过几个像素*弹回*。当检测到与边界的碰撞时，我们将调用这个方法。将`bounce`方法添加到`Asteroid`类中：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As with the `SpaceShip` and `Bullet` classes, we will update the collision
    package in the `update` method just after the call to `move` at the very end of
    the `update` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SpaceShip`和`Bullet`类一样，我们将在`update`方法中，紧接在`move`调用之后，在`update`方法的最后更新碰撞包：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we need to do something that we didn't need to do for the other classes.
    Our crossing number algorithm uses lines not vertices, so we need to make a line
    out of the last vertex by joining it with the first. We didn't need to do this
    with the `SpaceShip` class because of the way our collision data code worked.
    The collision data code will test the points of the bullets and ship against the
    lines of the asteroids. Not the other way around.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做一件在其他类中不需要做的事情。我们的交叉数算法使用线而不是顶点，所以我们需要通过将最后一个顶点与第一个顶点连接起来来形成一条线。由于我们的碰撞数据代码的工作方式，我们不需要对`SpaceShip`类这样做。碰撞数据代码将测试子弹和飞船的顶点与小行星的线。而不是反过来的方式。
- en: 'Here is the extra code to add to the seventh point in the `generatePoints`
    method. In the following code, I have included the existing code on either side
    of the new highlighted code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要添加到`generatePoints`方法的第七点处的额外代码。在以下代码中，我在新突出显示的代码两侧包含了现有的代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can talk about building the collision detection class itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以谈谈构建碰撞检测类本身。
- en: The CD class outline
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD类大纲
- en: We will now implement the first phase of collision detection. As discussed,
    the algorithms we will use are computationally expensive, and we only want to
    use them when there is a realistic chance of a collision.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现碰撞检测的第一阶段。如所讨论的，我们将使用的算法计算成本很高，只有当有实际碰撞的可能性时，我们才希望使用它们。
- en: Therefore, we will check each bullet and the ship against every asteroid using
    the radius overlapping method discussed in [Chapter 3](ch03.html "Chapter 3. Tappy
    Defender – Taking Flight"), *Tappy Defender – Taking Flight*. We will check the
    asteroids, ship, and bullets against the border using a simplified rectangle intersection
    method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用在[第3章](ch03.html "第3章. Tappy Defender – 起飞")中讨论的半径重叠方法，检查每个子弹和飞船与每个小行星之间的碰撞。我们将使用简化的矩形相交方法检查小行星、飞船和子弹与边界之间的碰撞。
- en: After the next two sections, you will actually be able to play the game, but
    you will see that the basic collision detection that we have used so far is not
    satisfying enough for this type of game.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分之后，你实际上可以玩游戏，但你会发现我们到目前为止使用的这种基本碰撞检测对于这类游戏来说还不够令人满意。
- en: These first checks will decide whether we then move on to do the more accurate
    and computationally expensive checks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些初步检查将决定我们是否继续进行更准确且计算成本更高的检查。
- en: We will implement these second phase checks in the sections *Precise collision
    detection with the border* and *Precise collision detection with an asteroid*,
    which will use the more advanced algorithms and put the data in our collision
    packages to full use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*精确边界碰撞检测*和*精确小行星碰撞检测*部分实现这些第二阶段检查，它们将使用更高级的算法，并充分利用我们的碰撞数据包。
- en: To get started, create a new class and call it `CD`. Add a member `PointF` object
    and initialize it. We will use it to avoid creating new objects during the critical
    parts of the code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`CD`的新类。添加一个`PointF`成员对象并初始化它。我们将在代码的关键部分使用它，以避免创建新对象。
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's discuss the methods.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下这些方法。
- en: Implementing radius overlapping for asteroids and ships
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为小行星和飞船实现半径重叠
- en: Let's add our first method to the `CD` class, to detect collisions between bullets
    and asteroids as well as the ship and asteroids. As we discussed, we are only
    implementing the first part of this method for now. Here is the implementation
    of the radius overlapping code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`CD`类中添加我们的第一个方法，用于检测子弹与行星以及飞船与行星之间的碰撞。正如我们讨论的，现在我们只实现这个方法的第一部分。以下是半径重叠代码的实现。
- en: The code works by making a hypothetical triangle with a missing side, and then
    using Pythagoras' theorem to calculate the missing side that is the distance between
    the centre points of the two objects. If the combined radii of the two objects
    is greater than the distance between the two object centers, we have an overlap.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过构建一个缺少一边的假设三角形，然后使用勾股定理计算两个对象中心点之间的缺失边，也就是两个物体之间的距离。如果两个物体的半径之和大于两个物体中心之间的距离，那么就存在重叠。
- en: Add the `detect` method with the radius overlapping code. Note that we return
    `true` if the radii overlap. This one line of code will be replaced with the more
    accurate detection later in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 添加带有半径重叠代码的`detect`方法。注意，如果半径重叠，我们返回`true`。这行代码将在本章后面被更准确的检测所替换。
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's discuss the border.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下边界。
- en: Implementing rectangle intersection for the border
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现边界矩形相交
- en: We will see if any asteroids, bullets, or the ship need containing within the
    border. As discussed, we will carry out a simple rectangle intersect test and
    return `true` if detected. Later, we will delete the return `true` and add the
    more sophisticated code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查是否有任何小行星、子弹或飞船需要被限制在边界内。如讨论所述，我们将执行一个简单的矩形相交测试，如果检测到则返回`true`。稍后，我们将删除返回`true`并添加更复杂的代码。
- en: 'Implement the `contain` method as shown next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按照如下所示实现`contain`方法：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we have two methods that we just need to call them on all the appropriate
    object combinations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个方法，只需对所有合适对象组合调用它们即可。
- en: Performing the checks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行检查
- en: We are really close to being able to play our game, albeit with simplified collision
    detection. First add some methods that handle what happens when certain collisions
    are detected and then see how we actually use our `CD` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常接近能够玩我们的游戏了，尽管碰撞检测被简化了。首先添加一些处理特定碰撞被检测到时会发生什么的方法，然后看看我们是如何实际使用我们的`CD`类的。
- en: Helper methods
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助方法
- en: First of all, we need a couple of helper methods to respond, when we detect
    various types of collisions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些辅助方法，以便在检测到各种类型的碰撞时做出响应。
- en: We need a method for when the ship is destroyed and a method for when an asteroid
    is destroyed. The next two subsections cover this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个在飞船被摧毁时调用的方法，以及一个在摧毁小行星时调用的方法。接下来的两个小节将介绍这些内容。
- en: Destroying a ship
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摧毁飞船
- en: The death of a ship can be detected in two places, so it makes sense to add
    a method to handle the events that follow. In this next method, we reset the ship's
    location to the center of the map, play a sound, and decrement `numLives`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船的“死亡”可以在两个地方检测到，因此添加一个处理随后事件的方法是合理的。在下一个方法中，我们将飞船的位置重置为地图中心，播放声音，并减少`numLives`的值。
- en: If `numLives` is equal to zero, set `levelNumber` back to one, `numLives` to
    three, call `createObjects()` to redraw a level, pause the game, and then play
    a sound suitable to let the player know that he is starting again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`numLives`等于零，将`levelNumber`重置为1，`numLives`重置为3，调用`createObjects()`重新绘制一个级别，暂停游戏，然后播放一个声音，让玩家知道他要重新开始。
- en: 'Now, add the `lifeLost` method to the `AsteroidsRenderer` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向`AsteroidsRenderer`类中添加`lifeLost`方法：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will handle what happens when an asteroid dies.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理小行星“死亡”时会发生什么。
- en: Destroying an asteroid
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摧毁小行星
- en: This method will be called when the ship or a bullet hits an asteroid. First,
    we set the asteroid that triggered the collision to `setActive(false)`. It will
    not be drawn or updated any more.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船或子弹击中一个小行星时，将调用此方法。首先，我们将触发碰撞的小行星设置为`setActive(false)`，它将不再被绘制或更新。
- en: Next, we play a sound and decrement `numAsteroidsRemaining`. Finally if `numAsteroidsRemaining`
    is equal to zero, the player has cleared an entire level. In that case, we increment
    `levelNumber` and `numLives`, play a victorious sound, and start a harder level
    by calling `createObjects()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们播放声音并减少`numAsteroidsRemaining`的值。如果`numAsteroidsRemaining`等于零，意味着玩家已经清除了整个关卡。在这种情况下，我们增加`levelNumber`和`numLives`，播放胜利的声音，并通过调用`createObjects()`开始一个更难的级别。
- en: 'Now, add the `destroyAsteroid()` method to the `AsteroidsRenderer` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向`AsteroidsRenderer`类中添加`destroyAsteroid()`方法：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now call our new `CD` class's static methods and respond when we get
    a collision.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用我们新的`CD`类的静态方法，并在检测到碰撞时做出响应。
- en: Testing for collisions in update()
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`update()`中测试碰撞
- en: First, we will check to see if the ship needs containing. We simply call `CD.contain()`
    with the `mapWidth`, `mapHeight`, and the ship's collision package. If there is
    a collision, the code calls `lifeLost()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查是否需要限制飞船。我们只需使用`mapWidth`、`mapHeight`和飞船的碰撞包调用`CD.contain()`。如果发生碰撞，代码将调用`lifeLost()`。
- en: 'Add the collision detection code after all the code that updates the objects
    in the `update` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '在`update`方法中更新所有对象后，添加碰撞检测代码： '
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the code that detects if any of the asteroids are attempting to leave
    the asteroid simulator. It works exactly the same way as the previous block of
    code except that we loop through each asteroid, check if it is active, and call
    bounce on the asteroid if we detect a collision.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码用于检测是否有小行星试图离开小行星模拟器。除了我们遍历每个小行星，检查它是否处于活动状态，并在检测到碰撞时对小行星调用`bounce`方法外，它的工作原理与之前的代码块完全相同。
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code for the bullets looks a little more complicated, but it isn't really.
    The call to `CD.contain()` is identical, and we do so for each bullet. However,
    some last minute balancing of the game play is necessary for the bullet to be
    reset as it left the viewport (if that was before the border), because otherwise
    the ship can just spin round and destroy the asteroids from a great distance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹的代码看起来有点复杂，但其实不是。对`CD.contain()`的调用是相同的，我们对每颗子弹都这样做。但是，为了使子弹在离开视口（如果这发生在边界之前）时重置，需要进行一些最后的游戏平衡，否则飞船可以简单地旋转并从很远的距离摧毁小行星。
- en: 'Enter the code to detect bullet collisions with the border and the edge of
    the viewport:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输入代码以检测子弹与边界和视口边缘的碰撞：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can run the game now and see how the `CD.contain()` method does a fairly
    good job of keeping everything within the asteroid simulator.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行游戏，看看`CD.contain()`方法是如何很好地保持所有物体在模拟小行星内的。
- en: We will call our `detect` method to see if anything is bumping into an asteroid.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`detect`方法，看看是否有任何东西撞上了小行星。
- en: First, check the bullets. Note that we do a preliminary check to make sure the
    bullet is in flight, and the asteroid is active before we trouble our `CD.detect`
    method. Then, we just pass in the two collision packages and `CD.detect` does
    the rest. If a bullet collides with the border, we call `resetBullet()` on the
    appropriate bullet.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查子弹。注意我们进行初步检查，以确保子弹在飞行中，小行星处于活动状态，然后才会麻烦我们的`CD.detect`方法。然后，我们只需传入两个碰撞包，`CD.detect`完成其余工作。如果子弹与边界碰撞，我们会在相应的子弹上调用`resetBullet()`。
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we test for the ship. If a collision is detected, we call `destroyAsteroid()`
    followed by `lifeLost()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们测试飞船。如果检测到碰撞，我们依次调用`destroyAsteroid()`和`lifeLost()`。
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, you can play the game and our rudimentary collision detection
    will work. However, fly too close to an asteroid, and you will lose a life without
    touching it or merely shoot a bullet close and the asteroid is gone. We need to
    be able to skim the surface of the border or asteroid and only get a hit when
    a point actually crosses into the exact space of another object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以玩游戏，我们的基本碰撞检测将会起作用。但是，如果你飞得太接近小行星，你会在没有接触的情况下失去一条生命，或者只是在小行星附近发射一颗子弹，小行星就会消失。我们需要能够掠过边界或小行星的表面，并且只有在当一个点实际进入另一个物体的确切空间时才会发生碰撞。
- en: Precise collision detection with the border
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确的边界碰撞检测
- en: To upgrade our `detect` method, we need to replace the return statement in the
    `if(possibleCollision)` block with the more precise detection code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了升级我们的`detect`方法，我们需要用更精确的检测代码替换`if(possibleCollision)`块中的返回语句。
- en: First, initialize `radianAngle` to be the radian equivalent of whichever direction
    (in degrees) our object is facing. The `Math` class uses radians as they are more
    mathematically useful in calculations than the easier to visualize degree measurement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化`radianAngle`为我们的物体面向的任意方向（以度为单位）的弧度等价。`Math`类使用弧度，因为它们在计算中比更容易视觉化的度数更有数学上的用途。
- en: The variables `cosAngle` and `sinAngle` are just what the name suggests, and
    are used in the block of code which follows this one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`cosAngle`和`sinAngle`正如其名所示，并在接下来的代码块中使用。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is worth mentioning that the `Math.cos()` and `Math.sin()` methods are relatively
    time consuming. We can speed up our collision detection class by precomputing
    360 values for both `sin` and `cos` and then using a simple lookup method instead
    of this calculation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，`Math.cos()`和`Math.sin()`方法相对耗时。我们可以通过预先计算`sin`和`cos`的360个值来加速碰撞检测类，然后使用简单的查找方法代替这个计算。
- en: However, we maintain our goal of over 60 frames per second, so don't do so here.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们要保持每秒60帧以上的目标，所以这里不要这样做。
- en: 'Delete the return statement and add this code in the `if(possibleCollision)`
    block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 删除返回语句，并在`if(possibleCollision)`块中添加以下代码：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next block of code, enter a `for` loop that loops through each of the
    object's vertices, translates them from model-space to world-space coordinates,
    then uses our previously computed values for cosine and sine of the `facingAngle`
    object to rotate them to their precise locations in the game world.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，输入一个`for`循环，遍历每个对象的顶点，将它们从模型空间转换到世界空间坐标，然后使用之前计算好的`facingAngle`对象的余弦和正弦值来旋转它们到游戏世界中的精确位置。
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now all we do is see if the rotated and translated vertex falls outside of either
    the left, right, top, or bottom of the border/map. If it does, we return `true`;
    if not, the loop continues to check each and every vertex the same way (translate,
    rotate, check, and so on).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的就是检查旋转和平移后的顶点是否在边界/地图的左侧、右侧、顶部或底部之外。如果是，我们返回`true`；如果不是，循环将继续以相同的方式检查每个顶点（平移、旋转、检查等）。
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can run the game now and watch the bullets disappear with a satisfying thud
    into the border or fly your ship deadly close to the border.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，观看子弹带着令人满意的撞击声消失在边界内，或者驾驶你的飞船危险地接近边界。
- en: Let's improve our asteroid collisions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们优化小行星碰撞的处理。
- en: Precise collision detection with an asteroid
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确检测小行星的碰撞
- en: We did this last because there is a more complicated final step. As in the border
    detection, we will need to translate and rotate our object's vertices. However
    this time, we will need to do it for two objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以最后做这个，是因为有一个更复杂的最后步骤。与边界检测类似，我们需要转换和旋转物体的顶点。但这次，我们需要对两个物体都这样做。
- en: Furthermore, once we rotated and translated the asteroid's vertices, we will
    need to handle them in pairs of vertices that form a line. These are lines that
    we will test against each and every vertex from the other object. This test is
    of course our crossing number method that we discussed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦我们旋转和平移了小行星的顶点，我们需要成对处理形成线的顶点。这些线是我们将要测试与其他物体每个顶点相交的线。这个测试当然是我们之前讨论过的交叉数方法。
- en: We need to do all of this within the body of the `if (distance < cp1.radius
    + cp2.radius) { ...}`, where we previously just set the `collided` Boolean to
    `true`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`if (distance < cp1.radius + cp2.radius) { ...}`的代码块内完成所有这些操作，之前我们只是将`collided`布尔值设置为`true`。
- en: There is quite a lot of code, so we will split it into chunks and see what is
    going on at each stage. Also, the code indentation will not always be consistent
    from block to block in order to format it in the most readable way possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码量相当大，因此我们会将其分成几部分，并逐步了解每个阶段发生的情况。此外，为了尽可能使格式易于阅读，代码缩进在各个代码块之间可能不会始终保持一致。
- en: The next few blocks of code are the entire contents of the aforementioned, `if`
    block that needs replacing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几段代码就是前述`if`代码块的全部内容，需要替换。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As mentioned previously, we can use a sine and cosine lookup table here too.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这里我们也可以使用正弦和余弦的查找表。
- en: We could make a method to rotate angles as we do this so often. But this is
    not as straightforward as it may seem. If we put the rotation code in a method,
    we will either have to put the following sine and cosine calculations in it, which
    will make it slow or precompute it before the method call and the `for` loops
    which is kind of untidy itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个方法来旋转角度，因为我们经常这样做。但这并不像看起来那么简单。如果我们把旋转代码放在一个方法中，我们要么不得不把下面的正弦和余弦计算也放进去，这将使它变慢；要么在方法调用和`for`循环之前预先计算，这本身也是一种不太整洁的做法。
- en: Also, if you consider that we need more than one value for both the sine and
    cosine of an angle, the method needs to *know* which value to use, and this isn't
    rocket science, but it starts to get even less compact than we might have initially
    imagined. So, I opted to avoid the method call altogether, even if the code is
    a little sprawling. Actually, if you place the whole lot in a method call, you
    still get nearly 60 FPS on an old Galaxy S2 phone. So if you want to tidy things
    up, go ahead; I just thought it was worth discussing why I did things this way.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，考虑到我们需要一个角度的正弦和余弦的多个值，该方法需要*知道*使用哪个值，这并不是火箭科学，但它的复杂度可能比我们最初想象的还要高。因此，我选择完全避免方法调用，即使代码看起来有些冗长。实际上，如果你把所有代码放在一个方法调用中，在旧款Galaxy
    S2手机上仍然可以得到接近60 FPS的帧率。所以如果你想要整理代码，请随意；我只是认为这种方式值得一谈。
- en: Before we jump into the `for` loops, as we did with the border detection, we
    will compute a few things that won't change for the duration of this method. The
    sine and cosine of the facing angle from each of the two collision packages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们像边界检测一样进入`for`循环之前，我们会计算一些在此方法执行期间不会改变的东西。即两个碰撞包的面向角度的正弦和余弦。
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we loop through all the vertices from `cp2`, then test each in turn with
    all the sides (vertex pairs) from `cp1`. Remember an asteroid has an extra vertex
    of padding that is the same as the first. Therefore, we can test the last side
    of the asteroid. We must always pass in the asteroid collision package as the
    *second* argument when calling `CD.detect()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从`cp2`遍历所有顶点，然后依次与`cp1`中的所有边（顶点对）进行测试。记住，小行星有一个额外的顶点填充，与第一个顶点相同。因此，我们可以测试小行星的最后一边。调用`CD.detect()`时，我们一定要将小行星碰撞包作为*第二个*参数传入。
- en: In the next block of code, translate and then rotate the object being tested
    against an asteroid.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一代码块中，将测试对象翻译并相对于小行星进行旋转。
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now using a pair of vertices at a time, from the asteroid, translate and rotate
    both to their final world-space coordinates ready for the next block of code,
    where we will use the vertex locations calculated in the previous block and this
    block.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次使用小行星的一对顶点，将它们翻译并旋转到它们最终的世界坐标空间，为下一代码块做准备，在那里我们将使用上一块和这一块计算出的顶点位置。
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we detect if the current vertex from either the ship or a bullet crosses
    the line formed by the current vertex pair of the asteroid. If it does, we increment
    `numCrosses`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检测当前的顶点（无论是飞船还是子弹）是否穿过由小行星当前顶点对形成的线。如果穿过了，我们就增加`numCrosses`的计数。
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we use the modulus operator to determine if `numCrosses` is odd or
    even. As discussed, we return `true` (collision) for odd and `false` (no collision)
    for even.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用模运算符来确定`numCrosses`是奇数还是偶数。如讨论所述，对于奇数我们返回`true`（碰撞），对于偶数返回`false`（无碰撞）。
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can now fly your ship right up to the asteroids and only get hit when it
    really looks like you should. Refer to the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以驾驶你的飞船直接飞向小行星，只有在真正看起来应该撞上的时候才会被击中。参考以下截图：
- en: '![Precise collision detection with an asteroid](img/B043422_11_04.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![与行星精确碰撞检测](img/B043422_11_04.jpg)'
- en: Now, all of our collision detection and our Asteroids simulator game is done!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的碰撞检测和小行星模拟器游戏都完成了！
- en: Finishing touches
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成收尾工作
- en: We can continue to improve our game. For example, it wouldn't be too hard to
    spawn two or three smaller asteroids when the current asteroid is destroyed. We
    just need an array to hold the smaller asteroids. When we deactivate the regular
    asteroid, the array activates some previously instantiated smaller ones at the
    same location as the regular one. We can then make some minor modifications to
    the way we count asteroids, and we will have a neat new feature.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续改进我们的游戏。例如，当当前的小行星被摧毁时，生成两个或三个更小的行星并不困难。我们只需要一个数组来保存小行星。当我们停用常规小行星时，该数组会在与常规小行星相同的位置激活一些先前实例化的小型小行星。然后我们可以对计算小行星数量的方式进行一些小修改，这样我们就会有一个整洁的新功能。
- en: The arcade classic, Asteroids, had a mean UFO that would turn up occasionally.
    It would be simple to design a UFO shape from lines, and have it randomly proceed
    from left to right, or right to left, moving up and down a bit as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 街机经典游戏Asteroids中，会偶尔出现一个神秘的UFO。设计一个由线条构成的UFO形状很简单，让它随机从左到右或从右到左移动，同时上下也有所移动。
- en: Finally, we can add a hyperspace button. This is a kind of last resort for the
    player when they are sure that death is imminent. Tap the hyperspace button and
    the ship will respawn in a random location. We will just need to add a button
    to the array in the `InputController` class and a call to a new, simple `randomHyperspaceJUmp`
    method in the `Ship` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个超空间按钮。这是玩家在确定即将死亡时的最后手段。轻触超空间按钮，飞船将在随机位置重新生成。我们只需要在`InputController`类中的数组里添加一个按钮，并在`Ship`类中调用一个新的简单方法`randomHyperspaceJump`。
- en: 'We can also add Google Play achievements and leaderboards and then publish
    the game. If you publish a game that uses OpenGL, you need to add this declaration
    to the `AndroidManifest.xml` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加谷歌游戏成就和排行榜，然后发布游戏。如果你发布一个使用OpenGL的游戏，你需要在`AndroidManifest.xml`文件中添加这个声明：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try and add some of the improvements we talked about and perhaps some more of
    your own. If you publish your game or even if you don't, I would love to hear
    your ideas or see a link to your projects on [gamecodeschool.com](http://gamecodeschool.com).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加我们讨论过的一些改进，也许还有你自己的改进。无论你是否发布你的游戏，我都想听听你的想法，或者看到你在[gamecodeschool.com](http://gamecodeschool.com)上的项目链接。
- en: I think we are done!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们已经完成了！
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you have enjoyed our whirl-wind tour, making games for Android, and I
    hope you keep making lots of new games!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您享受了我们快速浏览的为Android制作游戏的旅程，并希望您继续制作更多的新游戏！
