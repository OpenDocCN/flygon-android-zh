- en: Chapter 2. Looking Good – The Graphical Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 外观美观——图形界面
- en: In the previous chapter, we covered the features of Unity and Android. We also
    discussed the benefits of using them together. After we finished installing a
    bunch of software and setting up our devices, we created a simple Hello World
    application to confirm that everything was connected correctly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Unity和Android的特性，并讨论了将它们一起使用的益处。在我们安装了大量软件并设置好设备之后，我们创建了一个简单的Hello
    World应用程序，以确认一切连接正确。
- en: This chapter is all about **Graphical User Interface** (**GUI**). We will start
    by creating a simple Tic-tac-toe game, using the basic pieces of GUI that Unity
    provides. Following this, we will discuss how we can change the styles of our
    GUI controls to improve the look of our game. We will also explore some tips and
    tricks to handle the many different screen sizes of Android devices. Finally,
    we will learn about a much quicker way, compared to the one covered in the previous
    chapter, to put our games on the device. With all that said, let's jump in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完全关于**图形用户界面**（**GUI**）。我们将从使用Unity提供的基本GUI组件创建一个简单的井字游戏开始。接下来，我们将讨论如何改变我们的GUI控件的样式，以改善游戏的外观。我们还将探索一些技巧，以处理Android设备的不同屏幕尺寸。最后，我们将学习一种比上一章介绍的方法更快的方式，将我们的游戏放在设备上。说到这里，让我们开始吧。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: User preferences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户偏好设置
- en: Buttons, text, and images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮文字和图片
- en: Dynamic GUI positioning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态GUI定位
- en: Build and run
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行
- en: In this chapter, we will be creating a new project in Unity. The first section
    here will walk you through its creation and setup.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Unity中创建一个新项目。这里的第一个部分将指导你完成创建和设置。
- en: Creating a Tic-tac-toe game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个井字游戏
- en: The project for this chapter is a simple Tic-tac-toe style game, similar to
    what any of us might play on paper. As with anything else, there are several ways
    in which you can make this game. We are going to use Unity's uGUI system in order
    to better understand how to create a GUI for any of our other games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是一个简单的类似井字风格的游戏，就像我们可能在纸上玩的那样。与其他任何事情一样，有多种方法可以制作这个游戏。我们将使用Unity的uGUI系统，以便更好地了解如何为我们的其他游戏创建一个图形用户界面。
- en: The game board
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏板
- en: 'The basic Tic-tac-toe game involves two players and a 3 x 3 grid. The players
    take turns filling squares with Xs and Os. The player who first fills a line of
    three squares with his or her letter wins the game. If all squares are filled
    without a player achieving a line of three, the game is a tie. Let''s start with
    the following steps to create our game board:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的井字游戏涉及两名玩家和一个3x3的网格。玩家轮流用X和O填充方格。第一个用字母填满一行三个方格的玩家赢得游戏。如果所有方格被填满，但没有玩家达到三个连成一行的方格，则游戏平局。让我们从以下步骤开始创建我们的游戏板：
- en: The first thing to do is to create a project for this chapter. So, start up
    Unity and we will do just that.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为本章创建一个项目。因此，启动Unity，我们将执行这一操作。
- en: 'If you have been following along so far, Unity should boot up into the last
    project that was open. This isn''t a bad feature, but it can become extremely
    annoying. Think of it like this: you have been working on a project for a while
    and it has grown large. Now you need to quickly open something else, but Unity
    defaults to your huge project. If you wait for it to open before you can work
    on anything else, it can consume a lot of time.'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你一直按照至今的步骤操作，Unity应该会启动到最后打开的项目。这并不是一个糟糕的特性，但它可能变得非常烦人。想象一下：你一直在一个项目上工作了一段时间，它已经变得很大。现在你需要快速打开别的东西，但Unity默认会打开你的大型项目。如果你在它能打开之前等待，那么可能会消耗很多时间。
- en: 'To change this feature, go to the top of the Unity window and click on **Edit**,
    followed by **Preferences**. This is the same place where we changed our script
    editor''s preferences. This time, though, we are going to change settings in the
    **General** tab. The following screenshot shows the options that are present under
    the **General** tab:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要更改此功能，请转到Unity窗口顶部，点击**编辑**，然后点击**偏好设置**。这是我们更改脚本编辑器偏好的同一个地方。不过，这次我们将更改**常规**标签下的设置。以下屏幕截图显示了**常规**标签下存在的选项：
- en: '![The game board](img/4691OT_02_01.jpg)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![游戏板](img/4691OT_02_01.jpg)'
- en: 'At this moment, our primary concern is the **Load Previous Project on Startup**
    option; however, we will still cover all the options in turn. All the options
    under the **General** tab are explained in detail as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个时候，我们主要关注的是**启动时加载上一个项目**的选项；不过，我们仍将按顺序介绍所有选项。以下是**常规**标签下的所有选项的详细解释：
- en: '**Auto Refresh**: This is one of the best features of Unity. Because an asset
    is changed outside of Unity, this option lets Unity automatically detect the change
    and refresh the asset inside your project.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动刷新**：这是Unity最好的功能之一。因为资产是在Unity外部更改的，这个选项允许Unity自动检测更改并刷新你项目中的资产。'
- en: '**Load Previous Project on Startup**: This is a great option, and you should
    make sure that this is unchecked whenever installing Unity. When checked, Unity
    will immediately open the last project you worked on rather than **Project Wizard**.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时加载上一个项目**：这是一个很棒的功能，你应该确保在安装Unity时始终不勾选这个选项。勾选后，Unity将直接打开你最后工作的项目，而不是**项目向导**。'
- en: '**Compress Assets on Import**: This is the checkbox for automatically compressing
    your game assets when they are first imported into Unity.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入时压缩资源**：这是用于在资源首次导入Unity时自动压缩你的游戏资源的复选框。'
- en: '**Editor Analytics**: This checkbox is for Unity''s anonymous usage statistics.
    Leave it checked and the Unity Editor will send information occasionally to the
    Unity source. It doesn''t hurt anything to leave it on and helps the Unity team
    to make the Unity Editor better; however, it comes down to personal preference.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器分析**：这个复选框是用于Unity的匿名使用统计。保持勾选状态，Unity编辑器将偶尔向Unity源发送信息。让它开启不会造成任何伤害，并且有助于Unity团队改进Unity编辑器；然而，这也取决于个人偏好。'
- en: '**Show Asset Store search hits**: This setting is only relevant if you plan
    to use **Asset Store**. The asset store can be a great source of assets and tools
    for any game; however, since we are not going to use it, its relevance to this
    book is rather limited. It does what the name suggests. When you search the asset
    store for something within the Unity Editor, the number of results is displayed
    based on this checkbox.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示资源商店搜索结果**：只有当你计划使用**资源商店**时，这个设置才是相关的。资源商店可以是任何游戏资产和工具的绝佳来源；然而，由于我们不打算使用它，它与本书的相关性相当有限。它正如其名所示，当你在Unity编辑器中搜索资源商店中的内容时，根据这个复选框的设置，会显示搜索结果的数量。'
- en: '**Verify Saving Assets**: This is a good one to leave unchecked. If this is
    on, every time you click on **Save** in Unity, a dialog box will pop up so that
    you can make sure to save any and all of the assets that have changed since your
    last save. This option is not so much about your models and textures, but is concerned
    with Unity''s internal files, materials, and prefabs. It''s best to leave it off
    for now.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证保存资源**：这是一个好选项，可以保持不勾选。如果勾选了这个选项，每次你在Unity中点击**保存**时，都会弹出一个对话框，以便你可以确保保存自上次保存以来所有已更改的资产。这个选项与你模型和纹理无关，而是关注Unity的内部文件、材质和预制体。现在最好是关闭它。'
- en: '**Skin (Pro Only)**: This option only applies to Unity Pro users. It gives
    the option to switch between the light and dark versions of the Unity Editor.
    It is purely cosmetic, so go with your gut for this one.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**皮肤（仅限专业版）**：这个选项仅适用于Unity Pro用户。它提供了在Unity编辑器的浅色和深色版本之间切换的选项。这纯粹是外观上的，所以你可以根据自己的感觉选择。'
- en: With your preferences set, now go to **File** and then select **New Project**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好你的偏好设置后，现在转到**文件**，然后选择**新建项目**。
- en: Click on the **Browse...** button to pick a location and name for the new project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览...**按钮来选择新项目的位置和名称。
- en: We will not be using any of the included packages, so click on **Create** and
    we can get on with it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会使用任何包含的包，所以点击**创建**，我们可以继续进行。
- en: By changing a few simple options, we can save ourselves a lot of trouble later.
    This may not seem like that big of a deal now for simple projects from this book,
    but for large and complex projects, not choosing the correct options can cause
    a lot of hassle for you even if you just want to make a quick switch between projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改一些简单的设置，我们可以避免以后很多麻烦。对于本书中的简单项目来说，这看起来可能不是什么大问题，但对于大型复杂项目，如果你没有选择正确的设置，即使你只是想在项目之间快速切换，也可能会给你带来很多麻烦。
- en: Creating the board
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建棋盘
- en: 'With the new project created, we have a clean slate to create our game. Before
    we can create the core functionality, we need to set up some structure in our
    scene for our game to work and our players to interact with:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目创建后，我们就有了一个干净的起点来创建我们的游戏。在我们能够创建核心功能之前，我们需要在场景中设置一些结构，以便游戏能够运行，玩家能够与之互动：
- en: Once Unity finishes initializing the new project, we need to create a new **canvas**.
    We can do this by navigating to **GameObject** | **UI** | **Canvas**. The whole
    of Unity's uGUI system requires a canvas in order to draw anything on the screen.
    It has a few key components, as you can see in the following **Inspector** window,
    which allow it and everything else in your interface to work:![Creating the board](img/4691OT_02_08.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Unity 初始化新项目完成后，我们需要创建一个新的**画布**。我们可以通过导航到**GameObject** | **UI** | **Canvas**来实现这一点。整个
    Unity 的 uGUI 系统需要画布才能在屏幕上绘制任何内容。它有几个关键组件，如接下来的**检查器**窗口所示，这些组件使得它和界面中的其他所有内容都能正常工作：![创建面板](img/4691OT_02_08.jpg)
- en: '**Rect Transform**: This is a special type of the normal transform component
    that you will find on nearly every other object you will use in your games. It
    keeps track of the object''s position on screen, its size, its rotation, the pivot
    point around which it will rotate, and how it will behave when the screen size
    changes. By default, the Rect Transform for a canvas is locked to include the
    whole screen''s size.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩形变换**: 这是你几乎在你将要在游戏中使用的每个其他对象上找到的普通变换组件的特殊类型。它跟踪对象在屏幕上的位置、大小、旋转、围绕其旋转的轴心点以及屏幕大小变化时的行为方式。默认情况下，画布的矩形变换被锁定以包括整个屏幕的大小。'
- en: '**Canvas**: This component controls how it and the interface elements it controls
    interact with the camera and your scene. You can change this by adjusting **Render
    Mode**. The default mode, **Screen Space – Overlay**, means that everything will
    be drawn on screen and over the top of everything else in the scene. The **Screen
    Space – Camera** mode will draw everything a specific distance away from the camera.
    This allows your interface to be affected by the perspective nature of the camera,
    but any models that might be closer to the camera will appear in front of it.
    The **World Space** mode ensures that the canvas and elements it controls are
    drawn in the world just like any of the models in your scene.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布**: 这个组件控制它及其所控制的界面元素与相机和场景的交互方式。你可以通过调整**渲染模式**来改变这一点。默认模式是**屏幕空间 - 覆盖**，这意味着所有内容都将在屏幕上绘制，并覆盖场景中的其他所有内容。**屏幕空间
    - 相机**模式将在特定距离处从相机绘制所有内容。这使得你的界面受到相机透视性质的影响，但任何可能更靠近相机的模型将出现在它的前面。**世界空间**模式确保画布及其控制的元素像场景中的任何模型一样在世界中绘制。'
- en: '**Graphics Raycaster**: This is the component that lets you actually interact
    with and click on your various interface elements.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形光线投射器**: 这是让你实际上可以与各种界面元素交互和点击的组件。'
- en: When you added the canvas, an extra object called **EventSystem** was also created.
    This is what allows our buttons and other interface elements to interact with
    our scripts. If you ever accidentally delete it, you can recreate it by going
    to the top of Unity and navigating to **GameObject** | **UI** | **EventSystem**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加画布时，还会创建一个名为**EventSystem**的额外对象。这就是允许我们的按钮和其他界面元素与脚本交互的东西。如果你不小心删除了它，可以通过转到
    Unity 顶部并导航到**GameObject** | **UI** | **EventSystem**来重新创建它。
- en: Next, we need to adjust the way the Unity Editor will display our game so that
    we can easily make our game board. To do this, switch to the **Game** view by
    clicking on its tab at the top of the **Scene** view.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整 Unity 编辑器显示我们游戏的方式，这样我们就可以轻松制作游戏面板。为此，点击**场景**视图顶部的**游戏**视图标签，切换到**游戏**视图。
- en: 'Then, click on the button that says **Free Aspect** and select the option near
    the bottom: **3 : 2 Landscape (3 : 2)**. Most of the mobile devices your games
    will be played on will use a screen that approximates this ratio. The rest will
    not see any distortion in your game.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击写着**自由宽高比**的按钮，并选择靠近底部的选项：**3:2横向 (3:2)**。你游戏将在大多数使用近似此比例屏幕的移动设备上播放。其余的设备在游戏中不会看到任何失真。
- en: To allow our game to adjust to the various resolutions, we need to add a new
    component to our canvas object. With it selected in the **Hierarchy** panel, click
    on **Add Component** in the **Inspector** panel and navigate to **Layout** | **Canvas
    Scaler**. The selected component allows us to work from a base screen resolution,
    letting it automatically scale our GUI as the devices change.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们的游戏能够适应各种分辨率，我们需要为画布对象添加一个新组件。在**层次结构**面板中选择它，然后在**检查器**面板中点击**添加组件**，并导航到**布局**
    | **画布缩放器**。所选组件允许我们从基本屏幕分辨率开始工作，使其在设备更改时自动缩放我们的 GUI。
- en: To select a base resolution, select **Scale With Screen Size** from the **Ui
    Scale Mode** drop-down list.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择基本分辨率，请从**UI缩放模式**下拉列表中选择**随屏幕大小缩放**。
- en: Next, let's put `960` for **X** and `640` for **Y**. It is better to work from
    a larger resolution than a smaller one. If your resolution is too small, all your
    GUI elements will look fuzzy when they are scaled up for high-resolution devices.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将**X**设置为`960`，**Y**设置为`640`。从较大分辨率开始工作比从较小分辨率要好。如果你的分辨率太小，当它们在高分辨率设备上放大时，所有的GUI元素都会显得模糊。
- en: To keep things organized, we need to create three empty GameObjects. Go back
    to the top of Unity and select **Create Empty** three times under **GameObject**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持组织性，我们需要创建三个空的GameObject。回到Unity顶部，在**GameObject**下选择**创建空对象**三次。
- en: In the **Hierarchy** tab, click and drag them to our canvas to make them the
    canvas's children.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**标签中，点击并拖动它们到我们的画布上，使它们成为画布的子对象。
- en: To make each of them usable for organizing our GUI elements, we need to add
    the Rect Transform component. Find it by navigating to **Add Component** | **Layout**
    | **Rect Transform** in **Inspector** for each.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使它们每个都能用于组织我们的GUI元素，我们需要添加Rect Transform组件。在**检查器**中，通过导航到**添加组件** | **布局**
    | **Rect Transform**来找到它。
- en: To rename them, click on their name at the top of the **Inspector** and type
    in a new name. Name one `Board`, another `Buttons`, and the last one `Squares`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名它们，请点击**检查器**顶部它们的名称，并输入新名称。将一个命名为`Board`，另一个`Buttons`，最后一个`Squares`。
- en: Next, make `Buttons` and `Squares` children of `Board`. The `Buttons` element
    will hold all the pieces of our game board that are clickable while `Squares`
    will hold the squares that have already been selected.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使`Buttons`和`Squares`成为`Board`的子对象。`Buttons`元素将持有我们游戏板上所有可点击的片段，而`Squares`将持有已经被选中的格子。
- en: To keep the `Board` element at the same place as the devices change, we need
    to change the way it anchors to its parent. Click on the box with a red cross
    and a yellow dot in the center at the top right of **Rect Transform** to expand
    the **Anchor Presets** menu:![Creating the board](img/4691OT_02_02.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持`Board`元素在设备更改时位置不变，我们需要改变它相对于父元素的锚定方式。点击位于**Rect Transform**右上角的带红色交叉和黄色圆点的方框，展开**锚点预设**菜单：![创建板块](img/4691OT_02_02.jpg)
- en: Each of these options affects which corner of the parent the element will stick
    to as the screen changes size. We want to select the bottom-right option with
    four arrows, one in each direction. This will make it stretch with the parent
    element.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些选项中的每一个都会影响元素在屏幕尺寸变化时粘附到父元素的哪个角落。我们选择带有四个箭头、每个方向一个的右下角选项。这将使它与父元素一起拉伸。
- en: Make the same change to `Buttons` and `Squares`, as well.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Buttons`和`Squares`也进行同样的更改。
- en: Set **Left**, **Top**, **Right**, and **Bottom** of each of these objects to
    `0`. Also, make sure that **Rotation** is set to `0` and **Scale** is set to `1`.
    Otherwise, our interface may be scaled oddly when we work or play on it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些对象的**左**、**上**、**右**和**下**都设置为`0`。同时确保**旋转**设置为`0`，**缩放**设置为`1`。否则，在我们工作或玩游戏时，界面可能会被奇怪地缩放。
- en: Next, we need to change the anchor point of the board. If **Anchor** is not
    expanded, click on the little triangle on the left-hand side to expand it. Either
    way, the **Max X** value needs to be set to `0.667` so that our board will be
    a square and cover the left two-thirds of our screen.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要改变板块的锚点。如果**锚点**没有展开，点击左侧的小三角形来展开它。无论如何，需要将**Max X**值设置为`0.667`，这样我们的板块将是一个正方形，覆盖屏幕左边的三分之二。
- en: This game board is the base around which the rest of our project will be created.
    Without it, the game won't be playable. The game squares use it to draw themselves
    on screen and anchor themselves to relevant places. Later, when we create menus,
    is needed to make sure that a player only sees what we need he or she to be interacting
    with at that moment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏板块是我们项目其余部分的基础。没有它，游戏就无法玩。游戏格子使用它来在屏幕上绘制自己，并锚定到相关位置。稍后，当我们创建菜单时，需要确保玩家只看到我们需要他们与之互动的内容。
- en: Game squares
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏格子
- en: 'Now that we have our base game board in place, we need the actual game squares.
    Without them, it is going to be kind of hard to play the game. We need to create
    nine buttons for the player to click on, nine images for the background of the
    selected squares, and nine texts to display which person controls the squares.
    To create and set them up, perform these steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了基础的游戏板块，接下来就需要实际的游戏格子了。没有它们，游戏玩起来就会有些困难。我们需要为玩家创建九个可点击的按钮，九个被选中格子的背景图片，以及九个显示控制格子人员的文本。为了创建并设置它们，请执行以下步骤：
- en: Navigate to **Game Object** | **UI** just like we did for the canvas, but this
    time select **Button**, **Image**, and **Text** to create everything we need.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们对画布所做的那样，导航到**游戏对象** | **UI**，但这次选择**按钮**、**图像**和**文本**来创建我们需要的一切。
- en: Each of the image objects needs one of the text objects as a child. Then, all
    the images must be children of the `Squares` object and the buttons must be children
    of the `Buttons` object.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个图像对象都需要一个文本对象作为子对象。然后，所有的图像必须是`Squares`对象的子对象，而按钮必须是`Buttons`对象的子对象。
- en: All the buttons and images need a number in their name so that we can keep them
    organized. Name the buttons `Button0` through `Button8` and the images `Square0`
    through `Square8`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的按钮和图片都需要在它们的名字中加入数字，以便我们可以将它们组织起来。将按钮命名为`Button0`至`Button8`，图片命名为`Square0`至`Square8`。
- en: The next step is to lay out our board so that we can keep things organized and
    in sync with our programming. We need to set each numbered set specifically. But
    first, pick the crossed arrows from the bottom-right corner of **Anchor Presets**
    for all of them and ensure that their **Left**, **Top**, **Right**, and **Bottom**
    values are set to `0`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是布置我们的游戏板，这样我们就可以将事情组织起来并与编程保持同步。我们需要具体设置每个编号的集合。但首先，从**锚点预设**的右下角选择交叉箭头，确保它们的**左**、**上**、**右**和**下**的值设置为`0`。
- en: 'To set each of our buttons and squares at the right place, just match the numbers
    to the following table. The result will be that all the squares will be in order,
    starting at the top left and ending at the bottom right:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将我们的按钮和方块放置在正确的位置，只需将数字与以下表格相匹配。这样做的结果就是所有的方块都会有序排列，从左上角开始，到右下角结束：
- en: '| Square | Min X | Min Y | Max X | Max Y |'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 方块 | 最小X | 最小Y | 最大X | 最大Y |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0.67 | 0.33 | 1 |'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 0.67 | 0.33 | 1 |'
- en: '| 1 | 0.33 | 0.67 | 0.67 | 1 |'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 1 | 0.33 | 0.67 | 0.67 | 1 |'
- en: '| 2 | 0.67 | 0.67 | 1 | 1 |'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 2 | 0.67 | 0.67 | 1 | 1 |'
- en: '| 3 | 0 | 0.33 | 0.33 | 0.67 |'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 3 | 0 | 0.33 | 0.33 | 0.67 |'
- en: '| 4 | 0.33 | 0.33 | 0.67 | 0.67 |'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 4 | 0.33 | 0.33 | 0.67 | 0.67 |'
- en: '| 5 | 0.67 | 0.33 | 1 | 0.67 |'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 5 | 0.67 | 0.33 | 1 | 0.67 |'
- en: '| 6 | 0 | 0 | 0.33 | 0.33 |'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 6 | 0 | 0 | 0.33 | 0.33 |'
- en: '| 7 | 0.33 | 0 | 0.67 | 0.33 |'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 7 | 0.33 | 0 | 0.67 | 0.33 |'
- en: '| 8 | 0.67 | 0 | 1 | 0.33 |'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 8 | 0.67 | 0 | 1 | 0.33 |'
- en: The last thing we need to add is an indicator to show whose turn it is. Create
    another **Text** object just like we did before and rename it `Turn Indicator`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一样东西是一个指示器，用来显示轮到谁了。像之前一样创建另一个**文本**对象，并将其重命名为`Turn Indicator`。
- en: After you make sure that the **Left**, **Top**, **Right**, and **Bottom** values
    are set to `0` again, set **Anchor Point Preset** to the blue arrows once more.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保再次将**左**、**上**、**右**和**下**的值设置为`0`之后，再次将**锚点预设**设置为蓝色箭头。
- en: Finally, set **Min X** under **Anchor** to `0.67`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**锚点**下的**最小X值**设置为`0.67`。
- en: We now have everything we need to play the basic game of Tic-tac-toe. To check
    it out, select the **Squares** object and uncheck the box in the top-right corner
    to turn it off. When you hit play now, you should be able to see your whole game
    board and click on the buttons. You can even use Unity Remote to test it with
    the touch settings. If you have not already done so, it would be a good idea to
    save the scene before continuing.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们拥有玩基本井字游戏所需的一切。要查看它，选择**Squares**对象并取消右上角的勾选框以关闭它。现在当你点击播放，你应该能够看到整个游戏板并点击按钮。你甚至可以使用Unity
    Remote来测试触摸设置。如果你还没有这样做，保存场景然后继续会是一个好主意。
- en: The game squares are the last piece to set up our initial game. It almost looks
    like a playable game now. We just need to add a few scripts and we will be able
    to play all the games of Tic-tac-toe we could ever desire.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏方块是我们设置初始游戏的最后一步。现在它看起来几乎像一个可玩的游戏了。我们只需要添加一些脚本，就能够玩到我们梦寐以求的所有井字游戏。
- en: Controlling the game
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制游戏
- en: 'Having a game board is one of the most important parts of creating any game.
    However, it doesn''t do us any good if we can''t control what happens when its
    various buttons are pressed. Let''s create some scripts and write some code to
    fix this now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个游戏板是创建任何游戏最重要的部分之一。然而，如果我们无法控制当其各个按钮被按下时发生的情况，那它对我们来说就没有任何好处。现在，让我们创建一些脚本并编写一些代码来解决这个问题：
- en: Create two new scripts in the **Project** panel, just as we did for the *Hello
    World* project in the previous chapter. Name the new scripts `TicTacToeControl`
    and `SquareState`. Open them and clear out the default functions, just as we did
    in [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中创建两个新的脚本，就像我们在上一章的*Hello World*项目中做的那样。将新脚本命名为`TicTacToeControl`和`SquareState`。打开它们并清除默认函数，就像我们在[第1章](ch01.html
    "第1章. 与Unity和Android打招呼")，*Saying Hello to Unity and Android*中所做的那样。
- en: 'The `SquareState` script will hold the possible states of each square of our
    game board. To do this, clear absolutely everything out of the script, including
    the `using UnityEngine` line and the `public class SquareState` line, so that
    we can replace them with a simple enumeration. An enumeration is just a list of
    potential values. This one is concerned with the player who controls the square.
    It will allow us to keep track of whether X is controlling it, O is controlling
    it, or if it is clear. The `Clear` statement becomes the first and therefore,
    the default state:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SquareState`脚本将保存我们游戏板每个方块的可能状态。为此，请清除脚本中的所有内容，包括`using UnityEngine`行和`public
    class SquareState`行，这样我们可以用一个简单的枚举来替换它们。枚举只是一个潜在值的列表。这个枚举关注的是控制方块的是哪个玩家。它将允许我们跟踪是X控制它，O控制它，还是它是空的。`Clear`语句成为第一个，因此也就是默认状态：'
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our other script, `TicTacToeControl`, we need to start by adding an extra
    line at the very beginning, right under `using UnityEngine`. This line lets our
    code interact with the various GUI elements, and most importantly, with this game,
    allowing us to change the text of who controls a square and whose turn it is:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的另一个脚本`TicTacToeControl`中，首先需要在最开始的`using UnityEngine`下面添加一行，这行代码让我们的代码能够与各种GUI元素交互，最重要的是，它能与这个游戏交互，允许我们更改控制方块的人和轮到谁的信息：
- en: '[PRE1]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need two variables that will largely control the flow of the game.
    They need to be added in place of the two default functions. The first defines
    our game board. It is an array of nine squares to keep track of who owns what.
    The second keeps track of whose turn it is. When the Boolean is `true`, the X
    player gets a turn. When the Boolean is `false`, the O player gets a turn:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要两个变量，它们将主要控制游戏的流程。它们需要替代两个默认函数。第一个定义了我们的游戏板，这是一个由九个方块组成的数组，用于跟踪谁拥有哪个方块。第二个变量用于记录轮到谁了。当布尔值为`true`时，X玩家将进行操作。当布尔值为`false`时，O玩家将进行操作：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next variable will let us change the text on screen for whose turn it is:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量将让我们更改屏幕上显示的轮到谁的信息：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These three variables will give us access to all the GUI objects we set up
    in the last section, allowing us to change the image and text based on who owns
    the square. We can also turn the buttons and squares on and off as they are clicked.
    All of them are marked with **Landscape** so that we will be able to keep them
    straight later, when we have a second board for the **Portrait** orientation of
    devices:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这三个变量将让我们访问到最后一个部分设置的所有GUI对象，允许我们根据谁拥有方块来更改图片和文本。我们还可以在点击时打开或关闭按钮和方块。它们都被标记为**Landscape**，这样当我们在设备**Portrait**方向上有第二个板块时，我们能够区分它们：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last two variables, for now, will give us access to the images we need
    to change the backgrounds of:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个变量，目前将让我们访问到需要更改背景的图片：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our first function for this script will be called every time a button is clicked.
    It receives the number of buttons clicked, and the first thing it does is turn
    the button off and the square on:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为此脚本编写的第一个函数将在每次点击按钮时被调用。它接收被点击按钮的数量，并且首先关闭按钮并激活方块：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, the function checks the Boolean we created earlier to see whose turn
    it is. If it is the X player''s turn, the square is set to use the appropriate
    image and text, indicating that their control is set. It then marks on the script''s
    internal board that controls the square before finally switching to the O player''s
    turn:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，函数会检查我们之前创建的布尔值，以确定轮到谁了。如果是X玩家的回合，方块将设置为使用适当的图片和文本，表明他们的控制权已设定。然后它在脚本内部的游戏板上标记控制方块，最后切换到O玩家的回合：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This next block of code does the same thing as the previous one, except it
    marks control for the O player and changes the turn to the X player:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个代码块与上一个相同，不过它标记了O玩家的控制权，并将轮次改为X玩家：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is it for the code right now. Next, we need to return to the Unity Editor
    and set up our new script in the scene. You can do this by creating another empty
    GameObject and renaming it `GameControl`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前代码就这些。接下来，我们需要返回Unity编辑器，在场景中设置我们的新脚本。你可以通过创建另一个空的游戏对象并重命名为`GameControl`来实现这一点。
- en: Add our `TicTacToeControl` script to it by dragging the script from the **Project**
    panel and dropping it in the **Inspector** panel when the object is selected.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**项目**面板中拖动`TicTacToeControl`脚本，并在选择对象时将其拖放到**检查器**面板中，将脚本添加到对象上。
- en: We now need to attach all the object references our script needs in order to
    actually work. We don't need to touch the **Board** or **XTurn** slots in the
    **Inspector** panel, but the **Turn Indicator** object does need to be dragged
    from the **Hierarchy** tab to the **Turn Indicator Landscape** slot in the **Inspector**
    panel.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要附上脚本实际工作所需的所有对象引用。我们不需要在**检查器**面板中触碰**棋盘**或**XTurn**槽，但需要将**Turn Indicator**对象从**层次结构**标签拖到**检查器**面板中的**Turn
    Indicator Landscape**槽。
- en: Next, expand the **Buttons Landscape**, **Squares Landscape**, and **Square
    Texts Landscape** settings and set each **Size** slot to `9`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，展开**Buttons Landscape**、**Squares Landscape**和**Square Texts Landscape**设置，并将每个**大小**槽设置为`9`。
- en: To each of the new slots, we need to drag the relevant object from the **Hierarchy**
    tab. The **Element 0** object under **Buttons Landscape** gets **Button0**, **Element
    1** gets **Button1**, and so on. Do this for all the buttons, images, and texts.
    Ensure that you put them in the right order or else our script will appear confusing
    as it changes things when the player is playing.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个新槽，我们需要从**层次结构**标签中拖动相关的对象。**Buttons Landscape**下的**Element 0**对象获得**Button0**，**Element
    1**获得**Button1**，依此类推。对所有按钮、图像和文本执行此操作。确保你将它们按正确的顺序排列，否则当玩家进行游戏时，我们的脚本会看起来很混乱，因为它会改变事物。
- en: Next, we need a few images. If you have not already done so, import the starting
    assets for this chapter by going to the top of Unity, by navigating to **Assets**
    | **Import New Asset**, and selecting the files to import them. You will need
    to navigate to and select each one at a time. We have **Onormal** and **Xnormal**
    for indicating control of the square. The **ButtonNormal** image is used when
    the button is just sitting there and **ButtonActive** is used when the player
    touches the button. The **Title** field is going to be used for our main menu
    a little bit later.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些图像。如果你还没有这样做，通过导航到Unity顶部，选择**资产** | **导入新资产**，并选择要导入的文件，导入本章的起始资产。你需要逐个导航到并选择它们。我们有**Onormal**和**Xnormal**用来指示方块的控制器。当按钮只是闲置在那里时，使用**ButtonNormal**图像，当玩家触摸按钮时，使用**ButtonActive**。稍后，**标题**字段将用于我们的主菜单。
- en: In order to use any of these images in our game, we need to change their import
    settings. Select each of them in turn and find the **Texture Type** dropdown in
    the **Inspector** panel. We need to change them from **Texture** to **Sprite (2D
    \ uGUI)**. We can leave the rest of the settings at their defaults. The **Sprite
    Mode** option is used if we have a sprite sheet with multiple elements in one
    image. The **Packing Tag** option is used for grouping and finding sprites in
    the sheet. The **Pixels To Units** option affects the size of the sprite when
    it is rendered in world space. The **Pivot** option simply changes the point around
    which the image will rotate.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在我们的游戏中使用这些图像，我们需要更改它们的导入设置。逐一选择它们，并在**检查器**面板中找到**纹理类型**下拉菜单。我们需要将它们从**纹理**更改为**精灵(2D
    \ uGUI)**。其余设置可以保持默认。如果我们的精灵表包含单个图像中的多个元素，可以使用**精灵模式**选项。**打包标签**选项用于在表中分组和查找精灵。**像素到单位**选项影响精灵在世界空间中渲染时的大小。**轴心点**选项简单更改图像将旋转的点。
- en: For the four square images, we can click on **Sprite Editor** to change how
    the border appears when they are rendered. When clicked, a new window opens that
    shows our image with some green lines at the edges and some information about
    it in the lower-right. We can drag these green lines to change the **Border**
    property. Anything outside the green lines will not be stretched with the image
    as it fills spaces that are larger than it. A setting around `13` for each side
    will keep our whole border from stretching.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于四个方形图像，我们可以点击**精灵编辑器**来更改它们渲染时边框的外观。点击后，会打开一个新窗口，显示我们的图像边缘有一些绿线及其在右下角的一些信息。我们可以拖动这些绿线来更改**边框**属性。绿线外的任何内容都不会随着图像填充比它大的空间而拉伸。每边大约`13`的设置将防止我们的整个边框拉伸。
- en: Once you make any changes, ensure that you hit the **Apply** button to commit
    them.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你做了任何更改，请确保点击**应用**按钮来提交它们。
- en: Next, select the **GameControl** object once more and drag the **ONormal** image
    to the **OImage** slot and the **XNormal** image to the **XImage** slot.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**游戏控制**对象，并将**ONormal**图像拖到**OImage**槽，将**XNormal**图像拖到**XImage**槽。
- en: Each of the buttons need to be connected to the script. To do this, select each
    of them from **Hierarchy** in turn and click on the plus sign at the bottom-right
    corner of their **Inspector**:![Controlling the game](img/4691OT_02_03.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个按钮都需要连接到脚本。为此，依次从**层次结构**中选择它们，并点击它们**检查器**右下角的加号：![控制游戏](img/4691OT_02_03.jpg)
- en: We then need to click on that little circle to the left of **No Function** and
    select **GameControl** from the list in the new window.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要点击**无功能**左侧的小圆圈，并在新窗口中的列表中选择**游戏控制**。
- en: Now, navigate to **No Function** | **TicTacToeControl** | **ButtonClick (int)**
    to connect the function in our code to the button.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到**无功能** | **井字游戏控制** | **按钮点击（int）**，将我们的代码中的函数连接到按钮。
- en: Finally, for each of the buttons, put the number of the button in the number
    slot to the right of the function list.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于每个按钮，将按钮的编号放入函数列表右侧的编号槽中。
- en: To keep everything organized, rename your **Canvas** object `GameBoard_Landscape`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持组织性，将你的**画布**对象重命名为`GameBoard_Landscape`。
- en: Before we can test it out, be sure that the `Squares` object is turned on by
    checking the box in the top-left corner of its **Inspector**. Also, uncheck the
    box of each of its image children.![Controlling the game](img/4691OT_02_04.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们测试之前，请确保通过勾选**检查器**左上角的框来打开**方块**对象。同时，取消选中其每个图像子对象的框。![控制游戏](img/4691OT_02_04.jpg)
- en: This may not look like the best game in the world, but it is playable. We have
    buttons that call functions in our scripts. The turn indicator changes as we play.
    Also, each square indicates who controls it after they are selected. With a little
    more work, this game could look and work great.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是世界上最好的游戏，但它是可玩的。我们有一些按钮可以调用脚本中的函数。随着游戏的进行，转向指示会发生变化。此外，每个方块在被选中后会显示谁控制它。再做一些工作，这个游戏就能看起来很棒，也能玩得很好。
- en: Messing with fonts
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整字体
- en: 'Now that we have a basic working game, we need to make it look a little better.
    We are going to add our button images and pick some new font sizes and colors
    to make everything more readable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基本可玩的游戏，我们需要让它看起来更好一些。我们将添加按钮图片，并选择一些新的字体大小和颜色，使所有内容更具可读性：
- en: 'Let''s start with the buttons. Select one of the Button elements and you will
    see in the **Inspector** that it is made of an **Image (Script)** component and
    a **Button (Script)** component. The first component controls how the GUI element
    will appear when it just sits there. The second controls how it changes when a
    player interacts with it and what bit of functionality this triggers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从按钮开始。选择一个按钮元素，你会在**检查器**中看到它由一个**图像（脚本）**组件和一个**按钮（脚本）**组件组成。第一个组件控制当GUI元素静止时它的外观。第二个组件控制当玩家与之互动时它的变化以及这会触发哪些功能：
- en: '**Source Image**: This is the base image that is displayed when the element
    just sits there and is untouched by the player.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源图像**：这是当元素静止未被玩家触碰时显示的基础图像。'
- en: '**Color**: This controls the tinting and fading of the image that is being
    used.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：这控制着正在使用的图像的着色和淡化。'
- en: '**Material**: This lets you use a texture or shader that might otherwise be
    used on 3D models.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质**：这允许你使用可能在3D模型上使用的纹理或着色器。'
- en: '**Image Type**: This determines how the image will be stretched to fill the
    available space. Usually, it will be set to **Sliced**, which is for images that
    use a border and can be optionally filled with a color based on the **Fill Center**
    checkbox. Otherwise, it will often be set to **Simple**, for example, when you
    are using a normal image and can prevent the **Preserve Aspect** box from being
    stretched by odd sized Rect Transforms.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像类型**：这决定了图像如何被拉伸以填充可用空间。通常，它会设置为**切片**，这是用于使用边框的图像，可以选择根据**填充中心**复选框用颜色填充。否则，它通常会设置为**简单**，例如，当你使用普通图像时，可以防止**保持宽高比**的框被奇数大小的矩形变换拉伸。'
- en: '**Interactable**: This simply toggles whether or not the player is able to
    click on the button and trigger functionality.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可交互**：这简单地切换玩家是否能够点击按钮并触发功能。'
- en: '**Transition**: This changes how the button will react as the player interacts
    with it. **ColorTint** causes the button to change color as it is interacted with.
    **SpriteSwap** will change the image when it is interacted with. **Animation**
    will let you define more complex animation sequences for the transitions between
    states.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡**：这改变了当玩家与按钮交互时按钮的反应方式。**颜色色调**会使按钮在交互时改变颜色。**SpriteSwap**会在交互时改变图像。**动画**将允许你为状态之间的过渡定义更复杂的动画序列。'
- en: The **Target Graphic** is a reference to the base image used for drawing the
    button on screen.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标图形**是用于在屏幕上绘制按钮的基础图像的引用。'
- en: The **Normal** slot, **Highlighted** slot, **Pressed** slot, and **Disabled**
    slot define the effects or images to use when the button is not being interacted
    with or is moused over, or the player clicks on it and the button has been turned
    off.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**槽、**高亮**槽、**按下**槽和**禁用**槽定义了当按钮未被交互或被鼠标悬停，或者玩家点击按钮并且按钮已被关闭时使用的效果或图像。'
- en: For each of our buttons, we need to drag our **ButtonNormal** image from our
    **Project** panel to the **Source Image** slot.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的每个按钮，我们需要从**项目**面板将**ButtonNormal**图像拖到**源图像**槽中。
- en: Next, click on the white box to the right of the **Color** slot to open the
    color picker. To stop our buttons from being faded, we need to move the **A**
    slider all the way to the right or set the box to `255`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**颜色**槽右侧的白框以打开颜色选择器。为了防止我们的按钮变暗，我们需要将**A**滑块移到最右边或把盒子设置为`255`。
- en: We want to change images when our buttons are pressed, so change the **Transition**
    to **SpriteSwap**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望当按钮被按下时改变图像，因此将**过渡**改为**SpriteSwap**。
- en: Mobile devices have almost no way of hovering over GUI elements, so we do not
    need to worry about the **Highlighted** state. However, we do want to add our
    **ButtonActive** image to the **Pressed Sprite** slot so that it will switch when
    the player touches the button.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动设备几乎无法悬停在GUI元素上，因此我们不需要担心**高亮**状态。然而，我们确实想要将我们的**ButtonActive**图像添加到**Pressed
    Sprite**槽中，这样当玩家触摸按钮时，它就会切换。
- en: The button squares should be blank until someone clicks on them, so we need
    to get rid of the text element. The easiest way to do this is to select each one
    under the button and delete it.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮方块在有人点击之前应该是空的，因此我们需要删除文本元素。最简单的方法是选择每个按钮下的元素并删除它。
- en: Next, we need to change the **Text** child of each of the image elements. It
    is the **Text (Script)** component that allows us to control how text is drawn
    on screen.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要改变每个图像元素的**文本**子项。是**文本（脚本）**组件允许我们控制文本如何在屏幕上绘制。
- en: '**Text**: This is the area where we can change text that will be drawn on screen.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：这是我们能够更改将在屏幕上绘制的文本的区域。'
- en: '**Font**: This allows us to pick any font file that is in our project to use
    for the text.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体**：这允许我们选择项目中任何字体文件用于文本。'
- en: '**Font Style**: This will let you adjust the bold and italic nature of the
    text.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体样式**：这将允许你调整文本的粗体和斜体特性。'
- en: '**Font Size**: This is the size of the text. This is just like picking a font
    size in your favorite word processor.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体大小**：这是文本的大小。这就像在你喜欢的文字处理软件中选择字体大小一样。'
- en: '**Line Spacing**: This is the distance between each line of text.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行间距**：这是每行文本之间的距离。'
- en: '**Rich Text**: This will let you use a few special HTML style tags to affect
    only part of the text with a color, italics, and so on.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**富文本**：这将允许你使用一些特殊的HTML样式标签，仅对部分文本应用颜色、斜体等效果。'
- en: '**Alignment**: This changes the location where the text will be centered in
    the box. The first three boxes adjust the horizontal position. The second three
    change the vertical position.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐方式**：这会改变文本在框中居中的位置。前三个框调整水平位置。后三个框改变垂直位置。'
- en: '**Horizontal Overflow / Vertical Overflow**: These adjust whether the text
    can be drawn outside the box, wrapped to a new line, or clipped off.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平溢出/垂直溢出**：这些调整文本是否可以绘制在框外，换行还是裁剪。'
- en: '**Best Fit**: This will automatically adjust the size of the text to fit a
    dynamically size-changing element, within a **Min** and **Max** value.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳适应**：这将自动调整文本的大小，以适应动态大小变化的元素，在**最小**和**最大**值之间。'
- en: '**Color/Material**: These change the color and texture of the text as and when
    it is drawn.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色/材质**：这些会改变文本在绘制时的颜色和纹理。'
- en: '**Shadow (Script)**: This component adds a drop shadow to the text, just like
    what you might add in Photoshop.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影（脚本）**：这个组件为文本添加了一个阴影效果，就像你在Photoshop中添加的那样。'
- en: For each of our text elements, we need to use a **Font Size** of `120` and the
    **Alignment** should be centered.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的每个文本元素，我们需要使用`120`的**Font Size**，并且**Alignment**应该居中。
- en: For the **Turn Indicator** text element, we also need to use a **Font Size**
    of `120` and it also needs to be centered.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Turn Indicator**文本元素，我们还需要使用`120`的**Font Size**，并且需要将其居中。
- en: The last thing to do is to change the **Color** of the text elements to a dark
    gray so that we can easily see it against the color of our buttons:![Messing with
    fonts](img/4691OT_02_07.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要做的最后一件事是更改文本元素的颜色为深灰色，这样我们就可以轻松地将其与我们按钮的颜色区分开来：![调整字体](img/4691OT_02_07.jpg)
- en: Now, our board works and looks good, too. Try taking a stab at adding your own
    images for the buttons. You will need two images, one for when the button sits
    there and one for when the button is pressed. Also, the default Arial font is
    boring. Find a new font to use for your game; you can import it just like any
    other game asset.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的游戏板运作良好，看起来也很棒。尝试为按钮添加自己的图片。你需要两张图片，一张是按钮静止时的，另一张是按钮被按下时的。此外，默认的Arial字体很乏味。为你的游戏找一个新字体；你可以像导入其他游戏资源一样导入它。
- en: Rotating devices
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转设备
- en: 'If you have been testing your game so far, you have probably noticed that the
    game only looks good when we hold the device in the landscape mode. When it is
    held in the portrait mode, everything becomes squished as the squares and turn
    indicator try to share the little amount of horizontal space that is available.
    As we have already set up our game board in one layout mode, it becomes a fairly
    simple matter to duplicate it for the other mode. However, it does require duplicating
    a good portion of our code to make it all work properly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你到目前为止一直在测试你的游戏，你可能已经注意到，当我们横持设备时，游戏看起来才好看。当设备竖持时，由于正方形和回合指示器试图共享可用的少量水平空间，所有内容都会变得拥挤。由于我们已经为一种布局模式设置好了游戏板，因此为另一种模式复制它就变得相当简单了。然而，这确实需要复制我们的大部分代码，才能使其正常工作：
- en: To make a copy of our game board, right-click on it and select **Duplicate**
    from the new menu. Rename the duplicate game board `GameBoard_Portrait`. This
    will be the board used when our player's device is in the portrait mode. To see
    our changes while we are making them, turn off the landscape game board and select
    **3:2 Portrait (2:3)** from the drop-down list at the top left of the **Game**
    window.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要复制我们的游戏板，右键点击它并从新菜单中选择**Duplicate**（复制）。将复制的游戏板重命名为`GameBoard_Portrait`。这将是在玩家设备处于竖屏模式时使用的游戏板。为了在制作更改时查看更改，请关闭横屏游戏板，并从**Game**窗口左上角的下拉列表中选择**3:2
    Portrait (2:3)**。
- en: Select the **Board** object that is a child of **GameBoard_Portrait**. In its
    **Inspector** panel, we need to change the anchors to use the top two-thirds of
    the screen rather than the left two-thirds. The values of `0` for **Min X**, `0.33`
    for **Min Y**, and `1` for both **Max X** and **Max Y** will make this happen.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**GameBoard_Portrait**下的**Board**对象。在其**Inspector**面板中，我们需要将锚点改为使用屏幕的上三分之二，而不是左三分之二。将**Min
    X**设为`0`，**Min Y**设为`0.33`，**Max X**和**Max Y**都设为`1`即可实现这一点。
- en: Next, **Turn Indicator** needs to be selected and moved to the bottom third
    of the screen. Values of `0` for **Min X** and **Min Y**, `1` for **Max X**, and
    `0.33` for **Max Y** will work well here.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要选择**Turn Indicator**并将其移到屏幕底部三分之一的位置。将**Min X**和**Min Y**设为`0`，**Max X**设为`1`，**Max
    Y**设为`0.33`，在这里效果会很好。
- en: Now that we have our second board set up, we need to make a place for it in
    our code. So, open the `TicTacToeControl` script and scroll to the top so that
    we can start with some new variables.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了第二个游戏板，我们需要在代码中为它腾出空间。因此，打开`TicTacToeControl`脚本，并滚动到顶部，这样我们就可以从一些新变量开始。
- en: 'The first variable we are going to add will give us access to the turn indicator
    for the portrait mode of our screen:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要添加的第一个变量将让我们能够访问屏幕竖屏模式下的回合指示器：
- en: '[PRE9]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next three variables will keep track of the buttons, square images, and
    owner text information. These are just like the three lists we created earlier
    to keep track of the board while it is in the landscape mode:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个变量将跟踪按钮、正方形图片和所有者文本信息。这些就像我们之前创建的三个列表，用于在横屏模式下跟踪游戏板：
- en: '[PRE10]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last two variables we are going to add to the top of our script here are
    for keeping track of the two canvas objects that actually draw our game boards.
    We need these so that we can switch between them as the user turns their device
    around:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们脚本顶部要添加的最后两个变量是为了跟踪实际绘制游戏面板的两个画布对象。我们需要这些以便在用户翻转设备时切换它们：
- en: '[PRE11]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to update a few of our functions so that they make changes to
    both boards and not just the landscape board. These first two lines turn the portrait
    board''s buttons off and the squares on when the player clicks on them. They need
    to go at the beginning of our `ButtonClick` function. Put them right after the
    two lines where we use `SetActive` on the buttons and squares for the landscape
    set:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新一些函数，使它们对两个面板进行更改，而不仅仅是横屏面板。这两行代码用于在玩家点击时关闭竖屏面板的按钮并激活方块。它们需要放在我们使用`SetActive`对横屏的按钮和方块进行操作的代码后的`ButtonClick`函数的开始部分：
- en: '[PRE12]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These two lines change the image and text for the controlling square in favor
    of the X player for the **Portrait** set. They go inside the `if` statement of
    our `ButtonClick` function, right after the two lines that do the same thing for
    the landscape set:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两行代码更改了**Portrait**集中控制方块的图片和文本，以支持X玩家。它们放在`ButtonClick`函数的`if`语句内，紧接在为横屏集做相同操作的两行代码之后：
- en: '[PRE13]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line goes at the end of that same `if` statement and changes the **Portrait**
    set''s turn indicator text:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码放在同一`if`语句的末尾，更改**Portrait**集的轮次指示文本：
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next two lines change image and text in favor of the O player. They go
    after the same lines for the **Landscape** set, inside of the `else` statement
    of our `ButtonClick` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两行代码更改图片和文本，以支持O玩家。它们放在对**Landscape**集进行相同操作的代码之后，位于`ButtonClick`函数的`else`语句内：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the last line we need to add to our `ButtonClick` function; it needs
    to be put at the end of the `else` statement. It simply changes the text indicating
    whose turn it is:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们需要添加到`ButtonClick`函数的最后一条代码；它需要放在`else`语句的末尾。它只是更改表示轮到谁的文本：
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we need to create a new function to control the changing of our game
    boards when the player changes the orientation of their device. We will start
    by defining the `Update` function. This is a special function called by Unity
    for every single frame. It will allow us to check for a change in orientation
    for every frame:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的函数，用于控制在玩家改变设备方向时游戏面板的更改。我们将从定义`Update`函数开始。这是一个由 Unity 每帧调用的特殊函数。它将允许我们检查每一帧的方向是否发生了变化：
- en: '[PRE17]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The function begins with an `if` statement that uses `Input.deviceOrientation`
    to find out how the player''s device is currently being held. It compares the
    finding to the `LandscapeLeft` orientation to see whether the device is begin
    held sideways, with the home button on the left side. If the result is true, the
    **Portrait** set of GUI elements are turned off while the **Landscape** set is
    turned on:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数以一个`if`语句开始，该语句使用`Input.deviceOrientation`来找出玩家当前的持握方式。它与`LandscapeLeft`方向进行比较，以查看设备是否被横向持握，主页按钮在左侧。如果结果为真，则关闭**Portrait**集的GUI元素，同时打开**Landscape**集：
- en: '[PRE18]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next `else if` statement checks for a `Portrait` orientation if the home
    button is down. It turns **Portrait** on and the **Landscape** set off, if `true`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个`else if`语句检查如果主页按钮向下，是否为`Portrait`方向。如果为`true`，则打开**Portrait**并关闭**Landscape**设置：
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This `else if` statement is checking `LanscapeRight` when the home button is
    on the right side:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`else if`语句用于检查当主页按钮在右侧时是否为`LanscapeRight`方向：
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we check the `PortraitUpsideDown` orientation, which is when the home
    button is at the top of the device. Don''t forget the extra bracket to close off
    and end the function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查`PortraitUpsideDown`方向，即主页按钮在设备顶部时。别忘了额外的括号来结束并关闭函数：
- en: '[PRE21]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now need to return to Unity and select our **GameControl** object so that
    we can set up our new **Inspector** properties.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要回到Unity，选择我们的**GameControl**对象，以便我们可以设置新的**Inspector**属性。
- en: Drag and drop the various pieces from the portrait game board in **Hierarchy**
    to the relevant slot in **Inspector**, **Turn Indicator** to the **Turn Indicator
    Portrait** slot, the buttons to the **Buttons Portrait** list in order, the squares
    to **Squares Portrait**, and their text children to the **Square Texts Portrait**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自肖像游戏面板的各种部件从**层级**拖放到**检查器**中的相关槽位，将**转向指示器**拖到**转向指示器肖像**槽位，按钮按顺序拖到**按钮肖像**列表，方块到**方块肖像**，以及它们的文本子对象到**方块文本肖像**。
- en: Finally, drop the **GameBoard_Portrait** object in the **Game Board Group Portrait**
    slot.![Rotating devices](img/4691OT_02_09.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**GameBoard_Portrait**对象拖放到**游戏面板组肖像**槽位中。![旋转设备](img/4691OT_02_09.jpg)
- en: We should now be able to play our game and see the board switch when we change
    the orientation of our device. You will have to either build your project on your
    device or connect using Unity Remote because the Editor itself and your computer
    simply don't have a device orientation like your mobile device. Be sure to set
    the display mode of your **Game** window to **Remote** in the top-left corner
    so that it will update along with your device while using Unity Remote.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够玩我们的游戏，并在改变设备方向时看到面板切换。由于编辑器和电脑本身没有像移动设备那样的设备方向，你将需要在你的设备上构建项目或使用Unity远程连接。确保将你的**游戏**窗口的显示模式设置为左上角的**远程**，以便在使用Unity远程时与你的设备一起更新。
- en: Menus and victory
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单和胜利
- en: 'Our game is nearly complete. The last things we need are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏几乎完成了。我们还需要以下内容：
- en: An opening menu where players can start a new game
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许玩家开始新游戏的开始菜单
- en: A bit of code for checking whether anybody has won the game
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段用于检查是否有人赢得游戏的代码
- en: A game over menu for displaying who won the game
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示谁赢得了游戏的游戏结束菜单
- en: Setting up the elements
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置元素
- en: 'Our two new menus will be quite simple when compared to the game board. The
    opening menu will consist of our game''s title graphic and a single button, while
    the game over menu will have a text element to display the victory message and
    a button to go back to the main menu. Let''s perform the following steps to set
    up the elements:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏面板相比，我们的两个新菜单将相当简单。开始菜单将包括我们游戏的标题图像和一个按钮，而游戏结束菜单将有一个显示胜利消息的文本元素和一个返回主菜单的按钮。下面是设置元素的操作步骤：
- en: Let's start with the opening menu by creating a new **Canvas**, just like we
    did before, and rename it `OpeningMenu`. This will allow us to keep it separate
    from the other screens we have created.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从开始菜单开始，创建一个新的**画布**，就像我们之前做的那样，并将其重命名为`OpeningMenu`。这将使我们能够将其与其他创建的屏幕区分开来。
- en: Next, the menu needs an **Image** element and a **Button** element as children.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，菜单需要一个**图像**元素和一个**按钮**元素作为子对象。
- en: To make everything easier to work with, turn off the game boards with the checkbox
    at the top of their **Inspector** windows.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使一切更容易操作，通过它们**检查器**窗口顶部的复选框关闭游戏面板。
- en: For our image object, we can drag our **Title** image to the **Source Image**
    slot.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的图像对象，我们可以将**标题**图像拖到**源图像**槽位。
- en: For the image's **Rect Transform**, we need to set the **Pos X** and **Pos Y**
    values to `0`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于图像的**矩形变换**，我们需要将**Pos X**和**Pos Y**的值设置为`0`。
- en: We also need to adjust the **Width** and **Height**. We are going to match the
    dimensions of the original image so that it will not be stretched. Put a value
    of `320` for **Width** and `160` for **Height**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整**宽度**和**高度**。我们将匹配原始图像的尺寸，这样它就不会被拉伸。为**宽度**设置一个值`320`，为**高度**设置一个值`160`。
- en: To move the image to the top half of the screen, put a `0` in the **Pivot Y**
    slot. This changes where the position is based for the image.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将图像移动到屏幕上半部分，在**Pivot Y**槽位中放入一个`0`。这将改变图像的定位基准。
- en: For the button's **Rect Transform**, we again need the value of `0` for both
    **Pos X** and **Pos Y**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于按钮的**矩形变换**，我们同样需要在**Pos X**和**Pos Y**中输入值`0`。
- en: We again need a value of `320` for the **Width**, but this time we want a value
    of `100` for the **Height**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为**宽度**再次输入一个值`320`，但这次我们希望**高度**的值为`100`。
- en: To move it to the bottom half of the screen, we need a value of `1` in the **Pivot
    Y** slot.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将其移动到屏幕下半部分，我们需要在**Pivot Y**槽位中输入一个值`1`。
- en: Next up is to set the images for the button, just like we did earlier for the
    game board. Put the `ButtonNormal` image in the **Source Image** slot. Change
    **Transition** to **SpriteSwap** and put the `ButtonActive` image in the **Pressed
    Sprite** slot. Do not forget to change **Color** to have an **A** value of `255`
    in the color picker so that our button is not partially faded.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为按钮设置图像，就像之前为游戏板所做的那样。将`ButtonNormal`图像放入**源图像**槽中。将**过渡**更改为**精灵交换**，并将`ButtonActive`图像放入**按下精灵**槽中。别忘了将**颜色**更改为颜色选择器中的**A**值为`255`，这样我们的按钮就不会部分褪色。
- en: Finally, for this menu to change the button text, expand **Button** in the **Hierarchy**
    and select the **Text** child object.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使此菜单更改按钮文本，请在**层次结构**中展开**按钮**并选择**文本**子对象。
- en: Right underneath **Text** in the **Inspector** panel for this object is a text
    field where we can change the text displayed on the button. A value of `New Game`
    here will work well. Also, change **Font Size** to `45` so that we can actually
    read it.![Setting up the elements](img/4691OT_02_05.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对象的**检查器**面板中，**文本**下方是一个文本字段，我们可以在其中更改按钮上显示的文本。这里的值设置为`新游戏`会很合适。同时，将**字体大小**更改为`45`，这样我们才能实际阅读它。![设置元素](img/4691OT_02_05.jpg)
- en: Next, we need to create the game over menu. So, turn off our opening menu and
    create a new canvas for our game over menu. Rename it `GameOverMenu` so that we
    can continue to be organized.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建游戏结束菜单。因此，关闭我们的开场菜单并为游戏结束菜单创建一个新的画布。将其重命名为`GameOverMenu`，以便我们可以继续保持组织性。
- en: For this menu, we need a **Text** element and a **Button** element as its children.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于此菜单，我们需要一个**文本**元素和一个**按钮**元素作为其子项。
- en: We will set this one up in an almost identical way to the previous one. Both
    the text and button need values of `0` for the **Pos X** and **Pos Y** slots,
    with a value of `320` for **Width**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将几乎与上一个完全相同的方式设置这个。文本和按钮都需要在**Pos X**和**Pos Y**槽中具有`0`的值，以及`320`的**宽度**值。
- en: The text will use a **Height** of `160` and a **Pivot Y** of `0`. We also need
    to set its **Font Size** to `80`. You can change the default text, but it will
    be overwritten by our code anyway.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本将使用`160`的**高度**和`0`的**Pivot Y**。我们还需要将**字体大小**设置为`80`。你可以更改默认文本，但无论如何它都会被我们的代码覆盖。
- en: To center our text in the menu, select the middle buttons from the two sets
    next to the **Alignment** property.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使菜单中的文本居中，请从**对齐**属性旁边的两组按钮中选择中间的按钮。
- en: The button will use a **Height** of `100` and a **Pivot Y** of `1`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮将使用`100`的**高度**和`1`的**Pivot Y**。
- en: Also, be sure you set the **Source Image**, **Color**, **Transition**, and **Pressed
    Sprite** to the proper images and settings.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，请确保将**源图像**、**颜色**、**过渡**和**按下精灵**设置为适当的图像和设置。
- en: The last thing to set is the button's text child. Set the default text to **Main
    Menu** and give it a **Font Size** of `45`.![Setting up the elements](img/4691OT_02_06.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要设置的最后一项是按钮的文本子项。将默认文本设置为**主菜单**，并将**字体大小**设置为`45`。![设置元素](img/4691OT_02_06.jpg)
- en: That is it for setting up our menus. We have all the screens we need to allow
    the player to interact with our game. The only problem is we don't have any of
    the functionality to make them actually do anything.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的菜单设置。我们有所有让玩家与游戏互动所需的屏幕。唯一的问题是，我们没有实现任何功能让它们实际执行操作。
- en: Adding the code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加代码
- en: To make our game board buttons work, we had to create a function in our script
    they could reference and call when they are touched. The main menu's button will
    start a new game, while the game over menu's button will change screens to the
    main menu. We will also need to create a little bit of code to clear out and reset
    the game board when a new game starts. If we don't, it will be impossible for
    the player to play more than one round before being required to restart the whole
    app if they want to play again.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的游戏板按钮起作用，我们不得不在脚本中创建一个函数，它们可以引用并在被触摸时调用。主菜单的按钮将开始新游戏，而游戏结束菜单的按钮将切换屏幕至主菜单。我们还需要创建一小段代码，以便在开始新游戏时清除并重置游戏板。如果我们不这样做，玩家将无法在需要重新启动整个应用程序之前玩超过一轮的游戏。
- en: Open the `TicTacToeControl` script so that we can make some more changes to
    it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TicTacToeControl`脚本，这样我们可以对其进行更多修改。
- en: We will start with the addition of three variables at the top of the script.
    The first two will keep track of the two new menus, allowing us to turn them on
    and off as per our need. The third is for the text object in the game over screen
    that will give us the ability to put up a message based on the result of the game.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在脚本顶部添加三个变量。前两个将跟踪两个新菜单，使我们能够根据需要打开或关闭它们。第三个是用于游戏结束屏幕中的文本对象，它将根据游戏结果给我们提供显示消息的能力。
- en: 'Next, we need to create a new function. The `NewGame` function will be called
    by the button in the main menu. Its purpose is to reset the board so that we can
    continue to play without having to reset the whole application:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新函数。`NewGame`函数将被主菜单中的按钮调用。其目的是重置棋盘，这样我们就可以继续玩，而无需重置整个应用程序：
- en: '[PRE22]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function starts by setting the game to start on the X player''s turn. It
    then creates a new array of `SquareStates`, which effectively wipes out the old
    game board. It then sets the turn indicators for both the **Landscape** and **Portrait**
    sets of controls:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数首先将游戏设置为从X玩家的回合开始。然后创建一个`SquareStates`的新数组，这实际上会清除旧的棋盘。然后设置**横屏**和**竖屏**两组控制的回合指示：
- en: '[PRE23]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We next loop through the nine buttons and squares for both the **Portrait**
    and **Landscape** controls. All the buttons are turned on and the squares are
    turned off using `SetActive`, which is the same as clicking on the little checkbox
    at the top-left corner of the **Inspector** panel:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历**竖屏**和**横屏**控制的九个按钮和方块。所有按钮都通过`SetActive`打开，方块关闭，这就像点击**检查器**面板左上角的小复选框一样：
- en: '[PRE24]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last three lines of code control which screens are visible when we change
    over to the game board. By default, it chooses to turn on the **Landscape** board
    and makes sure that the **Portrait** board is turned off. It then turns off the
    main menu. Don''t forget the last curly bracket to close off the function:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后三行控制当我们切换到游戏板时哪些屏幕可见。默认情况下，它选择打开**横屏**板并确保**竖屏**板关闭。然后关闭主菜单。别忘了最后的括号来结束函数：
- en: '[PRE25]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we need to add a single line of code to the end of the `ButtonClick`
    function. It is a simple call to check whether anyone has won the game after the
    buttons and squares have been dealt with:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`ButtonClick`函数的末尾添加一行代码。这是一个简单的调用，用于检查在处理完按钮和方块后是否有人赢得了游戏：
- en: '[PRE26]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `CheckVictory` function runs through the possible combinations for victory
    in the game. If it finds a run of three matching squares, the `SetWinner` function
    will be called and the current game will end:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CheckVictory`函数遍历游戏中可能获胜的组合。如果它找到连续三个匹配的方块，将调用`SetWinner`函数，当前游戏将结束：'
- en: '[PRE27]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A victory in this game is a run of three matching squares. We start by checking
    the column that is marked by our loop. If the first square is not `Clear`, compare
    it to the square below; if they match, check it against the square below that.
    Our board is stored as a list but drawn as a grid, so we have to add three to
    go down a square. The `else if` statement follows with checks of each row. By
    multiplying our loop value by three, we will skip down a row of each loop. We''ll
    again compare the square to `SquareState.Clear`, then to the square to its right,
    and finally, with the two squares to its right. If either set of conditions is
    correct, we''ll send the first square in the set to another function to change
    our game screen:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个游戏中，连续三个匹配的方块组成一次胜利。我们从被循环标记的列开始检查。如果第一个方块不是`Clear`，将其与下面的方块进行比较；如果它们匹配，再检查下面的方块。我们的棋盘是作为列表存储但以网格形式绘制，所以我们需要加三来下移一个方块。`else
    if`语句随后对每一行进行检查。通过将循环值乘以三，我们将跳过每一层循环的一行。我们再次将方块与`SquareState.Clear`进行比较，然后与它右侧的方块，最后与它右侧的两个方块。如果任一条件正确，我们将集合中的第一个方块发送到另一个函数以更改游戏屏幕：
- en: '[PRE28]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code snippet is largely the same as the `if` statements we just
    saw. However, these lines of code check the diagonals. If the conditions are `true`,
    again send out to the other function to change the game screen. You have probably
    also noticed the returns after the function calls. If we have found a winner at
    any point, there is no need to check any more of the board. So, we''ll exit the
    `CheckVictory` function early:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段与刚才看到的`if`语句基本相同。然而，这些代码检查对角线。如果条件为`true`，再次发送到另一个函数以更改游戏屏幕。你可能也注意到了函数调用后的返回。如果在任何一点找到胜者，就没有必要检查棋盘的其余部分。因此，我们将提前退出`CheckVictory`函数：
- en: '[PRE29]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the last little bit for our `CheckVictory` function. If no one has
    won the game, as determined by the previous parts of this function, we have to
    check for a tie. This is done by checking all the squares of the game board. If
    any one of them is `Clear`, the game has yet to finish and we exit the function.
    But, if we make it through the entire loop without finding a `Clear` square, we
    set the winner by declaring a tie:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`CheckVictory`函数的最后一点。如果没有人赢得游戏，由函数的先前部分判断，我们必须检查平局。这是通过检查游戏板的所有格子来完成的。如果其中任何一个格子是`Clear`，游戏尚未结束，我们退出函数。但是，如果我们遍历整个循环而没有找到一个`Clear`的格子，我们通过宣布平局来设定胜者：
- en: '[PRE30]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we create the `SetWinner` function that is called repeatedly in our `CheckVictory`
    function. This function passes who has won the game, and it initially turns on
    the game over screen and turns off the game board:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`SetWinner`函数，该函数在`CheckVictory`函数中被反复调用。这个函数传递了谁赢得了游戏的信息，它最初会开启游戏结束屏幕并关闭游戏板：
- en: '[PRE31]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The function then checks to see who won and picks an appropriate message for
    the `victorText` object:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，函数检查谁赢得了比赛，并为`victorText`对象选择一个适当的信息：
- en: '[PRE32]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we have the `BackToMainMenu` function. This is short and sweet; it
    is simply called by the button on the game over screen to switch back to the main
    menu:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`BackToMainMenu`函数。这个函数简短而精炼；它只是被游戏结束屏幕上的按钮调用，以切换回主菜单：
- en: '[PRE33]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That is all the code we have in our game. We have all the visual pieces that
    make up our game and now, we also have all the functional pieces. The last step
    is to put them together and finish the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在游戏中拥有的所有代码。我们拥有了构成游戏的所有视觉部分，现在我们也拥有了所有功能部分。最后一步是将它们组合起来，完成游戏。
- en: Putting them together
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将它们组合起来
- en: 'We have our code and our menus. Once we connect them together, our game will
    be complete. To put it all together, perform the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了代码和菜单。一旦将它们连接起来，我们的游戏就完成了。为了完成这一切，请执行以下步骤：
- en: Go back to the Unity Editor and select the **GameControl** object from the **Hierarchy**
    panel.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity编辑器，从**Hierarchy**面板中选择**GameControl**对象。
- en: The three new properties in its **Inspector** window need to be filled in. Drag
    the **OpeningMenu** canvas to the **Main Menu Group** slot and **GameOverMenu**
    to the **Game Over Group** slot.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的**Inspector**窗口中的三个新属性需要填写。将**OpeningMenu**画布拖到**Main Menu Group**槽中，将**GameOverMenu**拖到**Game
    Over Group**槽中。
- en: Also, find the text object child of **GameOverMenu** and drag it to the **Victor
    Text** slot.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，找到**GameOverMenu**的文本对象子级，并将其拖到**Victor Text**槽中。
- en: Next, we need to connect the button functionality for each of our menus. Let's
    start by selecting the button object child of our **OpeningMenu** canvas.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为每个菜单连接按钮功能。首先选择**OpeningMenu**画布的按钮对象子级。
- en: Click on the little plus sign at the bottom right of its **Button (Script)**
    component to add a new functionality slot.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击其**Button (Script)**组件右下角的小加号，以添加新的功能槽。
- en: Click on the circle in the center of the new slot and select **GameControl**
    from the new pop-up window, just like we did for each of our game board buttons.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新槽中心的圆圈，并从新弹出的窗口中选择**GameControl**，就像我们对每个游戏板按钮所做的那样。
- en: The drop-down list that currently says **No Function** is our next target. Click
    on it and navigate to **TicTacToeControl** | **NewGame ()**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前显示**No Function**的下拉列表是我们的下一个目标。点击它，然后导航到**TicTacToeControl** | **NewGame
    ()**。
- en: Repeat these few steps to add the functionality to the Button child of **GameOverMenu**.
    Except, select **BackToMainMenu()** from the list.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这几个步骤，为**GameOverMenu**的子按钮添加功能。不过，从列表中选择**BackToMainMenu()**。
- en: The very last thing to do is to turn off both the game boards and the game over
    menu, using the checkbox in the top left of the **Inspector**. Leave only the
    opening menu on so that our game will start there when we play it.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的就是使用**Inspector**左上角的复选框关闭游戏板和游戏结束菜单。只留下开场菜单，这样当我们玩游戏时，游戏将从那里开始。
- en: Congratulations! This is our game. All our buttons are set, we have multiple
    menus, and we even created a game board that changes based on the orientation
    of the player's device. The last thing to do is to build it for our devices and
    go show it off.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这就是我们的游戏。我们的所有按钮都已设置，我们拥有多个菜单，甚至还创建了一个根据玩家设备方向改变的游戏板。最后要做的就是为我们的设备构建它，并展示出来。
- en: A better way to build for a device
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为设备构建的更好方法。
- en: 'Now, for the part of the build process that everyone itches to learn. There
    is a quicker and easier way to have your game built and play it on your Android
    device. The long and complicated way is still very good to know. Should this shorter
    method fail, and it will at some point, it is helpful to know the long method
    so that you can debug any errors. Also, the short path is only good for building
    for a single device. If you have multiple devices and a large project, it will
    take significantly more time to load them all with the short build process. Follow
    these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是每个人渴望了解的构建过程部分。有一个更快更简单的方法来构建你的游戏并在你的 Android 设备上玩。长而复杂的方法仍然非常值得一知。如果这个简短的方法失败了，而且在某个时候它会失败，了解长方法有助于你调试任何错误。另外，简短路径只适合为单个设备构建。如果你有多个设备和一个大项目，使用简短的构建过程加载它们将需要更多的时间。按照以下步骤操作：
- en: Start by opening the **Build Settings** window. Remember, it can be found under
    **File** at the top of the Unity Editor.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开**构建设置**窗口。记住，它可以在 Unity 编辑器顶部的**文件**下找到。
- en: If you have not already done so, save your scene. The option to save your scene
    is also found under **File** at the top of the Unity Editor.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，保存你的场景。保存场景的选项也可以在 Unity 编辑器顶部的**文件**下找到。
- en: Click on the **Add Current** button to add our current scene, also the only
    scene, to the **Scenes In Build** list. If this list is empty, there is no game.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加当前**按钮，将我们当前的场景（也是唯一一个场景）添加到**构建中的场景**列表中。如果这个列表是空的，就没有游戏。
- en: Be sure to change your **Platform** to **Android** if you haven't already done
    so. It is, after all, still the point of this book.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请确保将您的**平台**更改为**Android**。毕竟，这是这本书的重点。
- en: Do not forget to set the **Player Settings**. Click on the **Player Settings**
    button to open them up in the **Inspector** window. You might remember this from
    [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记设置**玩家设置**。点击**玩家设置**按钮，在**检查器**窗口中打开它们。你可能还记得我们在[第1章](ch01.html "第1章. 向Unity和Android问好")中提到过，*Saying
    Hello to Unity and Android*。
- en: At the top, set the **Company Name** and **Product Name** fields. Values of
    `TomPacktAndroid` and `Ch2 TicTacToe`, respectively, for these fields will match
    the included completed project. Remember, these fields will be seen by the people
    playing your game.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，设置**公司名称**和**产品名称**字段。这些字段分别设置为`TomPacktAndroid`和`Ch2 TicTacToe`，将匹配包含的已完成项目。记住，这些字段会被玩你游戏的人看到。
- en: The **Bundle Identifier** field under **Other Settings** needs to be set, as
    well. The format is still `com.CompanyName.ProductName`, so `com.TomPacktAndroid.Ch2.TicTacToe`
    will work well. In order to see our cool dynamic GUI in action on a device, there
    is one other setting that should be changed. Click on **Resolution** and **Presentation**
    to expand the options.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**其他设置**下的**捆绑标识符**字段也需要设置。格式仍然是`com.CompanyName.ProductName`，所以`com.TomPacktAndroid.Ch2.TicTacToe`会很好用。为了在设备上看到我们酷炫的动态
    GUI，还有一个设置应该更改。点击**分辨率**和**展示**以展开选项。
- en: We are interested in **Default Orientation**. The default is **Portrait**, but
    this option means that the game will be fixed in the portrait display mode. Click
    on the drop-down menu and select **Auto Rotation**. This option tells Unity to
    automatically adjust the game to be upright irrespective of the orientation in
    which it is being held.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们关注的是**默认方向**。默认是**纵向**，但这个选项意味着游戏将被固定在纵向显示模式。点击下拉菜单，选择**自动旋转**。这个选项告诉 Unity
    无论游戏是被持在哪个方向，都会自动调整游戏使其直立。
- en: The new set of options that popped up when **Auto Rotation** was selected allows
    the limiting of the orientations that are supported. Perhaps you are making a
    game that needs to be wider and held in landscape orientation. By unchecking **Portrait**
    and **Portrait Upside Down**, Unity will still adjust (but only for the remaining
    orientations).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选择**自动旋转**时弹出的新选项集允许限制支持的方向。也许你正在制作一个需要更宽并且横屏持握的游戏。通过取消勾选**纵向**和**纵向倒置**，Unity
    仍然会进行调整（但只针对剩余的方向）。
- en: Note
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On your Android device, the controls are along one of the shorter sides; these
    usually are the home, menu, and back or recent apps buttons. This side is generally
    recognized as the bottom of the device and it is the position of these buttons
    that dictates what each orientation is. The **Portrait** mode is when these buttons
    are down relative to the screen. The **Landscape Right** mode is when they are
    to the right. The pattern begins to become clear, does it not?
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的Android设备上，控制按钮位于较短的边之一；这些通常是主页、菜单和返回或最近应用按钮。这一侧通常被认为是设备的底部，这些按钮的位置决定了每个方向。**纵向**模式是指这些按钮相对于屏幕向下。**横向右**模式是指它们位于右侧。这种模式开始变得清晰，不是吗？
- en: For now, leave all the orientation options checked and we will go back to **Build
    Settings**.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保留所有方向选项的勾选状态，我们将返回到**构建设置**。
- en: The next step (and this very important) is to connect your device to your computer
    and give it a moment to be recognized. If your device is not the first one connected
    to your computer, this shorter build path will fail.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步（这是非常重要的）是将你的设备连接到电脑上，并给它一点时间以被识别。如果你的设备不是第一个连接到电脑的设备，这条简短的构建路径将会失败。
- en: In the bottom-right corner of the **Build Settings** window, click on the **Build
    And Run** button. You will be asked to give the application file, the APK, a relevant
    name, and save it to an appropriate location. A name such as `Ch2_TicTacToe.apk`
    will be fine, and it is suitable enough to save the file to the desktop.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**窗口的右下角，点击**构建并运行**按钮。系统会要求你给应用程序文件，即APK，一个合适的名字，并将其保存到适当的位置。一个像`Ch2_TicTacToe.apk`这样的名字就很好，并且可以将其保存在桌面上。
- en: Click on **Save** and sit back to watch the wonderful loading bar that is provided.
    If you paid attention to the loading bar we built in the *Hello World* project
    in [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*, you will notice we took an extra step this time around.
    After the application is built, there is a pushing to device step. This means
    that the build was successful and Unity is now putting the application on your
    device and installing it. Once this is done, the game will start on the device
    and the loading will be done.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**，然后坐下来欣赏所提供的精彩加载条。如果你注意到了我们在[第1章](ch01.html "第1章. 向Unity和Android问好")中的*Hello
    World*项目中构建的加载条，你会发现这次我们多了一个步骤。应用程序构建完成后，会有一个推送至设备的步骤。这意味着构建成功，Unity现在正在将应用程序安装到你的设备上。完成这一步后，游戏将在设备上启动，加载完成。
- en: We just learned about the **Build And Run** button provided by the **Build Settings**
    window. This is quick, easy, and free from the pain of using the command prompt;
    isn't the short build path wonderful? However, if the build process fails for
    any reason, including being unable to find the device, the application file will
    not be saved. You will have to go through the entire build process again, if you
    want to try installing again. This isn't so bad for our simple Tic-tac-toe game,
    but it might consume a lot of time for a larger project. Also, you can only have
    one Android device connected to your computer while building. Any more devices
    and the build process is a guaranteed failure. Unity also doesn't check for multiple
    devices until after it has gone through the rest of the potentially long build
    process.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了**构建并运行**按钮，这是由**构建设置**窗口提供的。这种方法快速、简单，且无需使用命令提示行的痛苦；这样简短的构建路径不是很棒吗？然而，如果构建过程由于任何原因失败，包括无法找到设备，应用程序文件将不会被保存。如果你想再次尝试安装，就必须重新进行整个构建过程。这对于我们简单的井字游戏来说并不算太糟糕，但对于较大的项目可能会消耗很多时间。此外，在构建时你只能将一个Android设备连接到电脑上。如果连接更多设备，构建过程肯定会失败。而且Unity在完成可能很长的构建过程之后才会检查多个设备。
- en: Other than these words of caution, the **Build And Run** option is really quite
    nice. Let Unity handle the hard part of getting the game to your device. This
    gives us much more time to focus on testing and making a great game.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些注意事项之外，**构建并运行**选项真的相当不错。让Unity处理将游戏传送到设备上的复杂部分。这为我们提供了更多的时间来专注于测试和制作一款伟大的游戏。
- en: 'If you are up for a challenge, this is a tough one: creating a single player
    mode. You will have to start by adding an extra button to the opening screen for
    selecting the second game mode. Any logic for the computer player should go in
    the `Update` function. Also, take a look at `Random.Range` for randomly selecting
    a square to take control. Otherwise, you could do a little more work and make
    the computer search for a square where it can win or create a line of two matches.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个挑战，这是一个艰难的任务：创建单人模式。你将需要从添加一个额外的按钮开始，这个按钮位于开场屏幕上，用于选择第二种游戏模式。任何计算机玩家的逻辑都应该放在`Update`函数中。同时，查看`Random.Range`以随机选择一个方块进行控制。否则，你可以多做一点工作，让计算机寻找可以获胜或创建两个匹配行的方块。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, you should be familiar with Unity's new uGUI system, including
    how to position the GUI elements, styling them to meet your needs, and adding
    functionality to them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该已经熟悉了 Unity 的新 uGUI 系统，包括如何定位 GUI 元素，根据需要设置它们的样式，以及向它们添加功能。
- en: In this chapter, we learned all about the GUI by creating a Tic-tac-toe game.
    We first became familiar with creating buttons and other objects to be drawn on
    the game's GUI Canvas. After delving into improving the look of our game, we continued
    to improve it when we added dynamic orientation to the game board. We created
    an opening and closing screen to round out the game experience. Finally, we explored
    an alternative build method for putting our game onto devices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建一个井字游戏，学习了关于 GUI 的所有内容。我们首先熟悉了创建按钮和其他要在游戏的 GUI 画布上绘制的对象。在深入改善游戏的外观之后，我们继续通过为游戏板添加动态方向来改进它。我们创建了一个开场和结束屏幕，以完善游戏体验。最后，我们探索了将游戏部署到设备上的另一种构建方法。
- en: 'In the next chapter, we will be starting a new and more complex game. The tank
    battle game we will create will be used to gain an understanding of the basic
    building blocks of any game: meshes, materials, and animations. When everything
    is done, we will be able to drive a tank around a colorful city and shoot animated
    targets.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始创建一个全新且更复杂游戏。我们将要制作的坦克大战游戏，将用于了解任何游戏的基本构建块：网格、材质和动画。当一切完成时，我们将能够在多彩的城市中驾驶坦克并射击动画目标。
