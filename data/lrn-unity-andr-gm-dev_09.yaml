- en: Chapter 9. Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 优化
- en: In the previous chapter, we learned about special effects for our games. We
    added background music to our Monkey Ball game. We also created dust trails for
    our monkey. By combining both audio effects and particle systems, we created explosions
    when a player collects a banana. Together, these round out the game experience
    and give us a very complete-looking game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了关于游戏特效的知识。我们为Monkey Ball游戏添加了背景音乐。我们还为我们的猴子创建了尘埃轨迹。通过结合音频效果和粒子系统，当玩家收集香蕉时我们创建了爆炸效果。这些共同丰富了游戏体验，使我们的游戏看起来非常完整。
- en: In this chapter, we explore our options for optimization. We start by looking
    at the application footprint and how to reduce it. We then move on to look at
    the game's performance even further. Finally, we explore some key areas that can
    cause lag and look at how we can minimize their effects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨优化的各种选项。我们从应用程序占用空间着手，探讨如何减少它，然后进一步查看游戏性能，最后探索可能导致延迟的关键区域，以及如何减少它们的影响。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Minimizing the application footprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化应用程序占用空间
- en: Tracking performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪性能
- en: Minimizing lag
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少延迟
- en: Occlusion culling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遮挡剔除
- en: For this chapter, we will be working on both our Monkey Ball and Tank Battle
    games. Start the chapter by opening the Monkey Ball project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将同时处理我们的Monkey Ball和Tank Battle游戏。首先打开Monkey Ball项目来开始本章的学习。
- en: Minimizing the application footprint
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化应用程序占用空间
- en: One of the keys to a successful game is the size of the game itself. Many users
    will quickly uninstall any application that appears to be unnecessarily large.
    In addition, all of the mobile app stores impose restrictions on how your game
    will be supplied to users based on the size of the application itself. Becoming
    familiar with the options that you have for minimizing the size of your game is
    the key to control how your game will be distributed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏成功的关键之一在于游戏本身的大小。许多用户会迅速卸载那些看起来不必要的大的应用程序。此外，所有移动应用商店都根据应用程序本身的大小对游戏如何提供给用户设置了限制。熟悉缩小游戏大小的各种选项是控制游戏分发方式的关键。
- en: The first thing to note when working to minimize the footprint is how Unity
    handles assets as it builds the game. Only assets that are used somewhere in one
    of the scenes for the build are actually included in the game. If it is not in
    the scene itself or referenced by an asset that is in the scene, it will not be
    included. This means you could have test versions of assets, or incomplete versions;
    as long as they are not referenced, they will not affect the final build size
    of your game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当致力于最小化占用空间时，首先需要注意的是Unity在构建游戏时如何处理资源。只有那些在构建中至少一个场景中使用过的资源才会被实际包含在游戏中。如果资源不在场景本身或者不在场景中引用的资源中，那么它就不会被包含。这意味着你可以拥有资源的测试版本或不完整版本；只要它们没有被引用，它们就不会影响你游戏的最终构建大小。
- en: Unity also allows you to keep your assets in the format that you need for working
    on them. When the final build is made, all the assets are converted to an appropriate
    version for their type. This means that you can keep models in the format that
    are native to your modeling program, which will be converted to FBX files. Otherwise,
    you can keep your images as Photoshop files, or any other format in which you
    work, and they will be converted to JPG or PNG appropriately when the game is
    built.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还允许你以你需要的工作格式保存资源。当最终构建时，所有资源都会转换为适合其类型的适当版本。这意味着你可以将模型保存在与你的建模程序本机格式中，它们将在构建游戏时转换为FBX文件。否则，你可以将图像保存为Photoshop文件，或你工作的任何其他格式，并在构建游戏时适当转换为JPG或PNG。
- en: Editor log
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器日志
- en: 'When you are finally ready to work with the footprint of your game, it is possible
    to find out exactly what is causing your game to be larger than desired. In the
    top-right corner of the **Console** window is a drop-down menu button. Inside
    this menu is **Open Editor Log**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好最终处理游戏的占用空间时，可以确切地找出导致游戏比预期更大的原因。在**控制台**窗口的右上角有一个下拉菜单按钮。这个菜单中有**打开编辑器日志**：
- en: '![Editor log](img/4691OT_09_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器日志](img/4691OT_09_01.jpg)'
- en: 'The Editor log is the location where Unity outputs information while it is
    running. This file tracks information about the current version of the Unity Editor,
    performs any checks done for your license, and contains a bit of information about
    any assets you have imported. The log will also contain detailed information about
    the file size and assets included in the game, after it has been built. An example
    of the Editor log is shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器日志是 Unity 在运行时输出信息的位置。这个文件会记录有关当前 Unity 编辑器版本的信息，执行对你的许可证的任何检查，并包含一些关于你导入的资源的详细信息。日志还将包含有关构建后游戏中包含的文件大小和资源的详细信息。以下屏幕截图显示了编辑器日志的一个示例：
- en: '![Editor log](img/4691OT_09_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器日志](img/4691OT_09_02.jpg)'
- en: Here, we can see a breakdown of the aspects of the final build. Every asset
    category has a size and percentage of the total build size. We are also supplied
    with a list of every asset that is actually included in the game, organized by
    their file size before they are added to the build. This information becomes very
    useful when you are looking for assets that can be made smaller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到最终构建方面的细分。每个资源类别都有其大小以及占总构建大小的百分比。同时，我们还获得了一个列表，列出了实际包含在游戏中的每个资源，按文件大小进行了组织，在添加到构建之前。当你寻找可以缩小的资源时，这些信息会非常有用。
- en: Asset compression
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源压缩
- en: Inside the **Import Settings** window for models, textures, and audio, there
    are options that affect the size and quality of imported assets. In general, the
    affected change is a reduction in quality. However, especially when working on
    a game for the mobile device, asset quality can be reduced well below the levels
    required for a computer before the difference becomes noticeable on the device.
    Once you understand the options available for each type of asset, you will be
    able to make optimal decisions regarding the quality of your game. When working
    with any of these options, look for a setting that minimizes the size before introduction
    of undesired artifacts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型、纹理和音频的**导入设置**窗口中，有一些影响导入资源的尺寸和质量的选项。通常，受影响的是质量的降低。然而，特别是在为移动设备开发游戏时，资源质量可以在达到计算机所需水平以下很多，而不会在设备上注意到差异。一旦你了解了每种资源类型可用的选项，你将能够就游戏的质量做出最佳决策。在使用这些选项中的任何一个时，寻找一个在引入不需要的伪影之前能最小化尺寸的设置。
- en: Models
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: No matter what program or method you use to create your models, ultimately,
    there is always a list of vertex positions and triangles, with a few references
    to textures. Most of the file size of a model comes from the list of vertex positions.
    To make sure that the models in your game are of the highest quality, start in
    the modeling program of your choice. Delete any and all extra vertexes, faces,
    and unused objects. Not only will this result in a smaller file when you build
    your final game, but it will also reduce the import time when you work in the
    editor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么程序或方法来创建你的模型，最终总会有一个顶点位置和三角形的列表，以及一些对纹理的引用。模型的大部分文件大小来自顶点位置列表。为了确保你的游戏中的模型具有最高质量，从你选择的建模程序开始。删除所有额外的顶点、面和未使用的对象。这不仅能让你在构建最终游戏时得到较小的文件，还能减少你在编辑器中的导入时间。
- en: The **Import Settings** window for models consists of three pages, resulting
    in more options to adjust the quality. Each page tab corresponds to the relevant
    part of the model, allowing you to fine-tune each one of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的**导入设置**窗口由三个页面组成，提供了更多调整质量的选项。每个页面标签对应于模型的相应部分，允许你微调每一个部分。
- en: The Model tab
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型标签页
- en: 'On the **Model** tab, you can influence how the mesh is imported. When it comes
    to optimizing your use of the models, there are many options here that are key
    to your success. Once your game looks and plays the way you want it to, you should
    always have a good look at these settings to see if you can make them work even
    better:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在**模型**标签页上，你可以影响网格的导入方式。在优化模型使用方面，这里有许多关键选项。一旦你的游戏看起来和玩起来的效果如你所愿，你应该始终仔细查看这些设置，看看是否能让它们工作得更好：
- en: '![The Model tab](img/4691OT_09_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![模型标签页](img/4691OT_09_03.jpg)'
- en: 'The following are the various settings in the **Model** tab:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**模型**标签页中的各种设置：
- en: '**Scale Factor** and **File Scale**: These let you control the default visual
    size of your model. The **File Scale** parameter is how big Unity calculated your
    model to be when importing it. The **Scale Factor** parameter lets you adjust
    what additional scaling Unity will apply when it imports your model.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放因子**和**文件缩放**：这些选项允许您控制模型的默认视觉大小。**文件缩放**参数是 Unity 在导入模型时计算的大小。**缩放因子**参数允许您调整
    Unity 在导入模型时应用的额外缩放。'
- en: '**Mesh Compression**: This option lets you select how much compression should
    be applied to the model. The compression effect amounts to combining vertexes
    to reduce the overall amount of detail that has to be stored for the mesh. This
    setting is likely to introduce undesired oddities in the mesh, when pushed too
    far. So, always pick the highest setting that does not introduce any artifacts.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格压缩**：此选项允许您选择对模型应用多少压缩。压缩效果相当于合并顶点以减少必须为网格存储的细节总量。如果过度使用此设置，可能会在网格中引入不希望出现的异常。因此，应始终选择不会引入任何伪影的最高设置。'
- en: '**Read/Write Enabled**: This option is only useful when you want to manipulate
    the mesh, through the script, while the game is running. If you never touch the
    mesh with any of your scripts, uncheck this box. Although this will not affect
    the final build size, it will affect how much memory is required to run your game.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写启用**：此选项仅在您想在游戏运行时通过脚本操作网格时有用。如果您从未用任何脚本接触网格，请取消勾选此框。尽管这不会影响最终构建的大小，但它会影响运行游戏所需的内存量。'
- en: '**Optimize Mesh**: This option causes Unity to reorder the triangles list that
    describes the model. This option is always a good one to leave checked. The only
    reason you might want to uncheck it is if you are manipulating the game or mesh
    based on the specific order of the triangles.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格**：此选项使 Unity 重新排序描述模型的三角形列表。此选项始终是一个好的选择，应该勾选。唯一可能需要取消勾选的情况是，如果您基于三角形的特定顺序操作游戏或网格。'
- en: '**Import BlendShapes**: BlendShapes are similar to keyframes in a normal animation,
    but they work on the mesh detail itself rather than the positions of bones. By
    unchecking this box, you can save space in your game and project because Unity
    will not need to calculate and store them.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入混合形状**：混合形状与普通动画中的关键帧相似，但它们作用于网格细节本身，而不是骨骼的位置。通过取消勾选此框，您可以节省游戏和项目中的空间，因为
    Unity 将不需要计算和存储它们。'
- en: '**Generate Colliders**: This option is almost always a candidate to leave unchecked.
    This option will add **Mesh Collider** components to every mesh in your model.
    These colliders are relatively expensive to calculate when working with physics
    in your game. If possible, you should always use a group of significantly simpler
    **Box Colliders** and **Sphere Colliders**.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成碰撞器**：此选项几乎总是建议不勾选。此选项将为模型中的每个网格添加**网格碰撞器**组件。这些碰撞器在处理游戏中的物理时计算相对昂贵。如果可能，您应该始终使用一组明显更简单的**盒子碰撞器**和**球体碰撞器**。'
- en: '**Swap UVs**: Unity supports models that have two sets of UV coordinates. Generally,
    the first is for normal texture and the second is for any lightmaps that the object
    has. If you generate your own lightmap UVs, it is possible for Unity to recognize
    them in the wrong order. Checking this box then forces Unity to change the order
    in which they are used.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换 UV**：Unity 支持具有两组 UV 坐标的模型。通常，第一组用于普通纹理，第二组用于物体的光照图。如果您生成自己的光照图 UV，Unity
    可能会识别错误的顺序。勾选此框将强制 Unity 改变它们的使用顺序。'
- en: '**Generate Lightmap UVs**: This option should only be used when you are working
    with objects that need static shadows. If the object does not need it, this will
    introduce excess vertex information and bloat the asset.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成光照图 UV**：仅当您处理需要静态阴影的物体时，才应使用此选项。如果物体不需要，这将会引入过多的顶点信息并增加资源的大小。'
- en: '**Normals**: This option is used to calculate or import normal information.
    **Normals** are used by materials for determining direction in which a vertex
    or triangle faces and how lighting should affect it. If the mesh never uses a
    material that needs the **Normals** information, be sure to set this to **None**.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线**：此选项用于计算或导入法线信息。**法线**被材质用于确定顶点或三角形面向的方向以及光照应该如何影响它。如果网格从未使用需要**法线**信息的材质，请确保将其设置为**无**。'
- en: '**Tangents**: This option is used to calculate or import tangent information.
    **Tangents** are used by materials to fake details with bump maps and similar
    special effects. Just as with the **Normals** setting, if you don''t need them,
    don''t import them. If **Normals** is set to **None**, this setting will automatically
    be grayed out and will no longer be imported.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切线**：这个选项用于计算或导入切线信息。**切线**被材质用于通过凹凸贴图和类似的特效来模拟细节。就像**法线**设置一样，如果你不需要它们，就不要导入它们。如果**法线**设置为**无**，这个设置会自动变灰，并且不再导入。'
- en: '**Smoothing Angle**: When calculating normals, this option lets you define
    how close the angle between two faces needs to be to be shaded smoothly across
    their shared edge.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平滑角度**：在计算法线时，这个选项允许你定义两个面之间的角度需要多接近，才能在它们共享的边缘上平滑着色。'
- en: '**Split Tangents**: This causes the tangents of your mesh to be recalculated
    where there are seams in your UVs. This is used for fixing some lighting irregularities
    in highly-detailed models.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割切线**：这会导致你的网格在UV接缝处重新计算切线。这对于修复高细节模型中的一些光照不规则性非常有用。'
- en: '**Keep Quads**: Unity normally converts all faces to triangles for rendering.
    If you are using DirectX 11 for rendering, this option will keep your faces as
    quads for tessellation.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持四边形**：Unity通常会将所有面转换为三角形进行渲染。如果你使用DirectX 11进行渲染，这个选项将保持你的面作为四边形进行镶嵌。'
- en: '**Import Materials**: This option lets you control whether or not new materials
    will be created when you are importing your models. If this is unchecked, no new
    models will be created when you are importing.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入材质**：这个选项允许你控制导入模型时是否创建新材质。如果取消勾选，导入时不会创建新模型。'
- en: '**Material Naming**: This lets you control the manner in which the models that
    are imported will name any new materials that are created.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质命名**：这允许你控制导入的模型命名任何新创建的材质的方式。'
- en: '**Material Search**: Unity can use a variety of methods for finding a material
    to use on the model that has already been created. The **Local Materials Folder**
    option will only look in a folder named `Materials` next to where the model is
    imported. The **Recursive-Up** option will look in the folder of the model, and
    the root assets folder through parent levels up. The **Project-Wide** option will
    search your whole project for a material with the right name.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质搜索**：Unity可以使用多种方法来查找已经创建的模型上要使用的材质。**本地材质文件夹**选项只会在导入模型的旁边名为`Materials`的文件夹中查找。**递归向上**选项会从模型所在的文件夹以及通过父级向上的根资源文件夹中查找。**全项目**选项会在整个项目中搜索具有正确名称的材质。'
- en: The Rig tab
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “绑定”标签页
- en: 'As we can see in the following screenshot, there are very few options to adjust
    for an animation rig:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，动画绑定调整的选项非常少：
- en: '![The Rig tab](img/4691OT_09_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![绑定标签页](img/4691OT_09_04.jpg)'
- en: There are really only two things to keep in mind when you are working to optimize
    your animation rig. The first is, if the asset does not animate, then don't import
    it. By setting **Animation Type** to **None**, Unity will not try to import the
    rig or any useless animations. The second thing to keep in mind is to remove any
    unnecessary bones. Once imported to Unity, delete any and all objects from the
    rig that do not actually have an effect on the animation or character. Unity can
    convert any inverse kinematics that you might use for animation into forward kinematics,
    so the guides used for it can be deleted once Unity is launched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化你的动画绑定时，你真正需要记住的只有两件事。第一，如果资源不进行动画处理，那么就不要导入它。将**动画类型**设置为**无**，Unity就不会尝试导入绑定或任何无用的动画。第二件需要记住的事情是移除所有不必要的骨骼。一旦导入Unity，删除那些实际上对动画或角色没有影响的绑定中的所有对象。Unity可以将你可能用于动画的反向运动学转换为正向运动学，因此在Unity启动后，可以删除用于它的引导。
- en: The **Optimize Game Object** checkbox that is there does not actually help in
    the overall optimization of the game. It simply hides the extra rig objects in
    the Hierarchy window, so you don't have to deal with them. This checkbox can also
    be very helpful when dealing with complex rigs in the editor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那里的**优化游戏对象**复选框实际上并不帮助游戏的整体优化。它只是在层次窗口中隐藏额外的绑定对象，这样你就不必处理它们。当在编辑器中处理复杂的绑定时，这个复选框也可以非常有帮助。
- en: The Animations tab
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “动画”标签页
- en: 'As with the **Rig** tab, if the model does not animate, do not import animations.
    Unchecking the **Import Animation** checkbox when you first import the asset will
    prevent any extra components from being added to your **GameObject** components
    in Unity. In addition, if any extra animations get added to your final build accidentally,
    they can quickly make your application oversized. The Animations tab is highlighted
    in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与**绑定**标签一样，如果模型没有动画，不要导入动画。在首次导入资源时取消勾选**导入动画**复选框，可以防止在 Unity 中向你的**GameObject**组件添加任何额外的组件。此外，如果任何额外的动画意外地被添加到你的最终构建中，它们可能会迅速使你的应用程序变得过大。以下截图突出了动画标签：
- en: '![The Animations tab](img/4691OT_09_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![The Animations tab](img/4691OT_09_05.jpg)'
- en: '**Anim.Compression**: This option adjusts how Unity handles excess keyframes
    in your animations. For most situations, the default option works well. The various
    options available are as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画压缩**：此选项调整 Unity 处理动画中多余关键帧的方式。在大多数情况下，默认选项效果很好。可用的各种选项如下：'
- en: '**Off**: This option should only be used if you need a high-precision animation.
    This is the largest and most costly setting to choose.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：只有当你需要高精度动画时，才应使用此选项。这是最大且成本最高的设置选择。'
- en: '**Keyframe Reduction**: This option will reduce the number of keyframes used
    by the animation based on the Error settings that follow. Essentially, if a keyframe
    does not have a noticeable effect upon the animation, it will be ignored.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键帧减少**：此选项将根据以下错误设置减少动画使用的关键帧数量。本质上，如果一个关键帧对动画没有明显的影响，它将被忽略。'
- en: '**Optimal**: This option does the same as the previous option, but additionally
    it compresses the file size of the animations. However, at runtime, the animation
    will still require the same amount of processor resources for calculation as the
    previous option.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳**：此选项与上一个选项相同，但此外它还会压缩动画的文件大小。然而，在运行时，动画仍然需要与上一个选项相同的处理器资源来进行计算。'
- en: '**Rotation Error**: This option is the difference of the number of degrees
    between keyframes that will be ignored when performing keyframe reduction.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转误差**：此选项是在执行关键帧减少时，关键帧之间将被忽略的度数差。'
- en: '**Position Error**: This option is the movement distance that will be ignored
    between keyframes when performing keyframe reduction.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置误差**：此选项是在执行关键帧减少时，关键帧之间将被忽略的移动距离。'
- en: '**Scale Error**: This option is the amount of size adjustment in the animation
    that will be ignored between keyframes when performing keyframe reduction.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放误差**：此选项是在执行关键帧减少时，关键帧之间将被忽略的动画大小调整量。'
- en: Textures
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理
- en: It is hard to imagine a quality game that does not have a whole bunch of images
    in it. Textures have a bunch of options to control how much detail will be preserved
    when they are used in the game. In general, it is best to select the lowest quality
    settings that do not introduce noticeable artifacts in the image. In addition,
    it is best to work with texture sizes that are in a power of two to improve processing
    speed. Moreover, few processors are commonly able to handle textures that are
    greater than `1024` pixels in size. By putting your images in or below this size,
    you potentially save a lot of memory and space in your final game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个高质量的游戏里面没有大量的图像。纹理有一系列选项来控制在使用游戏时保留多少细节。通常，最好选择不会在图像中引入明显瑕疵的最低质量设置。此外，最好使用大小为2的幂次的纹理以提高处理速度。而且，很少有处理器能够处理大于`1024`像素大小的纹理。通过将图像大小控制在或低于这个尺寸，你可以在最终游戏中节省大量的内存和空间。
- en: '![Textures](img/4691OT_09_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Textures](img/4691OT_09_06.jpg)'
- en: '**Texture Type**: This option affects what type of texture the image will be
    treated as. It is always best to select the type that is most appropriate for
    the intended use of the image. The following options show the various types of
    textures that can be used:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理类型**：此选项影响图像将被视为哪种类型的纹理。最好选择最适合图像预期用途的类型。以下选项展示了可以使用各种类型的纹理：'
- en: '**Texture**: This option is the most common and default setting when working
    with 3D games. This should be used for your normal model textures.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：此选项是在处理3D游戏时最常见和默认的设置。这应该用于你的普通模型纹理。'
- en: '**Normal Map**: This option is used for special effects such as bump maps.
    Materials that use this type of texture will also need normal and tangent information
    from the model''s import settings.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线图**：这个选项用于特殊效果，如凹凸贴图。使用这种类型纹理的材料还需要从模型的导入设置中获取法线和切线信息。'
- en: '**Editor GUI and Legacy GUI**: Unless you are working with special editor scripts,
    or other special cases, you will not use this setting. This is very similar to
    the **Sprite** setting.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器 GUI 和旧版 GUI**：除非你在使用特殊的编辑器脚本或其他特殊情况，否则你不会使用这个设置。这非常类似于**精灵**设置。'
- en: '**Sprite (2D and UI)**: This option is the most common and default setting
    when working with 2D games. This should always be used for your flat 2D characters
    and UI elements.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵（2D 和 UI）**：这个选项在处理 2D 游戏时是最常见和默认的设置。这应该始终用于你的平面 2D 角色和 UI 元素。'
- en: '**Cursor**: This setting is not particularly relevant to our Android platform.
    It allows you to create custom mouse pointers that aren''t commonly available
    for most Android devices.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光标**：这个设置对我们的 Android 平台来说并不是特别相关。它允许你创建自定义鼠标指针，这对于大多数 Android 设备来说并不常见。'
- en: '**Cubemap**: When you are working with custom reflections or skybox type materials,
    your images should use this option. This automatically wraps the image around,
    so it repeats like the edges of a sphere or cube.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立方体贴图**：当你在处理自定义反射或天空盒类型的材质时，你的图像应该使用这个选项。这会自动将图像环绕，使其像球面或立方体的边缘一样重复。'
- en: '**Cookie**: These textures are used on lights and they change how the light
    is emitted from the light object, like the ones we used for our tank''s headlights.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie**：这些纹理用于灯光上，它们改变光线从光源物体的发射方式，就像我们用于坦克车头灯的那种。'
- en: '**Lightmap**: We worked with Unity''s lightmapping system in our Tank Battle
    game. However, this system won''t always work for all situations. So, when you
    are making custom lightmaps outside of Unity, choose this option.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照图**：我们在坦克大战游戏中使用了 Unity 的光照图系统。然而，这个系统并不总是适用于所有情况。因此，当你需要在 Unity 外部制作自定义光照图时，请选择这个选项。'
- en: '**Advanced**: This option gives you full control over all the settings that
    are concerned with importing images. You will only need this setting if you have
    a special purpose for your textures or you need precise control over them.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**：这个选项让你能够完全控制所有与导入图像相关的设置。只有当你对你的纹理有特殊用途或需要精确控制它们时，你才需要这个设置。'
- en: '**Read/Write Enabled**: This checkbox is available when **Texture Type** is
    set to **Advanced**. This should only be left checked if you plan to manipulate
    the texture from your scripts while the game is running. If this is unchecked,
    Unity does not maintain a copy of the data in the CPU, freeing memory for other
    parts of the game.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写启用**：当**纹理类型**设置为**高级**时，此复选框可用。只有当你计划在游戏运行时通过脚本操作纹理时，才应该勾选此项。如果未勾选，Unity
    不会在 CPU 上维护数据副本，从而为游戏的其他部分释放内存。'
- en: '**Generate Mip Maps**: This option is another **Advanced** setting that lets
    you control the creation of smaller versions of the texture. These are then used
    when the texture is small on the screen, reducing the amount of processing needed
    to draw the texture and the object that is using it on the screen.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成 Mip Maps**：这个选项是另一个**高级**设置，它允许你控制纹理较小版本的创建。当纹理在屏幕上显示得很小的时候，这些较小版本的纹理就会被使用，从而减少绘制纹理及其在屏幕上使用的对象所需的处理量。'
- en: '**Filter Mode**: This option is available for all of the texture types. It
    affects how the image will look when you are very close to it. **Point** will
    make the image look blocky, while **Bilinear** and **Trilinear** will blur the
    pixels. In general, **Point** is the fastest mode; **Trilinear** is the slowest
    mode but gives the best-looking effect.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤模式**：这个选项适用于所有纹理类型。它影响当你非常接近图像时图像的显示效果。**点过滤**会使图像看起来块状化，而**双线性**和**三线性**则会模糊像素。通常，**点过滤**是速度最快的模式；**三线性**是速度最慢的模式，但能提供最佳视觉效果。'
- en: '**Max Size**: This option adjusts how large the image can be when it is used
    in the game. This allows you to work with images that are very large but import
    them to Unity in an appropriately small size. In general, values greater than
    **1024** are poor choices, not just because of the increased memory requirement
    but also since most mobile devices simply cannot handle textures that are any
    larger. In general, 1024-sized textures should be reserved for your main characters
    and other highly important objects. A size of 256 works well on mobile devices
    for objects with medium and low importance. For all of your objects, if you can
    combine their textures to share a 1024 texture, they will have a smaller impact
    on your game than if they have small separate textures. Choosing the smallest
    size possible will have a great effect on the footprint size of the textures in
    your final build.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大尺寸**：此选项调整图像在游戏中使用时可以有多大。这允许你处理非常大的图像，但以适当的小尺寸导入到Unity中。一般来说，大于**1024**的值都不是好选择，不仅因为内存需求增加，而且由于大多数移动设备根本无法处理更大的贴图。通常，1024大小的纹理应该保留给你的主要角色和其他非常重要物体。对于中等和低重要性物体，在移动设备上256大小表现良好。对于你的所有物体，如果能将它们的纹理合并到共享的1024纹理中，它们对游戏的影响会比它们有单独的小纹理要小。选择尽可能小的尺寸将大大影响最终构建中纹理的占用空间。'
- en: '**Format**: This option adjusts how the image would be imported and how much
    detail each pixel can hold. **Compressed** is the smallest format, while **Truecolor**
    provides the most detail.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式**：此选项调整图像的导入方式以及每个像素可以保留的细节量。**压缩**格式最小，而**真彩**提供最多的细节。'
- en: Audio
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频
- en: Giving a game quality sound always adds a lot to the final size of the game.
    It is one of the assets that a game cannot do without, but it can be hard to include
    at a suitable level. When working on the sounds in your audio program, keep them
    as short as possible to minimize their size. In addition, bear in mind that most
    of your players will not have the same fancy headphones or speakers to listen
    to your audio, so quality can be reduced to quite an extent before they notice
    any difference. The audio import settings all have an effect on either their footprint
    in the build size or the memory required to run the game.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏提供高品质的声音总是会增加游戏最终的大小。音频是游戏不可或缺的资产之一，但合适的包含水平可能难以把握。在音频程序中处理声音时，尽量保持简短，以减小其大小。此外，要考虑到大多数玩家并没有高级耳机或扬声器来听你的音频，因此在他们注意到差异之前，音频质量可以大幅度降低。音频导入设置都会影响它们在构建大小中的占用空间或运行游戏所需的内存。
- en: '![Audio](img/4691OT_09_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![音频](img/4691OT_09_07.jpg)'
- en: '**Force To Mono**: This setting converts multichannel audio into a single channel.
    While most devices are technically capable of playing stereo sounds, they do not
    always have the multiple speakers required for it to make a difference. Checking
    this box can significantly reduce the file size of the audio by combining all
    of the channels into a single, smaller one. Multichannel audio files are used
    to give the illusion of direction based on which speaker the sound is coming from.
    This essentially requires separate sound files for each speaker. Mono channel
    audio files use the same sound file for all speakers and thus require much less
    data and space in your game.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制单声道**：此设置将多声道音频转换为单声道。虽然大多数设备技术上能够播放立体声，但它们并不总是具有让声音产生差异所需的多个扬声器。勾选此框可以显著减小音频文件的大小，通过将所有声道合并为单个较小的声道。多声道音频文件用于根据声音来自哪个扬声器来制造方向感的错觉。这实际上需要为每个扬声器使用单独的音效文件。单声道音频文件对所有扬声器使用相同的音效文件，因此在游戏中需要的数据和空间要少得多。'
- en: '**Load In Background** and **Preload Audio Data**: These two settings work
    together to define when the audio information will be loaded and made ready to
    be played. The **Load In Background** parameter determines whether the game waits
    until the file is loaded before loading any other game data. Checking this box
    is a good idea for long or large files, such as background music. The **Preload
    Audio Data** parameter determines whether the files should be loaded as soon as
    possible. Any audio clips that you are going to need right away should have this
    option checked.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台加载**和**预加载音频数据**：这两个设置共同定义音频信息的加载和准备播放时间。**后台加载**参数决定游戏是否在其他游戏数据加载前等待文件加载完成。对于长或大的文件，如背景音乐，勾选此框是个好主意。**预加载音频数据**参数决定文件是否应尽快加载。对于你马上需要使用的任何音频剪辑，应该勾选这个选项。'
- en: '**Load Type**: This setting affects how much of the system''s memory will be
    used, while the game is running, to handle the loading of audio files. The **Decompress
    on Load** option uses maximum memory and is best for small, short sounds. The
    **Compressed in Memory** option only decompresses the file while it is playing,
    using a medium amount of memory, and is best for medium-sized files. The **Streaming**
    option means that only the part of the file that is currently being played is
    stored in the runtime memory. This is like streaming video or music from the Internet.
    This option is best for large files but should only be used by a few at one time.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载类型**：此设置影响游戏运行时，系统内存将使用多少来处理音频文件的加载。**加载时解压缩**选项使用最大内存，最适合小而短的声音。**内存中压缩**选项仅在播放时解压缩文件，使用中等数量的内存，最适合中等大小的文件。**流式传输**选项意味着只有当前正在播放的文件部分存储在运行时内存中。这就像从互联网上流式传输视频或音乐。这个选项最适合大文件，但一次应该只由少数几个使用。'
- en: '**Compression Format**: This determines what sort of data reduction to apply
    to the audio file to make it small enough to include in the game. The **PCM**
    format is going to preserve most of the original audio and will be the largest
    file size as a result. The **ADPCM** format will give you a medium level of compression,
    but it will also reduce some of the quality as a result. The **Vorbis** format
    can give you the smallest possible file size, but at the cost of maximum reduction
    in quality.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩格式**：这决定了要对音频文件应用哪种数据缩减，使其足够小以包含在游戏中。**PCM**格式将保留大部分原始音频，因此文件大小也将是最大的。**ADPCM**格式将提供中等程度的压缩，但也会因此降低一些质量。**Vorbis**格式可以为你提供尽可能小的文件大小，但以最大程度降低质量为代价。'
- en: '**Quality** and **Sample Rate Setting**: These control the amount of detail
    that will be preserved when you apply compression from the previous option. If
    the file size is still too large, you can reduce the overall quality to bring
    it within acceptable limits. However, reducing quality here comes at the cost
    of the sound quality. Always seek the lowest setting possible before artifacts
    are introduced and audible on your target device.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量和采样率设置**：这些控制当你应用前一个选项的压缩时，将保留多少细节。如果文件大小仍然过大，你可以降低整体质量以使其在可接受范围内。然而，降低质量会牺牲声音质量。在目标设备上出现可听见的伪迹之前，始终寻求最低的设置。'
- en: Player settings
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家设置
- en: Open your game's **Player Settings** window by going to Unity's toolbar and
    navigating to **Edit** | **Project Settings** | **Player**. In the platform-specific
    settings for Android, we have another few options under **Other Settings** that
    will affect the final size and speed of our game.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到Unity的工具栏，导航到**编辑** | **项目设置** | **玩家**，打开你的游戏的**玩家设置**窗口。在针对Android的平台特定设置中，我们在**其他设置**下还有几个选项，这些选项将影响我们游戏的最终大小和速度。
- en: Rendering
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染
- en: 'The **Rendering** group of settings control how your game will handle drawing
    your game on the screen. This controls the kind of lighting and shadow calculations
    that are used. It also allows you to optimize the number of calculations needed
    to draw the many objects that make up your game''s scene. The **Rendering** window
    can be seen in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染**设置组控制你的游戏如何在屏幕上绘制游戏。这控制了使用的光照和阴影计算类型。它还允许你优化绘制构成游戏场景的许多对象所需的计算数量。以下是**渲染**窗口的截图：'
- en: '![Rendering](img/4691OT_09_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![渲染](img/4691OT_09_08.jpg)'
- en: 'The settings that are seen in the **Rendering** window are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在**渲染**窗口中看到的设置如下：
- en: '**Rendering Path**: This set of options primarily controls the quality with
    which lights and shadows are rendered. The options under **Rendering Path** are
    as follows:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染路径**：这一组选项主要控制光照和阴影渲染的质量。**渲染路径**下的选项如下：'
- en: '**Forward**: This is going to be your most common setting. It supports real-time
    shadows from a single directional light. This option is your normal baseline for
    rendering light in Unity.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正向渲染**：这将是你的最常见设置。它支持来自单个方向光的实时阴影。这个选项是Unity中渲染光照的正常基准。'
- en: '**Deferred**: This is going to give you the highest quality lighting and shadow,
    but it will cost the most for the system to process it. Not every system is going
    to be able to support it, and it happens to be a Unity Pro-only feature.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟渲染**：这将为你提供最高质量的光照和阴影，但系统处理它的成本最高。并非每个系统都能支持它，而且它恰好是Unity Pro独有的功能。'
- en: '**Legacy Vertex Lit**: This rendering method is part of the old system. It
    is also the cheapest method to process. There are no real-time shadows with this
    method, and the lighting calculations are highly simplified. Older machines and
    mobile devices will default to this mode.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统顶点光照**：这种渲染方法是旧系统的一部分。它也是处理成本最低的方法。这种方法没有实时阴影，光照计算也高度简化。较旧的机器和移动设备将默认使用此模式。'
- en: '**Legacy Deferred (light prepass)**: This method is also part of the old system.
    The newer `Deferred` method is highly improved over this one and in general, this
    should not be used. You would only need to select this method if you have a special
    case or need to support a specific platform.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统延迟渲染（光照预通过）**：这种方法也是旧系统的一部分。较新的`延迟`方法对此进行了高度改进，通常来说，不应当使用这种方法。只有在有特殊案例或需要支持特定平台时，你才需要选择这种方法。'
- en: '**Multithreaded Rendering**: The process and series of steps used to run a
    program is called a thread. It is possible to start many of these threads and
    make them work on different parts of the program at the same time. Unity has utilized
    this feature of programming to increase the speed and quality of the rendering
    system. However, it requires a more powerful processor to run effectively.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程渲染**：运行程序的过程和步骤系列称为线程。可以启动许多这样的线程，并让它们同时处理程序的不同部分。Unity利用了编程的这一点，以提高渲染系统的速度和质量。然而，这需要一个更强大的处理器才能有效运行。'
- en: '**Static Batching**: This is a Unity Pro feature that allows Unity to significantly
    speed up rendering times by grouping identical objects that have been marked as
    static in the **Inspector**. For each group, it then renders one object in multiple
    places rather than rendering each object individually. Potentially, this setting
    can add some extra girth to your final build size because Unity will need to save
    extra information about your static objects to make this work.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态批处理**：这是Unity Pro的一个功能，通过将标记为静态的相同对象分组，可以显著提高渲染速度。对于每组，它然后在一个地方渲染一个对象，而不是单独渲染每个对象。这个设置可能会增加最终构建的大小，因为Unity需要保存关于静态对象的额外信息以实现这一功能。'
- en: '**Dynamic Batching**: This works in the same manner as **Static Batching**,
    but with two major differences. First, it is available to both Unity Pro and Basic
    users. Second, it groups objects that are not marked as static.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态批处理**：这与**静态批处理**的工作方式相同，但有两个主要区别。首先，它适用于Unity Pro和Basic用户。其次，它将未标记为静态的对象分组。'
- en: '**GPU Skinning**: This setting is less applicable for older mobile devices,
    and it is used more for the newest of mobile devices and other systems that have
    both a CPU and GPU. This allows the calculations that are normally done on meshes,
    that animate and are deformed by bones, to take place on the GPU instead of the
    CPU. This will free up resources for processing other parts of your game and giving
    your players the best experience possible.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU蒙皮**：这个设置对于较旧的移动设备不太适用，它更多地用于最新的移动设备和其他同时具有CPU和GPU的系统。这允许通常在网格上进行的计算，如通过骨骼进行动画和变形的计算，在GPU上进行而不是CPU。这将释放资源以处理游戏的其他部分，为玩家提供最佳体验。'
- en: Optimization
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**优化**'
- en: 'The **Optimization** group of settings allows you to adjust how Unity will
    compile your project and the assets involved. Each setting should be given careful
    consideration when you approach the final build of your game. Altogether, these
    settings have the potential to make a huge difference in how well your game runs.
    The **Optimization** window is shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化**设置组允许你调整Unity编译项目及涉及资源的方式。在接近游戏最终构建时，每个设置都应该仔细考虑。总的来说，这些设置有可能极大地影响你的游戏运行效果。以下是**优化**窗口的截图：'
- en: '![Optimization](img/4691OT_09_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/4691OT_09_09.jpg)'
- en: '**Api Compatibility Level**: This setting determines which set of the .NET
    functions to include in the final build. The **.Net 2.0** option will include
    all of the available functions, making the largest footprint. The **.Net 2.0 Subset**
    option is a smaller portion of the functions and includes only the functions that
    your programming is most likely to use. Unless you need some special functionality,
    the **.Net 2.0 Subset** option should always be the option that you choose.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API兼容性级别**：此设置决定了最终构建中包含哪一组.NET函数。"**.Net 2.0**"选项将包括所有可用的函数，产生最大的占用空间。"**.Net
    2.0子集**"选项是函数的一小部分，仅包括你的编程最有可能使用的函数。除非你需要一些特殊功能，否则应始终选择"**.Net 2.0子集**"选项。'
- en: '**Prebake Collision Meshes**: This box saves time when you load your levels,
    by moving the physics calculations from the scene load to the game build. It means
    your build size will be large but the processing speed will be reduced.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预烘焙碰撞网格**：此选项通过将物理计算从场景加载移动到游戏构建来节省你加载关卡时的时间。这意味着你的构建大小会增大，但处理速度会降低。'
- en: '**Preload Shaders**: When a mesh uses a new shader that has not yet been used
    in the game scene, the system needs to process and calculate how that shader will
    render objects. This box will process that information when the scene starts and
    avoid potential stalls in your game while it tries to do the calculations.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预加载着色器**：当一个网格使用尚未在游戏场景中使用的新着色器时，系统需要处理并计算该着色器将如何渲染物体。此选项将在场景开始时处理该信息，以避免在尝试进行计算时可能导致游戏停滞。'
- en: '**Preloaded Assets**: This option does the same thing as the previous one,
    but for assets and prefabs instead of shaders. When you first instantiate an object,
    it needs to be loaded into memory. This will change it so that all of the assets
    in this list are loaded when the scene starts.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预加载资源**：此选项与之前的选项相同，但它是为着色器以外的资源和预制件而设的。当你首次实例化一个对象时，它需要被加载到内存中。这将改变为在场景开始时加载此列表中的所有资源。'
- en: '**Stripping Level**: This setting is a Unity Pro only feature. It allows you
    to reduce the size of your final build by removing all of the excess code before
    compiling it. System functions are grouped into what are called libraries for
    easy reference. The **Strip Assemblies** option removes the unused libraries from
    the final build. The **Use micro mscorlib** option performs the same function
    as the previous option but utilizes a minimized form of the libraries. While significantly
    smaller, this library possesses fewer functions for your code to use. However,
    unless your game is complex, this should not make a difference.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剥离级别**：此设置是Unity Pro版独有的功能。它允许你在编译前通过移除所有多余的代码来减少最终构建的大小。系统功能被分组到所谓的库中以便于引用。"**Strip
    Assemblies**"选项会从最终构建中移除未使用的库。"**使用微型的mscorlib**"选项执行与前一选项相同的操作，但使用的是库的最小化形式。尽管这个库显著较小，但它可供你的代码使用的函数较少。然而，除非你的游戏非常复杂，否则这不应造成影响。'
- en: '**Enable Internal Profiler**: This option lets you retrieve information about
    how your game is running on a device. It does introduce a little bit of overhead
    to process the information while your game is running, but the effect is less
    than what Unity Editor introduces. The information can be retrieved using the
    `adb logcat` command in the command prompt.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用内部分析器**：此选项允许你获取关于游戏在设备上运行的信息。这确实会在游戏运行时处理信息的过程中引入一些开销，但其影响小于Unity编辑器引入的开销。通过在命令提示符中使用`adb
    logcat`命令可以获取这些信息。'
- en: '**Optimize Mesh Data**: This setting will remove extra information from all
    of your meshes that are not being used by any materials that are applied to them.
    This includes **Normals**, **Tangents**, and a few other bits of information.
    It also causes the triangle data that makes up the mesh to be reordered for optimal
    processing and rendering. Unless you have a very special case, this is a good
    box to always check.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格数据**：此设置将从所有网格中移除任何未由应用在它们上面的材质使用的额外信息。这包括**法线**、**切线**以及其他一些信息。它还会导致构成网格的三角形数据为最佳处理和渲染而重新排序。除非你有非常特殊的情况，否则这是一个始终应该勾选的好选项。'
- en: Tracking performance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪性能
- en: Unity provides us with many tools that allow us to determine how well our game
    is running. The first tool that we will be covering is readily available for both
    Unity Pro and Basic users. However, the information is rather limited, though
    it is still useful. The second tool is only available to Unity Pro users. It provides
    significantly more detail and information on performance. Finally, we will create
    our own tool, allowing us to view the performance of our scripts in detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为我们提供了许多工具，让我们可以确定游戏运行得有多好。我们将要介绍的第一款工具对Unity专业版和基础版用户都是现成的。然而，这些信息相当有限，尽管它仍然有用。第二款工具仅对Unity专业版用户开放。它提供了更多关于性能的详细信息和数据。最后，我们将创建自己的工具，让我们可以详细查看脚本的性能。
- en: Editor statistics
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器统计
- en: 'In the top-right corner of the **Game** window, there is a button labeled **Stats**.
    Clicking on this button will open a window that will give us information about
    how the game is running and how long it will take to process. Most of the information
    in this window concerns how well the game is being rendered, largely amounting
    to how many objects are currently on the screen, how many are animating, and how
    much memory they take up. Additionally, there is also some information about the
    sound in the game and any network traffic that might be occurring. The **Stats**
    tab is displayed in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在**游戏**窗口的右上角，有一个标有**统计**的按钮。点击这个按钮会打开一个窗口，为我们提供有关游戏运行情况以及处理所需时间的信息。这个窗口中的大多数信息关注的是游戏渲染的好坏，主要涉及到当前屏幕上的对象数量、正在动画的对象数量以及它们占用的内存量。此外，还有一些关于游戏中声音以及可能发生的任何网络流量的信息。以下截图显示了**统计**标签：
- en: '![Editor statistics](img/4691OT_09_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器统计](img/4691OT_09_10.jpg)'
- en: 'The **Audio** section concerns the various audio clips that are playing in
    your scene. It contains information about how loud your game is and how much memory
    is required to process it all. The **Audio** section consists of the following
    details:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频**部分关注场景中播放的各种音频剪辑。它包含有关游戏音量以及处理所有这些音频所需的内存信息。**音频**部分包括以下详细信息：'
- en: '**Level**: This is how loud your game is in decibels. It is really just a special
    form of volume measurement and represents a total for every audio clip that is
    playing in your game.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别**：这是游戏音量的大小，以分贝为单位。它实际上只是一种特殊的音量测量形式，并代表游戏中正在播放的每个音频剪辑的总和。'
- en: '**DSP load**: This is the cost in processing the digital audio clips in your
    scene. It is represented as a percentage of the memory used by your game.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DSP负载**：这是处理场景中数字音频剪辑的成本。它表示为游戏使用的内存的百分比。'
- en: '**Clipping**: This is the percentage of your audio files that are simply not
    played because of the overload on the system. Based on the power of your device''s
    processor, the device can only play a limited number of audio clips at one time.
    Any extra audio clips are ignored based on the priority setting in the **Inspector**
    panel of the **Audio Source** component.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剪辑**：这是由于系统过载而没有播放的音频文件百分比。根据设备处理器的性能，设备一次只能播放有限数量的音频剪辑。根据**检查器**面板中**音频源**组件的优先级设置，任何额外的音频剪辑都会被忽略。'
- en: '**Stream load**: This is the cost involved in processing any audio that must
    be streamed as it is being played. It is again a percentage of the memory used.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流加载**：这是处理任何必须边播放边流的音频所需的成本。它同样是使用内存的百分比。'
- en: 'The **Graphics** section is concerned with the rendering of your game and the
    memory required in doing this. It contains information about how fast the game
    is running, how many objects are being rendered, and how detailed the objects
    are. Most of the time, when using the **Stats** window, you will be looking at
    this section. The **FPS** value to the right of this group heading is an excellent
    estimation of how fast your game is running. This is the number of frames being
    processed in one second, followed by the number of milliseconds it takes to process
    a single frame of your game. The **Graphics** section consists of the following
    details:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形**部分关注的是游戏的渲染以及进行此操作所需的内存。它包含有关游戏运行速度、正在渲染的对象数量以及对象细节程度的信息。大多数时候，在使用**统计**窗口时，你会查看这个部分。此分组标题右侧的**FPS**值是估计游戏运行速度的一个很好的指标。这是每秒处理的帧数，后面是处理游戏中单个帧所需的时间（毫秒）。**图形**部分包括以下详细信息：'
- en: '**CPU**: This section breaks down into two pieces. The **main** piece is how
    long it takes to process the code that is used to run your game. The **render
    thread** piece is how long it takes to draw all the parts of your game on the
    screen. Together, you can get a good idea of what is taking the most time to run
    in your game.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：这一部分分为两个小节。**主要**的部分是处理运行游戏所使用代码所需的时间。**渲染线程**的部分是在屏幕上绘制游戏所有部分所需的时间。结合起来，你可以了解到游戏中运行最耗时的部分。'
- en: '**Batches**: When using **Static** or **Dynamic Batching**, found in the **Rendering**
    group of **Player Settings**, the first number denotes how many groups were created
    for the batch rendering pass and the **Saved by batching** value is the number
    of draw calls that were avoided because of the batching process. The more saved
    means that less work was done to draw your game on the screen.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：当使用**玩家设置**中**渲染**组内的**静态**或**动态批处理**时，第一个数字表示为批渲染过程创建了多少组，**通过批处理节省**的值是因为批处理过程而避免的绘制调用次数。节省的越多，意味着在屏幕上绘制游戏所需的工作量越少。'
- en: '**Tris**: Ultimately, every model in 3D graphics is made from a series of triangles.
    This value is the total number of triangles that are seen and are being rendered
    by the cameras in your scene. Fewer triangles means that the graphics process
    has to do less work to draw a model on the screen.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角形**：最终，3D图形中的每个模型都是由一系列三角形组成的。这个值是场景中相机看到并渲染的三角形总数。三角形越少，图形处理在屏幕上绘制模型时所需的工作量就越少。'
- en: '**Verts**: Most of the information in a model file is concerned with the world
    position, normal orientation, and texture position of each vertex. This value
    is the total number of vertexes seen and rendered by the camera. The lower the
    number of vertexes for each model, the faster it will be calculated for rendering.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点**：模型文件中的大部分信息与每个顶点的世界位置、法线方向和纹理位置有关。这个值是相机看到并渲染的顶点总数。每个模型顶点的数量越少，计算渲染的速度就越快。'
- en: '**Screen**: This is the current width and height, in pixels, of the **Game**
    window. It also displays the amount of memory that is needed for rendering at
    that size. A smaller size results in less detail for your game, but it also makes
    the game easier to render.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕**：这是当前**游戏**窗口的宽度和高度，以像素为单位。同时显示该尺寸渲染所需的内存量。较小的尺寸会减少游戏的细节，但也使得游戏更容易渲染。'
- en: '**SetPass calls**: This is essentially the number of times the different parts
    of a shader need to be called to draw everything in your scene on the screen.
    It is based more on the number of different materials in your scene than the number
    of objects.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetPass 调用**：这基本上是绘制场景中所有内容在屏幕上时，需要调用着色器不同部分的次数。它更多地基于场景中不同材质的数量，而不是物体的数量。'
- en: '**Shadow casters**: This statistic is used when you make use of real-time shadows.
    Real-time shadows are expensive. If possible, they should not be used on mobile
    devices. However, if you have to have them, minimize the number of objects that
    cast shadows. Limit it to move objects that are large enough for the user to see
    the shadow. Small, static objects especially do not need to cast shadows.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影投射器**：当你使用实时阴影时，会用到这个统计信息。实时阴影是昂贵的。如果可能，不应在移动设备上使用。然而，如果你必须使用它们，请尽量减少投射阴影的物体数量。仅限于那些用户能够看到阴影的大物体。特别是小型静态物体不需要投射阴影。'
- en: '**Visible skinned meshes**: This is the total number of rigged objects that
    are currently in the view of the camera. Skinned meshes are often going to be
    your characters and just about anything else that animates. They are more expensive
    to render than static meshes because of the extra calculations that are needed
    to make them move and change with animation.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见的蒙皮网格**：这是当前在相机视图中带有骨骼的物体总数。蒙皮网格通常是你的角色以及任何会动的东西。由于需要额外的计算来使它们移动和随动画变化，所以它们比静态网格更昂贵。'
- en: '**Animations**: This is simply the total number of animations playing in the
    scene.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：这只是场景中正在播放的动画总数。'
- en: The **Network** group of statistics only becomes visible when it is connected
    to other players in a multiplayer game. The information generally amounts to how
    many people the game is connected to and how fast those connections are.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当在多人游戏中连接到其他玩家时，**网络**统计信息组才会可见。这些信息通常包括游戏连接的人数以及这些连接的速度。
- en: The Profiler
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析器
- en: 'The **Profiler** window, found in Unity''s toolbar by navigating to **Window
    | Profiler**, is a great tool for analyzing how your game is running. It gives
    us a colorful breakdown of each part of our system and how much work it is doing.
    The only really unfortunate part of this tool is that it is only available to
    Unity Pro users. The **Profiler** window is shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析器**窗口，在Unity的工具栏中通过导航到**窗口 | 分析器**找到，是分析游戏运行情况的一个很好的工具。它为我们提供了系统每个部分及其工作量的多彩分解。这个工具唯一真正不幸的部分是它仅对Unity
    Pro用户可用。以下截图显示了**分析器**窗口：'
- en: '![The Profiler](img/4691OT_09_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![分析器](img/4691OT_09_11.jpg)'
- en: By first opening the **Profiler** window, we can then play our game in the window
    and watch the tool give us a fairly detailed breakdown of what is going on. We
    can click on any point and see detailed information about that frame at the bottom
    of the window. The information provided is specific to the point, such as **CPU
    Usage**, **Rendering**, **Memory**, and so on, that you clicked on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开**分析器**窗口，然后我们可以在窗口中玩游戏，并观察工具为我们提供相当详细的正在进行中的情况分解。我们可以点击任何点，并在窗口底部查看有关该帧的详细信息。提供的信息与您点击的点的特定信息有关，如**CPU使用率**、**渲染**、**内存**等。
- en: The **CPU Usage** information is particularly useful when we are trying to find
    parts of our game that are taking too long to process. Spikes in processing cost
    stand out pretty easily. By clicking on a spike, we can see the breakdown of what
    each part of the game played in making that frame expensive. For most of these
    parts, we can dig down to the exact object or function that is causing the issue.
    However, we can only get down to the function level. Just because we know where
    an issue in the code generally is, the **Profiler** window will not tell us exactly
    which part of that function is causing the issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU使用率**信息在尝试查找游戏中处理时间过长的部分时特别有用。处理成本的高峰非常容易凸显出来。点击一个高峰，我们可以看到游戏中的每个部分在使这一帧变得昂贵时的分解情况。对于这些部分中的大多数，我们可以深入到导致问题的确切对象或函数。然而，我们只能定位到函数级别。仅仅因为我们知道代码中问题的大概位置，**分析器**窗口并不会告诉我们具体是函数的哪部分导致了问题。'
- en: In order to actually work, the Profiler needs to hook into every part of your
    game. This introduces a little extra cost in the speed of your game. Therefore,
    when analyzing the information provided, it is best to consider the relative costs
    rather than hold each cost as an exact value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际工作，分析器需要挂接到游戏的每个部分。这会在游戏速度上引入一些额外的成本。因此，在分析提供的信息时，最好考虑相对成本，而不是将每个成本视为一个确切值。
- en: Tracking script performance
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪脚本性能
- en: 'All of these tools that Unity provides are great, but they are not always the
    right solution. The Unity Basic user does not have access to the **Profiler**
    window. In addition, both **Profiler** and **Editor Statistics** are fairly generalized.
    We can get a little more detail with the **Profiler**, but the information is
    not always enough without you having to dig through a bunch of menus. In this
    next part, we will create a special script that is capable of tracking the performance
    of specific parts of any script. It should definitely become a regular piece of
    your developer kit. Let''s use these steps to create the script in our Monkey
    Ball game:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供的所有这些工具都很好，但它们并不总是正确的解决方案。Unity基础用户无法访问**分析器**窗口。此外，**分析器**和**编辑器统计**相对泛化。我们可以通过**分析器**获得更多细节，但信息并不总是足够，除非你不得不浏览一堆菜单。在下一部分中，我们将创建一个特殊的脚本，能够跟踪任何脚本特定部分的性能。它绝对应该成为您开发工具包中的常备部分。让我们按照以下步骤在我们的Monkey
    Ball游戏中创建脚本：
- en: First, we will need a special class that will keep track of our performance
    statistics. To do this, create a new script and name it `TrackerStat`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个特殊的类来跟踪我们的性能统计数据。为此，创建一个新脚本，并将其命名为`TrackerStat`。
- en: 'To begin this script, we need to enable the ability to interact with the various
    GUI elements. Go to the very top of the script and add this line next to the other
    lines that begin with `using`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个脚本，我们需要启用与各种GUI元素交互的能力。转到脚本的最顶部，并在以`using`开头的其他行旁边添加这一行：
- en: '[PRE0]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to change the class definition line. We do not want or need to
    extend the `MonoBehaviour` class. So, find the following line of code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改类定义行。我们不希望或需要扩展`MonoBehaviour`类。因此，找到以下代码行：
- en: '[PRE1]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And, change it to the following code:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将其更改为以下代码：
- en: '[PRE2]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This script starts with four variables. The first variable will be used as
    an ID, allowing us to track multiple scripts at once by supplying different key
    values. The second variable will keep track of the average amount of time that
    the tracked bits of code will take. The third variable is just the total number
    of times the tracked code has been called. The fourth variable is the longest
    time the code has taken to execute:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从四个变量开始。第一个变量将用作 ID，通过提供不同的键值，我们可以同时跟踪多个脚本。第二个变量将跟踪被跟踪代码段平均所需的时间。第三个变量只是被跟踪代码被调用的总次数。第四个变量是代码执行所需的最长时间：
- en: '[PRE3]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we have two more variables. These will do the work of actually tracking
    how long the script takes to execute. The first variable includes the time when
    the tracking starts. The second variable is a flag that marks that tracking has
    started.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还有两个变量。它们将实际跟踪脚本执行所需的时间。第一个变量包括跟踪开始的时间。第二个变量是一个标记，表示跟踪已开始。
- en: '[PRE4]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The third and last batch of variables for this script is used to store references
    to the Text objects that will actually display our stat information:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本脚本的第三组也是最后一组变量用于存储实际显示我们状态信息的 Text 对象的引用：
- en: '[PRE5]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first function for this script is `Open`. This function is called when we
    want to start tracking a bit of code. It first checks to see whether the code
    is already being tracked. If it is, then it uses `Debug.LogWarning` to send a
    warning to the **Console** window. Next, it sets the flag marking that the code
    is being tracked. Finally, the function tracks the time it was called by using
    `Time.realtimeSinceStartup`, which contains the actual number of seconds since
    the game started.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本脚本的第一个函数是`Open`。当我们想要开始跟踪一段代码时，会调用这个函数。它首先检查代码是否已经被跟踪。如果是，那么它会使用`Debug.LogWarning`向**控制台**窗口发送警告。接下来，它设置标记表示代码正在被跟踪。最后，该函数通过使用`Time.realtimeSinceStartup`跟踪调用它的时刻，其中包含自游戏开始以来的实际秒数。
- en: '[PRE6]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next function, `Close`, acts as the opposite of the previous one. It is
    called when we have reached the end of the code that we want to track. The time
    when the tracking should stop is passed to it. This is done to minimize excess
    code from being executed. As with the previous function, it checks to see whether
    tracking is being done and sends out another warning and exits early if the function
    is not being tracked. Next, the `isOpen` flag is cleared by setting it to `false`.
    Finally, the amount of time since tracking was opened is calculated and the `AddValue`
    function is called.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数`Close`起到了前一个函数的相反作用。当我们要跟踪的代码结束时会被调用。跟踪应该停止的时间被传递给它。这是为了尽量减少执行多余的代码。与上一个函数一样，它会检查是否正在跟踪，如果该函数没有被跟踪，它会发出另一个警告并提前退出。接下来，通过将`isOpen`标志设置为`false`来清除它。最后，计算自跟踪开始以来的时间，并调用`AddValue`函数。
- en: '[PRE7]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AddValue` function is passed `callLength`, which is the length of time
    that the tracked bit of code took. It then uses some calculations to add the value
    to `averageTime`. Next, the function compares the current `longestCall` with the
    new value and updates it, if the new one is greater than the current one. The
    function then increments `totalCalls` before finally updating the text on screen
    with the new values.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddValue`函数接收`callLength`，即跟踪的代码段执行所需的时间长度。然后它使用一些计算将值添加到`averageTime`中。接下来，该函数将当前的`longestCall`与新的值进行比较并更新它，如果新的值大于当前的值。然后函数增加`totalCalls`，最后在屏幕上更新显示新值的文本。'
- en: '[PRE8]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last function for our script, `CreateTexts`, is called when we first create
    an instance of this class to track some bit of code. It first calculates the vertical
    position of the GUI elements. By using the `ScriptTracker.NewLabel` function,
    which we will create in our next script, we can save ourselves some work; it automatically
    handles the creation and basic setup of the Text objects that are needed to display
    the stat information. We just need to pass a name to it to use it in the **Hierarchy**
    window and set the position and size when it gives us the new object.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的脚本中最后一个函数`CreateTexts`在我们首次创建此类实例以跟踪某段代码时被调用。它首先计算 GUI 元素的垂直位置。通过使用我们将在下一个脚本中创建的`ScriptTracker.NewLabel`函数，我们可以节省一些工作量；它会自动处理创建和基本设置显示状态信息的
    Text 对象。我们只需传递一个名称以在**层次结构**窗口中使用它，并在它给我们新对象时设置位置和大小。
- en: '[PRE9]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we need to create another new script and name it `ScriptTracker`. This
    script will allow us to do actual performance tracking.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建另一个新脚本，并将其命名为`ScriptTracker`。这个脚本将允许我们进行实际性能跟踪。
- en: 'Just like we did for the previous script, we need to add a new line at the
    very top of the script next to the other `using` lines so that the script can
    create and interact with GUI objects:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们对上一个脚本所做的那样，我们需要在脚本顶部的其他`using`行旁边添加一行，以便脚本可以创建和与GUI对象交互。
- en: '[PRE10]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This script starts off with a single variable. This variable maintains all
    of the stats that are currently being tracked. Note the use of `static` here;
    it allows us to easily update the list from anywhere in the game:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从一个单一变量开始。这个变量维护当前正在跟踪的所有状态。注意这里使用的`static`；它允许我们从游戏中的任何地方轻松更新列表：
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first function for this script, `Open`, allows us to start tracking the
    code's execution. It uses the `static` flag, so the function can be called easily
    by any script. A `key` value is passed to the function, allowing us to group track
    calls. The function starts by creating a variable to hold the index of the stat
    to start tracking. Next, it loops through the current set of stats to find a matching
    `key` value. If one is found, the `index` variable is updated with the value and
    the loop is exited.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本脚本的第一个函数`Open`允许我们开始跟踪代码的执行。它使用`static`标志，因此任何脚本都可以轻松调用该函数。一个`key`值被传递给函数，允许我们将跟踪调用分组。函数首先创建一个变量来保存要开始跟踪的状态的索引。接下来，它遍历当前的状态集以找到匹配的`key`值。如果找到，将更新`index`变量并退出循环。
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Open` function continues by checking whether a stat was found. The `index`
    variable will be less than zero only if we make it through the whole loop of current
    stats and are unable to find a matching `key`. If one is not found, we first check
    to see whether the list of stats is empty and if it is empty, we create some display
    labels by calling the `CreateLabels` function. We then call `AddNewStat` to set
    up the new stat for tracking. We will create both of these functions shortly.
    The `index` is then set to that of the new stat. Finally, the stat is triggered
    to start tracking by using the stat's `Open` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Open`函数继续检查是否找到了状态。只有当我们遍历完当前状态列表并且找不到匹配的`key`时，`index`变量才会小于零。如果没有找到，我们首先检查状态列表是否为空，如果为空，我们通过调用`CreateLabels`函数创建一些显示标签。然后我们调用`AddNewStat`来设置新的跟踪状态。我们很快就会创建这两个函数。然后`index`被设置为新的状态的索引。最后，通过使用状态的`Open`函数触发状态开始跟踪。'
- en: '[PRE13]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AddNewStat` function is passed the key of the stat that is to be created.
    It starts by storing the list of stats in a temporary variable and increasing
    the size of the stats list by one. Each value is then transferred from the temp
    list to the larger stats list. Finally, a new stat is created, and it is assigned
    to the last slot in the stats list. Then, the `key` is set and its `CreateTexts`
    function is called so that it can display on screen.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddNewStat`函数接收要创建的状态的键。它首先将状态列表存储在一个临时变量中，并将状态列表的大小增加一个。然后，每个值从临时列表转移到更大的状态列表中。最后，创建一个新状态，并将其分配到状态列表的最后一个槽位。然后，设置`key`并调用其`CreateTexts`函数，以便它可以在屏幕上显示。'
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we have the `Close` function. This function is passed the key value of
    the stat to be closed. It starts by finding the time when the function was called,
    minimizing the amount of excess code that will be tracked. It continues by looping
    through the list of stats to find a matching `key`. If one is found, the stat's
    `Close` function is called and the function is exited. If a match is not found,
    `Debug.LogError` is called to send an error message to the **Console** window.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`Close`函数。这个函数接收要关闭的状态的键值。它首先找到调用函数的时间，以最小化将跟踪的额外代码量。然后通过遍历状态列表找到匹配的`key`。如果找到，将调用状态的`Close`函数并退出。如果没有找到匹配项，将调用`Debug.LogError`向**控制台**窗口发送错误消息。
- en: '[PRE15]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `CreateLabels` function handles the creation of text labels on the screen,
    so we can easily tell what each bit of displayed information means. Just like
    our previous script, it uses the `NewLabel` function to handle the basic creation
    of the text objects, passing it a name to be displayed in the **Hierarchy** window.
    It then sets the text to be displayed on the screen, positions it along the top-left
    corner of the screen, and sets its size.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateLabels`函数处理屏幕上文本标签的创建，这样我们可以轻松地了解每一段显示信息的含义。就像我们之前的脚本一样，它使用`NewLabel`函数来处理文本对象的基本创建，传递一个在**层次结构**窗口中显示的名称。然后设置要在屏幕上显示的文本，将其定位在屏幕左上角，并设置其大小。'
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last static function for this script is the `NewLabel` function. It handles
    the basic creation of each text object that we are using in the rest of the script.
    It first tries to find the canvas object and creates a new one if it can't be
    found. To use our text objects, we need the canvas so that they can actually be
    drawn.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本的最后一个静态函数是`NewLabel`函数。它处理我们在脚本其余部分使用的每个文本对象的基本创建。它首先尝试查找画布对象，如果找不到则创建一个新的。为了使用我们的文本对象，我们需要画布，这样它们实际上才能被绘制。
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, the `NewLabel` function creates a new **GameObject** by using the name
    that was passed to it and making it a child of the canvas. It then adds the `RectTransform`
    component so that it can position itself in 2D space and anchors it to the top-left
    corner. The text object is then given a `CanvasRenderer` component so that it
    can actually draw on the screen and a `Text` component so it is actually a text
    object. We then use the `Resources.GetBuiltinResource` function to grab Unity's
    default `Arial` font for the text object before returning it to the caller of
    the function.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`NewLabel`函数通过使用传递给它的名称创建一个新的**GameObject**，并将其设置为画布的子对象。然后它添加了`RectTransform`组件，以便它可以在2D空间中定位自己，并将其锚定在左上角。然后给文本对象一个`CanvasRenderer`组件，这样它实际上可以在屏幕上绘制，并添加一个`Text`组件，这样它实际上就是一个文本对象。然后我们使用`Resources.GetBuiltinResource`函数为文本对象获取Unity的默认`Arial`字体，再将其返回给函数的调用者。
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test these scripts, open your `BananaBounce` script. At the beginning of
    the `Update` function, add the following line to start tracking how long it takes
    to run:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试这些脚本，请打开你的`BananaBounce`脚本。在`Update`函数的开始处，添加以下行以开始跟踪运行所需的时间：
- en: '[PRE19]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the end of the `Update` function, we need to call the `Close` function with
    the same key:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数的末尾，我们需要用相同的键调用`Close`函数：
- en: '[PRE20]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, start the game and take a look at the results (shown in the following
    screenshot):![Tracking script performance](img/4691OT_09_12.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动游戏并查看结果（如下截图所示）:![跟踪脚本性能](img/4691OT_09_12.jpg)
- en: We created a tool for testing specific parts of code. By wrapping any bit of
    code in calls to the functions and sending a unique ID, we can determine how long
    it takes to execute the code. By averaging out the calls to the script and wrapping
    different parts of code, we can determine exactly which parts of a script are
    taking the longest time to complete. We can also find out whether the parts of
    code have been called too many times. Both cases are ideal points to look at for
    minimizing processing and lag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个用于测试代码特定部分的工具。通过将任何代码片段包裹在函数调用中，并发送一个唯一的ID，我们可以确定执行代码需要多长时间。通过平均调用脚本，并包裹代码的不同部分，我们可以确切地确定脚本中哪些部分需要最长的时间来完成。我们还可以找出代码部分是否被调用得太多次。这两种情况都是优化处理和减少延迟的理想点。
- en: Be sure to remove any references to this tool before you deploy your game. If
    it is left in the final levels, it can add an unnecessary amount of load on the
    CPU. This adverse effect on the game could make the game unplayable. Always remember
    to clear out any uses of tools that are exclusively for Editor debugging.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署游戏之前，请确保删除与此工具的所有引用。如果它被留在最终关卡中，可能会增加不必要的CPU负载。这种对游戏的不良影响可能导致游戏无法玩。一定要记得清除那些仅用于编辑器调试的工具使用情况。
- en: Minimizing lag
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化延迟
- en: Lag is one of those nebulous ideas used to describe an application that is slower
    than expected. It is most commonly seen and recognized in an application's frame
    rate. Most games run at about 60 FPS and are considered to be lagging if they
    drop to 30 FPS or less. However, lag and its issues run deeper and include issues
    such as input responsiveness, internet connectivity, and file reading/writing.
    As developers, we constantly fight against providing the highest quality experience
    we can, while maintaining the speeds and responsiveness that users expect. It
    essentially amounts to whether or not the processor on the user's device can handle
    the cost of providing the game experience. A few, simple objects in your game
    will result in fast processing, but several complex objects will require the most
    processing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是用于描述比预期慢的应用程序的一个模糊概念。它最常见于应用程序的帧率中。大多数游戏以大约60 FPS的速度运行，如果降至30 FPS 或更低，则被认为是延迟的。然而，延迟及其问题更深层次，包括输入响应性、网络连接以及文件读写等问题。作为开发者，我们不断努力提供尽可能高的体验质量，同时保持用户期望的速度和响应性。这基本上取决于用户设备上的处理器是否能够处理提供游戏体验的成本。游戏中的几个简单对象将导致快速处理，但几个复杂对象将需要最多的处理。
- en: Occlusion
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遮挡剔除
- en: Occlusion is great for games with a lot of objects. In its basic form, anything
    that is at the sides or behind the camera is not seen and therefore not drawn.
    In Unity Pro, we are able to set up occlusion culling. This will calculate what
    can actually be seen by the camera and not draw anything that is blocked from
    view. There is a balance that has to be achieved when using these tools. The cost
    of calculating what cannot be seen needs to be less than the cost of just drawing
    the objects. There are no solid numbers for how long a scene might take to render.
    It all depends on the render settings that you have chosen and the detail in your
    models and textures. As a rule of thumb, if you have many small objects that are
    regularly blocked from view by larger objects, occlusion culling is the right
    choice.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡对于拥有大量对象的游戏来说非常有效。在其基本形式中，任何在摄像机侧面或后面的内容都是不可见的，因此不会绘制。在 Unity Pro 中，我们可以设置遮挡剔除。这将计算摄像机实际可以看到的内容，并且不绘制任何被遮挡的视图。在使用这些工具时，必须达到一个平衡。计算不可见内容所需的成本需要小于直接绘制对象的成本。没有确切的数字可以表示一个场景可能需要多长时间来渲染。这完全取决于你所选择的渲染设置以及模型和纹理的细节。作为一个经验法则，如果你有许多经常被较大对象遮挡的小对象，那么选择遮挡剔除是正确的。
- en: 'We will add occlusion culling to the Tank Battle game because it is the only
    one with anything large enough to regularly block objects from view. Let''s set
    it up with these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为坦克大战游戏添加遮挡剔除，因为它是唯一一个有足够大的对象来经常遮挡视图的游戏。让我们按照以下步骤进行设置：
- en: Open up the Tank Battle game now. If you completed the challenges and added
    the extra debris and obstacles, this section will be particularly effective for
    you.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开坦克大战游戏。如果你完成了挑战并添加了额外的碎片和障碍物，这一部分将对你特别有效。
- en: Open the Occlusion window by going to Unity's toolbar and navigate to **Window**
    | **Occlusion Culling**. This window is your primary point of access for modifying
    the various settings associated with occlusion in your game. Unfortunately, this
    is a Unity Pro only feature. If you try to open the window while in Unity Basic,
    this will result in nothing more than an error message in the **Console**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 Unity 的工具栏并导航到**窗口** | **遮挡剔除**来打开遮挡窗口。这个窗口是修改与游戏中遮挡相关的各种设置的主要入口。不幸的是，这是一个仅限
    Unity Pro 的功能。如果你在 Unity Basic 中尝试打开该窗口，除了在**控制台**中收到错误消息外，不会有任何结果。
- en: Switch to the **Bake** page and we can take a look at the options associated
    with occlusion culling:![Occlusion](img/4691OT_09_13.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**烘焙**页面，我们可以查看与遮挡剔除相关的选项：![遮挡](img/4691OT_09_13.jpg)
- en: '**Smallest Occluder**: This should be set to the size of the smallest thing
    that can block other things from view. Things like large boulders and houses make
    good occluders. Smaller things like furniture or books are generally too small
    to block anything of significance from view.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小遮挡体**：这应该设置为可以阻挡其他物体视野的最小物体的尺寸。像大石头和房子这样的事物是很好的遮挡体。像家具或书籍这样的小物体通常太小，无法阻挡任何重要的视野。'
- en: '**Smallest Hole**: This is the smallest gap in your scene through which you
    can see other objects. Smaller values require more detailed calculations. Larger
    values are less costly but are more likely to cause objects to flicker in and
    out of view as the player moves around.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小孔洞**：这是场景中可以看到其他对象的最小缝隙。较小的值需要更详细的计算。较大的值成本较低，但更有可能导致对象随着玩家的移动而在视野中闪烁。'
- en: '**Backface Threshold**: This setting causes the system to do extra checks for
    objects that might be inside others. A value of `100` means no checks will be
    done and the calculation time will be saved. A value of `5` will require a bunch
    of extra calculations to figure out where everything is in relation to each other.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背面阈值**：这个设置让系统对可能位于其他对象内部的对象进行额外检查。值为`100`意味着不进行检查，从而节省计算时间。值为`5`将需要进行大量额外的计算，以确定所有对象相对于彼此的位置。'
- en: For our purposes at this point, the defaults will work fine. You ideally want
    to find settings that are balanced between the reduced cost of rendering and the
    cost of calculating what should be rendered.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前阶段，对于我们来说，默认设置将工作得很好。你理想的情况是找到一组在渲染成本降低和计算应渲染内容成本之间平衡的设置。
- en: In order to make the occlusion system work with dynamic objects, we need to
    set up a number of occlusion areas. To create them, create an empty **GameObject**
    and add an **Occlusion Area** component that can be found in Unity's toolbar by
    navigating to **Component** | **Rendering** | **Occlusion Area**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让遮挡系统与动态对象一起工作，我们需要设置多个遮挡区域。要创建它们，请创建一个空的**GameObject**，并添加一个在Unity工具栏中通过导航到**Component**
    | **Rendering** | **Occlusion Area**可以找到的**Occlusion Area**组件。
- en: You will need to create and manipulate several of these objects. They need to
    cover the whole area where any dynamic objects and the camera can be located.
    To this end, create and position enough areas to cover the streets of our game.
    Their size can be edited just as when working with the **Box Collider** components.
    You can also use the little cylinders on each side of the area to manipulate the
    field. Be sure to make them tall enough to cover all of your targets (as you can
    see in the following screenshot):![Occlusion](img/4691OT_09_14.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要创建并操作这些对象。它们需要覆盖任何动态对象和相机可能存在的整个区域。为此，创建并定位足够的区域以覆盖我们游戏中的街道。它们的大小可以像使用**Box
    Collider**组件时一样编辑。你还可以使用区域每侧的小圆柱来操纵场域。确保它们足够高，以覆盖所有目标（如下面的截图所示）：![Occlusion](img/4691OT_09_14.jpg)
- en: Next, hit **Bake** at the bottom of the **Occlusion** window. A progress bar
    will appear at the bottom-right corner of the Unity Editor, which will tell you
    how much longer the calculations will take. This process usually takes a good
    amount of time, especially as your game becomes more and more complex. For our
    simple Tank Battle game, this process will not take particularly long. Our simple
    scene with very little in it should only take a couple of seconds to be processed.
    A large level that is full of detail could easily take all day to be processed.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**Occlusion**窗口底部点击**Bake**。Unity编辑器右下角会出现一个进度条，它会告诉你计算还需要多长时间。这个过程通常会花费一些时间，特别是当你的游戏变得越来越复杂时。对于我们简单的坦克大战游戏，这个过程不会特别长。我们场景中内容很少，处理时间只需几秒钟。一个充满细节的大型关卡可能需要一整天来处理。
- en: When the baking process has completed, the **Occlusion** window would switch
    to the **Visualization** tab and, if it can be found, the camera should be selected
    in your **Scene** window. If it is not, select it now. In the **Scene** view,
    Unity will give us a preview of how occlusion culling is working. Only those objects
    that can be seen will be visible while the rest will be turned off (as seen in
    the following screenshot):![Occlusion](img/4691OT_09_15.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当烘焙过程完成后，**Occlusion**窗口将切换到**Visualization**标签，如果可以找到的话，应在你的**Scene**窗口中选择相机。如果没有，现在选择它。在**Scene**视图中，Unity会给我们展示遮挡剔除是如何工作的。只有那些可以看到的对象是可见的，其余的将被关闭（如下面的截图所示）：![Occlusion](img/4691OT_09_15.jpg)
- en: We went through the basic process to set up occlusion culling. We took a look
    at the **Occlusion** window and learned about the settings available there. Occlusion
    culling is great for reducing the number of draw calls in a scene. However, that
    reduction needs to be balanced against the cost of storing and retrieving the
    occlusion calculations. This balance is achieved by selecting a proper technique
    and an appropriate **View Cell Size**. Play around with the different values now
    to find a cell size that gives the appropriate amount of detail without supplying
    too much information.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了设置遮挡剔除的基本流程。我们查看了**遮挡**窗口并了解了那里可用的设置。遮挡剔除对于减少场景中的绘制调用数量非常有效。然而，这种减少需要与存储和检索遮挡计算的成本相平衡。通过选择适当的技术和合适的**视单元格大小**来实现这种平衡。现在尝试调整不同的值，找到一个可以在不过量提供信息的情况下提供适当细节的单元格大小。
- en: Tips for minimizing lag
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少延迟的小贴士
- en: 'The following is a list of tips for dealing with and avoiding lag in your games.
    Not all of them will apply to every game that you make, but they are good to keep
    in mind for every project:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些处理和避免游戏中延迟的小贴士。不是所有这些都会适用于你制作的每一个游戏，但它们对于每个项目都是值得牢记的：
- en: Avoid using transparency, if possible, when creating your materials. They are
    more expensive to render than a normal opaque material. In addition, you can save
    yourself a world of headaches of dealing with depth sorting, if you avoid them.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建材质时，如果可能的话避免使用透明度。它们比正常的不透明材质更昂贵。此外，如果你避免使用它们，还可以省去处理深度排序的许多麻烦。
- en: Use one material per object. The greater the number of draw calls in your game,
    the longer each frame will take to render. Every mesh is drawn once per material
    on it, even if the material doesn't appear to do anything. By keeping to one material
    per object, especially on mobile platforms, you minimize the number of draw calls
    and maximize your rendering speed.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象使用一个材质。你的游戏中绘制调用越多，每帧渲染的时间就会越长。即使材质看起来并没有做什么，每个网格也会根据其上的材质进行一次绘制。特别是对于移动平台，保持每个对象一个材质，可以最小化绘制调用次数，最大化渲染速度。
- en: Combine textures when possible. Not every texture you make will utilize the
    whole of the image. Whenever possible, combine the textures of objects that are
    in the same scene. This maximizes your efficient use of images, while reducing
    the final build size and amount of memory that is needed to utilize the textures.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能合并纹理。你制作的不是每个纹理都会利用到整张图像。只要有可能，就合并同一场景中对象的纹理。这最大化了图像的有效使用，同时减少了最终构建的大小和利用纹理所需的内存量。
- en: Group objects in your **Hierarchy** window using empty **GameObject** components.
    Though this is not specific to minimizing lag, it will make your project easier
    to work with. Especially with large and complex levels, you will be able to spend
    less time searching through the objects in your scene and more time making a great
    game.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**层级**窗口中使用空的**GameObject**组件来分组对象。这虽然不是特定于减少延迟，但它会使你的项目更容易操作。特别是在大型复杂关卡中，你将能够减少在场景中搜索对象的时间，从而有更多时间制作优秀的游戏。
- en: The **Console** window is your friend. Before worrying about your game not working,
    first take a look at the **Console** window or the bar at the bottom in Unity.
    Both will display any complaints that Unity might have about the way your game
    is currently setup. The messages here are great for pointing you in the right
    direction to fix any problems. If you are ever unsure what the messages are trying
    to tell you, perform a Google search for the message and you should be able to
    easily find a solution from one of the many Unity users. If your code ever appears
    to be not working and Unity isn't complaining about it, use the `Debug.Log` function
    to print messages to the Console. This will let you find places where your code
    might be exiting unexpectedly or find values that are not what they should be.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**窗口是你的好朋友。在担心你的游戏不能运行之前，首先查看一下Unity中的**控制台**窗口或底部的栏。两者都会显示Unity对于你游戏当前设置可能有的任何抱怨。这里的消息非常适合指引你解决问题。如果你不确定这些消息想要告诉你什么，可以针对这些消息进行一次谷歌搜索，你应该能轻松地从众多Unity用户那里找到一个解决方案。如果你的代码似乎不起作用，而Unity也没有对此抱怨，使用`Debug.Log`函数向控制台打印消息。这将帮助你找到代码可能意外退出的地方或找到不是预期值的变量。'
- en: Device testing is important. Working in the Editor is great, but there is nothing
    quite like testing on the target device. You can get a much better feel for how
    your game is performing when it is on the device. The Editor always introduces
    a small amount of additional processing overhead. In addition, the computer you
    are working on will always be more powerful than the mobile devices on which you
    might intend to deploy your game on.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备测试很重要。在编辑器中工作固然好，但没有什么能比在目标设备上进行测试更好。当游戏在设备上运行时，你能更直观地感受到游戏的表现。编辑器总会引入一些额外的处理开销。此外，你用来工作的电脑通常会比你可能打算部署游戏的移动设备要强大。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about our options for optimization in Unity. We
    first took a look at the various settings for the assets used in our games that
    are used to keep their file size down while maintaining quality. Next, we learned
    about some settings that affect the overall game. After that, we explored options
    for tracking the performance of the game. We first looked at some tools provided
    by Unity for tracking that performance. Then, we created a tool of our own for
    tracking script performance in detail. We then took a look at some options for
    minimizing lag in our games, including utilizing occlusion culling. Now that we
    know about all of these tools and options, go through the games that we created
    and optimize them. Make them the best that they can be.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了在Unity中进行优化的各种选择。首先，我们查看了一些用于减小游戏资产文件大小同时保持质量的设置。接下来，我们学习了一些影响整个游戏的设置。之后，我们探索了追踪游戏性能的选项。我们首先了解了一些由Unity提供的用于追踪性能的工具。然后，我们创建了自己的工具，详细追踪脚本性能。接着，我们查看了一些减少游戏中延迟的选项，包括利用遮挡剔除。现在我们知道了所有这些工具和选项，请回顾我们创建的游戏并进行优化。让它们尽可能做到最好。
- en: In this book, we learned a whole lot. We started with learning about Unity,
    Android, and how to make them work together. Our journey continued with an exploration
    of Unity's GUI system and the creation of a Tic-tac-toe game. We then learned
    about the basic assets needed for any game while we started the creation of a
    Tank Battle game. Our Tank Battle game then expanded with the addition of a few
    special camera effects and some lighting. We concluded the creation of the Tank
    Battle game by introducing some enemies and making them chase the player. The
    creation of our Monkey Ball game taught us about the touch and tilt controls that
    we can utilize in our game. A short break from that game saw the creation of an
    Angry Birds' clone while learning about physics and the options for working with
    Unity's 2D pipeline. We then returned to the Monkey Ball game to polish it with
    the addition of sound and particle effects. Finally, our journey concluded by
    learning about optimizing our games. Thank you for reading this book. We hope
    that you enjoy your experiences with Unity and Android while creating the awesome
    games that you always dreamed about.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们学到了很多。我们从学习Unity、Android以及如何让它们协同工作开始。我们的旅程继续探索Unity的GUI系统，并创建了一个井字游戏。然后，在学习任何游戏都需要的基本资产的同时，我们开始创建一个坦克大战游戏。随着一些特殊相机效果和灯光的加入，我们的坦克大战游戏得到了扩展。通过引入一些敌人并让它们追逐玩家，我们完成了坦克大战游戏的制作。我们的猴子球游戏教会了我们如何在游戏中利用触摸和倾斜控制。在短暂离开这个游戏后，我们创建了一个类似愤怒的小鸟的克隆游戏，同时学习了物理知识以及与Unity的2D管线工作的选项。然后，我们回到猴子球游戏，通过增加声音和粒子效果来完善它。最后，我们的旅程以学习如何优化我们的游戏结束。感谢您阅读这本书。我们希望您在Unity和Android上创造那些您一直梦寐以求的精彩游戏的过程中，享受这段经历。
