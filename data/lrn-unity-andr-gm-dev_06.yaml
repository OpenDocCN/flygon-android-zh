- en: Chapter 6. Specialities of the Mobile Device – Touch and Tilt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 移动设备的特性——触摸和倾斜
- en: In the previous chapter, we learned about pathfinding and AI. We expanded our
    Tank Battle game to include enemy tanks. We created points for them to spawn at
    and made them shoot at the player. In addition, the player was given the ability
    to destroy the tanks. Once they were destroyed, the player received some points
    and a new enemy tank was spawned.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了路径查找和人工智能。我们将坦克大战游戏扩展到了包括敌方坦克。我们为它们创建了生成点，并让它们向玩家射击。此外，玩家获得了摧毁坦克的能力。一旦坦克被摧毁，玩家将获得一些分数，并且会生成新的敌方坦克。
- en: In this chapter, we will work on a new game as we explore some of the specialties
    of mobile devices. We will create a **Monkey Ball** game. The player will take
    control of a monkey in an oversized hamster ball and try to reach the end of the
    maze before time runs out, while collecting bananas. To move around, they will
    have to tilt the mobile device. To collect bananas, the player will have to touch
    the screen where the banana is.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过探索移动设备的某些特性来开发一个新游戏。我们将创建一个**猴子球**游戏。玩家将控制一个超大仓鼠球中的猴子，尝试在时间耗尽前到达迷宫的终点，同时收集香蕉。为了移动，他们将不得不倾斜移动设备。为了收集香蕉，玩家将不得不触摸屏幕上香蕉所在的位置。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Touch controls
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸控制
- en: Tilt controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: The Monkey Ball game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猴子球游戏
- en: We will be creating a new project for this chapter, so start Unity and we will
    begin.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章创建一个新项目，因此启动Unity，我们将开始。
- en: Setting up the development environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'As with every project, we need a little bit of preparation work in order to
    prepare our development environment. Don''t worry; the setup for this chapter
    is simple and straightforward. Let''s follow these steps to do it:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个项目一样，我们需要做一些准备工作以准备我们的开发环境。别担心，本章的设置简单直接。让我们按照以下步骤进行操作：
- en: The first step is, of course, to start Unity and create a new project. It will
    need to be a 3D project and naming it `Ch6_MonkeyBall` will work well.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步当然是启动Unity并创建一个新项目。它应该是一个3D项目，将其命名为`Ch6_MonkeyBall`会很合适。
- en: Once Unity has finished initializing, this is the perfect opportunity to set
    our build settings. Open the **Build Settings** window, select **Android** from
    the list of platforms and hit **Switch Platform** to change the target platform.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Unity完成初始化后，这是设置我们构建设置的完美时机。打开**构建设置**窗口，从平台列表中选择**Android**，然后点击**切换平台**以改变目标平台。
- en: While you are in the **Build Settings** window, select **Player Settings** to
    open the player settings in the **Inspector**. Adjust the **Company Name**, **Product
    Name**, and, most importantly, the **Bundle Identifier**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你处于**构建设置**窗口时，选择**玩家设置**以在**检查器**中打开玩家设置。调整**公司名称**、**产品名称**，最重要的是**捆绑标识符**。
- en: When a user tilts their device, the whole screen will adjust its orientation
    when a new side becomes the bottom. Since the whole game is based around tilting
    the device, the screen orientation might change at any moment when a player is
    playing and thus spoil their game. Therefore, in **Player Settings**, find the
    **Resolution** **and Presentation** section and ensure that the **Default Orientation**
    is not set to **Auto Rotation**, which would cause Unity to change a game's orientation
    when we are playing. Any of the other options will work for us here.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户倾斜他们的设备时，当新的一边成为底部时，整个屏幕将调整其方向。由于整个游戏都是围绕倾斜设备设计的，因此在玩家游戏过程中屏幕方向可能会随时改变，从而破坏他们的游戏体验。因此，在**玩家设置**中，找到**分辨率**和**展示**部分，确保**默认方向**没有设置为**自动旋转**，这会导致Unity在我们玩游戏时改变游戏的方向。这里的其他任何选项都可以为我们所用。
- en: We need to create a few folders to keep the project organized. The `Scripts`,
    `Models`, and `Prefabs` folders should be created in the **Project** window. Since
    we may end up with dozens of levels and maps in the future, it would be a good
    idea to make a `Scenes` folder as well.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建几个文件夹以保持项目的组织性。在**项目**窗口中应创建`Scripts`（脚本）、`Models`（模型）和`Prefabs`（预制体）文件夹。由于将来我们可能会有数十个关卡和地图，因此创建一个`Scenes`（场景）文件夹也是个好主意。
- en: Lastly, we must import the assets for this project. We are going to need a monkey
    for the player, a banana to collect, a sample map, and some fences. Luckily, all
    of these have already been prepared and are available with the starting assets
    for this chapter. Import `Monkey.blend`, `Monkey.psd`, `Ball.psd`, `Banana.blend`,
    `Banana.psd`, `MonkeyBallMap.blend`, `Grass.psd`, `Fence.blend`, and `Wood.psd`
    to the `Models` folder that you just created.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须为本项目导入资源。我们需要一个作为玩家的猴子、一个要收集的香蕉、一个示例地图和一些围栏。幸运的是，所有这些资源都已准备就绪，并包含在本章的初始资源中。将`Monkey.blend`、`Monkey.psd`、`Ball.psd`、`Banana.blend`、`Banana.psd`、`MonkeyBallMap.blend`、`Grass.psd`、`Fence.blend`和`Wood.psd`导入到您刚才创建的`Models`文件夹中。
- en: We have just finished the setup for this chapter's project. Once again, a little
    bit of effort at the beginning of the project will save time and avoid frustration
    later; as the project grows in size, the organization done at the beginning becomes
    very important.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了本章项目的设置。再次强调，项目开始时的一点点努力将节省时间并避免后期出现挫折；随着项目规模的扩大，开始时的组织工作变得非常重要。
- en: A basic environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基本的环境
- en: 'Before we dive into all the fun of tilt and touch controls, we need a basic
    testing environment. When working with new control schemes, it is always best
    to work in a simple and well-controlled environment before introducing the complexities
    of a real level. Let''s make ours with these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨倾斜和触摸控制的乐趣之前，我们需要一个基本的测试环境。在使用新的控制方案时，最好在一个简单且易于控制的环境中工作，然后再引入真实关卡复杂性。让我们按照以下步骤创建我们的环境：
- en: Go to the top of Unity and select **Cube** by navigating to **GameObject** |
    **3D Object** to create a new cube, which will be the base of our basic environment.
    Rename it as `Ground` so that we can keep track of it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity顶部，通过导航到**GameObject** | **3D Object**选择**Cube**，创建一个新立方体，它将成为我们基本环境的基础。将其重命名为`Ground`，以便我们可以跟踪它。
- en: Set the cube's **Position** in the **Inspector** panel to `0` on each axis,
    allowing us to work around the world origin. Also, set its **X** and **Z** **Scale**
    in the **Inspector** to `10`, giving us enough space to move around and test our
    monkey.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中将立方体的**位置**设置为每个轴上的`0`，这样我们就可以围绕世界原点进行操作。同时，将它的**X**和**Z**的**缩放**在**检查器**中设置为`10`，为我们提供足够的空间来移动并测试我们的猴子。
- en: Next, we need a second cube, named `Fence`. This cube should have a **Position**
    value of `-5` for **X**, `1` for **Y**, and `0` for **Z**, along with a scale
    of `0.2` for **X** and **Y** and `10` for **Z**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个名为`Fence`的第二个立方体。这个立方体的**位置**值应为**X**的`-5`，**Y**的`1`，**Z**的`0`，以及**X**和**Y**的`0.2`缩放和**Z**的`10`。
- en: With `Fence` selected in the **Hierarchy** window, you can hit *Ctrl* + *D*
    on your keyboard to make a duplicate. We are going to need a total of four, positioned
    along each side of our `Ground` cube:![A basic environment](img/4691OT_06_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择`Fence`，您可以按键盘上的*Ctrl* + *D*来创建一个副本。我们需要总共四个，沿着我们的`Ground`立方体的每一边放置：![一个基本的环境](img/4691OT_06_01.jpg)
- en: We now have a basic testing environment that will allow us to work with our
    controls and not worry about all the complexities of a whole level. Once our controls
    work in this environment the way we want them to, we will introduce our monkey
    to a new environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的测试环境，它将允许我们使用控制装置，而不必担心整个关卡的所有复杂性。一旦我们的控制装置在这个环境中按照我们想要的方式工作，我们将把我们的猴子引入到一个新的环境。
- en: Controlling with tilt
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: Modern mobile devices provide a broad variety of internal sensors to detect
    and provide information about the surrounding world. Though you may not have thought
    of them in such a way, you must be certainly very familiar with the microphone
    and speaker that are required for making calls. There is also a Wi-Fi receiver
    for connecting to the Internet and a camera for taking pictures. In addition,
    your device almost certainly has a magnetometer, to work with your GPS and provide
    directions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动设备提供了各种各样的内部传感器来检测并提供关于周围世界的信息。尽管你可能没有这样想过，但你一定非常熟悉用于打电话的麦克风和扬声器。还有用于连接互联网的Wi-Fi接收器和用于拍照的摄像头。此外，你的设备几乎肯定有一个磁力计，用于与GPS配合提供方向。
- en: 'The sensor that we are interested in right now is the **gyroscope**. This sensor
    detects local rotation of the device. In general, it is one of the many sensors
    in your phone that is used to determine the orientation and movement of the device
    in the world. We are going to use it to steer our monkey. When the user tilts
    their device left and right, the monkey will move left and right. When the device
    is tilted up and down, the monkey will go forward and backward. With these steps,
    we can create the script that will let us control our monkey in this manner:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在感兴趣的传感器是**陀螺仪**。这个传感器可以检测设备的局部旋转。一般来说，它是手机中众多传感器之一，用于确定设备在世界中的方向和移动。我们将使用它来控制我们的猴子。当用户左右倾斜设备时，猴子就会左右移动。当设备上下倾斜时，猴子就会前进和后退。通过这些步骤，我们可以创建一个脚本来让我们以这种方式控制猴子：
- en: To start this off, create a new script and name it `MonkeyBall`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新脚本并将其命名为`MonkeyBall`。
- en: 'Our first variable will hold a reference to the **Rigidbody** component that
    will be attached to the ball. This is what will allow us to actually make it roll
    around and collide with the things in the world:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们第一个变量将保存一个对附加到球体的**Rigidbody**组件的引用。这是让我们实际让它滚动并与世界中的物体碰撞的关键：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next two variables will let us control how the tilting of the device affects
    the movement in the game. The first will allow us to get rid of any movements
    that are too small. This lets us avoid random movements from the environment or
    a sensor that perhaps isn''t entirely accurate. The second will let us scale the
    tilt input up or down in case the control feels either sluggish and slow or uncontrollably
    fast:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个变量将让我们控制设备倾斜如何影响游戏中的移动。第一个将允许我们消除任何太小的移动。这让我们避免了来自环境或可能不是完全准确的传感器的随机移动。第二个将让我们在控制感觉过于迟缓或过快时，调整倾斜输入的大小：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last variable for now will keep track of how much the device has been tilted.
    It forces the user to tilt their device back and forth, countering movement if
    they want to go in the opposite direction:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前最后一个变量将跟踪设备被倾斜了多少。它迫使用户如果想要朝相反方向移动，就需要来回倾斜设备，以抵消移动：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our very first function for this script is nice and short. In order to get
    input from the gyroscope, we must first turn it on. We will do this in the `Awake`
    function so that we can start tracking it at the very beginning of the game:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们这个脚本的第一个函数非常简短。为了从陀螺仪获取输入，我们首先必须打开它。我们将在`Awake`函数中这样做，以便从游戏一开始就跟踪它：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next function for our script will be `Update`. It starts by grabbing the
    value of `rotationRate` from the gyroscope. This is a value in radians per second,
    indicating how fast the user has tilted their device along each axis. To make
    it a little more understandable, we multiply the value of `rotationRate` by `Mathf.Rad2Deg`
    to convert it into degrees per second before we store it in a variable:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们脚本的下一个函数是`Update`。它首先从陀螺仪获取`rotationRate`的值。这是一个每秒弧度的值，表示用户沿着每个轴倾斜设备的速度有多快。为了使它更容易理解，我们在将其存储在变量之前，将`rotationRate`的值乘以`Mathf.Rad2Deg`将其转换为每秒度数：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When holding your device with the screen facing you, the *x* axis of your device
    points to the right. The *y* axis is straight up, at the top of the device and
    the *z* axis points directly towards you from the center of the screen.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你将设备屏幕朝向你握在手中时，设备的*x*轴指向右边。*y*轴是垂直向上的，位于设备的顶部，而*z*轴则直接从屏幕中心指向你。
- en: 'Next, we make sure that there is enough movement along each axis to actually
    make our monkey move. By using `Mathf.Abs` on each value, we find the absolute
    value of the axis movement. We then compare it to the minimum amount of tilt that
    we are looking for. If the movement is too little, we zero it out in our `rotation`
    variable:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要确保每个轴上的移动足够大，以实际让我们的猴子移动。通过对每个值使用`Mathf.Abs`，我们找到轴移动的绝对值。然后，我们将其与我们寻找的最小倾斜量进行比较。如果移动太小，我们在`rotation`变量中将其归零：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, for our `Update` function, we track the new movement by adding it
    to our `totalRotate` variable. To do this properly, we need to rearrange the values.
    The player expects to be able to tilt the top of their device towards them to
    go backwards and away to go forwards. This is the *x* axis movement, but it comes
    in backwards from our device compared to what we need to move the monkey, hence
    the negative sign before the value. Next, we swap the *y* and *z* axes'' rotation
    because the player is going to expect to tilt their device left and right to go
    left and right, which is a *y* axis movement. If we applied that to the *y* axis
    of our monkey, he would just spin in place. So, the movement is treated to be
    speed per second rather than speed per frame; we have to multiply by `Time.deltaTime`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于我们的`Update`函数，我们通过将新移动添加到我们的`totalRotate`变量来跟踪新移动。为此，我们需要重新排列这些值。玩家期望能够将设备顶部向自己倾斜以向后移动，远离以向前移动。这是*x*轴移动，但与我们需要移动猴子相比，它从我们的设备中反方向输入，因此值前有负号。接下来，我们交换*y*和*z*轴的旋转，因为玩家将期望通过左右倾斜设备来左右移动，这是*y*轴移动。如果我们将其应用于猴子的*y*轴，他只能在原地旋转。因此，移动被视为每秒的速度而不是每帧的速度；我们需要乘以`Time.deltaTime`：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last function for now is the `FixedUpdate` function. When making changes
    to and dealing with rigidbodies, it is best to do it in `FixedUpdate`. The rigidbody
    is what actually connects us into Unity''s physics engine, and it only updates
    during this function. All we are doing here is adding some torque, or rotational
    force, to the rigidbody. We use the total that we have been collecting and multiply
    it by our `sensitivity` to give our players the speed of control that they will
    expect:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前最后一个函数是`FixedUpdate`函数。在对刚体进行修改和处理时，最好在`FixedUpdate`中进行。刚体实际上是将我们连接到 Unity
    物理引擎的部分，而且它只在这个函数中更新。我们在这里所做的就是给刚体添加一些扭矩，或者说旋转力。我们使用收集到的总量乘以我们的`sensitivity`来给玩家提供他们预期的控制速度：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to make use of our new script, we need to make some changes to the
    ball. Start by creating a sphere for us to work with; this can be found by navigating
    to **GameObject** | **3D Object** | **Sphere**. Rename it as `MonkeyBall` and
    position it a little above our **Ground** cube.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用我们的新脚本，需要对球体进行一些修改。首先创建一个球体供我们操作；可以通过导航至**游戏对象** | **3D对象** | **球体**找到。将其重命名为`MonkeyBall`，并将其位置稍微设在我们**地面**方块之上。
- en: Next, give it the `Ball.psd` texture in a material so that we can see it rotate
    and not just move. The two-tone nature of the texture will let us easily see it
    roll around the scene.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，给物体赋予`Ball.psd`材质，这样我们就能看到它旋转而不仅仅是移动。材质的双色调特性将使我们能够轻松看到它在场景中滚动。
- en: The **Rigidbody** component can be found by navigating to **Component** | **Physics**
    | **Rigidbody** at the top of Unity. Add a new **Rigidbody** component.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**刚体**组件可以通过在 Unity 顶部导航至**组件** | **物理** | **刚体**找到。添加一个新的**刚体**组件。'
- en: In addition, add our `MonkeyBall` script to the sphere and drag the new **Rigidbody**
    component to the **Body** slot in the **Inspector** panel.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将我们的`MonkeyBall`脚本添加到球体上，并将新的**刚体**组件拖到**检查器**面板中的**Body**槽。
- en: This is the point where it is especially important to have **Unity Remote**.
    With your device attached and *Unity Remote* running, you can hold it up and steer
    the ball. Feel free to adjust the sensitivity and minimum tilt until you find
    settings that feel natural to control. Due to the great variety of devices, their
    hardware, and the architecture used, the rate of tilt can easily differ from one
    device to the next. However, especially at this stage, you must find settings
    that work for your device now and worry about what will work for other devices
    once the game is more complete.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，拥有**Unity Remote**尤为重要。将设备连接并运行*Unity Remote*，你可以拿起它来控制球体。随意调整敏感度和最小倾斜度，直到找到感觉自然的控制设置。由于设备、硬件以及所用架构的多样性，不同设备之间的倾斜速率可能很容易有所不同。然而，特别是在这个阶段，你必须找到现在适合你设备的设置，并在游戏更加完善后再考虑其他设备的兼容性。
- en: If you are having trouble seeing the ball roll around, move the camera so that
    you have a better view. However, make sure that it continues to point forward
    along the world's *z* axis.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你发现球体滚动时的视线不好，移动摄像头以获得更好的视角。但确保它继续沿着世界的*z*轴向前指。
- en: Once all your settings are in place, ensure that you save the scene. Name it
    `MonkeyBall`.![Controlling with tilt](img/4691OT_06_02.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有设置完成后，确保保存场景。将其命名为`MonkeyBall`。![通过倾斜控制](img/4691OT_06_02.jpg)
- en: We made use of the gyroscope to provide you with the steering control of a ball.
    By measuring how the player is tilting his or her device, we are able to add motion
    to the ball accordingly. By rolling around a simple map, we can fine-tune our
    controls and make sure everything is working correctly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用陀螺仪为你提供了球的转向控制。通过测量玩家倾斜设备的方式，我们能够相应地给球添加运动。通过在简单地图上滚动，我们可以微调我们的控制，确保一切正常工作。
- en: Following with the camera
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与相机一起跟随
- en: 'To really make the player feel like they are controlling the ball, the camera
    needs to follow it around. This is particularly necessary when the maps and levels
    become larger and more complex than what can be shown in a single camera shot.
    The simplest solution would be to just make the camera a child of the ball, but
    that will make it spin with the ball and our controls will become confusing as
    well. So, let''s use these steps to set up our camera to follow the ball around:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家真正感觉到他们正在控制球，相机需要跟随球移动。当地图和关卡变得比一个相机镜头能展示的更大更复杂时，这一点尤为重要。最简单的解决方案是将相机设置为球的子对象，但这会使它与球一起旋转，我们的控制也会变得混乱。所以，让我们按照以下步骤设置相机跟随球移动：
- en: We need to first create a new script and name it `CameraFollow`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个新的脚本，并将其命名为`CameraFollow`。
- en: 'This script is really simple. It has a single variable to keep track of what
    is being followed:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本非常简单。它有一个单一变量来跟踪正在跟随的对象：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The only function in the script is the `LateUpdate` function. We use this function
    because it executes after everything else has had a chance to do their normal
    update. The only thing the script is going to do is move to the new position of
    the ball:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本中唯一的函数是`LateUpdate`函数。我们使用这个函数，因为它在所有其他内容有机会进行正常更新之后执行。脚本要做的就是移动到球的新位置：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make use of this script, we need a new empty **GameObject** component. Name
    it `CameraPivot`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用这个脚本，我们需要一个新的空**GameObject**组件。将其命名为`CameraPivot`。
- en: Position it at (approximately) the center of the ball. This is the point that
    will actually move to follow the ball around. At this point, the created **GameObject**
    doesn't have to be perfectly positioned; it just needs to be close enough so that
    it's easier to line up the camera.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其定位在（大约）球的中心。这是实际上会移动以跟随球的位置。在这一点上，创建的**GameObject**不需要完美定位；它只需要足够接近，这样更容易对齐相机。
- en: Next, find the `Main Camera` in the **Hierarchy** window and make it a child
    of `CameraPivot`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**层次结构**窗口中找到**主相机**，并将其设置为`CameraPivot`的子对象。
- en: Set the `Main Camera` component's **X** position to `0`. As long as **X** stays
    at zero and the camera continues to point relatively forward along the *z* axis,
    you can freely move it to find a good position from which to observe the ball.
    Values of `2` for the **Y** position, `-2.5` for the **Z** position, and `35`
    for the **X** rotation also work well.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主相机**组件的**X**位置设置为`0`。只要**X**保持为零，且相机继续沿着*z*轴相对向前指向，你就可以自由移动它以找到一个观察球的好位置。**Y**位置为`2`，**Z**位置为`-2.5`，**X**旋转为`35`也效果不错。
- en: Next, add the `CameraFollow` script to the `CameraPivot` object.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`CameraFollow`脚本添加到`CameraPivot`对象上。
- en: Finally, drag `MonkeyBall` from the scene and drop it on the **Ball** slot of
    the new **CameraFollow** script component. Then, go try it out!![Following with
    the camera](img/4691OT_06_03.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将场景中的`MonkeyBall`拖拽到新的**CameraFollow**脚本组件的**Ball**槽中。然后，去试试看！！[与相机一起跟随](img/4691OT_06_03.jpg)
- en: We now have a ball that rolls around and a camera that follows it. The camera
    is simply updating its position to keep pace with the ball, but it works well
    as an effect. As a player, we will definitely feel that we are taking control
    of the ball and its motion.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个滚动的球和一个跟随它的相机。相机只是更新其位置以跟上球的步伐，但它作为一个效果非常好。作为玩家，我们肯定会感觉到我们正在控制球及其运动。
- en: Adding the monkey
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加猴子
- en: 'Now that we are close to the ball and following it around, we need something
    a little more interesting to look at. In this section, we are going to add the
    monkey to the ball. In addition, to ensure that he isn''t being spun around wildly,
    we will make a new script to keep him upright. Let''s do all of that by following
    these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们离球很近并且跟随它移动，我们需要一些更有趣的东西来观察。在本节中，我们将在球上添加猴子。此外，为了确保他不会被疯狂地旋转，我们将制作一个新的脚本来保持他直立。按照以下步骤进行操作：
- en: Create a new empty **GameObject** and rename it `MonkeyPivot`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空**GameObject**，并将其重命名为`MonkeyPivot`。
- en: Make it a child of the `MonkeyBall` script and zero out its position.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为`MonkeyBall`脚本的子对象，并将位置归零。
- en: Next, add the monkey to the scene and make it a child of the `MonkeyPivot` GameObject.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将猴子添加到场景中，并将其设置为`MonkeyPivot` GameObject的子对象。
- en: To make it easier to see the monkey inside the ball, we need to make it slightly
    transparent. Select `MonkeyBall` and find the **Rendering Mode** setting on the
    material at the bottom. By changing it to **Transparent**, we will be able to
    adjust it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更容易看到球内的猴子，我们需要让猴子稍微透明一些。选择`MonkeyBall`并找到材质底部上的**渲染模式**（Rendering Mode）设置。将其更改为**透明**（Transparent），我们就能进行调整。
- en: Now, click on the **Color Picker** box to the right of **Albedo** and change
    the **A** slider, alpha, to `128`; this will allow us to now see through the ball.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**反照率**（Albedo）右侧的**颜色选择器**（Color Picker）框，并将**A**滑块，即alpha值，调整为`128`；这样我们就能透视球体内部了。
- en: Scale and move the monkey until he fills the center of the ball.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放并移动猴子，直到他填满球体的中心。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can also take this opportunity to pose the monkey. If you expand the monkey
    in the **Hierarchy** window, you will be able to see all of the bones that make
    up his skeleton rig. Giving him a cool pose now will make the game much better
    for our players later.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以借此机会为猴子摆个姿势。如果展开**层级**（Hierarchy）窗口中的猴子，你将能够看到构成他骨骼的所有骨头。现在给他一个酷炫的姿势，将使我们的玩家在游戏中的体验更好。
- en: '![Adding the monkey](img/4691OT_06_04.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加猴子](img/4691OT_06_04.jpg)'
- en: 'Our monkey and the ball are looking really cool right now, until we actually
    hit play and the monkey spins around dizzily in the ball. We need to open our
    `MonkeyBall` script and fix his spinning antics:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前我们的猴子和球体看起来很酷，但当我们实际播放时，猴子在球内晕头转向地旋转。我们需要打开`MonkeyBall`脚本，修复他的旋转动作：
- en: 'First, we need two new variables at the top of the script. The first will keep
    track of the empty **GameObject** that we created a moment ago. The second will
    give us the speed for updating the rotation of the monkey. We want it to look
    like the monkey is moving the ball, so he needs to face the direction in which
    the ball is moving. The speed here is how fast he will turn to face the right
    direction:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在脚本顶部我们需要两个新的变量。第一个将追踪我们刚才创建的空的**GameObject**。第二个将为我们提供更新猴子旋转的速度。我们希望看起来像是猴子在移动球体，所以他需要面向球体移动的方向。这里的速度是指他转向正确方向的速度：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need a new `LateUpdate` function. This double-checks whether the `monkeyPivot`
    variable has actually been filled for the script. If it isn''t there, we can''t
    do anything else:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个新的`LateUpdate`函数。这会再次检查`monkeyPivot`变量是否真的为脚本所填充。如果没有，我们就无法进行其他操作：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We first need to figure out which direction the ball is moving in. The easiest
    way to do this is to grab `velocity` of the **Rigidbody** component, our body
    variable. It is a `Vector3` that indicates how fast and in which direction we
    are currently moving. Since we do not want our monkey to point up or down, we
    zero out the *y* axis movement:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要弄清楚球体移动的方向。做到这一点最简单的方法是获取**刚体**（Rigidbody）组件的`velocity`，即我们的body变量。它是一个`Vector3`，表示我们当前移动的速度和方向。由于我们不希望猴子指向上下，所以我们为零*y*轴移动：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to figure out which direction the monkey is currently facing.
    We have used the forward value before, with our tanks. It is simply the direction
    in 3D space in which we are facing. Again, to avoid looking up or down, we zero
    out the *y* axis:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要弄清楚猴子当前面向的方向。我们之前在使用坦克时已经使用过前进值。它只是我们在3D空间中面向的方向。同样，为了避免上下看，我们将*y*轴归零：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To prevent suddenly changing direction as we move and to keep pace with the
    frame rate, we must calculate a `step` variable. This is how much we can rotate
    this frame, based on our speed and the time that has elapsed since the last frame:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免移动时突然改变方向，并与帧率保持一致，我们必须计算一个`step`变量。这是基于我们的速度和自上一帧以来经过的时间，这一帧我们可以旋转多少：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then need to find a new direction to face by using `Vector3.RotateTowards`.
    It takes the direction we were facing, followed by the direction we want to face
    and two speeds. The first speed specifies how much the angle can change in this
    frame and the second specifies how much the magnitude, or length, of the vector
    can change. We are not concerned with a change in magnitude, so it is given a
    zero value:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过使用`Vector3.RotateTowards`找到一个新面向的方向。它包括我们当前面向的方向，接着是我们想要面向的方向以及两个速度。第一个速度指定了这一帧中角度可以改变多少，第二个指定了向量的大小或长度可以改变多少。我们不关心向量大小的变化，所以给它赋予零值：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, the new rotation is calculated using `Quaternion.LookRotation` by
    passing the `newFacing` vector to it and applying the result to the monkey''s
    rotation. This will turn the monkey to face in the direction of the movement and
    keep him from spinning with the ball:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将`newFacing`向量传递给`Quaternion.LookRotation`来计算新的旋转，并将结果应用到猴子旋转上。这将使猴子面向移动方向，防止它与球一起旋转：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To make it work, drop the `MonkeyPivot` object on the **Monkey Pivot** slot
    on the **MonkeyBall** script component. The monkey will rotate to face the direction
    of the ball's movement while staying upright:![Adding the monkey](img/4691OT_06_05.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使其工作，请将`MonkeyPivot`对象拖放到**MonkeyBall**脚本组件上的**Monkey Pivot**槽中。猴子将旋转以面向球的移动方向，同时保持直立：![添加猴子](img/4691OT_06_05.jpg)
- en: We've just finished adding the monkey to the ball. By giving him a cool pose,
    the player will be more engaged with it as a character. However, it looks a little
    weird when the monkey spins wildly within the ball, so we updated our script to
    keep him upright and facing the direction in which the ball is moving. Now, it
    almost looks as though the monkey is in control of the ball.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了将猴子添加到球中的工作。通过给猴子一个酷炫的姿势，玩家会更多地将其作为一个角色来参与。然而，当猴子在球内疯狂旋转时，看起来有点奇怪，因此我们更新了脚本，使他能保持直立并面向球的移动方向。现在，它几乎看起来像是猴子在控制球。
- en: Keeping the monkey on the board
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持猴子在板上
- en: 'What fun is a game if there is no risk of failure? In order to test our monkey
    and tilt controls, we put a safety fence around our basic environment to keep
    them from falling over. However, every game needs a little risk to make it exciting.
    By removing the safety fence, we introduce a risk of falling over and losing the
    game. However, usually there is an option to retry the game if you fall. To this
    end, we will now create what is traditionally called a **kill** **volume**. This
    is simply an area that resets the player when they fall into it. Let''s use these
    steps to create it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏中没有失败的风险，那还有什么乐趣？为了测试我们的猴子和倾斜控制，我们在基本环境周围设置了一个安全围栏，防止它们翻倒。然而，每个游戏都需要一点风险来增加刺激感。通过移除安全围栏，我们引入了翻倒和游戏失败的风险。但是，通常如果你掉落了，会有重试游戏的选择。为此，我们现在将创建一个传统上称为**kill**
    **volume**的区域。这只是一个在玩家掉入时重置玩家的区域。让我们按照以下步骤来创建它：
- en: First, create a new script and name it `KillVolume`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新脚本并将其命名为`KillVolume`。
- en: 'This script has a single variable. It will keep track of where to put the monkey
    ball after it has fallen in:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有一个单一变量。它将跟踪猴子球掉入后放置的位置：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This script also has a single function, `OnTriggerEnter`. This function is
    called every time an object with a **Rigidbody** component enters a trigger volume.
    It receives the object that enters as a collider:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本还有一个单一函数`OnTriggerEnter`。每当具有**Rigidbody**组件的对象进入触发器体积时，都会调用此函数。它接收进入的对象作为碰撞器：
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function simply changes the position of the thing that entered the volume
    to that of the point where we want to respawn it. The only thing that will be
    moving around our game will be the monkey ball, so we don''t have to worry about
    any double-checking what has entered. We also set `velocity` to `zero` so that
    it doesn''t move suddenly when the player regains control:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数简单地将进入体积的物体的位置更改为我们想要重新生成它的点的位置。我们游戏中唯一会移动的是猴子球，所以我们不需要担心检查进入的是什么。我们还设置了`velocity`为`zero`，这样当玩家重新获得控制时，它就不会突然移动：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we need a new empty **GameObject**, named `RespawnPoint`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个名为`RespawnPoint`的新空**GameObject**。
- en: Position this object at approximately the same location of where our ball starts.
    This is the point where the ball will be put after it has fallen off the field.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此对象定位在我们球开始的大致位置。这是球在掉出场地后将被放置的点。
- en: Now, create another empty **GameObject** and name it `KillVolume`. This object
    will catch and reset the game when the player falls in.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个空的**GameObject**并将其命名为`KillVolume`。当玩家掉入该对象时，它将捕捉并重置游戏。
- en: Set its position to `-10` for **Y** and `0` for both **X** and **Z**. This will
    put it well below where the player is going to be. The important thing for future
    levels is that this volume is below where the player is normally going to be.
    If it isn't, they might miss it and fall forever, or suddenly jump back to the
    beginning, passing through it on their way to an that area they are supposed to
    be in.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为**Y轴**的`-10`，**X轴和Z轴**的`0`。这将使其位于玩家将要到达的位置下方。对于未来关卡来说，重要的是这个体积位于玩家通常所在位置的下方。如果不是这样，他们可能会错过它，永远下落，或者突然跳回到起点，在前往他们应该到达的区域时穿过它。
- en: We need to give the object a **Box Collider** component and attach our `KillVolume`
    script.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要给对象一个**盒子碰撞器**组件，并附加我们的`KillVolume`脚本。
- en: In order to get `OnTriggerEnter` function called by Unity, we need the **Is
    Trigger** box checked. Otherwise, it will just collide with the volume and appear
    to the player that they are just floating.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让Unity调用`OnTriggerEnter`函数，我们需要勾选**是触发器**的选项。否则，它将与体积碰撞，玩家看起来就像是漂浮着。
- en: Next, we need to make the volume large enough to actually catch our player when
    they fall in. To do this, set **Size** on the **Box Collider** component to `100`
    for both the **X** and **Z** axes.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使体积足够大，以便在玩家掉入时能够捕捉到他们。为此，将**盒子碰撞器**组件的**大小**设置为**X轴和Z轴**的`100`。
- en: Drag the `RespawnPoint` object from the **Hierarchy** window to the **Respawn
    Point** slot on our `KillVolume` script component in the **Inspector**. Without
    it, our player will never be able to get back after falling off the map.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**层次结构**窗口中的`RespawnPoint`对象拖到**检查器**中的`KillVolume`脚本组件的**重生点**槽上。如果没有它，玩家在掉出地图后将无法返回。
- en: Finally, delete the `Fence` cubes from our basic environment so that we can
    test it out. You can move the ball around and when it falls off the ground block,
    it will hit `KillVolume` and return to `RespawnPoint`.![Keeping the monkey on
    the board](img/4691OT_06_06.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从我们的基础环境中删除`Fence`立方体，这样我们就可以测试一下了。你可以移动球体，当它从地面方块掉落时，会撞击`KillVolume`并返回到`RespawnPoint`位置。[保持猴子在板上](img/4691OT_06_06.jpg)
- en: We now have the ability to reset our players when they fall off the map. The
    important part is detecting when they are no longer on the map and not interrupting
    them when they should be. This is why we have made it so large and put it well
    underneath the main area of our level. However, it would be a bad idea to put
    the volume too far below the play area, or the player is going to be falling for
    a long time before the game is reset.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在玩家掉出地图时重置他们。重要的是要检测他们何时不再在地图上，并且在应该重置时不要打断他们。这就是为什么我们做得这么大，并将其放在关卡主要区域的下方。但是，将体积放置得太远低于游戏区域是一个坏主意，否则玩家在游戏重置之前会下落很长时间。
- en: Winning and losing the game
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赢得或失去游戏
- en: 'Now that we have the ability to move around and reset if we fall off the map,
    we just need some way to win or lose the game. This particular type of game is
    traditionally tracked by how fast you are able to get from one end of the map
    to the other. If you fail to reach the end before the timer runs out, it is game
    over. Let''s use these steps to create a finish line and a timer for our game:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经具备了移动和如果掉出地图就重置的能力，我们只需要找到一种方法来赢得或输掉游戏。这种类型的游戏传统上是根据你从地图一端移动到另一端的速度来判定的。如果你在计时器耗尽之前未能到达终点，那么游戏就结束了。让我们按照以下步骤为游戏创建一个终点线和计时器：
- en: We need a new script named `VictoryVolume`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新的名为`VictoryVolume`的脚本。
- en: 'It starts with a pair of variables for tracking the messages for our player.
    The first will be turned on and shown to the player if they reach the end within
    the time limit. The second will only display if they run out of time:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先用一对变量来跟踪玩家的信息。如果玩家在限定时间内到达终点，第一个变量将被激活并展示给玩家。第二个变量只有在时间耗尽时才会显示：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next variable will track the `Text` object in the GUI to display the current
    amount of time left to complete the level:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量将跟踪GUI中的`Text`对象，以显示完成关卡剩余的当前时间：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This variable is for setting how much time, in seconds, is available for a
    player to complete the level. When adjusting this in the **Inspector** panel for
    a larger version of the game, it is a good idea to have several people test the
    level in order to get a feel of how long it takes to complete:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个变量用于设置玩家完成关卡可用的时间，单位为秒。在为大型版本的游戏调整**检查器**面板时，最好让多人测试关卡，以便了解完成关卡需要多长时间：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our last variable for the script will simply track whether or not our timer
    can actually count down. By making it `private` and defaulting it to `true`, the
    timer will always start counting from the moment the level loads:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本最后一个变量将简单地跟踪计时器是否能够倒计时。通过将其设置为`private`并默认为`true`，计时器将从关卡加载的那一刻开始计时：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first function for this script is `Awake`, which is the best location for
    initialization. The only thing it does is turn off both of the messages. We will
    turn on the appropriate one later, based on how our player performs:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本第一个函数是`Awake`，这是初始化的最佳位置。它只做一件事，就是关闭两个消息。稍后我们会根据玩家的表现开启相应的消息：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To detect when the player has crossed the finish line, we will be using the
    same `OnTriggerEnter` function that we used for the `KillVolume` script. Here,
    however, we will first check to make sure that we are still timing the player.
    If we are no longer timing them, they must have run out of time and lost. Therefore,
    we should not let them cross the finish line and win:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检测玩家是否越过终点线，我们将使用与`KillVolume`脚本相同的`OnTriggerEnter`函数。不过，首先我们会检查是否仍在为玩家计时。如果我们不再为他们计时，那么他们肯定已经用完了时间并且失败了。因此，我们不应该让他们越过终点线并获得胜利：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we turn on the text that tells the player that they have won. We have
    to let them know at some point, so it might as well be now:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们开启告知玩家他们已经获胜的文本。我们总得让他们知道胜利了，现在就是合适的时候：
- en: '[PRE26]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next thing the function does is essentially turn the physics off for the
    monkey ball to stop it from rolling around. By using `attachedRigidbody`, we gain
    access to the **Rigidbody** component, which is the part hooking it into Unity''s
    physics engine that is attached to the object. Then, we set its `isKinematic`
    property to `true`, essentially telling it that it will be controlled by the script
    and not by the physics engine:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数接下来要做的是本质上关闭猴子球的物理效果，防止它继续滚动。通过使用`attachedRigidbody`，我们访问到与物体连接的**Rigidbody**组件，这是连接到Unity物理引擎的部分。然后，我们将它的`isKinematic`属性设置为`true`，基本上告诉它将由脚本控制，而不是由物理引擎控制：
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, the function stops counting the player''s time:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，该函数停止计算玩家的剩余时间：
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last function for this script is the `Update` function, which first checks
    to make sure that the timer is running:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的最后一个函数是`Update`函数，它首先检查以确保计时器正在运行：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It then removes the time since the last frame, from the time remaining to complete
    the level:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它从完成关卡剩余的时间中减去自上一帧以来的时间：
- en: '[PRE30]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we update the time on screen with the amount of time that remains. The
    text on the screen must be in the form of a string, or words. A number, such as
    our remaining time, is not a word, so we use the `ToString` function on it to
    convert it into the right datatype for it to be displayed. Leaving it at that
    would have been fine, but it would have displayed a bunch of extra decimal places
    that the player wouldn''t have even cared about. Therefore, `0.00` is passed to
    the function. We are telling it what format and how many decimal places we want
    the number to have when it becomes a word. This makes it more meaningful to our
    players and much easier to read:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在屏幕上更新剩余的时间。屏幕上的文本必须是字符串形式，或者说是文字。像我们剩余的时间这样的数字并不是文字，所以我们使用`ToString`函数将其转换为正确的数据类型以便显示。如果仅此而已，那也是可以的，但它会显示一堆玩家不会关心的额外小数位。因此，我们传递`0.00`给函数。我们告诉它当数字变成文字时，我们希望它具有的格式和有多少个小数位。这使得它对玩家更有意义，也更容易阅读：
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After checking to see whether the player is out of time, we turn on the text
    that tells them that they have lost and turn off the time display. We also stop
    counting the time. If they are already out of time, what is the point in counting?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查玩家是否超时后，我们开启告知他们已经失败的文本，并关闭时间显示。同时我们也停止计时。如果他们已经超时，继续计时又有什么意义呢？
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we need to return to Unity and make this script work. Do this by first
    creating a new empty **GameObject** and naming it `VictoryPoint`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要回到Unity，让这个脚本工作。首先创建一个新的空**GameObject**，并将其命名为`VictoryPoint`。
- en: It is going to need three cubes as children. Remember, you can find them by
    navigating to **GameObject** | **3D Object** | **Cube**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将需要三个子立方体。记住，你可以通过导航到**GameObject** | **3D Object** | **Cube**来找到它们。
- en: The first cube should be positioned at `1` for **X**, `1` for **Y**, and `0`
    for **Z**. In addition, give it a scale of `0.25` for **X**, `2` for **Y**, and
    `0.25` for **Z**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方块应定位在**X**为`1`，**Y**为`1`，**Z**为`0`的位置。此外，将其缩放为**X**为`0.25`，**Y**为`2`，**Z**为`0.25`。
- en: The second cube should have all of the same settings as the first one, except
    for having a position of `-1` for **X**, which moves it to the opposite side of
    the object.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个方块应具有与第一个相同的所有设置，除了**X**的位置为`-1`，这会将它移动到对象的另一侧。
- en: The last cube needs a position of `0` for **X**, `2.5` for **Y**, and `0` for
    **Z**. Its scale needs to be set as `2.25` for **X**, `1` for **Y**, and `0.25`
    for **Z**. Together, these three cubes give us a basic-looking finish line, which
    will stand out from the rest of the game board.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个方块需要**X**为`0`，**Y**为`2.5`，**Z**为`0`的位置。它的缩放比例需要设置为**X**为`2.25`，**Y**为`1`，**Z**为`0.25`。这这三个方块共同构成了一个基本外观的终点线，它将突出于游戏板的其他部分。
- en: Next, we are going to need some text objects for the GUI. Create three of them,
    by navigating to **GameObject** | **UI** | **Text**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为GUI创建一些文本对象。通过导航到**GameObject** | **UI** | **Text**来创建三个对象。
- en: The first should be named `Timer`; this will handle the display, showing how
    much time remains for the player to reach the finish line. It needs to be anchored
    to the **top-left** with a position of `80` for **Pos X** and `-20` for **Pos
    Y**. It also needs a value of `130` for **Width** and a value of `30` for **Height**.
    We can also change the default text to `0.00` so that we have a better idea of
    how it will look in the game. A **Font Size** value of `20` and **Alignment**
    of **left-center** will position it well for us.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个应命名为`Timer`；这将处理显示，显示玩家到达终点线还剩多少时间。它需要锚定在**左上角**，**Pos X**为`80`，**Pos Y**为`-20`。它还需要**宽度**为`130`，**高度**为`30`。我们可以将默认文本更改为`0.00`，以便我们更好地了解在游戏中它的样子。**字体大小**为`20`和**对齐方式**为**左中**将为我们很好地定位它。
- en: The second text object should be named `Victory`; it will display the message
    shown when the player reaches the finish line. It needs to be anchored in **middle-center**
    with a position of `0` for **Pos X** and **Pos Y**. It needs a value of `200`
    for **Width** and a value of `60` for **Height** so that we will have enough space
    to draw the message. Change the default text to `You Win!`, increase **Font Size**
    to `50,` and select **middle-center** for **Alignment** so that we get a nice,
    big message in the center of the screen.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个文本对象应命名为`Victory`；当玩家到达终点线时，它将显示消息。它需要锚定在**居中**，**Pos X**和**Pos Y**为`0`。它需要**宽度**为`200`和**高度**为`60`，这样我们就有足够的空间绘制消息。将默认文本更改为`You
    Win!`，将**字体大小**增加到`50`，并选择**居中对齐**，以便我们在屏幕中央获得一个清晰的大消息。
- en: The last text object should be named `OutOfTime`; it will display the message
    when the player fails to reach the end, before the timer runs down. It shares
    all the same settings as the previous one, except it needs a value of `500` for
    **Width** to fit its larger default text of `You Ran Out Of Time!`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个文本对象应命名为`OutOfTime`；当玩家在计时器归零前未能到达终点时，它将显示消息。除了**宽度**需要设置为`500`以适应其更大的默认文本`You
    Ran Out Of Time!`外，它与其他对象共享所有相同的设置。
- en: Next, we need to select `VictoryPoint` and give it a **BoxCollider** component,
    as well as our `VictoryVolume` script.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择`VictoryPoint`并为其添加**BoxCollider**组件，以及我们的`VictoryVolume`脚本。
- en: The **BoxCollider** component is going to need the **Is Trigger** box to be
    checked. It needs a value of `0` for **X**, `1` for **Y**, and `0` for **Z** for
    **Center**. In addition, **Size** should be `1.75` for **X**, `2` for **Y**, and
    `0.25` for **Z**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**BoxCollider**组件需要勾选**Is Trigger**复选框。**中心**的**X**需要`0`，**Y**需要`1`，**Z**需要`0`。此外，**大小**的**X**应为`1.75`，**Y**应为`2`，**Z**应为`0.25`。'
- en: Finally, drag each of the text objects that we just created to the appropriate
    slot on the **VictoryVolume** script component.![Winning and losing the game](img/4691OT_06_07.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将我们刚刚创建的每个文本对象拖动到**VictoryVolume**脚本组件上的适当槽位。![游戏的胜利与失败](img/4691OT_06_07.jpg)
- en: We've just finished putting together a means by which the player can either
    win or lose the game. If you were to try it out now, you should be able to see
    the timer tick down in the top-left corner of the screen. When you manage to reach
    the finish line in time, a nice message is displayed indicating this. If you are
    not quite as successful in reaching it, a different message is displayed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了一个设定，玩家可以通过这个设定赢得或输掉游戏。如果你现在尝试一下，你应该能在屏幕左上角看到计时器倒计时。当你及时到达终点线时，会显示一条好消息来提示你。如果你没能成功到达，则会显示另一条消息。
- en: This is the entire interface that we will be creating for this game, but it
    is still awfully bland. Use your skills from what you learned in [Chapter 2](ch02.html
    "Chapter 2. Looking Good – The Graphical Interface"), *Looking Good – The Graphical
    Interface* to style the interface. It should look pleasing and exciting, perhaps
    even monkey-themed. To get extra fancy, you could try to set it up to change colors
    and size as the remaining time approaches zero, giving the player an indication
    at a glance of where they stand in terms of the time remaining to complete that
    level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将为这款游戏创建的整个界面，但它仍然相当乏味。利用你在[第2章](ch02.html "第2章. 看起来不错——图形界面")中学到的技能，*看起来不错——图形界面*来设计界面。它应该看起来令人愉悦和兴奋，甚至可以是猴子主题的。为了使其更高级，你可以尝试设置它，让剩余时间接近零时改变颜色和大小，让玩家一眼就能看出完成该关卡剩余的时间。
- en: The finish line also looks boring, as it is made only out of cubes. Try your
    hand at creating a new one. It could have some sort of finish line banner across
    it, like they have in races. Maybe it could be a little more round-looking. If
    you wanted to get really fancy, you could look at creating a second timer that
    would exist at the front of the finish line. It would allow the player to look
    at the world, where most of their focus will be, and know what their remaining
    time is.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 终点线看起来也很单调，因为它只是由方块组成。尝试自己创建一个新的终点线。它可以在上面横幅上有一个终点线标志，就像比赛中的那样。也许它可以看起来更圆润一些。如果你想让它更高级，你可以考虑在终点线前面创建第二个计时器。这样玩家可以看着世界，他们的主要焦点在这里，并知道剩余的时间。
- en: Putting together the complex environment
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装复杂的环境。
- en: 'Having a one block map does not make for a very interesting game experience.
    It works excellently for us to set up the controls, but the players will not find
    it much fun. So, we need something a little better. Here, we will be setting up
    a more complex environment with ramps, bridges, and turns. We will also use some
    fences to help and guide the player. Let''s do this all with these steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方块地图并不能提供很有趣的游戏体验。它非常适合我们设置控制，但玩家会觉得这并不有趣。因此，我们需要一些更好的东西。在这里，我们将设置一个更复杂的环境，包括斜坡、桥梁和弯道。我们还将使用一些围栏来帮助和引导玩家。让我们按照以下步骤进行：
- en: Start by adding the `MonkeyBallMap` model to the scene.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`MonkeyBallMap`模型添加到场景中。
- en: Set its **Scale** attribute to `100` on each axis and its **Position** attribute
    to `0` on each axis.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**缩放**属性在每个轴上设置为`100`，并将其**位置**属性在每个轴上设置为`0`。
- en: If the map appears to be white, then apply the `Grass` texture to it. This map
    gives us a good starting platform, a half-pipe ramp, a few turns, and a short
    bridge. Altogether, there are plenty of basic challenges for the player.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果地图看起来是白色的，那么为其应用`Grass`纹理。这个地图为我们提供了一个良好的起点平台，一个半管斜坡，几个弯道，以及一座短桥。总的来说，玩家将面临许多基本挑战。
- en: To enable our ball to actually to use the map, it is going to need some colliders
    to make it physical. Expand `MonkeyBallMap` in the **Hierarchy** window and select
    both `FlatBits` and `HalfPipe`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们的球能够实际使用这个地图，它需要一些碰撞器来使其具有物理特性。在**层次结构**窗口中展开`MonkeyBallMap`，并选择`FlatBits`和`HalfPipe`。
- en: On to each of these objects add a **MeshCollider** component, just like we did
    for some of the parts of our tank city. Remember, it can be found by navigating
    to **Component** | **Physics** | **Mesh Collider**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些对象上添加一个**网格碰撞器**组件，就像我们为坦克城市的某些部分所做的那样。记住，可以通过导航到**组件** | **物理** | **网格碰撞器**来找到它。
- en: Next, we have the `Fence` model. With this, we can both help and hinder the
    player by placing guardrails along the edges or blockages in their path. Start
    by dragging the `Fence` model into the scene and setting its **Scale** to `100`
    to keep it sized in proportion to our map.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`Fence`模型。通过这个模型，我们可以在边缘放置护栏或者在玩家路径中设置障碍来帮助或阻碍玩家。首先将`Fence`模型拖入场景，并将其**缩放**设置为`100`，以保持与地图的比例。
- en: To enable the fences to physically block the player, they need a collider. To
    both of the children fence objects, add a **BoxCollider** component that can be
    found by navigating to **Component** | **Physics** | **Box Collider**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使围栏能够物理地阻挡玩家，它们需要一个碰撞器。对于两个子围栏对象，添加一个 **BoxCollider** 组件，可以通过导航到 **组件** |
    **物理** | **盒碰撞器** 来找到。
- en: In addition, ensure that you apply the `Wood` texture to both of the fence pieces
    if they appear white in the scene.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果围栏在场景中显示为白色，请确保你将 `Wood` 文理应用到两个围栏部件上。
- en: Create a new empty **GameObject** and name it `Fences`. Then, set its **Position**
    attribute to `0` on each axis. This object will help us to stay organized because
    we could end up with a great many pieces of fence.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 **GameObject** 并将其命名为 `Fences`。然后，将其 **位置** 属性在每一个轴上设置为 `0`。这个对象将帮助我们保持组织有序，因为最终我们可能会有很多围栏部件。
- en: Now, expand the `Fence` model in the **Hierarchy** window and make both `Post`
    and `PostWithSpokes` children of the `Fences` empty **GameObject**. Then, delete
    the `Fence` object. By doing this, we break the prefab connection and remove the
    risk of recreating it. If we had just used the `Fence` object for our organization,
    there was a risk that we could've ended up deleting all of our work that we put
    in setting them up in the scene if we made changes to the original model file.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **层次结构** 窗口中展开 `Fence` 模型，并使 `Post` 和 `PostWithSpokes` 成为 `Fences` 空的 **GameObject**
    的子对象。然后，删除 `Fence` 对象。这样做，我们打破了预制体的连接，消除了重新创建它的风险。如果我们只是用 `Fence` 对象来组织，那么如果我们对原始模型文件进行更改，就有可能删除我们在场景中设置它们时所做的一切工作。
- en: We need to position the fences in strategic locations to affect how our player
    is able to play the game. The first place we might want to put them is around
    the starting area, giving our player a nice safe beginning to the game. Remember,
    you can use *Ctrl* + *D* to duplicate the fence pieces so that you will always
    have enough fences.![Putting together the complex environment](img/4691OT_06_08.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将围栏放置在战略位置，以影响玩家玩游戏的方式。我们可能想要放置它们的第一个地方是起始区域周围，为玩家提供一个游戏开始的良好安全环境。记住，你可以使用
    *Ctrl* + *D* 来复制围栏部件，这样你就总会有足够的围栏。![组装复杂环境](img/4691OT_06_08.jpg)
- en: The second place to put fences would be after the half pipe, just before the
    bridge. Here, they would help the player to reorient themselves before they try
    to go across the small bridge:![Putting together the complex environment](img/4691OT_06_09.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置围栏的第二个地方是在半管之后，正好在桥前。在这里，它们可以帮助玩家在尝试过小桥之前重新定位自己：![组装复杂环境](img/4691OT_06_09.jpg)
- en: The last place we could put them would be a hindrance to the player. If we place
    them in the middle of the final platform, we would force the player to go around
    and risk falling off before reaching the end.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以放置围栏的最后一个地方可能会阻碍玩家。如果我们把它们放在最后平台的中间，我们就会迫使玩家绕行，并在到达终点前冒着跌落的危险。
- en: Speaking of the finish line, now that everything else is placed, we need to
    move it into position. Place it at the end of the lower platform. Here, the player
    will have to face all of the challenges of the map and risk falling many times
    before they finally achieve victory by reaching the end.![Putting together the
    complex environment](img/4691OT_06_10.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说到终点线，现在其他一切都已布置完毕，我们需要将其移至适当位置。将其放置在较低平台的末端。在这里，玩家必须面对地图上的所有挑战，并在最终达成胜利前多次冒着跌落的危险。![组装复杂环境](img/4691OT_06_10.jpg)
- en: That is it for setting up our complex environment. We gave the player a chance
    to orient themselves before forcing them to navigate a handful of challenges and
    reach the end. Give it a try. Our game is starting to look really nice.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置我们复杂环境的全部内容。我们让玩家有机会在强制他们导航一系列挑战并到达终点之前先定位自己。试一试吧。我们的游戏看起来真的很不错。
- en: The first challenge here might be quite obvious. Try your hand at making your
    own map with ramps, bridges, chutes, and blockages. You could perhaps make a big
    maze out of the fences. Otherwise, you could alter the level so that it actually
    requires the player to go up some straight paths and ramps, meaning the player
    would need enough speed to make it. There might even be the need for a few jumps.
    Make the player go down a ramp to gain speed before jumping across to another
    platform. Whatever your new level becomes, make sure that `KillVolume` is below
    it and covers plenty of area underneath. You never quite know how the players
    will play and where they will manage to get themselves stuck.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个挑战可能相当明显。尝试自己制作一个带有坡道、桥梁、滑梯和障碍的地图。你可能可以用围栏制作一个大型迷宫。否则，你可以改变关卡，使其实际上要求玩家沿着一些直线路径和坡道向上，这意味着玩家需要足够速度来完成。可能还需要进行几次跳跃。让玩家沿着坡道下滑以获得速度，然后跳到另一个平台上。无论你的新关卡变成什么样，确保`KillVolume`在它的下方，并且覆盖足够大的区域。你永远不知道玩家会如何玩，以及他们会如何卡住自己。
- en: The map itself looks pretty good, but the area around it could use some work.
    Use your skills from the previous chapters—add a skybox to the world, something
    that looks better than the defaults. While you're at it, work with the lighting.
    A single **Directional Light** is nice but not very interesting. Create some light
    source models to place round the map. Then, bake the lightmaps to create some
    good quality shadows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 地图本身看起来很不错，但周围的区域还需要加工。利用你之前章节学到的技能——为世界添加一个天空盒，比默认的看起来更好。同时，调整一下光线。一个单一的**定向光**不错，但不够有趣。创建一些光源模型放置在地图周围。然后，烘焙光照贴图以产生一些高质量的阴影。
- en: Adding bananas
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加香蕉
- en: 'When it comes to a game with monkeys, the most obvious thing for our player
    to collect is bananas. However, it is never enough to have items in the world
    for players to collect; we have to show the player that the items are collectible.
    Usually, this means that the thing is spinning, bouncing, shining, generating
    sparks, or demonstrating some other special effect. For our game, we are going
    to make the bananas bounce up and down while spinning in place. Let''s do it with
    these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到猴子游戏时，玩家最明显要收集的物品就是香蕉。然而，仅仅在世界上拥有可收集的物品是不够的；我们还得向玩家展示这些物品是可以被收集的。通常，这意味着物品在旋转、弹跳、发光、产生火花或展示其他特殊效果。对于我们的游戏，我们将使香蕉在原地旋转的同时上下弹跳。下面是完成这个效果的步骤：
- en: Right off the bat, we are going to need a new script. Create one and name it
    `BananaBounce`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的脚本。创建一个并命名为`BananaBounce`。
- en: 'This script begins with three variables. The first is how fast, in meters per
    second, the banana will move up and down. The second is how high the banana will
    go from its starting position. The third is at how many degrees per second the
    banana will spin in place. Altogether, these variables will let us easily control
    and tweak the movement of the banana:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从三个变量开始。第一个是香蕉上下移动的速度，单位是每秒米。第二个是香蕉从起始位置会移动多高。第三个是香蕉每秒在原地旋转多少度。这些变量共同使我们能够轻松控制和调整香蕉的运动：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This next variable will keep track of the actual object that will be moving.
    By using two objects for the setup and control of the banana, we are able to separate
    position and rotation and make everything easier:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量将跟踪实际移动的对象。通过使用两个对象来设置和控制香蕉，我们能够将位置和旋转分离，使一切变得更容易：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The function for this script is `Update`. It first checks to make sure that
    our `bobber` variable has been filled. Without it, we can''t do anything to make
    our banana move:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的函数是`Update`。它首先检查以确保我们的`bobber`变量已被填充。如果没有它，我们就无法进行操作使香蕉移动：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we use the `PingPong` function to calculate a new position for our banana.
    This function bounces a value between zero and the second value you to it. In
    this case, we are using the current time multiplied by our speed to determine
    how far the banana might have moved in this game. By giving a height to it, we
    end up with a value that moves back and forth from zero to our maximum height.
    We then multiply it by an up vector and apply it to our `localPosition` so that
    the banana will move up and down:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`PingPong`函数为我们的香蕉计算一个新位置。这个函数会在零和传递给它的第二个值之间反弹一个值。在这个案例中，我们使用当前时间乘以我们的速度来确定在这场游戏中香蕉可能移动了多远。通过给它一个高度，我们得到一个从零到我们最大高度来回移动的值。然后我们将其乘以一个向上向量，并将其应用到我们的`localPosition`上，使香蕉能够上下移动：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we use the same `Rotate` function that we used for rotating turrets
    to make the banana spin in its place. It will just do this constantly at whatever
    speed we tell it to:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用之前用于旋转炮塔的同一个`Rotate`函数，让香蕉在原地旋转。它会以我们设定的任何速度不断旋转。
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we need to return to Unity and set these bananas up. To do this, we first
    need to add the `Banana` model to the scene. If it is white, be sure to add the
    `Banana` texture to it.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要回到 Unity 并设置这些香蕉。为此，我们首先需要在场景中添加`Banana`模型。如果它是白色的，确保为其添加`Banana`纹理。
- en: Add our `BananaBounce` script to the new banana, or else it is just not going
    to set there.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让新香蕉弹跳，需要添加我们的`BananaBounce`脚本，否则它就不会在那里弹跳。
- en: The child object of `Banana` needs to be put in the **Bobber** slot on our script
    component.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Banana`的子对象需要放在我们脚本组件中的**Bobber**槽位上。'
- en: 'Finally, turn it into a prefab and scatter them about the map: a few at the
    beginning area, a few near the finish line, and some along the way.![Adding bananas](img/4691OT_06_11.jpg)'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，把它变成一个预制体，在地图上散布一些：在初始区域放几个，在终点线附近放几个，沿途也放一些。![添加香蕉](img/4691OT_06_11.jpg)
- en: If you try out the game now, you should have several happily bouncing bananas.
    By using the `Mathf.PingPong` function, our jobs are made very easy for the creation
    of this effect. Without it, we would have needed to do a bunch of extra calculations
    to figure out whether we were moving up or down and how far along we were.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试游戏，你应该会看到有几个快乐弹跳的香蕉。通过使用`Mathf.PingPong`函数，我们很容易就能创建这种效果。如果没有它，我们需要做很多额外的计算来确定我们是向上还是向下移动以及移动了多远。
- en: Having bananas as collectibles is great, but which game these days has a single
    type of pickup? Try your hand at making some other pickup models. The most obvious
    one would be some banana bundles, such as the bunches that you can buy at the
    grocery store or the huge bunch that actually grows on banana trees. However,
    you could also go down the route of coins, energy crystals, ancient monkey totems,
    checkpoints, score multipliers, or anything else that might catch your attention.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 收集香蕉作为收藏品很棒，但现在哪个游戏只有一种拾取物品呢？尝试制作一些其他拾取物品的模型。最明显的就是香蕉束，比如你在杂货店可以买到的那些，或者是实际长在香蕉树上的大串香蕉。不过，你还可以选择硬币、能量水晶、古老猴子图腾、检查点、分数乘数，或者任何可能吸引你注意的东西。
- en: Collecting bananas with touch
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用触摸收集香蕉
- en: 'One of the most obvious features of the modern mobile device is the touch screen.
    Devices use the electrical conductivity of the user''s finger and many tiny contact
    points to determine the location that is being touched. In order to explore the
    possibilities of the touch interface for our game, we will be making our players
    poke the bananas on the screen rather than running into them to collect them.
    Unity provides us with easy access to the touch inputs. By combining the input
    with ray casts, as we did for making the tanks fire, we can determine which object
    in the 3D space was touched by the user. For us, this means we can give the player
    the ability to touch and collect those bananas. To do it, let''s use these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动设备最明显的特点之一就是触摸屏。设备使用用户的指尖电导性和许多微小的接触点来确定被触摸的位置。为了探索我们的游戏触摸界面的可能性，我们将让玩家戳屏幕上的香蕉，而不是跑过去收集它们。Unity
    为我们提供了轻松访问触摸输入的方法。通过将输入与射线投射结合，就像我们之前让坦克开火一样，我们可以确定3D空间中被用户触摸的物体。对于我们来说，这意味着我们可以让玩家触摸并收集那些香蕉。要做到这一点，请按照以下步骤操作：
- en: First up, we need a new script. Create one and name it `BananaTouch`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新脚本。创建一个，并将其命名为`BananaTouch`。
- en: 'The `Update` function is the only function in this script. It starts by checking
    to see whether the player is touching the screen in any way. The `Input` class
    provides us with the `touchCount` value, which is simply a counter for how many
    fingers are currently touching the device''s screen. If there are no fingers touching,
    we don''t want to waste our time doing any work, so we exit early with `return`:
    and are ready to check the next frame again to see whether the player is touching
    the screen.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update`函数是这段脚本中唯一的函数。它首先检查玩家是否以任何方式触摸屏幕。`Input`类为我们提供了`touchCount`值，这只是一个计数器，用来记录当前触摸设备屏幕的手指数量。如果没有手指触摸，我们不想浪费时间做任何工作，所以我们会提前退出`return`：并准备好再次检查下一帧，看玩家是否触摸了屏幕。'
- en: '[PRE38]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We next create a `foreach` loop. This is a loop that will check each item in
    the list of touches, but it will not track the index of that touch. We then check
    the phase of each touch to see whether it has just started touching the screen.
    Every touch has five potential phases: **Began**, **Moved**, **Stationary**, **Ended**,
    and **Canceled**:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`foreach`循环。这是一个将检查触摸列表中的每个项目的循环，但它不会跟踪触摸的索引。然后我们检查每个触摸的阶段，以判断它是否刚刚开始触摸屏幕。每个触摸都有五个可能的状态：**开始**，**移动**，**静止**，**结束**和**已取消**：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the description for each state:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是每个状态的描述：
- en: '**Began**: This phase of touch occurs when the user first touches the screen.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**：当用户首次触摸屏幕时，会进入此触摸阶段。'
- en: '**Moved**: This phase of touch occurs when the user moves his or her finger
    across the screen.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：当用户在屏幕上移动手指时，会进入此触摸阶段。'
- en: '**Stationary**: This phase of touch is the opposite of the previous phase;
    this happens when the user''s finger is not moving across the screen.'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静止**：此触摸阶段与上一个阶段相反；当用户的 finger 在屏幕上不移动时发生。'
- en: '**Ended**: This phase of touch occurs when the user''s finger is lifted off
    the screen. This is the normal way for a touch to complete.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束**：当用户的手指离开屏幕时，会进入此触摸阶段。这是触摸完成的正常方式。'
- en: '**Canceled**: This phase of touch occurs when an error occurs while tracking
    the touch. This phase tends to occur most often when a finger is touching the
    screen but not moving for a lot of time. The touch system is not perfect, so it
    assumes that it missed the finger being lifted off the screen and just cancels
    that touch.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已取消**：当跟踪触摸时发生错误时，会进入此触摸阶段。这种阶段通常在手指触摸屏幕但不移动一段时间后最常发生。触摸系统并不完美，所以它会假设错过了手指离开屏幕的动作，并取消该触摸。'
- en: 'Next, we create a pair of variables. As with our tanks, the first is a holder
    for what was hit by our raycast. The second is a `Ray`, which is just a container
    for storing a point in space and a directional vector. The `ScreenPointToRay`
    function is specially provided by the camera for converting touch positions from
    the 2D space of the screen to the 3D space of the game world:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一对变量。就像我们的坦克一样，第一个变量用于保存被我们的射线投射命中的对象。第二个是一个`Ray`类型的变量，它只是一个用于存储空间中的一个点和方向向量的容器。`ScreenPointToRay`函数是相机专门提供的，用于将屏幕上2D空间的触摸位置转换为游戏世界中3D空间的位置：
- en: '[PRE40]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last step for the function is to call the `Raycast` function. We pass the
    ray and the tracking variable to the function. If an object is hit, we send it
    a message to tell it that it has been touched, just like shooting things with
    our tank. In addition, there are several curly braces that are required to close
    off the `if` statements, loop, and function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最后一步是调用`Raycast`函数。我们将射线和跟踪变量传递给该函数。如果击中了对象，我们向它发送一个消息，告诉它已被触摸，就像用我们的坦克射击东西一样。此外，还需要几个花括号来结束`if`语句、循环和函数：
- en: '[PRE41]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Before we can try it out, we need to update our `BananaBounce` script to give
    it some health and allow it to be destroyed when its health runs out. So, open
    it now.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试之前，我们需要更新我们的`BananaBounce`脚本，为其添加一些生命值，并在生命值耗尽时允许其被摧毁。所以，现在就打开它吧。
- en: 'First, we need a pair of variables. The first is `health`. Actually, this is
    just the number of touches that are required to destroy the banana. If we had
    multiple types of bananas, they could each have a different amount of health.
    The second variable is a modifier for the banana''s speed of movement. Every time
    the banana loses health, it will slow down, indicating how much health it has
    left:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一对变量。第一个是`health`。实际上，这只是摧毁香蕉所需的触摸次数。如果我们有不同类型的香蕉，它们可以各有不同的生命值。第二个变量是香蕉移动速度的调节器。每次香蕉失去生命值，它的移动速度就会减慢，表明它还剩下多少生命值：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we need to add a new function. This `Touched` function will receive the
    message from our `BananaTouch` script. It works similar to how we shot with our
    tank. The very first thing it does is reduce the remaining health:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个新函数。这个`Touched`函数将接收来自我们的`BananaTouch`脚本的消息。它的工作原理类似于我们用坦克射击的方式。它做的第一件事是减少剩余的生命值：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After some damage has been done, we can slow the movement of the banana by
    doing a little division. This way it is easy for the player to know whether their
    touch was successful:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在造成一些伤害之后，我们可以通过进行一些除法运算来减慢香蕉的移动速度。这样玩家就能轻松判断他们的触摸是否成功：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the function checks to see whether the banana has run out of health.
    If it has, we use the `Destroy` function to get rid of it, just like the enemy
    tanks:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，函数会检查香蕉是否已经耗尽生命值。如果是，我们使用`Destroy`函数来移除它，就像敌方坦克一样：
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you return to Unity, you need to attach our new `BananaTouch` script to
    the `MonkeyBall` object. Due to the way it works, it could technically go on any
    object, but it is always a good practice to keep player control scripts together
    and on what they are controlling.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你回到Unity时，需要将我们新的`BananaTouch`脚本附加到`MonkeyBall`对象上。由于它的工作原理，它实际上可以放在任何对象上，但最好是将玩家控制脚本保持在一起，并放在它们所控制的对象上。
- en: Next, add a **Sphere Collider** component to one of your bananas; this can be
    found by navigating to **Component** | **Physics** | **Sphere Collider**. If we
    make the changes to one and update the prefab, all the bananas in the scene will
    be updated.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为其中一个香蕉添加一个**球体碰撞器**组件，你可以通过导航到**组件** | **物理** | **球体碰撞器**来找到它。如果我们对一个进行更改并更新预制体，场景中的所有香蕉都将被更新。
- en: Check the **Is Trigger** box so that the bananas do not block the movement of
    our monkey,. They will still be touchable while allowing our monkey to pass through
    them.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**是触发器**复选框，这样香蕉就不会阻挡我们猴子的移动。它们仍然可以被触摸，同时允许我们的猴子穿过它们。
- en: The collider also needs to be positioned in a place where the player will mostly
    touch when they hit it. So, set the **Center** to `0` for **X**, `0.375` for **Y**,
    and `0` for **Z**. In addition, make sure the **Radius** is set to `0.5`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 碰撞器还需要被放置在玩家在击中时通常会触摸的位置。因此，将**中心**设置为**X**的`0`，**Y**的`0.375`，**Z**的`0`。此外，确保将**半径**设置为`0.5`。
- en: Finally, be sure to hit the **Apply** button at the top right of the **Inspector**
    panel to update all the bananas in the scene.![Collecting bananas with touch](img/4691OT_06_12.jpg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保点击**应用**按钮，位于**检查器**面板右上角，以更新场景中的所有香蕉。![使用触摸收集香蕉](img/4691OT_06_12.jpg)
- en: When you try out the game now, you should be able to touch any of the bananas.
    Initially, all of the bananas will move up and down evenly, like they did earlier.
    As you touch them, the ones that you touched will move slower, thanks to the bit
    of division that we made, before they are finally deleted. This lets our player
    easily see which bananas have been touched and which haven't.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试游戏，你应该能够触摸任何香蕉。最初，所有香蕉会像之前一样均匀地上下移动。当你触摸它们时，由于我们做的除法运算，你触摸的香蕉会移动得慢一些，然后最终消失。这让我们的玩家能够轻松地看出哪些香蕉被触摸过，哪些没有。
- en: The next step from having collectible objects in a game is to give meaning to
    the player. This is mostly done by giving them some point value. Try to do that
    here. It could be done in a very similar manner to the point system we had when
    we were destroying enemy tanks. If you created some other pickups earlier, you
    could set each of them up to have different amounts of health. They could also
    give you different amounts of points as a result. Play around with the numbers
    and settings until you find something that will be fun for the player to interact
    with.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中拥有可收集物体之后，下一步是给玩家赋予意义。这通常是通过给它们一些积分值来实现的。在这里尝试这样做。它与我们之前摧毁敌方坦克时的积分系统非常相似。如果你之前创建了一些其他的收集物，你可以设置它们每个拥有不同的生命值。因此，它们也可以给你不同的积分。调整数字和设置，直到找到玩家互动起来会感到有趣的东西。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the specialties of the modern mobile device.
    We created a Monkey Ball game to try this out. We gained access to the device's
    gyroscope to detect when it is rotated. This gave our monkey the ability to be
    directed. After creating a more complex and interesting environment for the player
    to move around, we created a bunch of bananas that bob up and down while spinning
    in place. We also made use of the touch screen to give the player the ability
    to collect the bananas.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了现代移动设备的特点。我们创建了一个猴子球游戏来尝试这个功能。我们访问了设备的陀螺仪来检测它何时被旋转。这让我们的猴子能够被引导。在为玩家创建了一个更复杂、更有趣的运动环境后，我们创建了一串会原地旋转同时上下浮动的香蕉。我们还利用触摸屏让玩家能够收集香蕉。
- en: In the next chapter, we will be taking a short break from our Monkey Ball game.
    One of the most popular mobile games on the market, Angry Birds, is a distinct
    and not uncommon type of game. In order to learn about physics in Unity and the
    possibility of a 2D-style game, we will be making an Angry Birds clone. We will
    also take a look at Parallax scrolling to help us create a pleasing background.
    Before you know it, we will be creating all of the Angry Birds levels that you
    always wished you could play.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时放下我们的猴子球游戏。市场上最受欢迎的移动游戏之一，愤怒的小鸟，是一种独特且并不罕见的游戏类型。为了了解 Unity 中的物理学以及2D风格游戏的可能性，我们将制作一个愤怒的小鸟克隆版。我们还将探讨视差滚动，以帮助我们创建一个令人愉悦的背景。在你意识到之前，我们将创造出所有你一直希望玩到的愤怒的小鸟关卡。
