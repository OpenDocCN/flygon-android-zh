- en: Chapter 6. Rendering Graphics with OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 使用 OpenGL ES 渲染图形
- en: '*Let''s face the fact that one of the main interests of Android NDK is to write
    multimedia applications and games. Indeed, these programs consume lots of resources
    and need responsiveness. That is why one of the first available APIs (and almost
    the only one until recently) in Android NDK is an API for graphics: the **Open
    Graphics Library for Embedded Systems** (abbreviated as **OpenGL ES**).*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*面对现实，Android NDK 的主要兴趣之一是编写多媒体应用程序和游戏。实际上，这些程序消耗大量资源并需要响应性。这就是为什么在 Android
    NDK 中最早可用的 API（直到最近几乎也是唯一的一个）是图形 API：**嵌入式系统开放图形库**（简称 **OpenGL ES**）。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*OpenGL is a standard API created by Silicon Graphics and is now managed by
    the Khronos Group (see [http://www.khronos.org/](http://www.khronos.org/)). OpenGL
    provides a common interface for all standard **GPU**s (**Graphics Processing Unit**
    like your graphics card, and so on) on desktops. OpenGL ES is a derivative API
    available on many embedded platforms, such as Android or iOS. It is your best
    hope to write portable and efficient graphics code. OpenGL can render both 2D
    and 3D graphics.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*OpenGL 是由硅谷图形公司创建的一个标准 API，现在由 Khronos Group 管理（见[http://www.khronos.org/](http://www.khronos.org/)）。OpenGL
    为所有桌面上的标准 **GPU**（**图形处理单元**，如你的显卡等）提供了一个通用接口。OpenGL ES 是在许多嵌入式平台上可用的衍生 API，例如
    Android 或 iOS。它是编写可移植和高效图形代码的最佳选择。OpenGL 可以渲染 2D 和 3D 图形。*'
- en: 'There are three main releases of OpenGL ES currently supported by Android:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Android 支持的 OpenGL ES 有三个主要版本：
- en: OpenGL ES 1.0 and 1.1 are supported on all Android devices (except 1.1, which
    is supported on a few very old devices). It offers an old school graphic API with
    a **fixed pipeline** (that is, a fixed set of configurable operations to transform
    and render geometry). Specification is not completely implemented, but most features
    are available. This could still be a good choice for simple 2D or 3D graphics
    or to port legacy OpenGL code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 1.0 和 1.1 在所有 Android 设备上得到支持（除了 1.1，只在一些非常旧的设备上支持）。它提供了一个老式的图形 API，具有**固定管线**（即，一组可配置的操作，用于转换和渲染几何体）。规范没有完全实现，但大多数功能是可用的。这仍然是简单
    2D 或 3D 图形或移植旧版 OpenGL 代码的好选择。
- en: OpenGL ES 2 is supported on almost all phones nowadays, even older ones, starting
    from API Level 8\. It replaces the fixed pipeline with a modern programmable pipeline
    with **Vertex** and **Fragment Shaders**. It is a bit more complex but also more
    powerful. It is a good choice for the more complex 2D or 3D games, while still
    maintaining a very good compatibility. Note that OpenGL ES 1.X is frequently emulated
    by an OpenGL 2 implementation behind the scenes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，几乎所有的手机，即使是较旧的型号，从 API 级别 8 开始都支持 OpenGL ES 2。它用现代的可编程管线替换了固定管线，包括**顶点**和**片段着色器**。它稍微复杂一些，但功能也更强大。对于更复杂的
    2D 或 3D 游戏，这是一个不错的选择，同时仍然保持非常好的兼容性。请注意，OpenGL ES 1.X 通常会在幕后由 OpenGL 2 的实现进行模拟。*
- en: OpenGL ES 3.0 is available on modern devices starting from API Level 18, and
    OpenGL ES 3.1 is available starting from API Level 21 (not all devices at these
    API level may support it though). They bring a set of new improvements to GLES
    2 (**Texture Compression** as a standard feature, **Occlusion Queries, Instanced
    Rendering**, and others for 3.0, **Compute Shaders**, **Indirect Draw** commands,
    and others for 3.1) and a better compatibility with the desktop version of OpenGL.
    It is backward compatible with OpenGL ES 2.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 从 API 级别 18 开始在现代设备上可用，而 OpenGL ES 3.1 则从 API 级别 21 开始可用（不过，这些
    API 级别上的并非所有设备都支持它）。它们为 GLES 2 带来了一系列新改进（**纹理压缩**作为标准特性，**遮挡查询、实例渲染**等属于 3.0，**计算着色器**、**间接绘制**命令等属于
    3.1），并与桌面版 OpenGL 的兼容性更好。它与 OpenGL ES 2 向后兼容。
- en: 'This chapter teaches you how to create some basic 2D graphics using OpenGL
    ES 2\. More specifically, you are going to discover how to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用 OpenGL ES 2 创建一些基本的 2D 图形。更具体地说，你将了解到如何：
- en: Initialize OpenGL ES
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 OpenGL ES
- en: Load a texture from a PNG file packaged in the assets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从资产中打包的 PNG 文件加载纹理
- en: Draw sprites using vertex and fragment shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器绘制精灵
- en: Render a particle effect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染粒子效果
- en: Adapt graphics to various resolutions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应各种分辨率图形
- en: With OpenGL ES, and graphics in general, being a wide subject, this chapter
    covers only the basics to being with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenGL ES 以及一般的图形是一个广泛的课题，本章仅涵盖入门的基础知识。
- en: Initializing OpenGL ES
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 OpenGL ES
- en: The first step to create awesome 2D and 3D graphics is to initialize OpenGL
    ES. Although not terribly complex, this task requires some boilerplate code to
    bind a rendering context to an Android window. These pieces are glued together
    with the help of the **Embedded-System Graphics Library** (**EGL**), a companion
    API of OpenGL ES.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建出色的2D和3D图形的第一步是初始化OpenGL ES。尽管不是特别复杂，但这项任务需要一些样板代码将渲染上下文绑定到Android窗口。这些部分在**嵌入式系统图形库**（**EGL**）的帮助下粘合在一起，它是OpenGL
    ES的伴随API。
- en: For this first section, we are going to replace the raw drawing system implemented
    in the previous chapter with OpenGL ES. A black to white fading effect will demonstrate
    that the EGL initialization works properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将用OpenGL ES替换前一章中实现的原始绘图系统。黑色到白色的渐变效果将展示EGL初始化是正常工作的。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part5`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目结果名为`DroidBlaster_Part5`。
- en: Time for action – initializing OpenGL ES
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——初始化OpenGL ES
- en: 'Let''s rewrite our `GraphicsManager` to initialize an OpenGL ES context:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`GraphicsManager`以初始化OpenGL ES上下文：
- en: 'Modify `jni/GraphicsManager.hpp` by performing the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下操作来修改`jni/GraphicsManager.hpp`：
- en: Include `EGL/egl.h` to bind OpenGL ES to the Android platform and `GLES2/gl2.h`
    to render graphics
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`EGL/egl.h`以将OpenGL ES绑定到Android平台，以及`GLES2/gl2.h`以渲染图形。
- en: Add a method `stop()` to unbind the OpenGL rendering context and free graphics
    resources when you're leaving the activity
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`stop()`方法，在离开活动时解绑OpenGL渲染上下文并释放图形资源。
- en: 'Define `EGLDisplay`, `EGLSurface`, and `EGLContext` member variables, which
    represent handles to system resources, as shown here:'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`EGLDisplay`、`EGLSurface`和`EGLContext`成员变量，这些变量表示对系统资源的句柄，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Reimplement `jni/GraphicsManager.cpp` by replacing the previous code based
    on Android raw graphics API with OpenGL-based code. Start by adding new members
    to the constructor initialization list:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用基于OpenGL的代码替换`jni/GraphicsManager.cpp`中基于Android原始图形API的先前代码来重新实现它。首先，在构造函数初始化列表中添加新成员：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The hard work must be done in the method `start()`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`start()`方法中必须完成繁重的工作：
- en: First, declare some variables. Note how EGL defines its own types and re-declares
    primitive types `EGLint` and `EGLBoolean` to favor platform independence.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，声明一些变量。注意EGL如何定义自己的类型，并用`EGLint`和`EGLBoolean`重新声明基本类型，以支持平台独立性。
- en: 'Then, define the needed OpenGL configuration in constant attribute lists. Here,
    we want OpenGL ES 2 and a 16 bit surface (5 bits for red, 6 bits for green, and
    5 bits for blue). We could also choose a 32 bit surface for better color fidelity
    (but less performance on some devices). The attribute lists are terminated by
    `EGL_NONE` sentinel:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在常量属性列表中定义所需的OpenGL配置。这里，我们想要OpenGL ES 2和一个16位表面（红色5位，绿色6位，蓝色5位）。我们也可以选择32位表面以获得更好的色彩保真度（但在某些设备上性能较差）。属性列表以`EGL_NONE`结束符结束：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Connect to the default **display**, that is, the Android main window, with
    `eglGetDisplay()` and `eglInitialize()`. Then, find an appropriate **framebuffer**
    (An OpenGL term referring to the rendering surface, and possibly additional buffers,
    such as **Z-buffer** or **Stencil** buffer) configuration with `eglChooseConfig()`
    as the display. Configurations are selected according to the requested attributes:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eglGetDisplay()`和`eglInitialize()`连接到默认**显示**，即Android主窗口。然后，使用`eglChooseConfig()`找到合适的**帧缓冲区**配置（OpenGL术语，指的是渲染表面，可能还包括其他缓冲区，如**Z缓冲区**或**模板缓冲区**）。配置根据请求的属性进行选择：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reconfigure the Android window with the selected configuration (retrieved with
    `eglGetConfigAttrib()`). This operation is Android-specific and performed with
    the Android `ANativeWindow` API.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用选择的配置（通过`eglGetConfigAttrib()`获取）重新配置Android窗口。这个操作是Android特定的，使用Android `ANativeWindow`
    API执行。
- en: 'After that, create the display surface and the OpenGL context using the display
    and configuration selected previously. A context contains all data related to
    OpenGL state (enabled settings, disabled settings, and so on):'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，使用先前选择的显示和配置创建显示表面和OpenGL上下文。上下文包含与OpenGL状态相关的所有数据（启用的设置，禁用的设置等）：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Activate the created rendering context with `eglMakeCurrent()`. Finally, define
    the display viewport according to the surface attributes retrieved with `eglQuerySurface()`.
    The Z-buffer is not needed and can be disabled:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eglMakeCurrent()`激活创建的渲染上下文。最后，根据使用`eglQuerySurface()`获取的表面属性定义显示视口。Z缓冲区不需要，可以禁用：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the application stops running, unbind the application from the Android
    window and release the EGL resources:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序停止运行时，将应用程序从Android窗口解绑并释放EGL资源：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*What just happened?*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have initialized and connected both OpenGL ES and the Android native window
    system together with EGL. Thanks to this API, we have queried a display configuration
    that matches our expectations and creates a framebuffer to render our scene on.
    EGL is a standard API specified by the Khronos group (like OpenGL). Platforms
    often implement their own variant (haphazardly, EAGL on iOS and so on) so that
    the display window initialization remains OS-specific. Thus, portability is quite
    limited in practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初始化并将OpenGL ES和Android原生窗口系统通过EGL连接在一起。得益于这个API，我们已经查询了一个符合我们预期的显示配置，并创建了一个Framebuffer来渲染我们的场景。EGL是由Khronos组（如OpenGL）指定的标准API。平台通常实现自己的变体（例如iOS上的EAGL等），因此显示窗口初始化仍然与操作系统相关。因此，实际上可移植性相当有限。
- en: 'This initialization process results in the creation of an OpenGL context, which
    is the first step to enable the OpenGL graphics pipeline. Special care should
    be taken with OpenGL contexts, which are frequently lost on Android: when you''re
    leaving or going back to the home screen, when a call is received, when devices
    go to sleep, when you''re switching to another application, and so on. As a lost
    context becomes unusable, it is important to release graphics resources as soon
    as possible.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化过程将创建一个OpenGL上下文，这是启用OpenGL图形管道的第一步。应特别注意OpenGL上下文，在Android上它们经常丢失：当你离开或返回主屏幕时，当接到电话时，设备进入休眠状态时，当你切换到另一个应用程序时等等。由于丢失的上下文将无法使用，因此尽快释放图形资源非常重要。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The OpenGL ES specification supports the creation of multiple contexts for one
    display surface. This allows dividing rendering operations among threads or rendering
    to several windows. However, it is not well supported on Android hardware and
    should be avoided.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES规范支持为单一显示表面创建多个上下文。这允许将渲染操作分配给线程或渲染到多个窗口。然而，这在Android硬件上支持不佳，应避免使用。
- en: OpenGL ES is now initialized but nothing will show up unless we start rendering
    some graphics on the display screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES现已初始化，但除非我们开始在显示屏幕上渲染一些图形，否则不会显示任何内容。
- en: Time for action – clearing and swapping buffers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——清除和交换缓冲区
- en: 'Let''s clear the display buffers with a color fading from black to white:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用颜色从黑变白的方式来清除显示缓冲区：
- en: While still being in `jni/GraphicsManager.cpp`, refresh the screen during each
    update step with `eglSwapBuffers()`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.cpp`中，每次更新步骤时使用`eglSwapBuffers()`刷新屏幕。
- en: 'To have a visual feedback, change the display background color gradually with
    the help of `glClearColor()` before erasing the Framebuffer with `glClear()`:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了提供视觉反馈，在用`glClear()`清除Framebuffer之前，借助`glClearColor()`逐渐改变显示背景色：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the `Android.mk` file to link `the EGL` and `GLESv2` libraries:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Android.mk`文件以链接`EGL`和`GLESv2`库：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Launch the application. If everything works fine, your device screen will progressively
    fade from black to white. Instead of clearing the display with a raw `memset()`,
    or setting pixels one by one as seen in the previous chapter, we invoke efficient
    OpenGL ES drawing primitives. Note that the effect appears only the first time
    the application starts because the clear color is stored in a static variable.
    To make it appear again, kill the application and relaunch it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序。如果一切正常，你的设备屏幕将从黑色逐渐过渡到白色。与之前章节中看到的用原始`memset()`清除显示或逐个设置像素点相比，我们现在调用高效的OpenGL
    ES绘图原语。请注意，该效果仅在应用程序首次启动时出现，因为清除颜色存储在一个静态变量中。要使其再次出现，请杀死应用程序并重新启动。
- en: Rendering a scene requires clearing the framebuffer and swapping the display
    buffer. The latter operation is triggered when `eglSwapBuffers()` is invoked.
    Swapping on Android is synchronized with the screen refresh rate to avoid image
    **Tearing**; this is a **VSync**. The refresh rate is variable depending on the
    device. A common value is 60 Hz but some devices have different refresh rates.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染场景需要清除framebuffer并交换显示缓冲区。后者操作是在调用`eglSwapBuffers()`时触发的。在Android上，交换与屏幕刷新率同步以避免图像**撕裂**；这是一个**VSync**。刷新率根据设备而异。一个常见的值是60
    Hz，但有些设备有不同的刷新率。
- en: Internally, rendering is performed on a back buffer which is swapped with the
    front buffer shown to the user. The front buffer becomes the back buffer and vice
    versa (the pointers are switched). This technique is more commonly referred to
    as **page flipping**. According to the driver implementation, the swapping chain
    can be extended with a third buffer. In this situation, we talk about **Triple
    Buffering**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，渲染是在后台缓冲区执行的，该缓冲区与显示给用户的前台缓冲区交换。前台缓冲区变成后台缓冲区，反之亦然（指针交换）。这种技术通常称为**页面翻转**。根据驱动程序实现，交换链可以扩展到第三个缓冲区。在这种情况下，我们称之为**三重缓冲**。
- en: Our OpenGL pipeline is now properly initialized and able to display graphics
    on the screen. However, you may still find this concept of "pipeline" a bit nebulous.
    Let's see what is hidden behind it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的OpenGL管道现在已经正确初始化，能够显示屏幕上的图形。然而，你可能会发现“管道”这个概念还有点模糊。让我们看看它背后隐藏了什么。
- en: An insight into the OpenGL pipeline
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对OpenGL管道的深入理解
- en: 'We talk about pipeline because the graphics data goes through a series of steps
    in which it is transformed. The following diagram shows a simplified representation
    of the OpenGL ES 2 pipeline:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称之为管道，是因为图形数据经过一系列步骤进行转换。以下图表展示了OpenGL ES 2管道的简化表示：
- en: '![An insight into the OpenGL pipeline](img/9645OS_06_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![对OpenGL管道的深入理解](img/9645OS_06_05.jpg)'
- en: '**Vertex Processing**: An input mesh of vertices, given as a **vertex buffer
    object** or a **vertex array**, is transformed vertex by vertex in a vertex shader.
    The vertex shader can, for example, move or rotate single vertices, project them
    onto the screen, adapt texture coordinates, compute lighting, and so on. It generates
    an output vertex that can be processed further in the pipe.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点处理**：作为**顶点缓冲对象**或**顶点数组**输入的顶点网格，在顶点着色器中逐个进行转换。顶点着色器可以移动或旋转单个顶点，将它们投影到屏幕上，调整纹理坐标，计算光照等。它会生成一个输出顶点，该顶点可以在管道中进一步处理。'
- en: '**Primitive Assembly**: Individual vertices are connected together into triangles,
    points, lines, and so on. More connection information is specified by the client
    code when the draw call is sent. It can take the form of an index buffer (each
    index points to a vertex through its rank) or a predefined rule, such as stripping
    or fanning. Transformations such as **back face culling** or **clipping** are
    done at this stage.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图元装配**：单独的顶点被连接成三角形、点、线等。当发送绘制调用时，客户端代码指定了更多的连接信息。它可以是索引缓冲区（每个索引通过其等级指向一个顶点）或预定义的规则，如剥离或扇形连接。如**背面剔除**或**剪辑**等转换在此阶段进行。'
- en: '**Rasterization**: Primitives are interpolated into fragments, which is a term
    covering all the data associated with one pixel to render (such as color, normals,
    and so on). One fragment is related to one pixel. These fragments feed the fragment
    shader.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化**：图元被插值成片段，片段是包含与一个像素渲染相关的所有数据（如颜色、法线等）的术语。一个片段关联一个像素。这些片段为片段着色器提供数据。'
- en: '**Fragment Processing**: The fragment shader is a program which processes each
    fragment to compute the pixel to display. This is the stage where texture mapping,
    using the coordinates computed by the vertex shader and interpolated by the rasterizer,
    is applied. Different shading algorithms can be computed to render specific effects
    (for example, **Toon shading**).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段处理**：片段着色器是一个处理每个片段以计算要显示的像素的程序。这是应用纹理映射的阶段，使用顶点着色器计算并由光栅化器插值的坐标。可以计算不同的着色算法以渲染特定效果（例如，**卡通着色**）。'
- en: '**Pixel Processing**: The fragment shader outputs pixels which have to be merged
    in the existing framebuffer (the rendering surface), where some pixels may be
    already drawn. Transparency effects or blending is applied at this stage.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素处理**：片段着色器输出的像素必须与现有的帧缓冲区（渲染表面）合并，其中一些像素可能已经被绘制。在此阶段应用透明效果或混合。'
- en: The vertex and fragment shaders are programmable in the **GL Shading Language**
    (**GLSL**). They are available only in OpenGL ES 2 and 3\. OpenGL ES 1 provides
    a fixed function pipeline with a predefined set of possible transformations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器可以用**GL着色语言**（**GLSL**）进行编程。它们仅在OpenGL ES 2和3中可用。OpenGL ES 1提供了一个固定功能的管道，具有预定义的可能转换集合。
- en: This is only a brief overview of all the processing done by the OpenGL rendering
    pipeline. To find more information about it, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是OpenGL渲染管线处理流程的简要概述。要了解更多信息，请查看OpenGL.org维基页面 [http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview)。
- en: Loading textures using the Asset manager
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源管理器加载纹理
- en: I guess you need something more consistent than just changing the screen color!
    But before showing awesome graphics in our application, we need to load some external
    resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你需要的不仅仅是改变屏幕颜色！但在我们应用程序中展示出色的图形之前，我们需要加载一些外部资源。
- en: In this second part, we are going to load a texture into OpenGL ES thanks to
    the Android Asset manager, an API provided since NDK R5\. It allows programmers
    to access any resources stored in the `assets` folder in their project. Assets
    stored there are then packaged into the final APK archive during application compilation.
    Asset resources are considered as raw binary files that your application needs
    to interpret and access using their filename relative to the `assets` folder (a
    file `assets/mydir/myfile` can be accessed with `mydir/myfile` path). Files are
    available in the read-only mode and might be compressed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们将通过Android资源管理器加载纹理到OpenGL ES中，这是从NDK R5开始提供的API。它允许程序员访问项目 `assets`
    文件夹中存储的任何资源。这些资源在应用程序编译期间被打包到最终的APK存档中。资源被视为原始二进制文件，你的应用程序需要通过相对于 `assets` 文件夹的文件名来解释和访问（一个文件
    `assets/mydir/myfile` 可以通过 `mydir/myfile` 路径访问）。文件以只读模式提供，可能会被压缩。
- en: If you have already written some Java Android application, then you know that
    Android also provides resources accessible through compile-time generated IDs
    inside the res project folder. This is not directly available on the Android NDK.
    Unless you are ready to use a JNI bridge, assets are the only way to package resources
    in your APK.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经写过一些Java Android应用程序，那么你就会知道Android也通过编译时在res项目文件夹中生成的ID提供资源访问。这在Android
    NDK上并不直接可用。除非你准备使用JNI桥接，否则资源是打包APK中资源的唯一方式。
- en: We are now going to load a texture encoded in one of the most popular picture
    formats used nowadays, the **Portable Network Graphics** (**PNG**). For this,
    we are going to integrate **libpng** in a NDK module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将加载一种现今最流行的图片格式之一，**便携式网络图形**（**PNG**）编码的纹理。为此，我们将在NDK模块中集成 **libpng**。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The resulting project is provided with this book under the name `DroidBlaster_Part6`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的项目以 `DroidBlaster_Part6` 的名称随本书提供。
- en: Time for action – reading assets with the Asset manager
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——使用资源管理器读取资源
- en: 'Let''s create a class to read the Android asset files:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类来读取Android资源文件：
- en: Create `jni/Resource.hpp` to encapsulate the access to asset files. We are going
    to use the `AAsset` API defined in `android/asset_manager.hpp` (which is already
    included in `android_native_app_glue.h`).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `jni/Resource.hpp` 来封装对资源文件的访问。我们将使用在 `android/asset_manager.hpp` 中定义的 `AAsset`
    API（该API已包含在 `android_native_app_glue.h` 中）。
- en: 'Declare the three main operations: `open()`, `close()`, and `read()`. We also
    need to retrieve the resource''s path in `getPath()`.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明三个主要操作：`open()`、`close()` 和 `read()`。我们还需要在 `getPath()` 中获取资源的路径。
- en: 'The Android Asset management API entry point is an `AAsetManager` opaque structure.
    We can access asset files, represented by a second opaque structure `AAsset`,
    from it:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android资源管理API的入口点是一个不透明的 `AAsetManager` 结构。我们可以从它那里访问代表资源文件的第二个不透明结构 `AAsset`：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implement the class `Resource` in `jni/Resource.cpp`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Resource.cpp` 中实现 `Resource` 类。
- en: 'The Asset manager is provided by the **Native App Glue** module in its `android_app->activity`
    structure:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 资源管理器由 **Native App Glue** 模块在其 `android_app->activity` 结构中提供：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Asset manager opens assets with `AassetManager_open()`. This is the sole
    responsibility of this method, apart from listing folders. We use the default
    open mode `AASSET_MODE_UNKNOWN` (more about this soon):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源管理器通过 `AassetManager_open()` 打开资源。这是此方法的唯一职责，除了列出文件夹。我们使用默认的打开模式 `AASSET_MODE_UNKNOWN`（关于这一点稍后会详细介绍）：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like files in classic applications, an opened asset must be closed when finished
    with `AAsset_close()` so that any resource allocated by the system is released:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与经典应用程序中的文件一样，使用完毕后必须通过 `AAsset_close()` 关闭打开的资源，以便释放系统分配的任何资源：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the code operates on asset files with `AAsset_read()` to read data.
    This is quite similar to what you can find with the standard Posix file API. Here,
    we try to read the `pCount` data in a memory buffer and retrieve the amount of
    data that was effectively read (in case we reach the end of the asset):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代码使用`AAsset_read()`在资源文件上操作以读取数据。这与标准的Posix文件API非常相似。在这里，我们尝试在内存缓冲区中读取`pCount`数据，并获取实际读取的数据量（如果我们到达资源的末尾）：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have seen how to call the Android Asset API to read a file stored in the
    `assets` directory. Android assets are read-only and should be used to hold static
    assets only. The Android Asset API is defined in the `android/assert_manager.h`
    including file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何调用Android Asset API来读取存储在`assets`目录中的文件。Android资源是只读的，应该只用于保存静态资源。Android
    Asset API在`android/assert_manager.h`包含文件中定义。
- en: More about the Asset Manager API
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Asset Manager API的更多信息
- en: 'The Android Asset manager provides a small set of method to access directories:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android资源管理器提供了一组小方法来访问目录：
- en: '`AAssetManager_openDir()` gives the possibility to explore an asset directory.
    Use it in conjunction with `AAssetDir_getNextFileName()` and `AAssetDir_rewind()`.
    An opened directory must be closed with `AAssetDir_close()`:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetManager_openDir()`提供了探索资源目录的可能性。与`AAssetDir_getNextFileName()`和`AAssetDir_rewind()`结合使用。打开的目录必须使用`AAssetDir_close()`关闭：'
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`AAssetDir_getNextFileName()` lists all the files available in the specified
    asset directory. One filename is returned each time you call it, or `NULL` is
    returned when all files have been listed:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_getNextFileName()`列出指定资源目录中所有可用的文件。每次调用它时都会返回一个文件名，或者当所有文件都列出时返回`NULL`：'
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`AAssetDir_rewind()` gives the possibility to restart the file iteration process
    with `AAssetDir_getNextFileName()` from the beginning of the process:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_rewind()`提供了可能从文件迭代过程的开头使用`AAssetDir_getNextFileName()`重新开始迭代过程的功能：'
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`AAssetDir_close()` frees all the resources allocated when the directory has
    been opened. This method must be called in pair with `AAssetManager_openDir()`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetDir_close()`释放打开目录时分配的所有资源。这个方法必须与`AAssetManager_openDir()`成对调用：'
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Files can be opened with an API similar to the POSIX file API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以使用类似于POSIX文件API的API打开：
- en: '`AAssetManager_open()` opens an asset file to read its content, retrieve its
    content as a buffer, or access its file descriptor. An opened asset must be closed
    with `AAsset_close()`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAssetManager_open()`打开一个资源文件以读取其内容，将其内容作为缓冲区获取，或访问其文件描述符。打开的资源必须使用`AAsset_close()`关闭：'
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`AAsset_read()` attempts to read the requested number of bytes in the provided
    buffer. The number of bytes actually read is returned or a negative value is returned
    in case an error occurs:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_read()`尝试在提供的缓冲区中读取请求的字节数。实际读取的字节数将被返回，如果发生错误则返回负值：'
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`AAsset_seek()` moves directly to the specified offset in the file, ignoring
    the previous data:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_seek()`直接跳转到文件中指定的偏移量，忽略之前的数据：'
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AAsset_close()` closes the asset and frees all the resources allocated when
    the file has been opened. This method must be called in pair with `AAssetManager_open()`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_close()`关闭资源，并释放打开文件时分配的所有资源。这个方法必须与`AAssetManager_open()`成对调用：'
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AAsset_getBuffer()` returns a pointer to a memory buffer containing the whole
    asset content or `NULL` if a problem occurs. The buffer might be memory mapped.
    Beware, as Android compresses some assets (depending on their extension) so that
    the buffer might not be directly readable:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_getBuffer()`返回一个指向包含整个资源内容的内存缓冲区的指针，如果出现问题则返回`NULL`。该缓冲区可能是内存映射的。请注意，因为Android会压缩某些资源（取决于它们的扩展名），所以缓冲区可能不是直接可读的：'
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`AAsset_getLength()` gives the total asset size in bytes. This method might
    be useful to preallocate a buffer of the right size before reading an asset:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_getLength()`给出资源的总大小（以字节为单位）。在读取资源之前，这个方法可能有助于预分配正确大小的缓冲区：'
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Aasset_getRemainingLength()` is similar to `AAsset_getLength()` except that
    it does take into account the bytes already read:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aasset_getRemainingLength()`与`AAsset_getLength()`类似，不同之处在于它考虑了已经读取的字节数：'
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`AAsset_openFileDescriptor()` returns a raw Unix file descriptor. This is used
    in OpenSL to read a music file:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_openFileDescriptor()`返回一个原始的Unix文件描述符。这在OpenSL中用于读取音乐文件：'
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`AAsset_isAllocated()` indicates if the buffer returned by the asset is memory
    mapped:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AAsset_isAllocated()`指示资源返回的缓冲区是否是内存映射的：'
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will see more about these methods in the subsequent chapters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中详细介绍这些方法。
- en: 'The modes available to open asset files are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开资源文件的可用模式有：
- en: '`AASSET_MODE_BUFFER`: This helps to perform fast small reads'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_BUFFER`：这有助于执行快速的小读取'
- en: '`AASSET_MODE_RANDOM`: This helps to read chunks of data forward and backward'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_RANDOM`：这有助于向前和向后读取数据块'
- en: '`AASSET_MODE_STREAMING`: This helps to read data sequentially with occasional
    forward seeks'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_STREAMING`：这有助于顺序读取数据，偶尔向前搜索'
- en: '`AASSET_MODE_UNKNOWN`: This helps to keep the system default settings'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AASSET_MODE_UNKNOWN`：这有助于保持系统默认设置'
- en: Most of the time `AASSET_MODE_UNKNOWN` will be the way to go.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下`AASSET_MODE_UNKNOWN`会是正确的选择。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Installing, large APK can be problematic even when they are deployed on an SD
    card (see the `installLocation` option in the Android manifest). Thus, a good
    strategy to deal with tons of megabytes of assets is to keep only the essential
    ones in your APK. Download the remaining files to the SD card at runtime or package
    them within a second APK.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装大型的APK可能会出现问题，即使它们部署在SD卡上（参见Android清单中的`installLocation`选项）。因此，处理大量兆字节的资源的良好策略是只将必要的资源放在APK中。在运行时将剩余的文件下载到SD卡，或者将它们包装在第二个APK中。
- en: Now that we have the PNG asset files to read, let's load them using `libpng`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了要读取的PNG资源文件，那么我们使用`libpng`来加载它们。
- en: Time for action – compiling and embedding libpng module
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——编译并嵌入libpng模块
- en: Let's load an OpenGL texture from a PNG file in DroidBlaster.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在DroidBlaster中从PNG文件加载一个OpenGL纹理。
- en: Go to the website [http://www.libpng.org/pub/png/libpng.html](http://www.libpng.org/pub/png/libpng.html)
    and download the `libpng` source package (which is Version 1.6.10 in this book).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问网站[http://www.libpng.org/pub/png/libpng.html](http://www.libpng.org/pub/png/libpng.html)，下载`libpng`源代码包（本书中是版本1.6.10）。
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original `libpng` 1.6.10 archive is provided with this book in the `Libraries/libpng`
    folder.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中提供了原始的`libpng` 1.6.10存档，位于`Libraries/libpng`文件夹中。
- en: Create a folder named `libpng` inside `$ANDROID_NDK/sources/`. Move all files
    from the `libpng` package into this.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`$ANDROID_NDK/sources/`内创建一个名为`libpng`的文件夹。将`libpng`包中的所有文件移动到这个文件夹中。
- en: Copy the file `libpng/scripts/pnglibconf.h.prebuilt` into the root folder `libpng`
    with other source files. Rename it as `pnglibconf.h`.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将文件`libpng/scripts/pnglibconf.h.prebuilt`复制到根文件夹`libpng`中的其他源文件中。将其重命名为`pnglibconf.h`。
- en: Note
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The folder `$ANDROID_NDK/sources` is a special folder considered as a module
    folder by default. It contains reusable libraries. See [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*, for
    more information.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件夹`$ANDROID_NDK/sources`是一个特殊的文件夹，默认情况下被认为是模块文件夹。它包含可重用的库。更多信息请参见[第9章](ch09.html
    "第9章. 将现有库移植到Android")，*将现有库移植到Android*。
- en: 'Write the `$ANDROID_NDK/sources/libpng/Android.mk` file with the content given
    in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码中给定的内容编写`$ANDROID_NDK/sources/libpng/Android.mk`文件：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, open `jni/Android.mk` in the `DroidBlaster` directory.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`DroidBlaster`目录中的`jni/Android.mk`。
- en: 'Link and import `libpng` with the help of the `LOCAL_STATIC_LIBRARIES` and
    `import-module` directives. This is similar to what we have done with the Native
    App Glue module:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`LOCAL_STATIC_LIBRARIES`和`import-module`指令链接和导入`libpng`。这与我们对Native App Glue模块所做的类似：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*What just happened?*'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'In the previous chapter, we embedded the existing Native App Glue module to
    create a fully native application. This time we have created our first native
    reusable module to integrate `libpng`. Ensure that it works by compiling `DroidBlaster`.
    If you look at the **Console** view of the `libpng` source files, it should get
    compiled for each target platform. Note that NDK provides incremental compilation
    and will not recompile the already compiled sources:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们嵌入了现有的Native App Glue模块以创建一个完全本地的应用程序。这次我们创建了自己的第一个本地可重用模块来集成`libpng`。通过编译`DroidBlaster`确保它能正常工作。如果你查看`libpng`源文件的**控制台**视图，它应该为每个目标平台编译。请注意，NDK提供增量编译，并且不会重新编译已经编译的源文件：
- en: '![What just happened?](img/9645OS_06_01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645OS_06_01.jpg)'
- en: A native library module (here, `libpng`) is defined in a Makefile located at
    the root of its own directory. It is then referenced from another Makefile module,
    typically the application module (here `Droidblaster`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本地库模块（在这里是`libpng`）在位于其自身目录根部的Makefile中定义。然后它从另一个Makefile模块引用，通常是应用程序模块（在这里是`Droidblaster`）。
- en: Here, the `libpng` library Makefile selects all the C files with the help of
    a custom macro `LS_C`. This macro is invoked from the `LOCAL_SRC_FILES` directive.
    We exclude `example.c` and `pngtest.c`, which are just test files, using the standard
    "Make" function `filter-out()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`libpng`库的Makefile通过自定义宏`LS_C`选择所有的C文件。这个宏是从`LOCAL_SRC_FILES`指令中调用的。我们使用标准的“Make”函数`filter-out()`排除了`example.c`和`pngtest.c`，它们只是测试文件。
- en: All the prerequisites include files that are made available to client modules
    with the directive `LOCAL_EXPORT_C_INCLUDES`, which refers to the source directory
    `LOCAL_PATH` here. The prerequisite libraries like `libzip` (option `-lz`) are
    also provided to the client modules using the `LOCAL_EXPORT_LDLIBS` directive
    this time. All directives containing the `_EXPORT_` term exports directives that
    are appended to the client module's own directives.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先决条件包含文件都通过`LOCAL_EXPORT_C_INCLUDES`指令提供给客户端模块，该指令指向这里的源目录`LOCAL_PATH`。像`libzip`（选项`-lz`）这样的先决条件库也通过`LOCAL_EXPORT_LDLIBS`指令提供给客户端模块。所有包含`_EXPORT_`术语的指令都会将指令附加到客户端模块自身的指令中。
- en: For more information about Makefiles, directives, and standard functions, have
    a look at [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Makefiles、指令和标准函数的更多信息，请查看[第9章](ch09.html "第9章. 将现有库移植到Android")，*将现有库移植到Android*。
- en: Time for action – loading a PNG image
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——加载PNG图像
- en: 'Now that `libpng` is compiled, let''s read a real PNG file with it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 既然`libpng`已经编译完成，让我们用它来读取一个真正的PNG文件：
- en: Edit `jni/GraphicsManager.hpp` and include the `Resource` header file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.hpp`并包含`Resource`头文件。
- en: 'Create a new structure named `TextureProperties` containing:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为`TextureProperties`的新结构，包含以下内容：
- en: A resource representing the texture asset
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示纹理资源的资源
- en: An OpenGL texture identifier (which is a kind of handle)
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个OpenGL纹理标识符（这是一种句柄）
- en: A width and a height
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽度和高度
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Append a method `loadTexture()` to the `GraphicsManager` to read a PNG and load
    it into an OpenGL texture.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`GraphicsManager`追加一个`loadTexture()`方法，以读取PNG并将其加载到OpenGL纹理中。
- en: Textures are saved in an `mTextures` array to cache and finalize them.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 纹理保存在`mTextures`数组中以便缓存和最终确定。
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Edit `jni/GraphicsManager.cpp` to include a new header named `png.h` and update
    the constructor initialization list:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.cpp`以包含名为`png.h`的新头文件，并更新构造函数初始化列表：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Free the texture-related resources when `GraphicsManager` stops using `glDeleteTetxures()`.
    This function can delete several textures at once, which explains why this method
    expects an ordinal and an array. But we will not use this possibility here:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`GraphicsManager`停止使用`glDeleteTetxures()`时，释放与纹理相关的资源。这个函数可以一次删除多个纹理，这就是为什么此方法预期是一个序数和一个数组的原因。但在这里我们不会使用这种可能性：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To be fully independent from the data source, `libpng` provides a mechanism
    to integrate custom-read operations. This takes the form of a callback and reads
    the requested quantity of data into a buffer provided by `libpng`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完全独立于数据源，`libpng`提供了一个机制来整合自定义读取操作。这通过回调的形式，将请求的数据量读取到由`libpng`提供的缓冲区中。
- en: 'Implement this callback in conjunction with the Android Asset API to access
    the read data from application assets. The asset file is read through a `Resource`
    instance given by `png_get_io_ptr()` as an untyped pointer. This pointer is going
    to be provided by us while setting up the callback function (using `png_set_read_fn()`).
    We will see how this is done in the next steps:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结合Android Asset API实现此回调，以访问应用资产的读取数据。资产文件通过`png_get_io_ptr()`给出的`Resource`实例作为非类型指针进行读取。这个指针将在设置回调函数时（使用`png_set_read_fn()`）由我们提供。我们将在下一步中看到如何执行此操作：
- en: '[PRE33]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement `loadTexture()`. First, look for the `texture` in the cache. Textures
    are expensive in terms of memory and performance and should be managed with care
    (like all OpenGL resources in general):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`loadTexture()`。首先，在缓存中查找`texture`。纹理在内存和性能方面开销很大，应该谨慎管理（与所有OpenGL资源一样）：
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you could not find the texture in the cache, let's read it. Define a few
    variables needed to read the PNG file first.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法在缓存中找到纹理，那么让我们读取它。首先定义一些读取PNG文件所需的变量。
- en: 'Then, open the image using the `AAsset` API and check the image signature (the
    first 8 bytes of the file) to ensure that the file is a PNG (note that it might
    still be corrupted):'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，使用`AAsset` API打开图像，并检查图像签名（文件的前8个字节），以确保文件是PNG格式（注意，文件可能仍然已损坏）：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Allocate all the structures necessary to read a PNG image. After that, prepare
    reading operations by passing our `callback_readPng()`, implemented earlier in
    this tutorial, to `libpng`, along with our `Resource` reader. `Resource` pointer
    is the one retrieved in the callback with `png_get_io_ptr()`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配读取PNG图像所需的所有结构。之后，通过将我们在此教程中早先实现的`callback_readPng()`以及我们的`Resource`读取器传递给`libpng`，准备读取操作。通过`png_get_io_ptr()`在回调中获取的`Resource`指针。
- en: 'Also, set up error management with `setjmp()`. This mechanism allows jumping
    in code like a `goto` but through the call stack. If an error occurs, the control
    flow comes back at the point where `setjmp()` has been called first but enters
    the `if` block instead (here `goto ERROR`). This is the moment where we can provide
    the following script:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，使用`setjmp()`设置错误管理。这种机制允许像`goto`一样通过调用栈跳转代码。如果发生错误，控制流程将返回到首次调用`setjmp()`的位置，但会进入`if`块（这里为`goto
    ERROR`）。这是我们提供以下脚本的时刻：
- en: '[PRE36]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Ignore the first 8 bytes from the signature, which have already been read,
    for file signatures with `png_set_sig_bytes()` and `png_read_info()`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略已经读取的文件签名中的前8个字节，使用`png_set_sig_bytes()`和`png_read_info()`：
- en: 'Start reading the PNG file header with `png_get_IHDR()`:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`png_get_IHDR()`开始读取PNG文件头：
- en: '[PRE37]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The PNG files can be encoded in several formats: RGB, RGBA, 256 colors with
    a palette, grayscale, and so on. R, G, and B color channels can be encoded up
    to 16 bits. Hopefully, `libpng` provides transformation functions to decode unusual
    formats and transforms them into more classical RGB and luminance formats (with
    8 bits per channel, with or without an alpha channel).'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PNG文件可以用多种格式编码：RGB、RGBA、带有调色板的256色、灰度等。R、G和B颜色通道可以编码到16位。幸运的是，`libpng`提供了转换函数来解码不常见的格式，并将它们转换为更经典的RGB和亮度格式（每个通道8位，可选带或不带alpha通道）。
- en: Select the right transformation using `png_set` functions. Transformations are
    validated with `png_read_update_info()`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`png_set`函数选择正确的转换。通过`png_read_update_info()`验证转换。
- en: 'At the same time, select the corresponding OpenGL texture format:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，选择相应的OpenGL纹理格式：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Allocate the necessary temporary buffer to hold image data and a second one
    with the address of each output image row for `libpng`. Note that the row order
    is inverted because OpenGL uses a different coordinate system (the first pixel
    is at bottom-left) than PNG (first pixel at top-left).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`libpng`分配必要的临时缓冲区以保存图像数据，以及一个用于存储每行输出图像地址的第二个缓冲区。注意，行顺序是反转的，因为OpenGL使用的坐标系（左下角为第一个像素）与PNG（左上角为第一个像素）不同。
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, start reading the image content with `png_read_image()`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`png_read_image()`开始读取图像内容。
- en: 'Finally, when it''s finished, release all temporary resources:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，完成时，释放所有临时资源：
- en: '[PRE40]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, when it''s finished, release all temporary resources:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，完成时，释放所有临时资源：
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*What just happened?*'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Combining our native library module `libpng` with the Asset manager API gives
    us the power to load PNG files packaged in the assets directory. PNG is a relatively
    simple image format that is rather easy to integrate. In addition, it supports
    compression, which is good to limit the size of your APKs. Please note that once
    loaded, the PNG image buffer is uncompressed and can consume a lot of memory.
    So, release them as soon as you can. For detailed information about the PNG format,
    see [http://www.w3.org/TR/PNG/](http://www.w3.org/TR/PNG/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的本地库模块`libpng`与资产管理器API结合使用，使我们能够加载资产目录中打包的PNG文件。PNG是一种相对简单的图像格式，易于集成。此外，它支持压缩，有利于限制APK的大小。请注意，一旦加载，PNG图像缓冲区将被解压缩，可能会消耗大量内存。因此，一旦可以，请尽快释放它们。有关PNG格式的详细信息，请参见[http://www.w3.org/TR/PNG/](http://www.w3.org/TR/PNG/)。
- en: Now that our PNG image is loaded, we can generate an OpenGL texture from it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的PNG图像已加载，我们可以从中生成OpenGL纹理。
- en: Time for action – generating an OpenGL texture
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候生成OpenGL纹理了——采取行动。
- en: 'The `image` buffer filled by `libpng` now contains raw texture data. The next
    step is to generate a texture from it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由`libpng`填充的`image`缓冲区现在包含原始纹理数据。下一步是从此生成纹理：
- en: Let's continue our previous method `which is GraphicsManager::loadTexture()`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续我们之前的方法`GraphicsManager::loadTexture()`。
- en: Generate a new texture identifier with `glGenTextures()`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glGenTextures()`生成新的纹理标识符。
- en: Indicate that we are working on a texture with `glBindTexture()`.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glBindTexture()`指示我们正在处理一个纹理。
- en: 'Configure texture parameters with `glTexParameteri()` to specify the way a
    texture is filtered and wrapped. Use `GL_NEAREST`, as smoothing is not essential
    for a 2D game without zoom effects. Texture repetition is also not necessary and
    can be prevented with `GL_CLAMP_TO_EDGE`:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `glTexParameteri()` 配置纹理参数，以指定纹理的过滤和包裹方式。使用 `GL_NEAREST`，因为对于没有缩放效果的2D游戏来说，平滑并不是必需的。纹理重复也不必要，可以通过
    `GL_CLAMP_TO_EDGE` 来防止：
- en: '[PRE42]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Push the image data into OpenGL texture with `glTexImage2D()`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glTexImage2D()` 将图像数据推送到OpenGL纹理中。
- en: This unbinds the texture to put OpenGL pipeline back in its previous state.
    This is not strictly necessary, but it helps to avoid configuration mistakes in
    future draw calls (that is, drawing with an unwanted texture).
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将解绑纹理，使OpenGL管线恢复到之前的状态。这不是严格必要的，但有助于避免未来绘制调用（即，使用不需要的纹理进行绘制）时的配置错误。
- en: Finally, do not forget to free the temporary image buffer.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，不要忘记释放临时图像缓冲区。
- en: 'You can check that the texture has been created properly with `glGetError()`:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用 `glGetError()` 来检查纹理是否已正确创建：
- en: '[PRE43]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, cache the `texture` before returning it:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在返回之前，将 `texture` 缓存起来：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `jni/DroidBlaster.hpp`, include the `Resource` header and define two resources,
    of which one is for the ship and another is for the asteroids:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/DroidBlaster.hpp` 文件中，包含 `Resource` 头文件，并定义两个资源，其中一个用于飞船，另一个用于小行星：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Open `jni/DroidBlaster.cpp` and initialize the `texture` resources in the constructor.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `jni/DroidBlaster.cpp` 文件，并在构造函数中初始化 `texture` 资源。
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To ensure that the code is working, load textures in `onActivate()`. The textures
    can be loaded only after OpenGL is initialized by `GraphicsManager`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保代码正常工作，在 `onActivate()` 中加载纹理。只有在 `GraphicsManager` 初始化OpenGL之后，才能加载纹理：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Before running `DroidBlaster`, add `asteroid.png` and `ship.png` into the `droidblaster/assets`
    directory (create it if it's necessary).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `DroidBlaster` 之前，将 `asteroid.png` 和 `ship.png` 添加到 `droidblaster/assets`
    目录中（如果需要，请创建它）。
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The PNG files are provided with this book in the `DroidBlaster_Part6/assets`
    directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PNG文件随本书在 `DroidBlaster_Part6/assets` 目录中提供。
- en: '*What just happened?*'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Run the application and you should not see much difference. Indeed, we have
    loaded two PNG textures, but we are not actually rendering them. However, if you
    check the logs, you should see traces showing that the textures are properly loaded
    and retrieved from the cache, as shown in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你不会看到太多差别。实际上，我们已经加载了两个PNG纹理，但我们并没有真正渲染它们。然而，如果你检查日志，你应该能看到痕迹显示纹理已经被正确加载并从缓存中检索，如下面的截图所示：
- en: '![What just happened?](img/9645OS_06_04.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645OS_06_04.jpg)'
- en: 'Textures in OpenGL are objects (in the OpenGL way) which are in the form of
    an array of memory allocated on the **Graphical Processing Unit** (**GPU**) to
    store specific data. Storing graphics data in the GPU memory provides faster memory
    access than if it was stored in the main memory, which is a bit like a cache on
    a CPU. This efficiency comes at a price: texture loading is costly and must be
    performed as much as possible during startup.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，纹理是对象（按照OpenGL的方式），形式为在 **图形处理单元**（**GPU**）上分配的内存数组，用于存储特定的数据。将图形数据存储在GPU内存中，比存储在主内存中提供了更快的内存访问速度，这有点像CPU上的缓存。这种效率是有代价的：纹理加载成本高，必须在启动时尽可能多地执行。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The pixels of a texture are named **Texels**. Texel is the contraction of "**Texture
    Pixel**". Textures, and thus Texels, are projected on 3D objects during scene
    rendering.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的像素被称为 **Texels**（纹理像素）。Texel是“**Texture Pixel**”（纹理像素）的缩写。在场景渲染期间，纹理（因此Texels）会被投影到3D对象上。
- en: More about textures
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于纹理的更多信息
- en: An important requirement to remember while dealing with textures is their dimensions;
    OpenGL textures must have a power of two dimensions (for example, 128 or 256 pixels).
    Other dimensions will fail on most devices. These dimensions ease a technique
    called **MIPmapping** (**Multum In Parvo** (**MIP**), which mean much in little).
    MIPmaps are smaller versions of the same texture (see the following figure) applied
    selectively depending on the rendered object distance. They increase performance
    and reduce aliasing artifacts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理纹理时，要记住的一个重要要求是它们的尺寸；OpenGL纹理的尺寸必须是2的幂（例如，128或256像素）。其他尺寸在大多数设备上都会失败。这些尺寸简化了一种称为
    **MIPmapping**（**Multum In Parvo**（**MIP**），意为小中见大）的技术。MIPmaps是同一纹理的较小版本（见下图的例子），根据渲染对象距离的选择性应用。它们可以提高性能并减少锯齿伪影。
- en: '![More about textures](img/9645OS_06_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![关于纹理的更多信息](img/9645OS_06_08.jpg)'
- en: 'The texture configuration is set with `glTexParameteri()`. They need to be
    specified at the texture creation time only. The following two main kinds of parameters
    can be applied:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理配置是通过`glTexParameteri()`设置的。它们只需在创建纹理时指定。以下两种主要类型的参数可以应用：
- en: '**Texture Filtering** with `GL_TEXTURE_MAG_FILTER` and `GL_TEXTURE_MIN_FILTER`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GL_TEXTURE_MAG_FILTER`和`GL_TEXTURE_MIN_FILTER`进行**纹理过滤**。
- en: These parameters control the way texture magnification and minification are
    performed, that is, the processing applied when texture is respectively smaller
    or bigger than the rasterized primitive. Two values are possible in this, as shown
    in the next figure.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些参数控制了纹理放大和缩小的处理方式，即当纹理分别小于或大于光栅化图元时的处理过程。下一个图中展示了这两种可能的值。
- en: '`GL_LINEAR` interpolates textures drawn onscreen based on the closest texel
    colors (also known as Bilinear filtering). This calculation results in a smooth
    effect.`GL_NEAREST` displays the closest texel color without any interpolation.
    This value gives slightly better performance than `GL_LINEAR`.![More about textures](img/9645OS_06_06.jpg)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_LINEAR`根据最近的纹理颜色（也称为双线性过滤）对屏幕上绘制的纹理进行插值。这种计算产生平滑效果。`GL_NEAREST`不进行任何插值，直接显示最近的纹理颜色。这个值比`GL_LINEAR`稍微好一点性能。![关于纹理的更多信息](img/9645OS_06_06.jpg)'
- en: There exist variants that can be used in conjunction with MIPmaps to indicate
    how to apply minification; some of these variants are `GL_NEAREST_MIPMAP_NEAREST`,
    `GL_LINEAR_MIPMAP_NEAREST`, `GL_NEAREST_MIPMAP_LINEAR` and `GL_LINEAR_MIPMAP_LINEAR`
    (this one is better known as **Trilinear filtering**).
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在一些变体，可以与MIPmaps结合使用以指示如何应用缩小；其中一些变体包括`GL_NEAREST_MIPMAP_NEAREST`、`GL_LINEAR_MIPMAP_NEAREST`、`GL_NEAREST_MIPMAP_LINEAR`和`GL_LINEAR_MIPMAP_LINEAR`（后者被称为**三线性过滤**）。
- en: '**Texture Wrapping** with `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GL_TEXTURE_WRAP_S`和`GL_TEXTURE_WRAP_T`进行**纹理包裹**。
- en: 'These parameters control the way textures are repeated when texture coordinates
    go outside the range [0.0, 1.0]. S represents the X axis and T, the Y axis. Their
    different naming is used to avoid any confusion with position coordinates. They
    are often referred to as U and V. The following figure shows some of the possible
    values and their effect:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些参数控制了当纹理坐标超出[0.0, 1.0]范围时纹理的重复方式。S代表X轴，T代表Y轴。它们的不同命名用于避免与位置坐标混淆。它们通常被称为U和V。以下图展示了可能的一些值及其效果：
- en: '![More about textures](img/9645OS_06_07.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![关于纹理的更多信息](img/9645OS_06_07.jpg)'
- en: 'A few good practices to remember while dealing with textures are:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理纹理时需要记住的一些良好实践包括：
- en: Switching textures is an expensive operation, so avoid OpenGL pipeline state
    changes as much as possible (binding a new texture and changing an option with
    `glEnable()` are examples of state changes).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换纹理是一项代价高昂的操作，因此尽可能避免OpenGL管道状态变化（绑定新纹理和通过`glEnable()`更改选项都是状态变化的例子）。
- en: Textures are probably the most memory and bandwidth consuming resources. Consider
    using **compressed** texture formats to greatly improve performances. Sadly, texture
    compression algorithms are rather tied to the hardware.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理可能是最消耗内存和带宽的资源。考虑使用**压缩**纹理格式以大幅提高性能。遗憾的是，纹理压缩算法相当依赖于硬件。
- en: Create big textures to pack, as much data as you can, even from multiple objects.
    This is known as **Texture Atlas**. For example, if you look at the ship and asteroid
    texture, you will find that several sprite images are packed in them (we could
    even pack more):![More about textures](img/9645OS_06_09.jpg)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建大的纹理图集，尽可能多地打包数据，甚至来自多个对象。这被称为**纹理图集**。例如，如果你查看飞船和小行星的纹理，你会发现其中打包了几个精灵图像（我们甚至可以打包更多）：![关于纹理的更多信息](img/9645OS_06_09.jpg)
- en: This introduction to textures gives a slight overview of what OpenGL ES can
    achieve. For more information about texturing, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Texture](http://www.opengl.org/wiki/Texture).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇纹理介绍提供了对OpenGL ES可以实现的效果的简要概述。关于纹理的更多信息，请查看OpenGL.org维基页面：[http://www.opengl.org/wiki/Texture](http://www.opengl.org/wiki/Texture)。
- en: Drawing 2D sprites
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制2D精灵图像
- en: 2D games are based on **sprites**, which are pieces of images composited onscreen.
    They can represent an object, a character, a static, or an animated element. Sprites
    can be displayed with a transparency effect using the alpha channel of an image.
    Typically, an image will contain several frames for a sprite, each frame representing
    a different animation step or different objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏基于**精灵**，它们是在屏幕上组合的图像片段。它们可以代表一个对象、角色、静态元素或动画元素。精灵可以使用图像的alpha通道显示透明效果。通常，一个图像将包含一个精灵的多个帧，每个帧代表不同的动画步骤或不同的对象。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need a powerful multiplatform image editor, consider using **GNU Image
    Manipulation Program** (**GIMP**). This program is available on Windows, Linux,
    and Mac OS X, and is a powerful and open source. You can download it from [http://www.gimp.org/](http://www.gimp.org/).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个强大的跨平台图像编辑器，可以考虑使用**GNU图像处理程序**（**GIMP**）。这个程序在Windows、Linux和Mac OS X上都可以使用，是一款功能强大且开源的软件。你可以从[http://www.gimp.org/](http://www.gimp.org/)下载它。
- en: Several techniques exist to draw sprites using OpenGL. One of these is called
    **Sprite Batch**. This is one of the most efficient ways to create 2D games with
    OpenGL ES 2\. It is based on a vertex array (stored in main memory) that is regenerated
    during each frame with all the sprites to render. Rendering is performed with
    the help of a simple vertex shader that projects 2D coordinates onto the screen
    and a fragment shader that outputs the raw sprite texture color.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL绘制精灵的技术有很多种。其中一种称为**Sprite Batch**。这是使用OpenGL ES 2创建2D游戏的最有效方法之一。它基于一个顶点数组（存储在主内存中），每个帧都会用所有要渲染的精灵重新生成。渲染是借助一个简单的顶点着色器将2D坐标投影到屏幕上，以及一个输出原始精灵纹理颜色的片段着色器来完成的。
- en: We are now going to implement a sprite batch to render the ship and multiple
    asteroids onscreen in `DroidBlaster`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个精灵批次，在`DroidBlaster`中渲染飞船和多颗小行星。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part7`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的项目与本一起提供，名为`DroidBlaster_Part7`。
- en: Time for action – initializing OpenGL ES
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——初始化OpenGL ES
- en: 'Let''s now see how to implement a sprite batch in DroidBlaster:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在DroidBlaster中实现精灵批次：
- en: 'Modify `jni/GraphicsManager.hpp`. Create the class `GraphicsComponent`, which
    defines a common interface for all rendering techniques starting with sprite batches.
    Define a few new methods such as:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`jni/GraphicsManager.hpp`。创建`GraphicsComponent`类，它为所有以精灵批次开始的渲染技术定义了一个通用接口。定义一些新的方法，例如：
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getProjectionMatrix()`提供用于在屏幕上投影2D图形的OpenGL矩阵'
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadShaderProgram()`用于加载顶点和片段着色器，并将它们链接成一个OpenGL程序'
- en: '`registerComponent()` which records a list of `GraphicsComponent` to initialize
    and render'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerComponent()`记录要初始化和渲染的`GraphicsComponent`列表'
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '创建`RenderVertex`私有结构，表示单个精灵顶点的结构。 '
- en: 'Also, declare a few new member variables such as:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，声明几个新的成员变量，例如：
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games).'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mProjectionMatrix`用于存储正交投影（与3D游戏中使用的透视投影相对）。'
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mShaders`、`mShaderCount`、`mComponents`和`mComponentCount`用来追踪所有资源。'
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，移除前一章用于渲染原始图形的所有`GraphicsElement`相关内容，如下代码所示：
- en: '[PRE48]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, define a few new methods in `GraphicsManager`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`GraphicsManager`中定义几个新方法：
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getProjectionMatrix()`提供用于在屏幕上投影2D图形的OpenGL矩阵'
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadShaderProgram()`用于加载顶点和片段着色器，并将它们链接成一个OpenGL程序'
- en: '`registerComponent()` which records a list of GraphicsComponent to initialize
    and render'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerComponent()`记录要初始化和渲染的`GraphicsComponent`列表'
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建`RenderVertex`私有结构，表示单个精灵顶点的结构。
- en: 'Also, declare a few new member variables such as:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，声明几个新的成员变量，例如：
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mProjectionMatrix`用于存储正交投影（与3D游戏中使用的透视投影相对）'
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mShaders`、`mShaderCount`、`mComponents`和`mComponentCount`用于跟踪所有资源。'
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，移除前一章用于渲染原始图形的所有`GraphicsElement`相关内容：
- en: '[PRE49]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Open `jni/GraphicsManager.cpp`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/GraphicsManager.cpp`。
- en: Update the constructor initialization list and the destructor. Again, get rid
    of everything related to `GraphicsElement`.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新构造函数初始化列表和析构函数。再次，移除所有与`GraphicsElement`相关的部分。
- en: 'Also implement `registerComponent()` in place of `registerElement()`:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`registerComponent()`替代`registerElement()`实现注册：
- en: '[PRE50]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Amend `onStart()` to initialize the **Orthographic** projection matrix array
    with display dimensions (we will see how to compute matrices more easily using
    GLM in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*) and load components.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onStart()`，使用显示尺寸初始化**正交**投影矩阵数组（我们将在[第9章](ch09.html "第9章. 将现有库移植到Android")中看到如何更容易地使用GLM计算矩阵），并加载组件。
- en: Tip
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A projection matrix is a mathematical way to project 3D objects composing a
    scene into a 2D plane, which is the screen. In orthographic projection, a projection
    is perpendicular to the display surface. That means that an object has exactly
    the same size whether it is close or far away from the point of view. Orthographic
    projection is appropriate for 2D games. **Perspective** projection, in which objects
    look smaller the farther they are, is rather used for 3D games.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 投影矩阵是一种数学方法，用于将组成场景的3D对象投影到2D平面上，即屏幕。在正交投影中，投影与显示表面垂直。这意味着无论物体距离观察点远近，其大小都完全相同。正交投影适用于2D游戏。**透视**投影中，物体越远看起来越小，通常用于3D游戏。
- en: For more information, have a look at [http://en.wikipedia.org/wiki/Graphical_projection](http://en.wikipedia.org/wiki/Graphical_projection).
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如需了解更多信息，请查看[http://en.wikipedia.org/wiki/Graphical_projection](http://en.wikipedia.org/wiki/Graphical_projection)。
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Free any resources loaded with `loadShaderProgram()` in `stop()`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stop()`中释放所有使用`loadShaderProgram()`加载的资源。
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Render any registered components in `update()` after the display is cleared
    but before it is refreshed:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update()`中清除显示后但在刷新之前，渲染所有已注册的组件：
- en: '[PRE53]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the new method `loadShader()`. Its role is to compile and load the given
    shaders passed as a human-readable GLSL program. To do so:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的方法`loadShader()`。其作用是编译并加载作为可读GLSL程序的给定着色器。为此：
- en: Generate a new vertex shader with `glCreateShader()`.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCreateShader()`生成新的顶点着色器。
- en: Upload the vertex shader source into OpenGL with `glShaderSource()`.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glShaderSource()`将顶点着色器源代码上传到OpenGL。
- en: Compile the shader with `glCompileShader()` and check the compilation status
    with `glGetShaderiv()`. The compilation errors can be read with `glGetShaderInfoLog()`.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCompileShader()`编译着色器，并使用`glGetShaderiv()`检查编译状态。编译错误可以通过`glGetShaderInfoLog()`读取。
- en: 'Repeat the operation for the given fragment shader:'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对给定的片段着色器重复该操作：
- en: '[PRE54]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once compiled, link the compiled vertex and fragment shaders together. To do
    so:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译后，将编译好的顶点和片段着色器链接在一起。为此：
- en: Create a program object with `glCreateProgram()`.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glCreateProgram()`创建一个程序对象。
- en: Specify the shaders to use `glAttachShader()`.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glAttachShader()`指定要使用的着色器。
- en: Link them together with `glLinkProgram()` to create the final program. Shader
    consistencies and compatibility with the hardware is checked at that point. The
    result can be checked with `glGetProgramiv()`.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glLinkProgram()`将它们链接在一起，创建最终程序。此时将检查着色器的一致性和与硬件的兼容性。可以使用`glGetProgramiv()`检查结果。
- en: Finally, get rid of the shaders as they are useless once linked in a program.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，移除着色器，因为一旦链接到程序中，它们就不再有用。
- en: '[PRE55]'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create `jni/Sprite.hpp`, which defines a class with all the necessary data to
    animate and draw a single sprite.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Sprite.hpp`，它定义了一个包含所有用于动画和绘制单个精灵所需数据的类。
- en: Create a `Vertex` structure which defines the content of a sprite vertex. We
    need a 2D position and texture coordinates which delimit the sprite picture.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个`Vertex`结构体，定义精灵顶点的内容。我们需要一个2D位置和纹理坐标，这些坐标限定精灵图片。
- en: 'Then, define a few methods:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，定义一些方法：
- en: Sprite animation can be updated and retrieved with `setAnimation()` and `animationEnded()`.
    Location is publicly available for simplicity purposes.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `setAnimation()` 和 `animationEnded()` 更新和检索精灵动画。位置为了简单起见，是公开可用的。
- en: Give privileged access to a component that we are going to define later, named
    `SpriteBatch`. It can `load()` and `draw()` sprites.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了稍后定义的 `SpriteBatch` 组件提供特权访问。它能够 `load()` 和 `draw()` 精灵。
- en: '[PRE56]'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, define a few properties:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一些属性：
- en: A texture containing the sprite sheet and its corresponding resource
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含精灵表及其对应资源的纹理
- en: '**Sprite frame data**: `mWidth` and `mHeight`, horizontal, vertical, and total
    number of frames in `mFrameXCount`, `mFrameYCount`, and `mFrameCount`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵帧数据**：`mWidth` 和 `mHeight`，以及水平、垂直和总帧数 `mFrameXCount`、`mFrameYCount` 和
    `mFrameCount`'
- en: '**Animation data**: first and total number of frames of an animation in `mAnimStartFrame`
    and `mAnimFrameCount`, animation speed in `mAnimSpeed`, the currently shown frame
    in `mAnimFrame`, and a looping indicator in `mAnimLoop`:'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画数据**：动画的第一帧和总帧数 `mAnimStartFrame` 和 `mAnimFrameCount`，动画速度 `mAnimSpeed`，当前显示的帧
    `mAnimFrame`，以及循环指示器 `mAnimLoop`：'
- en: '[PRE57]'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Write the `jni/Sprite.cpp` constructor and initialize the members to default
    values:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `jni/Sprite.cpp` 构造函数，并将成员初始化为默认值：
- en: '[PRE58]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Frame information (horizontal, vertical, and total number of frames) needs
    to be recomputed in `load()` as texture dimensions are known only at load time:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帧信息（水平、垂直和总帧数）需要在 `load()` 时重新计算，因为纹理尺寸仅在加载时才知道：
- en: '[PRE59]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'An animation starts from a given in the sprite sheet and ends after a certain
    amount of frames, whose number changes according to speed. An animation can loop
    to restart from the beginning when it is over:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动画从精灵表中的给定帧开始，并在一定数量的帧数后结束，这个数量会根据速度变化。动画可以在结束时循环回到开始处重新播放：
- en: '[PRE60]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `draw()`, first update the frame to draw according to the sprite animation
    and the time spent since the last frame. What we need is the indices of the frame
    in the spritesheet:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw()` 中，首先根据精灵动画和自上一帧以来的时间更新要绘制的帧。我们需要的是帧在精灵表中的索引：
- en: '[PRE61]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A sprite is composed of four vertices drawn in an output array, `pVertices`.
    Each of these vertices is composed of a sprite position (`posX1`, `posY1`, `posX2`,
    `posY2`) and texture coordinates (`u1`, `u2`, `v1`, `v2`). Compute and generate
    these vertices dynamically in the memory buffer, `pVertices`, provided in the
    parameter. This memory buffer will be given later to OpenGL to render the sprite:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精灵由四个顶点组成，绘制在输出数组 `pVertices` 中。这些顶点中的每一个都由精灵位置（`posX1`、`posY1`、`posX2`、`posY2`）和纹理坐标（`u1`、`u2`、`v1`、`v2`）组成。动态计算并在提供的内存缓冲区
    `pVertices` 中生成这些顶点。这个内存缓冲区稍后将提供给OpenGL以渲染精灵：
- en: '[PRE62]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Specify `jni/SpriteBatch.hpp` with methods such as:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/SpriteBatch.hpp` 中指定方法，例如：
- en: '`registerSprite()` to add a new sprite to draw'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerSprite()` 添加一个新的精灵以进行绘制'
- en: '`load()` to initialize all the registered sprites'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()` 初始化所有已注册的精灵'
- en: '`draw()` to effectively render all the registered sprites'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw()` 有效地渲染所有已注册的精灵'
- en: 'We are going to need member variables:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将需要成员变量：
- en: A set of sprites to draw in `mSprites` and `mSpriteCount`
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `mSprites` 和 `mSpriteCount` 中绘制的精灵集合
- en: '`mVertices`, `mVertexCount`, `mIndexes`, and `mIndexCount`, which define a
    vertex and an index buffer'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mVertices`、`mVertexCount`、`mIndexes` 和 `mIndexCount`，它们定义了顶点和索引缓冲区'
- en: A shader program identified by `mShaderProgram`
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `mShaderProgram` 标识的着色器程序。
- en: 'The vertex and fragment shader parameters are:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶点和片段着色器参数是：
- en: '`aPosition`, which is one of the sprite corner positions.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aPosition`，它是精灵角的其中一个位置。'
- en: '`aTexture`, which is the sprite corner texture coordinate. It defines the sprite
    to display in the sprite sheet.'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aTexture`，它是精灵角纹理坐标。它定义了在精灵表中显示的精灵。'
- en: '`uProjection`, is the orthographic projection matrix.'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uProjection` 是正交投影矩阵。'
- en: '`uTexture`, contains the sprite picture.'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTexture`，包含精灵图片。'
- en: '[PRE63]'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Implement the `jni/SpriteBach.cpp` constructor to initialize the default values.
    The component must register with `GraphicsManager` to be loaded and rendered.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `jni/SpriteBach.cpp` 构造函数以初始化默认值。组件必须注册到 `GraphicsManager` 以便加载和渲染。
- en: In the destructor, the allocated sprites must be freed when the component is
    destroyed.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在析构函数中，当组件被销毁时，必须释放已分配的精灵。
- en: '[PRE64]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The index buffer is rather static. We can precompute its content when a sprite
    is registered. Each index points to a vertex in the vertex buffer (0 representing
    the very first vertex, 1 the 2nd, and so on). As a sprite is represented by 2
    triangles of 3 vertices (to form a quad), we need 6 indexes per sprite:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引缓冲区相对静态。当注册精灵时，我们可以预先计算其内容。每个索引指向顶点缓冲区中的一个顶点（0代表第一个顶点，1代表第二个，依此类推）。由于一个精灵由2个3顶点的三角形组成（形成一个四边形），我们需要每个精灵6个索引：
- en: '[PRE65]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Write the GLSL vertex and fragment shaders as constant strings.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GLSL顶点和片段着色器写成常量字符串。
- en: 'The shader code is written inside a `main()` function similar to what can be
    coded in C. As any normal computer program, shaders require variables to process
    data: attributes (per-vertex data like the position), uniforms (global parameters
    per draw call), and varying (values interpolated per fragment like the texture
    coordinates).'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 着色器代码是写在类似于C语言中可以编写的`main()`函数内的。像任何正常的计算机程序一样，着色器需要变量来处理数据：属性（如顶点位置这样的逐顶点数据）、统一变量（每次绘制调用的全局参数）以及变化量（如纹理坐标这样的逐片段插值值）。
- en: 'Here, texture coordinates are passed to the fragment shader in `vTexture`.
    The vertex position is transformed from a 2D vector to a 4D vector into a predefined
    GLSL variable `gl_Position`. The fragment shader retrieves interpolated texture
    coordinates in `vTexture`. This information is used as an index in the predefined
    function `texture2D()` to access the texture color. Color is saved in the predefined
    output variable `gl_FragColor`, which represents the final pixel:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，纹理坐标通过`vTexture`传递给片段着色器。顶点位置从2D向量转换为4D向量，进入预定义的GLSL变量`gl_Position`。片段着色器在`vTexture`中获取插值的纹理坐标。此信息用作预定义函数`texture2D()`中的索引，以访问纹理颜色。颜色保存在预定义的输出变量`gl_FragColor`中，它表示最终的像素：
- en: '[PRE66]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Load the shader program and retrieve the shader attributes and uniform identifiers
    in `load()`. Then, initialize sprites, as shown in the following code:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`load()`中加载着色器程序并获取着色器属性和统一变量标识符。然后，初始化精灵，如下代码所示：
- en: '[PRE67]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Write `draw()`, which executes the OpenGL sprite rendering logic.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`draw()`，它执行OpenGL精灵渲染逻辑。
- en: 'First, select the sprite shader and pass its parameters: the matrix and the
    texture uniforms:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，选择精灵着色器并传递其参数：矩阵和纹理统一变量：
- en: '[PRE68]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, indicate to OpenGL how the position and UV coordinates are stored in
    the vertex buffer with `glEnableVertexAttribArray()` and `glVertexAttribPointer()`.
    These calls basically describe the `mVertices` structure. Note how vertex data
    is linked to shader attributes:'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，使用`glEnableVertexAttribArray()`和`glVertexAttribPointer()`指示OpenGL如何存储顶点缓冲区中的位置和UV坐标。这些调用基本上描述了`mVertices`结构。注意顶点数据是如何与着色器属性链接的：
- en: '[PRE69]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Activate transparency using a blending function to draw sprites over the background,
    or other sprites:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用混合函数激活透明度，以在背景或其他精灵上方绘制精灵：
- en: '[PRE70]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Tip
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information about the blending modes provided by OpenGL, have a look
    at [https://www.opengl.org/wiki/Blending](https://www.opengl.org/wiki/Blending).
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关OpenGL提供的混合模式的更多信息，请查看[https://www.opengl.org/wiki/Blending](https://www.opengl.org/wiki/Blending)。
- en: We can now start the rendering loop to render all sprites in a batch.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始渲染循环，批量渲染所有精灵。
- en: 'The first outer loop basically iterates over textures. Indeed, the pipeline
    state changes in OpenGL are costly. Methods like `glBindTexture()` should be called
    as little as possible to guarantee performance:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个外部循环基本上遍历纹理。实际上，OpenGL中的管道状态变化是代价高昂的。像`glBindTexture()`这样的方法应该尽可能少调用，以保证性能：
- en: '[PRE71]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The inner loop generates vertices for all sprites with the same texture:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内部循环为所有具有相同纹理的精灵生成顶点：
- en: '[PRE72]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Each time the texture changes, render the bunch of sprites with `glDrawElements()`.
    The vertex buffer specified earlier is combined with the index buffer given here
    to render the right sprites with the right texture. At this point, draw calls
    are sent to OpenGL, which executes the shader program:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当纹理发生变化时，使用`glDrawElements()`渲染一批发射的精灵。之前指定的顶点缓冲区与这里给出的索引缓冲区结合，使用正确的纹理渲染正确的精灵。此时，绘制调用被发送到OpenGL，执行着色器程序：
- en: '[PRE73]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When all sprites are rendered, restore the OpenGL state:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当所有精灵渲染完毕后，恢复OpenGL状态：
- en: '[PRE74]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Update `jni/Ship.hpp` with the new sprite system. You can remove the previous
    `GraphicsElement` stuff:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的精灵系统更新`jni/Ship.hpp`。你可以移除之前的`GraphicsElement`内容：
- en: '[PRE75]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The file `jni/Ship.cpp` does not change much apart from the `Sprite` type:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件`jni/Ship.cpp`除了`Sprite`类型之外，变化不大。
- en: '[PRE76]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Include the new `SpriteBatch` component in `jni/DroidBlaster.hpp`:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中包含新的`SpriteBatch`组件：
- en: '[PRE77]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In `jni/DroidBlaster.cpp`, define some new constants with animation properties.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`中，定义一些具有动画属性的新常量。
- en: Then, use the `SpriteBatch` component to register the ship and asteroids graphics.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，使用`SpriteBatch`组件注册飞船和小行星的图形。
- en: 'Remove the previous stuff related to `GraphicsElement` again:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次移除与`GraphicsElement`相关的前一段内容：
- en: '[PRE78]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We do not need to load textures manually in `onActivate()` anymore. Sprites
    will handle this for us.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要在`onActivate()`中手动加载纹理。Sprite会为我们处理这些。
- en: 'Finally, release the graphic resources in `onDeactivate()`:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在`onDeactivate()`中释放图形资源：
- en: '[PRE79]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '*What just happened?*'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Launch DroidBlaster. You should now see an animated ship surrounded by frightening
    rotating asteroids:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 启动DroidBlaster。你现在应该看到一个被可怕旋转小行星环绕的动画飞船：
- en: '![What just happened?](img/9645OS_06_02.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么?](img/9645OS_06_02.jpg)'
- en: In this part, we have seen how to draw a sprite efficiently with the help of
    the Sprite Batch technique. Indeed, a common cause of bad performance in OpenGL
    programs lies in state changes. Changing the OpenGL device state (for example,
    binding a new buffer or texture, changing an option with `glEnable()`, and so
    on) is a costly operation and should be avoided as much as possible. Thus, a good
    practice to maximize OpenGL performance is to order draw calls and change only
    the needed states.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们看到了如何通过Sprite Batch技术有效地绘制一个精灵。实际上，在OpenGL程序中性能不佳的一个常见原因是状态变化。改变OpenGL设备状态（例如，绑定一个新的缓冲区或纹理，使用`glEnable()`更改选项等）是一个代价高昂的操作，应尽可能避免。因此，为了最大化OpenGL的性能，一个好的实践是按顺序排列绘制调用，并且只改变所需的状态。
- en: Tip
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One of the best OpenGL ES documentation is available from the Apple developer
    site at [https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/](https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最优秀的OpenGL ES文档可以在苹果开发者网站上找到，地址是[https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/](https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/)。
- en: But first, let's see more about the way OpenGL stores vertices in memory and
    the basics of OpenGL ES shaders.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们更深入地了解OpenGL在内存中存储顶点的方式以及OpenGL ES着色器的基础知识。
- en: Vertex Arrays versus Vertex Buffer Object
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点数组与顶点缓冲对象
- en: '**Vertex** **Arrays** (**VA**) and **Vertex Buffer Objects** (**VBO**) are
    the two main ways to manage vertices in OpenGL ES. Like with textures, multiple
    VAs/VBOs can be bound simultaneously to one vertex shader.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点数组**（**VA**）和**顶点缓冲对象**（**VBO**）是OpenGL ES中管理顶点的两种主要方式。与纹理一样，可以同时将多个VA/VBO绑定到一个顶点着色器上。'
- en: 'There are two main ways to manage vertices in OpenGL ES:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES中有两种主要方式来管理顶点：
- en: In main memory (that is, in RAM), we talk about Vertex Arrays (abbreviated VA).
    Vertex arrays are transmitted from the CPU to the GPU for each draw call. As a
    consequence, they are slower to render, but also much easier to update. Thus,
    they are appropriate when a mesh of vertices is changing frequently. This explains
    the decision to use a vertex array to implement sprite batches; each sprite is
    updated each time a new frame is rendered (position, as well as texture coordinates,
    to switch to a new frame).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主内存中（即在RAM中），我们讨论的是顶点数组（简称VA）。顶点数组在每个绘制调用时从CPU传输到GPU。因此，它们的渲染速度较慢，但更新起来要容易得多。因此，当顶点网格经常变化时，它们是适当的。这解释了为什么要使用顶点数组来实现Sprite
    Batches；每次渲染新帧时都会更新每个Sprite（位置以及纹理坐标，以切换到新帧）。
- en: In driver memory (generally in GPU memory or **VRAM**), we talk about **Vertex
    Buffers Objects**. Vertex buffers are faster to draw but more expensive to update.
    Thus, they are often used to render static data that never changes. You can still
    transform it with vertex shaders, which we are going to see in the next part.
    Note that some hints can be provided to the driver during initialization (`GL_DYNAMIC_DRAW`)
    to allow fast updates but at the price of more complex buffer management (that
    is, multiple buffering).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在驱动器内存中（通常在GPU内存或**VRAM**中），我们讨论的是**顶点缓冲对象**。顶点缓冲绘制速度快，但更新成本更高。因此，它们通常用于渲染永远不会改变的静态数据。你仍然可以通过顶点着色器对其进行变换，我们将在下一部分看到。注意，在初始化期间可以向驱动器提供一些提示（`GL_DYNAMIC_DRAW`），以允许快速更新，但代价是更复杂的缓冲管理（即多重缓冲）。
- en: 'After transformation, the vertices are connected together during the primitive
    assembly stage. They can be assembled in the following ways:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 变换后，顶点在图元装配阶段连接在一起。它们可以通过以下方式组装：
- en: As lists 3 by 3 (which can lead to vertex duplication), in fans, in strips,
    and so on; in which case, we use `glDrawArrays()`.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当列表以3x3排列（可能导致顶点重复），扇形，条形等方式时；在这种情况下，我们使用`glDrawArrays()`。
- en: Using an index buffers which specifies 3 by 3, where vertices are connected
    together. Index buffers are often the best way to achieve better performance.
    Indices need to be sorted to favor caching. Indices are drawn with their associated
    VBO or VA using `glDrawElements()`.![Vertex Arrays versus Vertex Buffer Object](img/9645OS_06_10.jpg)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指定为3x3的索引缓冲区，其中顶点相互连接。索引缓冲区通常是实现更好性能的最佳方式。需要排序索引以利于缓存。使用`glDrawElements()`与相关的VBO或VA绘制索引。![顶点数组与顶点缓冲对象对比](img/9645OS_06_10.jpg)
- en: 'Some good practices to remember when you''re dealing with vertices are:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理顶点时，需要记住的一些好的实践是：
- en: Pack as many vertices in each buffer as you can, even from multiple meshes.
    Indeed, switching from one set of vertices to another, either a VA or a VBO, is
    slow.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能在每个缓冲区中打包尽可能多的顶点，甚至来自多个网格。实际上，从一组顶点切换到另一组，无论是VA还是VBO，都是比较慢的。
- en: Avoid updating static vertex buffers at runtime.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在运行时更新静态顶点缓冲区。
- en: Make vertex structure the size of a power of 2 (in bytes) to favor data alignment.
    It is often preferred to pad data rather than to transmit unaligned data because
    of the way GPU processes it.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使顶点结构的大小为2的幂（以字节为单位）以利于数据对齐。通常，相对于传输未对齐的数据，更倾向于填充数据，因为GPU处理数据的方式。
- en: For more information about vertex management, have a look at the OpenGL.org
    wiki at [http://www.opengl.org/wiki/Vertex_Specification](http://www.opengl.org/wiki/Vertex_Specification)
    and [http://www.opengl.org/wiki/Vertex_Specification_Best_Practices](http://www.opengl.org/wiki/Vertex_Specification_Best_Practices).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有关顶点管理的更多信息，请查看OpenGL.org维基的[http://www.opengl.org/wiki/Vertex_Specification](http://www.opengl.org/wiki/Vertex_Specification)和[http://www.opengl.org/wiki/Vertex_Specification_Best_Practices](http://www.opengl.org/wiki/Vertex_Specification_Best_Practices)。
- en: Rendering particle effects
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染粒子效果
- en: DroidBlaster needs a background to make it more pleasant-looking. As the action
    is located in space, what about a falling star to give an impression of speed?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: DroidBlaster需要一个背景来使其看起来更美观。由于动作发生在太空中，那么一个流星如何给速度感？
- en: Such an effect can be simulated in several ways. One possible choice consists
    of showing a particle effect, where each particle corresponds to a star. OpenGL
    provides such a feature through **Point** **Sprites**. A point sprite is a special
    kind of element that requires only one vertex to draw a sprite. Combined with
    a whole vertex buffer, many sprites can be drawn at the same time efficiently.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果可以通过几种方式模拟。一种可能的选择是显示一个粒子效果，其中每个粒子对应一个星星。OpenGL通过**点精灵**提供了这一特性。点精灵是一种特殊的元素，只需要一个顶点就能绘制一个精灵。结合整个顶点缓冲区，可以高效地同时绘制许多精灵。
- en: Point sprites are usable with vertex and fragment shaders. To be even more efficient,
    we can use their power to process particle movement directly inside the shaders.
    Thus, we will not need to regenerate the vertex buffer each time a particle changes,
    like we have to do with sprite batches.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵可以使用顶点和片段着色器。为了更高效，我们可以利用它们直接在着色器内部处理粒子移动的能力。因此，我们将不需要每次粒子变化时重新生成顶点缓冲区，就像使用精灵批次时必须做的那样。
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part8`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最终项目随本书提供，名为`DroidBlaster_Part8`。
- en: Time for action – rendering a star field
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作 - 渲染星域
- en: 'Let''s now see how to apply this particle effect in `DroidBlaster`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在`DroidBlaster`中应用这个粒子效果：
- en: In `jni/GraphicsManager.hpp`, define a new method to load a vertex buffer.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.hpp`中，定义一个加载顶点缓冲区的新方法。
- en: 'Add an array to store vertex buffer resources:'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个数组来存储顶点缓冲区资源：
- en: '[PRE80]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In `jni/GraphicsManager.cpp`, update the constructor initialization list and
    free vertex buffer resources in `stop()`:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/GraphicsManager.cpp`中，更新构造函数初始化列表，并在`stop()`中释放顶点缓冲区资源：
- en: '[PRE81]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create the new method `loadVertexBuffer()` to upload the data from the given
    memory location into an OpenGL vertex buffer. As opposed to the SpriteBatch example,
    which uses a dynamic vertex buffer in computer memory, the following vertex buffer
    is static and located in GPU memory. This makes it faster but quite inflexible
    too. To do so:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的方法`loadVertexBuffer()`，将给定内存位置的数据上传到OpenGL顶点缓冲区。与在计算机内存中使用动态顶点缓冲区的SpriteBatch示例相比，下面的顶点缓冲区是静态的，位于GPU内存中。这使得它更快但也相对不灵活。为此：
- en: Generate a buffer identifier with `glGenBuffers()`.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glGenBuffers()`生成缓冲区标识符。
- en: Indicate that we are working on a vertex buffer with `glBindBuffer()`.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glBindBuffer()`指示我们正在处理一个顶点缓冲区。
- en: Push the vertex data from the given memory location into OpenGL vertex buffer
    with `glBufferData()`.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glBufferData()`将顶点数据从给定的内存位置推送到OpenGL顶点缓冲区。
- en: Unbind the vertex buffer to put OpenGL back in its previous state. This is not
    strictly necessary, like for textures, but it helps avoiding configuration mistakes
    in future draw calls.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解绑顶点缓冲区，将OpenGL恢复到之前的状态。这并非严格必要，但对于纹理来说是有帮助的，可以避免未来绘制调用时的配置错误。
- en: 'You can check that the vertex buffer has been created properly with `glGetError()`:'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`glGetError()`检查顶点缓冲区是否已正确创建：
- en: '[PRE82]'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Define the new `StarField` component in `jni/StarField.hpp`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/StarField.hpp`中定义新的`StarField`组件。
- en: Override `the GraphicsComponent` methods, as done previously.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重写`GraphicsComponent`方法，就像之前做的那样。
- en: Define a specific `Vertex` structure with 3 coordinates `x`, `y`, and `z`.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个特定的`Vertex`结构，包含3个坐标`x`、`y`和`z`。
- en: A star field is characterized by the number of stars in `mStarCount` and a texture
    that represents a single one in `mTextureResource`.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星场由`mStarCount`中的星星数量和一个代表单个星星的纹理`mTextureResource`来特征化。
- en: 'We will need some OpenGL resources: a vertex buffer, a texture, and a shader
    program with its variables:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要一些OpenGL资源：一个顶点缓冲区、一个纹理以及一个包含其变量的着色器程序：
- en: '`aPosition`, which is the star position.'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aPosition`，代表星星的位置。'
- en: '`uProjection`, which is the orthographic projection matrix.'
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uProjection`，即正交投影矩阵。'
- en: '`uTime`, which is the total elapsed time given by `TimeManager`. This is necessary
    to simulate the movement of stars.'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTime`是`TimeManager`给出的总经过时间。这是模拟星星移动的必要条件。'
- en: '`uHeight`, which is the height of the display. The stars are going to be recycled
    when they reach the screen boundaries.'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uHeight`，即显示的高度。当星星到达屏幕边界时，它们将被回收。'
- en: '`uTexture`, which contains the star picture.'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uTexture`，包含星星图片。'
- en: '[PRE83]'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create `jni/StarField.cpp` and implement its constructor:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/StarField.cpp`并实现其构造函数：
- en: '[PRE84]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The star field logic is mostly implemented in the vertex shader. Each star,
    represented by a single vertex, is moved from top to bottom according to time,
    speed (which is constant), and star distance. The farther it is (distance being
    determined by the `z` vertex component), the slower it scrolls.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星场的逻辑主要在顶点着色器中实现。每个由单个顶点表示的星星根据时间、速度（是恒定的）和星星距离从上到下移动。它越远（距离由`z`顶点分量确定），滚动越慢。
- en: The GLSL function `mod`, which stands for modulo, resets the star position when
    it has reached the bottom of the screen. The final star position is saved in the
    predefined variable `gl_Position`.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GLSL函数`mod`，代表取模，当星星到达屏幕底部时重置其位置。最终的星星位置保存在预定义变量`gl_Position`中。
- en: 'The star size on screen is also a function of its distance. The size is saved
    in the predefined variable `gl_PointSize` in pixel units:'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星星在屏幕上的大小也是其距离的函数。大小以像素单位保存在预定义变量`gl_PointSize`中：
- en: '[PRE85]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The fragment shader is much simpler and only draws the star texture onscreen:'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 片段着色器要简单得多，只在屏幕上绘制星星纹理：
- en: '[PRE86]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the `load()` function, generate the vertex buffer with the help of the `loadVertexBuffer()`
    method implemented in `GraphicsManager`. Each star is represented by a single
    vertex. The position on screen and depth are generated randomly. Depth is determined
    on a [0.0, 1.0] scale. Once this is done, release the temporary memory buffer
    holding the star field data:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`load()`函数中，借助`GraphicsManager`中实现的`loadVertexBuffer()`方法生成顶点缓冲区。每个星星由一个顶点表示。屏幕上的位置和深度是随机生成的。深度在[0.0,
    1.0]范围内确定。完成此操作后，释放临时内存缓冲区，该缓冲区保存星星场数据：
- en: '[PRE87]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, load the `star` texture and generate the program from the shaders defined
    above. Retrieve their attribute and uniform identifiers:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载`star`纹理并从上面定义的着色器生成程序。获取它们的属性和统一标识符：
- en: '[PRE88]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, render the `star` field by sending the static vertex buffer, the texture,
    and the shader program together in one draw call. To do so:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过在一次绘制调用中发送静态顶点缓冲区、纹理和着色器程序来渲染`star`场。为此：
- en: Disable blending, that is, the management of transparency. Indeed, the star
    "particles" are small, sparse, and drawn over a black background.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用混合，即透明度的管理。实际上，星星“粒子”很小，稀疏，并且是在黑色背景上绘制的。
- en: Select the vertex buffer first with `glBindBuffer()`. This call is necessary
    when a static vertex buffer has been generated at load time.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先选择顶点缓冲区`glBindBuffer()`。当在加载时生成了一个静态顶点缓冲区时，这个调用是必要的。
- en: Indicate how vertex data is structured with `glVertexAttribPointer()`, and to
    which shader attributes it relates with `glEnableVertexAttribArray()`. Note that
    the last parameter of `glVertexAttribPointer()` is not a pointer to a buffer this
    time but an index within the vertex buffer. Indeed, the vertex buffer is static,
    and in GPU memory, so we do not know its address.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glVertexAttribPointer()`指示顶点数据的结构，并通过`glEnableVertexAttribArray()`关联到哪个着色器属性。请注意，这次`glVertexAttribPointer()`的最后一个参数不是指向缓冲区的指针，而是顶点缓冲区内的索引。实际上，顶点缓冲区是静态的，位于GPU内存中，因此我们不知道它的地址。
- en: Select the texture to draw with `glActiveTexture()` and `glBindTexture()`.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glActiveTexture()`和`glBindTexture()`选择要绘制的纹理。
- en: Select the shader program with `glUseProgram()`.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glUseProgram()`选择着色器程序。
- en: Bind the program parameters with `glUniform` function variants.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glUniform`函数变体绑定程序参数。
- en: Finally, send the draw call to OpenGL with `glDrawArrays()`.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过`glDrawArrays()`向OpenGL发送绘制调用。
- en: 'You can then restore the OpenGL pipeline state:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以恢复OpenGL管道状态：
- en: '[PRE89]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In `jni/DroidBlaster.hpp`, define the new `StarField` component along with
    a new texture resource:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中，定义新的`StarField`组件以及一个新的纹理资源：
- en: '[PRE90]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Instantiate it in the `jni/DroidBlaster.cpp` constructor with `50` stars:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`构造函数中实例化它，使用`50`个星星：
- en: '[PRE91]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Before running `DroidBlaster`, add `droidblaster/star.png` into the assets directory.
    These files are provided with this book in the `DroidBlaster_Part8/assets` directory.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`DroidBlaster`之前，将`droidblaster/star.png`文件添加到assets目录中。这些文件随本书一起提供，位于`DroidBlaster_Part8/assets`目录。
- en: '*What just happened?*'
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Run `DroidBlaster`. The star field should look as shown in the following screenshot,
    when scrolling through the screen at a random pace:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`DroidBlaster`。在随机速度滚动屏幕时，星域应该看起来像下面的截图所示：
- en: '![What just happened?](img/9645OS_06_03.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645OS_06_03.jpg)'
- en: 'All of these stars are rendered as point sprites, where each point represents
    a quad determined by:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些星星都是作为点精灵渲染的，其中每个点代表一个由以下确定的四边形：
- en: '**A position on screen**: The position represents the center of the point sprite'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕上的一个位置**：该位置表示点精灵的中心。'
- en: '**A point size**: The size defines implicitly the point sprite quad'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个点的大小**：大小隐式定义了点精灵四边形的尺寸。'
- en: 'Point sprites are an interesting way to create particle effects, but, they
    have a few drawbacks, which are:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵是创建粒子效果的一种有趣方式，但它们有一些缺点，包括：
- en: 'Their possible size is more or less limited depending on the hardware capabilities.
    You can find the maximum size by querying `GL_ALIASED_POINT_SIZE_RANGE` with `glGetFloatv()`;
    look at the following example for this:'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能的大小或多或少受到硬件能力的限制。你可以通过使用`glGetFloatv()`查询`GL_ALIASED_POINT_SIZE_RANGE`来找到最大尺寸；以下示例将展示这一点：
- en: '[PRE92]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you draw bigger point sprites, you will notice that the particles are clipped
    (that is, masked) at their center and the whole sprite boundaries don't get out
    of screen.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你绘制更大的点精灵，你会注意到粒子在它们的中心被剪裁（即遮罩），整个精灵边界没有超出屏幕。
- en: Thus, depending on your needs, it might be more appropriate to use classic vertices.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据你的需要，使用传统的顶点可能更合适。
- en: Talking about vertices, you may have noticed that we have not created a vertex
    array but a vertex buffer object. Indeed, point sprites are evaluated completely
    in the vertex shader. This optimization allows us to use a static geometry (`glBufferData()`
    with the hint `GL_STATIC_DRAW`) which can be managed efficiently by the driver.
    Note that vertex buffer objects can also be marked as being subject to updates
    using the hint `GL_DYNAMIC_DRAW` (which means buffer will change frequently) or
    `GL_STREAM_DRAW` (which means buffer will be used once and thrown). The process
    of creating a VBO is similar to the process of creating any other kind of object
    in OpenGL, and involves generating a new identifier, selecting it, and finally
    uploading data in driver memory. If you understand this process, you understand
    the way OpenGL works.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到顶点，你可能已经注意到我们没有创建一个顶点数组，而是创建了一个顶点缓冲对象。实际上，点精灵完全在顶点着色器中评估。这种优化允许我们使用静态几何体（使用提示`GL_STATIC_DRAW`的`glBufferData()`），驱动程序可以有效地管理它。请注意，顶点缓冲对象也可以被标记为需要更新，使用提示`GL_DYNAMIC_DRAW`（意味着缓冲区将频繁变化）或`GL_STREAM_DRAW`（意味着缓冲区将使用一次后丢弃）。创建VBO的过程与在OpenGL中创建任何其他类型对象的过程类似，涉及生成新的标识符，选择它，并最终将数据上传到驱动程序内存。如果你理解这个过程，你就理解了OpenGL的工作方式。
- en: Programming shaders with GLSL
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GLSL编程着色器
- en: 'Shaders are written in GLSL, a (relatively) high-level programming language
    which allows defining functions (with in, out, and inout parameters), conditionals,
    loops, variables, arrays, structures, arithmetic operators, and so on. It abstracts
    as much as possible hardware specificities. GLSL allows the following kind of
    variables to be used:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是用 GLSL 编写的，这是一种相对高级的编程语言，允许定义函数（带有 in、out 和 inout 参数）、条件语句、循环、变量、数组、结构、算术运算符等等。它尽可能地抽象了硬件的特定性。GLSL
    允许使用以下类型的变量：
- en: '| **attributes** | These contain per-vertex data, such as vertex position or
    texture coordinates. Only one vertex is processed each time the shader executes.
    |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| **attributes** | 这些包含每个顶点的数据，例如顶点位置或纹理坐标。每次着色器执行时只处理一个顶点。 |'
- en: '| **const** | It represents compile-time constants or read-only function parameters.
    |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| **const** | 它表示编译时常量或只读函数参数。 |'
- en: '| **uniforms** | These are a kind of global parameter that can be changed per
    primitive (that is, per draw call). It has the same value for a whole mesh. An
    example of this could be a model-view matrix (for a vertex shader) or a texture
    (for a fragment shader). |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| **uniforms** | 这些是一种全局参数，可以根据每个图元（即每次绘制调用）进行更改。对于整个网格来说，它具有相同的值。这方面的一个例子可能是模型视图矩阵（对于顶点着色器）或纹理（对于片段着色器）。
    |'
- en: '| **varying** | These are per-pixel interpolated values computed according
    to the vertex shader output. They are an output parameter in vertex shaders and
    an input parameter in fragment shaders. In OpenGL ES 3, the "varying" parameters
    have a new syntax: `out` in a vertex shader and `in` in a pixel shader. |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| **varying** | 这些是根据顶点着色器输出计算的每个像素的插值值。它们在顶点着色器中是输出参数，在片段着色器中是输入参数。在 OpenGL
    ES 3 中，“varying”参数有新的语法：在顶点着色器中使用 `out`，在像素着色器中使用 `in`。 |'
- en: 'The main types of parameters allowed to declare such variables are shown in
    the following table:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明此类变量的主要参数类型如下表所示：
- en: '| **void** | This is for function result only. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| **void** | 这仅用于函数结果。 |'
- en: '| **bool** | This is a boolean value. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **bool** | 这是一个布尔值。 |'
- en: '| **float** | This is a floating point value. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **float** | 这是一个浮点数。 |'
- en: '| **int** | This is a signed integer value. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| **int** | 这是一个有符号整数。 |'
- en: '| **vec2, vec3, vec4** | This is a floating point vector. Vectors exist for
    other types such as `bvec` for booleans or `ivec` for signed integer. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| **vec2, vec3, vec4** | 这是一个浮点数向量。存在其他类型的向量，例如用于布尔值的 `bvec` 或用于有符号整数的 `ivec`。
    |'
- en: '| **mat2, mat3, mat4** | These are 2x2, 3x3, and 4x4 floating point matrices.
    |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| **mat2, mat3, mat4** | 这些是 2x2、3x3 和 4x4 浮点矩阵。 |'
- en: '| **sampler2D** | This gives access to 2D texture texels. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| **sampler2D** | 这提供了对 2D 纹理纹理元素（texel）的访问。 |'
- en: 'Note that the GLSL specification provides some predefined variables, such as
    the ones shown in the following table:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 GLSL 规范提供了一些预定义的变量，如下表所示：
- en: '| **highp vec4 gl_Position** | Vertex shader Output | This is the transformed
    vertex position. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| **highp vec4 gl_Position** | 顶点着色器输出 | 这是变换后的顶点位置。 |'
- en: '| **mediump float gl_PointSize** | Vertex shader Output | This is the size
    of a point sprite in pixels (more about this will be discussed in the next part).
    |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| **mediump float gl_PointSize** | 顶点着色器输出 | 这是点精灵的大小，以像素为单位（关于这一点将在下一部分中讨论）。
    |'
- en: '| **mediump vec4 gl_FragCoord** | Fragment shader Input | These are the coordinates
    of the fragment within framebuffer. |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| **mediump vec4 gl_FragCoord** | 片段着色器输入 | 这些是片段在帧缓冲区内的坐标。 |'
- en: '| **mediump vec4****gl_FragColor** | Fragment shader Output | This is the color
    to display for the fragment. |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| **mediump vec4 gl_FragColor** | 片段着色器输出 | 这是要为片段显示的颜色。 |'
- en: Numerous functions, mostly arithmetic, are also provided, such as `sin()`, `cos()`,
    `tan()`, `radians()`, `degrees()`, `mod()`, `abs()`, `floor()`, `ceil()`, `dot()`,
    `cross()`, `normalize()`, `texture2D()`, and so on.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了许多函数，主要是算术函数，例如 `sin()`、`cos()`、`tan()`、`radians()`、`degrees()`、`mod()`、`abs()`、`floor()`、`ceil()`、`dot()`、`cross()`、`normalize()`、`texture2D()`
    等等。
- en: 'These are some of the best practices to remember while dealing with shaders:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理着色器时，以下是一些需要记住的最佳实践：
- en: Do not compile or link shaders at runtime.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在运行时编译或链接着色器。
- en: Beware of different hardware that has different capabilities and, more specifically,
    a limited number of variables allowed.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意不同硬件具有不同的功能，特别是允许的变量数量有限。
- en: Find a good trade-off between performance and accuracy while defining precision
    specifiers (for example, `highp`, `medium`, or `lowp`). Do not hesitate to redefine
    them to get consistent behavior. Note that a `float` precision specifier should
    be defined in the GLES fragment shaders.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义精度说明符时（例如`highp`、`medium`或`lowp`），在性能和准确性之间找到一个好的折中方案。不要犹豫，重新定义它们以获得一致的行为。注意，`float`精度说明符应在GLES片段着色器中定义。
- en: Avoid conditional branches as much as possible.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能避免条件分支。
- en: For more information, have a look at OpenGL.org wiki at [http://www.opengl.org/wiki/OpenGL_Shading_Language](http://www.opengl.org/wiki/OpenGL_Shading_Language),
    [http://www.opengl.org/wiki/Vertex_Shader](http://www.opengl.org/wiki/Vertex_Shader)
    and [http://www.opengl.org/wiki/Fragment_Shader](http://www.opengl.org/wiki/Fragment_Shader).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多信息，请查看OpenGL.org维基页面：[http://www.opengl.org/wiki/OpenGL_Shading_Language](http://www.opengl.org/wiki/OpenGL_Shading_Language)，[http://www.opengl.org/wiki/Vertex_Shader](http://www.opengl.org/wiki/Vertex_Shader)和[http://www.opengl.org/wiki/Fragment_Shader](http://www.opengl.org/wiki/Fragment_Shader)。
- en: Beware, as the content of these pages is applicable to OpenGL but not necessarily
    to GLES.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些页面的内容适用于OpenGL，但不一定适用于GLES。
- en: Adapting graphics to various resolutions
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配各种分辨率的图形
- en: A complex subject to handle while writing a game is the Android screen size
    fragmentation. Low-end phones have resolutions of a few hundred pixels, whereas
    some high-end devices provide resolutions of more than two thousand.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写游戏时，需要处理的一个复杂主题是安卓屏幕尺寸的碎片化。低端手机的分辨率只有几百像素，而一些高端设备提供的分辨率则超过两千。
- en: There exist several ways to handle various screen sizes. We can adapt graphic
    resources, use black bands around the screen, or apply and adapt responsive designs
    to games.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以处理不同的屏幕尺寸。我们可以适配图形资源，使用屏幕周围的黑色带，或者将响应式设计应用于游戏。
- en: Another simple solution consists of rendering the game scene off-screen with
    a fixed size. The off-screen framebuffer is then copied onto the screen and scaled
    to an appropriate size. This *one size fits all* technique does not provide the
    best quality and might be a bit slow on low-end devices (especially if they have
    a lower resolution than the off-screen framebuffer). However, it is quite simple
    to apply.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的解决方案是使用固定大小离屏渲染游戏场景。然后将离屏帧缓冲区复制到屏幕上，并缩放到适当的大小。这种“一刀切”技术并不能提供最佳质量，在低端设备上可能会有些慢（特别是如果它们的分辨率低于离屏帧缓冲区）。然而，应用它相当简单。
- en: Note
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part9`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的附赠项目中提供了名为`DroidBlaster_Part9`的结果项目。
- en: Time for action – adapting resolution with off-screen rendering
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——通过离屏渲染适配分辨率
- en: 'Let''s render the game scene off-screen:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在离屏渲染游戏场景：
- en: 'Change `jni/GraphicsManager.hpp`, followed by these steps:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`jni/GraphicsManager.hpp`，然后执行以下步骤：
- en: Define new getter methods for the screen width and height with their corresponding
    member variables
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义获取屏幕宽度和高度的新方法，以及它们对应的成员变量
- en: 'Create a new function `initializeRenderBuffer()`, which creates an off-screen
    buffer to render the scene:'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新函数`initializeRenderBuffer()`，用于创建离屏缓冲区以渲染场景：
- en: '[PRE93]'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'While still being in the same file, follow these steps:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，执行以下步骤：
- en: Declare a new `RenderVertex` structure with four components - `x`, `y`, `u`,
    and `v`
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个新的`RenderVertex`结构，包含四个分量 - `x`、`y`、`u`和`v`
- en: 'Define the OpenGL resources necessary for the framebuffer, namely, the texture,
    the vertex buffer, the shader program, and its variables:'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义帧缓冲区所需的OpenGL资源，即纹理、顶点缓冲区、着色器程序及其变量：
- en: '[PRE94]'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Update the `jni/GraphicsManager.cpp` constructor initialization list to initialize
    default values:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`jni/GraphicsManager.cpp`构造函数初始化列表，以初始化默认值：
- en: '[PRE95]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Change `start()` method to save the display surface width and height respectively
    in `mScreenWidth` and `mScreenHeight`.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`start()`方法，分别将显示表面宽度与高度保存到`mScreenWidth`和`mScreenHeight`中。
- en: 'Then, call `initializeRenderBuffer()`:'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，调用`initializeRenderBuffer()`：
- en: '[PRE96]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Define a vertex and fragment shader for off-screen rendering. This is similar
    to what we have seen until now:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为离屏渲染定义顶点和片段着色器。这与我们至今所见的类似：
- en: '[PRE97]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In `initializeRenderBuffer()`, create a predefined array of a vertex that is
    going to be loaded into OpenGL. It represents a single quad with a full texture
    rendered on it.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initializeRenderBuffer()`中，创建一个预定义的顶点数组，该数组将要被加载到OpenGL中。它代表了一个带有完整纹理的单一四边形。
- en: Compute the new render height based on a fixed target width of `600` pixels.
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算基于固定目标宽度`600`像素的新渲染高度。
- en: 'Retrieve the current screen framebuffer from the location where the final scene
    is rendered using `glGetIntegerv()` and the special value `GL_FRAMEBUFFER_BINDING`:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glGetIntegerv()`和特殊值`GL_FRAMEBUFFER_BINDING`从最终场景渲染的位置获取当前屏幕帧缓冲区：
- en: '[PRE98]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a texture for off-screen rendering, like we have seen previously. In
    `glTexImage2D()`, pass a `NULL` value as the last parameter to create only the
    surface without initializing its content:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于离屏渲染的纹理，就像我们之前看到的那样。在`glTexImage2D()`中，传递`NULL`值作为最后一个参数，只创建表面而不初始化其内容：
- en: '[PRE99]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Then, create an off-screen framebuffer with `glGenFramebuffers()`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`glGenFramebuffers()`创建一个离屏帧缓冲区。
- en: Attach the previous texture to it with `glBindFramebuffer()`.
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glBindFramebuffer()`将之前的纹理附着到它上面。
- en: 'Terminate by restoring the device state:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，恢复设备状态：
- en: '[PRE100]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the shader program used to render texture to screen and retrieve its
    attributes and uniforms:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于将纹理渲染到屏幕的着色器程序，并获取其属性和制服：
- en: '[PRE101]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Do not forget to release allocated resources in `stop()` when the activity
    finishes:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动结束时，不要忘记在`stop()`中释放分配的资源：
- en: '[PRE102]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, use the new off-screen framebuffer to render the scene. To do so,
    you need to:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用新的离屏帧缓冲区来渲染场景。为此，你需要：
- en: Select the framebuffer with `glBindFramebuffer()`.
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`glBindFramebuffer()`选择帧缓冲区。
- en: 'Specify the rendering viewport, which has to match the off-screen framebuffer
    dimensions, as shown here:'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定渲染视口，它必须与离屏帧缓冲区的尺寸相匹配，如下所示：
- en: '[PRE103]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Once it's rendered, restore the normal screen framebuffer and the correct viewport
    dimensions.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染完成后，恢复正常的屏幕帧缓冲区和正确的视口尺寸。
- en: 'Then, select as a source the following parameters:'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，选择以下参数作为源：
- en: The off-screen texture which is attached to the off-screen framebuffer
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离屏纹理，它附着在离屏帧缓冲区上。
- en: The shader program, which does basically nothing apart from projecting vertices
    and scaling texture, on the screen framebuffer
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器程序，它基本上除了在屏幕帧缓冲区上投影顶点和缩放纹理之外什么也不做。
- en: 'The vertex buffer, which contains a single quad with texture coordinates, as
    shown in the following code:'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点缓冲区，它包含一个带有纹理坐标的单个四边形，如下代码所示：
- en: '[PRE104]'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Terminate by rendering the off-screen buffer into the screen.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将离屏缓冲区渲染到屏幕上来结束。
- en: 'You can then restore the device state again, like this:'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以像这样再次恢复设备状态：
- en: '[PRE105]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '*What just happened?*'
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Launch the application on several devices. Every device should display a proportionally
    similar scene. Indeed, graphics are now rendered to an off-screen framebuffer
    attached to a texture. The result is then scaled according to the target screen
    resolution to provide the same experience across different devices. This simple
    and cheap solution comes with a price, which is that the low-end devices might
    suffer depending on the chosen fixed resolution, whereas high-end devices will
    look blurry.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个设备上启动应用程序。每个设备应该显示一个比例相似的景象。实际上，现在图形渲染到一个附着在纹理上的离屏帧缓冲区。然后根据目标屏幕分辨率进行缩放，以提供不同设备上的相同体验。这个简单且经济的解决方案有一个缺点，即根据选择的固定分辨率，低端设备可能会受到影响，而高端设备则会显得模糊。
- en: Note
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Handling various screen resolutions is one thing. Managing their various aspect
    ratios is another. Several solutions exist for this problem, such as using black
    stripes, stretching the screen, or defining a minimum and maximum displayable
    area with only the first one containing important information.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 处理各种屏幕分辨率是一方面。管理它们的多种宽高比则是另一方面。这个问题有几种解决方案，比如使用黑边条、拉伸屏幕，或者定义一个只包含重要信息的可显示的最小和最大区域。
- en: More generally, the rendering of a scene off-screen is often referred to as
    **Render to Texture**. This technique is commonly used to implement shadows, reflection,
    or postprocessing effects. Mastering this technique is a key in implementing high
    quality games.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，离屏渲染场景通常被称为**渲染到纹理**。这种技术常用于实现阴影、反射或后期处理效果。掌握这项技术是实现高质量游戏的关键。
- en: Summary
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: OpenGL, and graphics in general, is a complex and highly technical API. One
    book is not enough to cover it entirely, but drawing 2D graphics with textures
    and buffer objects opens the door to much more advanced stuff!
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL和一般的图形是一个复杂且技术性很强的API。一本书不足以完全涵盖它，但使用纹理和缓冲对象绘制2D图形为更高级的内容打开了大门！
- en: In more detail, you have learned how to initialize an OpenGL ES context and
    bind it to an Android window. Then, you have seen how to turn libpng into a module
    and load a texture from a PNG asset. We have used this texture and then combined
    it with vertex buffers and shaders to render sprites and particles. Finally, we
    have found a solution to the Android resolution fragmentation issue with a simple
    off-screen and scaling rendering technique.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，你已经学会了如何初始化一个OpenGL ES上下文并将其绑定到一个Android窗口。然后，你了解了如何将libpng转换为一个模块，并从PNG资源中加载纹理。我们使用了这个纹理，并结合顶点缓冲区和着色器来渲染精灵和粒子。最后，我们找到了一个简单的离屏渲染和缩放技术解决方案，以解决Android分辨率碎片化问题。
- en: 'OpenGL ES is a complex API that requires an in-depth understanding to get the
    best performance and quality. This is even true with OpenGL ES 3, which we have
    not covered here, that is available since Android KitKat. Do not hesitate to have
    a look at:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES是一个复杂的API，需要深入理解才能获得最佳性能和品质。这同样适用于自Android KitKat以来可用的OpenGL ES 3，我们在这里并未涉及。不妨查看以下内容：
- en: The Openg ES and GLSL specification at [http://www.khronos.org/registry/gles/](http://www.khronos.org/registry/gles/)
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅[OpenGL ES和GLSL规范](http://www.khronos.org/registry/gles/)。
- en: The Android Developer website at [http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html)
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[Android开发者网站](http://developer.android.com/guide/topics/graphics/opengl.html)获取更多信息。
- en: With the knowledge acquired here, the road to OpenGL ES 2 or 3 is at a perfectly
    walkable distance! So now, let's discover how to reach the fourth dimension, the
    musical one, with OpenSL ES in our next chapter.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里获得的知识，使得通往OpenGL ES 2或3的道路变得完全可行！现在，让我们在下一章中探索如何通过OpenSL ES达到第四维度，即音乐维度。
