- en: Chapter 10. Intensive Computing with RenderScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。使用 RenderScript 进行密集计算
- en: '*If the NDK is one of the best tools to get a high performance on Android.
    It gives low-level access to the machine, gives you control on memory allocation,
    provides access to advanced CPU instruction-sets, and even more.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果 NDK 是在 Android 上获得高性能的最佳工具之一。它提供了对机器的低级访问，让你控制内存分配，提供对高级 CPU 指令集的访问，甚至更多。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This power comes with a price: to get maximum performance on a key piece of
    code, ones need to optimize code for the many devices and platforms in the world.
    Sometimes, it is more appropriate to use CPU SIMD instructions, and other times,
    to perform computation on the GPU. You had better be experienced and have plenty
    of devices and time in front of you! This is the reason Google introduced RenderScript
    on Android.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这种能力是有代价的：要想在一块关键代码上获得最大性能，需要针对世界上许多设备和平台优化代码。有时，使用 CPU SIMD 指令更合适，而其他时候，在
    GPU 上进行计算更佳。你最好有丰富的经验、大量的设备和充足的时间！这就是谷歌在 Android 上引入 RenderScript 的原因。*'
- en: '**RenderScript** is a programming language specific to Android written with
    one goal in mind: *performance*. Let''s be clear, applications cannot be entirely
    written in RenderScript. However, the critical parts, requiring intensive computations,
    should be! RenderScript can be executed from either Java or C/C++.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**RenderScript** 是一种专为 Android 设计的编程语言，它的编写宗旨是：*性能*。明确一点，应用程序不能完全用 RenderScript
    编写。但是，那些需要密集计算的关键部分，应该用！RenderScript 可以从 Java 或 C/C++ 中执行。'
- en: 'In this chapter, we will discuss these basics and concentrate our effort on
    its NDK binding. We will create a new project to demonstrate RenderScript capabilities
    by filtering images. More precisely, we will see how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些基础知识，并将我们的努力集中在它的 NDK 绑定上。我们将创建一个新项目来演示通过过滤图像的 RenderScript 功能。更准确地说，我们将了解如何：
- en: Execute the predefined **Intrinsics**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行预定义的**内置函数**
- en: Create your own custom **Kernels**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的自定义**内核**
- en: Combine Intrinsics and Kernels together
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内置函数和内核结合在一起
- en: By the end of this chapter, you should be able to create your own RenderScript
    programs and bind them into your native code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建自己的 RenderScript 程序并将它们绑定到你的原生代码中。
- en: What is RenderScript ?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 RenderScript？
- en: RenderScript was introduced in Honeycomb in 2011 with a strong focus on graphics
    capabilities, hence the name. The graphics engine part of RenderScript has, however,
    been deprecated since Android 4.1 JellyBean. Although it has kept its name, RenderScript
    has deeply evolved to emphasize its "compute engine". It is similar to technologies
    such as OpenCL and CUDA, with an emphasis on portability and usability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript 在 2011 年的 Honeycomb 中被引入，重点是图形处理能力，因此得名。然而，自 Android 4.1 JellyBean
    起，RenderScript 的图形引擎部分已被弃用。尽管保留了它的名字，但 RenderScript 已经深刻演变，强调其“计算引擎”。它与 OpenCL
    和 CUDA 等技术相似，重点是可移植性和可用性。
- en: More specifically, RenderScript tries to abstract hardware specificities from
    the programmer and extract the maximum raw power from it. Instead of taking the
    least common denominator, it optimizes code according to the platform it executes
    on at runtime. The final code can run on either the CPU or GPU, with an advantage
    of automatic parallelization managed by RenderScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，RenderScript 试图将硬件的具体性从程序员中抽象出来，并从中提取最大的原始力量。它不是采取最小公倍数，而是根据运行时执行的平台优化代码。最终代码可以在
    CPU 或 GPU 上运行，具有由 RenderScript 管理的自动并行化的优势。
- en: 'The RenderScript framework is composed of a few elements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript 框架由几个元素组成：
- en: A C-like language based on C99, which provides variables, functions, structures,
    and so on
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于 C99 的 C 语言，提供变量、函数、结构等。
- en: A **low level virtual machine** (**LLVM**) based compiler on the developer machine
    that produces intermediate code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者机器上基于**低级虚拟机**（**LLVM**）的编译器，生成中间代码
- en: A RenderScript library and runtime that translates intermediate code to machine
    code only when the final program runs on the device
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 RenderScript 库和运行时，只有在最终程序在设备上运行时才将中间代码转换为机器代码
- en: A Java and NDK binding API to execute and chain computation tasks
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Java 和 NDK 绑定 API，用于执行和链接计算任务
- en: 'Computation tasks are obviously the center of RenderScript. There are two kinds
    of tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算任务显然是 RenderScript 的核心。有两种类型的任务：
- en: Kernels, which are user-created scripts that perform a computation task using
    the RenderScript language
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核，这是用户创建的脚本，使用 RenderScript 语言执行计算任务
- en: Intrinsics, which are built-in Kernels to perform some common tasks such as
    blurring pixels
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数（Intrinsics），用于执行一些常见任务，如模糊像素的内置内核（Kernels）。
- en: Kernels and Intrinsics can be combined together, the output of a program being
    linked to the input of another. From the complex graphs of computation tasks emerge
    fast and powerful programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核（Kernels）和内置函数（Intrinsics）可以组合在一起，一个程序的输出链接到另一个程序的输入。从复杂的计算任务图中可以快速生成强大程序。
- en: However, for the moment, let's see what Intrinsics are and how they work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们看看内置函数（Intrinsics）是什么以及它们是如何工作的。
- en: Executing a predefined Intrinsic
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行一个预定义的内置函数（Intrinsic）。
- en: RenderScript provides a few built-in functions, mainly dedicated to Image processing,
    called Intrinsics. With these, blending images, such as in Photoshop, blurring
    them, or even decoding raw YUV images from the camera, (see [Chapter 4](ch04.html
    "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back from Native
    Code*, for a slower alternative) becomes simple and highly efficient. Indeed,
    Intrinsics are highly optimized and can be considered as one of the best implementations
    in their domain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderScript`提供了一些内置函数，主要用于图像处理，称为内置函数（Intrinsics）。使用这些函数，可以实现像Photoshop中那样的图像混合、模糊处理，甚至是从相机中解码原始YUV图像（对于更慢的替代方案，请参见[第4章](ch04.html
    "第4章. 从本地代码调用Java")，*从本地代码调用Java*）。这些内置函数简单高效。实际上，内置函数经过高度优化，可以认为是它们领域中最好的实现之一。'
- en: To see how Intrinsics work, let's create a new project that takes an input image
    and applies a blur effect to it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解内置函数（Intrinsics）是如何工作的，让我们创建一个新项目，该项目接收一个输入图像并对其应用模糊效果。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: The resulting project is provided with this book under the name `RenderScript_Part1`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`RenderScript_Part1`。
- en: Time for action – creating a Java UI
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建一个Java UI。
- en: Let's create a new Java project with a JNI module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有JNI模块的新Java项目。
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照在[第2章](ch02.html "第2章. 开始一个本地Android项目")，*开始一个本地Android项目*中所示，创建一个新的混合Java/C++项目：
- en: Name it `RenderScript`.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其命名为`RenderScript`。
- en: The main package is `com.packtpub.renderscript`.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主包名为`com.packtpub.renderscript`。
- en: '`minSdkVersion` is 9 and `targetSdkVersion` is 19.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minSdkVersion`为9，`targetSdkVersion`为19。'
- en: Define the `android.permission.WRITE_EXTERNAL_STORAGE` permission in the `AndroidManifest.xml`
    file.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中定义`android.permission.WRITE_EXTERNAL_STORAGE`权限。
- en: Turn the project into a native project as already seen.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目转换为已经了解过的本地项目。
- en: Remove the native source and header files that have been created by ADT.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除由ADT创建的本地源文件和头文件。
- en: Name the main Activity `RenderScriptActivity` and its layout `activity_renderscript.xml`.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主活动命名为`RenderScriptActivity`，其布局命名为`activity_renderscript.xml`。
- en: 'Define the `project.properties` file as follows. These lines activate the `RenderScript`
    support library, which allows porting code to older devices until API 8:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义`project.properties`文件。这些行激活了`RenderScript`支持库，允许将代码移植到直到API 8的旧设备上。
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `res/activity_renderscript.xml` to make it look as follows. We will
    need:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`res/activity_renderscript.xml`文件，使其看起来如下所示。我们将需要：
- en: A `SeekBar` to define the blur radius
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`SeekBar`来定义模糊半径。
- en: A `Button` to apply the blur effect
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于应用模糊效果的`Button`。
- en: Two `ImageView` elements to display the image before and after the effect is
    applied.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`ImageView`元素用于显示应用效果前后的图像。
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement `RenderScriptActivity` as shown below.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面所示实现`RenderScriptActivity`。
- en: Load the `RSSupport` module, which is the `RenderScript` support library, and
    the `renderscript` module, which we are about to create in a static block.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载`RSSupport`模块，它是`RenderScript`的支持库，以及`renderscript`模块，我们将在一个静态块中创建它。
- en: 'Then, in `onCreate()`, load a 32-bit bitmap from an image placed in `drawable`
    resources (here, named `picture`) and create a second empty bitmap of the same
    size. Assign these bitmaps to their respective `ImageView` component. Also, define
    `OnClickListener` on the **Blur** button:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在`onCreate()`方法中，从`drawable`资源目录下加载一个32位的位图（这里命名为`picture`），并创建一个相同大小的空白位图。将这些位图分配给它们各自的`ImageView`组件。同时，为**模糊**按钮定义`OnClickListener`。
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a native function, `blur`, which takes in the parameter:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个本地函数`blur`，它带有以下参数：
- en: The application cache directory for the `RenderScript` runtime
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderScript`运行时的应用程序缓存目录。'
- en: The source and destination bitmaps
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源位图和目标位图。
- en: The blur effect radius to determine the blur strength
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊效果的半径，以确定模糊的强度。
- en: Call this method from the `onClick()` handler using the seek bar value to determine
    the blur radius. The radius must be in the range [`0`, `25`].
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`onClick()`处理程序中调用这个方法，使用滑动条值来确定模糊半径。半径必须在`[0, 25]`范围内。
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action – running RenderScript Blur intrinsic
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——运行RenderScript模糊内置（Blur intrinsic）。
- en: Let's create the native module that will generate our new effect.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个本地模块，用于生成我们的新效果。
- en: 'Create a new file `jni/ RenderScript.cpp`. We will need the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/RenderScript.cpp`。我们需要以下内容：
- en: '`android/bitmap.h` header to manipulate bitmaps.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`android/bitmap.h`头文件操作位图。
- en: '`jni.h` for JNI strings.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jni.h`处理JNI字符串。
- en: '`RenderScript.h`, which is the main `RenderScript` header file. This is the
    only one you should need. RenderScript is written in C++ and is defined in the
    `android::RSC` namespace.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderScript.h`是主要的`RenderScript`头文件。这是你需要唯一的一个。RenderScript是用C++编写的，并在`android::RSC`命名空间中定义。'
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write two utility methods to lock and unlock Android bitmaps as seen in [Chapter
    4](ch04.html "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back
    from Native Code*:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写两个实用方法，按照[第4章](ch04.html "Chapter 4. Calling Java Back from Native Code")，*从本地代码调用Java*中所示锁定和解锁Android位图：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implement the native method `blur()` using the JNI convention.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI约定实现本地方法`blur()`。
- en: Then, instantiate the RS class. This class is the main interface, which controls
    RenderScript initialization, resource management, and object creation. Wrap it
    with the `sp` helper class provided by RenderScript, which represents a smart
    pointer.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，实例化RS类。这个类是主要的接口，控制RenderScript初始化、资源管理和对象创建。使用RenderScript提供的`sp`帮助类包装它，这代表一个智能指针。
- en: 'Initialize it with the cache directory given in parameter, converting the string
    appropriately with JNI:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用提供的缓存目录初始化它，并使用JNI适当地转换字符串：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lock the bitmaps we are working on using the utility methods we just wrote:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚才编写的实用方法锁定我们正在操作的位图：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now comes the interesting part. Create a RenderScript **Allocation** from the
    source bitmap. This `ALLOCATION` represents the whole input memory area whose
    dimensions are defined by `Type`. The Allocation is composed of "individual" **Elements**;
    in our case, 32-bit RGBA pixels are defined as `Element::RGBA_8888`. Since the
    bitmap is not used as a texture, we have no need for **Mipmaps** (see [Chaper
    6](ch06.html "Chapter 6. Rendering Graphics with OpenGL ES"), *Rendering Graphics
    with OpenGL ES*, about OpenGL ES for more information).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是这部分有趣的内容。从源位图创建一个RenderScript的**分配（Allocation）**。这个`ALLOCATION`代表了整个输入内存区域，其维度由`Type`定义。分配（Allocation）由“单个”**元素（Elements）**组成；在我们的案例中，32位RGBA像素定义为`Element::RGBA_8888`。由于位图不作为纹理使用，我们不需要**Mipmaps**（更多信息请参见[第6章](ch06.html
    "Chapter 6. Rendering Graphics with OpenGL ES")，*使用OpenGL ES渲染图形*）。
- en: 'Repeat the same operation for the output `ALLOCATION` created from the output
    bitmap:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对从输出位图创建的输出`ALLOCATION`重复相同的操作：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a `ScriptIntrinsicBlur` instance and the kind of elements it works on,
    which is again RGBA pixels. An Intrinsic is a predefined RenderScript function,
    which implements a common operation, such as a blur effect in our case. The **Blur
    Intrinsic** takes a radius as an input parameter. Set it with `setRadius()`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ScriptIntrinsicBlur`实例以及它处理的数据类型，即RGBA像素。内置（Intrinsic）是一个预定义的RenderScript函数，实现了一些常见的操作，比如我们案例中的模糊效果。**模糊内置（Blur
    Intrinsic）**以一个半径作为输入参数。使用`setRadius()`设置它。
- en: Then, specify the blur Intrinsic input, that is the source Allocation with `setInput()`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，指定模糊内置（Intrinsic）的输入，即使用`setInput()`的源分配（Allocation）。
- en: Apply the Intrinsic on each of its elements with `forEach()` and save it to
    the output Allocation.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`forEach()`将内置（Intrinsic）应用于每个元素，并将其保存到输出分配（Allocation）中。
- en: Finally, copy the result to the destination bitmap with `copy2DRangeTo()`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，使用`copy2DRangeTo()`将结果复制到目标位图。
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don't forget to unlock the bitmap after the effect is applied!
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用效果后，不要忘记解锁位图！
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a `jni/Application.mk` file targeting the `ArmEABI V7` and `X86` platforms.
    Indeed, RenderScript currently does not support older `ArmEABI V5`. `STLPort`,
    and is also required by the RenderScript native library.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`jni/Application.mk`文件，针对`ArmEABI V7`和`X86`平台。实际上，RenderScript目前不支持较旧的`ArmEABI
    V5`。需要`STLPort`，这也是RenderScript本地库要求的。
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a `jni/Android.mk` file defining our `renderscript` module and listing
    `RenderScript.cpp` for compilation.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`jni/Android.mk`文件，定义我们的`renderscript`模块，并列出`RenderScript.cpp`进行编译。
- en: Make `LOCAL_C_INCLUDES` point to the appropriate RenderScript, including the
    file directory in the NDK platform directory. Also, append the RenderScript precompiled
    libraries directory to `LOCAL_LDFLAG`.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `LOCAL_C_INCLUDES` 指向适当的 RenderScript，包括 NDK 平台目录中的文件目录。同时，将 RenderScript
    预编译库目录添加到 `LOCAL_LDFLAG`。
- en: 'Finally, link against `dl`, `log`, and `RScpp_static`, which are required for
    RenderScript:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，链接到 `dl`、`log` 和 `RScpp_static`，这些是 RenderScript 必需的：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'Run the project, increase the `SeekBar` value, and click on the **Blur** button.
    The output `ImageView` should display the filtered picture as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，增加 `SeekBar` 的值，点击 **模糊** 按钮。输出 `ImageView` 应显示如下过滤后的图片：
- en: '![What just happened?](img/9645_10_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/9645_10_01.jpg)'
- en: We embedded the RenderScript compatibility library in our project, giving us
    access to RenderScript down to the API 8 Froyo. On older devices, RenderScript
    is "emulated" on the CPU.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中嵌入了 RenderScript 兼容库，使我们能够访问到 API 8 Froyo 的 RenderScript。在旧设备上，RenderScript
    是在 CPU 上“模拟”的。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you decide to use RenderScript from the NDK but do not want to use the compatibility
    library, you will need to embed the RenderScript runtime manually. To do so, remove
    all the stuff we added in the `project.properties` file in step 2 and include
    the following piece of code at the end of your `Android.mk` files:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定从 NDK 使用 RenderScript 但不想使用兼容库，则需要手动嵌入 RenderScript 运行时。为此，删除在第2步中添加到 `project.properties`
    文件的所有内容，并在您的 `Android.mk` 文件的末尾包含以下代码片段：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we executed our first RenderScript Intrinsic that applies a blur effect
    as efficiently as possible. Intrinsic execution follows a simple and repetitive
    pattern that you will see repeatedly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行了第一个 RenderScript 内在（Intrinsic），尽可能高效地应用了模糊效果。内在执行遵循一种简单且重复的模式，您会多次看到：
- en: Ensure that the input and output memory areas are exclusively available, for
    example, by locking bitmaps.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保输入和输出内存区域是独占可用的，例如，通过锁定位图。
- en: Create or reuse the appropriate input and output Allocation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或重用适当的输入和输出分配。
- en: Create and set up the Intrinsic parameters.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并设置内在参数。
- en: Set the input Allocation and apply the Intrinsic to an output Allocation.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置输入分配（Allocation），并将内在（Intrinsic）应用于输出分配。
- en: Copy the result from the output Allocation to the target memory area.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出分配中的结果复制到目标内存区域。
- en: 'To understand this process better, let''s dive a bit more into the way RenderScript
    works. RenderScript follows a simple model. It takes some data as the input and
    processes it to an output memory area:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，让我们更深入地了解 RenderScript 的工作方式。RenderScript 遵循一个简单的模型。它获取一些数据作为输入，并处理到输出内存区域：
- en: '![What just happened?](img/9645_10_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/9645_10_04.jpg)'
- en: 'As a computing solution, RenderScript works with any type of data stored in-memory.
    This is an Allocation. An Allocation is composed of individual Elements. For an
    Allocation pointing to a bitmap, an element would typically be a pixel (which
    is itself a set of 4 `uchar` values). Among the large list of Elements available,
    we can cite:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算解决方案，RenderScript 处理内存中存储的任何类型的数据。这是一个分配（Allocation）。分配由单个元素组成。对于一个指向位图的分配，元素通常是一个像素（本身是一组4个
    `uchar` 值）。在众多可用的元素中，我们可以列举：
- en: '| Possible Allocation Elements |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 可能的分配元素 |'
- en: '| --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `U8`, `U8_2`, `U8_3`, `U8_4` | `I8`, `I8_2`, `I8_3`, `I8_4` | `RGBA_8888`
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `U8`, `U8_2`, `U8_3`, `U8_4` | `I8`, `I8_2`, `I8_3`, `I8_4` | `RGBA_8888`
    |'
- en: '| `U16`, `U16_2`, `U16_3`, `U16_4` | `I16`, `I16_2`¸ `I16_3`, `I16_4` | `RGB_565`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `U16`, `U16_2`, `U16_3`, `U16_4` | `I16`, `I16_2`, `I16_3`, `I16_4` | `RGB_565`
    |'
- en: '| `U32`, `U32_2`, `U32_3`, `U32_4` | `I32`, `I32_2`¸ `I32_3`¸ `I32_4` | `RGB_888`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `U32`, `U32_2`, `U32_3`, `U32_4` | `I32`, `I32_2`, `I32_3`, `I32_4` | `RGB_888`
    |'
- en: '| `U64`, `U64_2`, `U64_3`, `U64_4` | `I64`, `I64_2`, `I64_3`, `I64_4` | `A_8`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `U64`, `U64_2`, `U64_3`, `U64_4` | `I64`, `I64_2`, `I64_3`, `I64_4` | `A_8`
    |'
- en: '| `F32`, `F32_2`, `F32_3`, `F32_4` | `F64`, `F64_2`, `F64_3`¸ `F64_4` | `YUV`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `F32`, `F32_2`, `F32_3`, `F32_4` | `F64`, `F64_2`, `F64_3`, `F64_4` | `YUV`
    |'
- en: '| `MATRIX_2X2` | `MATRIX_3X3` | `MATRIX_4X4` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `MATRIX_2X2` | `MATRIX_3X3` | `MATRIX_4X4` |'
- en: '`U` = unsigned integer, `I` = signed integer, `F` = float'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`U` = 无符号整数，`I` = 有符号整数，`F` = 浮点数'
- en: '`8`, `16`, `32`, `64` = byte count. For example `I8` = 8-bits signed `int`
    (that is, a signed char)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`8`, `16`, `32`, `64` = 字节计数。例如 `I8` = 8位有符号整型（即有符号字符）'
- en: '`_2`, `_3`, `_4` = Number of elements for vectors (`I8_3` means vector of 3
    signed int)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`_2`, `_3`, `_4` = 向量中的元素数量（`I8_3` 表示3个有符号整数的向量）'
- en: '`A_8` represents an Alpha channel (with each pixel represented as an unsigned
    char).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`A_8` 表示 Alpha 通道（每个像素表示为一个无符号字符）。'
- en: Internally, Elements are described with a **DataType** (such as `UNSIGNED_8`
    for an unsigned char) and a **DataKind** (such as `PIXEL_RGBA` for a pixel). The
    DataKind is used with something called **Samplers** for graphics data that is
    interpreted on the GPU (see [Chapter 6](ch06.html "Chapter 6. Rendering Graphics
    with OpenGL ES"), *Rendering Graphics with OpenGL ES*, about OpenGL ES to better
    understand what is a Sampler). DataType and DataKind are for more advanced usage
    and should be transparent to you most of the time. You can have a look at the
    full list of elements at [http://developer.android.com/reference/android/renderscript/Element.html](http://developer.android.com/reference/android/renderscript/Element.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Element 使用 **DataType**（例如 `UNSIGNED_8` 表示无符号字符）和 **DataKind**（例如 `PIXEL_RGBA`
    表示像素）来描述。DataKind 与称为 **Samplers** 的东西一起用于在 GPU 上解释的图形数据（请参阅[第6章](ch06.html "第6章.
    使用OpenGL ES渲染图形")，*使用OpenGL ES渲染图形*，以更好地了解什么是 Sampler）。DataType 和 DataKind 是更高级的用法，大多数时候对您应该是透明的。您可以在
    [http://developer.android.com/reference/android/renderscript/Element.html](http://developer.android.com/reference/android/renderscript/Element.html)
    查看完整的 Element 列表。 |
- en: Knowing the type of input/output Element is not enough. Their number is also
    essential, as this determines the whole Allocation size. This is the role of `Type`,
    which can be set up with 1 dimension, 2 dimensions (typically for bitmaps), or
    3 dimensions. Some other information is also supported, such as the YUV format
    (NV21 being the default in Android as seen in [Chapter 4](ch04.html "Chapter 4. Calling
    Java Back from Native Code"), *Calling Java Back from Native Code*). So, in other
    words, `Type` describes a multi-dimensional array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅知道输入/输出 Element 的类型是不够的。它们的数量同样重要，因为这决定了整个 Allocation 的大小。这就是 `Type` 的作用，它可以设置为1维，2维（通常用于位图），或3维。还支持其他一些信息，例如
    YUV 格式（NV21 是 Android 中的默认格式，如[第4章](ch04.html "第4章. 从本地代码调用 Java")，*从本地代码调用 Java*
    中所见）。换句话说，`Type` 描述了一个多维数组。
- en: Allocations have a specific flag to control how Mipmaps are generated. By default,
    most Allocations will not need one (`RS_ALLOCATION_MIPMAP_NONE`). However, when
    used as the input of a graphics texture, Mipmaps are either created in script
    memory (`RS_ALLOCATION_MIPMAP_FULL`) or when uploaded to the GPU (`RS_ALLOCATION_MIPMAP_ON_SYNC_TO_TEXTURE`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Allocation 有一个特定的标志来控制如何生成 Mipmaps。默认情况下，大多数 Allocation 都不需要 Mipmap (`RS_ALLOCATION_MIPMAP_NONE`)。然而，当作为图形纹理的输入时，Mipmap
    要么在脚本内存中创建 (`RS_ALLOCATION_MIPMAP_FULL`)，要么在上传到 GPU 时创建 (`RS_ALLOCATION_MIPMAP_ON_SYNC_TO_TEXTURE`)。
- en: 'Once we create the Allocation from a Type and an Element, we can take care
    of creating and setting up Intrinsics. RenderScript provides a few of them, which
    are not many, but mainly focused on image processing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们根据 Type 和 Element 创建了 Allocation，就可以处理创建和设置 Intrinsics。RenderScript 提供了一些主要关注图像处理的内置函数，虽然数量不多：
- en: '| Intrinsic | Description |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 内置函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| To blend two Allocations together, for example, two images (we will see additive
    blending in the last part of this chapter). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 用于将两个 Allocation 混合在一起，例如，两个图像（我们将在本章的最后部分看到加性混合）。 |'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| To apply a blur effect on a Bitmap. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 用于在 Bitmap 上应用模糊效果。 |'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| To apply a color matrix to an Allocation (for example, to adjust image hue,
    change colors, and so on). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 用于将颜色矩阵应用到 Allocation（例如，调整图像色调，改变颜色等）。 |'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| To apply a convolve matrix of size 3 to an Allocation (many image filters
    can be implemented with a convolve matrix, including blurring). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 用于将大小为3的卷积矩阵应用到 Allocation（许多图像滤镜可以通过卷积矩阵实现，包括模糊处理）。 |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This is the same as `ScriptIntrinsicConvolve3x3` but with a matrix of size
    5. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 这与 `ScriptIntrinsicConvolve3x3` 相同，但使用的是大小为5的矩阵。 |'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This is used to apply a histogram filter (for example, to improve the image
    contrast). |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 用于应用直方图滤镜（例如，提高图像对比度）。 |'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| This is used to apply a "Lookup Table" per channel (for example, to translate
    a given red value in a pixel to another predefined value in the table). |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 用于每个通道应用“查找表”（例如，将像素中给定的红色值转换为表中另一个预定义的值）。 |'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| This is used to resize a 2D Allocation (for example, to scale an image).
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 用于调整2D Allocation 的大小（例如，缩放图像）。 |'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| To translate YUV images coming, for example, from a camera to an RGB image
    (like we did in [Chapter 4](ch04.html "Chapter 4. Calling Java Back from Native
    Code"), *Calling Java Back from Native Code*). The binding of this Intrinsic in
    the NDK is bugged and, thus, unusable at the time this book was written. If you
    really need it, apply it from Java. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 例如，要将来自相机的 YUV 图像转换为 RGB 图像（就像我们在[第4章](ch04.html "第4章. 从本地代码调用 Java")，*从本地代码调用
    Java*中所做的那样）。在 NDK 中绑定这个内置函数是有问题的，因此在本书编写时无法使用。如果你确实需要它，从 Java 应用它。|'
- en: Each of these Intrinsics requires its own specific parameters (for example,
    the radius for a blur effect). Full Intrinsics documentation can be found at [http://developer.android.com/reference/android/renderscript/package-summary.html](http://developer.android.com/reference/android/renderscript/package-summary.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内置函数都需要其自己的特定参数（例如，模糊效果的半径）。完整的内置函数文档可以在 [http://developer.android.com/reference/android/renderscript/package-summary.html](http://developer.android.com/reference/android/renderscript/package-summary.html)
    找到。
- en: Intrinsics require an input and output Allocation. It is technically possible
    to use an input as an output if the kind of function applied is appropriate. This
    is not the case, for example, `ScriptIntrinsicBlur` as a blurred pixel could be
    written at the same time it is read to blur other pixels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数需要输入和输出分配。从技术上讲，如果应用的函数类型适当，可以使用输入作为输出。例如，`ScriptIntrinsicBlur` 就不适用，因为模糊的像素可能在同时被读取以模糊其他像素时被写入。
- en: Once Allocations are set, an Intrinsic is applied and performs its work. After
    that, the result must be copied to the output memory area with one of the `copy***To()`
    methods (`copy2DRangeTo()` for a bitmap, which has two dimensions or `copy2DStridedTo()`
    if there are gaps in the target area). Data copying is a prerequisite step before
    making use of the computation result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好分配后，应用内置函数并执行其工作。之后，结果必须使用 `copy***To()` 方法之一（对于具有两个维度的位图使用 `copy2DRangeTo()`，如果目标区域有间隔则使用
    `copy2DStridedTo()`）复制到输出内存区域。数据复制是在使用计算结果之前的一个必要步骤。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some problems have been reported on some devices when the size of an image Allocation
    was not a multiple of 4\. This will probably remind you of OpenGL textures, which
    have the same requirements. So, try to stick with dimensions that are multiples
    of 4.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些设备上，如果图像分配的大小不是 4 的倍数，已经报告了一些问题。这可能会让你想起 OpenGL 纹理，它们也有相同的要求。因此，尽量使用 4 的倍数的尺寸。
- en: Although the Intrinsics provided by RenderScript are really useful, you may
    want more flexibility. Maybe you need your own custom image filter, or a blur
    effect of more than 25 pixels, or maybe you do not want to process images at all.
    Then, RenderScript Kernels might be the right answer for you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 RenderScript 提供的内置函数确实很有用，但你可能需要更多的灵活性。也许你需要自己的自定义图像滤镜，或者需要超过 25 像素的模糊效果，或者你可能根本不想处理图像。那么，RenderScript
    内核可能就是你要找的答案。
- en: Writing a custom Kernel
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义内核
- en: RenderScript gives you the ability to develop small custom "scripts" instead
    of the built-in Intrinsics. These programs are called Kernels and are written
    in a C-like language. They are compiled to an intermediate language by the RenderScript
    LLVM-based compiler at build time. Finally, they are translated to machine code
    at runtime. RenderScript takes care of platform-dependent optimizations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript 让你有能力开发小的自定义“脚本”，而不是内置函数。这些程序称为内核，用类似 C 的语言编写。它们由基于 RenderScript
    LLVM 的编译器在构建时编译成中间语言。最后，它们在运行时被翻译成机器码。RenderScript 负责平台相关的优化。
- en: Let's now see how to create such a Kernel by implementing a custom image effect
    that filters pixels according to their luminosity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过实现一个根据像素亮度过滤的自定义图像效果来创建这样的内核。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The resulting project is provided with this book under the name `RenderScript_Part2`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的项目随书提供，名为 `RenderScript_Part2`。
- en: Time for action – writing a luminance threshold filter
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 编写一个亮度阈值滤波器
- en: Let's append a new component to our UI and implement the new image filter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 UI 中添加一个新组件并实现新的图像滤镜。
- en: 'Add a new **Threshold** `SeekBar` and `Button` in `res/activity_renderscript.xml`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/activity_renderscript.xml` 中添加一个新的 **阈值** `SeekBar` 和 `Button`：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Edit `RenderScriptActivity` and bind the **Threshold** `SeekBar` and `Button`
    to a new native method `threshold()`. This method is similar to `blur()`, except
    that it takes a threshold float parameter in the range [`0`, `100`].
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `RenderScriptActivity`，并将**阈值** `SeekBar` 和 `Button` 绑定到一个新的本地方法 `threshold()`。这个方法与
    `blur()` 类似，不同之处在于它接收一个在范围 [`0`, `100`] 内的浮点阈值参数。
- en: '[PRE24]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s write our own `jni/threshold.rs` filter using the RenderScript
    language. First, use pragma directives to declare:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 RenderScript 语言编写自己的 `jni/threshold.rs` 过滤器。首先，使用 pragma 指令声明：
- en: The script language version (currently, only `1` is possible)
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本语言版本（目前只有 `1` 是可能的）
- en: The Java package name the script is associated with
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本关联的 Java 包名
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, declare an input parameter `thresholdValue` of type `float`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明一个类型为 `float` 的输入参数 `thresholdValue`。
- en: 'We also to need two constant vectors of 3 floats (`float3`):'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要两个 3 个浮点数（`float3`）的常量向量。
- en: The first value represents a `BLACK` color
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值表示 `BLACK` 颜色
- en: The second value a predefined `LUMINANCE_VECTOR`
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值是一个预定义的 `LUMINANCE_VECTOR`。
- en: '[PRE26]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the root function of the script named `threshold()`. It takes a vector
    of 4 unsigned char, that is, an RGBA pixel in input, and returns a new one in
    output. Prepend `__attribute__((kernel))` to indicate that this function is the
    main script function, that is, the "Kernel''s Root". The function works as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `threshold()` 的脚本根函数。它接收一个 4 个无符号字符的向量，即输入的 RGBA 像素，并输出一个新的像素。使用 `__attribute__((kernel))`
    作为前缀，表示这个函数是主要的脚本函数，即“Kernel 的根”。该函数的工作原理如下：
- en: It converts the input pixel from a vector of char, with each color component
    in the range [`0`, `255`], to a vector of float value with each component in the
    range [`0.0`, `1.0`]. This is the role of the function `rsUnpackColor8888()`.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将输入像素从字符向量转换成浮点值向量，每个颜色分量在范围 [`0`, `255`] 内，转换成每个分量在范围 [`0.0`, `1.0`] 内的向量。这是函数
    `rsUnpackColor8888()` 的作用。
- en: Now that we have a float vector, some of the many mathematical functions provided
    by RenderScript can be applied. Here, a dot product with a predefined luminosity
    vector for the RGBA color space returns the relative luminosity of a pixel.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了浮点向量，可以使用 RenderScript 提供的许多数学函数之一。这里，与 RGBA 颜色空间的预定义亮度向量进行点乘，返回一个像素的相对亮度。
- en: With this information, the function checks whether a pixel's luminosity is sufficient
    according to the given threshold. If not, the pixel is set to black.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有了这些信息，函数会检查一个像素的亮度是否根据给定的阈值足够。如果不是，像素将被设置为黑色。
- en: Finally, it converts a pixel's color from a float vector to an unsigned char
    vector with `rsPackColor8888()`. This value will then be copied by RenderScript
    into the final Bitmap as we will see.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它通过 `rsPackColor8888()` 将像素颜色的浮点向量转换为无符号字符向量。这个值随后会被 RenderScript 复制到最终的
    Bitmap 中，我们稍后会看到。
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To compile our new `threshold.rs` script, list it in the `Android.mk` file.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译我们新的 `threshold.rs` 脚本，请在 `Android.mk` 文件中列出它。
- en: 'During the compilation process, `ScriptC_threshold.h` and `ScriptC_threshold.cpp`
    is generated in `obj/local/armeabi-v7a/objs-debug/renderscript`. These files contain
    the code to bind our code with the **Threshold Kernel** executed by RenderScript.
    So, we also need to append the directory to the `LOCAL_C_INCLUDES` directory:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编译过程中，`ScriptC_threshold.h` 和 `ScriptC_threshold.cpp` 会被生成在 `obj/local/armeabi-v7a/objs-debug/renderscript`
    目录下。这些文件包含将我们的代码与由 RenderScript 执行的**阈值 Kernel**绑定的代码。因此，我们还需要将此目录添加到 `LOCAL_C_INCLUDES`
    目录中：
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Include the generated header in `jni/RenderScript.cpp`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/RenderScript.cpp` 中包含生成的头文件。
- en: '[PRE29]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, implement the new method `threshold()`, respecting the JNI naming convention.
    This method is similar to `blur()`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照 JNI 命名约定实现新的 `threshold()` 方法。这个方法与 `blur()` 方法类似。
- en: However, instead of instantiating a predefined Intrinsic, we instantiate a Kernel
    generated by RenderScript. This Kernel is named `ScriptC_threshold` according
    to our RenderScript filename.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们不是实例化一个预定义的 Intrinsic，而是通过 RenderScript 实例化一个名为 `ScriptC_threshold` 的 Kernel，这个名字是根据我们的
    RenderScript 文件名来的。
- en: The input parameter `thresholdValue` defined in our script can be initialized
    with `set_thresholdValue()` generated by RenderScript. Then, the main method `threshold()`
    can be applied using the generated method `forEach_threshold()`.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的脚本中定义的输入参数 `thresholdValue` 可以通过 RenderScript 生成的 `set_thresholdValue()`
    进行初始化。然后，可以使用生成的 `forEach_threshold()` 方法应用主方法 `threshold()`。
- en: 'Once the Kernel has been applied, the result can be copied on the target bitmap,
    such as with Intrinsics, using `copy2DRangeTo()`:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用了 Kernel 之后，结果可以像使用 Intrinsics 一样，通过 `copy2DRangeTo()` 复制到目标位图上：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Run the project, increase the new `SeekBar`, and click on the **Threshold**
    button. The output `ImageView` should display the filtered picture with only luminous
    pixels as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，增加新的 `SeekBar`，并点击 **阈值** 按钮。输出的 `ImageView` 应显示只有发光像素的过滤图片，如下所示：
- en: '![What just happened?](img/9645_10_02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/9645_10_02.jpg)'
- en: 'We have written and compiled our first RenderScript Kernel. Kernel scripts
    have a `.rs` extension and are written in a language inspired by C99\. Their content
    starts with pragma definitions that bring additional "meta" information about
    them: the language version (which can be only 1) and the Java package. We can
    also use them to tweak the floating point precision for calculations with pragma
    directives `(#pragma rs_fp_full, #pragma rs_fp_relaxed`, or `#pragma rs_fp_imprecise`).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写并编译了第一个RenderScript Kernel。Kernel脚本以`.rs`为扩展名，并使用受C99启发的语言编写。它们的内容以pragma定义开始，这些定义提供了关于它们的额外“元”信息：语言版本（只能是1）和Java包。我们还可以使用pragma指令调整浮点计算精度（`#pragma
    rs_fp_full`, `#pragma rs_fp_relaxed`，或`#pragma rs_fp_imprecise`）。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Java package is important for the RenderScript runtime, which needs to resolve
    compiled Kernels during execution. When using the RenderScript Compatibility library,
    scripts compiled with the NDK (that is stored in the `jni` folder) might not get
    resolved. In that case, a possible solution is to make a copy of the `.rs` files
    in the Java `src` folder in the appropriate package.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java包对于RenderScript运行时很重要，它需要在执行期间解析编译后的Kernels。当使用RenderScript兼容库时，使用NDK编译的脚本（存储在`jni`文件夹中）可能无法解析。在这种情况下，一个可能的解决方案是在Java
    `src`文件夹中适当包内复制`.rs`文件。
- en: 'Kernels are, in a way similar, to Intrinsics. Indeed, once compiled, the same
    process applies to them: creating the allocations, the Kernel, setting everything
    up, applying, and finally, copying the result. When executed, a Kernel function
    is applied on each Element of the input and returned in the corresponding output
    allocation Element, in parallel.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Kernels在某种程度上类似于Intrinsics。实际上，一旦编译，它们应用的过程是相似的：创建分配、Kernel、设置一切、应用，最后复制结果。当执行时，Kernel函数对输入的每个Element进行操作，并在对应的输出分配Element中并行返回。
- en: You can set up a Kernel through the NDK binding API and an additional binding
    layer (more commonly called the **reflected** layer), which is generated at compile
    time. Each compiled script is "reflected" by a C++ class, whose name is defined
    according to the script filename prefixed with `ScriptC_`. The final code is generated
    in the **eponym** header and the source files in the `obj` directory, one for
    each per ABI. The reflected classes are your only interface with the script file,
    as a kind of wrapper. They perform some runtime checks on the kind of Allocation
    passed in the input or output of the Kernel to ensure their Element type matches
    what is declared in the script file. Have a look at the generated `ScriptC_threshold.cpp`
    in the project `obj` directory for a concrete example.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过NDK绑定API和额外的绑定层（更常见的是称为**反射**层）来设置Kernel，该层在编译时生成。每个编译的脚本都由一个C++类“反射”，其名称根据脚本文件名前缀`ScriptC_`定义。最终代码在**同名**头文件和`obj`目录中的源文件中生成，每个ABI一个。反射类是与脚本文件交互的唯一接口，作为一种包装器。它们对传递给Kernel输入或输出的分配类型进行一些运行时检查，以确保其Element类型与脚本文件中声明的类型匹配。查看项目中`obj`目录下生成的`ScriptC_threshold.cpp`以获取具体示例。
- en: 'Kernel input parameters are passed from the reflected layer to the script file
    through global variables. Global variables correspond to all the non-`static`
    and non-`const` variables, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Kernel输入参数通过反射层传递给脚本文件，通过全局变量。全局变量对应于所有非`static`和非`const`变量，例如：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: They are declared outside functions such as a C variable. Global variables are
    made available in the reflected layer through setters. In our project, the `thresholdValue`
    global variable is passed through the generated method `set_thresholdValue()`.
    Variables do not have to be primitive types. They can also be pointers, in which
    case the reflected method name is prefixed with `bind_`. and expects an Allocation.
    Getters are also provided in the generated classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是在函数外部声明的，比如C变量。全局变量通过设置器在反射层中可用。在我们的项目中，`thresholdValue`全局变量通过生成的`set_thresholdValue()`方法传递。变量不必是基本类型。它们还可以是指针，在这种情况下，反射方法名称以`bind_`为前缀，并期望一个分配。在生成的类中也提供了获取器。
- en: 'On the other hand, static variables, declared in the same scope as global variables,
    are not accessible in the NDK reflected layer and cannot be modified outside of
    the script. When marked `const`, they are obviously treated as constants, like
    the luminance vector in our project:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，与全局变量在同一作用域内声明的静态变量在NDK反射层中不可访问，且无法在脚本外部修改。当标记为`const`时，它们显然被视为常量，就像我们项目中亮度向量一样：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The main Kernel functions, more commonly called **root functions**, are declared
    like a C function except that they are marked with `__attribute__((kernel))`.
    They take as parameter the Element type of the input Allocation and return the
    type of Element of the output Allocation. Both the input parameter and return
    value are optional but at least one of them must be present. In our example, the
    input parameter and the output return value is a pixel Element (that is, a vector
    of 4 unsigned char; 1 byte for each color channel):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 Kernel 函数，更常见的称呼是**root 函数**，像声明 C 函数一样，只是它们用`__attribute__((kernel))`标记。它们以输入
    Allocation 的 Element 类型作为参数，并以输出 Allocation 的 Element 类型作为返回值。输入参数和返回值都是可选的，但至少需要其中一个。在我们的示例中，输入参数和输出返回值都是一个像素
    Element（即 4 个无符号字符的向量；每个颜色通道 1 字节）：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'RenderScript root functions can be also given additional index parameters that
    represent Element position (or "coordinates") within its Allocation. For example,
    we can declare two additional `uint32_t` parameters to get pixel Element coordinates
    in `threshold()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript 的 root 函数还可以提供额外的索引参数，这些参数表示 Allocation 内的 Element 位置（或“坐标”）。例如，我们可以在`threshold()`中声明两个额外的`uint32_t`参数，以获取像素
    Element 的坐标：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Multiple root functions with different names can be declared in one script.
    After compilation, they are reflected in the generated class as functions prefixed
    with `forEach_`, for example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个脚本中可以声明多个具有不同名称的 root 函数。编译后，它们在生成的类中以`forEach_`前缀的函数形式体现，例如：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before `__attribute__((kernel))` was introduced, RenderScript files could only
    contain one main function named root. This form is still allowed nowadays. Such
    functions take a pointer to the input, output Allocation in parameters, and do
    not allow return values. So the `threshold()` function rewritten as a traditional
    root method would look like the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__attribute__((kernel))`引入之前，RenderScript 文件只能包含一个名为 root 的主函数。这种形式至今仍然被允许。这类函数接收输入、输出
    Allocation 的指针作为参数，并且不允许有返回值。因此，将`threshold()`函数重写为传统的 root 方法如下所示：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In addition to the `root()` function, a script can also contain an `init()`
    function with no parameter and return value. This function is called only once
    when the script is instantiated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`root()`函数之外，脚本还可以包含一个无参数和返回值的`init()`函数。这个函数在脚本实例化时只被调用一次。
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Obviously, the possibilities of the RenderScript language are more limited
    and constrained than traditional C. We cannot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，RenderScript 语言的功能比传统的 C 语言更有限、更受限制。我们无法：
- en: Allocate resources directly. The memory must be allocated by the client application
    before running the Kernel.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接分配资源。在运行 Kernel 之前，内存必须由客户端应用程序分配。
- en: Write low-level assembly code or do fancy C stuff. However, hopefully, plenty
    of familiar elements of the C language are available, such as `struct`, `typedef`,
    `enum` and so on; even pointers!
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写低级汇编代码或进行花哨的 C 语言操作。但是，希望有大量熟悉的 C 语言元素可用，比如`struct`、`typedef`、`enum`等等；甚至指针！
- en: Use C libraries or runtime. However, RenderScript provides a full "runtime"
    library with plenty of math, conversion, atomic functions, and so on. Have a look
    at [http://developer.android.com/guide/topics/renderscript/reference.html](http://developer.android.com/guide/topics/renderscript/reference.html)
    for more details about them.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C 库或运行时。然而，RenderScript 提供了一个完整的“运行时”库，其中包含大量的数学、转换、原子函数等。更多详细信息，请查看[http://developer.android.com/guide/topics/renderscript/reference.html](http://developer.android.com/guide/topics/renderscript/reference.html)。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A method provided by RenderScript that you may find particularly useful is `rsDebug()`,
    which prints debug log to ADB.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RenderScript 提供的一个你可能觉得特别有用的方法是`rsDebug()`，它将调试日志打印到 ADB。
- en: Even with those limitations, RenderScript constraints are still quite relaxed.
    A consequence is that some scripts might not benefit from maximum acceleration,
    for example, on the GPU, which is quite restricting. To overcome this issue, a
    limited subset of RenderScript called **FilterScript** was designed to favor optimization
    and compatibility. Consider it if you need maximum performance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些限制，RenderScript 的限制仍然相当宽松。其结果是，某些脚本可能无法从最大加速中受益，例如在 GPU 上，这相当受限。为了解决这个问题，设计了一个名为
    **FilterScript** 的 RenderScript 有限子集，以优化和兼容性。如果你需要最大性能，可以考虑使用它。
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RenderScript语言功能的更多信息，请查看[http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html)。
- en: Combining scripts together
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合脚本
- en: '*Unity is strength* could not be truer than with RenderScript. Intrinsics and
    Kernels alone are powerful features. However, combined together, they give its
    full strength to the RenderScript framework.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*团结就是力量*对于RenderScript来说再真实不过了。内置函数和内核本身是强大的功能。然而，当它们结合在一起时，它们使RenderScript框架发挥出全部的力量。'
- en: Let's now see how to combine the **Blur** and **Luminosity** threshold filters
    together with a blending Intrinsic to create a great-looking image effect.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将**模糊**和**亮度**阈值滤镜与混合内置函数结合在一起，创建一个美观的图像效果。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `RenderScript_Part3`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目在名称`RenderScript_Part3`下。
- en: Time for action – combining Intrinsics and scripts together
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——组合内置函数和脚本
- en: Let's improve our project to apply a new combined filter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进项目，应用一个新的组合滤镜。
- en: 'Add a new **Combine** `Button` in `res/activity_renderscript.xml`, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/activity_renderscript.xml`中添加一个新的**组合**`Button`，如下所示：
- en: '[PRE38]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Bind the **Combine** button to a new native method `combine()`, which has the
    parameters of both `blur()` and `threshold()`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**组合**按钮绑定到一个新的本地方法`combine()`，该方法具有`blur()`和`threshold()`的参数：
- en: '[PRE39]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Edit `jni/RenderScript.cpp` and add the new `combine()` method, following the
    JNI convention again. The method performs similarly to what we saw previously:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/RenderScript.cpp`并按照JNI约定添加新的`combine()`方法。该方法与我们之前看到的类似：
- en: The RenderScript engine is initialized
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化RenderScript引擎
- en: Bitmaps are locked
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图被锁定
- en: The appropriate Allocation is created for the input and output bitmaps
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为输入和输出位图创建适当的分配
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will also need a temporary memory area to store the result of computations.
    Let''s create a temporary allocation backed by a memory buffer `tmpBuffer`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个临时内存区域来存储计算结果。让我们创建一个由内存缓冲区`tmpBuffer`支持的临时分配：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Initialize the Kernels and Intrinsics we need for the combined filter:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化组合滤镜所需的内核和内置函数：
- en: The `Threshold` Kernel
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`阈值`内核'
- en: The `Blur` Intrinsic
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模糊`内置函数'
- en: An additional `Blend` Intrinsic that does not require parameters
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不需要参数的额外`混合`内置函数
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, combine the multiple filters together:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将多个滤镜组合在一起：
- en: First, apply the Threshold filter and save the result into the temporary allocation.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，应用阈值滤镜并将结果保存到临时分配中。
- en: Second, apply the Blur filter on the temporary Allocation and save the result
    in the target bitmap Allocation.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在临时分配上应用模糊滤镜，并将结果保存到目标位图分配中。
- en: Finally, blend both the source and the filtered bitmap using an additive operation
    to create the final image. Blending can be done "in-place", without an additional
    Allocation, since each pixel is read and written only once (to the opposite of
    the blur filter).
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用加法操作将源位图和过滤后的位图混合在一起，以创建最终图像。由于每个像素只读取和写入一次（与模糊滤镜相反），因此可以“就地”混合，无需额外的分配。
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, save the result and free resources. All values wrapped in a `sp<>`
    (that is, a smart pointer) template, such as `tmpAlloc`, are freed automatically:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存结果并释放资源。所有在`sp<>`（即智能指针）模板中的值，如`tmpAlloc`，都会自动释放：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Run the project, tweak the `SeekBar` components, and click on the **Combine**
    button. The output `ImageView` should display a "remastered" picture, where the
    luminous parts are highlighted:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，调整`SeekBar`组件，并点击**组合**按钮。输出`ImageView`应该显示一个“重制”的图片，其中发光部分被突出显示：
- en: '![What just happened?](img/9645_10_03.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645_10_03.jpg)'
- en: We chained multiple Intrinsics and Kernels together to apply a **Combine** filter
    to an image. Such a chain is easy to put in place; we basically need to connect
    the output Allocation of one script to the input Allocation of the next. Copying
    data to the output memory area is really only necessary at the end.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将多个内置函数和内核串联在一起，将**组合**滤镜应用于图像。这样的链很容易建立；我们基本上需要将一个脚本的输出分配连接到下一个脚本的输入分配。在最后才真正需要将数据复制到输出内存区域。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's really sad but script grouping features are not yet available on the Android
    NDK API, only on the Java side. With the script grouping feature, a full "graph"
    of scripts can be defined allowing RenderScript to optimize the code further.
    If you need this feature, then you can either wait or go back to Java.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 令人遗憾的是，脚本分组功能在Android NDK API上还不可用，只能在Java端使用。通过脚本分组功能，可以定义一个完整的脚本“图”，使RenderScript能够进一步优化代码。如果你需要这个功能，那么你可以选择等待或者回到Java。
- en: Hopefully, Allocations can be reused if necessary in multiple scripts, to avoid
    allocating useless memory. It is even possible to reuse the same Allocation in
    input and output, if the script allows "in-place" modifications. This is not the
    case, for example, of the **Blur** filter, which would rewrite blurred pixels
    while they are read to blur other pixels, resulting in weird visual artefacts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果需要，Allocations可以在多个脚本中重复使用，以避免分配无用的内存。如果脚本允许“就地”修改，甚至可以将同一个Allocation用于输入和输出。例如，**模糊**滤镜就不可以这样，因为它会在读取其他像素进行模糊处理时重写模糊的像素，从而导致奇怪的视觉伪影。
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Speaking of reuse, it is good practice to reuse RenderSript objects (that is
    the RS context object, Intrinsics, Kernels, and so on) between executions. This
    is even more important if you repeatedly perform a computation, such as processing
    images from the camera.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 说到复用，在执行之间重复使用RenderSript对象（即RS上下文对象，Intrinsics，Kernels等）是一种好的实践。如果你反复执行一个计算，比如处理摄像头拍摄的图像，这一点尤为重要。
- en: 'Memory is an important aspect of RenderScript performance. Used badly, it can
    decrease efficiency. In our project, we provided a pointer to the Allocations
    we created it. This means that the Allocations we created in our project are "backed"
    with native memory, in our case, the bitmap content:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是RenderScript性能的一个重要方面。如果使用不当，它可能会降低效率。在我们的项目中，我们提供了一个指向我们创建的Allocations的指针。这意味着我们项目中创建的Allocations是用本地内存“支持”的，在我们的例子中，就是位图内容：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, data can also be copied before processing from the input memory area
    into the allocation using the `copy***From()` methods, which are the pendant of
    the `copy***To()` methods. This is especially useful with the Java binding side,
    which does not always allow the use of "backed Allocation". The NDK binding is
    more flexible and input data copying can be avoided most of the time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以在处理前使用`copy***From()`方法将数据从输入内存区域复制到分配的内存中，这些方法是`copy***To()`方法的对应方法。这对于Java绑定来说特别有用，因为Java绑定并不总是允许使用“支持分配”。NDK绑定更加灵活，大多数时候可以避免输入数据的复制。
- en: RenderScript provides others mechanisms to communicate data from a script. The
    first ones are the methods `rsSendToClient()` and `rsSendToClientBlocking()`.
    They allow a script to communicate a "command", optionally with some data, to
    the calling side. The latter method is obviously a bit more dangerous in terms
    of performances, and should be avoided.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript提供了其他机制来从脚本中传递数据。第一种是`rsSendToClient()`和`rsSendToClientBlocking()`方法。它们允许脚本向调用方传递一个“命令”，可选地带有一些数据。后一种方法在性能方面显然有点危险，应尽量避免使用。
- en: Data can also be communicated through pointers. Pointers are dynamic memory
    that allows bi-directional communication between the Kernel and the caller. As
    indicated previously, they are reflected in the generated classes with a method
    prefixed with `bind_`. The appropriate getters and setters should be generated
    in the reflected layer at compile time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以通过指针进行传递。指针是动态内存，允许Kernel和调用者之间进行双向通信。如前所述，它们在生成的类中以`bind_`前缀的方法反映出来。在编译时，应该在反射层生成适当的获取器和设置器。
- en: However, the NDK RenderScript framework does not reflect structures declared
    in RenderScript files yet. So declaring a pointer to `struct` defined in a script
    file will not work for now. Pointers to primitive types work using Allocations
    though. Thus, expect annoying limitations on the NDK side on this subject.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，NDK RenderScript框架目前还无法反映在RenderScript文件中声明的结构。因此，现在还不能声明指向在脚本文件中定义的`struct`的指针。不过，使用Allocations，基本类型的指针是可以工作的。因此，在这个问题上，预计NDK端会有一些令人讨厌的限制。
- en: Let's end on the subject of memory by saying that in case you need more than
    one input or output Allocations for a script, there is a solution, an `rs_allocation`,
    which represents an Allocation reflected through a getter and setter. You can
    have as many of them as you want. Then, you can access dimensions and elements
    through the `rsAllocationGetDim*()`, `rsGetElementAt*()`, `rsSetElementAt*()`
    methods, and so on.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束内存这一主题之前，如果你在脚本中需要不止一个输入或输出分配（Allocation），有一个解决方案，即`rs_allocation`，它通过getter和setter反映一个分配（Allocation）。你可以有任意多个。然后，你可以通过`rsAllocationGetDim*()`，`rsGetElementAt*()`，`rsSetElementAt*()`等方法访问尺寸和元素。
- en: 'For example, the `threshold()` method could be rewritten the following way:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`threshold()`方法可以以下列方式重写：
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that since we do not pass an input Allocation in parameter, return one
    as usual
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们没有在参数中传递输入分配（Allocation），因此像往常一样返回一个。
- en: The `for` loops are not implicit like it would be with an Allocation passed
    in parameter
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环不是隐式的，如果传递了参数中的分配（Allocation），它将是隐式的。'
- en: The `threshold()` function cannot be a Kernel root. It is perfectly possible
    to use input Allocation in conjunction with `rs_allocation` though.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold()`函数不能作为内核根。但是，完全可以通过与`rs_allocation`结合使用输入分配（Allocation）。'
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, the Kernel would be called in the following way. Note how the method
    that applies the effect is prefixed with `invoked_` (instead of `forEach_`). This
    is because the `threshold()` function is not a Kernel root:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将以下列方式被调用。注意，应用效果的方法前缀为`invoked_`（而不是`forEach_`）。这是因为`threshold()`函数不是内核的根函数：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RenderScript语言功能的更多信息，请查看[http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html)。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced RenderScript, an advanced technology to parallelize
    intensive computation tasks. More specifically, we saw how to use predefined RenderScript
    built-in Intrinsics, which are currently mainly dedicated to image processing.
    We also discovered how to implement our own Kernels with the RenderScript custom
    language inspired by C. Finally, we saw an example of an Intrinsics and Kernels
    combination to perform computations that are more complex.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了RenderScript，这是一种用于并行化密集计算任务的高级技术。更具体地说，我们了解了如何使用预定义的RenderScript内置Intrinsics，这些Intrinsics目前主要用于图像处理。我们还发现如何使用受C语言启发的RenderScript自定义语言实现我们自己的内核（Kernel）。最后，我们看到了一个Intrinsics和Kernels结合的例子，以执行更复杂的计算。
- en: RenderScript is available from either the Java or the native side. However,
    let's be clear, apart from the exception of Allocations backed by memory buffers
    (a rather important feature for performance though), RenderScript is still more
    useable through its Java API. Grouping is not available, `struct` is not reflected
    yet, and some other features are still buggy (for example YUV Intrinsics).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript可以从Java或原生侧使用。但是，让我们明确一点，除了由内存缓冲区支持的分配（Allocation）（这是一个相当重要的性能特性）之外，RenderScript仍然更多地通过其Java
    API使用。分组不可用，`struct`尚未反映，还有一些其他特性仍然存在问题（例如YUV Intrinsics）。
- en: Indeed, RenderScript aims at giving tremendous computing power to the developers
    who neither have the time nor the knowledge to follow the native path. Thus, the
    NDK is not well-served yet. Although that will probably change in the future,
    you should be ready to keep at least parts of your RenderScript code on the Java
    side.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，RenderScript旨在为那些没有时间或知识走原生开发路径的开发者提供巨大的计算能力。因此，NDK目前并没有得到很好的支持。尽管这可能会在未来改变，但你应该准备好至少将部分RenderScript代码保留在Java端。
