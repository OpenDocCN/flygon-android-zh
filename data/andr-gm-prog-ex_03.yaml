- en: Chapter 3. Tappy Defender – Taking Flight
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章．Tappy Defender – 飞翔之旅
- en: We are now ready to quickly add a lot of new objects and some features as well.
    By the end of this chapter, we will be really close to a playable game. We will
    detect the player touching the screen, so he can control the spaceship. We will
    add virtual boosters to our `SpaceShip` class to move the ship up and down and
    increase the speed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备快速添加许多新对象和一些功能。在本章结束时，我们将非常接近一个可玩的游戏。我们将检测玩家触摸屏幕，这样他就可以控制飞船。我们将在`SpaceShip`类中添加虚拟推进器，以使飞船上下移动并增加速度。
- en: We will then detect the resolution of the Android device and use it to do things
    like prevent the player boosting off the screen, and to detect when our enemies
    need to respawn.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检测安卓设备的分辨率，并利用它来执行诸如防止玩家从屏幕边缘飞出，以及检测我们的敌人何时需要重生等操作。
- en: We will create a new `EnemyShip` class, which will represent the suicidal enemies.
    We will also see how we can easily spawn and then control them without changing
    any of the logic from the control part of our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`EnemyShip`类，它将代表自杀式的敌人。我们还将看到如何轻松生成并控制它们，而无需更改我们代码中控制部分的任何逻辑。
- en: We will add a scrolling effect by adding a `SpaceDust` class and spawning dozens
    of them to make it look like the player is whizzing through space.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加一个`SpaceDust`类并生成数十个它们来添加滚动效果，使玩家看起来像是在太空中飞速穿梭。
- en: Finally, we will learn about, and implement, collision detection so we know
    when our player has been hit by an enemy, as well as look at a graphical trick
    to help us with debugging our collision detection code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将了解并实现碰撞检测，以便我们知道玩家何时被敌人击中，同时也会看看一个图形技巧，以帮助我们在调试碰撞检测代码时。
- en: Controlling the spaceship
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制飞船
- en: We have our player's spaceship floating aimlessly on the screen starting 50
    pixels from the left and 50 pixels from the top and drifting slowly to the right.
    Now, we can give the player the power to control the spaceship.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让玩家的飞船在屏幕上毫无目的地漂浮，从左边缘和顶部边缘各50像素开始，缓缓向右漂移。现在，我们可以让玩家控制飞船。
- en: Remember the design for the controls is a one finger tap and hold to boost,
    release to quit boosting and decelerate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，控制设计是一个单指点击并长按加速，释放后停止加速并减速。
- en: Detecting touches
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测触摸
- en: The `SurfaceView` class that we extended for our view is perfect for handling
    screen touches.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展的用于视图的`SurfaceView`类非常适合处理屏幕触摸。
- en: 'All we need to do is override the `onTouchEvent` method within our `TDView`
    class. Let''s see the code in full, and then we can examine it more closely to
    make sure we understand what is going on. Enter this method in the `TDView` class
    and import the necessary classes in the usual way. I have highlighted the parts
    of the code that we will be customizing later:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是在我们`TDView`类中重写`onTouchEvent`方法。让我们先看看完整的代码，然后我们可以更仔细地检查以确保我们理解正在发生的事情。在`TDView`类中输入此方法，并以通常的方式导入必要的类。我已经突出了我们稍后将自定义的代码部分：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is how the `onTouchEvent` method works so far. The player touches the screen;
    this can be any kind of contact at all. It could be a swipe, a pinch, multiple
    fingers, and so on. A detailed message is sent to the `onTouchEvent` method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到目前为止`onTouchEvent`方法的工作方式。玩家触摸屏幕；这可以是任何一种接触。它可能是滑动，捏合，多个手指等。一条详细的信息被发送到`onTouchEvent`方法。
- en: The details of the event are contained in the `MotionEvent` class parameter,
    as we can see in our code. The `MotionEvent` class holds lots of data. It knows
    how many fingers were placed on the screen, the coordinates of each, and if any
    gestures were made as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '事件详细信息包含在`MotionEvent`类参数中，正如我们在代码中所看到的。`MotionEvent`类包含大量数据。它知道有多少个手指放在屏幕上，每个手指的坐标，以及是否还进行了任何手势。 '
- en: As we are implementing a simple tap and hold to boost, release to stop boosting
    control scheme; we can simply switch using the `motionEvent.getAction() & MotionEvent.ACTION_MASK`
    condition and cater for just two of many possible different cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了一个简单的点击并长按加速，释放停止加速的控制方案；我们可以通过使用`motionEvent.getAction() & MotionEvent.ACTION_MASK`条件简单地切换，只需处理许多可能不同情况中的两种。
- en: The case `MotionEvent.ACTION_UP:` will, as the name suggests, tell us when the
    player removes a finger from the screen. Then, perhaps unsurprisingly, case `MotionEvent.ACTION_DOWN:`
    tells us if the player places a finger on the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionEvent.ACTION_UP:`的情况，顾名思义，会告诉我们在玩家将手指从屏幕上移开时。然后，不出所料，`MotionEvent.ACTION_DOWN:`的情况会告诉我们在玩家将手指放在屏幕上时。'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'What we can find out through the `MotionEvent` class is quite vast. Why not
    take a look at the full scope of its potential here: [http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html).
    We will also explore this class further in the next project that we start to build
    in [Chapter 5](ch05.html "Chapter 5. Platformer – Upgrading the Game Engine"),
    *Platformer – Upgrading the Game Engine*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`MotionEvent`类我们可以了解到的内容非常丰富。何不在这里看看它的全部潜力：[http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html)。在接下来的项目中，我们也会在[第5章](ch05.html
    "第5章.平台游戏——升级游戏引擎")《平台游戏——升级游戏引擎》中进一步探索这个类。
- en: Adding boosters to the spaceship
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为飞船添加助推器
- en: 'Now, all we need to do is think about how we will use these events to control
    the spaceship. First of all, the spaceship needs to know if it is boosting or
    not boosting. This suggests a Boolean member variable. Add this code just after
    the class declaration in the `PlayerShip` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要考虑如何使用这些事件来控制飞船。首先，飞船需要知道它是否正在加速。这需要一个布尔成员变量。在`PlayerShip`类的类声明后立即添加以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then need to initialize it when a `PlayerShip` object is created. So add
    this to the `PlayerShip` constructor:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在创建`PlayerShip`对象时初始化它。在`PlayerShip`构造函数中添加以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we need to let the `onTouchEvent` method toggle `boosting` between true
    and false, boosting and not boosting. Add these methods to the `PlayerShip` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让`onTouchEvent`方法在`boosting`的真和假之间切换，以控制飞船的加速和停止加速。在`PlayerShip`类中添加以下方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can call these public methods from our `onTouchEvent` method to control
    the state of whether the spaceship is boosting or not. Add this new code in the
    `onTouchEvent` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从`onTouchEvent`方法中调用这些公共方法，以控制飞船是否正在加速的状态。在`onTouchEvent`方法中添加以下新代码：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, our view is talking to our model; all we need to do is make the boosting
    variable do something depending on which state it is in. The logical place for
    this code will be the `PlayerShip` class's `update` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的视图与模型进行了交流；我们需要做的是根据加速变量的状态让它执行不同的操作。逻辑上，这部分代码应该放在`PlayerShip`类的`update`方法中。
- en: 'We will change the `speed` variable of our spaceship based on whether the ship
    is currently boosting. At first this seems simple, but there are a few minor issues
    with just increasing the speed based on whether the ship is boosting:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据飞船当前是否正在加速来改变飞船的`speed`变量。这看起来很简单，但仅仅基于飞船是否加速来增加速度会有一些小问题：
- en: One problem is that the `update` method is called 60 times every second. So,
    it wouldn't take much boosting to have the ship flying at ridiculous speeds. We
    need to constrain the ship's speed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题是`update`方法每秒被调用60次。因此，不需要太多加速，飞船就会以荒谬的速度飞行。我们需要限制飞船的速度。
- en: Another problem is that our spaceship will rise up the screen when boosting,
    and there is nothing to stop it whizzing straight off the top of the screen, never
    to be seen again. We need to constrain the ship's *x* and *y* coordinates within
    the screen.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个问题在于，当飞船加速时，它将向屏幕上方移动，而没有任何东西能阻止它直接飞出屏幕顶部，永远消失不见。我们需要将飞船的*x*和*y*坐标限制在屏幕内。
- en: When the ship is not boosting and the speed steadily returns to zero, what will
    bring the ship back down again? We will need a simple gravity physics simulation.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当飞船不加速且速度逐渐降为零时，是什么让飞船再次降下来？我们需要一个简单的重力物理模拟。
- en: To solve these three problems, we can add code to our `PlayerShip` class. However,
    before we do this, a quick word about gameplay balance. The code which we will
    see very soon uses different integer values, for example, we initialize `GRAVITY`
    to `-12` and `MAX_SPEED` to `20`. These numbers have no bearing in reality!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这三个问题，我们可以在`PlayerShip`类中添加代码。但在我们这样做之前，先简单谈谈游戏平衡。我们很快就会看到的代码使用了不同的整数值，例如，我们将`GRAVITY`初始化为`-12`，将`MAX_SPEED`初始化为`20`。这些数字在现实中没有任何依据！
- en: They are simply the arbitrary numbers that make the gameplay balanced. Feel
    free to play with all these arbitrary figures to make the game harder, easier,
    or even impossible. At the end of [Chapter 4](ch04.html "Chapter 4. Tappy Defender
    – Going Home"), *Tappy Defender – Going Home*, we will look more closely at game
    iteration and look again at difficulty and balance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数值只是为了使游戏玩法保持平衡。随意调整这些任意数值，让游戏变得更容易或更难，甚至不可能完成。在[第4章](ch04.html "第4章. Tappy
    Defender——回家")《Tappy Defender——回家》的最后，我们将更详细地探讨游戏迭代，并再次审视难度和平衡。
- en: 'With three of our previously stated problems in mind, add the following member
    variables just after the class declaration in the `PlayerShip` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们之前提出的三个问题，请在`PlayerShip`类声明后的类声明后立即添加以下成员变量：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we made a start to solve our three problems, we can add code to our `PlayerShip`
    class''s `update` method. We will delete the one line of code, we put in there
    in the previous chapter. That was just there to take a quick look at our ship
    in action. Enter the new code of our `PlayerShip` class''s `update` method. We
    will take a closer look afterward:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经开始了解决我们三个问题的过程，我们可以在`PlayerShip`类的`update`方法中添加代码。我们将删除之前章节中放入的那行代码。那只是为了快速查看我们的飞船的行动。输入我们`PlayerShip`类的`update`方法的新代码。之后我们将更详细地查看：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order from the top of the previous block of code, we are increasing and decreasing
    the speed variable by apparently arbitrary amounts, each frame of the game, based
    on if the ship is boosting or not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前代码块的顶部开始，我们根据飞船是否在加速，每一帧游戏都在增加或减少速度变量，这些数值看似是任意的。
- en: We then constrain the speed of the ship to a maximum of 20 and a minimum of
    1, as specified by the variables we added earlier. With the line `y -= speed +
    GRAVITY`, we move the graphic on screen either up or down based on speed and gravity.
    The apparently arbitrary values for `GRAVITY` and `MAX_SPEED` work nicely to allow
    the player to awkwardly and precariously bounce along through space.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将飞船的速度限制在最大20和最小1之间，这是我们之前添加的变量所指定的。通过`y -= speed + GRAVITY`这行代码，我们根据速度和重力将屏幕上的图形向上或向下移动。`GRAVITY`和`MAX_SPEED`的看似任意的值很好地让玩家能够笨拙且不稳定地在太空中弹跳。
- en: Finally, we stop the ship from ever disappearing off the screen by making sure
    the ship graphic is never drawn beyond `maxY` and `minY`. You have probably noticed
    that, as of yet, we haven't initialized `maxY` and `minY`. Furthermore, what will
    we initialize them to anyway as many Android devices have vastly different screen
    resolutions?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保飞船图形永远不会超出屏幕，也就是确保飞船图形不会超过`maxY`和`minY`。你可能已经注意到，到目前为止，我们还没有初始化`maxY`和`minY`。此外，由于许多Android设备的屏幕分辨率截然不同，我们到底要将它们初始化为多少？
- en: What we need to do is discover the resolution of the Android device at run time
    and use the information to initialize `MaxY` and `minY`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是在运行时发现Android设备的分辨率，并使用这些信息来初始化`MaxY`和`minY`。
- en: Detecting the screen resolution
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测屏幕分辨率
- en: We know that we need the maximum *y* coordinate of the player's screen. Later
    in the project when we start adding backgrounds and enemy ships, we will realize
    that we also need the maximum *x* coordinate as well. With this in mind, let's
    see how we can get this information and make it available to the `PlayerShip`
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要玩家屏幕的最大*y*坐标。稍后，在项目中添加背景和敌方飞船时，我们会意识到我们也需要最大的*x*坐标。考虑到这一点，让我们看看如何获取这些信息，并将其提供给`PlayerShip`类。
- en: 'The most expedient time to detect the screen resolution is as the app is starting,
    and before our view and the model have been instantiated. This implies that our
    `GameActivity` class is a good place to do it. We will now add code to the `onCreate`
    method of the `GameActivity` class. Add this new code to the `onCreate` class,
    before the call to `new...` that creates our `TDView` object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用启动时检测屏幕分辨率最为方便，这发生在我们的视图和模型被实例化之前。这意味着我们的`GameActivity`类是进行这一操作的好地方。现在我们将在`GameActivity`类的`onCreate`方法中添加代码。在创建我们的`TDView`对象的`new...`调用之前，将以下新代码添加到`onCreate`类中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code declares and initializes an object of the `Display` type using
    `getWindowManager().getDefaultDisplay();`. Then we create a new object of type
    `Point`. The `Point` object can hold two coordinates and we then pass it as an
    argument into the `getSize` method of our new `Display` object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`getWindowManager().getDefaultDisplay();`声明并初始化了`Display`类型的对象。然后我们创建了一个`Point`类型的新对象。`Point`对象可以保存两个坐标，然后我们将其作为参数传递给新`Display`对象的`getSize`方法。
- en: 'We now have the resolution of the Android device our game is running on, neatly
    stored in `size`. Now pass this on to the parts of our code which require it.
    First, we will change the arguments we pass in the call to `new`, which initializes
    our `TDView` object. Change the call to `new` as shown next to pass in the screen
    resolution to the `TDView` constructor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将我们游戏运行的Android设备的分辨率整洁地存储在`size`中。现在，将这个信息传递给需要它的代码部分。首先，我们将改变我们传递给初始化我们的`TDView`对象的`new`调用的参数。按照如下所示更改`new`的调用，将屏幕分辨率传递给`TDView`构造函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, of course, we need to update the `TDView` constructor itself. In the
    `TDView.java` file, amend the `TDView` constructor''s signature so that the declaration
    now looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，我们需要更新`TDView`构造函数本身。在`TDView.java`文件中，修改`TDView`构造函数的签名，使得声明现在看起来像这样：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, still in the constructor, change the way we initialize the player of our
    `PlayerShip` object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构造函数中，改变我们初始化`PlayerShip`对象的玩家方式：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, we must now amend the constructor declaration within the `PlayerShip`
    class itself, to this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在必须修改`PlayerShip`类本身中的构造函数声明，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In addition, we can now initialize our `maxY` and `minY` variables within the
    `PlayerShip` constructor. Before we see the code, we need to consider exactly
    how this will work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们现在可以在`PlayerShip`构造函数内初始化我们的`maxY`和`minY`变量。在我们看到代码之前，我们需要确切地考虑这将如何工作。
- en: 'The coordinates of the bitmap that holds our spaceship graphic is drawn with
    the top-left corner at the *x = 0* and *y = 0* coordinates passed in to `drawBitmap()`
    in the `TDView` class''s `draw` method. This means that there are pixels off to
    the right and after the coordinates at which we begin to draw the ship. Take a
    look at this next image to visualize this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们太空飞船图形的位图的坐标是在`TDView`类的`draw`方法中传递给`drawBitmap()`的*x = 0*和*y = 0*坐标处绘制的。这意味着在开始绘制飞船的坐标右侧和下方有一些像素。查看下一张图片以可视化这一点：
- en: '![Detecting the screen resolution](img/B043422_03_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![检测屏幕分辨率](img/B043422_03_01.jpg)'
- en: Therefore, we must set our `minY` and `maxY` values with this in mind. As the
    image illustrates, the top pixel of the bitmap is indeed drawn exactly at the
    ships *y*. We can then be confident that `minY` should be zero.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须考虑到这一点，设置我们的`minY`和`maxY`值。如图所示，位图的顶部像素确实是在船只的*y*位置精确绘制的。这样我们可以确定`minY`应该是零。
- en: The bottom of the ship, however, is drawn at *y + the height of the bitmap*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，船的底部是在*y + 位图的高度*处绘制的。
- en: 'We can now add two lines of code to our constructor to initialize these variables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在构造函数中添加两行代码来初始化这些变量：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can now run the game and test out your boosters!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行游戏并测试您的助推器了！
- en: Building the enemies
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建敌人
- en: Now that we have the tap controls implemented, it is time to add some enemies
    that the player can boost to avoid.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经实现了点击控制，现在是时候添加一些玩家可以通过助推来躲避的敌人了。
- en: This is going to be much easier than when we added our player's spaceship because
    most of what we need is in place already. All we have to do is code a class to
    represent our enemy, instantiate as many enemy objects as we need, call their
    `update` methods, and then draw them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将比我们添加玩家太空飞船时要简单得多，因为我们所需的大部分内容已经就位。我们只需编写一个类来表示我们的敌人，实例化我们需要的多个敌人对象，调用它们的`update`方法，然后绘制它们。
- en: As we will see, the `update` method for our enemy will be quite different to
    that of `PlayerShip`. It will need to handle things like simple AI to fly toward
    the player. It will also need to handle respawning when it leaves the screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，我们敌人的`update`方法与`PlayerShip`的将大不相同。它需要处理像简单的AI飞向玩家等事情。它还需要处理当它离开屏幕时的重生。
- en: Designing the enemy
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计敌人
- en: 'To begin with, create a new Java class and call it `EnemyShip`. Add these member
    variables inside the class so your new class will look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Java类，将其命名为`EnemyShip`。在类内部添加这些成员变量，这样你的新类将如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, add some getter and setter methods so that the `draw` method can access
    what it needs to draw, and where it needs to draw it. There is nothing new or
    unusual here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一些getter和setter方法，以便`draw`方法可以访问它需要绘制的内容以及需要绘制的地方。这里没有新的或异常的内容：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Spawning the enemy
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人
- en: 'Let''s implement the `EnemyShip` constructor in full. Enter the code now, and
    we will then take a closer look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完整地实现`EnemyShip`构造函数。现在输入代码，然后我们将更仔细地查看：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructors' signature is exactly that of the `PlayerShip` class. A `Context`
    class for manipulating your `Bitmap` object and `screenX` and `screenY` that hold
    the resolution of the screen.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的签名与`PlayerShip`类完全相同。一个用于操作`Bitmap`对象的`Context`类以及保存屏幕分辨率的`screenX`和`screenY`。
- en: 'Just as we did with the `PlayerShip` class, we load up an image into `Bitmap`.
    Of course, we once again need to add an image file named `enemy.png` to the `drawable`
    folder of our project. There is a neat enemy graphic in the `Chapter3/drawable`
    folder of the download bundle or you can design your own. Any size between roughly
    32 x 32 and 256 x 256 will suffice for the purposes of this game. Also, like those
    supplied, your graphics do not need to be square. We will see that our game engine
    is imperfect when it comes to how it looks on different screen sizes, and we will
    address this in the next project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`PlayerShip`类所做的那样，我们将图像加载到`Bitmap`中。当然，我们再次需要将名为`enemy.png`的图像文件添加到项目的`drawable`文件夹中。下载包的`Chapter3/drawable`文件夹中有一个整洁的敌人图形，或者你可以设计自己的图形。对于这个游戏来说，大约32
    x 32到256 x 256之间的任何尺寸都足够了。同样，你的图形也不需要是正方形。我们会看到，我们的游戏引擎在处理不同屏幕尺寸的外观时并不完美，我们将在下一个项目中解决这个问题：
- en: '![Spawning the enemy](img/B043422_03_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![生成敌人](img/B043422_03_02.jpg)'
- en: Next, we initialize `maxX`, `maxY`, `minX`, and `minY`. Although the enemies
    only move horizontally, we need the `maxY` and `minY` coordinates to make sure
    that we spawn them at a sensible height. The `maxX` coordinate will enable us
    to spawn them just off-screen horizontally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化`maxX`、`maxY`、`minX`和`minY`。尽管敌人只进行水平移动，我们需要`maxY`和`minY`坐标以确保我们以一个合理的高度生成它们。`maxX`坐标将使我们能够将它们水平地生成在屏幕之外。
- en: We create a new object of type `Random` and generate a random number between
    the values of 10 and 15\. These are the maximum and minimum speeds our enemies
    can travel at. These values are fairly arbitrary, and we might adjust them when
    we do some play-testing in [Chapter 4](ch04.html "Chapter 4. Tappy Defender –
    Going Home"), *Tappy Defender – Going Home*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类型为`Random`的新对象，并生成了一个在10到15之间的随机数。这是我们的敌人能够移动的最大和最小速度。这些值相对随意，我们在[第4章](ch04.html
    "第4章. Tappy Defender – Going Home")进行游戏测试时可能会调整它们，*Tappy Defender – Going Home*。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering how `generator.nextInt(6)+10;` comes up with a number between
    10 and 15, it is because the `6` argument causes `nextInt()` to return a number
    between 0 and 5.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇`generator.nextInt(6)+10;`是如何生成10到15之间的数字的，这是因为`6`参数导致`nextInt()`返回一个0到5之间的数字。
- en: We then set the enemy ship's *x* coordinate to screen, which spawns it on the
    far left of the screen. Actually, this spawns it off screen. However, that is
    fine because it will then emerge in to the player's view rather than just appearing
    all at once.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将敌人飞船的*x*坐标设置为屏幕，这样它就会在屏幕最左侧生成。实际上，这是在屏幕外生成的。但这没问题，因为它会逐渐进入玩家的视野，而不是一次性出现。
- en: We now generate another random number based on `maxY`—the height of the enemy
    ship bitmap `(bitmap.getHeight())`—to create a random but sensible *y* coordinate
    for our enemy ship to spawn at.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在基于`maxY`生成另一个随机数——敌人飞船位图的高度`(bitmap.getHeight())`——为我们的敌人飞船生成一个随机但合理的*y*坐标。
- en: What we need to do now is to give our enemies life by coding their update method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的是通过编写它们的更新方法给敌人赋予生命。
- en: Making the enemy think
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让敌人“思考”
- en: Now, we can handle the `EnemyShip` class's `update` method. For now, we just
    need to handle two things. First, fly the enemy toward the player's end of the
    screen. We need to take account of the enemy's speed and the player's speed to
    simulate this accurately. The reason we need to do this is because when the player
    boosts, he expects his speed to increase, and objects to rush toward him more
    quickly. However, the spaceship graphic is horizontally static.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理`EnemyShip`类的`update`方法。目前，我们只需要处理两件事。首先，让敌人向玩家端的屏幕飞行。我们需要考虑敌人的速度和玩家的速度以准确模拟这一点。我们需要这样做的原因是，当玩家加速时，他期望自己的速度会增加，物体更快地向他冲来。然而，太空船的图形是水平静止的。
- en: We can increase the rate of travel of an enemy in proportion to both the enemy's
    static and randomly generated speed at the same time as the player's dynamically
    set speed (through boosting). This will give the player a sense of speeding up
    even though the ship graphic never moves forward.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同时根据敌人的静态速度和随机生成的速度以及玩家动态设定的速度（通过加速）增加敌人移动的速度，这将给玩家一种加速的感觉，尽管飞船图形从未向前移动。
- en: The other issue is that the enemy ship will eventually fly off the screen, on
    the left-hand side. We need to detect when this happens and respawn it on the
    right-hand side with a new random *y* coordinate and a new random speed. This
    is just like we did in the constructor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题就是敌人的飞船最终会从屏幕左侧飞出。我们需要检测这种情况，并在右侧以新的随机*y*坐标和速度重生它。这与我们在构造函数中所做的一样。
- en: Finally before we get to the actual code, let's consider something. If the enemy
    is going to take note of and use the player's speed, it will need to be able to
    get it. Note that in the next block of code, the `EnemyShip` class's `update`
    method declaration has a parameter to receive the player's speed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正开始编写代码之前，先考虑一个问题。如果敌人要留意并利用玩家的速度，它需要能够获取这个速度。注意在下一个代码块中，`EnemyShip`类的`update`方法声明有一个参数用来接收玩家的速度。
- en: 'We will see how this is passed in when we add code to the `TDView` class''s
    `update` method soon. Enter the following code for the `EnemyShip` class''s `update`
    method to implement what we have just discussed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向`TDView`类的`update`方法中添加代码时，我们将会看到它是如何传递的。现在，为`EnemyShip`类的`update`方法输入以下代码，以实现我们刚才讨论的内容：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we first decreased the enemy's *x* coordinate by the player's
    speed then by the enemy's speed. As the player boosts, the enemy will fly at the
    player faster. However, if the player is not boosting then the enemy will attack
    at the speed that was previously and randomly generated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先将敌人的*x*坐标减去玩家的速度，然后减去敌人的速度。当玩家加速时，敌人会以更快的速度向玩家飞行。然而，如果玩家没有加速，那么敌人将以之前随机生成的速度攻击。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After this, we simply detected if the right-hand edge of the enemy bitmap has
    disappeared from the left-hand side of the screen. This is done by detecting if
    the `EnemyShip` class's *x* coordinate is the width of the bitmap off screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们简单地检测敌人的位图右侧是否已经从屏幕左侧消失。这是通过检测`EnemyShip`类的*x*坐标是否在屏幕外位图的宽度处完成的。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then we respawn the very same object to come at the player again. This appears
    to the player as if it is an entirely new enemy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重生同一个对象，让它再次向玩家发起攻击。这对玩家来说就像是完全新的敌人。
- en: The last three things we must do are create a new object from `EnemyShip` by
    declaring and then initializing an object. Actually, let's make three.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须做的最后三件事是声明并初始化一个来自`EnemyShip`的新对象。实际上，让我们创建三个。
- en: 'Here, were we declared our player''s ship in our `TDView.java` file, declare
    three enemy ships like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在我们`TDView.java`文件中声明玩家飞船的地方，像这样声明三个敌舰：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, in the constructor of our `TDView` class, initialize our three new enemies:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们`TDView`类的构造函数中，初始化我们的三个新敌人：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `update` method of our `TDView` class, we call each of the new object's
    `update` methods in turn. Here, we also see how we pass in the player's speed
    to each of our enemies so they can use it in their `update` methods to adjust
    speed accordingly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`TDView`类的`update`方法中，我们依次调用了每个新对象的`update`方法。在这里，我们也可以看到如何将玩家的速度传递给每个敌人，以便它们在自己的`update`方法中使用它来相应地调整速度。
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, in the `TDView` class's `draw` method, we draw our new enemies to the
    screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`TDView`类的`draw`方法中，我们在屏幕上绘制我们新的敌人。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can run the game and give this a try now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏并尝试一下这个功能。
- en: The first and most obvious problem is that the player and the enemies fly right
    through each other. We will solve this problem later in this chapter, in the *Things
    that go bump – collision detection* section. But right now, we can make our player's
    sense of immersion better by drawing a star/space dust field as a background.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最明显的问题是玩家和敌人会直接穿过对方。我们将在本章的*碰撞检测——相互碰撞的部分*解决这个问题。但现在，我们可以通过绘制星形/星际尘埃场作为背景来增强玩家的沉浸感。
- en: The thrill of flight – scrolling the background
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行的刺激——滚动背景
- en: Implementing our space dust is going to be really quick and easy. All we will
    do is create a `SpaceDust` class with very similar properties to our other game
    objects. Spawn them into the game at a random location, move them toward the player
    at a random speed, and respawn them on the far right of the screen, again with
    a random speed and *y* coordinate.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的星际尘埃将会非常快和简单。我们要做的是创建一个具有与其他游戏对象非常相似属性的`SpaceDust`类。在随机位置生成它们，以随机速度向玩家移动，并在屏幕最右侧重生它们，再次赋予它们随机的速度和*y*坐标。
- en: Then in our `TDView` class, we can declare a whole array of these objects, update,
    and draw them each frame.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的`TDView`类中，我们可以声明一个这些对象的整个数组，每一帧更新并绘制它们。
- en: 'Create a new class and call it `SpaceDust`. Now enter this code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，并将其命名为`SpaceDust`。现在输入此代码：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is what is happening in the `SpaceDust` class. At the top of the previous
    block of code, we declare our usual speed and maximum and minimum variables. They
    will allow us to detect when the `SpaceDust` object leaves the left of the screen
    and needs respawning on the right, and provide sensible bounds for the height
    at which we respawn the object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SpaceDust`类中发生的事情。在上一代码块的顶部，我们声明了通常的速度和最大/最小变量。它们将使我们能够检测到`SpaceDust`对象离开屏幕左侧并需要在右侧重新生成时，并为重新生成对象的高度提供合理的边界。
- en: Then inside the `SpaceDust` constructor, we initialize the `speed`, `x`, and
    `y` variables with random values, but within the bounds set by the maximum and
    minimum variables we just initialized.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`SpaceDust`构造函数中，我们用随机值初始化`speed`、`x`和`y`变量，但要在我们刚刚初始化的最大和最小变量设定的范围内。
- en: Then we implement the `SpaceDust` class's `update` method, which moves the object
    to the left based on the speed of the object and the player, then checks if the
    object has flown of the left-hand edge of the screen and respawns it with random
    but appropriate values if it has.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现了`SpaceDust`类的`update`方法，它根据对象和玩家的速度将对象向左移动，然后检查对象是否已经飞出屏幕左侧边缘并在必要时使用随机但适当的值重新生成它。
- en: At the bottom, we provide two getter methods so that our `draw` method knows
    where to draw each speck of dust.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们提供了两个getter方法，以便我们的`draw`方法知道在哪里绘制每一粒尘埃。
- en: 'Now, we can create an `ArrayList` object to hold all our `SpaceDust` objects.
    Declare it just under the declaration of the other game objects near the top of
    the `TDView` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`ArrayList`对象来保存所有的`SpaceDust`对象。在`TDView`类顶部声明其他游戏对象的地方下面声明它：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `TDView` constructor, we can initialize a whole bunch of the `SpaceDust`
    objects using a `for` loop and then stash them into the `ArrayList` object:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TDView`构造函数中，我们可以使用`for`循环初始化一堆`SpaceDust`对象，然后将它们放入`ArrayList`对象中：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We create forty specks of dust in total. Each time through the loop, we create
    a new speck of dust and the `SpaceDust` constructor assigns it a random location
    and a random speed. We then put the `SpaceDust` object into our `ArrayList` object
    with `dustList.add(spec);`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共创建了四十粒尘埃。每次通过循环，我们创建一粒新的尘埃，`SpaceDust`构造函数为其分配一个随机位置和一个随机速度。然后，我们使用`dustList.add(spec);`将`SpaceDust`对象放入我们的`ArrayList`对象中。
- en: 'Next, we jump to our `TDView` class''s `update` method and use an enhanced
    `for` loop to call `update()` on each of our `SpaceDust` objects:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们跳转到`TDView`类的`update`方法，并使用增强的`for`循环来调用每个`SpaceDust`对象的`update()`：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that we passed in the player speed so that the dust increases and decreases
    its speed relative to the player's speed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们传入了玩家速度，以便尘埃相对于玩家的速度增加和减少其速度。
- en: Now to draw all our space dust, we loop through our `ArrayList` object and draw
    a speck at a time. Of course, we add the code to our `TDView` class's `draw` method,
    but we must make sure to draw the space dust first so it appears behind the other
    game objects. In addition, we have an extra line to switch pixel color to white
    before using the `drawPoint` method of our `Canvas` object to plot a single pixel
    for each `SpaceDust` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要绘制所有的空间尘埃，我们遍历`ArrayList`对象一次绘制一粒尘埃。当然，我们将代码添加到我们的`TDView`类的`draw`方法中，但我们必须确保首先绘制空间尘埃，使其出现在其他游戏对象后面。此外，我们在使用我们的`Canvas`对象的`drawPoint`方法为每个`SpaceDust`对象绘制单个像素之前，添加了一行额外的代码以切换像素颜色为白色。
- en: 'In the `draw` method of the `TDView` class, add this code to draw our dust:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TDView`类的`draw`方法中，添加此代码来绘制我们的尘埃：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only new thing here is the `canvas.drawpoint...` line of code. Apart from
    drawing bitmaps to the screen, the `Canvas` class allows us to draw primitives,
    like points and lines, as well as things like text and shapes. We will use these
    features when drawing a HUD for our game in [Chapter 4](ch04.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一新事物是`canvas.drawpoint...`这行代码。除了向屏幕绘制位图，`Canvas`类还允许我们绘制诸如点、线这样的基本图形，以及文本和形状等。在[第4章](ch04.html
    "第4章. Tappy Defender – Going Home")，*Tappy Defender – Going Home*中绘制游戏HUD时，我们将使用这些功能。
- en: 'Why not run the app and check out how much neat stuff we have implemented?
    In this screenshot, I have temporarily increased the number of the `SpaceDust`
    objects to `200`, just for fun. You can also see that we have enemies drawn, attacking
    at a random *y* coordinate with random speed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 何不运行这个应用程序，看看我们已经实现了多少整洁的功能？在这张截图中，我临时将`SpaceDust`对象的数量增加到`200`，仅供娱乐。你还可以看到我们已经绘制了敌人，它们在随机的*y*坐标以随机速度攻击：
- en: '![The thrill of flight – scrolling the background](img/B043422_03_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![飞行的刺激——滚动背景](img/B043422_03_03.jpg)'
- en: Things that go bump – collision detection
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测那些事
- en: Collision detection is quite a broad subject. Throughout the three projects
    in this book, we will use a whole range of different ways to detect when things
    collide.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测是一个相当广泛的主题。在本书的三个项目中，我们将使用各种不同的方法来检测物体何时发生碰撞。
- en: So, here is a quick look at our options for collision detection, and in which
    circumstances different methods may be appropriate.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里快速了解一下我们进行碰撞检测的选择，以及不同方法在哪些情况下可能适用。
- en: Essentially, we just need to know when certain objects from our game touch other
    objects. We can then respond to that event by exploding, reducing shields, playing
    a sound, or whatever is appropriate. We need a broad understanding of our different
    options so we can make the right decisions in any particular game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们只需要知道游戏中某些物体何时接触到其他物体。然后，我们可以通过爆炸、减少护盾、播放声音等方式对此事件做出反应，或者采取任何适当的措施。我们需要广泛了解不同的选择，这样我们才能在任何特定游戏中做出正确的决定。
- en: Collision detection options
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测选项
- en: First of all, here are a few of the different mathematical calculations we can
    utilize and when they may be useful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一些不同的数学计算方法我们可以利用，以及它们可能在什么情况下有用。
- en: Rectangle intersection
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形相交
- en: 'This type of collision detection is really straightforward. We draw an imaginary
    rectangle; we can call it a hitbox or bounding rectangle, around the objects we
    want to test for collision. Then, test to see if they intersect. If they do, we
    have a collision:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碰撞检测方法非常直观。我们围绕想要检测碰撞的物体画一个假想的矩形，我们可以称之为命中框或边界矩形。然后，检测它们是否相交。如果相交，那么就发生了碰撞：
- en: '![Rectangle intersection](img/B043422_03_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![矩形相交](img/B043422_03_04.jpg)'
- en: Where the hitboxes intersect, we have a collision. As we can see from the previous
    image, this is far from perfect. However, in some situations, it is sufficient.
    To implement this method, all we need to do is test for the intersection using
    the *x* and *y* coordinates of both objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 命中框相交的地方，我们称之为碰撞。从前面的图片可以看出，这种方法远非完美。然而，在某些情况下，它已经足够了。要实现这个方法，我们只需要使用两个物体的*x*和*y*坐标来检测它们是否相交。
- en: Don't use the following code. It is for demonstration purposes only.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用下面的代码。它仅用于演示目的。
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code assumes we have a `getHitbox` method that returns the left
    and right *x* coordinates as well as the top and bottom *y* coordinates of the
    given object. In the aforementioned code, we first check to see if the *x* axes
    overlap. If they don't, then there is no point going any further. If they do,
    then check the *y* axes. If they don't, it could have been an enemy whizzing by
    above or below. If they overlap on the *y* axis as well, then we have a collision.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设我们有一个`getHitbox`方法，它返回给定物体的左右*x*坐标以及上下*y*坐标。在上述代码中，我们首先检查*x*轴是否重叠。如果没有，那么就没有继续的必要了。如果它们在*x*轴上重叠，那么检查*y*轴。如果它们在*y*轴上也没有重叠，那么可能是敌人从上方或下方飞过。如果它们在*y*轴上也重叠，那么我们就有了碰撞。
- en: Note that we can check the *x* and *y* axis in either order as long as we check
    them both.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以先检查*x*轴或*y*轴，只要两个轴都检查了即可。
- en: Radius overlapping
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半径重叠
- en: This method is also checking to see if two hitboxes intersect with each other,
    but as the title suggests, it does so using circles instead. There are obvious
    advantages and disadvantages. Mainly that this works well with shapes more circular
    in nature and less well with elongated shapes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法同样用于检测两个命中框是否相互相交，但正如标题所示，它使用圆形而非矩形。这有明显的优缺点。主要是这种方法对于更接近圆形的形状效果很好，对于细长形状则效果不佳。
- en: '![Radius overlapping](img/B043422_03_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![半径重叠](img/B043422_03_05.jpg)'
- en: From the previous image, it is easy to see how the radius overlapping method
    is inaccurate for these particular objects and not hard to imagine how for a circular
    object like a ball it would be perfect.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图片中，我们可以很容易地看出半径重叠方法对于这些特定物体是如何不精确的，也不难想象对于一个圆形物体比如球来说，它将是完美的。
- en: Here is how we can implement this method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何实施这种方法。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code is for demonstration purposes only.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码仅用于演示目的。
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code again makes some assumptions. Like we have a `getHitBox` method that
    can return the radius as well as the center *x* and *y* coordinates. Furthermore,
    because the static `Math.sqrt` method takes and returns a variable of type `double`,
    we will need to start working with different types in our `SpaceShip` and `EnemyShip`
    classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次做出了一些假设。比如我们有一个 `getHitBox` 方法，它可以返回半径以及中心的 *x* 和 *y* 坐标。此外，因为静态的 `Math.sqrt`
    方法接收并返回一个 `double` 类型的变量，我们将需要在 `SpaceShip` 和 `EnemyShip` 类中开始使用不同的类型。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the way we initialize distance: `Math.sqrt(distanceX * distanceX + distanceY
    * distanceY);` looks a little confusing, it is simply using Pythagoras'' theorem
    to get the length of the hypotenuse of a triangle which is equal in length to
    a straight line drawn between the centers of the two circles. In the last line
    of our solution, we test if `distance < ship.getHitBox.radius + enemy.getHitBox.radius`,
    then we can be certain that we must have a collision. That is because if the center
    points of two circles are closer than the combined length of their radii, they
    must be overlapping.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们初始化距离的方式：`Math.sqrt(distanceX * distanceX + distanceY * distanceY);` 让人有些迷惑，它实际上只是使用了勾股定理来获取一个直角三角形的斜边长度，这个长度等于两个圆心之间直线距离的长度。在我们解决方案的最后一步，我们测试
    `distance < ship.getHitBox.radius + enemy.getHitBox.radius`，这样我们可以确定一定发生了碰撞。这是因为如果两个圆的中心点比它们的半径之和还要近，那么它们一定发生了重叠。
- en: The crossing number algorithm
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉数算法
- en: 'This method is mathematically more complicated. However, as we will see in
    our third and final project, it is perfect for detecting when a point intersects
    a convex polygon:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在数学上更为复杂。然而，正如我们将在第三个也是最后一个项目中看到的，它非常适合检测一个点是否与凸多边形相交：
- en: '![The crossing number algorithm](img/B043422_03_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![交叉数算法](img/B043422_03_06.jpg)'
- en: This is perfect for an Asteroids clone, and we will explore this method more
    as well as see it in action in our final project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合制作一个《小行星》克隆游戏，我们将在最终项目中进一步探索这种方法，并看到它的实际应用。
- en: Optimizations
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: As we have seen, the different collision detection methods can have at least
    two problems depending on which method you use in which situation. The problems
    are lack of accuracy and drain on CPU cycles.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，不同的碰撞检测方法至少可以根据你在哪种情况下使用哪种方法而有至少两个问题。这些问题是缺乏精确度和对CPU周期的消耗。
- en: Multiple hitboxes
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个碰撞箱
- en: The first problem, a lack of accuracy, can be solved by having multiple hitboxes
    per object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题，精确度不足，可以通过每个对象具有多个碰撞箱来解决。
- en: We simply add the required number of hitboxes to our game object to most effectively
    *wrap* it, and then perform the same rectangle intersection code on each in turn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需向游戏对象添加所需数量的碰撞箱，以最有效的方式*包装*它，然后依次对每个执行相同的矩形相交代码。
- en: Neighbor checking
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 邻居检查
- en: This method allows us to only check objects that are in the approximate same
    area as each other. It can be achieved by checking which neighborhood of our game
    a given two objects are in, and then only performing the more CPU intensive collision
    detection if there is a realistic chance that a collision could occur.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们只检查那些彼此在近似相同区域内的对象。这可以通过检查我们的游戏中的给定两个对象在哪个邻域内，并且只有在有可能发生碰撞的情况下，才执行更耗CPU的碰撞检测来实现。
- en: Suppose we have 10 objects that each need to be checked against each other,
    then we need to perform 10 squared (100) collision checks. If we do neighbor checking
    first, we can significantly reduce this number. In the very hypothetical situation
    in the diagram, we would only need to do an absolute maximum of 11 collision checks,
    instead of 100, for our 10 objects, if we first check to see if objects share
    the same sector.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有10个对象，每个对象都需要与其他对象进行检查，那么我们需要执行10的平方（100）次碰撞检查。如果我们首先进行邻居检查，我们可以显著减少这个数字。在图表中非常假设的情况下，如果我们首先检查对象是否共享同一个区域，那么对于10个对象，我们最多只需要执行11次碰撞检查，而不是100次。
- en: '![Neighbor checking](img/B043422_03_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![邻居检查](img/B043422_03_07.jpg)'
- en: Implementing this in code can be as simple as having a sector member variable
    for each game object, then looping through the list of objects and just checking
    if they are in the same sector.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现这一点可以很简单，即为每个游戏对象提供一个区域成员变量，然后遍历对象列表，仅检查它们是否在同一个区域。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will use all these options and optimizations over the course of our three
    game projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的三个游戏项目中，我们将使用所有这些选项和优化。
- en: Best options for Tappy Defender
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于 Tappy Defender 的最佳选项
- en: Now that we know our collision detection options, we can decide the best course
    of action in our current game. All our ships are approximately rectangular (or
    square), there are few or no extremities on any of them, and we only have one
    object were we really care about a collision (with all the others).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了碰撞检测的选项，我们可以决定在我们当前游戏中采取的最佳行动。我们所有的飞船都近似于矩形（或正方形），它们上面很少有或没有突出部分，而且我们只有一个真正关心与其他物体发生碰撞的对象。
- en: This tends to suggest that we can use a single rectangular hitbox for the player
    and the enemy and perform purely corner aligned, global collision detection. If
    you're disappointed that we are going for the easy option, then you will be pleased
    to hear we will be getting into all the fancier techniques over the next two projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这往往建议我们可以为玩家和敌人使用单一的矩形碰撞箱，并执行纯角对齐的全局碰撞检测。如果你对我们选择简单的方法感到失望，那么你将会很高兴听到在接下来的两个项目中，我们将要研究所有更高级的技术。
- en: To make life even easier, the Android API has a handy the `Rect` class that
    can not only represent our hitboxes, but also has a neat `intersects` method that
    basically does the same thing as rectangle intersection collision detection. Let's
    think about how to add collision detection to our game.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活更加便捷，Android API 有一个方便的`Rect`类，它不仅可以表示我们的碰撞箱，而且还有一个整洁的`intersects`方法，基本上与矩形相交碰撞检测相同。让我们考虑如何为我们的游戏添加碰撞检测。
- en: 'First, all of our enemies and our player ship are going to need a hitbox. Add
    this code to declare a new `Rect` member called `hitbox`. Do this in both the
    `PlayerShip` and `EnemyShip` class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的所有敌人和玩家飞船都需要一个碰撞箱。添加这段代码来声明一个名为`hitbox`的新`Rect`成员。在`PlayerShip`和`EnemyShip`类中都这样做：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Important!**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要！**'
- en: Be sure to do the previous step and the next three blocks of code for both the
    `EnemyShip` class as well as the `PlayerShip` class. I will remind you each time
    but just thought it worth mentioning beforehand as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为`EnemyShip`类和`PlayerShip`类都完成上一步和接下来的三个代码块。我每次都会提醒你，但觉得还是提前提一下比较好。
- en: 'Now, we need to add a getter method to the `PlayerShip` class and the `EnemyShip`
    class. Add this code to both classes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向`PlayerShip`类和`EnemyShip`类添加一个获取器方法。将此代码添加到两个类中：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And next, we need to make sure we initialize our hitboxes in both constructors.
    Make sure to enter the code right at the end of the constructor:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保在两个构造函数中都初始化我们的碰撞箱。确保在构造函数的最后输入代码：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need to make sure the hitboxes are kept up-to-date with the coordinates
    of our enemies and our player. The best place to do this is the `update` method
    of the enemy/player ships. The next block of code will update the hitboxes with
    the ship''s current coordinates. Be sure to add this block of code at the very
    end of the `update`() methods so that the hitbox is updated with the coordinates
    after the `update` methods have done their adjustments. Again, add it to both
    `PlayerShip` and `EnemyShip`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保碰撞箱与我们的敌人和玩家的坐标保持最新。做这件事最好的地方是敌舰/玩家飞船的`update`方法。下一代码块将使用飞船的当前坐标更新碰撞箱。确保将此代码块添加到`update()`方法的最后，以便在`update`方法进行调整后，用坐标更新碰撞箱。同样，也要将其添加到`PlayerShip`和`EnemyShip`中：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our hitboxes have the coordinates that represent the outline of our bitmaps.
    This situation is nearly perfect, apart from the transparent bits around the edges.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的碰撞箱具有代表位图外框的坐标。这种情况几乎完美，除了边缘周围的透明部分。
- en: Now, we can use our hitboxes from the `TDView` class's `update` method to detect
    collisions. But first, we need to decide what we are going to do when a collision
    occurs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从`TDView`类的`update`方法中使用我们的碰撞箱来检测碰撞。但首先，我们需要决定碰撞发生时我们打算做什么。
- en: We need to refer to the rules of our game. We discussed them back at the beginning
    of [Chapter 2](ch02.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We know that the player has three shields but an enemy blows up
    after one hit. It makes sense to leave things like shields to a later part of
    the chapter, but we need some way to see our collision detection in action and
    make sure it is working.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要参考我们游戏的规则。我们在[第二章](ch02.html "第二章. Tappy Defender – 第一步")，*Tappy Defender
    – First Step*的开头讨论过它们。我们知道玩家有三个护盾，但一个敌方飞船在一次撞击后就会爆炸。将护盾等内容留到章节的后面部分是有道理的，但我们需要某种方式来查看我们的碰撞检测的实际效果并确保它正常工作。
- en: Probably, the simplest way to acknowledge a collision at this stage, will be
    to make the enemy ship disappear and respawn as normal, as if it is a totally
    new enemy. We already have a mechanism in place for this. We know that when an
    enemy moves off the left of the screen it respawns as if it is a new enemy on
    the right. All we need to do is instantly transport the enemy to a location off
    of the left of the screen and the `EnemyShip` class will do the rest.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，最简单的确认碰撞的方法可能是让敌方飞船消失并像正常情况一样重生，就像它是一艘全新的敌方飞船一样。我们已经为此建立了一个机制。我们知道，当敌方飞船从屏幕左侧移出时，它会在右侧重生，就像是一艘新的敌方飞船。我们需要做的就是立即将敌方飞船传送到屏幕左侧外的位置，`EnemyShip`类会完成其余的工作。
- en: 'We need to be able to change the `EnemyShip` object''s *x* coordinate. Let''s
    add a setter method to the `EnemyShip` class so we can manipulate the *x* coordinate
    of all our enemy spaceships. Like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够改变`EnemyShip`对象的*x*坐标。让我们为`EnemyShip`类添加一个setter方法，这样我们就可以操纵所有敌方太空飞船的*x*坐标。如下所示：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can carry out collision detection and respond when we get a hit. The
    next block of code uses the static method `Rect.intersects()` to detect a hit
    by comparing the player ship''s hitbox with each of the enemy hitboxes in turn.
    If a hit is detected, the appropriate enemy is moved off screen, ready to be respawned
    by its own `update` method in the next frame. Enter this code at the very top
    of the `TDView` class''s `update` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进行碰撞检测并在检测到碰撞时做出响应。下面这段代码使用了静态方法`Rect.intersects()`，通过比较玩家飞船的碰撞箱与每个敌方碰撞箱，来检测是否发生碰撞。如果检测到碰撞，适当的敌方飞船将被移出屏幕，准备在下一帧由其自己的`update`方法重生。将这段代码放在`TDView`类的`update`方法的最顶部：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That''s it, our collisions will now work. It may be nice to be able to really
    see what is going on. For the purposes of debugging, let''s draw a rectangle around
    all our spaceships, so we can see the hitboxes. We will use the `drawRect` method
    of the `Paint` class and pass the properties of our hitboxes in as arguments to
    define the area to draw. As you will expect, this code goes in the `draw` method.
    Note that it should go before the code that draws our ships so that the rectangles
    are drawn behind them, but after we clear the screen, as shown by the highlighted
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了，我们的碰撞现在可以工作了。能够真正看到发生的情况可能会更好。为了调试的目的，让我们在所有太空飞船周围画一个矩形，这样我们就可以看到碰撞箱了。我们将使用`Paint`类的`drawRect`方法，并将我们的碰撞箱的属性作为参数传递，以定义要绘制的区域。如您所料，这段代码应该放在`draw`方法中。请注意，它应该在绘制我们飞船的代码之前，这样矩形就在它们后面绘制了，但在我们清除屏幕的代码之后，如高亮代码所示：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now run Tappy Defender and see the game in action complete with debugging
    mode hitboxes enabled:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行Tappy Defender，开启调试模式的碰撞箱，查看游戏运行的实际效果：
- en: '![Best options for Tappy Defender](img/B043422_03_08.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Tappy Defender的最佳选项](img/B043422_03_08.jpg)'
- en: We can comment out this debugging code when we are done with it and then uncomment
    it should we need it again later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用完调试代码后，可以注释掉这段代码，如果以后需要，再取消注释。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have all the game objects that we need for a complete game. They all
    think and represent themselves internally in the model part of our design pattern.
    Furthermore, our player can at last control his spaceship, and we can detect when
    he crashes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了完成游戏所需的所有游戏对象。它们都在我们设计模式的模型部分内部进行思考和自我表示。此外，我们的玩家终于可以控制他的太空飞船了，我们也能检测到他是否发生碰撞。
- en: In the next chapter, we will put the finishing touches to our game including
    adding a HUD (Heads Up Display), implementing the game rules, adding some extra
    features, and play-testing our game to get everything in balance.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的游戏添加最后的润色，包括添加一个HUD（抬头显示），实现游戏规则，增加一些额外的功能，并通过测试游戏来使一切保持平衡。
