- en: Chapter 8. Handling Input Devices and Sensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章. 处理输入设备和传感器
- en: '*Android is all about interaction. Admittedly, that means feedback, through
    graphics, audio, vibrations, and so on. But there is no interaction without input!
    The success of today''s smartphones takes its root in their multiple and modern
    input possibilities: touchscreens, keyboard, mouse, GPS, accelerometer, light
    detector, sound recorder, and so on. Handling and combining them properly is a
    key to enrich your application and to make it successful.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android的一切都是关于互动。诚然，这意味着通过图形、音频、振动等方式进行反馈。但没有输入就没有互动！当今智能手机的成功源于它们多样化和现代的输入方式：触摸屏、键盘、鼠标、GPS、加速度计、光线检测器、声音记录器等等。正确处理和结合它们是丰富您的应用程序并使其成功的关键。*'
- en: 'Although Android handles many input peripherals, the Android NDK has long been
    very limited in its support (not to say the very least), until the release of
    R5! We can now access it directly through a native API. Examples of available
    devices are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Android处理许多输入外设，但Android NDK在其支持上长期以来非常有限（甚至可以说是最少），直到R5版本的发布！我们现在可以通过原生API直接访问。可用的设备实例包括：
- en: Keyboard, either physical (with a slide-out keyboard) or virtual (which appears
    on screen)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘，可以是物理键盘（带有滑出式键盘）或虚拟键盘（在屏幕上显示）
- en: Directional pad (up, down, left, right, and action buttons), often abbreviated
    as D-Pad.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方向键（上、下、左、右和动作按钮），通常简称为D-Pad。
- en: Trackball, optical ones included
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹球，包括光学轨迹球
- en: Touchscreen, which has made modern smart-phones successful
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏，使现代智能手机成功
- en: Mouse or Track Pad (since NDK R5, but available on Honeycomb devices only)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标或触摸板（自NDK R5起，但仅在Honeycomb设备上可用）
- en: 'We can also access hardware sensors, which are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问以下硬件传感器：
- en: Accelerometer, which measures the linear acceleration applied to a device.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计，测量施加在设备上的线性加速度。
- en: Gyroscope, which measures the angular velocity. It is often combined with the
    magnetometer to compute orientation accurately and quickly. Gyroscope has been
    introduced recently and is not available on most devices yet.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陀螺仪，测量角速度。它通常与磁力计结合使用，以准确快速地计算方向。陀螺仪是最近引入的，并且大多数设备上还不可用。
- en: Magnetometer, which gives the ambient magnetic field and consequently the cardinal
    direction.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁力计，提供环境磁场，从而得出基本方向。
- en: Light sensor, for example, to automatically adapt to screen luminosity.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光传感器，例如，自动适应屏幕亮度。
- en: Proximity sensor, for example, to detect ear distance during a call.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近距离传感器，例如，在通话期间检测耳朵的距离。
- en: 'In addition to hardware sensors, "software sensors" have been introduced with
    Gingerbread. These sensors are derived from the hardware sensor''s data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬件传感器外，Gingerbread版本还引入了“软件传感器”。这些传感器源自硬件传感器的数据：
- en: Gravity sensor, to measure the gravity direction and magnitude
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力传感器，测量重力的方向和大小
- en: Linear acceleration sensor, which measures device "movement" excluding gravity
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性加速度传感器，测量设备“移动”时排除重力的部分
- en: Rotation vector, which indicates device orientation in space
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转矢量，表示设备在空间中的方向
- en: The gravity sensor and the linear acceleration sensor are derived from the accelerometer.
    On the other hand, rotation vector is derived from the magnetometer and the accelerometer.
    Because these sensors are generally computed over time, they usually incur a slight
    delay in getting up-to-date values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重力传感器和线性加速度传感器源自加速度计。另一方面，旋转矢量由磁力计和加速度计派生。由于这些传感器通常需要计算一段时间，因此它们在获取最新值时通常会有轻微的延迟。
- en: 'To familiarize ourselves more deeply with input devices and sensors, this chapter
    teaches how to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解输入设备和传感器，本章将介绍如何：
- en: Handle screen touches
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理屏幕触摸
- en: Detect keyboard, D-Pad, and trackball events
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测键盘、方向键和轨迹球事件
- en: Turn the accelerometer sensor into a joypad
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加速度计传感器转变为游戏手柄
- en: Interacting with touch events
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与触摸事件互动
- en: The most emblematic innovation of today's smart phones is the touchscreen, which
    has replaced the now antique mice. A touchscreen detects, as its name suggests,
    touches made with fingers or styluses on a device's surface. Depending on the
    quality of the screen, several touches (also referred to as cursors in Android)
    can be handled, de-multiplying interaction possibilities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当今智能手机最具标志性的创新是触摸屏，它已经取代了现已过时的鼠标。正如其名，触摸屏可以检测手指或手写笔在设备表面的触摸。根据屏幕的质量，可以处理多个触摸（在Android中也称为光标），从而增加了互动的可能性。
- en: 'So let''s start this chapter by handling touch events in `DroidBlaster`. To
    keep the example simple, we will only handle a single "touch". The goal is to
    move the ship in the direction of touch. The farther the touch, the faster the
    ship goes. Beyond a predefined range `TOUCH_MAX_RANGE`, the ship''s speed reaches
    its speed limit, as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `DroidBlaster` 中处理触摸事件开始本章的内容。为了简化示例，我们只处理单一的“触摸”。目标是使飞船向触摸的方向移动。触摸越远，飞船移动越快。超过预定义的范围
    `TOUCH_MAX_RANGE`，飞船的速度将达到其速度极限，如下图所示：
- en: '![Interacting with touch events](img/9645OS_08_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![与触摸事件交互](img/9645OS_08_01.jpg)'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part13`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为 `DroidBlaster_Part13`。
- en: Time for action – handling touch events
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——处理触摸事件
- en: 'Let''s intercept touch events in `DroidBlaster`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `DroidBlaster` 中拦截触摸事件：
- en: 'In the same way that we created `ActivityHandler` to process application events
    in [Chapter 5](ch05.html "Chapter 5. Writing a Fully Native Application"), *Writing
    a Fully Native Application*, create `jni/InputHandler.hpp` to process input events.
    The input API is declared in `android/input.h`. Create `onTouchEvent()` to handle
    touch events. These events are packaged in an `AInputEvent` structure. Other input
    peripherals will be described later in this chapter:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如在 [第5章](ch05.html "第5章. 编写一个完全原生的应用程序")《编写一个完全原生的应用程序》中创建 `ActivityHandler`
    来处理应用程序事件一样，创建 `jni/InputHandler.hpp` 来处理输入事件。输入 API 在 `android/input.h` 中声明。创建
    `onTouchEvent()` 来处理触摸事件。这些事件被封装在 `AInputEvent` 结构中。其他输入外设将在本章后面描述：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Modify the `jni/EventLoop.hpp` header file to include and handle an `InputHandler`
    instance.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `jni/EventLoop.hpp` 头文件，包含并处理 `InputHandler` 实例。
- en: 'In a similar way, to activity events, define an internal method `processInputEvent()`,
    which is triggered by a static callback `callback_input()`:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于活动事件，定义一个内部方法 `processInputEvent()`，该方法由静态回调 `callback_input()` 触发：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to process input events in the `jni/EventLoop.cpp` source file and notify
    the associated `InputHandler`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `jni/EventLoop.cpp` 源文件中处理输入事件，并通知相关的 `InputHandler`。
- en: 'First, connect the Android input queue to `callback_input()`. The `EventLoop`
    itself (that is, `this`) is passed anonymously through the `userData` member of
    the `android_app` structure. That way, callback is able to delegate input processing
    back to our own object, that is, to `processInputEvent()`:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，将 Android 输入队列连接到 `callback_input()`。`EventLoop` 本身（即 `this`）通过 `android_app`
    结构的 `userData` 成员匿名传递。这样，回调能够将输入处理委托回我们自己的对象，即 `processInputEvent()`。
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Touchscreen events are of the type `MotionEvent` (as opposed to key events).
    They can be discriminated according to their source (`AINPUT_SOURCE_TOUCHSCREEN`)
    thanks to the Android native input API (here, `AinputEvent_getSource()`):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触摸屏事件属于 `MotionEvent` 类型（与按键事件相对）。通过 Android 原生输入 API（此处为 `AinputEvent_getSource()`），可以根据它们的来源（`AINPUT_SOURCE_TOUCHSCREEN`）来区分它们。
- en: Note
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how `callback_input()` and by extension `processInputEvent()` return an
    integer value (which is intrinsically a Boolean value). This value indicates that
    an input event (for example, a pressed button) has been processed by the application
    and does not need to be processed further by the system. For example, `1` is returned
    when the back button is pressed to stop event processing and prevent the activity
    from getting terminated.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意 `callback_input()` 以及扩展的 `processInputEvent()` 返回一个整数值（本质上是一个布尔值）。这个值表示输入事件（例如，按下的按钮）已经被应用程序处理，不需要系统进一步处理。例如，当按下返回按钮时返回
    `1`，以停止事件处理，防止活动被终止。
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create `jni/InputManager.hpp` to handle touch events and implement our new `InputHandler`
    interface.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `jni/InputManager.hpp` 以处理触摸事件并实现我们的新 `InputHandler` 接口。
- en: 'Define the methods as follows:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按如下方式定义方法：
- en: '`start()` to perform the necessary initialization.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()` 执行必要的初始化。'
- en: '`onTouchEvent()` to update the manager state when a new event is triggered.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTouchEvent()` 在触发新事件时更新管理器状态。'
- en: '`getDirectionX()` and `getDirectionY()` to indicate the ship direction.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDirectionX()` 和 `getDirectionY()` 指示飞船的方向。'
- en: '`setRefPoint()` refers to the ship position. Indeed, the direction is defined
    as the vector between the touch point and the ship location (that is, the reference
    point).'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRefPoint()` 指的是飞船的位置。实际上，方向被定义为触摸点和飞船位置（即参考点）之间的向量。'
- en: Also, declare the necessary members and more specifically `mScaleFactor`, which
    contains the proper ratio to convert the input event from screen coordinates to
    game coordinates (remember that we use a fixed size).
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，声明必要的成员变量，尤其是`mScaleFactor`，它包含了从屏幕坐标到游戏坐标的正确比例（记住我们使用的是固定大小）。
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create `jni/InputManager.cpp`, starting with the constructor:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/InputManager.cpp`，从构造函数开始：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write the `start()` method to clear members and compute the scale factor. The
    scale factor is necessary because, as seen in [Chapter 6](ch06.html "Chapter 6. Rendering
    Graphics with OpenGL ES"), *Rendering Graphics with OpenGL ES*, we need to convert
    screen coordinates provided in input events (which depends on the device) into
    game coordinates:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`start()`方法以清除成员变量并计算缩放因子。这个缩放因子是必要的，因为在[第6章](ch06.html "第6章。使用OpenGL ES渲染图形")，*使用OpenGL
    ES渲染图形*中提到，我们需要将输入事件提供的屏幕坐标（这取决于设备）转换为游戏坐标：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The effective event processing comes in `onTouchEvent()`. Horizontal and vertical
    directions are computed according to the distance between the reference point
    and the touch point. This distance is restricted by `TOUCH_MAX_RANGE` to an arbitrary
    range of `65` units. Thus, a ship's maximum speed is reached when the reference-to-touch
    point distance is beyond `TOUCH_MAX_RANGE` pixels.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有效的事件处理在`onTouchEvent()`中实现。根据参考点与触摸点之间的距离，计算出水平方向和垂直方向。这个距离通过`TOUCH_MAX_RANGE`限制在一个任意的`65`单位范围内。因此，当参考点到触摸点的距离超出`TOUCH_MAX_RANGE`像素时，飞船将达到最大速度。
- en: 'Touch coordinates are retrieved thanks to `AMotionEvent_getX()` and `AMotionEvent_getY()`
    when you move your finger. The direction vector is reset to `0` when no more touch
    is detected:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你移动手指时，通过`AMotionEvent_getX()`和`AMotionEvent_getY()`获取触摸坐标。当不再检测到触摸时，方向向量重置为`0`：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a simple component `jni/MoveableBody.hpp`, whose role is to move `PhysicsBody`
    according to input events:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的组件`jni/MoveableBody.hpp`，其作用是根据输入事件移动`PhysicsBody`：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implement this component in `jni/MoveableBody.cpp`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/MoveableBody.cpp`中实现这个组件。
- en: '`InputManager` and the body are bound in `registerMoveableBody()`:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`registerMoveableBody()`中，将`InputManager`和物体绑定：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initially, the body has no velocity.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，物体没有速度。
- en: 'Then, each time it is updated, the velocity mirrors the current input state.
    This velocity is taken in input by `PhysicsManager` created in [Chapter 5](ch05.html
    "Chapter 5. Writing a Fully Native Application"), *Writing a Fully Native Application*,
    to update the entity''s position:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，每次更新时，速度都会反映当前的输入状态。这个速度由[第5章](ch05.html "第5章。编写一个完全原生的应用程序")，*编写一个完全原生的应用程序*中创建的`PhysicsManager`接收，以更新实体的位置：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reference the new `InputManager` and `MoveableComponent` in `jni/DroidBlaster.hpp`:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中引用新的`InputManager`和`MoveableComponent`：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, adapt the `jni/DroidBlaster.cpp` constructor to instantiate `InputManager`
    and `MoveableComponent`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调整`jni/DroidBlaster.cpp`构造函数，以实例化`InputManager`和`MoveableComponent`。
- en: Append `InputManager` to `EventLoop`, which dispatches input events, at construction
    time.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造时，将`InputManager`添加到`EventLoop`中，后者负责分派输入事件。
- en: 'The spaceship is the entity being moved. So, pass a reference to its location
    to the `MoveableBody` component:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 飞船是被移动的实体。因此，需要将它的位置引用传递给`MoveableBody`组件：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize and update `MoveableBody` and `InputManager` in the corresponding
    methods:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的函数中初始化和更新`MoveableBody`和`InputManager`：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a simple example of an input system, based on touch events. The ship
    flies toward the touch point at a speed dependent on the touch distance. The touch
    event coordinates are absolute. Their origin is in the upper-left corner of the
    screen, on the opposite of OpenGL, which is on the lower-left corner. If screen
    rotation is permitted by an application, then the screen origin remains on the
    upper-left corner from the user's point of view, whether the device is in portrait
    or landscape mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基于触摸事件的输入系统的简单示例。飞船以与触摸距离相关的速度向触摸点飞行。触摸事件坐标是绝对的。它们的原点在屏幕左上角，与OpenGL的左下角相对。如果应用程序允许屏幕旋转，那么屏幕原点对于用户来说仍然在左上角，无论设备是纵向还是横向模式。
- en: '![What just happened?](img/9645OS_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645OS_08_07.jpg)'
- en: To implement this new feature, we connected our event loop to the input event
    queue provided by the `native_app_glue` module. This queue is internally represented
    as a UNIX pipe, like the activity event queue. Touchscreen events are embedded
    in an `AInputEvent` structure, which stores other kinds of input events. Input
    events are handled with the `AInputEvent` and `AMotionEvent` API declared in `android/input.h`.
    The `AInputEvent` API is necessary to discriminate input event types using `AInputEvent_getType()`
    and `AInputEvent_getSource()` methods. The `AMotionEvent` API provides methods
    to handle touch events only.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个新特性，我们将事件循环连接到了`native_app_glue`模块提供的输入事件队列。这个队列在内部表现为一个UNIX管道，类似于活动事件队列。触摸屏事件嵌入在`AInputEvent`结构中，该结构还存储其他类型的输入事件。使用`android/input.h`中声明的`AInputEvent`和`AMotionEvent`
    API处理输入事件。`AInputEvent` API通过`AInputEvent_getType()`和`AInputEvent_getSource()`方法来区分输入事件类型。而`AMotionEvent`
    API仅提供处理触摸事件的方法。
- en: 'The touch API is rather rich. Many details can be requested as shown in the
    following table (non-exhaustively):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸API相当丰富。许多细节可以按照以下表格所示请求（非详尽无遗）：
- en: '| Method | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| To detect whether a finger makes contact with the screen, leaving it, or
    moving over the surface.The result is an integer value composed of the event type
    (on byte `1`, for example, `AMOTION_EVENT_ACTION_DOWN`) and a pointer index (on
    byte `2`, to know which finger the event refers to). |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 用于检测手指是否与屏幕接触、离开或在其表面移动。结果是一个整数值，由事件类型（例如，第1个字节上的`AMOTION_EVENT_ACTION_DOWN`）和一个指针索引（在第2个字节上，以了解事件指的是哪个手指）组成。
    |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| To retrieve touch coordinates on screen, expressed in pixels as a float (sub-pixel
    values are possible). |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 用于获取屏幕上的触摸坐标，以浮点数（像素）表示（可能存在亚像素值）。 |'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| To retrieve how much time a finger has been sliding over the screen and when
    the event was generated in nanoseconds. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 用于获取手指在屏幕上滑动的时间和事件生成的时间（单位为纳秒）。 |'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| To detect the pressure intensity and zone. Values usually range between `0.0`
    and `1.0` (but may exceed it). Size and pressure are generally closely related.
    The behavior can vary greatly and be noisy, depending on hardware. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 用于检测压力强度和区域。值通常在`0.0`到`1.0`之间（但可能会超出）。大小和压力通常密切相关。行为可能会因硬件而异并产生噪声。 |'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Touch events of type `AMOTION_EVENT_ACTION_MOVE` can be grouped together
    for efficiency purposes. These methods give access to these *historical points*
    that occurred between previous and current events. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 为了提高效率，可以将类型为`AMOTION_EVENT_ACTION_MOVE`的触摸事件分组在一起。这些方法提供了对发生在前一个事件和当前事件之间的这些*历史点*的访问。
    |'
- en: Have a look at `android/input.h` for an exhaustive list of methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完整的`android/input.h`方法列表。
- en: 'If you look more deeply at the `AMotionEvent` API, you will notice that some
    events have a second parameter `pointer_index`, which ranges between `0` and the
    number of active pointers. Indeed, most touchscreens today are multi-touch! Two
    or more fingers on a screen (if hardware supports it) are translated in Android
    by two or more pointers. To manipulate them, look at the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入查看`AMotionEvent` API，你会注意到一些事件有一个第二个参数`pointer_index`，其范围在`0`到活动指针的数量之间。实际上，当今大多数触摸屏都支持多点触控！屏幕上的两个或更多手指（如果硬件支持）在Android中由两个或更多指针表示。要操作它们，请查看以下表格：
- en: '| Method | Description |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| To know how many fingers touch the screen. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 用于了解有多少手指触摸屏幕。 |'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| To get a pointer unique identifier from a pointer index. This is the only
    way to track a particular pointer (that is, *finger*) over time, as its index
    may change when fingers touch or leave the screen. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 从指针索引获取一个指针的唯一标识符。这是跟踪特定指针（即*手指*）随时间变化唯一的方式，因为当手指触摸或离开屏幕时其索引可能会改变。 |'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you followed the story of the (*now prehistoric!*) Nexus One, then you know
    that it came out with a hardware defect. Pointers were often getting mixed up,
    two of them exchanging one of their coordinates. So always be prepared to handle
    hardware specificities or hardware that behaves incorrectly!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关注过（现在已成古董的！）Nexus One的故事，那么你应该知道它曾因硬件缺陷而出名。指针经常混淆，其中两个会交换它们的坐标。因此，一定要准备好处理硬件的特定行为或表现异常的硬件！
- en: Detecting keyboard, D-Pad, and Trackball events
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测键盘、D-Pad和轨迹球事件
- en: 'The most common input device among all is the keyboard. This is true for Android
    too. An Android keyboard can be physical: in the device front face (like traditional
    Blackberries) or on a slide-out screen. However, a keyboard is more commonly virtual,
    that is, emulated on the screen at the cost of a large portion of space taken.
    In addition to the keyboard itself, every Android device must include a few physical
    or emulated buttons such as **Menu**, **Home**, and **Tasks**.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的输入设备中，最常见的是键盘。这对于Android来说也是如此。Android的键盘可以是物理的：位于设备正面（如传统的黑莓手机），或者是在滑出式屏幕上的。然而，键盘通常是虚拟的，即在屏幕上模拟，这会占用大量的空间。除了键盘本身，每个Android设备都必须包括一些物理或模拟的按钮，如**菜单**、**主页**和**任务**。
- en: A much less common type of input device is the Directional-Pad. A D-Pad is a
    set of physical buttons to move up, down, left, or right and a specific action/confirmation
    button. Although they often disappear from recent phones and tablets, D-Pads remain
    one of the most convenient ways to move across text or UI widgets. D-Pads are
    often replaced by trackballs. Trackballs behave similarly to a mouse (the one
    with a ball inside) that would be upside down. Some trackballs are analogical,
    but others (for example, optical ones) behave as a D-Pad (that is, all or nothing).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不太常见的输入设备类型是方向键。方向键是一组物理按钮，用于向上、向下、向左或向右移动以及特定的动作/确认按钮。尽管它们经常从最近的手機和平板电脑上消失，但方向键仍然是在文本或UI小部件之间移动的最方便方式之一。方向键通常被轨迹球取代。轨迹球的行为类似于鼠标（带有一个球体的鼠标）并倒置。一些轨迹球是模拟的，但其他（例如，光学的）则表现为方向键（即全有或全无）。
- en: '![Detecting keyboard, D-Pad, and Trackball events](img/9645OS_08_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![检测键盘、方向键和轨迹球事件](img/9645OS_08_02.jpg)'
- en: To see how they work, let's use these peripherals to move our space ship in
    `DroidBlaster`. The Android NDK now allows handling all these input peripherals
    on the native side. So, let's try them!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它们是如何工作的，让我们在`DroidBlaster`中使用这些外设来移动我们的太空船。现在Android NDK允许在本地处理所有这些输入外设。那么，让我们试试看！
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part14`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的结果项目名为`DroidBlaster_Part14`。
- en: Time for action – handling keyboard, D-Pad, and trackball events natively
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——本地处理键盘、方向键和轨迹球事件
- en: 'Let''s extend our new Input system with more event types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们新的输入系统，加入更多的事件类型：
- en: 'Open `jni/InputHandler.hpp` and add the keyboard and trackball event handlers:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/InputHandler.hpp`并添加键盘和轨迹球事件处理程序：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Update the method `processInputEvent()` inside the existing file `jni/EventLoop.cpp`
    to redirect the keyboard and trackball events to `InputHandler`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新现有文件`jni/EventLoop.cpp`中的`processInputEvent()`方法，将键盘和轨迹球事件重定向到`InputHandler`。
- en: 'Trackballs and touch events are assimilated to motion events and can be discriminated
    according to their source. On the opposite side, key events are discriminated
    according to their type. Indeed, there exists two dedicated APIs for `MotionEvents`
    (the same for trackballs and touch events) and for `KeyEvents` (identical for
    keyboard, D-Pad, and so on):'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轨迹球和触摸事件被归纳为动作事件，可以根据它们的来源进行区分。相对的，按键事件根据它们的类型进行区分。实际上，存在两个专用的API，一个用于`MotionEvents`（轨迹球和触摸事件相同），另一个用于`KeyEvents`（键盘、方向键等相同）。
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `jni/InputManager.hpp` file to override these new methods:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`jni/InputManager.hpp`文件，重写这些新方法：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `jni/InputManager.cpp`, process the keyboard events in `onKeyboardEvent()`
    using:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.cpp`中，使用`onKeyboardEvent()`处理键盘事件：
- en: '`AKeyEvent_getAction()` to get the event type (that is, pressed or not).'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AKeyEvent_getAction()`获取事件类型（即按下或未按下）。
- en: '`AKeyEvent_getKeyCode()` to get the button identity.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AKeyEvent_getKeyCode()`获取按钮标识。
- en: In the following code, when left, right, up, or down buttons are pressed, `InputManager`
    calculates the direction and saves it into `mDirectionX` and `mDirectionY`. The
    movement starts when the button is down and stops when it is up.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下代码中，当按下左、右、上或下按钮时，`InputManager`会计算方向并将其保存到`mDirectionX`和`mDirectionY`中。按钮按下时开始移动，松开时停止。
- en: 'Return `true` when the key has been consumed and `false` when it has not. Indeed,
    if a user has pressed, for example, the back button (`AKEYCODE_BACK`) or volume
    buttons (`AKEYCODE_VOLUME_UP`, `AKEYCODE_VOLUME_DOWN`), then we let the system
    react appropriately for us:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当按键被消耗时返回`true`，否则返回`false`。实际上，如果用户按下了例如返回键（`AKEYCODE_BACK`）或音量键（`AKEYCODE_VOLUME_UP`，`AKEYCODE_VOLUME_DOWN`），我们就让系统为我们做出适当的反应：
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, process trackball events in a new method `onTrackballEvent()`. Retrieve
    the trackball magnitude with `AMotionEvent_getX()` and `AMotionEvent_getY()`.
    Because some trackballs do not offer a gradated magnitude, the movements are quantified
    with plain constants. The possible noise is ignored with an arbitrary trigger
    threshold:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新方法 `onTrackballEvent()` 中处理轨迹球事件。使用 `AMotionEvent_getX()` 和 `AMotionEvent_getY()`
    获取轨迹球的大小。由于一些轨迹球不提供渐变的幅度，因此使用普通常量来量化移动，并通过任意的触发阈值忽略可能出现的噪声：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When using a trackball that way, the ship moves until a "counter-movement"
    (for example, requesting to go to the right when going left) or action button
    is pressed (the last `else` section):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式使用轨迹球时，飞船会一直移动，直到出现“反方向移动”（例如，在向左移动时请求向右移动）或按下动作按钮（最后的 `else` 部分）：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*What just happened?*'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We extended our input system to handle the keyboard, D-Pad, and trackball events.
    D-Pad can be considered as a keyboard extension and is processed the same way.
    Indeed, D-Pad and keyboard events are transported in the same structure (`AInputEvent`)
    and handled by the same API (prefixed with `AKeyEvent`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了输入系统以处理键盘、D-Pad和轨迹球事件。D-Pad可以被视为键盘的扩展并以相同的方式处理。实际上，D-Pad和键盘事件使用相同的结构 (`AInputEvent`)
    并通过相同的API（以 `AKeyEvent` 为前缀）处理。
- en: 'The following table lists the main key event methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了主要的键事件方法：
- en: '| Method | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AKeyEvent_getAction()` | Indicates whether the button is down (`AKEY_EVENT_ACTION_DOWN`)
    or released (`AKEY_EVENT_ACTION_UP`). Note that multiple key actions can be emitted
    in batch (`AKEY_EVENT_ACTION_MULTIPLE`). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getAction()` | 指示按钮是按下 (`AKEY_EVENT_ACTION_DOWN`) 还是释放 (`AKEY_EVENT_ACTION_UP`)。请注意，可以批量发出多个键动作
    (`AKEY_EVENT_ACTION_MULTIPLE`)。 |'
- en: '| `AKeyEvent_getKeyCode()` | To retrieve the actual button being pressed (defined
    in `android/keycodes.h`), for example, `AKEYCODE_DPAD_LEFT` for the left button.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getKeyCode()` | 获取实际被按下的按钮（在 `android/keycodes.h` 中定义），例如，左按钮为
    `AKEYCODE_DPAD_LEFT`。 |'
- en: '| `AKeyEvent_getFlags()` | Key events can be associated with one or more flags
    that give various kinds of information on the event, such as `AKEY_EVENT_LONG_PRESS`,
    `AKEY_EVENT_FLAG_SOFT_KEYBOARD` for the event originated from an emulated keyboard.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getFlags()` | 键事件可以与一个或多个标志相关联，这些标志提供了关于事件的各种信息，例如 `AKEY_EVENT_LONG_PRESS`、`AKEY_EVENT_FLAG_SOFT_KEYBOARD`
    表示事件源自模拟键盘。 |'
- en: '| `AKeyEvent_getScanCode()` | Is similar to a key code except that this is
    the raw key ID, dependent and different from device to device. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getScanCode()` | 类似于键码，但这是一个原始键ID，依赖于设备且不同设备之间可能不同。 |'
- en: '| `AKeyEvent_getMetaState()` | Meta states are flags that indicate whether
    some modifier keys, such as Alt or Shift, are pressed simultaneously (for example,
    `AMETA_SHIFT_ON`, `AMETA_NONE`, and so on). |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getMetaState()` | 元状态是标志，表示是否同时按下了某些修饰键，如Alt或Shift（例如 `AMETA_SHIFT_ON`、`AMETA_NONE`
    等）。 |'
- en: '| `AKeyEvent_getRepeatCount()` | Indicates how many times the button event
    occurred, usually when you leave the button down. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getRepeatCount()` | 指示按钮事件发生了多少次，通常是在你按下按钮不放时。 |'
- en: '| `AKeyEvent_getDownTime()` | To know when a button was pressed. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getDownTime()` | 了解按钮被按下时间。 |'
- en: 'Although some of them (especially optical ones) behave like a D-Pad, trackballs
    do not use the same API. Actually, trackballs are handled through the `AMotionEvent`
    API (such as touch events). Of course, some information provided for touch events
    is not always available on trackballs. The most important functions to look at
    are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些轨迹球（尤其是光学的）表现得像D-Pad，但轨迹球并不使用相同的API。实际上，轨迹球是通过 `AMotionEvent` API（如触摸事件）来处理的。当然，一些为触摸事件提供的信息在轨迹球上并不总是可用。需要关注的最重要功能如下：
- en: '| `AMotionEvent_getAction()` | To know whether an event represents a move action
    (as opposed to a press action). |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `AMotionEvent_getAction()` | 了解事件是否表示移动动作（与按下动作相对）。 |'
- en: '| `AMotionEvent_getX()``AMotionEvent_getY()` | To get trackball movement. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `AMotionEvent_getX()``AMotionEvent_getY()` | 获取轨迹球移动。 |'
- en: '| `AKeyEvent_getDownTime()` | To know whether the trackball is pressed (such
    as the D-Pad action button). Currently, most trackballs use an all-or-nothing
    pressure to indicate the press event. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `AKeyEvent_getDownTime()` | 了解轨迹球是否被按下（如D-Pad动作按钮）。目前，大多数轨迹球使用全或无的压力来指示按下事件。
    |'
- en: A tricky point to keep in mind when dealing with trackballs is that no event
    is generated to indicate that the trackball is not moving. Moreover, trackball
    events are generated as a "burst", which makes it harder to detect when the movement
    is finished. There is no easy way to handle this, except using a manual timer
    and checking regularly that no event has happened for a sufficient amount of time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理轨迹球时，要记住的一个棘手点是，没有事件生成来指示轨迹球没有移动。此外，轨迹球事件是作为“爆发”生成的，这使得检测运动何时结束变得更加困难。处理这个问题的唯一方法（除了使用手动计时器并定期检查是否有足够长的时间没有事件发生）。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never expect peripherals to behave exactly the same on all phones. Trackballs
    are a very good example; they can either indicate a direction like an analogical
    pad or a straight direction like a D-Pad (for example, optical trackballs). There
    is currently no way to differentiate device characteristics from the available
    APIs. The only solutions are to either calibrate the device or configure it at
    runtime or save a kind of device database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望所有手机上的外围设备行为完全相同。轨迹球就是一个很好的例子；它们可以像模拟垫一样指示方向，也可以像D-Pad一样指示直线路径（例如，光学轨迹球）。目前还没有办法从可用的API中区分设备特性。唯一的解决方案是在运行时校准设备或配置设备，或者保存一种设备数据库。
- en: Probing device sensors
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测设备传感器
- en: Handling input devices is essential to any application, but probing sensors
    is important for the smartest one! The most spread sensor among Android game applications
    is the accelerometer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 处理输入设备对于任何应用来说都很重要，但对于最智能的应用来说，探测传感器才是关键！在Android游戏应用中最常见的传感器就是加速度计。
- en: 'An accelerometer, as its name suggests, measures the linear acceleration applied
    to a device. When moving a device up, down, left, or right, the accelerometer
    gets excited and indicates an acceleration vector in 3D space. Vector is expressed
    in relation to the screen''s default orientation. The coordinate system is relative
    to the device''s natural orientation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，加速度计测量施加在设备上的线性加速度。当将设备向上、下、左或右移动时，加速度计会被激发，并在3D空间中指示一个加速度矢量。该矢量是相对于屏幕默认方向的。坐标系相对于设备的自然方向：
- en: X axis points to the right
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X轴指向右侧
- en: Y points up
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y轴指向上方
- en: Z points from back to front
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z轴从后向前指
- en: Axes become inverted if the device is rotated (for example, Y points left if
    the device is rotated 90 degrees clockwise).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备旋转，轴会反转（例如，如果设备顺时针旋转90度，Y轴将指向左侧）。
- en: 'A very interesting feature of accelerometers is that they undergo a constant
    acceleration: gravity, around 9.8m/s2 on earth. For example, when lying flat on
    a table, acceleration vector indicates -9.8 on the Z-axis. When straight, it indicates
    the same value on Y axis. So assuming the device position is fixed, device orientation
    on two axes in space can be deduced from the gravity acceleration vector. A magnetometer
    is still required to get full device orientation in 3D space.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计一个非常有趣的特点是它们经历恒定加速度：地球上的重力，大约是9.8m/s²。例如，当设备平放在桌子上时，加速度矢量在Z轴上指示-9.8。当设备直立时，它在Y轴上指示相同的值。因此，假设设备位置固定，可以从重力加速度矢量推导出设备在空间中的两个轴的方向。要获取3D空间中设备的完全方向，还需要一个磁力计。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that accelerometers work with linear acceleration. They allow detecting
    the translation when the device is not rotating and partial orientation when the
    device is fixed. However, both movements cannot be combined without a magnetometer
    and/or gyroscope.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，加速度计处理的是线性加速度。它们可以检测设备不旋转时的平移和设备固定时的部分方向。然而，如果没有磁力计和/或陀螺仪，这两种运动是无法结合的。
- en: So we can use the device orientation deduced from the accelerometer to compute
    a direction. Let's now see how to apply this process in `DroidBlaster`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用从加速度计推导出的设备方向来计算一个方向。现在让我们看看如何在 `DroidBlaster` 中应用这个过程。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part15`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最终项目与本一起提供，名为 `DroidBlaster_Part15`。
- en: Time for action – handling accelerometer events
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——处理加速度计事件
- en: 'Let''s handle accelerometer events in `DroidBlaster`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `DroidBlaster` 中处理加速度计事件：
- en: 'Open `jni/InputHandler.hpp` and add a new method `onAccelerometerEvent()`.
    Include the `android/sensor.h` official header for sensors:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `jni/InputHandler.hpp` 文件，并添加一个新的方法 `onAccelerometerEvent()`。包含官方传感器头文件 `android/sensor.h`：
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create new methods in `jni/EventLoop.hpp`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/EventLoop.hpp` 中创建新方法：
- en: '`activateAccelerometer()` and `deactivateAccelerometer()` to enable/disable
    the accelerometer sensor when the activity starts and stops.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activateAccelerometer()`和`deactivateAccelerometer()`在活动开始和停止时启用/禁用加速度传感器。'
- en: '`processSensorEvent()` retrieves and dispatches sensor events.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processSensorEvent()`检索并分派传感器事件。'
- en: The callback `callback_input()` static method is bound to the Looper.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调`callback_input()`静态方法绑定到Looper。
- en: 'Also, define the following members:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，定义以下成员：
- en: '`mSensorManager`, of type `ASensorManager`, is the main "object" to interact
    with sensors.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorManager`，类型为`ASensorManager`，是与传感器交互的主要“对象”。'
- en: '`mSensorEventQueue` is `ASensorEventQueue`, which is a structure defined by
    the Sensor API to retrieve occurring events.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorEventQueue`是`ASensorEventQueue`，这是Sensor API定义的结构，用于检索发生的事件。'
- en: '`mSensorPollSource` is `android_poll_source` defined in the Native Glue. This
    structure describes how to bind the native thread Looper to the sensor callback.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSensorPollSource`是Native Glue中定义的`android_poll_source`。这个结构描述了如何将原生线程Looper绑定到传感器回调。'
- en: '`mAccelerometer`, declared as an `ASensor` structure, represents the sensor
    used:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mAccelerometer`，声明为`ASensor`结构，表示所使用的传感器：'
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Update constructor initialization list in `jni/EventLoop.cpp`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`jni/EventLoop.cpp`中的构造函数初始化列表：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create the sensor event queue, through which all `sensor` events are notified.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建传感器事件队列，通过它通知所有`sensor`事件。
- en: Bind it to `callback_sensor()`. Note here that we use the `LOOPER_ID_USER` constant
    provided by the Native App Glue to attach a user-defined queue.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其绑定到`callback_sensor()`。请注意，这里我们使用Native App Glue提供的`LOOPER_ID_USER`常量来附加用户定义的队列。
- en: 'Then, call `activateAccelerometer()` to initialize the accelerometer sensor:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接着，调用`activateAccelerometer()`来初始化加速度传感器：
- en: '[PRE30]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When an activity is disabled or terminated, disable the running accelerometer
    to avoid consuming battery needlessly.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当活动被禁用或结束时，禁用正在运行的加速度传感器，以免不必要的消耗电池。
- en: 'Then, destroy the `sensor` event queue:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，销毁`sensor`事件队列：
- en: '[PRE31]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`callback_sensor()` is triggered when event loop is polled. It dispatches events
    to `processSensorEvent()` on the `EventLoop` instance. We only care about `ASENSOR_TYPE_ACCELEROMETER`
    events:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事件循环被轮询时，`callback_sensor()`会被触发。它将事件分派给`EventLoop`实例上的`processSensorEvent()`。我们只关心`ASENSOR_TYPE_ACCELEROMETER`事件：
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Activate the sensor in `activateAccelerometer()` in three main steps:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activateAccelerometer()`中通过三个主要步骤激活传感器：
- en: Get a sensor of a specific type with `AsensorManager_getDefaultSensor()`.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsensorManager_getDefaultSensor()`获取特定类型的传感器。
- en: Then, enable it with `ASensorEventQueue_enableSensor()` so that the sensor event
    queue gets filled with related events.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用`ASensorEventQueue_enableSensor()`启用它，以便传感器事件队列填充相关事件。
- en: Set the desired event rate with `ASensorEventQueue_setEventRate()`. For a game,
    we typically want measures close to real time. The minimum delay can be queried
    with `ASensor_getMinDelay()` (setting it to a lower value might result in a failure).
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ASensorEventQueue_setEventRate()`设置所需的事件率。对于游戏，我们通常希望接近实时测量。可以使用`ASensor_getMinDelay()`查询最小延迟（将其设置得较低可能会导致失败）。
- en: 'Obviously, we should perform this setup only when the sensor event queue is
    ready:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，我们应该只在传感器事件队列准备好时执行此设置：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Sensor deactivation is easier and only requires a call to the method `AsensorEventQueue_disableSensor()`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传感器停用更容易，只需调用`AsensorEventQueue_disableSensor()`方法即可：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We created an event queue to listen to sensor events. Events are wrapped in
    an `ASensorEvent` structure, defined in `android/sensor.h`. This structure provides
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个事件队列来监听传感器事件。事件被封装在`ASensorEvent`结构中，该结构在`android/sensor.h`中定义。这个结构提供了以下内容：
- en: Sensor event origin, that is, which sensor produced this event.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器事件来源，即哪个传感器产生了这个事件。
- en: Sensor event occurrence time.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器事件发生的时间。
- en: Sensor output value. This value is stored in a union structure, that is, you
    can use either one of the inside structures (here, we are interested in the `acceleration`
    vector).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器输出值。这个值存储在一个联合结构中，即你可以使用其中一个内部结构（这里我们关心的是`acceleration`向量）。
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The same `ASensorEvent` structure is used for any Android sensor. In the case
    of the accelerometer, we retrieve a vector with three coordinates `x`, `y`, and
    `z`, one for each axis:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Android传感器，都使用相同的`ASensorEvent`结构。在加速度传感器的情况下，我们获取一个带有三个坐标`x`、`y`、`z`的向量，每个轴一个：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In our example, the accelerometer is set up with the lowest event rate possible,
    which may vary between devices. It is important to note that the sensor event
    rate has a direct impact on battery saving! So, use a rate that is sufficient
    for your application. The `ASensor` API offers some methods to query the available
    sensors and their capabilities, such as `ASensor_getName()`, `ASensor_getVendor()`,
    `ASensor_getMinDelay()`, and so on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，加速度计设置为尽可能低的事件率，这可能在不同的设备之间有所变化。需要注意的是，传感器事件率对电池节省有直接影响！因此，使用对应用程序来说足够的事件率。`ASensor`
    API提供了一些方法来查询可用的传感器及其功能，如`ASensor_getName()`、`ASensor_getVendor()`、`ASensor_getMinDelay()`等。
- en: Now that we can retrieve sensor events, let's use them to compute a ship's direction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够获取传感器事件，让我们用它们来计算飞船的方向。
- en: Time for action – turning an Android device into a Joypad
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——将Android设备转变为游戏手柄
- en: Let's find the device orientation and properly determine the direction.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到设备方向并正确确定方向。
- en: Write a new file `jni/Configuration.hpp` to help us get device information,
    and more specifically device rotation (defined as `screen_rot`).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个新文件`jni/Configuration.hpp`，帮助我们获取设备信息，特别是设备旋转（定义为`screen_rot`）。
- en: 'Declare `findRotation()` to discover the device orientation with the help of
    JNI:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明`findRotation()`，以借助JNI发现设备方向：
- en: '[PRE37]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Retrieve configuration details in `jni/Configuration.cpp`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Configuration.cpp`中获取配置详情。
- en: 'First, in the constructor, use the `AConfiguration` API to dump configuration
    properties, such as the current language, country, screen size, screen orientation.
    This information may be interesting, but is not sufficient to properly analyze
    accelerometer events:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，在构造函数中，使用`AConfiguration` API转储配置属性，例如当前语言、国家、屏幕大小、屏幕方向。这些信息可能很有趣，但不足以正确分析加速度计事件：
- en: '[PRE38]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then, attach the current native thread to the Android VM.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将当前本地线程附加到Android VM。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have carefully read [Chapter 4](ch04.html "Chapter 4. Calling Java Back
    from Native Code"), *Calling Java Back from Native Code*, you know that this step
    is necessary to get access to the `JNIEnv` object (which is thread-specific).
    The `JavaVM` itself can be retrieved from the `android_app` structure.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了[第4章](ch04.html "第4章. 从本地代码调用Java")，*从本地代码调用Java*，你就知道这一步是获取`JNIEnv`对象（特定于线程）的必要步骤。`JavaVM`本身可以从`android_app`结构中获取。
- en: After that, call `findRotation()` to retrieve the current device rotation.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，调用`findRotation()`以获取当前设备旋转。
- en: 'Finally, we can detach the thread from Dalvik as we will not use JNI any more.
    Remember that an attached thread should always be detached before terminating
    the application:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以将线程从Dalvik分离，因为我们不再使用JNI。请记住，在结束应用程序之前，始终应该分离已附加的线程：
- en: '[PRE39]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement `findRotation()`, which basically executes the following Java code
    through JNI:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`findRotation()`，其基本通过JNI执行以下Java代码：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Obviously, this is slightly more complex to write in JNI.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，这在JNI中编写会稍微复杂一些。
- en: First, retrieve JNI classes, then methods, and finally, fields
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，获取JNI类，然后是方法，最后是字段
- en: Then, perform the JNI calls
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，执行JNI调用
- en: Finally, release the allocated JNI references
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，释放分配的JNI引用
- en: 'The following code has been voluntarily simplified to avoid extra checks (that
    is, `FindClass()` and `GetMethodID()` return value and exception checks for each
    method call):'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码故意简化，以避免额外的检查（即，每个方法调用的`FindClass()`和`GetMethodID()`返回值和异常检查）：
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Manage the new accelerometer sensor in `jni/InputManager.hpp`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.hpp`中管理新的加速度计传感器。
- en: Accelerometer axes are transformed in `toScreenCoord()`.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加速度计轴在`toScreenCoord()`中进行转换。
- en: 'This transformation implies that we keep track of device rotation:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种转换意味着我们要跟踪设备旋转：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `jni/InputManager.hpp`, read the current screen rotation settings with the
    help of the new `Configuration` class. Since `DroidBlaster` forces portrait mode,
    we can store rotation once and for all:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/InputManager.hpp`中，利用新的`Configuration`类读取当前屏幕旋转设置。由于`DroidBlaster`强制使用竖屏模式，我们可以一次性存储旋转：
- en: '[PRE43]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's compute a direction from the accelerometer sensor values.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从加速度计传感器值计算一个方向。
- en: First, convert accelerometer values from canonical to screen coordinates to
    handle portrait and landscape devices.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，将加速度计值从标准坐标转换为屏幕坐标，以处理竖屏和横屏设备。
- en: 'Then, compute a direction from the captured accelerometer values. In the following
    code, the `X` and `Z` axis express the roll and pitch, respectively. Check for
    both axes whether the device is in a neutral orientation (that is, `CENTER_X`
    and `CENTER_Z`) or is sloping (`MIN_X`, `MIN_Z`, `MAX_X`, and `MAX_Z`). Note that
    Z values need to be inverted for our needs:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，从捕获到的加速度计值中计算一个方向。在以下代码中，`X`和`Z`轴分别表示滚转和俯仰。检查这两个轴，看设备是否处于中性位置（即`CENTER_X`和`CENTER_Z`）或者是在倾斜（`MIN_X`、`MIN_Z`、`MAX_X`和`MAX_Z`）。请注意，我们的需求需要将Z值取反：
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `toScreenCoord()` helper, swap or invert accelerometer axes depending
    on screen rotation, so that `X` and `Z` axes point toward the same direction,
    whatever device you use when playing `DroidBlaster` in portrait mode:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`toScreenCoord()`辅助函数中，根据屏幕旋转交换或反转加速度计轴，使得在使用`DroidBlaster`在纵向模式时，无论你使用哪种设备，`X`和`Z`轴都指向同一方向：
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*What just happened?*'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The accelerometer is now a Joypad! Android devices can be naturally portrait-oriented
    (mainly smartphones and smaller tablets) or landscape-oriented (mainly tablets).
    This has an impact on applications, which receive accelerometer events. Axes are
    not aligned the same way between these types of devices and depending on the way
    they are rotated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计现在是一个游戏手柄！Android设备可以是自然的纵向（主要是智能手机和小型平板电脑）或横向（主要是平板电脑）。这对接收加速度计事件的应用程序有影响。这些类型的设备及其旋转方式不同，轴线的对齐方式也不相同。
- en: 'Indeed, the screen can be oriented in four different ways: `0`, `90`, `180`,
    and `270` degrees. 0 degree is the device''s natural orientation. Accelerometer
    X axis always points right, Y points up, and Z points towards the front. On a
    phone, Y points up in portrait mode, whereas on most tables, Y points up in landscape
    mode. When the device is oriented at 90 degrees, the axes orientation obviously
    changes (X points up, and so on). This situation may also happen with a tablet
    (where 0 degree corresponds to landscape mode) that is used in portrait mode.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，屏幕可以以四种不同的方式定向：`0`、`90`、`180`和`270`度。0度是设备的自然方向。加速度计X轴始终指向右侧，Y轴指向上方，Z轴指向前方。在手机上，Y轴在纵向模式下指向上方，而在大多数平板电脑上，Y轴在横向模式下指向上方。当设备以90度方向定位时，轴的方向显然会改变（X轴指向上方，等等）。这种情况也可能发生在以纵向模式使用的平板电脑上（其中0度对应于横向模式）。
- en: '![What just happened?](img/9645OS_08_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/9645OS_08_03.jpg)'
- en: There is sadly no way to get device rotation relative to a screen's natural
    orientation with native APIs. Thus, we need to rely on JNI to get accurate device
    rotation. Then, we can easily deduce a direction vector from this like done in
    `onAccelerometerEvent()`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，使用原生API无法获取设备相对于屏幕自然方向的旋转。因此，我们需要依赖JNI来获取准确的设备旋转信息。然后，我们可以在`onAccelerometerEvent()`中像这样轻松地推导出方向向量。
- en: More on sensors
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于传感器的更多内容
- en: 'Each Android sensor has a unique identifier, defined in `android/sensor.h`.
    These identifiers are the same across all Android devices:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android传感器都有一个唯一的标识符，在`android/sensor.h`中定义。这些标识符在所有Android设备上都是相同的：
- en: '`ASENSOR_TYPE_ACCELEROMETER`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_ACCELEROMETER`'
- en: '`ASENSOR_TYPE_MAGNETIC_FIELD`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_MAGNETIC_FIELD`'
- en: '`ASENSOR_TYPE_GYRISCOPE`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_GYRISCOPE`'
- en: '`ASENSOR_TYPE_LIGHT`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_LIGHT`'
- en: '`ASENSOR_TYPE_PROXIMITY`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASENSOR_TYPE_PROXIMITY`'
- en: 'Additional sensors may exist and be available, even if they are not named in
    the `android/sensor.h` header. On Gingerbread, we have the same case with:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在其他额外的传感器并且可用，即使它们在`android/sensor.h`头文件中没有命名。在Gingerbread上，我们有与以下情况相同的情况：
- en: Gravity sensor (identifier `9`)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力传感器（标识符`9`）
- en: Linear acceleration sensor (identifier `10`)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性加速度传感器（标识符`10`）
- en: Rotation vector (identifier `11`).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转矢量（标识符`11`）。
- en: The rotation vector sensor, successor of the now deprecated orientation vector,
    is essential in the `Augmented Reality` application. It gives you device orientation
    in 3D space. Combined with the GPS, it allows locating any object through the
    eye of your device. The rotation sensor provides a data vector, which can be translated
    to an OpenGL view matrix, thanks to the `android.hardware.SensorManager` class
    (see its source code). That way, you can directly materialize device orientation
    into screen content, linking together real and virtual life.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转矢量传感器是现在已弃用的方向矢量的继承者，在`增强现实`应用中至关重要。它提供了设备在3D空间中的方向。结合GPS，它可以通过设备的视角定位任何物体。旋转传感器提供了一个数据矢量，通过`android.hardware.SensorManager`类（请参阅其源代码），可以将其转换为OpenGL视图矩阵。这样，你可以直接将设备方向物化为屏幕内容，将真实与虚拟生活联系起来。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered multiple ways to interact with Android from native
    code. More precisely, we discovered how to attach an input queue to the `Native
    App Glue` event loop. Then, we handled touch events and processed key events from
    keyboards and D-Pads or motion events from trackballs. Finally, we turned the
    accelerometer into a Joypad.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了多种从原生代码与Android交互的方法。更准确地说，我们学习了如何将输入队列附加到`Native App Glue`事件循环中。然后，我们处理了触摸事件以及来自键盘、D-Pad的动作事件和轨迹球的运动事件。最后，我们将加速度计转换成了游戏手柄。
- en: Because of Android fragmentation, expect specificities in an input device's
    behavior and be prepared to tweak your code. We have already been far in the capabilities
    of Android NDK in terms of application structure, graphics, sound, input, and
    sensors. However, reinventing the wheel is not a solution!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android的碎片化，预计输入设备的行为会有所不同，需要准备好调整代码。在应用结构、图形、声音、输入和传感器方面，我们已经深入了解了Android
    NDK的能力。然而，重新发明轮子并不是解决方案！
- en: In the next chapter, we will unleash the real power of the NDK by porting existing
    C/C++ libraries to Android.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过将现有的C/C++库移植到Android，释放NDK的真正力量。
