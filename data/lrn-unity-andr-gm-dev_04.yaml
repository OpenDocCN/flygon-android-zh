- en: Chapter 4. Setting the Stage – Camera Effects and Lighting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 设置舞台 - 相机效果与照明
- en: 'In the previous chapter, you learned about the basic building blocks of any
    game: meshes, materials, and animations. We created a *Tank Battle* game that
    utilized all of these blocks.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经学习了构成任何游戏的基础模块：网格、材质和动画。我们创建了一个名为*Tank Battle*的游戏，该游戏利用了所有这些模块。
- en: In this chapter, we will expand upon the Tank Battle game. We will start with
    the addition of a skybox and distance fog. The exploration of camera effects continues
    with a target indicator overlay that uses a second camera. The creation of a turbo
    boost effect for the tank will round out our look at camera effects. Continuing
    with a look at lighting, we will finish off our tank environment with the addition
    of lightmaps and shadows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展Tank Battle游戏。我们从添加天空盒和距离雾开始。通过使用第二个相机的目标指示器叠加，继续探索相机效果。为坦克创建涡轮增压效果，将完成我们对相机效果的探讨。继续关注照明，我们将通过添加光照图和阴影来完成坦克环境的制作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Skyboxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空盒
- en: Distance fog
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离雾
- en: Using multiple cameras
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个相机
- en: Adjusting the field of view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整视野
- en: Adding lights
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加灯光
- en: Creating lightmaps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建光照图
- en: Adding cookies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加饼干（cookies）
- en: We will be directly piggybacking off the project from [Chapter 3](ch03.html
    "Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations"), *The
    Backbone of Any Game – Meshes, Material, and Animations*. So, open the project
    in Unity and we will get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接沿用[第三章](ch03.html "第三章. 任何游戏的核心 - 网格、材质和动画")的项目，*任何游戏的核心 - 网格、材质和动画*。所以，在Unity中打开项目，我们将开始操作。
- en: Camera effects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机效果
- en: There are many great camera effects that you should add in order to give your
    game the last great finishing touch. In this chapter, we will be covering a few
    options that are easy to add. These will also give our tank game a finished look.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该添加许多出色的相机效果，以使你的游戏达到最后的完美。在本章中，我们将介绍一些容易添加的选项。这些也将给我们的坦克游戏一个完成的外观。
- en: Skyboxes and distance fog
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天空盒和距离雾
- en: When a camera renders the frame of a game, it starts by clearing the screen.
    The default camera in Unity does this by coloring everything with a gradient,
    simulating the look of a skybox. All of the game's meshes are then drawn on top
    of this blank screen. While the gradient looks better than a solid color, it is
    still rather boring for an exciting battle of tanks. Luckily for us, Unity allows
    us to change the skybox. A skybox is just a fancy word for the series of images
    that form the background sky of any game. Distance fog works in conjunction with
    the skybox by easing the visual transition between models and the background.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机渲染游戏的帧时，它会首先清除屏幕。Unity中的默认相机通过用渐变色给一切上色来实现这一点，模拟天空盒的外观。然后，所有的游戏网格都会绘制在这块空白的屏幕上。尽管渐变色比单一颜色看起来更好，但对于坦克的激烈战斗来说，它仍然相当乏味。幸运的是，Unity允许我们更改天空盒。天空盒只是指形成任何游戏背景天空的一系列图像的华丽说法。距离雾与天空盒配合使用，通过在模型和背景之间平滑视觉过渡。
- en: 'The very first thing we need is a new skybox. We can create our own, however,
    Unity provides us with several excellent ones that will fit our needs just fine.
    Let''s use the following steps to get a skybox now:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是一个新天空盒。我们可以创建自己的，但是Unity为我们提供了几个非常适合我们需求的优秀天空盒。以下是获取天空盒的步骤：
- en: At the top of the Unity Editor, select **Assets** and then click on **Import
    Package**. About halfway down this list, select **Skyboxes**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，选择**资源**，然后点击**导入包**。在这个列表大约一半的位置，选择**天空盒**。
- en: After a little bit of processing, a new window will pop up. A package in Unity
    is just a compressed group of assets that have already been set up in Unity. This
    window displays the contents and allows you to selectively import them. We want
    them all, so we just click on **Import** in the bottom-right corner of this window.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过一点处理，一个新的窗口会弹出。在Unity中，包只是一个已经设置好的压缩资产组。这个窗口显示内容并允许你选择性地导入它们。我们想要全部，所以只需点击此窗口右下角的**导入**。
- en: A new folder, `Standard Assets`, will be added to the **Project** window. This
    contains a folder, `Skyboxes`, which contains various skybox materials. Select
    any one of these. You can see in the **Inspector** window that they are normal
    materials that make use of the skybox shader. They each have six images, one for
    each direction of a box.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，将添加一个名为`Standard Assets`的新文件夹。其中包含一个名为`Skyboxes`的文件夹，里面包含各种天空盒材质。选择其中任何一个。你可以在**检查器**窗口看到，它们是使用天空盒着色器的普通材质。它们每个都有六张图片，代表一个立方体的每个方向。
- en: You will also notice that there are warning messages with a **Fix Now** button
    under each image. This is because all the images were compressed to save import
    time and space, but the skybox shader needs them in a different format. Just click
    on the **Fix Now** button each time and Unity will automatically fix it for you.
    It will also get rid of all of the odd blackness in the material preview.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还会注意到，每张图片下方都有带有**立即修复**按钮的警告信息。这是因为所有图片都被压缩以节省导入时间和空间，但天空盒着色器需要它们以不同的格式。只需每次点击**立即修复**按钮，Unity
    就会自动为你修复。它还将消除材质预览中的所有奇怪的黑色。
- en: To add a skybox of your choice to the game, first make sure that you have the
    correct scene loaded. If you do not, simply double-click on the scene in the **Project**
    window. This is necessary because the settings we are about to change are specific
    to each scene.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将你选择的天空盒添加到游戏中，首先确保你已经加载了正确的场景。如果没有，只需在**项目**窗口中双击场景。这是必要的，因为我们即将更改的设置是针对每个场景的。
- en: Go to the top of the Unity Editor and select **Edit** and then click on **Scene
    Render Settings**. The new group of settings will appear in the **Inspector**
    window.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器顶部，选择**编辑**，然后点击**场景渲染设置**。新的设置组将出现在**检查器**窗口中。
- en: At the moment, we are concerned with the value at the top, **Skybox Material**.
    Just drag and drop the new skybox material into the **Skybox Material** slot and
    it will be automatically updated. The change can be viewed right away in the **Game**
    and **Scene** windows.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们关注的是顶部的值，即**天空盒材质**。只需将新的天空盒材质拖放到**天空盒材质**槽中，它就会自动更新。这个更改可以在**游戏**和**场景**窗口立即查看。
- en: To add distance fog, we also adjust this setting in **Scene Render Settings**.
    To turn it on, simply tick the **Use Fog** checkbox.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加距离雾，我们还需在**场景渲染设置**中调整这个设置。要开启它，只需勾选**使用雾**复选框。
- en: The next setting, **Fog Color**, allows you to pick a color for the fog. It
    is good to pick a color that is close to the general color of the skybox.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个设置，**雾颜色**，允许你为雾选择一个颜色。选择一个接近天空盒总体颜色的颜色是好的。
- en: The **Fog Mode** setting is a drop-down list of options that dictate the method
    that Unity will use to calculate the distance fog. For nearly all cases, the default
    setting of **Exponential Squared** is suitable.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**雾模式**设置是一个下拉列表，其中包含决定 Unity 计算距离雾的方法的选项。在几乎所有情况下，默认设置**指数平方**是适用的。'
- en: The next three settings, **Density**, **Start**, and **End**, determine how
    much fog there is and how close it starts. They will only appear for the fog modes
    that use them. **Density** is used for the **Exponential** and **Exponential Squared**
    fog modes, while the others are used for the **Linear** fog mode. Settings that
    put the fog at the edge of sight will, in general, give the best-looking effect.
    Leave these settings on **Exponential Squared** and choose `0.03` for the **Density**
    in order to get a good look.![Skyboxes and distance fog](img/4691OT_04_01.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个设置，**密度**、**开始**和**结束**，决定了有多少雾以及它从多近的距离开始。它们只会在使用这些设置的雾模式下出现。**密度**用于**指数**和**指数平方**雾模式，而其他设置用于**线性**雾模式。将雾设置在视线边缘通常会产生最佳视觉效果。将这些设置保持在**指数平方**，并将**密度**选择为`0.03`以获得良好的视觉效果。![天空盒和距离雾](img/4691OT_04_01.jpg)
- en: We have imported several skyboxes and added them to the scene. The distance
    fog settings are also turned on and adjusted. Now, our scene has started to look
    like a real game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了几种天空盒，并将它们添加到了场景中。距离雾设置也已开启并调整。现在，我们的场景开始看起来像一个真正的游戏。
- en: Target indicator
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标指示器
- en: Another camera effect that is rather interesting is the use of multiple cameras.
    A second camera can be used to make a 3D GUI, a minimap, or perhaps a security
    camera popup. In the next section, we will be creating a system that will point
    at targets that are nearby. Using a second camera, we will make the indicators
    appear above the player's tank.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当有趣的摄像头效果是使用多个摄像头。第二个摄像头可以用来制作3D GUI、小地图，或者可能是安全摄像头弹出窗口。在下一节中，我们将创建一个系统，该系统将指向附近的的目标。使用第二个摄像头，我们将使指示器出现在玩家坦克的上方。
- en: Creating the pointer
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建指针
- en: 'We are going to start by creating an object that will point at targets. We
    will be making a prefab that can be used repeatedly. However, you will need to
    import the `IndicatorSliceMesh.blend` starting asset for this chapter, so we have
    something for the player to see. It is a pie-slice-shaped mesh. Let''s perform
    the following steps to create the pointer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个指向目标的物体开始。我们将制作一个可以重复使用的预制体。但是，为此章节，你需要导入`IndicatorSliceMesh.blend`起始资源，这样我们才有东西供玩家查看。它是一个饼状切片形状的网格。下面我们执行以下步骤来创建指针：
- en: Once you have the mesh imported, add it to the scene.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入网格后，将其添加到场景中。
- en: Create an empty **GameObject** component and rename it to `IndicatorSlice`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的**GameObject**组件，并将其重命名为`IndicatorSlice`。
- en: Make the mesh a child of `IndicatorSlice` and position it so that it points
    along the *z* axis of `GameObject`, with the small end of the pie slice being
    at the position of `IndicatorSlice`. The `IndicatorSlice` GameObject will be centered
    in our indicator. Each slice that is created will have its *z* axis pointing in
    the direction of a target, as shown in the following figure:![Creating the pointer](img/4691OT_04_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网格设置为`IndicatorSlice`的子对象，并将其定位，使其沿着`GameObject`的*z*轴指向，饼状切片的小端位于`IndicatorSlice`的位置。`IndicatorSlice`
    GameObject 将位于我们指示器的中心。创建的每个切片都将使其*z*轴指向目标的方向，如下图所示：![Creating the pointer](img/4691OT_04_02.jpg)
- en: Now, we need to create a new script that will control our indicator. Create
    a new script called `TargetIndicator` in the **Project** window.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的脚本来控制我们的指示器。在**项目**窗口中创建一个名为`TargetIndicator`的新脚本。
- en: 'We start off this script with a pair of variables. The first variable will
    hold a reference to the target that this indicator piece will point at. The indicator
    is also going to grow and shrink, based on how far away the target is. The second
    variable will control the distance at which the indicator will start to grow:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个脚本开始使用一对变量。第一个变量将保存对此指示器片段将指向的目标的引用。指示器也会根据目标距离的远近来增长和缩小。第二个变量将控制指示器开始增长的距离：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next function will be used to set the `target` variable when the indicator
    piece is created:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将在创建指示器片段时用来设置`target`变量：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last set of code goes in the `LateUpdate` function. The `LateUpdate` function
    is used so that the indicator pieces can point at a target after our tank moves
    in the `Update` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一组代码放入`LateUpdate`函数中。使用`LateUpdate`函数，指示器片段可以在我们的坦克在`Update`函数中移动后指向目标：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We start the function by checking whether the `target` variable has a value.
    If it is null, the indicator slice is destroyed. The `Destroy` function can be
    used to remove any object that exists from the game. The `gameObject` variable
    is automatically provided by the `MonoBehaviour` class and holds a reference to
    the **GameObject** component that the script component is attached to. Destroying
    this component will also destroy everything that is a child of (or attached to)
    it:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查`target`变量是否有值。如果是null，则销毁指示器片段。`Destroy`函数可以用来移除游戏中的任何对象。`gameObject`变量由`MonoBehaviour`类自动提供，并保存了对脚本组件所附加的**GameObject**组件的引用。销毁这个组件也会销毁所有其子对象（或附加的对象）：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we determine how far this indicator slice is from its target. By using
    `Vector3.Distance`, we can easily calculate the distance without doing the math
    ourselves:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们确定这个指示器片段距离其目标有多远。通过使用`Vector3.Distance`，我们可以轻松地计算出距离，而不需要我们自己进行数学计算：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line of code determines the vertical scale, *y* axis, of the slice. It
    does so by using a bit of carefully applied math and the `Mathf.Clamp01` function.
    This function limits the supplied value to be between zero and one:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码通过使用一些精心应用的数学和`Mathf.Clamp01`函数，确定了片段的垂直缩放，即*y*轴。这个函数将提供的值限制在零和一之间：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use the calculated scale to set the indicator slice''s local scale. By adjusting
    the local scale, we can easily control how big the whole indicator is just by
    changing the scale of the parent object:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用计算出的比例来设置指示器切片的局部比例。通过调整局部比例，我们可以通过改变父对象的比例轻松控制整个指示器的大小：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `transform.LookAt` function is just a fancy, automatic way of rotating
    a GameObject so that its *z* axis points to a specific spot in the world. However,
    we want all the indicator slices to lie flat on the ground and not point into
    the air at any targets that might be above us. So, we first collect the target''s
    position. By setting the variable''s `y` value to the position of the slice, we
    ensure that the slice remains flat. That last line, of course, closes off the
    `LateUpdate` function:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transform.LookAt`函数只是一种花哨、自动的方式，用于旋转GameObject，使其*z*轴指向世界中的特定位置。但是，我们希望所有的指示器切片都平铺在地面上，而不是指向可能在上方我们任何目标。因此，我们首先收集目标的位置。通过将变量的`y`值设置为切片的位置，我们确保切片保持平坦。当然，最后一行结束了`LateUpdate`函数：'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is the last code for this script. Return to Unity and add
    the `TargetIndicator` script to the `IndicatorSlice` object in the scene.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码是此脚本的最后一段代码。回到Unity，并将`TargetIndicator`脚本添加到场景中的`IndicatorSlice`对象。
- en: To finish off the indicator, create a prefab of it. Do it just like we did for
    our target objects.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成指示器，请创建它的预制件。就像我们对目标对象所做的那样。
- en: Lastly, delete the `IndicatorSlice` object from the scene. We will be creating
    slices dynamically when the game starts. This requires the prefab, but not the
    one in the scene.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从场景中删除`IndicatorSlice`对象。游戏开始时，我们将动态创建切片。这需要预制件，但不需要场景中的那个。
- en: We created a prefab of the object we will be using to indicate the direction
    of targets. The script that was created and attached will rotate each instance
    of the prefab to point at the targets in the scene. It will also adjust the scale
    to indicate how far away the targets are from the player.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个预制件，该预制件将用于指示目标的方向。创建并附加的脚本将旋转每个预制件实例，使其指向场景中的目标。它还将调整比例，以显示目标与玩家之间的距离。
- en: Controlling the indicator
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制指示器
- en: 'We now need to create a script that will control the indicator slices. This
    will include creating new slices as they are needed. Also, the **GameObject**
    component it is attached to will act as a center point for the indicator slices,
    which we just created, to rotate around. Let''s perform these steps to do this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个控制指示器切片的脚本。这将包括在需要时创建新的切片。此外，它所附加的**GameObject**组件将作为我们刚刚创建的指示器切片围绕旋转的中心点。让我们执行以下步骤来完成这些操作：
- en: Create a new script and name it `IndicatorControl`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`IndicatorControl`。
- en: 'We start off this script with a pair of variables. The first variable will
    hold a reference to the prefab that was just created. This will allow us to spawn
    instances of the prefab whenever we desire. The second is a static variable, which
    means that it can be easily accessed without a reference to the component that
    exists in the scene. It will be filled when the game starts with a reference to
    the instance of this script that is in the scene:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个脚本开始使用一对变量。第一个变量将保存对刚刚创建的预制件的引用。这样，我们就可以在需要时生成预制件的实例。第二个是一个静态变量，这意味着它可以轻松访问，无需引用场景中存在的组件。游戏开始时，它将被填充为场景中此脚本实例的引用：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next function will be used by the targets. Soon, we will be updating the
    target''s script to call this function at the beginning of the game. The function
    is static, just like the preceding variable:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数将由目标使用。很快，我们将更新目标的脚本，以便在游戏开始时调用这个函数。该函数是静态的，就像前面的变量一样：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function starts by checking whether there is a reference to any object
    in the static variable. If it is empty, equal to `null`, `Object.FindObjectOfType`
    is used to fill the variable. By telling it what type of object we want to find,
    it will search in the game and try to find one. This is a relatively slow process
    and should not be used often, but we use this process and the variable so that
    we can always be sure that the system can find the script:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数首先检查静态变量中是否有对任何对象的引用。如果它是空的，等于`null`，则使用`Object.FindObjectOfType`填充变量。通过告诉它我们想要查找什么类型的对象，它将在游戏中搜索并尝试找到。这是一个相对较慢的过程，不应该经常使用，但我们使用这个过程和变量，以便始终确保系统能找到脚本：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second part of the `CreateSlice` function checks to make sure that our
    static variable is not empty. If so, it tells the instance to create a new indicator
    slice and passes the target to the slice:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateSlice`函数的第二部分检查以确保我们的静态变量不为空。如果为空，它告诉实例创建一个新的指示器切片，并将目标传递给切片：'
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is one more function for this script: `NewSlice`. The `NewSlice` function
    does as its name implies; it will create new indicator slices when called:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本还有一个函数：`NewSlice`。`NewSlice`函数如其名所示，当被调用时会创建新的指示器切片：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function first uses the `Instantiate` function to create a copy of `indicatorPrefab`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数首先使用`Instantiate`函数创建`indicatorPrefab`的副本：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, the function makes the new slice a child of the control''s transform,
    so it will stay with us as we move around. By zeroing out the local position of
    the new slice, we also insure that it will be at the same location as our control:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，函数将新的切片设置为控制转换的子对象，这样在我们移动时它会跟随着我们。通过将新切片的本地位置归零，我们还确保它会与我们的控制处于同一位置：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last line of the function uses the slice''s `SendMessage` function to call
    the `SetTarget` function that we created previously and passes it the desired
    target object:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最后一条线使用切片的`SendMessage`函数调用我们之前创建的`SetTarget`函数，并传递所需的目标对象：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that the script is created, we need to use it. Create an empty **GameObject**
    component and name it `IndicatorControl`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在脚本已经创建好了，我们需要使用它。创建一个空的**GameObject**组件，并将其命名为`IndicatorControl`。
- en: The new **GameObject** component needs to be made a child of the tank, followed
    by having its position set to zero on each axis.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的**GameObject**组件需要设置为坦克的子对象，然后将其在每个轴上的位置设置为0。
- en: Add the script we just created to the `IndicatorControl` object.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚创建的脚本添加到`IndicatorControl`对象上。
- en: Finally, with the GameObject selected, add the reference to the `IndicatorSlice`
    prefab. Do this by dragging the prefab from the **Project** window to the proper
    slot in the **Inspector** window.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择GameObject，将`IndicatorSlice`预制体的引用添加到**Inspector**窗口中适当的槽位，通过从**Project**窗口拖动预制体来实现。
- en: We created a script that will control the spawning of our target indicator slices.
    The **GameObject** component we created at the end will also allow us to control
    the size of the whole indicator with ease. We are almost done with the target
    indicator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本来控制目标指示器切片的生成。我们最后创建的**GameObject**组件还能轻松地让我们控制整个指示器的大小。我们几乎完成了目标指示器的工作。
- en: Working with a second camera
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用第二个摄像头
- en: 'If you were to play the game now, it will still look no different. This is
    because the targets do not make the call yet to create the indicator slices. We
    will also be adding the second camera in this section as we finish off with the
    target indicator. These steps will help us do it well:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，看起来不会有任何不同。这是因为目标还没有调用创建指示器切片的命令。我们还将在这个部分添加第二个摄像头，完成目标指示器的工作。以下步骤将帮助我们做好这件事：
- en: 'Start by opening the `Target` script and adding the following line of code
    at the end of the `Awake` function. This line tells the `IndicatorControl` script
    to create a new indicator slice for this target:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开`Target`脚本，在`Awake`函数的末尾添加以下代码行。这行代码告诉`IndicatorControl`脚本为这个目标创建一个新的指示器切片：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Working with a second camera](img/4691OT_04_03.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用第二个摄像头](img/4691OT_04_03.jpg)'
- en: If you play the game now, you can see the indicator in action. However, it is
    probably too large and certainly appears inside the tank. A bad solution will
    be to move the `IndicatorControl` object until the whole thing appears above the
    tank. However, when explosions occur and things start flying through the air,
    they will obscure the target indicator all over again. A better solution is to
    add a second camera. You can do so now by selecting **GameObject** from the top
    of the Unity Editor and then clicking on **Camera**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，可以看到指示器的运行效果。但是它可能太大，而且肯定显示在坦克内部。一个糟糕的解决方案是将`IndicatorControl`对象移动，直到整个指示器显示在坦克上方。然而，当发生爆炸，物体开始空中飞散时，它们会再次遮挡目标指示器。一个更好的解决方案是添加第二个摄像头。现在你可以通过从Unity编辑器顶部选择**GameObject**，然后点击**Camera**来添加。
- en: Additionally, make the camera a child of `Main Camera`. Be sure to set the new
    camera's position and rotation values to `0`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将摄像头设置为`Main Camera`的子对象。确保将新摄像头的位置和旋转值设置为`0`。
- en: 'By default, every camera in Unity is given a variety of components: **Camera**,
    **Flare Layer**, **GUI Layer**, and **Audio Listener**. Besides the **Camera**
    component, the others are generally unimportant to every other camera, and there
    should only be one **Audio Listener** component in the whole of the scene. Remove
    the excess components from the camera, leaving just the **Camera** component.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Unity中的每个摄像机都会有一系列组件：**摄像机**、**光晕层**、**GUI层**和**音频监听器**。除了**摄像机**组件之外，其他组件通常对其他每个摄像机来说都不重要，整个场景中应该只有一个**音频监听器**组件。从摄像机中移除多余的组件，只留下**摄像机**组件。
- en: Before we do anything else with the camera, we need to change the layer that
    the `IndicatorSlice` prefab is on. Layers are used for selective interaction between
    objects. They are used primarily for physics and rendering. First select the prefab
    in the **Project** window.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们对摄像机进行任何其他操作之前，需要更改`IndicatorSlice`预制体的层。层用于对象之间的选择性交互。它们主要用于物理和渲染。首先在**项目**窗口中选择预制体。
- en: At the top of the **Inspector** window is the **Layer** label with a drop-down
    list that reads **Default**. Click on the drop-down list and select **Add Layer...**
    from the list.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的顶部是标签为**层**的下拉列表，默认显示**默认**。点击下拉列表，并从列表中选择**添加层...**。
- en: A list of layers will now appear in the **Inspector** window. These are all
    the layers that are used in the game. The first few are reserved for use by Unity;
    hence, they have been grayed out. The rest are for our use. Click on the input
    box at the right-hand side of **User Layer 8** and name it `Indicator`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中将会出现一个层列表。这些是游戏中使用的所有层。前几个被Unity保留使用，因此它们被灰显。其余的供我们使用。点击**用户层8**右侧的输入框，并将其命名为`Indicator`。
- en: Select the `IndicatorSlice` prefab again. This time, select the new **Indicator**
    layer from the **Layer** drop-down list.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择`IndicatorSlice`预制体。这次，从**层**下拉列表中选择新的**指示器**层。
- en: Unity will ask whether you want to change the layer of all the child objects
    as well. We want the whole object rendered on this layer, so we need to select
    **Yes, change children** and we will be able to do so.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity会询问你是否也想改变所有子对象的层。我们希望整个对象在此层上渲染，因此我们需要选择**是的，改变子对象**，这样我们就能做到。
- en: Now, let's get back to our second camera. Select the camera and take a look
    at the **Inspector** window.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到第二个摄像机。选择摄像机并查看**检查器**窗口。
- en: The first attribute of the **Camera** component is **Clear Flags**. This list
    of options dictate what the camera will fill the background with before drawing
    all the models in the game. The second camera should not block out everything
    drawn by the first camera. We select **Depth only** from the **Clear Flags** drop-down
    list. This means that instead of putting the skybox in the background, it will
    leave what was already rendered and just draw new things on top.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**摄像机**组件的第一个属性是**清除标志**。这个选项列表决定了摄像机在绘制游戏中的所有模型之前，将用什么来填充背景。第二个摄像机不应该挡住第一个摄像机绘制的一切。我们从**清除标志**下拉列表中选择**仅深度**。这意味着它不会在背景中放置天空盒，而是保留已经渲染的内容，只在新内容上绘制。'
- en: The next attribute, **Culling Mask**, controls which layers are rendered by
    the camera. The first two options, **Nothing** and **Everything**, are for the
    quick deselection and selection of all the layers. For this camera, deselect all
    other layers so that only the **Indicator** layer has a check next to it.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个属性，**剔除遮罩**，控制摄像机渲染哪些层。前两个选项，**无**和**全部**，用于快速取消选择和选择所有层。对于这个摄像机，取消选择其他所有层，使得只有**指示器**层旁边有勾选标记。
- en: The last thing to do is to adjust the scale of `IndicatorControl` so that the
    target indicator is not too large or small.![Working with a second camera](img/4691OT_04_04.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做的最后一件事是调整`IndicatorControl`的缩放，使得目标指示器不会太大或太小。![使用第二个摄像机](img/4691OT_04_04.jpg)
- en: We created a system to indicate the direction of potential targets. To do this,
    we used a second camera. By adjusting the layers in the **Culling Mask** attribute,
    we can make a camera render only a part of the scene. Also, by changing the **Clear
    Flags** attribute to **Depth only**, the second camera can draw on top of what
    was drawn by the first camera.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个系统来指示潜在目标的方向。为此，我们使用了第二个摄像机。通过调整**剔除遮罩**属性中的层，我们可以使摄像机只渲染场景的一部分。同时，将**清除标志**属性更改为**仅深度**，第二个摄像机可以在第一个摄像机绘制的内容上绘制。
- en: It is possible to change where the indicator is drawn by moving the camera.
    If you were to move the `IndicatorControl` object instead, it will change how
    the distance from the targets and the directions to target are calculated. Move
    and angle the second camera so that there is a more pleasing view of the target
    indicator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移动摄像头，可以改变指示器显示的位置。如果你移动`IndicatorControl`对象，它将改变目标距离和目标方向的计算方式。移动并调整第二个摄像头的角度，以便更美观地显示目标指示器。
- en: When you move the second camera or when you use the boost (from the next section),
    you will probably notice that the target indicator can still be seen in the tank.
    Adjust the main camera so that it does not render the target indicator. This is
    done similarly to how we made the second camera only render the target indicator
    objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动第二个摄像头或使用加速功能（下一节内容）时，你可能会注意到目标指示器仍然可以在坦克内看到。调整主摄像头，使其不渲染目标指示器。这类似于我们如何让第二个摄像头只渲染目标指示器对象。
- en: Turbo boost
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涡轮加速
- en: The last camera effect that we will be looking at in this chapter is a turbo
    boost. It is going to be a button on the screen that will propel the player forward
    rapidly for a short amount of time. The camera effect comes in because a simple
    adjustment to the **Field of View** attribute can make it look as if we are going
    much faster. A similar method is used in movies to make car chases look even faster
    than they are.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们要看的最后一个摄像头效果是涡轮增压。它将在屏幕上是一个按钮，可以迅速推动玩家向前移动一段短暂的时间。摄像头效果之所以出现，是因为简单调整**视野**属性，就能让我们看起来移动得更快。电影中在汽车追逐场景中使用了类似的方法，让追逐看起来比实际更快。
- en: 'We will only be making a single script in this section. The script will move
    the tank in a similar manner to the `ChassisControls` script we created in the
    last chapter. The difference is that we won''t have to hold down a button for
    the boost to work. Let''s get to it with these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们只会制作一个脚本。该脚本将使坦克以类似于上一章中创建的`ChassisControls`脚本的方式移动。不同之处在于，我们不需要按下一个按钮就能使加速生效。下面是操作步骤：
- en: Start by creating a new script and calling it `TurboBoost`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新脚本，并将其命名为`TurboBoost`。
- en: 'To start off the script, we need four variables. The first variable is a reference
    to the `CharacterController` component on the tank. We need this for movement.
    The second variable is how fast we will be moving while boosting. The third is
    for how long, in seconds, we will be boosting. The last is used internally for
    whether or not we can boost and when we should stop:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始脚本，我们需要四个变量。第一个变量是对坦克上`CharacterController`组件的引用。我们需要它来进行移动。第二个变量是我们在加速时移动的速度。第三个变量是加速持续的时间，以秒为单位。最后一个变量用于内部判断我们是否可以加速以及何时应该停止：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `StartBoost` function is pretty simple. It checks whether the `startTime`
    variable is less than zero. If it is, the variable is set to the current time
    as provided by `Time.time`. The value of the variable being less than zero means
    that we are not boosting currently:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartBoost`函数非常简单。它检查`startTime`变量是否小于零。如果是，将该变量设置为由`Time.time`提供的当前时间。该变量小于零意味着我们当前没有在加速：'
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last function we are going to use is the `Update` function. It begins with
    a check of `startTime` to see whether we are currently boosting. If we are not
    boosting, the function is exited early. The next line of code checks to make sure
    that we have our `CharacterController` reference. If the variable is empty, then
    we can''t make the tank move:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要使用的最后一个函数是`Update`函数。它首先检查`startTime`以确定我们当前是否正在加速。如果我们没有在加速，函数会提前退出。下一行代码检查以确保我们拥有`CharacterController`的引用。如果该变量为空，那么我们就无法让坦克移动：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next line of code should look familiar. This is the line that makes the
    tank move:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码应该看起来很熟悉。这是让坦克移动的那一行：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, check whether we are in the first half-second of the boost. By comparing
    the current time with the time that was recorded when we started, we can easily
    figure out for how long we have been boosting:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查我们是否处于加速的前半秒。通过将当前时间与开始加速时记录的时间进行比较，我们可以轻松地计算出我们已经加速了多长时间：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the time is right, we transition the camera by adjusting the `fieldOfView`
    value. The `Camera.main` value is just a reference provided by Unity to the main
    camera used in the scene. The `Mathf.Lerp` function takes a starting value and
    moves this value toward the goal value based on a third value between zero and
    one. Using this, the camera''s `fieldOfView` value is moved toward our goal over
    the half-second:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果时间合适，我们会通过调整`fieldOfView`值来转换相机。`Camera.main`值是Unity提供的一个引用，指向场景中使用的主相机。`Mathf.Lerp`函数根据零到一之间的第三个值，从起始值向目标值移动。使用这个，相机的`fieldOfView`值会在半秒内向我们的目标值移动。
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next piece of code does the same thing as the previous two, except for
    the last half-second of our boost, and uses the same method to transition the
    `fieldOfView` value back to the default:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一段代码与前面两段相同，除了在加速的最后半秒，并使用相同的方法将`fieldOfView`值恢复到默认：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last bit of code checks whether we are done with boosting. If so, `startTime`
    is set to `-1` in order to indicate that we can start another boost. That last
    curly brace, of course, closes off the `Update` function:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一段代码检查我们是否完成了加速。如果是这样，将`startTime`设置为`-1`以表示我们可以开始另一次加速。最后的那个大括号，当然，关闭了`Update`函数：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, add the script to your tank and connect the `CharacterController` reference.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将脚本添加到你的坦克上，并连接`CharacterController`引用。
- en: We are almost done. We need to create a new button. We can do this just like
    we have done before. Anchor the button to the bottom-right corner of **Canvas**
    and position it just above the chassis' movement controls.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们快完成了。我们需要创建一个新的按钮。我们可以像以前一样做。将按钮锚定到**画布**的右下角，并将其定位在底盘移动控制之上。
- en: Last, be sure to select `Tank` for the **OnClick** object and navigate to **Turbo
    Boost** | **StartBoost ()** for the function.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确保为**OnClick**对象选择`Tank`，并在功能中导航至**涡轮增压** | **StartBoost()**。
- en: Try this out.![Turbo boost](img/4691OT_04_05.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试这个吧。![涡轮增压](img/4691OT_04_05.jpg)
- en: We created a turbo boost here. The same method of movement that we used in the
    previous chapter moves the tank here. By adjusting the **Field of View** attribute
    of the camera, we make it look like the tank is moving even faster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个涡轮增压。我们在前一章中使用的方法同样用于移动这里的坦克。通过调整相机的**视野**属性，我们使坦克看起来移动得更快。
- en: You might notice while playing the game that you can turn even when boosting.
    Try adding a check to the `ChassisControls` script in order to lock the controls,
    at the time of boosting. You need to add a reference to the `TurboBoost` script
    to do this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，你可能会注意到即使在加速时也可以转向。尝试在`ChassisControls`脚本中添加一个检查，以在加速时锁定控制。为此，你需要添加对`TurboBoost`脚本的引用。
- en: 'For an additional, extra challenge, try adding a cooldown to the boost. Make
    it such that the player can''t constantly use the boost. Also, try canceling the
    boost if the tank runs into something. This is a hard one, so here''s a hint to
    start with: take a look at `OnControllerColliderHit` in the Unity documentation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加额外的挑战，尝试给加速添加一个冷却时间。让玩家不能持续使用加速。另外，如果坦克撞到某物，尝试取消加速。这是一个难题，所以这里有一个提示：先查看Unity文档中的`OnControllerColliderHit`。
- en: Lights
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光
- en: 'Unity provides a variety of light types for brightening the game world. They
    are **Directional Light**, **Spotlight**, **Point Light**, and **Area Light**.
    Each of these projects light in a different way; they are explained in detail
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了多种光类型来照亮游戏世界。它们分别是**方向光**、**聚光灯**、**点光源**和**区域光**。这些光以不同的方式投射光线；以下是它们的详细解释：
- en: '**Directional Light**: This functions much like the sun. It projects all of
    its light in a single direction. The position of the light does not matter, only
    the rotation does. Light is projected over the entire scene in one direction.
    This makes it perfect for initially adding light to a scene.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**：这类似于太阳。它将所有光线沿单一方向投射。光的位置无关紧要，重要的是旋转。光线以一个方向投射到整个场景。这使得它非常适合初步为场景添加光线。'
- en: '**Spotlight**: This functions just like the lights on a stage. Light is projected
    in a cone-like shape in a specific direction. Because of this, it is also the
    most complex light type for the system to calculate. Unity has made significant
    improvements on how it calculates lights, but an overuse of these lights should
    be avoided.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：这就像舞台上的灯光一样工作。光线以类似圆锥的形状沿特定方向投射。因此，这也是系统计算中最复杂的光类型。Unity对其计算光线的方式进行了重大改进，但应避免过度使用这些灯光。'
- en: '**Point Light**: This is the primary light type that will be used in your games.
    It emits light in every direction. This functions just like a light bulb.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这是在游戏中主要使用的光源类型。它向四面八方发射光线。这就像一个灯泡。'
- en: '**Area Light**: This is a special-use light. It emits light in a single direction
    from a plane. Think of it as a big neon sign used to advertise a hotel or restaurant.
    Because of their complexity, these lights can only be used when baking shadows.
    There are too many calculations for them to be used when the game is running.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域光源**：这是一种特殊用途的光源。它从平面单一方向发射光线。可以把它想象成用来为酒店或餐厅做广告的大型霓虹灯。由于它们的复杂性，这些光源只能在烘焙阴影时使用。当游戏运行时，它们的计算量太大，无法使用。'
- en: The next obvious question when talking about lights concerns shadows, especially
    real-time shadows. While real-time shadows add a lot to a scene and are technically
    possible on any platform, they are very expensive. On top of that, they are a
    Unity Pro feature for all light types, except **Directional Lights**. All in all,
    this makes them a bit too much for your average mobile game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论灯光时，下一个明显的问题涉及到阴影，尤其是实时阴影。虽然实时阴影为场景增加了许多效果，并且在任何平台上技术上都是可能的，但它们的成本非常高。除此之外，对于所有光源类型，除了**方向光**，它们都是Unity
    Pro功能。总的来说，这对于一般的移动游戏来说有点过于昂贵了。
- en: On the other hand, there are perfectly viable alternatives that do not cost
    nearly as much and often look more realistic than real-time shadows. The first
    alternative is for your environment. In general, the environment in a game never
    moves and never changes within a specific scene. For this, we have lightmaps.
    They are extra textures that contain shadow data. Using Unity, you can create
    these textures while making your game. Then, when the game is running, they are
    automatically applied and your shadows appear. This, however, does not work for
    dynamic objects (anything that moves).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些成本几乎不高的完美替代方案，它们通常比实时阴影看起来更真实。第一种替代方案是针对你的游戏环境。通常情况下，游戏中的环境在特定场景内不会移动也不会改变。为此，我们有光照图。它们是包含阴影数据的额外纹理。使用Unity，你可以在制作游戏时创建这些纹理。然后，当游戏运行时，它们会自动应用，阴影就会出现。然而，这对于动态物体（任何会移动的东西）并不适用。
- en: For dynamic objects, we have cookies. These are not your grandmother's cookies.
    In lighting, a cookie is a black and white image that is projected onto meshes
    in the game. This is similar to shadow puppets. Shadow puppets use a cutout to
    block a part of the light, whereas cookies use black and white images to tell
    the light where it can cast its light.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态物体，我们有“cookies”。这可不是你奶奶做的饼干。在照明中，cookie是一个黑白图像，它被投影到游戏中的网格上。这类似于皮影戏。皮影戏使用剪片来阻挡部分光线，而cookies则使用黑白图像来告诉光线可以投射光亮的位置。
- en: Cookies can also be used to create other good effects, both static and dynamic,
    such as a cloud cover that pans across the scene or, perhaps, light projecting
    out from a cage. Or, you can use them to make the uneven focus point of a flashlight.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies还可以用来创建其他静态和动态效果，比如在场景中移动的云层覆盖，或者从笼子中投射出的光线。或者，你可以使用它们来制作手电筒不均匀的焦点。
- en: Adding more lights
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多灯光
- en: 'It is rather simple to add additional lights to the scene. Also, as long as
    one sticks to point lights, the cost to render them stays low. Let''s use these
    steps to light up our game:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景中添加额外的灯光相当简单。而且，只要坚持使用点光源，渲染它们的成本就会保持较低。让我们使用以下步骤来照亮我们的游戏：
- en: At the top of the Unity Editor, navigate to **GameObject** | **Light** | **Point
    Light**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器顶部，导航到 **GameObject** | **Light** | **Point Light**。
- en: 'With the new light selected, these are a few attributes that we should be concerned
    about in the **Inspector** window:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的光源后，在**检查器**窗口中我们应该关注以下几个属性：
- en: '**Range**: This is how far light will be emitted from the object. The light
    emitted from this point is brightest at the center and fades to nothing as it
    reaches the extent of the range. The range is additionally represented as a yellow-colored
    wire sphere in the **Scene** view.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：这是光线从物体发射的距离。从这个点发出的光在中心位置最亮，在达到范围极限时逐渐消失。范围在**场景**视图中还以黄色线框球体表示。'
- en: '**Color**: This is simply the color of the light. By default, it is white;
    however, any color can be used here. This setting is shared between all the light
    types.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：这仅仅是光线的颜色。默认情况下，它是白色；然而，这里可以使用任何颜色。这个设置在所有光源类型之间共享。'
- en: '**Intensity**: This denotes the brightness of the light. The greater the intensity
    of the light, the brighter will be the light at its center. This setting is also
    shared between all the light types.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强度**：这表示光的亮度。光的强度越大，其中心的亮度也就越亮。这个设置对所有类型的灯光都是共享的。'
- en: Create and position several more lights, arranging them along the streets to
    add some more interesting elements to the environment.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并定位更多的灯光，沿着街道排列，为环境添加一些更有趣的元素。
- en: Press *Ctrl* + *D* to duplicate the selected object. This can greatly speed
    up the creation process (like the one shown in the following screenshot):![Adding
    more lights](img/4691OT_04_06.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *D* 来复制选定的对象。这可以大大加快创建过程（如下面的截图所示）：![添加更多灯光](img/4691OT_04_06.jpg)
- en: While adding these lights, you probably noticed one of their major drawbacks.
    There is a limit to the number of lights that will affect a surface in real time.
    It is possible to somewhat work around this by using more complex meshes. A better
    option is to use lightmaps, which we'll be seeing in the next section.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加这些灯光时，你可能注意到了它们的一个主要缺点。实时影响一个表面的灯光数量是有限制的。通过使用更复杂的网格，可以在一定程度上解决这个问题。更好的选择是使用光照图，我们将在下一节中看到。
- en: At the top of the Unity Editor again, navigate to **GameObject** | **Light**
    | **Spotlight**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在Unity编辑器顶部，导航到**游戏对象** | **灯光** | **聚光灯**。
- en: Select a new light and take a look at it in the **Inspector** window.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一盏新灯，并在**检查器**窗口中查看它。
- en: '**Spot Angle**: This is unique to this type of light. It dictates how wide
    the cone of the emitted light will be. Together with **Range**, it is represented
    by a yellow-colored wire cone in the **Scene** view.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**聚光角度**：这是这种类型灯光独有的。它决定了发射光的锥形有多宽。与**范围**一起，在**场景**视图中由一个黄色线框锥形表示。'
- en: Add a few spotlights around the fountain in the center of our Tank Battle city,
    as shown in the following screenshot:![Adding more lights](img/4691OT_04_07.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在坦克大战城市中心的喷泉周围添加几个聚光灯，如下面的截图所示：![添加更多灯光](img/4691OT_04_07.jpg)
- en: Having so many objects in a scene clutters the **Hierarchy** window, making
    it hard to find anything. To organize it, you can use empty GameObjects. Create
    a **GameObject** and name it `PointLights`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景中拥有如此多的对象使得**层次结构**窗口显得杂乱无章，难以找到任何东西。为了组织它们，你可以使用空的游戏对象。创建一个**游戏对象**，并将其命名为
    `PointLights`。
- en: By making all of your point lights children of this empty **GameObject**, the
    **Hierarchy** window becomes significantly less cluttered.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将所有点光源设置为这个空**游戏对象**的子对象，**层次结构**窗口将变得不再那么杂乱。
- en: We added several lights to the game. By changing the colors of the lights, we
    make the scene much more interesting to look at and play in. However, a drawback
    of the lighting system is revealed. The city we are using is very simple and there
    is a limit to the number of lights that can affect a plane at one time. While
    the look of our scene is nevertheless improved, much of the impressiveness is
    stolen by this drawback.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏添加了几盏灯。通过改变灯光的颜色，我们使场景看起来更有趣，玩起来也更吸引人。然而，这也揭示了照明系统的一个缺点。我们使用的城市非常简单，同时影响一个平面的灯光数量是有限制的。尽管如此，我们的场景外观得到了改善，但许多令人印象深刻的元素还是因为这一缺点而大打折扣。
- en: Lightmaps
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光照图
- en: Lightmaps are great for complex lighting setups that will be too expensive or
    simply won't work at runtime. They also allow you to add detailed shadows to your
    game world without the expense of real-time shadows. However, it will only work
    for objects that do not move over the course of a game.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 光照图对于复杂的照明设置非常有效，这些设置在运行时可能过于昂贵或根本无法工作。它们还允许你在不消耗实时阴影的情况下为游戏世界添加详细的阴影。然而，这种方法只适用于在整个游戏过程中不会移动的对象。
- en: 'Lightmaps are a great effect for any game environment, but we need to explicitly
    tell Unity which objects will not move and then create the lightmaps. The following
    steps will help us do this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 光照图对于任何游戏环境都是一个很好的效果，但我们需要明确告诉Unity哪些对象不会移动，然后创建光照图。以下步骤将帮助我们完成此操作：
- en: The first thing to do is to make your environment meshes static. To do this,
    start by selecting a piece of your city.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做的第一件事是使你的环境网格静态化。为此，首先选择城市的一部分。
- en: In the top-right corner of the **Inspector** window, to the right-hand side
    of the object name field, are a checkbox and a **Static** label. Checking this
    box will make the object static.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的右上角，对象名称字段右侧有一个复选框和**静态**标签。勾选此复选框将使对象变为静态。
- en: 'Make all of the city''s meshes static, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤将城市的所有网格设为静态：
- en: Instead of selecting each checkbox one by one, if you have any sort of grouping
    (as we just did for the lights), this step can be completed much faster. Select
    the root object of your city, the one that is the parent to all the pieces of
    your city, buildings, and streets.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你进行了任何形式的分组（正如我们对灯光所做的那样），那么这一步可以更快地完成，而不是逐个选择每个复选框。选择你城市的根对象，即所有城市部件、建筑和街道的父对象。
- en: Now, go and select the **Static** checkbox.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，勾选**静态**复选框。
- en: In the new popup, select **Yes, change children** to cause all the subobjects
    to become static as well.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的弹出窗口中，选择**是，更改子对象**，使所有子对象也变为静态。
- en: Any mesh that is either not unwrapped or has UV positions outside the normalized
    UV space will be skipped when Unity generates a lightmap. In the **Model Import
    Settings** window, there is an option to have Unity automatically generate lightmap
    coordinates, **Generate Lightmap UVs**. If you are using `TankBattleCity` for
    your environment, this option should be turned on now.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Unity 生成光照图时，任何未展开或具有规范化 UV 空间外 UV 位置的网格都将被跳过。在**模型导入设置**窗口中，有一个选项可以让 Unity
    自动生成光照图坐标，即**生成光照图UV**。如果你正在使用`TankBattleCity`作为你的环境，现在应该开启这个选项。
- en: Go to the top of the Unity Editor and select **Window** and then click on **Lighting**,
    near the bottom.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Unity 编辑器顶部，选择**窗口**，然后点击底部的**光照**。
- en: Most of your time will be spent on the **Scene** page when looking at this window.
    Select **Scene** at the top of the window to switch to that window.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你查看这个窗口时，大部分时间将花在**场景**页面上。选择窗口顶部的**场景**以切换到该页面。
- en: The first thing you will notice about this page is that it has the same **Sky
    Light** section that we saw in **Scene Render Settings**, where we changed the
    skybox. We also have all the **Fog** settings toward the bottom of the window.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会首先注意到这个页面的一个特点是，它具有我们在**场景渲染设置**中看到的相同的**天光**部分，我们在那里更改了天空盒。在窗口底部，我们还有所有的**雾**设置。
- en: The section we are interested in is **General GI Settings**, as shown in the
    following screenshot:![Lightmaps](img/4691OT_04_09.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们感兴趣的部分是**通用GI设置**，如下面的截图所示：![Lightmaps](img/4691OT_04_09.jpg)
- en: 'The preceding screenshot has the following settings:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的截图有以下设置：
- en: '**Workflow**: This setting determines which method you are going to use in
    order to work with your lightmaps. By default, **Legacy** is selected, which is
    the old method. We want to change it to **On Demand**. (**Iterative** is the same
    as **On Demand**, but it attempts to update the lightmaps while you are adjusting
    settings. This is only recommended if you have a computer that is powerful enough
    to handle it.)'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流程**：此设置决定了你将使用哪种方法来处理光照图。默认选择的是**旧版**方法。我们希望将其更改为**按需**。（**迭代**与**按需**相同，但在你调整设置时尝试更新光照图。只有当你的计算机足够强大以处理此操作时，才推荐使用此选项。）'
- en: '**Global Parameters**: This setting lets you create settings that you might
    want to be able to quickly select. This will be especially useful if you have
    many scenes that need to be changed. However, we only have one scene, so we can
    ignore it for now.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局参数**：此设置允许你创建你可能想要快速选择的设置。如果你有许多需要更改的场景，这将特别有用。然而，我们只有一个场景，所以现在可以忽略它。'
- en: '**Sky Light**: This setting affects how much ambient light is in the scene.
    A lower value will make the overall scene darker, perhaps giving you a night scene.
    A higher value will make everything brighter, perhaps a daytime scene. The **Realtime
    Sky** checkbox below this setting dictates whether this calculation is made while
    the game is running or only when you are baking the lightmaps. Unchecking the
    box will save on processing, but leaving it checked will allow you to change the
    brightness of your scene while the game is running. So, you can see your lights
    in the game, set **Sky Light** to `0.2`, and uncheck **Realtime Sky**.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天光**：此设置影响场景中的环境光量。较低的值会使整个场景变暗，可能给你一个夜晚的场景。较高的值会使一切变得更亮，可能是白天的场景。此设置下面的**实时天光**复选框决定了此计算是在游戏运行时进行，还是在烘焙光照图时进行。取消勾选此框将节省处理资源，但勾选它将允许你在游戏运行时更改场景的亮度。因此，如果你想在游戏中看到你的灯光，将**天光**设置为`0.2`，并取消勾选**实时天光**。'
- en: '**Albedo Scale**: This setting affects how much light bounces off of surfaces.
    The **Indirect Scale** option affects how much light is in the overall scene from
    the light sources that do not point directly at an object. For our purposes, both
    of these can be left at their default values.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反照率缩放**：这个设置影响光线从表面反射的多少。**间接光照缩放**选项影响场景中来自非直接照射物体的光源的整体光照。出于我们的目的，这两个选项可以保持默认值。'
- en: '**Realtime GI Settings**: This section is only available with Unity''s new
    lightmaping system. It holds the controls for lightmaps that are calculated while
    the game is running. The **Realtime Resolution** and **Realtime Atlas Size** options
    adjust how much detail is present in these lightmaps. The **CPU Usage** option
    controls the amount of effort that the system will put into calculating the values
    you see while the game is running. Since we are working on a mobile platform,
    we need to keep our processing costs down, so leaving all of these at their low
    defaults works fine for us.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时GI设置**：这一部分仅在Unity的新光照贴图系统中可用。它包含在游戏运行时计算的光照贴图的控件。**实时分辨率**和**实时图集大小**选项调整这些光照贴图中的细节量。**CPU使用率**选项控制在游戏运行时系统将投入多少努力来计算你所看到的值。由于我们是在移动平台上工作，我们需要保持处理成本降低，所以将这些选项保持在其低默认值对我们来说很好。'
- en: '**Baked GI Settings**: These settings hold the controls for adjusting the precalculated
    lightmaps. This is where most of your adjustments will take place. Right off the
    bat, we have a **Directional Mode** checkbox that dictates whether we are going
    to use a single set of lightmaps when unchecked. Or, if we are going to use two
    sets, where one set is for color and direct light and the second set is for indirect
    light. Using two sets of lightmaps can give you greater detail, especially in
    dark areas, but is more costly to calculate and use. So, we are going to leave
    it unchecked.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙GI设置**：这些设置包含调整预计算光照贴图的控件。这里是你大部分调整发生的地方。首先，我们有一个**方向模式**复选框，它决定了当我们未选中时是否使用单一组光照贴图。或者，如果我们使用两组，其中一组用于颜色和直接光照，第二组用于间接光照。使用两组光照贴图可以提供更高的细节，尤其是在暗区，但计算和使用成本更高。所以，我们打算保持它未选中。'
- en: '**Baked Resolution**: This setting controls how much detail is put into an
    object based on its size. After the number field, you can see the **texels per
    unit** setting. A texel is just a fancy lightmap pixel. So, it is really just
    the amount of pixel details in the lightmap for each unit in the scene. For our
    purposes, a value of `30` will give us a good amount of detail without overloading
    our computers.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙分辨率**：此设置根据物体的大小控制其包含的细节量。在数字字段后面，你可以看到**每单位纹理像素**设置。纹理像素只是一个花哨的光照贴图像素。所以，它实际上是场景中每个单位在光照贴图中的像素细节量。出于我们的目的，`30`的值可以为我们提供足够的细节，而不会让计算机过载。'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The **Baked Resolution** setting will most quickly affect how long it takes
    to actually bake your lightmaps. It is always better to start working with low
    values and only increase the values once your lighting setup comes close to what
    you want the final product to look like.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**烘焙分辨率**设置将最直接影响实际烘焙光照贴图所需的时间。最好先使用低值开始工作，并且只有当你的光照设置接近你想要的最终产品的样子时，才增加这些值。'
- en: '**Baked Atlas Size**: This setting controls the ultimate resolution of the
    final lightmap images. Smaller resolution sizes will be easier to process, but
    you need to limit the overall details of the largest objects in your scene. No
    matter what resolution you have chosen, a single plane of your models cannot have
    more detail than a single lightmap atlas. The default of **1024** is an excellent
    compromise between detail and processing cost.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙图集大小**：此设置控制最终光照贴图图像的分辨率。较小的分辨率更容易处理，但你需要限制场景中最大物体的总体细节。无论你选择哪种分辨率，你的模型的单个平面都不能比单个光照贴图图集拥有更多的细节。默认的**1024**在细节和处理成本之间取得了很好的平衡。'
- en: '**Padding**: The value of this setting adjusts the space in the lightmap between
    objects. A value that is too low will cause the shading to bleed onto the edges
    of other objects that share the lightmap. A value that is too high will lead to
    a great amount of wasted space in your lightmaps. Again, the default here will
    work just fine for us.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充**：此设置调整光照贴图中对象之间的空间。过低的值将导致阴影渗透到共享光照贴图的其他对象的边缘。过高的值将导致光照贴图中浪费大量空间。同样，默认值对我们来说就很好。'
- en: '**Direct Scale**: This setting will scale the intensity of lights when baked
    into your lightmap. It will let you change the overall brightness of your scene.
    The default will work just fine here as well.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接缩放**: 这个设置将在烘焙到光照贴图中的灯光强度进行缩放。它允许你改变场景的整体亮度。默认设置在这里同样可以正常工作。'
- en: '**AO Exponent**: This setting adjusts the contrast of the ambient lighting.
    This will make the dark areas in your scene look darker and the light areas look
    brighter. Leaving it at the default of `1` will be fine for us.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光指数**: 这个设置调整环境光照的对比度。这将使你场景中的暗区看起来更暗，亮区看起来更亮。将其保留为默认的`1`对我们来说就很好。'
- en: At the bottom of the page is a **Bake** button. Clicking on this button will
    start the render process. A loading bar will appear in the bottom-right corner
    of Unity, so you can monitor the progress.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部有一个**烘焙**按钮。点击这个按钮将开始渲染过程。在Unity的右下角会出现一个加载条，这样你可以监控进度。
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be warned as this process is likely to take a while. Especially as the complexity
    of the environment and the number of lights increases and the detail settings
    are ramped up, this will take longer and longer to run. Also, unless you have
    a superior computer, there isn't much you can do in Unity while it is running.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提醒一下，这个过程可能需要一些时间。特别是随着环境复杂度和灯光数量的增加以及细节设置的提升，这个过程运行的时间会越来越长。另外，除非你有一台高性能的计算机，否则在它运行的时候在Unity里你几乎什么也做不了。
- en: If you clicked on the button and realized that you have made a mistake, don't
    fret. After **Bake** is selected, the button changes to **Cancel**. At this time,
    it is possible to select it and stop the process from continuing. However, once
    the textures have been created and Unity starts to import them, there is no stopping
    it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击了按钮并意识到你犯了一个错误，不要慌张。选择**烘焙**后，该按钮会变为**取消**。此时，可以选择它并停止进程继续进行。然而，一旦纹理被创建并且Unity开始导入它们，就无法停止这一过程。
- en: At the left-hand side of the **Bake** button is **Clear**. This button is the
    quickest and easiest way to delete and remove all of the lightmaps that are currently
    being used in the scene. This cannot be undone.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**烘焙**按钮的左侧是**清除**。这个按钮是删除和移除场景中当前使用的所有光照贴图的最快和最简单的方法。这个操作无法撤销。
- en: In order to add shadows to your buildings, select **Directional Light** in your
    scene, from **Hierarchy**, and take a look at the **Inspector** window.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给你的建筑物添加阴影，在**层级**中选择你场景中的**方向光**，并查看**检查器**窗口。
- en: From the **Shadow Type** drop-down list, select **Soft Shadows**. This simply
    turns on the shadows for this light. It turns them on for both lightmaps and real-time
    lighting. The greater the number of lights with shadows turned on, the more expensive
    they become to render. It is a good idea to turn on the shadows for your lightmap,
    but be sure to turn them off afterwards. This will conserve processing in your
    final game, while still giving your static scene a good look.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**阴影类型**下拉列表中选择**软阴影**。这简单地为这个灯光开启了阴影。它为光照贴图和实时光照都开启阴影。开启阴影的灯光数量越多，渲染成本就越高。为你的光照贴图开启阴影是个好主意，但之后一定要关闭它们。这将为你最终的游戏节省处理资源，同时还能让你的静态场景看起来很好。
- en: When all your lights and settings match your expectations, select **Bake** and
    once it has finished processing, gaze in wonder at the now beautiful scene before
    you, as shown here:![Lightmaps](img/4691OT_04_08.jpg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的所有灯光和设置都符合你的预期时，选择**烘焙**，一旦处理完成，就可以惊奇地欣赏你面前现在这个美丽的场景，如下图所示：![光照贴图](img/4691OT_04_08.jpg)
- en: We added lightmaps to our game world. The length of time it takes to just process
    this step makes it difficult to make minor tweaks. However, our lighting has vastly
    improved with a few clicks. While earlier the lights were broken by the meshes,
    we now have smooth patches of color and light.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏世界添加了光照贴图。仅处理这一步所需的时间就使得进行微小调整变得困难。然而，通过几次点击，我们的光照效果得到了极大的改善。之前灯光被网格破坏，现在我们有了平滑的颜色和光照区域。
- en: 'When playing a game, there is only one type of light that people will not question
    the source of: sunlight. Every other light looks weird if a source is not seen.
    Create a mesh and add it to the game in order to give a reason for the lights
    you are using. This can be something along the lines of torches, lamp posts, or
    even glowing alien goo balls. Whatever they end up being, having them adds that
    touch of completeness that makes the difference between an OK-looking game and
    a great-looking game.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩游戏时，人们唯一不会质疑来源的光线类型是阳光。如果看不到来源，其他任何光线看起来都会很奇怪。创建一个网格并将其添加到游戏中，以便为你要使用的灯光提供一个理由。这可以是类似于火把、路灯，甚至是发光的外星粘液球的东西。无论它们最终是什么，拥有它们都能增加完整性，这是让游戏看起来不错与看起来很棒之间的区别。
- en: As a second challenge, take a look at your lightmap's quality. Play with the
    various quality settings we discussed to see what the differences are. Also, find
    out how low the resolution can be before you notice any pixelation. Can the settings
    go even lower when running on smaller mobile device screens? Go find out.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个挑战，看看你的光照贴图的质量。玩弄我们讨论的各种质量设置，看看有什么不同。还要找出分辨率可以低到什么程度，你才会注意到像素化。在运行小型移动设备屏幕时，设置是否可以更低？去发现吧。
- en: Cookies
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饼干效果
- en: Cookies are a great way to add interest to the lights in your game. They use
    a texture to adjust how the light is emitted. This effect can cover a wide range
    of uses, from sparkling crystals to caged industrial lights and, in our case,
    headlights.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 饼干是增强游戏中灯光兴趣的好方法。它们使用纹理来调整光线如何发射。这种效果可以涵盖广泛的使用范围，从闪烁的晶体到笼式工业灯光，在我们的案例中，是车头灯。
- en: 'By giving our tank headlights, we give the player the ability to control the
    light in their world. Using cookies, we can make them look more interesting than
    just circles of light. Let''s add those lights with these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给我们的坦克添加车头灯，我们让玩家能够控制他们世界中的灯光。使用饼干效果，我们可以让它们看起来比简单的光圈更有趣。按照以下步骤添加这些灯光：
- en: Start by creating a spotlight.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建一个聚光灯开始。
- en: Position the light in front of the tank and pointing away.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将灯光放置在坦克前方并指向外侧。
- en: In the **Inspector** window, increase the value of the **Intensity** attribute
    to `3`. This will make our headlights bright, like real headlights.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口中，将**强度**属性的值增加到`3`。这将使我们的车头灯更亮，就像真正的车头灯一样。
- en: Now, we need some cookie textures. At the top of the Unity Editor, navigate
    to **Assets** | **Import Package** | **Light Cookies**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一些饼干纹理。在Unity编辑器顶部，导航到**Assets** | **Import Package** | **Light Cookies**。
- en: In the new window, click on **Import** and wait for the loading bar to finish.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，点击**Import**并等待加载条完成。
- en: We now have a few options to choose from. Inside the `Standard Assets` folder,
    a new folder was created, `Light Cookies`, that contains the new textures. Drag
    **Flashlight** from the **Project** window and drop it onto the **Cookie** field
    on **Spotlight** in the **Inspector** window. It is as simple as that to add a
    cookie to a light.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有几个选项可以选择。在`Standard Assets`文件夹内，创建了一个名为`Light Cookies`的新文件夹，其中包含了新的纹理。将**Project**窗口中的**Flashlight**拖放到**Inspector**窗口中**Spotlight**的**Cookie**字段上。这样就可以简单地为灯光添加一个饼干效果。
- en: You may still not be able to see your cookie in action. It is the result of
    the same issue we were having before; too many lights can't shade the same object.
    Unfortunately, a light that is meant to move around cannot be baked into the lightmaps.
    To fix this, change the light's **Render Mode** attribute to **Important** in
    the **Inspector** panel. This will give the light priority and make it light an
    object before the other objects in the scene.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能仍然无法看到你的饼干效果。这是之前我们遇到的问题的同样结果；太多的灯光不能对同一个物体进行阴影处理。不幸的是，意味着要移动的灯光不能烘焙到光照贴图中。为了解决这个问题，在**Inspector**面板中将灯光的**渲染模式**属性更改为**重要**。这将给灯光优先级，使其在场景中的其他物体之前照亮一个物体。
- en: If you were to bake your lights again now, you would end up with the cookie
    shape stuck on the wall of a building. We need to change **GI Mode** to **Realtime**
    so that the light is ignored by the lightmaping process but is still able to affect
    the scene.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在再次烘焙你的灯光，你最终会得到一个贴在建筑物墙上的饼干形状。我们需要将**GI模式**更改为**实时**，这样光线就能被光照贴图过程忽略，但仍然能够影响场景。
- en: To finish off, duplicate the light for the second headlight and make them both
    children of the tank. What good is it to have headlights if they don't come with
    us?![Cookies](img/4691OT_04_10.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，复制第二个车头灯的灯光，并使它们都成为坦克的子物体。如果车头灯不跟着我们，那它们还有什么用？![Cookies](img/4691OT_04_10.jpg)
- en: We performed a few short steps and created a pair of headlights for our tank
    using cookies. This is exactly how many other games, especially horror games,
    create flashlight effects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过几个简短的步骤，使用cookies为我们的坦克创建了一对大灯。这正是许多其他游戏，尤其是恐怖游戏，创建手电筒效果的方式。
- en: Try making a script that will allow the player to turn the headlights on and
    off. It should be a simple button that toggles the lights. Take a look at the
    `enabled` variable that is supplied as part of the light.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个脚本，允许玩家打开和关闭大灯。它应该是一个简单的按钮，用来切换灯光。查看作为灯光一部分提供的`enabled`变量。
- en: As a simple challenge, create a lamp that sits on the turret of the tank. Give
    it a light as well. With this, the player can point a light to where they are
    shooting and not just in the direction in which their tank is pointing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项简单的挑战，创建一个位于坦克炮塔上的灯。给它一个光源。这样，玩家可以指向他们射击的地方，而不仅仅是坦克所指的方向。
- en: Blob shadows
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影
- en: Blob shadows are a simple and cheap method by which you can add a shadow to
    a character. They have been around since the dawn of video games. A normal shadow
    is a solid, dark projection of an object onto another surface. The contours of
    the shadow exactly match the shape of the object. This becomes expensive to calculate
    when characters start to move around randomly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影是一种简单且成本较低的方法，通过它你可以为角色添加阴影。自从视频游戏诞生以来，它们就一直存在。普通阴影是将物体的固体、暗色投影到另一个表面上。阴影的轮廓与物体的形状完全匹配。当角色开始随机移动时，这变得计算起来很昂贵。
- en: A blob shadow is a blot of black texture underneath a character or an object.
    It usually does not have a clearly definable shape and never matches the exact
    shape of the object it is meant to be the shadow of. The blob shadow also, generally,
    does not change sizes. This makes it significantly easier to calculate, making
    it the shadow of choice for many generations of video games. This also means that
    it is a better option for our mobile devices where processing speed can quickly
    become an issue.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影是一个位于角色或物体下方的黑色纹理块。它通常没有明确的形状，并且不会与它所要表示的物体的形状完全匹配。阴影通常也不会改变大小。这使得它计算起来明显更容易，成为许多代视频游戏的阴影选择。这也意味着它更适合我们的移动设备，因为在这些设备上处理速度可能很快就会成为一个问题。
- en: 'We are going to add a blob shadow to our tank. Unity has already done the bulk
    of the work for us; we just need to add it to the tank. With these steps, we can
    add a blob shadow:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的坦克添加一个阴影。Unity已经为我们完成了大部分工作；我们只需将其添加到坦克上。通过以下步骤，我们可以添加阴影：
- en: We start this one off by importing Unity's blob shadow. Go to the top of the
    Unity Editor and navigate to **Assets** | **Import Package** | **Projectors**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从导入Unity的阴影开始。回到Unity编辑器顶部，导航到**资源** | **导入包** | **投影仪**。
- en: Click on **Import** in the new window and look in the **Project** window for
    a new folder called `Projectors` created under `Standard Assets`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中点击**导入**，并在**项目**窗口中查看名为`Projectors`的新文件夹，该文件夹位于`Standard Assets`下创建。
- en: Drag the `Blob Shadow Projector` prefab from the **Project** window to the scene
    and position it above the tank, as shown in the following screenshot:![Blob shadows](img/4691OT_04_11.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口将`Blob Shadow Projector`预制体拖到场景中，并将其放置在坦克上方，如下图所示：![阴影](img/4691OT_04_11.jpg)
- en: Unfortunately, the shadow appears on top of our tank. To fix this, we again
    need to make use of layers. So, select the tank.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，阴影出现在我们坦克的顶部。为了解决这个问题，我们再次需要利用图层。所以，选择坦克。
- en: From the **Layer** drop-down list, select **Add Layer…**.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**图层**下拉列表中选择**添加图层…**。
- en: Click on the text field at the right-hand side of **User Layer 9** and give
    it the name `PlayerTank`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**用户图层9**右侧的文本框，为其命名`PlayerTank`。
- en: Select your tank once more, but select **PlayerTank** from the **Layer** drop-down
    list this time.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择你的坦克，但这次从**图层**下拉列表中选择**PlayerTank**。
- en: When the new window pops up, be sure to select **Yes, change children** to change
    the layer of the whole tank. If you don't select this, the blob shadow may appear
    on some parts of the tank, while it may not appear on other parts.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当新窗口弹出时，请确保选择**是，更改子对象**以改变整个坦克的图层。如果你不选择这个，阴影可能会出现在坦克的某些部分，而其他部分可能不会出现。
- en: Now, select `Blob Shadow Projector` from the **Hierarchy** window.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**层次结构**窗口中选择`Blob Shadow Projector`。
- en: Note
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The blob shadow is created by the **Projector** component. This component functions
    in a similar manner to the **Camera** component. However, it puts an image on
    the world rather than turning the world into an image and putting it on your screen.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: blob阴影是由**Projector**组件创建的。这个组件的工作方式与**Camera**组件类似。然而，它将图像投影到世界上，而不是将世界转换成图像并显示在你的屏幕上。
- en: Take a look at the **Inspector** window. The value we are concerned with right
    now is that of **Ignore Layers**. Right now, it is set to **Nothing**.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下**Inspector**窗口。我们现在关心的是**Ignore Layers**的值。目前，它被设置为**Nothing**。
- en: Click on **Nothing** and select `PlayerTank` from the **Layers** drop-down list.
    This will make the projector ignore the tank and only make the blob shadow appear
    underneath it.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Nothing**，并从**Layers**下拉列表中选择`PlayerTank`。这将使投影仪忽略坦克，只在其下方产生blob阴影。
- en: The next step is to change the size of the shadow to roughly match the size
    of the tank. Adjust the value of the **Field of View** attribute until the size
    is just about right. A value of `70` seems to be a good size to start with.![Blob
    shadows](img/4691OT_04_12.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调整阴影的大小，使其大致与坦克的大小相匹配。调整**Field of View**属性的值，直到大小差不多合适。从`70`开始似乎是一个不错的选择。![Blob
    shadows](img/4691OT_04_12.jpg)
- en: The final step is to make `Blob Shadow Projector` a child of the tank. We need
    to be able to bring our shadow with us; we don't want to lose it.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使`Blob Shadow Projector`成为坦克的子对象。我们需要能够带着我们的阴影移动；我们可不想失去它。
- en: We gave our tank a shadow. Shadows are great for making objects, and especially
    characters, look like they are actually touching the ground. The blob shadow that
    we used is better than a real-time shadow because it is processed faster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为坦克添加了阴影。阴影对于使物体，尤其是角色看起来实际接触地面非常有用。我们使用的blob阴影优于实时阴影，因为它的处理速度更快。
- en: The texture that the blob shadow comes with is round, but our tank is mostly
    square. Try creating your own texture for the blob shadow and use it. Some sort
    of a rectangle should work well. If you end up with long black streaks on your
    scene, make sure that your texture has a completely white border around the edge
    of the image.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: blob阴影自带的纹理是圆形的，但我们的坦克大多是方形的。尝试为blob阴影创建自己的纹理并使用它。某种矩形纹理应该会很合适。如果最终场景中出现了长长的黑色条纹，请确保你的纹理在图像边缘周围有完全白色的边框。
- en: If you managed to add your own texture to the blob shadow, then how about taking
    a look at that cannon? The cannon sticks out of our tank and ruins its otherwise
    square profile. Use a second blob shadow, attached to the turret, to project a
    shadow for the cannon. The texture for this will also have to be rectangle shaped.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功地为blob阴影添加了自己的纹理，那么不妨看看那门炮？炮管伸出我们的坦克，破坏了其原本的方形轮廓。使用第二个blob阴影，附着在炮塔上，为炮管投射阴影。这个纹理也将必须是矩形形状的。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, you should be well and truly familiar with camera effects and
    lights.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该已经非常熟悉摄像机效果和灯光。
- en: In this chapter, we started by taking a look at using multiple cameras. We then
    played around with a turbo boost camera effect. The chapter continued with the
    lighting of our city. The lights improved greatly when we made use of lightmaps.
    We finished it off with a look at cookies and blob shadows for use with some special
    lighting effects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先查看了使用多个摄像头的用法。然后，我们玩弄了涡轮增压摄像机效果。接着，我们继续对城市进行照明。当我们使用光照图时，灯光效果得到了极大的提升。最后，我们通过一些特殊的照明效果来查看饼干和blob阴影。
- en: In the next chapter, we will see the creation of enemies for our game. We will
    use Unity's pathfinding system to make them move around and chase the player.
    After this, the player will need to be much more active if they hope to keep their
    points.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到为我们的游戏创建敌人。我们将使用Unity的寻路系统使它们四处移动并追逐玩家。在此之后，如果玩家希望保持积分，他们需要变得更加积极。
