- en: Let us Chat in a Smart Way - Messaging API and More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们以智能方式进行聊天 - 消息API及更多
- en: The era of innovation has empowered us to chip away at numerous new shrewd subjects.
    Social media is currently an intense medium of communication. Taking a gander
    at the developing pattern of online networking and innovation, we could state
    that the belief system of social media has advanced and wiped out many difficulties
    of communication. Just about a couple of decades back, the communication medium
    was letters. A couple of centuries back, it was trained birds. If we still look
    back, we will definitely get a few more stories to comprehend the way people used
    to communicate in those days. Now, we are in the generation of IoT, wearable smart
    devices, and an era of smartphones, where communication happens across the planet
    in a fraction of a second. Without elaborating about communication, let's build
    a mobile and wear application that exhibits the power of Google wear messaging
    APIs to assist us in building chat application with a Wear companion application
    to administer and respond to the messages being received. To support the process
    of chatting, we will be using Google's very own technology Firebase in this chapter.
    We will not deep dive into the Firebase technologies, but we will surely understand
    the essentials of using Firebase in mobile platforms and working with wear technologies.
    A Firebase real-time database reflects the data being updated in its hashmap structure.
    Essentially, these are the stream of key-value pairs that Firebase works with.
    The data gets updated with minimal internet bandwidth requirement and instantly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创新时代赋予我们挖掘众多新兴智能主题的能力。社交媒体现在已成为一种强大的沟通媒介。观察在线社交网络与技术的发展趋势，我们可以认为社交媒体的理念已经进步，消除了很多沟通的难题。大约几十年前，通信媒介是书信。几个世纪前，是训练有素的鸽子。如果我们继续回顾，无疑会有更多故事来理解那时人们的沟通方式。现在，我们生活在物联网、可穿戴智能设备和智能手机的时代，通信在地球的每个角落以秒计的速度发生。不详细讨论通信，让我们构建一个移动应用和穿戴应用，展示谷歌穿戴消息API的强大功能，以帮助构建聊天应用，并有一个穿戴设备伴侣应用来管理和响应收到的消息。为了支持聊天过程，我们将在本章使用谷歌自家技术Firebase。我们不会深入探讨Firebase技术，但一定会了解在移动平台上使用Firebase的基础知识以及与穿戴技术的工作方式。Firebase实时数据库在其哈希表结构中反映数据更新。本质上，这些是Firebase处理的关键-值对流。数据在最小的互联网带宽要求下即时更新。
- en: To support the process of chatting, we will be using Google's very own technology,
    Firebase, in this chapter. We will comprehend a generic registration and login
    process for the mobile platform and we will have space for all the registered
    members and enable every one of them to chat exclusively by picking one user from
    the list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持聊天过程，我们将在本章使用谷歌的自家技术Firebase。我们将理解移动平台的通用注册和登录过程，并为所有注册会员提供空间，使他们每个人都能通过从列表中选择一个用户来进行独家聊天。
- en: 'In this chapter, we will explore the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Configuring Firebase to your mobile application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Firebase配置到您的移动应用中
- en: Creating user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Working with `GoogleApiClient`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GoogleApiClient`工作
- en: Understanding the Message API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解消息API
- en: Handling events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件
- en: Building a wear module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个穿戴模块
- en: Now, let's understand how to set up Firebase to our project. It follows a few
    steps that we need to carry out before using Firebase technologies in the project.
    First, we need to apply the Firebase plugin and then the dependencies that we
    use in our project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何将Firebase设置到我们的项目中。在使用项目中的Firebase技术之前，我们需要执行几个步骤。首先，我们需要应用Firebase插件，然后是我们项目中使用的依赖项。
- en: Installing Firebase
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Firebase
- en: 'For installing Firebase, perform the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装Firebase，请执行以下步骤：
- en: 'Visit the Firebase console [https://console.firebase.google.com](https://console.firebase.google.com):'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Firebase控制台 [https://console.firebase.google.com](https://console.firebase.google.com)：
- en: '![](img/00105.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: 'Choose Add project in the console and fill the necessary information about
    the project. After the project is successfully added, you will see the following
    screen:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中选择添加项目，并填写有关项目的必要信息。项目成功添加后，您将看到以下屏幕：
- en: '![](img/00106.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.jpeg)'
- en: 'The get started page helps you set up the project for different platforms.
    Let''s choose the second option, which says Add Firebase to your Android app:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “开始使用”页面帮助您为不同的平台设置项目。让我们选择第二个选项，它说“将Firebase添加到您的Android应用中”：
- en: '![](img/00107.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'Add the project package name and, for further security purposes, you can add
    the SHA-1 fingerprint, but that is optional. Now register the app:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加项目包名，出于进一步的安全考虑，你可以添加SHA-1指纹，但这是可选的。现在注册应用：
- en: '![](img/00108.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: Download the config file. The `google-services.json` file will have all the
    important configuration for the app and place it in the app directory of your
    project structure.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载配置文件。`google-services.json`文件将包含应用的所有重要配置，并将其放置在你的项目结构中的app目录下。
- en: 'Now, let''s fire up Android Studio and create the project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动Android Studio并创建项目：
- en: '![](img/00109.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: Make sure the package name is the same as the one mentioned in the Firebase
    console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确保包名与Firebase控制台提到的相同。
- en: 'Let''s choose the targeted platforms that are both phone and Wear:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择目标是手机和穿戴的平台：
- en: '![](img/00110.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: 'Now, add Empty Activity to the mobile activity chooser:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向移动活动选择器中添加空活动：
- en: '![](img/00111.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: 'Select **Blank Wear Activity** in the wear activity chooser for generating
    blank wear activity code through the Android Studio template:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在穿戴活动选择器中选择**空白穿戴活动**，通过Android Studio模板生成空白穿戴活动代码：
- en: '![](img/00112.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: 'Now, name your class and XML files and finish the project for Android Studio
    to generate boiler for your mobile and wear module. Using file explorer or finder,
    go to the directory structure and copy and paste the `google-services.json` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为你的类和XML文件命名，并完成项目，以便Android Studio为你的移动和穿戴模块生成模板代码。使用文件资源管理器或查找器，进入目录结构，并复制粘贴`google-services.json`文件：
- en: '![](img/00113.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: Since we are building wear and mobile app together and the `app` directory name
    will be mobile for mobile and wear for wear projects, we shall copy the config
    file (`google-services.json`) inside the mobile directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们同时构建移动和穿戴应用，且`app`目录名称对于移动项目是mobile，对于穿戴项目是wear，我们应该将配置文件（`google-services.json`）复制到移动目录内。
- en: 'After adding the config file, it is time to add the plugin classpath dependency:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加配置文件后，是时候添加插件类路径依赖项了：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/00114.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.jpeg)'
- en: 'Now, in the mobile Gradle module dependency, apply the plugin to the bottom
    of all the tag scope, as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在移动Gradle模块依赖项中，将插件应用到所有标签范围内的底部，如下截图所示：
- en: '![](img/00115.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00115.jpeg)'
- en: To help Gradle to manage dependencies and the order of events that Gradle uses
    to build the project, we are supposed to add Google Play services dependencies
    at the bottom of the Gradle file. However, it will also avoid the conflict with
    other Google dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助Gradle管理依赖项和构建项目的顺序，我们应在Gradle文件的底部添加Google Play服务依赖项。然而，它也将避免与其他Google依赖项的冲突。
- en: 'After a successful sync, the Firebase SDKs are integrated into our project.
    Now, we can get started using features that we are interested in. In this project,
    for the scope of a chatting feature, we will be using the Firebase Realtime database.
    Let''s add the dependency to the same gradle file inside the dependencies. We
    will use the volley network library for fetching the user''s list from the Firebase
    users node. We need to add the design support library for material design support:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 成功同步后，Firebase SDKs被集成到我们的项目中。现在，我们可以开始使用我们感兴趣的功能。在这个项目中，为了聊天功能范围，我们将使用Firebase实时数据库。让我们将依赖项添加到同一gradle文件的依赖项中。我们将使用volley网络库从Firebase用户节点获取用户列表。我们需要添加设计支持库以支持材料设计：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On off the chance if you see gradle error please add the following packaging
    in gradle file under dependency section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在gradle中遇到错误，请在依赖项部分添加以下包装。
- en: '`packagingOptions {`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`packagingOptions {`'
- en: '`exclude ''META-INF/DEPENDENCIES.txt''`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/DEPENDENCIES.txt''`'
- en: '`exclude ''META-INF/LICENSE.txt''`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/LICENSE.txt''`'
- en: '`exclude ''META-INF/NOTICE.txt''`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/NOTICE.txt''`'
- en: '`exclude ''META-INF/NOTICE''`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/NOTICE''`'
- en: '`exclude ''META-INF/LICENSE''`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/LICENSE''`'
- en: '`exclude ''META-INF/DEPENDENCIES''`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/DEPENDENCIES''`'
- en: '`exclude ''META-INF/notice.txt''`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/notice.txt''`'
- en: '`exclude ''META-INF/license.txt''`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/license.txt''`'
- en: '`exclude ''META-INF/dependencies.txt''`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/dependencies.txt''`'
- en: '`exclude ''META-INF/LGPL2.1''`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclude ''META-INF/LGPL2.1''`'
- en: '`}`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: After all the necessary project setup, let's conceptualize the chatting application
    that we are going to build.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有必要的项目设置后，让我们来构思我们将要构建的聊天应用程序。
- en: A basic chat application needs a registration process and, to avoid anonymous
    chats or, at least, to know with whom we are chatting, we need the sender and
    receiver names. The first screen is going to be the login screen with the username
    and password fields allowing already registered users to start chatting with the
    users. Then, we have the registration screen with the same username and password
    fields. Once the user successfully registers, we will ask the user to enter the
    credentials and allow them to have access to the list-of-users screen, where one
    can pick with whom they want to chat.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的聊天应用程序需要有一个注册过程，为了避免匿名聊天，或者至少要知道我们正在和谁聊天，我们需要发送者和接收者的名字。第一个界面将是登录界面，包含用户名和密码字段，让已经注册的用户可以开始与其他用户聊天。然后，我们有注册界面，同样包含用户名和密码字段。一旦用户成功注册，我们将要求用户输入凭据，并允许他们访问用户列表界面，在那里可以选择他们想与之聊天的人。
- en: Conceptualizing the chatting application
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念化聊天应用程序
- en: 'A login screen with input fields for users to enter the credentials will look
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入凭据的登录界面将如下所示：
- en: '![](img/00116.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00116.jpeg)'
- en: 'The registration screen with input fields will look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段的注册界面将如下所示：
- en: '![](img/00117.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00117.jpeg)'
- en: 'The following screenshot represents the user screen that shows the list of
    registered users:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了显示已注册用户列表的用户界面：
- en: '![](img/00118.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: 'The chat screen with the actual chat messages will look as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际聊天消息的聊天界面将如下所示：
- en: '![](img/00119.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.jpeg)'
- en: 'The Wear Chat Application will look as follows on round screens:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆形屏幕上，可穿戴聊天应用程序将如下所示：
- en: '![](img/00120.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00120.jpeg)'
- en: When a message enters the handheld device, it should notify wear and, from the
    wear device, users should be able to send a reply to that message. In this chapter,
    we will see a working mobile and wear chat application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条消息进入手持设备时，它应该通知可穿戴设备，并且用户应该能够从可穿戴设备发送回复。在本章中，我们将看到一个工作的移动设备和可穿戴设备聊天应用程序。
- en: Understanding Data Layer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据层
- en: Wearable Data Layer API is part of the Google Play services that establishes
    the communication channel to handheld device apps and wear apps. Using the `GoogleApiClient`
    class, we can get access to the Data Layer. Primarily, the Data Layer is used
    in the Wear app to communicate with the handheld device, but using it for connecting
    to the network is discouraged. When we create the `GoogleAPIClient` class using
    the builder pattern, we will be attaching `Wearable.API` to the `addAPI` method.
    When we add multiple APIs in `GoogleApiclient`, there is a chance of the client
    instance failing into the `onConnection` fail callbacks. It's a good approach
    to add an API through `addApiIfAvailable()`. This will take care of most of the
    hard work; it will add the API if it's available. After adding all this using
    `addConnectionCallbacks`, we can handle the Data Layer events. We need to start
    the connection of the client instance by calling the `connect()` method. After
    a successful connection, we can use the Data Layer API.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴数据层API是谷歌Play服务的一部分，它建立了与手持设备应用和可穿戴应用的通信通道。使用`GoogleApiClient`类，我们可以访问数据层。数据层主要在可穿戴应用中使用，与手持设备通信，但建议不要用它来连接网络。当我们使用构建器模式创建`GoogleAPIClient`类时，我们将`Wearable.API`附加到`addAPI`方法中。当我们在`GoogleApiclient`中添加多个API时，客户端实例有可能在`onConnection`失败回调中失败。通过`addApiIfAvailable()`添加API是一个好的方法。这将处理大部分繁重的工作；如果API可用，它将添加API。使用`addConnectionCallbacks`添加所有这些之后，我们可以处理数据层事件。我们需要通过调用`connect()`方法来启动客户端实例的连接。成功连接后，我们可以使用数据层API。
- en: Data Layer events
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层事件
- en: Events allow the developer to listen to what's happening in the communication
    channel. A successful communication channel will be able to send the status of
    the call when it's complete. These events will allow the developer to monitor
    all the state changes and data changes in a wireless communication channel. The
    Data Layer API returns pending results on an incomplete transaction, such as `putdataitem()`.
    The pending results will be automatically queued in the background when the transaction
    is incomplete and, if we don't handle it, this operation will be completed in
    the background. However, pending results need to be handled; pending result will
    wait for the result status and it has two methods to wait for the results synchronously
    and asynchronously.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事件允许开发者监听通信通道中发生的事情。成功的通信通道将能够在调用完成时发送调用状态。这些事件将允许开发者监控无线通信通道中的所有状态变化和数据变化。数据层API在未完成的交易上返回待定结果，例如`putdataitem()`。当交易未完成时，待定结果将在后台自动排队，如果我们不处理它，这个操作将在后台完成。然而，待定结果需要被处理；待定结果将等待结果状态，并且有两种方法同步和异步地等待结果。
- en: 'If the Data Layer code is running in the UI thread, we should avoid making
    blocking calls to the Data Layer API. Using asynchronous callbacks to the `pendingresult`
    object, we will be able to check the status and other vital information:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据层代码在UI线程中运行，我们应避免对数据层API进行阻塞调用。使用`pendingresult`对象的异步回调，我们将能够检查状态和其他重要信息：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the Data Layer code is running in a separate thread in a background service,
    such as `wearableListenerService`, it''s alright to block the calls and you can
    call the `await()` method on the `pendingresult` object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据层代码在后台服务中的独立线程中运行，例如`wearableListenerService`，那么阻塞调用是可以的，你可以在`pendingresult`对象上调用`await()`方法：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Data Layer events can be monitored in two ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层事件可以通过两种方式监控：
- en: Creating a class that extends to `WearableListenerService`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个扩展了`WearableListenerService`的类。
- en: An activity that implements `DataApi.DataListener`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`DataApi.DataListener`的Activity
- en: 'In both the facilities, we override the methods to handle the data events.
    Typically, we need to create the instance in both wearable and handheld apps.
    We can override the methods that we need for the application use case. Essentially,
    `WearableListenerService` has the following events:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个设施中，我们重写方法以处理数据事件。通常，我们需要在可穿戴设备和手持应用中都创建实例。我们可以根据应用场景的需要重写方法。本质上，`WearableListenerService`具有以下事件：
- en: '`onDataChanged()`: Whenever this is created, deleted, or updated, the system
    will trigger this method.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDataChanged()`: 每当创建、删除或更新时，系统都会触发这个方法。'
- en: '`onMessageReceived()`: A message sent from a node triggers this event in the
    target node.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMessageReceived()`: 从一个节点发送的消息会在目标节点触发这个事件。'
- en: '`onCapabilityChanged()`: This event is triggered when a capability of an instance
    advertise becomes available on the network. We can check the nearby nodes by calling
    `isnearby().`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCapabilityChanged()`: 当实例广告的某个能力在网络上可用时，会触发这个事件。我们可以通过调用`isnearby()`来检查附近的节点。'
- en: These methods are executed in a background thread.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是在后台线程中执行的。
- en: 'To create `WearableListenerService`, we need to create a class that extends
    `WearableListenerService`. Listen for the events that you''re interested in, such
    as `onDataChanged()`. Declare an `intent` filter in your Android manifest to notify
    the system about your `WearableListenerService`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`WearableListenerService`，我们需要创建一个扩展了`WearableListenerService`的类。监听你感兴趣的事件，比如`onDataChanged()`。在你的Android清单中声明一个`intent`过滤器，以通知系统你的`WearableListenerService`：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And register the service in the manifest as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并在清单中如下注册服务：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `DATA_CHANGED` action replaces the previously recommended `BIND_LISTENER`
    action so that only specific events go through the path. We will understand more
    while we are working on a live project in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATA_CHANGED`动作替换了之前推荐的`BIND_LISTENER`动作，以便只有特定事件通过该路径。在本章中，当我们实际操作项目时，我们会进一步了解。'
- en: Capability API
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能力API
- en: This API helps in advertising the capabilities given by nodes in the wear network.
    Capabilities are local to the application. Utilizing the Data Layer and Message
    API, we can communicate with the nodes. To discover whether the target node is
    proficient in doing certain actions, we have to utilize the capability API, for
    instance on the off chance that we need to launch an activity from wear.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API有助于广告穿戴网络中节点所提供的功能。功能对应用程序是本地的。利用数据层和消息API，我们可以与节点通信。为了发现目标节点是否擅长执行某些操作，我们必须利用能力API，例如如果我们需要从穿戴设备启动一个活动。
- en: 'To initialize the capability API to your application, perform the following
    steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要将能力API初始化到您的应用程序中，请执行以下步骤：
- en: Create an XML configuration file in the `res/values` directory.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values`目录中创建一个XML配置文件。
- en: Add a resource named `android_wear_capabilities`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`android_wear_capabilities`的资源。
- en: 'Define the capability that the device provides:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义设备所提供的能力：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Java program for `voice_transcription`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`voice_transcription`的Java程序：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have all the setup and designs to implement the chat application,
    let's get started.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了实施聊天应用程序的所有设置和设计，那我们就开始吧。
- en: Mobile app implementation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动应用实现
- en: The mobile app for the chat application utilises Google's Firebase real-time
    database. Whenever a user sends a message, it reflects in the Firebase console
    in real time. Stories aside, now that we have all the screens up and ready, let's
    get started on writing the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序的移动端应用使用了谷歌的Firebase实时数据库。每当用户发送消息时，它都会实时反映在Firebase控制台上。故事先放一边，既然我们已经准备好了所有屏幕，那就开始编写代码吧。
- en: 'Since we have the color that we are going to be using, let''s declare the colors
    in the colors value XML file under the `res` directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道将要使用的颜色，让我们在`res`目录下的colors值XML文件中声明颜色：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As per the design, we have a curved edge button with a teal color background.
    To make a similar button, we need to create an XML resource in the `drawable`
    directory and call it as `buttonbg.xml`, which is basically a `selector` tag,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，我们有一个带有蓝绿色背景的曲线边缘按钮。要制作类似的按钮，我们需要在`drawable`目录中创建一个XML资源，并将其命名为`buttonbg.xml`，它基本上是一个`selector`标签，如下所示：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the `selector` tag, we have an `item` tag that conveys the states; any
    normal button will have states, such as clicked, released, and default. Here,
    we have taken the default button background and pressed state and, using the `item`
    property tags, such as shape and corners, we are carving the button, as shown
    in the design.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`selector`标签内，我们有一个`item`标签，它传达了状态；任何普通的按钮都会有状态，比如点击、释放和默认。这里，我们采用了默认的按钮背景和按下状态，并使用`item`属性标签，如形状和圆角，来雕刻按钮，正如设计所示。
- en: 'To the comfort of not having multiple changes, we will not refactor `MainActivity`
    into `LoginActivity`, rather we will consider `MainActivity` as the `LoginActivity`.
    Now, in `activity_main.xml`, let''s add the following code to the login screen
    design. For making the screen dynamic, we will be adding the code under `scrollview`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多次更改，我们不会将`MainActivity`重构为`LoginActivity`，而是将`MainActivity`视为`LoginActivity`。现在，在`activity_main.xml`中，让我们添加以下代码到登录屏幕设计。为了使屏幕动态，我们将在`scrollview`下添加代码：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, for completing the login design, we need two input fields, one button
    instance, and one clickable link instance. The completed login screen code would
    look as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成登录设计，我们需要两个输入字段，一个按钮实例和一个可点击链接实例。完成的登录屏幕代码如下所示：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s create another activity and call it `RegistrationActivity`, which has
    a similar component requirement as the login activity, two input fields, and one
    button. The complete code for the XML layout looks as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个活动，并将其称为`RegistrationActivity`，它具有与登录活动类似的组件要求，两个输入字段和一个按钮。XML布局的完整代码如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s create a list of the user''s activity that will have a list of
    users. Call it as the `UsersList` activity and it will have one simple `ListView`
    and `TextView` for addressing the empty list. The complete XML code for `UsersListActivity`
    will look as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个用户活动列表，其中将包含用户列表。将其称为`UsersList`活动，它将有一个简单的`ListView`和一个`TextView`用来处理空列表。`UsersListActivity`的完整XML代码如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create another activity for the chat screen. We will call it `ChatActivity`.
    Add the following code inside the activity XML file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为聊天屏幕创建另一个活动。我们将它称为`ChatActivity`。在活动的XML文件中添加以下代码：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to include a layout for editing the message. Create another XML file
    named `message_area.xml` inside the `layout` directory and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含一个编辑消息的布局。在`layout`目录中创建另一个名为`message_area.xml`的XML文件，并添加以下代码：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, all our visual elements are in place to get started on writing our programming
    logic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们所有的视觉元素都已就位，可以开始编写我们的编程逻辑了。
- en: 'Add this following permission in the manifest file before we start working
    on our activity Java files:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理活动Java文件之前，在清单文件中添加以下权限：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `MainActivity` file, let''s create all the instances and map them to
    their XML ID that we placed in `activity_main.xml`. Inside the `MainActivity`
    class, in the global scope, declare the following instances:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`文件中，让我们创建所有实例，并将它们映射到我们在`activity_main.xml`中放置的XML ID。在`MainActivity`类的全局范围内，声明以下实例：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s connect all these instances to their XML visual elements, as follows,
    using the `findViewById()` method inside the `oncreate` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`onCreate`方法内的`findViewById()`方法将这些实例连接到它们的XML视觉元素，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, when the user clicks on the Register link, it should take the user to
    the registration activity. Using `intent`, we will achieve it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击注册链接时，它应该将用户带到注册活动。使用`intent`，我们将实现它：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By clicking on the login button, it should do a network call, check whether
    the user exists in Firebase, and show the proper action on success. Before we
    write the login logic, let's write the registration logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 点击登录按钮时，它应该进行网络调用，检查Firebase中是否存在用户，并在成功时显示适当的操作。在我们编写登录逻辑之前，让我们先编写注册逻辑。
- en: 'In registration, activity connects all the components in the Java file using
    the `findViewById()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册活动中，使用`findViewById()`方法在Java文件中连接所有组件：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Attach a click listener to `mSubmit` and fetch the inputs in the `onClick`
    listener to make sure we are not passing an empty string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mSubmit`上附加一个点击监听器，并在`onClick`监听器中获取输入，以确保我们没有传递空字符串：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Having a simple validation check will make the app strong from error prone
    situations. The validation and fetching input from the input fields are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的验证检查将使应用程序在容易出错的情况下变得强大。以下是来自输入字段的验证和获取输入：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We now need to reach Firebase for registering the user. Before we proceed, let's
    log in to the Firebase console, [https://console.firebase.google.com](https://console.firebase.google.com),
    and go to the project that we created before.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要访问Firebase以注册用户。在我们继续之前，请登录Firebase控制台，[https://console.firebase.google.com](https://console.firebase.google.com)，然后转到我们之前创建的项目。
- en: 'Now, on the left-hand side menu, we will see the database option and choose
    it. In the rules tab, by default, the read and write authorizations are set to
    `null`. It would be ideal if you change it to `true`, but this is not suggested
    when you are writing a production application:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在左侧菜单中，我们将看到数据库选项并选择它。在规则选项卡中，默认情况下，读写授权设置为`null`。建议您将其更改为`true`，但在编写生产应用程序时不建议这样做：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we set a read and write permission to true, essentially, we are telling
    Firebase anyone can read and write on the off chance that they have an endpoint
    URL.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将读写权限设置为true时，实际上我们是在告诉Firebase，只要他们有端点URL，任何人都可以读写。
- en: Knowing the intricacies of making the URL public, we will use it in the project.
    Now, in the `mSubmit` click listener, we will be checking for a few validations
    and fetch the username and password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到将URL公开的复杂性，我们将在项目中使用它。现在，在`mSubmit`点击监听器中，我们将检查一些验证，并获取用户名和密码。
- en: We should finish the code for the `mSubmit` click listener. After the `else
    if` instance of the password key field, let's make an else case for doing all
    the Firebase network operations. We will make the Firebase reference URL, push
    the child values, and utilize the `volley` network library. We will check whether
    the username exists and, on the off chance that it exists, we will allow the user
    to use the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该完成`mSubmit`点击监听器的代码。在密码关键字段的`else if`实例之后，让我们为执行所有Firebase网络操作创建一个else情况。我们将制作Firebase参考URL，推送子值，并利用`volley`网络库。我们将检查用户名是否存在，如果存在的话，我们将允许用户使用应用程序。
- en: 'The Firebase endpoint URL for this project is [https://packt-wear.firebaseio.com](https://packt-wear.firebaseio.com)
    and the node name can be anything we wish to add for users. Let''s add [https://packt-wear.firebaseio.com/users](https://packt-wear.firebaseio.com/users);
    the code looks as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的Firebase端点URL是[https://packt-wear.firebaseio.com](https://packt-wear.firebaseio.com)，节点名称可以是我们要为用户添加的任何名称。让我们添加[https://packt-wear.firebaseio.com/users](https://packt-wear.firebaseio.com/users)；代码如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using `volley`, we can add the request queues and handle the network request
    in a very efficient manner.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`volley`，我们可以添加请求队列并以非常高效的方式处理网络请求。
- en: 'Now, the complete registration activity class looks as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完整的注册活动类如下所示：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's jump into `MainActivity` for user login logic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到`MainActivity`处理用户登录逻辑。
- en: 'Before we continue, let''s create a class with static instances as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们创建一个带有静态实例的类，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, as we have seen in the registration screen, let''s validate it inside
    the login screen using the `volley` library, let''s check whether the username
    exists. If a valid user with a valid password logs in, we will have to allow the
    user to the chat screen. The following code goes inside the login click listener:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们在注册屏幕上看到的，让我们在登录屏幕中使用`volley`库进行验证，让我们检查用户名是否存在。如果有效的用户使用有效的密码登录，我们将不得不允许用户进入聊天屏幕。以下代码放入登录点击监听器中：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The complete class will look as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类将如下所示：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, after allowing the user to have a successful login, we need to show a
    list of users, ignoring the one who logged in. But the user should be able to
    see other lists of users. Now, let''s work on getting the list of users in `ListView`.
    Let''s connect the components:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，允许用户成功登录后，我们需要显示用户列表，忽略登录的那个。但用户应该能够看到其他用户列表。现在，让我们处理`ListView`中的用户列表。让我们连接组件：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, right in the `onCreate` method, we will initiate the `volley` and fetch
    the list of users, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，我们将初始化`volley`并获取用户列表，如下所示：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we make our Firebase endpoint URL public, anybody can read and write to
    the endpoint if they have the URL. I am just using the URL and adding `.json`
    as an extension so that it will return the JSON result. Now, we need to write
    one last method for managing the success result:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Firebase端点URL公开时，任何拥有该URL的人都可以读取和写入端点。我只是使用URL并添加`.json`作为扩展名，这样它会返回JSON结果。现在，我们需要编写最后一个用于管理成功结果的方法：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The complete class will look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类将如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we have completed one flow, which is `onBoarding` the user and showing
    a list of users who are available to chat. Now, it's time to work on the actual
    chatting logic. Let's start working on `ChatActivity`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了一个流程，即`引导`用户并显示可聊天的用户列表。现在是时候处理实际的聊天逻辑了。让我们开始处理`ChatActivity`。
- en: 'For the message background, we will be adding two drawable resources files:
    `rounded_corner1.xml` and `rounded_corner2.xml`. Let''s add the XML code for the
    drawable resource files:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息背景，我们将添加两个可绘制资源文件：`rounded_corner1.xml`和`rounded_corner2.xml`。让我们为可绘制资源文件添加XML代码：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For `rounded_corner2.xml`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`rounded_corner2.xml`
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s declare the necessary instances for the Firebase chat activity:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为Firebase聊天活动声明必要的实例：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On clicking the send button, using the `push()` method, we can update Firebase
    with the username and with the message that they sent across:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击发送按钮时，使用`push()`方法，我们可以将用户名和发送的消息更新到Firebase：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are callbacks we need to implement from the Firebase `addChildEventListener()`.
    In the `onChildAdded` method, we can show the messages added. The following code
    completes Firebase and adds the background for the messages:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从Firebase的`addChildEventListener()`实现回调。在`onChildAdded`方法中，我们可以显示添加的消息。以下代码完成了Firebase的添加，并为消息添加了背景：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `addMessageBox` method changes the sender and receiver message background:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMessageBox`方法改变了发送者和接收者消息的背景：'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The complete code for `ChatActivity` is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatActivity`的完整代码如下：'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have the complete working chatting module for a mobile application. Now,
    let's write the Wear module for the chat application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为移动应用程序完成了完整的聊天模块。现在，让我们为聊天应用程序编写Wear模块。
- en: Wear App implementation
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wear应用程序实现
- en: The objective of the wear module is that the wear device should receive new
    messages and show it in the app and users should be able to reply to that message
    from the wear device. In this, we will understand the classes and APIs for the
    Wear and mobile app to establish communications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 模块的目标是，穿戴设备应接收新消息并在应用中显示，用户应能够从穿戴设备回复这些消息。在这里，我们将了解 Wear 和移动应用之间建立通信的类和
    API。
- en: 'Now, the boilerplate code that Android Studio has generated a code for the
    timer app. All we need to do is delete all the code and just keep the `onCreate()`
    method. Later, in the `activity_main.xml` file, let''s add the user interface
    that helps the user to chat. Here, I will have `Edittext` and `Textview`, and
    a button that sends the message to the mobile device. Let''s add the XML code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Android Studio 为计时器应用生成了样板代码。我们需要做的是删除所有代码，只保留 `onCreate()` 方法。稍后，在 `activity_main.xml`
    文件中，让我们添加一个帮助用户聊天的用户界面。这里，我将使用 `Edittext` 和 `Textview`，以及一个将消息发送到移动设备的按钮。让我们添加以下
    XML 代码：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, the User Interface is ready. While we want to receive and send messages
    to mobiles, we need to write a service class that extends to `WearableListenerService`
    and the service class needs to be registered in the manifest:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户界面已准备就绪。当我们希望接收和发送消息到移动设备时，我们需要编写一个扩展了 `WearableListenerService` 的服务类，并且需要在清单文件中注册该服务类：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, register the `service` class in the manifest file within the application
    tag scope as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在清单文件的 application 标签范围内以下面的方式注册 `service` 类：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We are registering the `wear` service with the newest standard. Earlier, we
    had to register the service using the `BIND_LISTENER` API. Due to its inefficiency,
    it is deprecated. We have to use the previous `DATA_CHANGED` and `MESSAGE_RECEIVED`
    APIs, since they let the app listen to a particular path. Whereas the `BIND_LISTENER`
    API was listening to the wide range of system messages and that was a performance
    and battery level drawback. The following code illustrates the deprecated `BIND_LISTENER`
    registration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用最新标准注册了 `wear` 服务。之前，我们不得不使用 `BIND_LISTENER` API 来注册服务。由于其低效，它已被弃用。我们必须使用之前的
    `DATA_CHANGED` 和 `MESSAGE_RECEIVED` API，因为它们允许应用监听特定路径。而 `BIND_LISTENER` API 监听广泛范围的系统消息，这是性能和电池电量的缺点。以下代码展示了已弃用的
    `BIND_LISTENER` 注册方法：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After registering the service in the manifest, we can directly work `MainActivity`
    in the Wear module. Before we get started, make sure you have removed all the
    boilerplate code in `MainActivity` with only an `onCreate` method, which looks
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中注册服务后，我们可以在 Wear 模块中的 `MainActivity` 直接进行操作。在开始之前，请确保你已将 `MainActivity`
    中的所有样板代码删除，只留下一个 `onCreate` 方法，如下所示：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Connect all the XML components in `MainActivity`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中连接所有 XML 组件：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s implement the interfaces from `GoogleApiClient` that helps in finding
    connected nodes and for handling failure scenarios:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `GoogleApiClient` 的接口，以帮助查找已连接的节点和处理失败的场景：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After implementing `ConnectionCallbacks` and `OnConnectionFailedListener`,
    we have to override a few methods from this interface, namely, the `onConnected`,
    `onConnectionSuspended`, and `onConnectionFailed` methods. Most of our logic will
    be programmed in the `onConnected` method. Now, inside the `MainActivity` scope,
    we need to write a class that extends `BroadcastReciever` with the overriding
    `onReceive` method for listening to the message:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `ConnectionCallbacks` 和 `OnConnectionFailedListener` 之后，我们必须从这些接口重写一些方法，即
    `onConnected`、`onConnectionSuspended` 和 `onConnectionFailed` 方法。我们大部分逻辑将在 `onConnected`
    方法中编写。现在，在 `MainActivity` 范围内，我们需要编写一个扩展了 `BroadcastReciever` 的类，并重写 `onReceive`
    方法以监听消息：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Register the Local Broadcast receiver in the `onCreate` method as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中注册本地广播接收器，如下所示：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Declare `GoogleApiClient` and Node instances with `WEAR_PATH` for sending messages
    from wear that the mobile app will listen to:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `GoogleApiClient` 和 Node 实例，以及用于从穿戴设备发送消息的 `WEAR_PATH`，移动应用将监听这些消息：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And initialize the `mGoogleApiclient` in the `onCreate` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中初始化 `mGoogleApiclient`：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `onConnected` method, we will use the wearable node API for fetching
    all the connected nodes. It can be a wear or mobile device, which is paired. Using
    the following code, we will know which wear devices are paired:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onConnected` 方法中，我们将使用可穿戴节点 API 来获取所有已连接的节点。它可以是已配对的穿戴设备或移动设备。使用以下代码，我们将知道哪些穿戴设备已配对：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we need to attach `clicklistener` to the `send` button instance for fetching
    the value from `edittext` and passing it to a method that sends the message to
    the mobile device:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为`send`按钮实例添加`clicklistener`，以从`edittext`获取值并将其传递给发送消息到移动设备的方法：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `sendMessage` method takes one string argument and sends the same string
    message to the connected node as bytes. Using `MessageAPI`, we will send the message
    to the mobile. The following code explains how this is achieved:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendMessage`方法接受一个字符串参数，并将相同的字符串消息以字节的形式发送到已连接的节点。使用`MessageAPI`，我们将消息发送到移动设备。以下代码解释了如何实现这一点：'
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s override the `onstart` and `onstop` methods for seeking help in connecting
    and disconnecting `GoogleAPIClient`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`onstart`和`onstop`方法，以便在连接和断开`GoogleAPIClient`时寻求帮助：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The complete wear module `MainActivity` code is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的穿戴模块`MainActivity`代码如下：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The Wear module is ready to receive and send the message to the connected device.
    Now, we need to upgrade our mobile module to receive and send the messages to
    the wear.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 穿戴模块已准备好接收和发送消息到连接的设备。现在，我们需要升级我们的移动模块以接收和发送消息到穿戴设备。
- en: 'Switch to the mobile module and create a service class `WearListner` and override
    the `onMessageReceived` method as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到移动模块，并创建一个服务类`WearListner`，然后重写`onMessageReceived`方法，如下所示：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, register this `WearListner` class in the manifest within the application
    tag scope:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在清单文件的application标签范围内注册这个`WearListner`类：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now let's switch our work-scope to mobile module and add the following changes
    for deeplinking with wear and mobile.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将工作范围切换到移动模块，并添加以下更改以实现与穿戴设备和移动设备的深度链接。
- en: 'Implement the `ConnectionCallbacks` and `OnConnectionFailedListener` interfaces
    from the `GoogleApiClient` class in `ChatActivity`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChatActivity`中实现`GoogleApiClient`类中的`ConnectionCallbacks`和`OnConnectionFailedListener`接口：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Override the methods from the `ConnectionCallbacks` and `OnConnectionFailedListener`
    interfaces similar to what we did for wear `MainActivity`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`ConnectionCallbacks`和`OnConnectionFailedListener`接口中的方法，类似于我们对穿戴设备的`MainActivity`所做的那样：
- en: 'Initialize `GoogleApiClient` in the `onCreate` method as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中初始化`GoogleApiClient`，如下所示：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Write the broadcast receiver class within `ChatActivity` along with the string
    message we received. We need to pass it in the `addMessageBox` method, which we
    have written already:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ChatActivity`中编写广播接收器类以及我们收到的字符串信息。我们需要在已经编写的`addMessageBox`方法中传递它：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Register `MessageReciever` in the `onCreate` method as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中注册`MessageReciever`，如下所示：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After registering the broadcast receiver, write the `SendToDataLayerThread`
    class that extends to the `Thread` class for taking all the load in the separate
    thread, but on UI Thread. In the `void run` method, we will check for all the
    connected nodes and loop through the connected node. Once the connection is established,
    we will use `MessageAPI` to send the message as shown in the code. The Message
    API `sendMessage` method looks for certain parameters, such as `googleclient`,
    and the connected Node ID path, exactly what we registered in the wear manifest
    and the actual message as bytes. Using the `SendMessageResult` instance, we developers
    can make sure of whether the message fired from the device reached the nodes successfully
    or not:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注册广播接收器后，编写`SendToDataLayerThread`类，该类扩展了`Thread`类，在单独的线程中处理所有负载，但仍在UI线程中。在`void
    run`方法中，我们将检查所有已连接的节点并遍历已连接的节点。一旦建立连接，我们将使用`MessageAPI`发送消息，如代码所示。`Message API`的`sendMessage`方法会查找一些参数，例如`googleclient`和已连接节点ID路径，正是我们在穿戴设备清单中注册的内容以及实际的消息字节。使用`SendMessageResult`实例，我们开发者可以确保从设备发出的消息是否成功到达节点：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We need to initialize the `sendtoDatalayer` thread in a the few of methods
    in `chatActivity`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`chatActivity`的几个方法中初始化`sendtoDatalayer`线程：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When `reference1` is updated with some child events, we need to add the message
    to the `sendToDatalayer` thread:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当`reference1`更新了某些子事件时，我们需要将消息添加到`sendToDatalayer`线程中：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following callbacks for connecting and disconnecting the `GoogleApiClient`,
    Add the callbacks in the `ChatActivity`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为连接和断开`GoogleApiClient`添加以下回调，在`ChatActivity`中添加回调：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The chatting application is complete with wear and mobile interaction. Every
    message that chat activity receives is sent to wear and the reply from wear is
    updated to the mobile device.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序通过与穿戴设备和移动设备的交互而完整。`ChatActivity`收到的每条消息都会发送到穿戴设备，并且穿戴设备的回复会更新到移动设备。
- en: 'The chat screen that shows the basic conversation between two users looks as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显示两个用户之间基本对话的聊天界面如下所示：
- en: '![](img/00121.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00121.jpeg)'
- en: 'The wear app screen will look as follows in a round dial watch:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆形表盘手表上，可穿戴应用界面将如下所示：
- en: '![](img/00122.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00122.jpeg)'
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have seen how we can utilize the Firebase real-time database
    as a chatting medium. We assembled a straightforward messaging application that
    can send a reply from a wear device. There is ample space to this project to enhance
    the elements of the project. We have seen how a chatting application can send
    and receive messages crosswise over wear and handheld devices. We have conceptualised
    a chatting application from scratch and we have set Data Layer events for the
    nodes to communicate with each other. The basic idea of Messaging API is to strengthen
    our understanding of wearable communication. Also the `GoogleApiClient` class
    plays a noteworthy part in Play services.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何利用 Firebase 实时数据库作为聊天媒介。我们构建了一个简单的消息应用，可以从可穿戴设备发送回复。这个项目有很大的扩展空间，可以增强项目的各个元素。我们看到了聊天应用如何在可穿戴设备和手持设备之间发送和接收消息。我们从零开始构建了一个聊天应用，并为节点设置了数据层事件，以便它们之间进行通信。消息传递
    API 的基本思想是加强我们对可穿戴设备通信的理解。同时，`GoogleApiClient` 类在 Play 服务中扮演了重要的角色。
- en: In the next chapter, we will understand notifications, Firebase functions, and
    how push notifications can be triggered using Firebase functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解通知、Firebase 功能，以及如何使用 Firebase 函数触发推送通知。
