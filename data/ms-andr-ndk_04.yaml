- en: Chapter 4. Organizing a Virtual Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 组织虚拟文件系统
- en: In this chapter, we will implement low level abstractions to deal with OS-independent
    access to files and filesystems. We will show how to implement portable and transparent
    access to Android assets packed inside `.apk` files without falling back on any
    built-in APIs. This approach is necessary when building multi-platform applications
    debuggable in a desktop environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现低级别的抽象，以处理操作系统无关的文件和文件系统访问。我们将展示如何实现可移植且透明地访问`.apk`文件内部打包的Android资源，而不依赖于任何内置API。在桌面环境中构建可调试的多平台应用程序时，这种方法是必要的。
- en: Mount points
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载点
- en: The concept of mount points can be found in almost every modern filesystem.
    For a multi-platform C++ program, it is convenient to access files across heterogeneous
    storage devices in a unified way. For example, on Android, each read-only data
    file can be stored inside the `.apk` package and the developer is forced to use
    an Android-specific asset management API. On OSX and iOS, accessing program bundles
    requires yet another API, on Windows an application should store everything in
    its folder whose physical path also varies depending on where the application
    was installed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载点的概念几乎在现代每一个文件系统中都可以找到。对于跨平台C++程序来说，以一种统一的方式来访问异构存储设备中的文件非常方便。例如，在Android上，每个只读数据文件可以存储在`.apk`包内，开发者被迫使用特定的Android资产管理API。在OSX和iOS上，访问程序束需要另一个API，在Windows上，应用程序应该将其所有内容存储在其文件夹中，该文件夹的物理路径也取决于应用程序安装的位置。
- en: 'To organize file access across different platforms, we propose a shallow class
    hierarchy that abstracts away the differences of file management, as shown in
    the following figure:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同平台之间组织文件访问，我们提出了一个浅层类层次结构，它抽象了文件管理的差异，如下面的图所示：
- en: '![Mount points](img/image00221.jpeg)![Mount points](img/image00222.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![挂载点](img/image00221.jpeg)![挂载点](img/image00222.jpeg)'
- en: The virtual filesystem is a collection of mount points. Each mount point is
    an abstraction of a filesystem folder. This organization allows us to hide actual
    OS-specific file access routines and file name mapping from the application code.
    This chapter covers the description of filesystems, mount points and stream interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟文件系统是挂载点的集合。每个挂载点都是一个文件系统文件夹的抽象。这种组织方式允许我们将实际的操作系统特定文件访问例程和文件名映射从应用程序代码中隐藏起来。本章涵盖了文件系统、挂载点和流接口的描述。
- en: 'We define an `iMountPoint` interface which can resolve virtual file names and
    create instances of the file reading objects:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`iMountPoint`接口，它可以解析虚拟文件名，并创建文件阅读对象的实例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check whether the virtual file exists at this mount point:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 检查在这个挂载点是否存在的虚拟文件：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Convert a virtual file name to an absolute filename:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟文件名转换为绝对文件名：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `CreateReader()` member function creates a file reader object which implements
    the `iRawFile` interface introduced hereinafter in this chapter. This method is
    usually used only by the `clFileSystem` class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateReader()`成员函数创建一个文件阅读器对象，该对象实现了本章后续介绍的`iRawFile`接口。这个方法通常只被`clFileSystem`类使用：'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last two member functions get and set the internal name of this mount point.
    This string is used later in the `clFileSystem` interface to search and identify
    mount points:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个成员函数获取和设置此挂载点的内部名称。这个字符串稍后会在`clFileSystem`接口中使用，以搜索和识别挂载点：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our virtual filesystem is implemented as a linear collection of mount points.
    The `clFileSystem::CreateReader()` method here creates an `iIStream` object which
    encapsulates access to file data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的虚拟文件系统实现为挂载点的线性集合。这里的`clFileSystem::CreateReader()`方法创建一个`iIStream`对象，该对象封装了对文件数据的访问：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Mount()` method adds a physical (by *physical* we mean an OS-specific
    path) path to the list of mount points. If the `PhysicalPath` value represents
    a folder of the local filesystem, a `clPhysicalMountPoint` instance is created.
    If `PhysicalPath` is the name of a `.zip` or `.apk` file, the `clArchiveMountPoint`
    instance is added to the list of mount points. Definitions of the `clPhysicalMountPoint`
    and `ArchiveMountPoint` classes can be found in the example `1_ArchiveFileAccess`
    from the code bundle:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mount()`方法将一个物理（这里*物理*指的是特定操作系统的路径）路径添加到挂载点列表中。如果`PhysicalPath`值表示本地文件系统的一个文件夹，则会创建一个`clPhysicalMountPoint`实例。如果`PhysicalPath`是一个`.zip`或`.apk`文件的名称，则会将`clArchiveMountPoint`实例添加到挂载点列表中。`clPhysicalMountPoint`和`ArchiveMountPoint`类的定义可以在代码包中的示例`1_ArchiveFileAccess`中找到：'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`VirtualNameToPhysical()` converts our virtual path to an OS-specific system
    file path:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualNameToPhysical()`将我们的虚拟路径转换为特定操作系统的系统文件路径：'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `FileExists()` method inspects each mount point to see if the file exists
    in one of them:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileExists()`方法检查每个挂载点，以确定文件是否存在于其中一个挂载点中：'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The private part of the `clFileSystem` class is responsible for management
    of the internal list of mount points. The `FindMountPoint()` method searches the
    mount point containing a file named `FileName`. The `FindMountPointByName()` method
    is used internally to allow aliasing of file names. `AddMountPoint()` checks if
    the supplied mount point is unique and, if it is, adds it to the `FMountPoints`
    container:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`clFileSystem`类的私有部分负责管理内部挂载点列表。`FindMountPoint()`方法搜索包含名为`FileName`的文件的挂载点。`FindMountPointByName()`方法在内部使用，允许文件名称的别名。`AddMountPoint()`检查提供的挂载点是否唯一，如果是，则将其添加到`FMountPoints`容器中：'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the collection of mount points is stored in `std::vector`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，挂载点集合存储在`std::vector`中：
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we want to access a file in our application code, we do it via the filesystem
    object `g_FS`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在应用程序代码中访问一个文件时，我们是通过文件系统对象`g_FS`来实现的：
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Mount points and streams
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载点与流
- en: On Android, the `test.txt` file is most likely to reside in the `.apk` package
    and a lot of work needs to happen within the `CreateReader()` call. The data for
    `test.txt` is extracted and an instance of `clMemFileMapper` is created. Let's
    travel down the hidden pipeline of file operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，`test.txt`文件很可能位于`.apk`包中，需要在`CreateReader()`调用中完成大量工作。`test.txt`的数据被提取出来，并创建了一个`clMemFileMapper`实例。让我们深入探究文件操作背后的隐藏管道。
- en: 'The code for `CreateReader()` is simple. First, we convert the slashes and
    backslashes in the path to match those of the underlying operating system. Then
    a mount point is found which hosts the file named `FileName`. Finally, an instance
    of `clFileMapper` is created. This class implements the `iIStream` interface.
    Let''s take a closer look at all these classes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateReader()`的代码很简单。首先，我们将路径中的斜杠和反斜杠转换为与底层操作系统匹配的样式。然后找到一个包含名为`FileName`的文件的挂载点。最后，创建一个`clFileMapper`实例。这个类实现了`iIStream`接口。让我们仔细看看这些类：'
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we use the Null Object pattern ([http://en.wikipedia.org/wiki/Null_Object_pattern](http://en.wikipedia.org/wiki/Null_Object_pattern))
    to define neutral behavior in the case of a non-existent file. The `clNullRawFile`
    class represents an empty file not tied to any real device:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用空对象模式（[http://en.wikipedia.org/wiki/Null_Object_pattern](http://en.wikipedia.org/wiki/Null_Object_pattern)）来定义非存在文件的中性行为。`clNullRawFile`类表示一个不与任何实际设备关联的空文件：
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `FindMountPoint()` method iterates the collection of mount points to find
    the one which contains a file with a given name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindMountPoint()`方法遍历挂载点集合，以找到包含给定名称文件的挂载点：'
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Iterate mount points in reverse order, so that the most recently mounted paths
    will be checked first:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 反向迭代挂载点，以便首先检查最近挂载的路径：
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `clFileSystem` class delegates most of its work to individual `iMountPoint`
    instances. For example, the check for file existence is performed by finding the
    appropriate `iMountPoint` object and asking it if a file exists at that point:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`clFileSystem`类将大部分工作委托给各个`iMountPoint`实例。例如，检查文件是否存在是通过找到适当的`iMountPoint`对象并询问该点是否存在文件来执行的：'
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The physical file name is also found using the appropriate `iMountPoint` instance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过适当的`iMountPoint`实例找到物理文件名：
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Physical file names are not used directly to access files. For example, if an
    archive was mounted and we wanted to access the file in the archive, the physical
    path of that file is meaningless to the operating system. Instead, everything
    is abstracted by mount points and physical file names are only used as identifiers
    in our applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 物理文件名不直接用于访问文件。例如，如果挂载了一个存档，并且我们想要访问存档中的文件，那么该文件的物理路径对操作系统来说是没有意义的。相反，一切都由挂载点抽象化，物理文件名只在我们应用程序中作为标识符使用。
- en: The new mount point is added to the collection only if it is unique; there is
    no reason to allow duplicates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当新的挂载点是唯一的时候，它才会被添加到集合中；没有理由允许重复。
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code for `clFileSystem::Mount()` selects which mount point type to instantiate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`clFileSystem::Mount()`的代码选择要实例化的挂载点类型：'
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use a simple hardcoded logic here. If an path ends with a `.zip` or `.apk`
    substring, we instantiate `clArchiveMountPoint`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个简单的硬编码逻辑。如果路径以`.zip`或`.apk`子字符串结尾，我们将实例化`clArchiveMountPoint`：
- en: '[PRE20]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Otherwise, we check if `clPhysicalPath` exists and then create `clPhysicalMountPoint`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将检查`clPhysicalPath`是否存在，然后创建`clPhysicalMountPoint`：
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the mount point creation succeeds, we set its name and add it to the collection:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建挂载点成功，我们设置其名称并将其添加到集合中：
- en: '[PRE22]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will return to the mount point implementations later. Right now, we turn
    to the streams. Actual read access to files is done through the `iIStream` interface:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到挂载点的实现。现在，我们转向流。对文件的实际读取访问是通过`iIStream`接口完成的：
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following two methods get virtual and physical file names respectively:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法分别获取虚拟和物理文件名：
- en: '[PRE24]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Seek()` method sets the absolute reading position; `GetSize()` and `GetPos()`
    determine the size and the current reading position while `Eof()` checks if the
    end of the file has been reached:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seek()`方法设置绝对读取位置；`GetSize()`和`GetPos()`确定大小和当前的读取位置，而`Eof()`检查是否已达到文件末尾：'
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Read()` method reads the block of data with the specified `Size` into
    the untyped memory buffer `Buf`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read()`方法将指定`Size`的数据块读取到无类型内存缓冲区`Buf`中：'
- en: '[PRE26]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last two methods use memory mapping for array-like access to the file data.
    The first one returns a pointer to the shared memory corresponding to this file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法使用内存映射实现对文件数据的数组式访问。第一个返回与此文件对应的共享内存的指针：
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second one returns a pointer to the memory starting from the current file
    position. This is convenient for seamless switching between block and memory-mapped
    styles of access:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法返回从当前文件位置开始的内存指针。这对于在块和内存映射访问样式之间无缝切换非常方便：
- en: '[PRE28]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To avoid UI thread blocking, these methods should be usually called on the worker
    threads.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免UI线程阻塞，这些方法通常应该在工作者线程上调用。
- en: 'All work to access the physical files is done within the `clFileMapper` class.
    It is an implementation of the `iIStream` interface which delegates all the I/O
    to an object implementing the `iRawFile` interface. `iRawFile` itself is not used
    directly in the application code, so let''s look at the `clFileMapper` class first:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有访问物理文件的工作都在`clFileMapper`类中完成。它是`iIStream`接口的一个实现，将所有I/O操作委托给实现`iRawFile`接口的对象。`iRawFile`本身在应用程序代码中不直接使用，所以让我们先看看`clFileMapper`类：
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constructor just stores the reference to the `iRawFile` instance and resets
    the read pointer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是存储了对`iRawFile`实例的引用，并重置了读取指针：
- en: '[PRE30]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `GetVirtualFileName()` and `GetFileName()` methods use the instance of
    `iRawFile` to get virtual and physical file names respectively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetVirtualFileName()`和`GetFileName()`方法使用`iRawFile`的实例分别获取虚拟和物理文件名：'
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Read()` method emulates the `std::ifstream.read` and the `read()` routines
    from `libc`. It might seem unusual, but reading is done with the `memcpy` call
    which accesses the memory-mapped file. The description of `iRawFile::GetFileData()`
    will clarify things:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read()`方法模拟了`std::ifstream.read`和`libc`中的`read()`例程。它可能看起来不寻常，但读取是通过访问内存映射文件的`memcpy`调用完成的。`iRawFile::GetFileData()`的描述将澄清这些问题：'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Positioning and memory mapping are all delegated to the underlying `iRawFile`
    instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定位和内存映射都委托给底层的`iRawFile`实例：
- en: '[PRE33]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The private section contains a reference to `iRawFile` and the current reading
    position:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 私有部分包含了对`iRawFile`的引用和当前的读取位置：
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we can declare the `iRawFile` interface, which is very simple:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以声明`iRawFile`接口，它非常简单：
- en: '[PRE35]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first four methods get and set the virtual and physical file names:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个方法获取和设置虚拟和物理文件名：
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The essence of this interface is in the following two methods, which get the
    raw pointer to the file data and the size of the file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的实质在于以下两个方法，它们获取文件数据的原始指针和文件的大小：
- en: '[PRE37]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The private section contains strings with file names:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 私有部分包含文件名的字符串：
- en: '[PRE38]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Having declared all the interfaces, we may proceed to their implementation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 声明完所有接口后，我们可以继续进行它们的实现。
- en: Accessing files on the host filesystems
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问宿主文件系统中的文件
- en: 'We start from the `clRawFile` class, which uses OS-specific memory-mapping
    routines to map files into the memory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`clRawFile`类开始，它使用特定于操作系统的内存映射例程将文件映射到内存中：
- en: '[PRE39]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Open()` member function does most of the heavy lifting. It stores physical
    and virtual file names, opens a file handle and creates a mapped view of the file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Open()`成员函数完成了大部分繁重的工作。它存储物理和虚拟文件名，打开文件句柄并创建文件的映射视图：'
- en: '[PRE40]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With Windows, we use `CreateFileA()` to open the file. As usual, we enclose
    the OS-specific parts in `#ifdef` blocks.:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们使用`CreateFileA()`来打开文件。像往常一样，我们将特定于操作系统的部分用`#ifdef`块括起来。：
- en: '[PRE41]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the file is opened, we create a mapping object and retrieve a pointer
    to file data using the `MapViewOfFile()` system call:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，我们创建一个映射对象，并使用 `MapViewOfFile()` 系统调用获取指向文件数据的指针：
- en: '[PRE42]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If something goes wrong, close the handle and cancel the operation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，请关闭句柄并取消操作：
- en: '[PRE43]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To prevent reading past the end of the file, we should retrieve the size of
    the file. This is how it''s done with Windows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止读取超出文件末尾，我们应该获取文件的大小。在 Windows 中是这样完成的：
- en: '[PRE44]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With Android, we use `open()` to initialize the file handle and `fstat()` to
    get its size:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，我们使用 `open()` 初始化文件句柄，并使用 `fstat()` 获取其大小：
- en: '[PRE45]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If `fstat()` succeeds, we can retrieve its size. If the file has non-zero size,
    we call the `mmap()` function to map the file into memory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `fstat()` 成功，我们可以获取其大小。如果文件大小非零，我们调用 `mmap()` 函数将文件映射到内存中：
- en: '[PRE46]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make sure we do not call `mmap()` for zero-sized files:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对于大小为零的文件不调用 `mmap()`：
- en: '[PRE47]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can immediately close the file handle once we have the `mmap`-ed memory
    block. This is the standard way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `mmap`-ed 的内存块，就可以立即关闭文件句柄。这是标准做法：
- en: '[PRE48]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Close()` method unmaps the memory block and closes the file handle:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Close()` 方法取消内存块映射并关闭文件句柄：'
- en: '[PRE49]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With Windows, we use the `UnmapViewOfFile()` and `CloseHandle()` system calls:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，我们使用 `UnmapViewOfFile()` 和 `CloseHandle()` 系统调用：
- en: '[PRE50]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With Android, we call the `munmap()` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，我们调用 `munmap()` 函数：
- en: '[PRE51]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The rest of the `clRawFile` class contains two easy methods that return the
    file data pointer and file size. The private part declares file handles, file
    size and the data pointer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`clRawFile` 类的其余部分包含两个简单的方法，返回文件数据指针和文件大小。私有部分声明文件句柄、文件大小和数据指针：'
- en: '[PRE52]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To access physical folders in our virtual filesystem using the `clFileSystem`
    class, we declare the `clPhysicalMountPoint` class representing a single folder
    on the host filesystem:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `clFileSystem` 类访问虚拟文件系统中的物理文件夹，我们声明了 `clPhysicalMountPoint` 类，代表宿主文件系统上的单个文件夹：
- en: '[PRE53]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The constructor of `clPhysicalMountPoint` fixes the physical folder path by
    adding a trailing path separator which is the slash or the backslash character
    depending on the conventions of the underlying OS:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`clPhysicalMountPoint` 的构造函数通过添加一个路径分隔符（根据底层操作系统的约定是斜杠或反斜杠）来修复物理文件夹路径：'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `FileExists()` method uses an OS-dependent routine to check if the file
    exists:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileExists()` 方法使用依赖于操作系统的例程来检查文件是否存在：'
- en: '[PRE55]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`MapName()` converts the virtual file into the physical file name by adding
    the `FPhysicalName` prefix. The `FS_IsFullPath()` routine is defined in the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapName()` 方法通过添加 `FPhysicalName` 前缀将虚拟文件转换为物理文件名。`FS_IsFullPath()` 例程在以下代码中定义：'
- en: '[PRE56]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Instances of `clRawFile` are created in the `clPhysicalMountPoint::CreateReader()`
    method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`clRawFile` 实例是在 `clPhysicalMountPoint::CreateReader()` 方法中创建的：'
- en: '[PRE57]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The private part of the class contains a physical name of the folder:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有部分包含文件夹的物理名称：
- en: '[PRE58]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To complete this code, we have to implement some service routines. The first
    one is `FS_IsFullPath(),` which checks if the path is an absolute one. For Android,
    this means the path starts from the `/` character and, for Windows, the full path
    must start with the `<drive>:\` substring, where `<drive>` is the drive letter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成此代码，我们必须实现一些服务例程。第一个是 `FS_IsFullPath()`，它检查路径是否为绝对路径。对于 Android，这意味着路径以
    `/` 字符开始，对于 Windows，完整路径必须以 `<drive>:\` 子字符串开始，其中 `<drive>` 是驱动器字母：
- en: '[PRE59]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`FS_ValidatePath()` replaces each slash or backslash character with the platform-specific
    `PATH_SEPARATOR`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`FS_ValidatePath()` 方法将每个斜杠或反斜杠字符替换为特定于平台的 `PATH_SEPARATOR`：'
- en: '[PRE60]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To check if the file exists, we use the `stat()` routine whose syntax differs
    slightly with Windows and Android:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件是否存在，我们使用 `stat()` 例程，其语法在 Windows 和 Android 上略有不同：
- en: '[PRE61]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`PATH_SEPARATOR` is a platform-specific character constant:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH_SEPARATOR` 是一个特定于平台的字符常量：'
- en: '[PRE62]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code is enough to access the files stored directly on the host filesystem.
    Let us proceed with other abstractions to get to Android `.apk` packages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码足以访问直接存储在宿主文件系统上的文件。接下来，我们继续了解其他抽象概念以获取 Android `.apk` 包。
- en: In-memory files
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存文件
- en: The following implementation of the `iRawFile` interface encapsulates access
    to untyped memory blocks as file access. We will use this class to access uncompressed
    data in archives.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `iRawFile` 接口的实现封装了对未类型化内存块的访问作为文件访问。我们将使用此类来访问存档中的未压缩数据。
- en: '[PRE63]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The parameterized constructor initializes the pointer to a data buffer and
    its size:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化构造函数用于初始化指向数据缓冲区的指针及其大小：
- en: '[PRE64]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The memory mapping is trivial for a memory block, we just return the stored
    raw pointer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个内存块来说，内存映射是微不足道的，我们只需返回存储的原始指针：
- en: '[PRE65]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We will return to this class once we deal with archive file reading. Now, let's
    get familiar with one more important concept required to access `.apk` packages
    transparently.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理归档文件读取时，将回到这个类。现在，让我们熟悉一个更多重要的概念，这是透明访问`.apk`包所必需的。
- en: Aliasing
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名
- en: The file abstractions mentioned in the preceding section are very powerful.
    They can be used to create nested mount points to access files packed within other
    files. Let's demonstrate the flexibility of this approach by defining `clAliasMountPoint,`
    which acts like a symbolic link on Unix or NTFS filesystems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节提到的文件抽象非常强大。它们可以用来创建嵌套的挂载点，以访问其他文件中打包的文件。让我们通过定义`clAliasMountPoint`来展示这种方法的灵活性，它类似于Unix或NTFS文件系统中的符号链接。
- en: 'The implementation redirects each `iMountPoint::` method call to another mount
    point instance while transforming the file name on the fly by prepending each
    virtual file name we want to access with a specified `FAlias` prefix:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现将每个`iMountPoint::`方法调用重定向到另一个挂载点实例，同时在运行时通过为我们想要访问的每个虚拟文件名添加一个特定的`FAlias`前缀来转换文件名：
- en: '[PRE66]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We add the `FileSystem::AddAlias()` member function which decorates an existing
    mount point''s file names by concatenating them with the `FAlias` prefix:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`FileSystem::AddAlias()`成员函数，它通过将它们与`FAlias`前缀连接起来，来装饰现有挂载点的文件名：
- en: '[PRE67]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This mechanism can be used to transparently remap paths such as `assets/` to
    the root of our filesystem, which is essential to the functionality of our applications
    on Android.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制可以用来将路径（如`assets/`）透明地重映射到我们文件系统的根目录，这对于Android上的应用程序功能至关重要。
- en: Writing files
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写文件
- en: 'Before proceeding to the more complex stuff of archive unpacking, let''s take
    a short break and take a look at how to write to a file. We use the `iOStream`
    interface which declares only four pure virtual methods. The `GetFileName()` method
    returns the virtual file name. The `Seek()` method sets the writing position and
    `GetFilePos()` returns it. The `Write()` method takes an untyped memory buffer
    and writes it to the output stream:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始更复杂的归档解包工作之前，让我们先休息一下，看看如何写入文件。我们使用`iOStream`接口，它只声明了四个纯虚方法。`GetFileName()`方法返回虚拟文件名。`Seek()`方法设置写入位置，`GetFilePos()`返回它。`Write()`方法接受一个无类型的内存缓冲区并将其写入输出流：
- en: '[PRE68]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The only implementation of `iOStream` we provide here is `clMemFileWriter,`
    which treats an untyped memory block as an output stream. This class is used to
    access data in `.zip` files. First, the data is unpacked, then it is wrapped using
    `clMemRawFile`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提供的`iOStream`的唯一实现是`clMemFileWriter`，它将一个无类型的内存块视为输出流。这个类用于访问`.zip`文件中的数据。首先，数据被解包，然后使用`clMemRawFile`进行包装：
- en: '[PRE69]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The actual underlying memory block is RAII-managed ([https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization))
    by the `clBlob` object stored inside this class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的底层内存块由存储在此类中的`clBlob`对象通过RAII管理（[https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)）：
- en: '[PRE70]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `Seek()` method increments the current writing position:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seek()`方法增加当前的写入位置：'
- en: '[PRE71]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Write()` method redirects to the `clBlob` object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write()`方法重定向到`clBlob`对象：'
- en: '[PRE72]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The accompanying source code contains the implementation of the `clFileWriter`
    class which contains the `Open()` method similar to `clRawFile::Open()`. The `Write()`
    method uses system I/O routines to write data to a physical file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的源代码包含了`clFileWriter`类的实现，其中包含了类似于`clRawFile::Open()`的`Open()`方法。`Write()`方法使用系统I/O例程将数据写入物理文件。
- en: Now we have enough scaffolding code to proceed further with`.zip` archives.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有足够的脚手架代码可以进一步处理`.zip`归档。
- en: Accessing the archive files
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问归档文件
- en: 'Since `.apk` is just a fancy `.zip` archive, we use the ZLib library by Jean-loup
    Gailly combined with the MiniZIP library to retrieve compressed files from it.
    The complete source code is about 500 kilobytes in size so we provide two files,
    `libcompress.c` and `libcompress.h`, which are easily integrated into any build
    process. Our goal is to implement the `clArchiveMountPoint` which enumerates files
    in an archive, decompresses the data for the specific file, and creates a `clMemFileMapper`
    to read its data. To do this, we need to introduce a helper class, `clArchiveReader`,
    which reads and decompresses `.zip` archives:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`.apk`实际上就是一个花哨的`.zip`压缩包，我们使用了Jean-loup Gailly的ZLib库结合MiniZIP库来从中获取压缩文件。完整的源代码大约有500千字节大小，因此我们提供了两个文件，`libcompress.c`和`libcompress.h`，它们可以轻松地集成到任何构建过程中。我们的目标是实现`clArchiveMountPoint`，它枚举归档中的文件，为特定文件解压缩数据，并创建一个`clMemFileMapper`来读取其数据。为此，我们需要引入一个辅助类，`clArchiveReader`，它读取和解压缩`.zip`归档文件：
- en: '[PRE73]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The private `sFileInfo` structure is defined in the `clArchiveReader` class
    and encapsulates a pack of useful file properties together with the pointer to
    compressed file data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`clArchiveReader`类中定义的私有的`sFileInfo`结构体封装了一组有用的文件属性以及指向压缩文件数据的指针：'
- en: '[PRE74]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The private section of the `clArchiveReader` class contains a collection of
    `sFileInfo` structures in a `FFileInfos` field, a vector of uppercased file names
    `FFileNames`, a vector of in-archive file names `FReadFileNames`, and an `std::map`
    object, which maps each file name to an index in the extracted files vector `FExtractedFromArchive`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`clArchiveReader`类的私有部分包含一个`sFileInfo`结构的集合，在`FFileInfos`字段中，一个包含大写文件名的`FFileNames`向量，一个包含归档内文件名的`FReadFileNames`向量，以及一个`std::map`对象，它将每个文件名映射到解压文件向量`FExtractedFromArchive`中的索引：'
- en: '[PRE75]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `FSourceFile` field holds a pointer to the source file stream of the `.apk`
    file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`FSourceFile`字段保存指向`.apk`文件的源文件流的指针：'
- en: '[PRE76]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `OpenArchive()` member function invokes `Enumerate_ZIP()` to fill the `FFileInfos`
    container. `CloseArchive()` performs some required cleanup:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenArchive()`成员函数调用`Enumerate_ZIP()`来填充`FFileInfos`容器。`CloseArchive()`执行一些必要的清理工作：'
- en: '[PRE77]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The long `ExtractSingleFile()` method is described in detail below. It accepts
    a name of a compressed file from the archive and an `iOStream` object which contains
    the file data. The `AbortFlag` pointer to an atomic Boolean flag is used for multi-threaded
    decompression. It is polled from time to time in the decompressor. If the value
    is set to `true`, the internal decompression loop terminates prematurely and `ExtractSingleFile()`
    returns `false`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面将详细描述长的`ExtractSingleFile()`方法。它接受来自归档的压缩文件名和一个包含文件数据的`iOStream`对象。`AbortFlag`是指向原子布尔标志的指针，用于多线程解压缩。解压缩器会不时地轮询它。如果值设置为`true`，则内部解压缩循环会提前终止，`ExtractSingleFile()`返回`false`。
- en: 'The `Progress` pointer is used to update the progress of the decompression
    process, which should be atomic as well. An optional `Password` parameter can
    be provided, if an archive is encrypted:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Progress`指针用于更新解压缩进程的进度，这也应该是原子操作。如果归档文件已加密，可以提供一个可选的`Password`参数：'
- en: '[PRE78]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next two methods use the `FFileInfos` vector to check if a file exists
    within this archive and retrieve its decompressed size:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法使用`FFileInfos`向量来检查此归档中是否存在文件并获取其解压缩的大小：
- en: '[PRE79]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `GetFileDataIdx()` method first checks if the file was already decompressed.
    In this case, the pointer from `FExtractedFromArchive` is returned:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFileDataIdx()`方法首先检查文件是否已经解压缩。在这种情况下，返回来自`FExtractedFromArchive`的指针：'
- en: '[PRE80]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the file was not decompressed yet, the `GetFileData_ZIP()` function is called
    and an unpacked memory block from `clBlob` is returned:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件尚未解压缩，将调用`GetFileData_ZIP()`函数，并从`clBlob`返回一个已解包的内存块：
- en: '[PRE81]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `GetFileIdx()` method maps a `FileName` to an internal index into the `FFileInfos`
    vector. It uses the auxiliary `FFileInfoIdx` object to store the string-to-index
    correspondences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFileIdx()`方法将`FileName`映射到`FFileInfos`向量内部的索引。它使用辅助的`FFileInfoIdx`对象来存储字符串到索引的对应关系：'
- en: '[PRE82]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The last two public functions return the number of files in the archive and
    the name of each file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个公共函数返回归档中的文件数量和每个文件的名称：
- en: '[PRE83]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The private section of the `clArchiveReader` class declares internal methods
    for decompressed data management. The `Enumerate_ZIP()` method fills the `FFileInfos`
    container by reading the archive header. The `GetFileData_ZIP()` member function
    extracts file data from the archive:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`clArchiveReader`类的私有部分声明了用于解压缩数据管理的内部方法。`Enumerate_ZIP()`方法通过读取归档头填充`FFileInfos`容器。`GetFileData_ZIP()`成员函数从归档中提取文件数据：'
- en: '[PRE84]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `ClearExtracted()` method is invoked from `CloseArchive()`. It frees the
    allocated memory for each extracted file. Everything here is RAII-managed using
    the `clBlob` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearExtracted()`方法是从`CloseArchive()`中调用的。它会释放每个解压文件所分配的内存。这里的一切都是通过`clBlob`类使用RAII管理的：'
- en: '[PRE85]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s look into the `GetFileData_ZIP()` method implementation which uses the
    `ExtractSingleFile()` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`ExtractSingleFile()`方法的`GetFileData_ZIP()`方法的实现：
- en: '[PRE86]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `clMemFileWriter` object is created, which contains the decompressed data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含解压缩数据的`clMemFileWriter`对象：
- en: '[PRE87]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`ExtractSingleFile()` handles decompression. Here we use a blocking call (the
    `AbortFlag` parameter is `nullptr`) and an empty password:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractSingleFile()`处理解压缩。在这里我们使用了一个阻塞调用（`AbortFlag`参数为`nullptr`）和一个空密码：'
- en: '[PRE88]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the call succeeds, we return the decompressed contents from the `clMemFileWriter`
    object:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们从`clMemFileWriter`对象返回解压缩的内容：
- en: '[PRE89]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `ExtractSingleFile()` method creates the `zlib` reader object, positions
    the reader at the beginning of the compressed file data and calls the `ExtractCurrentFile_ZIP()`
    method to perform the actual decompression:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractSingleFile()`方法创建`zlib`读取对象，将读取器定位在压缩文件数据的开头，并调用`ExtractCurrentFile_ZIP()`方法以执行实际解压缩：'
- en: '[PRE90]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We create the internal structure to allow `zlib` to read from our `iIStream`
    objects. The same thing is done later in `Enumerate_ZIP()`. The `fill_functions()`
    routine and all related callbacks are described below in this section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建内部结构，允许`zlib`从我们的`iIStream`对象中读取。稍后在`Enumerate_ZIP()`中也会进行同样的操作。`fill_functions()`例程以及与此相关的所有回调都在本节下面描述：
- en: '[PRE91]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Return `false` if the file is not found within the archive:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在归档中没有找到文件，则返回`false`：
- en: '[PRE92]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Once we have positioned the reader, we call the `ExtractCurrentFile_ZIP()`
    method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定位了读取器，我们调用`ExtractCurrentFile_ZIP()`方法：
- en: '[PRE93]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The core of our decompressor lays inside `ExtractCurrentFile_Zip`(). Taking
    a memory block as an input, it reads decompressed bytes of the file and writes
    them into the output stream:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解压缩器的核心在于`ExtractCurrentFile_Zip`()。该方法接收一个内存块作为输入，读取文件的解压缩字节，并将其写入输出流：
- en: '[PRE94]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `unzGetCurrentFileInfo64()` function retrieves the uncompressed file size.
    We use it to count the total progress and write it into the `Progress` parameter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`unzGetCurrentFileInfo64()`函数检索未压缩的文件大小。我们用它来计算总进度并将其写入`Progress`参数：'
- en: '[PRE95]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `unzOpenCurrentFilePassword()` call initializes the decompression process:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`unzOpenCurrentFilePassword()`调用初始化了解压缩过程：'
- en: '[PRE96]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The final part of the method is a loop which reads a packet of decompressed
    bytes and calls the `iOStream::Write` method of the `Out` object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的最后部分是一个循环，该循环读取一包解压缩的字节，并调用`Out`对象的`iOStream::Write`方法：
- en: '[PRE97]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In our example implementation based on memory-mapped files, we cast the 64-bit
    file size to `size_t`. This essentially breaks support of files greater than 2Gb
    in size on 32-bit targets. However, this tradeoff is acceptable in most real-world
    mobile applications, unless you are writing the universal `.zip` decompressor,
    of course:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于内存映射文件的示例实现中，我们将64位文件大小转换为`size_t`。这实际上在32位目标上打破了大于2Gb文件的支持。然而，这种权衡在大多数实际移动应用中是可以接受的，除非你正在编写通用的`.zip`解压缩器，当然：
- en: '[PRE98]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Optionally we may break from the loop if the `AbortFlag` pointer (set from
    the other thread) instructs us to do so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以通过检查`AbortFlag`指针（由另一个线程设置）来决定是否跳出循环：
- en: '[PRE99]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `unzReadCurrentFile()` function performs decompression to the output stream:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`unzReadCurrentFile()`函数执行到输出流的解压缩：'
- en: '[PRE100]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'After writing the decompressed data, we update the `Progress` counter accordingly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 写入解压缩数据后，我们相应地更新`Progress`计数器：
- en: '[PRE101]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'At the end, we close the `UnzipFile` reader object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭`UnzipFile`读取器对象：
- en: '[PRE102]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The enumeration of files in an archive is done by yet another member function
    called `Enumerate_ZIP()`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 归档中文件的枚举是通过另一个名为`Enumerate_ZIP()`的成员函数完成的：
- en: '[PRE103]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'First, we fill the callbacks required by `zlib` to read the custom file stream,
    in this case our `iIStream` objects:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们填充`zlib`所需的回调以读取自定义文件流，在本例中是我们的`iIStream`对象：
- en: '[PRE104]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, the header of the archive is read in order to determine the number of
    compressed files:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，读取归档的头部以确定压缩文件的数量：
- en: '[PRE105]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'For each compressed file, we extract the information which we reuse later for
    decompression:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个压缩文件，我们提取稍后用于解压缩的信息：
- en: '[PRE106]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In each iteration, we fill the `sFileInfo` structure and store it in the `FFileInfos`
    vector:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们填充`sFileInfo`结构并将其存储在`FFileInfos`向量中：
- en: '[PRE107]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'All the backslashes in the file name are converted into the characters that
    separate elements of the path within the archive. The `FFileInfoIdx` map is filled
    for a quick lookup of the file index:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中的所有反斜杠都被转换为在归档内路径元素之间起分隔作用的字符。`FFileInfoIdx`映射被填充，以便快速查找文件索引：
- en: '[PRE108]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Finally, we clean up the `zlib` reader object and return the success code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清理`zlib`读取器对象并返回成功代码：
- en: '[PRE109]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Let''s take a closer look at the `fill_functions()` method. The memory block
    is contained in `iIStream`, so we implement a number of callbacks required by
    `zlib` to work with our stream class. The first method `zip_fopen()` does the
    preparation of `iIStream`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`fill_functions()`方法。内存块包含在`iIStream`中，因此我们实现了一组`zlib`需要的回调，以便与我们的流类一起工作。第一个方法`zip_fopen()`对`iIStream`进行准备：
- en: '[PRE110]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The reading of bytes from `iIStream` is implemented in `zip_fread()`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iIStream`读取字节的操作在`zip_fread()`中实现：
- en: '[PRE111]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `zip_ftell()` function tells the current position in `iIStream`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip_ftell()`函数告诉`iIStream`中的当前位置：'
- en: '[PRE112]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `zip_fseek()` routine sets the reading pointer, just like `libc`''s `fseek()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip_fseek()`例程设置读取指针，就像`libc`的`fseek()`一样：'
- en: '[PRE113]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For the `iIstream` class, `fclose()`, and `ferror()`, analogues are trivial:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`iIstream`类，`fclose()`和`ferror()`的类似操作是微不足道的：
- en: '[PRE114]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'A helper `fill_functions()` routine fills the callback structure used by `zlib`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助`fill_functions()`例程填充了`zlib`使用的回调结构：
- en: '[PRE115]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'That was all on the low-level decompression details. Let us get higher into
    the territory of more friendly abstractions and wrappers. The `clArchiveMountPoint`
    class wraps an instance of `clArchiveReader` and implements the `CreateReader()`,
    `FileExists()`, and `MapName()` methods:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于低级解压缩细节的全部内容。让我们进入更友好的抽象和包装领域。`clArchiveMountPoint`类包装了`clArchiveReader`的一个实例，并实现了`CreateReader()`、`FileExists()`和`MapName()`方法：
- en: '[PRE116]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `CreateReader()` method instantiates a `clMemRawFile` class and attaches
    an extracted memory block:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateReader()`方法实例化`clMemRawFile`类并附加一个提取的内存块：'
- en: '[PRE117]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `FileExists()` method is an indirection to `clArchiveReader::FileExists()`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileExists()`方法是对`clArchiveReader::FileExists()`的间接调用：'
- en: '[PRE118]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `MapName()` implementation is trivial for this type of a mount point:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类挂载点，`MapName()`的实现是微不足道的：
- en: '[PRE119]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The private section contains only a reference to a `clArchiveReader` object:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 私有部分只包含对`clArchiveReader`对象的引用：
- en: '[PRE120]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The obvious drawback of the simple `clArchiveMountPoint` is its non-asynchronous
    blocking implementation. The constructor accepts a fully initialized `clArchiveReader`
    object, which means we need to block until `clArchiveReader:: OpenArchive()` gets
    its job done. One way to overcome this is to run `OpenArchive()` on a different
    thread, in a task queue, and create the mount point once the archive is parsed.
    Of course, all subsequent calls to `CreateReader()` expecting data from this mount
    point should be postponed until a signal is raised. We encourage the reader to
    implement this kind of asynchronous mechanism as an exercise using the `clWorkerThread`
    class discussed in the previous chapter. A more sophisticated archive mount point
    implementation can accept a constructed `clArchiveReader` and invoke `OpenArchive()`
    itself. This requires more elaborate architecture as `clFileSystem` and/or `clArchiveMountPoint`
    classes should have access to a dedicated worker thread. However, it essentially
    hides all the complexity of time-consuming decompression operations behind the
    lean interface.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见，简单的`clArchiveMountPoint`的缺点在于其非异步阻塞实现。构造函数接受一个完全初始化的`clArchiveReader`对象，这意味着我们需要阻塞直到`clArchiveReader::OpenArchive()`完成其工作。克服此问题的一种方法是在不同的线程上运行`OpenArchive()`，在任务队列中，并在解析归档后创建挂载点。当然，所有后续调用`CreateReader()`以期望从此挂载点获取数据的操作应该推迟，直到收到信号。我们鼓励读者使用前一章讨论的`clWorkerThread`类实现这种异步机制。更复杂的归档挂载点实现可以接受构建的`clArchiveReader`并自行调用`OpenArchive()`。这需要更复杂的架构，因为`clFileSystem`和/或`clArchiveMountPoint`类应该能够访问专用的工人线程。然而，它本质上将所有耗时的解压缩操作复杂性隐藏在简洁的接口背后。
- en: Accessing application assets
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问应用程序资产
- en: To access the data packed inside the `.apk` package on Android in your C++ code,
    we need to get the path to `.apk` by using Java code and passing the result into
    our C++ code using JNI.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android上的C++代码中访问`.apk`包内的数据，我们需要使用Java代码获取`.apk`的路径，并使用JNI将结果传递给我们的C++代码。
- en: 'In the `onCreate()` method, pass the value obtained from `getApplication().getApplicationInfo().sourceDir`
    into our native code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，将来自`getApplication().getApplicationInfo().sourceDir`的值传递给我们的本地代码：
- en: '[PRE121]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The implementation of `onCreateNative()` can be found in `1_ArchiveFileAccess\jni\Wrappers.cpp`
    and looks as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateNative()`的实现可以在`1_ArchiveFileAccess\jni\Wrappers.cpp`中找到，如下所示：'
- en: '[PRE122]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We use the `ConvertJString()` function to convert `jstring` into `std::string`.
    The JNI methods `GetStringUTFChars()` and `ReleaseStringUTFChars()` get and release
    the pointer to an array of UTF8-encoded characters of the string:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ConvertJString()`函数将`jstring`转换为`std::string`。JNI方法`GetStringUTFChars()`和`ReleaseStringUTFChars()`获取和释放指向字符串的UTF8编码字符数组的指针：
- en: '[PRE123]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The simple usage example is implemented in the `OnStart()` callback inside
    the `main.cpp` file. It mounts the path, creates an archive mount point on Android,
    opens the archive `test.zip` and enlists its content. On a desktop, this code
    runs and reads `test.zip` which is stored at `assets/test.zip`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中的`OnStart()`回调中实现了简单的使用示例。它挂载路径，在Android上创建归档挂载点，打开归档`test.zip`并列出其内容。在桌面上，此代码运行并读取存储在`assets/test.zip`的`test.zip`：
- en: '[PRE124]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Iterate over all the files in this archive and print their names and contents:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历此归档中的所有文件并打印它们的名字和内容：
- en: '[PRE125]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Check the `1_ArchiveFileAccess` example and try it for yourself. It provides
    a great debugging experience of the Android file access code on your desktop machine.
    Use `make all` to build for the desktop environment and `ndk-build & ant debug`
    to build for Android.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 查看并尝试`1_ArchiveFileAccess`示例。它为在桌面上调试Android文件访问代码提供了很好的体验。使用`make all`构建桌面环境，使用`ndk-build
    & ant debug`构建Android。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to deal with files and `.apk` archives via C++
    in a platform-independent way. We will use this functionality in the subsequent
    chapters to access files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何以与平台无关的方式通过C++处理文件和`.apk`归档。我们将在后续章节中使用此功能来访问文件。
