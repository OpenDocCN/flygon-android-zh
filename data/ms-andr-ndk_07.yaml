- en: Chapter 7. Cross-platform UI and Input System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章. 跨平台UI与输入系统
- en: In the previous chapter, we introduced classes and interfaces for platform-independent
    rendering. Here, we make a slight detour on our way to a 3D OpenGL renderer and
    use the SDL library to render elements of the user interface. To render our UI,
    we need lines, rectangles, textured rectangles, and text strings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了用于平台独立渲染的类和接口。在这里，我们在通往3D OpenGL渲染器的路上稍作绕行，使用SDL库渲染用户界面的元素。为了渲染我们的UI，我们需要线条、矩形、纹理矩形和文本字符串。
- en: We will begin this chapter with the description of the `iCanvas` interface designed
    to render geometric primitives. The most complex part of `iCanvas` is Unicode
    text rendering, which is implemented using the FreeType library. Font glyphs caching
    is also a very important topic for complex UIs, which is discussed here. The second
    part of the chapter describes a multipage graphical user interface suitable for
    being the cornerstone for building interfaces of multiplatform applications. The
    chapter is concluded with an SDL application, which demonstrates capabilities
    of our UI system in action.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述`iCanvas`接口开始本章，该接口旨在渲染几何图元。`iCanvas`最复杂的部分是Unicode文本渲染，它使用FreeType库实现。字体字符缓存对于复杂的UI来说也是一个非常重要的主题，这里将讨论这个问题。本章的第二部分描述了一个多页图形用户界面，适用于构建多平台应用程序的界面基石。本章以一个SDL应用程序结束，该程序展示了我们UI系统在实际中的能力。
- en: Rendering
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: 'Right now, we use only the SDL library without any OpenGL, so we will declare
    the `iCanvas` interface to allow immediate, but not always fast, rendering of
    geometric primitives and avoid creating the `GLVertexArray` instances described
    in the previous chapter. Later, we might provide a different `iCanvas` implementation
    to switch to another renderer:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们仅使用SDL库，不使用任何OpenGL，因此我们将声明`iCanvas`接口，以允许立即渲染几何图元，但不一定快速，并避免创建前一章描述的`GLVertexArray`实例。稍后，我们可能会提供不同的`iCanvas`实现，以切换到另一个渲染器：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first two methods set the current rendering color specified as a triple
    of RGB integers or a 4-dimensional vector, which contains an additional alpha
    transparency value:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法设置当前的渲染颜色，指定为RGB整数的三元组或包含额外alpha透明度的4维向量：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Clear()` method clears the screen rendering surface:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear()`方法清除屏幕渲染表面：'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Rect()` and `Line()` methods render a rectangle and a line respectively,
    as their names suggest:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect()`和`Line()`方法分别按照其名称所示渲染矩形和线条：'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The texture-related group of methods manages the creation and updation of textures.
    The `CreateTexture()` method returns an integer handle of the created texture.
    The texture handle `Idx` is passed as an argument to the `UpdateTexture()` member
    function to upload bitmap data into the texture. The `Pixels` parameter holds
    a bitmap object with pixel data:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理相关的一组方法管理纹理的创建和更新。`CreateTexture()`方法返回创建的纹理的整数句柄。纹理句柄`Idx`作为参数传递给`UpdateTexture()`成员函数，以将位图数据上传到纹理中。`Pixels`参数持有包含像素数据的位图对象：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `TextureRect()` method renders a quadrilateral using a specified texture:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextureRect()`方法使用指定的纹理渲染一个四边形：'
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The text rendering is done with a single `TextStr()` call, which specifies
    the rectangular area in which the text should be fit (or clamped), string to be
    rendered, font height in points, text color, and font ID from the `TextRenderer`
    class, which we will describe later:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 文本渲染通过单个`TextStr()`调用完成，该调用指定了文本应适应（或夹紧）的矩形区域、要渲染的字符串、字体大小的点数、文本颜色以及来自`TextRenderer`类的字体ID，我们将在后面进行描述：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last public member function is `Present()`, which ensures that all the
    primitives are shown on the screen:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个公共成员函数是`Present()`，它确保所有图元都显示在屏幕上：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We provide two implementations of the `iCanvas` interface. One uses the SDL
    library, the other is based on pure OpenGL calls. The `clSDLCanvas` class contains
    a pointer to an SDL renderer object `m_Renderer`. The constructor of `clSDLCanvas`
    takes a pointer to an instance of the `clSDLWindow` class, described in the previous
    chapter, to create a renderer attached to the window:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个`iCanvas`接口的实现。一个使用SDL库，另一个基于纯OpenGL调用。`clSDLCanvas`类包含指向SDL渲染器对象`m_Renderer`的指针。`clSDLCanvas`的构造函数接受指向前一章描述的`clSDLWindow`类实例的指针，以创建与窗口关联的渲染器：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `clSDLCanvas` class directly calls the corresponding SDL routines to render
    rectangles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSDLCanvas`类直接调用相应的SDL例程来渲染矩形：'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `SetColor()`, `Clear()`, and `Present()` member functions also call the
    appropriate SDL routines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetColor()`，`Clear()`，和`Present()`成员函数也调用相应的SDL例程：'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to do some bookkeeping to synchronize our `clBitmap` object with `SDL_Texture`.
    The internals look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做一些记录以同步我们的`clBitmap`对象与`SDL_Texture`。内部结构如下：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `CreateTexture()` method allocates a new SDL texture:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateTexture()`方法分配一个新的SDL纹理：'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will use the pixel data within the `Pixels` object to update the SDL texture:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Pixels`对象中的像素数据来更新SDL纹理：
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we assume the pitch of the texture is always equal to the pitch of our
    raw pixel data. This is not true in general. However, this assumption always holds
    for power-of-two textures. We suggest that you implement pitch-respecting texture
    updates as an exercise:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设纹理的间距总是等于我们原始像素数据的间距。这在一般情况下不成立。然而，这个假设对于2的幂次纹理总是成立的。我们建议你实现尊重间距的纹理更新作为一个练习：
- en: '[PRE14]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the texture is created, we store it in the `m_Texture` container:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建纹理后，我们将其存储在`m_Texture`容器中：
- en: '[PRE15]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `UpdateTexture()` method is similar, except that it does not create a new
    texture and reuses the texture size from the previous one, hence, making updates
    much faster:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateTexture()`方法类似，不同之处在于它不创建新纹理，而是重用前一个纹理的大小，因此，更新速度更快：'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To update the texture, we will call the `SDL_LockTexture()` to get a pointer
    to the texture data and use `memcpy()` to copy bitmap pixels:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新纹理，我们将调用`SDL_LockTexture()`以获取指向纹理数据的指针，并使用`memcpy()`来复制位图像素：
- en: '[PRE17]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, this only works for textures with the same pitch as in the provided
    bitmap:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这也只适用于与所提供位图相同间距的纹理：
- en: '[PRE18]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the texture is not required any more, it can be deleted using the `DeleteTexture()`
    member function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要纹理时，可以使用`DeleteTexture()`成员函数来删除它：
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `TextureRect()` method calls the `SDL_RenderCopy()` function to draw a
    texture mapped rectangle:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextureRect()`方法调用`SDL_RenderCopy()`函数来绘制纹理映射的矩形：'
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `TextStr()` method renders a UTF-8 encoded string into a rectangular region.
    It uses the FreeType library and requires some advanced machinery to work. We
    will discuss its implementation in the following sections. Let''s have a look
    at the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextStr()`方法将UTF-8编码的字符串渲染到一个矩形区域内。它使用FreeType库，需要一些高级机制才能工作。我们将在以下章节讨论其实现。先来看看下面这个：'
- en: '[PRE21]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Basically, the `iCanvas` interface was designed around SDL, and its purpose
    is to hide the dependency on SDL behind a lightweight interface, so another implementation
    can be used relatively easily. Here, we implement the `iCanvas` interface using
    OpenGL and classes we introduced in the previous chapter. Take a look at the `clGLCanvas`
    class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`iCanvas`接口是围绕SDL设计的，其目的是将SDL的依赖隐藏在一个轻量级的接口之后，这样相对容易地使用另一种实现。在这里，我们使用OpenGL以及前一章中引入的类来实现`iCanvas`接口。看看`clGLCanvas`类。
- en: 'First, we need to define some GLSL shaders required to render filled and textured
    rectangles. We can do it naturally using the C++11 raw string literals. The vertex
    shader does remapping of window normalized coordinates, used in our canvas, into
    OpenGL normalized device coordinates and is shared between all fragment programs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一些GLSL着色器，以渲染填充和纹理矩形。我们可以自然地使用C++11原始字符串字面量来做这件事。顶点着色器重新映射我们画布中使用的窗口标准化坐标到OpenGL标准化设备坐标，并且被所有片段程序共享：
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We take the rectangle 0,0…1,1 and remap it into the required rectangle *X1,Y1-X2,Y2*.
    This way, we can use a single vertex array object to render any rectangle:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取0,0…1,1的矩形并将其重新映射到所需的矩形*X1,Y1-X2,Y2*。这样，我们可以使用单个顶点数组对象来渲染任何矩形：
- en: '[PRE23]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This fragment shader is used to render a flat colored rectangle:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段着色器用于渲染一个单色矩形：
- en: '[PRE24]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A texture-mapped version is marginally more complex. We modulate the constant
    color with a texture:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理映射的版本稍微复杂一些。我们将常数颜色与纹理进行调制：
- en: '[PRE25]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the constructor of `clGLCanvas`, we will create all persistent OpenGL objects
    required for rendering:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clGLCanvas`的构造函数中，我们将创建渲染所需的所有持久OpenGL对象：
- en: '[PRE26]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Initialize our OpenGL wrapper:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化我们的OpenGL包装器：
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The geometry of this rectangle is reused to render rectangles of any dimensions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩形的几何形状被重用来渲染任何尺寸的矩形：
- en: '[PRE28]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Link two shader programs from the source code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码中链接两个着色器程序：
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A private helper function is used to convert integer window coordinates into
    normalized window coordinates that we use in our shaders:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个私有辅助函数用于将整数窗口坐标转换为我们在着色器中使用的标准化窗口坐标：
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the actual rendering code is very straightforward. Let''s render a filled
    rectangle first:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际的渲染代码非常直接。首先让我们渲染一个填充的矩形：
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since alpha blending is a very costly operation, enable it only if the alpha
    channel of the color actually implies transparency:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于alpha混合是一个非常耗时的操作，只有当颜色的alpha通道实际暗示透明时才启用它：
- en: '[PRE32]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Disable blending again:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次禁用混合：
- en: '[PRE33]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our implementation is very simple and does not do any state change tracking,
    which is very costly once you do a lot of `Rect()` calls. We would suggest that
    you add a method to the `iCanvas` interface, which can render a pack of rectangles
    at once sorting them into transparent and non-transparent buckets before rendering.
    This way multiple rectangles can be rendered reasonably fast. By the way, SDL
    does it in a similar fashion providing the `SDL_FillRects()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简单，并不进行任何状态更改跟踪，一旦你进行大量`Rect()`调用时，这会非常耗时。我们建议你向`iCanvas`接口添加一个方法，该方法可以一次渲染一系列矩形，并在渲染之前将它们分类为透明和非透明桶。这样，多个矩形的渲染速度可以相对较快。顺便一提，SDL以类似的方式提供`SDL_FillRects()`函数。
- en: 'Since we can use our `clGLTexture` class, texture management functions are
    now simple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以使用我们的`clGLTexture`类，纹理管理功能现在变得简单了：
- en: '[PRE34]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `UpdateTexture()` and `DeleteTextures()` functions are almost one-liners,
    except the parameter validity check:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateTexture()`和`DeleteTextures()`函数几乎是一行代码，除了参数有效性检查：'
- en: '[PRE35]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s draw a textured rectangle using these textures. Most of the hassle is
    similar to `Rect()`, except the texture binding:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些纹理绘制一个纹理矩形。大部分工作与`Rect()`类似，除了纹理绑定：
- en: '[PRE36]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Bind the required texture to the texture unit `0`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将所需的纹理绑定到纹理单元`0`：
- en: '[PRE37]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `m_TexRectSP` shader program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`m_TexRectSP`着色器程序：
- en: '[PRE38]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Blending is always used for textured rectangles since individual texels can
    be transparent:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有透明texel的纹理矩形，总是使用混合：
- en: '[PRE39]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A similar optimization with the OpenGL state changes can be implemented here.
    We leave it to you to implement this caching mechanism. Now, let's proceed with
    the text rendering, so we can return to `clGLCanvas::TextStr()` afterwards.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL状态更改上可以实现类似的优化。我们留给你实现这种缓存机制。现在，让我们继续文本渲染，以便稍后可以返回到`clGLCanvas::TextStr()`。
- en: Text rendering
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本渲染
- en: 'In this section, we describe every essential detail of the text rendering process
    implemented in the `clTextRenderer` class. Here are the parts of our text renderer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述`clTextRenderer`类中实现的文本渲染过程的所有重要细节。以下是我们的文本渲染器的部分：
- en: UTF-8 string decoding ([http://en.wikipedia.org/wiki/UTF-8](http://en.wikipedia.org/wiki/UTF-8))
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8字符串解码（[http://en.wikipedia.org/wiki/UTF-8](http://en.wikipedia.org/wiki/UTF-8)）
- en: Text size calculation, kerning, and advance calculation
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本大小计算、字距调整和前进计算
- en: Rendering of individual glyph, just like the one in the FreeType example from
    [Chapter 2](part0024.xhtml#aid-MSDG2 "Chapter 2. Native Libraries"), *Native Libraries*
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个字形的渲染，就像[第2章](part0024.xhtml#aid-MSDG2 "Chapter 2. Native Libraries")中的FreeType示例，*本地库*
- en: Fonts and glyphs loading and caching
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体和字形加载与缓存
- en: String rendering
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串渲染
- en: We assume all the strings are in the UTF-8 encoding because this way all Latin
    characters with ASCII codes between 0 and 127 take exactly one byte, and various
    national symbols take up to four bytes. The only problem with UTF-8 is that FreeType
    accepts fixed-width 2-byte UCS-2 encoding, so we have to include the decoding
    routine to convert from UTF-8 to UCS-2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设所有字符串都是UTF-8编码，因为这样所有ASCII码在0到127之间的拉丁字符正好占一个字节，各种国家符号最多占四个字节。UTF-8唯一的问题是FreeType接受固定宽度的2字节UCS-2编码，因此我们必须包含解码例程以从UTF-8转换为UCS-2。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a nice article on the absolute minimum every software developer must
    know about Unicode and character sets. Check it out at [http://www.joelonsoftware.com/articles/Unicode.html](http://www.joelonsoftware.com/articles/Unicode.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于每个软件开发者都必须了解的Unicode和字符集的绝对基础知识的优秀文章。查看[http://www.joelonsoftware.com/articles/Unicode.html](http://www.joelonsoftware.com/articles/Unicode.html)。
- en: 'We store each character of rendered string in the `FString` field of `clTextRenderer`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染字符串的每个字符存储在`clTextRenderer`的`FString`字段中：
- en: '[PRE40]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A character description is stored in the following structure with the UCS-2
    character code in the `FChar` field and an internal character index `FIndex`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符的描述存储在以下结构中，其中`FChar`字段包含UCS-2字符代码，内部字符索引为`FIndex`：
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An `FGlyph` field holds the FreeType `FT_Glyph` structure with a rendered glyph:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`FGlyph`字段保存了带有渲染字形的FreeType `FT_Glyph`结构：'
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After decoding character codes, we calculate the pixel width and advance for
    each glyph and store these values in `FWidth` and `FAdvance`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解码字符编码后，我们计算每个字形的像素宽度和前进值，并将这些值存储在`FWidth`和`FAdvance`中：
- en: '[PRE43]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `FCacheNode` field is used internally by FreeType font caching subsystem
    and is described briefly as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`FCacheNode`字段由FreeType字体缓存子系统内部使用，以下是其简要描述：'
- en: '[PRE44]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The default constructor sets null values for each field:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数为每个字段设置空值：
- en: '[PRE45]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that we have a structure to hold our characters, we show how to process
    a string and calculate positions for each character. The subsequent paragraphs
    of this chapter describe the internal details of `clTextRenderer`, so that when
    we declare new fields, they are meant to be in the `clTextRenderer` class. We
    start with high-level routines that can render strings. After this, we get to
    UTF-8 decoding, and finally, show how to implement fonts management and caching.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个结构来保存我们的字符，下面将展示如何处理字符串并计算每个字符的位置。本章的后续段落描述了`clTextRenderer`的内部细节，因此当我们声明新字段时，意味着它们属于`clTextRenderer`类。我们从可以渲染字符串的高级例程开始。之后，我们讨论UTF-8解码，最后展示如何实现字体管理和缓存。
- en: Calculating glyph positions and string size in pixels
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算字形位置和字符串大小的像素值
- en: 'The `LoadStringWithFont()` member function takes a text string, an internal
    font identifier and desired font height in pixels. It calculates parameters of
    each element in the `FString` array. This routine is used in rendering and text
    size calculation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadStringWithFont()`成员函数接收一个文本字符串、内部字体标识符和所需的字体高度（以像素为单位）。它计算`FString`数组中每个元素的参数。此例程用于渲染和文本大小计算：'
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'First, we get the font handle and determine if we need kerning. `FFace` is
    a field of type `FT_Face` within `clTextRenderer`. The `GetSizedFace()` method
    retrieves the font matching the desired height. It uses internal font cache to
    avoid rendering the game glyphs multiple times for a single resolution and is
    discussed in great detail later in this chapter. Take a look at the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取字体句柄并确定是否需要字距调整。`FFace`是`clTextRenderer`中的`FT_Face`类型的字段。`GetSizedFace()`方法检索与所需高度匹配的字体。它使用内部字体缓存，以避免为单个分辨率多次渲染游戏字形，这一部分将在本章后面详细讨论。请看以下代码：
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we decode the UTF-8 string to UCS-2 and fill the `FString` array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将UTF-8字符串解码为UCS-2，并填充`FString`数组：
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After `FString` is filled, we render each character and calculate positions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`FString`后，我们渲染每个字符并计算位置：
- en: '[PRE49]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, we get the character index for the font and skip the end-of-line and
    carriage return characters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取字体的字符索引，并跳过行尾和回车字符：
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once we know the index of the character, we may call the `FT_RenderGlyph()`
    method, but this is quite suboptimal to render a single glyph each time it is
    encountered. The `GetGlyph()` routine does all the work to extract a glyph from
    the cache:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道字符的索引时，我们可以调用`FT_RenderGlyph()`方法，但每次遇到时都渲染单个字形是相当低效的。`GetGlyph()`例程负责从缓存中提取字形：
- en: '[PRE51]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If the glyph has been loaded successfully, we call the `SetAdvance()` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字形加载成功，我们会调用`SetAdvance()`方法：
- en: '[PRE52]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Optionally, we can call the `Kern()` method to adjust the advance of the current
    character:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以调用`Kern()`方法来调整当前字符的前进值：
- en: '[PRE53]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The auxiliary `SetAdvance()` method calculates the bounding box of a glyph
    and stores its width and advance in the `sFTChar` structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助`SetAdvance()`方法计算字形的边界框，并将其宽度和前进值存储在`sFTChar`结构中：
- en: '[PRE54]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The advance is stored as a `22:10` fixed-point value, we convert it to an integer
    value using a bitwise shift:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前进值以`22:10`固定点值存储，我们使用位运算移位将其转换为整数值：
- en: '[PRE55]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FT_Glyph_Get_CBox()` function returns a bounding box; we use its `xMax`
    field:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`FT_Glyph_Get_CBox()`函数返回一个边界框；我们使用它的`xMax`字段：'
- en: '[PRE56]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For some glyphs, such as a whitespace, the width is zero and we use the `FAdvance`
    field:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些字形，如空格，宽度为零，我们使用`FAdvance`字段：
- en: '[PRE57]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Kern()` routine takes two adjacent characters and calculates the advance
    correction. Our text renderer does not support automatic ligature substitution,
    and this might be the place to do it if such a substitution is required:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kern()`例程取两个相邻字符并计算前进校正。我们的文本渲染器不支持自动连字替换，如果需要这种替换，这里可能是执行它的地方：'
- en: '[PRE58]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'No kerning is required at the beginning and at the end of the string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的开头和结尾不需要进行字距调整：
- en: '[PRE59]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `FT_GetKerning()` call calculates the relative offset correction for the
    current character:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`FT_GetKerning()`调用计算当前字符的相对偏移校正：'
- en: '[PRE60]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The result is added to the advance value:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被加到前进值中：
- en: '[PRE61]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Using the `FString` array, we calculate the rendered string size easily by
    summing sizes of individual characters. Later, this size value is used to allocate
    the output bitmap for the string:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FString`数组，我们可以通过简单相加各个字符的大小来轻松计算渲染字符串的大小。稍后，这个大小值用于为字符串分配输出位图：
- en: '[PRE62]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `StrMinY` and `StrMaxY` variables hold minimum and maximum pixel coordinates
    of a character in a string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`StrMinY`和`StrMaxY`保存了字符串中字符的最小和最大像素坐标：
- en: '[PRE63]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `SizeX` variable holds the number of horizontal pixels in the string bitmap.
    We iterate the `FString` array and add the advance of each character to `SizeX`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`SizeX`变量保存字符串位图中的水平像素数。我们迭代`FString`数组，并将每个字符的前进值加到`SizeX`上：'
- en: '[PRE64]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For each character, we get the glyph''s bitmap and update the `SizeX` variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个字符，我们获取字形的位图并更新`SizeX`变量：
- en: '[PRE65]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After reading off the dimensions of a glyph, we update the minimum and maximum
    dimensions of the string:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 读取字形尺寸后，我们更新字符串的最小和最大尺寸：
- en: '[PRE66]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we calculate the integer value `Width` of the string by converting
    the `26:6` fixed-point value `SizeX` to pixels:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将`26:6`固定点值`SizeX`转换为像素来计算字符串的整数值`Width`：
- en: '[PRE67]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Before doing glyphs rendering, we still should check out yet another important
    thing. Let's outline the process of UTF-8 characters decoding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行字形渲染之前，我们还需要检查另一个重要事项。让我们概述UTF-8字符解码的过程。
- en: Decoding UTF-8
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码UTF-8
- en: 'The `DecodeUTF8()` routine mentioned in the preceding section, which was used
    in `LoadStringWithFont()`, iterates the incoming byte array and uses `DecodeNextUTF8Char()`
    to get the character code in the UCS-2 encoding:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节提到的`DecodeUTF8()`例程，在`LoadStringWithFont()`中使用，迭代传入的字节数组，并使用`DecodeNextUTF8Char()`获取UCS-2编码中的字符代码：
- en: '[PRE68]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'First, we store a pointer to a buffer and set the current position to zero:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们存储一个指向缓冲区的指针，并将当前位置设置为0：
- en: '[PRE69]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `FLength` field contains the number of bytes in `InStr`. The method `DecodeNextUTF8Char()`
    uses `FLength` to stop the decoding process when the end of string is reached:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLength`字段包含`InStr`中的字节数。`DecodeNextUTF8Char()`方法使用`FLength`在到达字符串末尾时停止解码过程：'
- en: '[PRE70]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we will iterate the vector of bytes in `FBuffer` until the zero byte
    is encountered:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历`FBuffer`中的字节数组，直到遇到零字节：
- en: '[PRE71]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The UCS-2 character code is the only thing we change in the new `sFTChar` instance:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: UCS-2字符代码是我们在新的`sFTChar`实例中唯一更改的东西：
- en: '[PRE72]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The UTF-8 decoder in `DecodeNextUTF8Char()` is based on the source code from
    the JSON checker, which can be downloaded from [http://www.json.org/JSON_checker/utf8_decode.c](http://www.json.org/JSON_checker/utf8_decode.c).
    To save space, we omit rather straightforward bit manipulation. The low-level
    implementation details can be found in the accompanying source code, just take
    a look at `TextRenderer.h` and `TextRenderer.cpp`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecodeNextUTF8Char()`中的UTF-8解码器基于来自[http://www.json.org/JSON_checker/utf8_decode.c](http://www.json.org/JSON_checker/utf8_decode.c)的JSON检查器的源代码。为了节省空间，我们省略了相当直接的位操作。低级实现细节可以在伴随的源代码中找到，只需查看`TextRenderer.h`和`TextRenderer.cpp`。'
- en: Glyphs rendering
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字形渲染
- en: 'The `RenderLineOnBitmap()` method takes an allocated bitmap as an output surface
    and renders a given text string using a specified font identifier. The `LeftToRight`
    parameter tells us whether the text is written from left to right or from right
    to left:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderLineOnBitmap()`方法接收一个分配好的位图作为输出表面，并使用指定的字体标识符渲染给定的文本字符串。`LeftToRight`参数告诉我们文本是从左到右还是从右到左书写：'
- en: '[PRE73]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After loading, text rendering is done by iterating the `FString` container
    once again and calling the `DrawGlyphOnBitmap()` method for each character:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，通过再次迭代`FString`容器，并为每个字符调用`DrawGlyphOnBitmap()`方法来完成文本渲染：
- en: '[PRE74]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We track the current horizontal position in the `x` variable by summing advances
    of each character. For each non-empty glyph, we calculate a *real* onscreen position
    taking into account the actual text direction specified by the `LeftToRight` argument:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过累加每个字符的前进值来跟踪当前的水平位置变量`x`。对于每个非空字形，我们计算一个*实际*的屏幕位置，考虑到由`LeftToRight`参数指定的实际文本方向：
- en: '[PRE75]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If the direction is right to left, we will correct the position accordingly:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方向是从右到左，我们将相应地校正位置：
- en: '[PRE76]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'At the end of each iteration, we shift the horizontal counter using the advance
    value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代的末尾，我们使用前进值来移动水平计数器：
- en: '[PRE77]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A wrapper routine `RenderTextWithFont()` precalculates the size of an output
    bitmap and returns a ready to use image:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 包装例程`RenderTextWithFont()`预先计算输出位图的大小，并返回一个可直接使用的图像：
- en: '[PRE78]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'After we have calculated the text size, we allocate an output bitmap, clear
    it, and call the `RenderLineOnBitmap()` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了文本大小之后，我们会分配一个输出位图，清除它，并调用`RenderLineOnBitmap()`方法：
- en: '[PRE79]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `RenderLineOnBitmap()` call fixes the starting position for the right-to-left
    text:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderLineOnBitmap()`调用为从右到左的文本固定了起始位置：'
- en: '[PRE80]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `DrawGlyphOnBitmap()` method is similar to the code we used in [Chapter
    2](part0024.xhtml#aid-MSDG2 "Chapter 2. Native Libraries"), *Native Libraries*.
    We iterate through all pixels of the glyph''s bitmap and set them using the data
    returned by FreeType:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawGlyphOnBitmap()`方法与我们在[第2章](part0024.xhtml#aid-MSDG2 "第2章.本地库")*本地库*中使用的代码类似。我们遍历字形的位图中的所有像素，并使用FreeType返回的数据设置它们：'
- en: '[PRE81]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the mask creation mode, we can copy the glyph directly into the output bitmap
    ignoring the `Color` parameter—that is, only a grayscale mask is rendered:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在掩模创建模式下，我们可以直接将字形复制到输出位图中，忽略`Color`参数，即只渲染灰度掩模：
- en: '[PRE82]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'For colored rendering, we fetch the source pixel and blend it with the specified
    color according to the mask:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于彩色渲染，我们会获取源像素，并根据掩模将其与指定颜色混合：
- en: '[PRE83]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `BlendColors()` routine performs linear interpolation between color `C1`
    and `C2`. The right shifts here replace the division by 256\. To avoid floating
    point arithmetic and conversions, the blend factor varies from 0 to 255, thus
    the value 255 instead of `1.0f` in the formula:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlendColors()`例程在颜色`C1`和`C2`之间执行线性插值。这里的右移位代替了除以256。为了避免浮点运算和转换，混合因子从0变化到255，因此在公式中使用值255而不是`1.0f`：'
- en: '[PRE84]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, we know how to render glyphs. Let's find out how to load, manage, and cache
    different fonts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何渲染字形。让我们找出如何加载、管理和缓存不同的字体。
- en: Font initialization and caching
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体初始化和缓存
- en: Until now, we haven't described the details of font management, glyph rendering,
    and reusing characters' bitmaps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有描述字体管理、字形渲染和重用字符位图的细节。
- en: 'First of all, we will declare a FreeType library handle used by every call
    to the FreeType API:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一个FreeType库句柄，供每次调用FreeType API时使用：
- en: '[PRE85]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For each font we use, we need a rendered glyph cache and a character map cache.
    These caches are maintained by an `FTC_Manager` instance:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们使用的每种字体，都需要一个渲染字形缓存和一个字符映射缓存。这些缓存由一个`FTC_Manager`实例维护：
- en: '[PRE86]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we need glyph and character map caches:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要字形和字符映射缓存：
- en: '[PRE87]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We keep track of byte buffers with loaded font files in the `FAllocatedFonts`
    field. The key for `std::map` is the name of a font file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`FAllocatedFonts`字段中跟踪已加载字体文件的字节缓冲区。`std::map`的键是字体文件的名称：
- en: '[PRE88]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `FFontFaceHandles` map is another container of initialized FreeType font
    handles:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`FFontFaceHandles`映射是另一个初始化的FreeType字体句柄的容器：'
- en: '[PRE89]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The private `LoadFontFile()` method reads a font file using our virtualfilesystem
    mechanism and adds the initialized font to the containers declared in the preceding
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`LoadFontFile()`方法使用我们的虚拟文件系统机制读取字体文件，并将初始化的字体添加到前面代码中声明的容器中：
- en: '[PRE90]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We prevent reloading of already loaded fonts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们防止已加载字体的重新加载：
- en: '[PRE91]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The new font is read into the `clBlob` object and its data is copied into a
    separate `Data` buffer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新字体被读取到`clBlob`对象中，并将其数据复制到一个单独的`Data`缓冲区：
- en: '[PRE92]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `FT_New_Memory_Face()` function creates a new `FT_Face` object, which is
    then stored in the `FFontFaceHandles` array:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`FT_New_Memory_Face()`函数用于创建一个新的`FT_Face`对象，并将其存储在`FFontFaceHandles`数组中：'
- en: '[PRE93]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `Data` buffer is added to `FAllocatedFonts` and the name of the font is
    added to the `FFontFaces` container:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data`缓冲区被添加到`FAllocatedFonts`中，字体名称被添加到`FFontFaces`容器中：'
- en: '[PRE94]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `clTextRenderer` class we are developing contains the initialization code
    inside the `InitFreeType()` method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发的`clTextRenderer`类在`InitFreeType()`方法中包含了初始化代码：
- en: '[PRE95]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We omit the `LoadFT()` method description here because for Windows, it is a
    simple loading of a FreeType dynamic library file and resolution of function pointers.
    For Android, this method is empty and returns `true`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们省略了`LoadFT()`方法的描述，因为在Windows上，它只是简单地加载一个FreeType动态库文件并解析函数指针。对于Android，此方法为空，并返回`true`：
- en: '[PRE96]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The actual initialization code creates an instance of the FreeType library
    and allocates caches:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的初始化代码创建了一个FreeType库实例并分配了缓存：
- en: '[PRE97]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A cache manager is initialized after FreeType. The `FreeType_Face_Requester`
    is a function pointer to the method we describe in the following code. It resolves
    the font filename and does the actual loading of font data:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeType之后初始化缓存管理器。`FreeType_Face_Requester`是一个指向我们下面代码中描述的方法的函数指针。它解析字体文件名并实际加载字体数据：
- en: '[PRE98]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'At last, two caches are initialized similarly to the manager:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，初始化两个缓存，类似于管理器：
- en: '[PRE99]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Deinitialization of FreeType is done in the reverse order:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: FreeType的逆序完成初始化：
- en: '[PRE100]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'First, we will clear the `FString` container by calling `FreeString`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`FreeString`来清除`FString`容器：
- en: '[PRE101]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we will deallocate memory blocks with font data inside the `FAllocatedFonts`
    map:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将释放`FAllocatedFonts`映射中包含字体数据的内存块：
- en: '[PRE102]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'At the end, we clear the container of font faces and destroy the cache manager
    and the library instance:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清除字体面容器，并销毁缓存管理器和库实例：
- en: '[PRE103]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `FreeString` method destroys the cached glyph for each element of the `FString`
    vector:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`FreeString`方法为`FString`向量的每个元素销毁缓存的字形：'
- en: '[PRE104]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When FreeType finds out that there is no required font in the cache, it calls
    our `FreeType_Face_Requester()` callback to initialize a new font face:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当FreeType发现缓存中没有所需的字体时，它会调用我们的`FreeType_Face_Requester()`回调来初始化新的字体面：
- en: '[PRE105]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This is one of the awkward places where we really need to convert a C-style
    font face pointer into an integer identifier. We use lower 32 bits as an identifier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真正需要将C风格字体指针转换为整型标识符的尴尬地方。我们使用低32位作为标识符：
- en: '[PRE106]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'If `FaceIdx` is less than zero, it is a valid pointer and the font was already
    loaded:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`FaceIdx`小于零，它是一个有效指针，并且字体已经被加载：
- en: '[PRE107]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The method we are describing is a callback for a C language library, so we
    emulate the `this` pointer using `RequestData`. In the `InitFreeType()` method,
    we supplied `this` as a parameter to `FTC_Manager_New`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在描述的方法是C语言库的回调，因此我们使用`RequestData`模拟`this`指针。在`InitFreeType()`方法中，我们提供了`this`作为参数给`FTC_Manager_New`：
- en: '[PRE108]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We extract a filename from the `FFontFaces` array:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`FFontFaces`数组中提取文件名：
- en: '[PRE109]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The call to `LoadFontFile()` might return zero if we have already loaded the
    file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`LoadFontFile()`可能会返回零，如果我们已经加载了文件：
- en: '[PRE110]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If we haven''t loaded the file, we search for the face in the `FFontFaceHandles`
    array:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有加载文件，我们会在`FFontFaceHandles`数组中查找字体：
- en: '[PRE111]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We are getting close to the complete picture of `clTextRenderer` and only a
    few methods related to fonts and glyphs remain. The first one is `GetSizedFace()`,
    which we have used in `LoadStringWithFont()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近`clTextRenderer`的完整视图，只剩下与字体和字形相关的少数几个方法。第一个是`GetSizedFace()`，我们在`LoadStringWithFont()`中使用过它：
- en: '[PRE112]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To start rendering glyphs at a given font height, we fill the `FTC_ScalerRec`
    structure to set rendering parameters. The `IntToID()` routine converts an integer
    identifier to a void pointer conversely to the code in `FreeType_Face_Requester()`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在给定字体高度渲染字形，我们填充`FTC_ScalerRec`结构以设置渲染参数。`IntToID()`例程将整数标识符转换为void指针，与`FreeType_Face_Requester()`中的代码相反：
- en: '[PRE113]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `FTC_Manager_LookupSize()` function searches for the `FT_Size` structure
    in the cache, which we supply to `FT_ActivateSize()`. After this, our glyphs get
    rendered with the size equal to the `Height` parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTC_Manager_LookupSize()`函数在缓存中查找`FT_Size`结构，我们将其提供给`FT_ActivateSize()`。在此之后，我们的字形以`Height`参数等于的大小进行渲染：'
- en: '[PRE114]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The second auxiliary method is `GetGlyph()`, which renders a single glyph:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助方法是`GetGlyph()`，它渲染单个字形：
- en: '[PRE115]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here, we convert a UCS-2 code to a character index:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将UCS-2代码转换为字符索引：
- en: '[PRE116]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `ImageType` structure is filled with glyph rendering parameters:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageType`结构被填充了字形渲染参数：'
- en: '[PRE117]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Then, the `FTC_ImageCache_Lookup()` function searches for the previously rendered
    glyph and renders one if it has not been rendered yet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`FTC_ImageCache_Lookup()`函数查找先前渲染的字形，如果尚未渲染，则渲染一个：
- en: '[PRE118]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The third method `GetCharIndex()` uses the FreeType character map cache to
    quickly convert a UCS-2 character code to a glyph index:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方法`GetCharIndex()`使用FreeType字符映射缓存快速将UCS-2字符代码转换为字形索引：
- en: '[PRE119]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `IntToID()` routine is similar to the casting code in `FreeType_Face_Requester()`.
    All it does is the conversion of an integer font face identifier to a C void pointer:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntToID()`例程与`FreeType_Face_Requester()`中的强制转换代码类似。它所做的就是将整数字体面标识符转换为C void指针：'
- en: '[PRE120]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Finally, we need the `GetFontHandle()` method, which loads a font file and
    returns a new valid font face identifier:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要`GetFontHandle()`方法，它加载字体文件并返回新的有效字体面标识符：
- en: '[PRE121]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'First, we will try to load the file. The result of zero can be returned if
    the file is already loaded:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试加载文件。如果文件已经加载，可能会返回零：
- en: '[PRE122]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We search for this font in a FFontFaces container and return its index:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在FFontFaces容器中查找此字体并返回其索引：
- en: '[PRE123]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We have all components necessary to render Unicode characters on bitmaps. Let's
    see how we can use this functionality to extend `clCanvas` with text rendering
    capabilities.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有在位图上渲染Unicode字符所需的所有组件。让我们看看如何使用这个功能来扩展`clCanvas`的文本渲染能力。
- en: Integrating the text renderer into the canvas
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文本渲染器集成到画布中
- en: 'Now that we have the `clTextRenderer` class, we can implement `clGLCanvas::TextStr()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`clTextRenderer`类，我们可以实现`clGLCanvas::TextStr()`：
- en: '[PRE124]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'First, we render the string to a bitmap:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将字符串渲染成位图：
- en: '[PRE125]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'A static texture is shared between all calls to `TextStr()`. Not that performant
    and multithreaded, but very simple:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 静态纹理在所有对`TextStr()`的调用之间共享。虽然性能不是特别高，也不是多线程的，但是非常简单：
- en: '[PRE126]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Then, we update the static texture from this bitmap:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从这个位图中更新静态纹理：
- en: '[PRE127]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'After calculating the output size, we will call the `TextureRect()` method
    to render the bitmap with our text string:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 计算完输出大小后，我们将调用`TextureRect()`方法，使用我们的文本字符串渲染位图：
- en: '[PRE128]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Global access to the single instance of `clTextRenderer` is implemented using
    the Singleton pattern:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例模式实现全局访问`clTextRenderer`的单个实例：
- en: '[PRE129]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We can now render text using the `iCanvas` interface. Let's draw a graphical
    user interface where we can put our text.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`iCanvas`接口来渲染文本。让我们绘制一个图形用户界面，我们可以在其中放置文本。
- en: Organizing the UI system
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织UI系统
- en: 'Having created the `iCanvas` interface for immediate mode rendering, we can
    switch to the user interface implementation. To create a meaningful application,
    the ability to render static or even animated graphical information is not always
    enough. An application must react to user input, which for mobiles often means
    responding to touch screen events. Here, we create a minimalistic graphical user
    interface consisting of three basic elements called views:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了立即模式渲染的`iCanvas`接口后，我们可以转向用户界面实现。为了创建有意义的应用程序，仅能渲染静态甚至动画图形信息并不总是足够的。应用程序必须对用户输入做出反应，对于移动设备来说，这通常意味着响应触摸屏事件。在这里，我们创建了一个由三种基本元素（称为视图）组成的简约图形用户界面：
- en: '`clUIView`: This is a logical container and a base class for other views'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clUIView`：这是一个逻辑容器，也是其他视图的基类'
- en: '`clUIStatic`: This is a static label with a text'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clUIStatic`：这是一个带有文本的静态标签'
- en: '`clUIButton`: This is an object that fires events once it is touched'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clUIButton`：这是一个一旦被触摸就会触发事件的物体'
- en: Each view is a rectangular region, which is capable of rendering itself and
    reacting to external events such as timing and user touches. Since we are working
    with the NDK, and at the same time, we want to debug our software on desktop machines,
    we must redirect events from an OS-specific queue to the C++ event handling code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都是一个矩形区域，能够渲染自身并对外部事件（如定时和用户触摸）做出反应。由于我们在使用NDK，同时我们也想在桌面机上调试我们的软件，因此我们必须将特定于操作系统的队列中的事件重定向到C++事件处理代码。
- en: The base UI view
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础的UI视图
- en: 'We define the `clUIView` interface for each UI element. This interface includes
    geometrical properties of the UI view:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个UI元素定义了`clUIView`接口。这个接口包括UI视图的几何属性：
- en: '[PRE130]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This class contains geometric properties of the UI element. The `m_X` and `m_Y`
    fields contain relative coordinates in parent''s coordinate frame. The `m_ScreenX`
    and `m_ScreenY` fields contain absolute coordinates in the screen reference frame.
    The `m_Width` and `m_Height` fields store the width and height of the element
    respectively:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了UI元素的几何属性。`m_X`和`m_Y`字段包含在父坐标框架中的相对坐标。`m_ScreenX`和`m_ScreenY`字段包含在屏幕参考框架中的绝对坐标。`m_Width`和`m_Height`字段分别存储元素的宽度和高度：
- en: '[PRE131]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The private part of the class contains flags and settings for the child views
    layout. These settings are used later in the `LayoutChildViews()` method. The
    `m_ParentFractionX` and `m_ParentFractionY` values are used to override `m_Width`
    and `m_Height` as a percentage of the parent view size. If the values are greater
    than one, they are ignored. Their explicit usage is shown in the `LayoutChildViews`.
    The `m_AlignV` and `m_AlignH` contain different alignment modes for the coordinates:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有部分包含子视图布局的标志和设置。这些设置稍后会在`LayoutChildViews()`方法中使用。`m_ParentFractionX`和`m_ParentFractionY`值用于覆盖作为父视图大小的百分比的`m_Width`和`m_Height`。如果这些值大于1，它们将被忽略。它们在`LayoutChildViews`中的显式使用如下所示。`m_AlignV`和`m_AlignH`包含坐标的不同对齐模式：
- en: '[PRE132]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The last field is the `m_ChildViews` vector with pointers to child views, as
    the name suggests:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段是`m_ChildViews`向量，其中包含指向子视图的指针，顾名思义：
- en: '[PRE133]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The default constructor sets the initial value for each field:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数为每个字段设置初始值：
- en: '[PRE134]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The class interface contains `Get*` and `Set*` one-liners to access properties
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 类接口包含访问属性的`Get*`和`Set*`单行函数
- en: '[PRE135]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then, getters and setters for layout parameters follow:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是布局参数的获取器和设置器：
- en: '[PRE136]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `Add()` and `Remove()` methods provide access to the `m_ChildViews` container:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`和`Remove()`方法提供了对`m_ChildViews`容器的访问：'
- en: '[PRE137]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Direct read-only access to `m_ChildViews` is provided by the `GetChildViews()`
    method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetChildViews()`方法直接提供了对`m_ChildViews`的只读访问：'
- en: '[PRE138]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `Draw()` method calls `PreDrawView()` to render the background layer of
    this UI element, then it calls `Draw()` for each and every child view, and finally,
    the call to `PostDrawView()` finishes the rendering process for this UI element:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw()`方法调用`PreDrawView()`来渲染该UI元素的背景层，然后它为每个子视图调用`Draw()`，最后，调用`PostDrawView()`完成该UI元素的渲染过程：'
- en: '[PRE139]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `UpdateScreenPositions()` method recalculates absolute screen positions
    of child views:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateScreenPositions()`方法重新计算子视图的绝对屏幕位置：'
- en: '[PRE140]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The event handling part consists of `Update()` and `OnTouch()` methods. The
    `Update()` method informs all the child views a period of time has passed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理部分包括`Update()`和`OnTouch()`方法。`Update()`方法通知所有子视图已经过了一段时间：
- en: '[PRE141]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The `OnTouch()` method accepts screen coordinates and a touch flag:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTouch()`方法接受屏幕坐标和触摸标志：'
- en: '[PRE142]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Check whether the touch event was handled by any of child views:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 检查触摸事件是否被任何子视图处理：
- en: '[PRE143]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `IsPointOver()` method checks whether the point is inside the view:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPointOver()`方法检查点是否在视图内：'
- en: '[PRE144]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The protected part contains two virtual methods to render the contents of the
    actual `clUIView`. The `PreDrawView()` method is called before rendering child
    views, so the visible result of this call may be erased by children, for example,
    a background layer. The `PostDrawView()` method is called after all child views
    had been rendered, like a decoration on top of the rendered image:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的部分包含两个虚拟方法，用于渲染实际`clUIView`的内容。`PreDrawView()`方法在渲染子视图之前调用，因此此调用的可见结果可能会被子视图擦除，例如背景层。`PostDrawView()`方法在所有子视图渲染后调用，就像渲染图像顶部的装饰：
- en: '[PRE145]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This mechanism enables UI rendering and customization. The last thing we need
    before our UI can come to life is an event dispatching mechanism. Let's implement
    it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制使得UI渲染和自定义成为可能。在我们UI可以生动呈现之前，我们还需要一个事件分派机制。让我们来实现它。
- en: Events
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'At the lowest level, all the events from Android or desktop OSes are handled
    by the SDL library, and we only have to write the handler for these events:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，所有来自Android或桌面操作系统的的事件都由SDL库处理，我们只需编写这些事件的处理程序：
- en: '[PRE146]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'We add two more case labels to `HandleEvent()` so we can dispatch touch events:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`HandleEvent()`函数增加了两个案例标签，以便我们可以分派触摸事件：
- en: '[PRE147]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Prior to C++11, wrapping C-like function pointers and class member function
    pointers in a single object was not an easy task requiring some heavy template
    library such as `boost::bind`. Now, the `std::function` object from the SDL library
    fits just fine for our purposes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，将类似C的函数指针和类成员函数指针包装在单个对象中并不是一件容易的事，需要一些重量级的模板库，如`boost::bind`。现在，SDL库中的`std::function`对象正好符合我们的需求。
- en: 'The only interactive object we implement here is `clUIButton`. When a user
    taps such an object, a custom action is performed. The code for the action can
    reside in a standalone function, a member function, or in a lambda expression.
    For example, we create an `Exit` button, and the code might be as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现的唯一交互式对象是`clUIButton`。当用户点击这样的对象时，会执行自定义操作。该操作的代码可以位于独立函数、成员函数或lambda表达式中。例如，我们创建一个`Exit`按钮，代码可能如下所示：
- en: '[PRE148]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The `clUIButton` class must contain the `std::function` field, and the `OnTouch()`
    method optionally invokes this function when a tap occurs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`clUIButton`类必须包含`std::function`字段，`OnTouch()`方法在发生点击时可选地调用此函数。'
- en: Implementing UI classes
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现UI类
- en: 'The `clUIStatic` view is a descendant of `clUIView` with the overridden `PreDrawView()`
    method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`clUIStatic`视图是`clUIView`的派生类，重写了`PreDrawView()`方法：'
- en: '[PRE149]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `clUIButton` class adds a custom touch event handling atop of `clUIStatic`
    rendering:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`clUIButton`类在`clUIStatic`渲染之上添加了自定义触摸事件处理：'
- en: '[PRE150]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Now, our mini user interface can be used in applications.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的迷你用户界面可以在应用程序中使用。
- en: Using views in application
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序中使用视图
- en: 'Here is a short code snippet that creates a button and exits the application
    once this button is tapped:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简短的代码片段，它创建了一个按钮，并在点击该按钮时退出应用程序：
- en: '[PRE151]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The full source code is in the `1_SDL2UI` example. Besides the details discussed
    in this chapter, the source code contains a basic layouting mechanism so that
    views can have relative coordinates and sizes. To get this bonus, take a look
    at `LayoutController.cpp` and `LayoutController.h`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`1_SDL2UI`示例中找到。除了本章讨论的细节之外，源代码还包含了一个基本的布局机制，以便视图可以拥有相对坐标和大小。想要了解这个附加功能，请查看`LayoutController.cpp`和`LayoutController.h`。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to implement and render basic user interface
    in C++, render UTF-8 text using the FreeType library, and handle user input in
    a platform independent way. We will use this functionality in the last chapter
    to implement a multiplatform gaming application. Now, let's return to the topic
    of 3D rendering started in [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. OpenGL
    ES 3.1 and Cross-platform Rendering"), *OpenGL ES 3.1 and Cross-platform Rendering*,
    and implement a rendering engine on top of those abstractions.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何用C++实现并渲染基本用户界面，使用FreeType库渲染UTF-8文本，并以平台无关的方式处理用户输入。我们将在最后一章使用这些功能来实现一个跨平台游戏应用。现在，让我们回到在[第6章](part0057.xhtml#aid-1MBG21
    "第6章. OpenGL ES 3.1与跨平台渲染")，*OpenGL ES 3.1 and Cross-platform Rendering*开始讨论的3D渲染话题，并在这些抽象之上实现一个渲染引擎。
