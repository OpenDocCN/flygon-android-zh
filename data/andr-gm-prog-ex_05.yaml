- en: Chapter 5. Platformer – Upgrading the Game Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 平台游戏 - 升级游戏引擎
- en: Welcome to the second project of this book. Here, we will build a really tough
    retro platform game. It is not tough to build, but tough to beat when you play
    it. At the end of the project, we will also discuss ways to make the game play
    a little less punishing should you wish.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到这本书的第二个项目。在这里，我们将构建一个真正困难的复古平台游戏。它不是难以构建，而是当你玩它时难以击败。在项目结束时，我们还将讨论如何使游戏玩法稍微不那么严苛，如果你希望的话。
- en: This chapter will focus entirely on our game engine and essentially lead to
    an upgraded version of the Tappy Defender code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将完全聚焦于我们的游戏引擎，本质上将导致Tappy Defender代码的升级版本。
- en: 'First, we will discuss what we want to achieve with this game: the backstory,
    game mechanics, and rules.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论我们希望通过这个游戏实现的目标：背景故事、游戏机制和规则。
- en: Then, we will quickly create an activity that instantiates a view that will
    do all the work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将快速创建一个活动，实例化一个将完成所有工作的视图。
- en: After that, we will flesh out the basic structure of our `PlatformView` class,
    which will have some subtle, but important differences to our `TDView` class.
    Most notably, `PlatformView` will have a simple but effective way of managing
    the timing of all the events of our game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将充实`PlatformView`类的基本结构，它将有一些微妙的但重要的区别于我们的`TDView`类。最值得注意的是，`PlatformView`将有一个简单但有效的方式来管理我们游戏所有事件的时间。
- en: We will then start the iterative process of building our `GameObject` class,
    from which almost every entity of the game world will be derived.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始迭代构建我们的`GameObject`类，游戏世界中的几乎每一个实体都将由此派生。
- en: Next, we will discuss the concept of a viewport through which the game world
    is viewed by the player. We will no longer be designing our game objects to operate
    at the level of the screen resolution, but they will now exist in a world with
    their own *x* and *y* coordinates that we can think of as virtual meters. There
    is also a simple system of depth on the *z* axis as well. This will be handled
    by our new `Viewport` class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论视口的概念，玩家通过这个视口来观看游戏世界。我们不再将游戏对象设计为在屏幕分辨率层面操作，而是存在于一个拥有自身*x*和*y*坐标的世界中，我们可以将这些坐标视为虚拟米。在*z*轴上也有一个简单的深度系统。这将由我们新的`Viewport`类来处理。
- en: After this, we will look at how we design and layout the content of our game.
    This is done via a class that is used as a level designer and can be used in a
    nonprogrammatic way to map out the jumps, enemies, rewards, and goals that constitute
    the layout of a level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将研究如何设计和布局游戏内容。这是通过一个用作关卡设计师的类完成的，可以非编程地使用它来规划跳跃、敌人、奖励和目标，这些构成了一个关卡的布局。
- en: To manage the level designs and load them into our game engine, we will need
    another class. We will call it `LevelManager`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理关卡设计并将它们加载到我们的游戏引擎中，我们将需要另一个类。我们将它称为`LevelManager`。
- en: Finally in this chapter, we will look at our enhanced `update` and `draw` methods
    within the `PlatformView` class so that we can actually run our new game and see
    the first output on the screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将查看`PlatformView`类中的增强型`update`和`draw`方法，这样我们就可以实际运行我们的新游戏，并在屏幕上看到首次输出。
- en: With so much to do, we better get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多事情要做，我们最好开始吧。
- en: The game
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: The game we will build is based on the game play of some of the brutally hard
    platform games of the '80s, such as Bounty Bob Strikes Back and Impossible Mission.
    These games featured difficult jumps and required insanely precise timing at the
    same time as giving the player an unforgiving number of lives/chances. This style
    of game works well for us because we can actually build a multilevel playable
    game in just four chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的游戏基于一些80年代残酷难度的平台游戏，如Bounty Bob Strikes Back和Impossible Mission的游戏玩法。这些游戏以难以跳跃和同时需要极其精确的时机控制著称，同时给玩家一个不宽恕的生命/机会数量。这种游戏风格很适合我们，因为我们可以实际上在四个章节内构建一个多级别的可玩游戏。
- en: The design of the classes will make it really easy for you to add your own extra
    features, and game objects or make it slightly less challenging to play should
    you want to.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计将使你能够轻松添加自己的额外功能、游戏对象，或者如果你愿意，也可以稍微降低游戏的难度。
- en: The backstory
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景故事
- en: Our hero Bob, having just returned from a secret mission to destroy an evil
    scientist at the center of the Earth, finds he is deep underground. Worse, it
    seems that although he has defeated the evil scientist, it was not in time to
    save the planet from the powerful guards and deadly flying robot drones that he
    unleashed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄鲍勃刚从地球中心摧毁一个邪恶科学家的秘密任务中回来，发现他正处于地下深处。更糟的是，尽管他已经击败了邪恶科学家，但似乎来不及拯救这个星球免受他释放的强大守卫和致命的飞行机器人无人机的侵袭。
- en: Bob must make his way from the deep underground fiery cave, through the heavily
    guarded city, and forest, high in the mountains, where he hopes to live, free
    from the terrifying new order that has taken over the planet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃必须从深地下的火焰洞穴出发，穿过重兵把守的城市和山区森林，他希望在那里过上自由的生活，摆脱接管这个星球的可怕新秩序。
- en: On his journey through these four levels, he must avoid guards, destroy drones,
    collect lots of money, and upgrade his initially puny machine gun.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个关卡中，他必须避开守卫，摧毁无人机，收集大量金钱，并升级他最初弱小的机枪。
- en: The game mechanics
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏机制
- en: The game will be about executing precise jumps, planning the best route through
    a level to collect the loot and escape. Bob will be able to stand precariously
    on ledges with whole pixels of his feet overhanging, to be able to make seemingly
    impossible jumps. Bob will be able to control the distance he travels while jumping,
    meaning that sometimes he will often need to make sure he doesn't over jump.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将围绕执行精确的跳跃，规划通过关卡的最佳路径以收集战利品并逃脱。鲍勃将能够小心翼翼地站在边缘，脚只有几个像素悬空，以完成看似不可能的跳跃。鲍勃将能够控制跳跃时的距离，这意味着有时他需要确保自己不会跳过头。
- en: Bob will need to collect machine gun upgrades before attempting to escape via
    heavily guarded areas.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃在尝试通过重兵把守的区域逃脱前，需要收集机枪升级。
- en: Bob will only have three lives, but may be able to find some more on his journey.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃只有三条生命，但在他的旅程中可能会找到更多。
- en: Rules for the game
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: When Bob loses a life by being caught by a drone/guard, touching fire, or falling
    out of the game world, he will respawn at the start of the current level. Drones
    can fly, and will home in on Bob as soon as he comes into view. Bob will need
    to make sure he has enough firepower to handle the drones. Guards will patrol
    predetermined parts of the level, but they are tough and can only be knocked back
    by Bob's machine gun. Usually, Bob will need to execute a precisely timed jump
    to progress past a guard.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃被无人机/守卫捕获、触碰到火焰，或者跌出游戏世界而失去生命时，他将在当前关卡的起点重新出现。无人机可以飞行，并且一旦鲍勃进入视线就会锁定他。鲍勃需要确保他有足够的火力来对付无人机。守卫将在关卡预定区域巡逻，但他们很强大，只能被鲍勃的机枪击退。通常，鲍勃需要执行一个精确计时跳跃以绕过守卫。
- en: The environment will also be tough. Bob will need to completely master each
    level, as one wrong jump will send him plummeting back to the start, straight
    into the clutches of an enemy or even to his fiery death.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 环境同样会非常艰难。鲍勃需要完全掌握每个关卡，因为一次错误的跳跃就会让他直接回到起点，落入敌人手中，甚至直接遭遇火葬。
- en: Upgrading the game engine
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级游戏引擎
- en: All the talk of guards, drones, fire, collectibles, guns, and the implied much
    larger game world suggests a much more complex system to manage. One of the goals
    of our game engine will be to make this complexity easily manageable. The other
    goal will be to separate the level design from the coding. When our game is done,
    you will be able to sit back and design the most evil, yet rewarding levels, in
    multiple different environments without touching the code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的守卫、无人机、火焰、收藏品、枪支的讨论，以及暗示的更大游戏世界，表明我们需要管理一个更为复杂的系统。我们的游戏引擎的目标之一就是让这种复杂性易于管理。另一个目标是将关卡设计从编码中分离出来。当我们的游戏完成时，你将能够轻松设计出最邪恶但也最有成就感的关卡，在不同的环境中无需触碰代码就能完成设计。
- en: The platform activity
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台活动
- en: First we start off with our `Activity` class, which is the entry point into
    our game. There is not much new here, so let's go ahead and get it built quickly.
    Create a new project, and in the **Application Name** field, enter `C5 Platform
    Game`. Choose **Phones and tablets**, then **Blank Activity** when prompted. In
    the **Activity Name** field, type `PlatformActivity`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`Activity`类开始，这是进入我们游戏的入口点。这里没有太多新内容，让我们快速构建它。创建一个新项目，在**应用名称**字段中输入`C5平台游戏`。选择**手机和平板**，然后在提示时选择**空白活动**。在**活动名称**字段中，输入`PlatformActivity`。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Obviously you don't have to follow my exact naming choices, but just remember
    to make minor alterations in the code to reflect your own naming choices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您不必遵循我的确切命名选择，但请记得在代码中进行一些小修改，以反映您自己的命名选择。
- en: 'You can delete `activity_platform.xml` from the `layout` folder. You can also
    delete all the code within the `PlatformActivity.java` file. Just leave the package
    declaration. Now, we have an entirely blank canvas ready for us to start coding.
    Here is the entirety of our project so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`layout`文件夹中删除`activity_platform.xml`。您还可以删除`PlatformActivity.java`文件中的所有代码。只保留包声明。现在，我们有一个完全空白的画布，准备开始编码。以下是到目前为止我们的项目的全部内容：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start building our engine. Just like in our Tappy Defender project, we
    will build a class to handle the view aspect of our game. Perhaps unsurprisingly,
    we will call the class `PlatformView`. Therefore, our `PlatformActivity` class
    needs to instantiate a `PlatformView` object and set it as the main view of the
    app, just like in the previous project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的引擎。就像在我们的Tappy Defender项目中一样，我们将构建一个类来处理游戏视图方面。或许不足为奇，我们将这个类称为`PlatformView`。因此，我们的`PlatformActivity`类需要实例化一个`PlatformView`对象，并将其设置为应用程序的主要视图，就像在之前的项目中一样。
- en: We will be making some significant upgrades to our engine, but this will mainly
    happen in the view. In the code for the `PlatformActivity` class that we will
    look at next, we do much the same as in the previous project. First, declare the
    `PlatformView` object and set it as the main view in the overridden `onCreate`
    method; however, before we do this, we also capture and pass in the resolution
    of the device's screen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对引擎进行一些重大升级，但主要是在视图层面进行。在接下来要看的`PlatformActivity`类的代码中，我们与上一个项目所做的类似。首先，在重写的`onCreate`方法中声明`PlatformView`对象，并将其设置为主要的视图；但在这样做之前，我们还需要捕获并传入设备屏幕的分辨率。
- en: We do this using the `Display` class and chaining the `getWindowManager()` and
    `getDefaultDisplay()` methods to get the properties of the physical display hardware
    that our game will be running on. Then, we create an object of type `Point` called
    resolution and store the resolution of the display into our `Point` object by
    calling `display.getSize(size)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`Display`类，链式调用`getWindowManager()`和`getDefaultDisplay()`方法来获取我们游戏将要运行的物理显示硬件的属性。然后，我们创建一个名为`resolution`的`Point`类型的对象，并通过调用`display.getSize(size)`将显示的分辨率存储到我们的`Point`对象中。
- en: This stores the horizontal and vertical number of pixels of the screen into
    `size.x` and `size.y`, respectively. We can then go ahead and instantiate a new
    `PlatformView` object by calling its constructor and passing in the values stored
    in `size.x` and `size.y`. As before, we also pass in the application, `Context`
    object (`this`) that like in the previous project, we will find many uses for.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将屏幕的水平像素数和垂直像素数分别存储在`size.x`和`size.y`中。然后我们可以继续通过调用其构造函数并传入`size.x`和`size.y`中存储的值来实例化一个新的`PlatformView`对象。与之前一样，我们还需要传入应用程序的`Context`对象（`this`），正如在之前的项目中，我们会发现它有很多用途。
- en: We can then set `platformView` as the view by calling `setContentView()` in
    the usual way. As earlier, we override the `Activity` class's lifecycle methods
    `onPause()` and `onResume()` to have them call their respective methods in our
    soon-to-be-written `PlatformView` class. These two methods can then start and
    stop our `Thread` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`setContentView()`方法，将`platformView`设置为视图。如前所述，我们重写`Activity`类的生命周期方法`onPause()`和`onResume()`，让它们调用我们即将编写的`PlatformView`类中的相应方法。这两个方法可以启动和停止我们的`Thread`类。
- en: Here is the entirety of the code for the `PlatformActivity` class that we have
    just discussed, with no significant new aspects. Type or copy and paste the code
    into your project. The code for this chapter can be found within the download
    bundle from the book's page on the Packt Publishing website. All the code and
    assets from this chapter can be found in the `Chapter5` folder. This file is called
    `PlatformActivity.java`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们刚刚讨论的`PlatformActivity`类的完整代码，没有新的重要方面。将代码输入或复制粘贴到您的项目中。本章的代码可以在Packt Publishing网站的书籍页面下载捆绑包中找到。本章的所有代码和资源都可以在`Chapter5`文件夹中找到。这个文件叫做`PlatformActivity.java`。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to import all the new classes when prompted to do so, or by pressing
    the *Alt* | *Enter* keyboard combination while hovering the cursor over the error
    when a missing class causes this error.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示导入所有新类时，请记得导入，或者当因缺少类而出现错误时，将光标悬停在错误上，按*Alt* | *Enter*键盘组合进行导入。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, until we create our `PlatformView` class, there will be errors in
    our `PlatformActivity` class's code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们创建`PlatformView`类之前，我们的`PlatformActivity`类代码中将会出现错误。
- en: Locking the layout to landscape
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将布局锁定为横屏
- en: 'Just as we did for the last project, we will make sure the game runs in the
    landscape mode only. We will make our `AndroidManifest.xml` file force our `PlatformActivity`
    class to run with a full screen, and we will also lock it to a landscape layout.
    Let''s make these changes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个项目中做的那样，我们将确保游戏只在横屏模式下运行。我们将使我们的`AndroidManifest.xml`文件强制我们的`PlatformActivity`类以全屏运行，并且我们还将将其锁定为横屏布局。让我们进行以下更改：
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`manifests`文件夹，双击`AndroidManifest.xml`文件，在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Immediately after it, type or copy and paste these two lines to make `PlatformActivity`
    run full screen and lock it in the landscape orientation.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它下面，输入或复制粘贴以下两行代码，使`PlatformActivity`全屏运行，并将其锁定为横屏方向。
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can move on to the real guts of our game and see how we can implement
    all these improvements we talked about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入游戏的核心部分，看看我们如何实现我们讨论的所有这些改进。
- en: The PlatformView class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PlatformView类
- en: This class, by the time it is completed, will be dependent on many other classes.
    I don't want to just present each class in turn, as this would be quite hard to
    follow and exactly what code implements which feature will become confusing. Instead,
    we will look at, and code, each feature in turn, as we require them, and then
    revisit many of the classes multiple times to add more features. This will keep
    the focus on the specific purpose of each part of the code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到完成时，这个类将依赖于许多其他类。我不想逐一介绍每个类，因为这样会很难跟上，而且哪些代码实现了哪个功能也会变得混乱。相反，我们将根据需要逐个查看和编写每个功能，并多次回顾许多类以添加更多功能。这将使代码每一部分的特定目的保持焦点。
- en: Having said this, great care has been taken so that although we will revisit
    many of these classes multiple times, we won't be constantly deleting code, just
    adding to it. When we add to it, the code will be presented in its proper context
    with the new parts highlighted among the existing code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，我们已经非常注意，尽管我们会多次回顾这些类，但我们不会不断地删除代码，而只是在原有代码中增加内容。当我们增加代码时，将在适当的上下文中展示代码，并将新部分在现有代码中突出显示。
- en: With regard to the structure of the classes, they are designed to be as minimal
    as possible, while at the same time, not restricting your potential to easily
    add features and extend the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 至于类的结构，它们被设计为尽可能最小，同时也不会限制你轻松添加功能和扩展代码的潜力。
- en: This is not a lesson in game engine design, but more a lesson in seeing how
    many different features we can learn to implement and cram into four chapters,
    without the code becoming unmanageable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是关于游戏引擎设计的课程，而是更多地学习如何实现和压缩四个章节中的不同功能，而不会使代码变得难以管理。
- en: If you plan to build very large-scale games, especially when working as a team,
    then a more robust design will be necessary. This more robust design will also
    mean a whole lot of extra classes, interfaces, packages, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建非常大的游戏，尤其是在团队中工作时，那么更健壮的设计将是必要的。这种更健壮的设计也将意味着大量的额外类、接口、包等等。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If this type of discussion interests you, I highly recommend the book, *Beginning
    Android Games* by Mario Zechner, published by APRESS. Mario is the founder/creator
    of the LibGDX cross-platform game library, and his book goes into great detail
    about the design patterns required to build a highly extensible and reusable code
    base for games. The only downside to the great design detail that this book has,
    is that it would take around 600 pages to build a simple retro Snake game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这类讨论吸引了你，我强烈推荐你阅读Mario Zechner所著的《Beginning Android Games》，由APRESS出版。Mario是跨平台游戏库LibGDX的创始人/创造者，他的书详细介绍了构建高度可扩展和可重用游戏代码库所需的设计模式。这本书详细的设计细节的唯一缺点是，它需要大约600页来构建一个简单的复古贪吃蛇游戏。
- en: First, let's create the class. Right-click on the package name in the Android
    Studio project explorer and navigate to **New** | **Java Class**. Call the new
    class `PlatformView`. Delete the autogenerated contents of the class, as we will
    add our own code soon.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个类。在Android Studio项目浏览器中右键点击包名，选择**New** | **Java Class**。将新类命名为`PlatformView`。删除类中自动生成的代码，因为我们将很快添加自己的代码。
- en: We will continue to add code to this class over the entirety of the project.
    The full extent of the code that we add to the class in this chapter can be found
    in the download bundle at `Chapter5/PlatformView.java`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目过程中，我们将会继续向这个类添加代码。本章中添加到类中的完整代码可以在下载包中的`Chapter5/PlatformView.java`找到。
- en: We need a class that can manage our level. Let's call it `LevelManager`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够管理我们关卡的类。让我们称它为`LevelManager`。
- en: We also need a class that can hold the data for our level, as we can then extend
    it each time we create a new/different level design. Let's call the parent class
    `LevelData`, and our first real level for Bob to escape from, `LevelCave`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个类来保存我们关卡的数据，这样每次我们创建一个新/不同的关卡设计时，都可以扩展它。让我们将父类称为`LevelData`，而Bob逃脱的第一个真实关卡称为`LevelCave`。
- en: Furthermore, as this game is going to have many enemies, props, and terrain
    types, we are going to need a cleaner system of managing them all. We need a fairly
    generic `GameObject` class, which all the different game objects can extend. We
    can then manage them really easily in our `update` and `draw` methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这个游戏将有许多敌人、道具和地形类型，我们需要一个更清洁的系统来管理它们。我们需要一个相当通用的`GameObject`类，所有不同的游戏对象都可以继承它。这样，我们在`update`和`draw`方法中可以更容易地管理它们。
- en: We will also, as a matter of necessity, build a slightly more complicated method
    of detecting the players input. We will create an `InputController` class to delegate
    all of the code from `PlatformView`. However, the details of this class we will
    not see, until we have fully fleshed out our `Player` object to represent the
    player in the next chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于必要性，我们将构建一个稍微复杂一些的方法来检测玩家的输入。我们将创建一个`InputController`类，将所有代码从`PlatformView`委托给它。但是，我们将在下一章中完全展开我们的`Player`对象来表示玩家之后，才会了解这个类的细节。
- en: We can quickly code our basic `PlatformView` class with very similar code to
    the first project, but with a few notable exceptions that we will discuss.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速编写基本的`PlatformView`类，其代码与第一个项目非常相似，但有几个值得注意的区别，我们将在后面讨论。
- en: The basic structure of PlatformView
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PlatformView`的基本结构'
- en: Here are the necessary imports and our member variables to get us started. We
    will add to these a fair bit as the project continues.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是必要的导入和我们开始需要的成员变量。随着项目的进行，我们将会增加这些内容。
- en: Note that we also declare three new object types, `lm` that will be our `LevelManager`
    class, `vp` that will be our `Viewport` class, and `ic` that is our `InputController`
    class. We will begin working on some of these in this chapter. These declarations
    will of course show an error until we implement their respective classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还声明了三种新的对象类型，`lm`是我们的`LevelManager`类，`vp`是我们的`Viewport`类，以及`ic`，它是我们的`InputController`类。我们将在本章中开始处理其中一些内容。当然，在我们实现它们各自的类之前，这些声明将显示错误。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have our `PlatformView` constructor. At this stage, it does nothing
    new, in fact, it has less code than our `TDView` constructor but it will soon
    be enhanced. For now, enter the code as shown:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的`PlatformView`构造函数。在这个阶段，它没有做任何新的操作，实际上，它的代码比我们的`TDView`构造函数还要少，但它很快就会得到增强。现在，请输入如下代码：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is our thread''s `run` method. Note that before the call to `update()`,
    we get the current time in milliseconds and put it in the `startFrameTime` long
    variable. Then after `draw()` has completed, we make another call to get the system
    time and measure how many milliseconds have elapsed since the frame started. We
    then carry out the calculation `fps = 1000 / thisFrameTime`, which gives us the
    number of frames per second our game ran at, in that last frame. This value is
    stored in the `fps` variable. We will be using this all over the place as we proceed
    with the game. Code the `run` method that we have just discussed, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的线程的`run`方法。注意，在调用`update()`之前，我们获取当前时间（毫秒）并将其放入`startFrameTime`长整型变量中。然后在`draw()`完成之后，我们再次调用以获取系统时间，并测量自帧开始以来已经过去了多少毫秒。然后我们执行计算`fps
    = 1000 / thisFrameTime`，这给了我们上一个帧中游戏运行的帧数。这个值存储在`fps`变量中。随着游戏的进行，我们将到处使用这个值。编写我们刚刚讨论的`run`方法，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Later in the chapter, we will see how we manage the extra complexity of multiple
    object types and update them when necessary. For now, just add an empty `update`
    method to the `PlatformView` class like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将看到如何管理多种对象类型的额外复杂性，并在必要时更新它们。现在，只需向`PlatformView`类添加一个空的`update`方法，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we see the familiar parts of our `draw` method. Later in this chapter,
    we will see some of the new code. For now, add the basics of the `draw` method
    as shown next as this will remain unchanged:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们熟悉的`draw`方法的部分。在本章后面，我们将看到一些新代码。现在，添加`draw`方法的基本部分，如下所示，这部分将保持不变：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last parts of the first phase of putting together our view is the `pause`
    and `resume` methods, which are called by `PlatformActivity` when the corresponding
    Activity lifecycle methods are called by the operating system. They are unchanged
    from the previous project, but here they are again for the sake of completeness
    and being able to follow along easily. Add these methods to the `PlatformView`
    class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 视图第一阶段组合的最后部分是`pause`和`resume`方法，这些方法是由操作系统调用相应的Activity生命周期方法时由`PlatformActivity`调用的。它们与上一个项目中的方法没有变化，但为了完整性和便于跟踪，这里再次列出。将这些方法添加到`PlatformView`类中：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we have the basic outline of our view coded and ready. Let's take our first
    look at the `GameObject` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了视图的基本大纲编码并准备就绪。让我们首先看看`GameObject`类。
- en: The GameObject class
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`GameObject`类'
- en: We know that we need a parent class to hold the vast majority of our game objects
    as we want to improve on the inflexibility and code duplication of the last project.
    From the previous project, we also know many of the properties and methods it
    will require.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要一个父类来保存我们游戏对象的大部分内容，因为我们想要改进上一个项目中代码的灵活性和重复性。从上一个项目我们知道，它需要许多属性和方法。
- en: 'First, we need a simple class to represent the world location of all our future
    `GameObject` classes. This class will hold a detailed location on both the *x*
    and *y* axis. Note that these are totally independent to the coordinates of the
    pixels of the device on which our game will run. We can think of the *z* coordinate
    as a layer number. The lower numbers get drawn first. Therefore, create a new
    Java class, call it `Vector2Point5D`, and enter this code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个简单的类来表示所有未来`GameObject`类的世界位置。这个类将在*x*和*y*轴上保存一个详细的位置。请注意，这些与我们的游戏将运行的设备上的像素坐标完全独立。我们可以将*z*坐标视为图层编号。数字越小，越先绘制。因此，创建一个新的Java类，将其命名为`Vector2Point5D`，并输入以下代码：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's have a look at, and code the basic working outline of, the `GameObject`
    class, and then throughout the project, we can come back and add extra features.
    Create a new Java class and call it `GameObject`. Let's look at the code we need
    to start to make this class useful. First, we import the classes we need.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看并编码`GameObject`类的基本工作大纲，然后在项目过程中，我们可以回过头来添加额外的功能。创建一个新的Java类，将其命名为`GameObject`。让我们看看我们需要开始编写使这个类有用的代码。首先，我们导入所需的类。
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we code `GameObject` itself, note that the class does not provide a constructor
    as this will be handled differently, depending on the specific `GameObject` that
    we are implementing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`GameObject`本身时，请注意该类没有提供构造函数，因为这将根据我们实现的特定`GameObject`而有所不同。
- en: The first variable you will notice in the code is `worldLocation`, which, as
    you may expect, is of type `Vector2Point5D`. We then have two float members, which
    will hold the width and height of the `GameObject` class. Next up, we have the
    Boolean variables `active` and `visible` which will be used, perhaps to label
    an object when it is active, visible, or otherwise. We will begin to see later
    in the chapter how this is of benefit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你在代码中注意到的第一个变量是`worldLocation`，正如你所预期的，它是`Vector2Point5D`类型的。然后我们有两个float成员，将保存`GameObject`类的宽度和高度。接下来是布尔变量`active`和`visible`，它们可能用于标记对象在活动、可见或其它状态时的标签。我们将在本章后面看到这样做的好处。
- en: We will also need to know how many frames of internal animation any given object
    has. The default will be `1`, so `animFrameCount` is initialized accordingly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道任何给定的对象有多少内部动画帧。默认值将是`1`，因此`animFrameCount`相应地初始化。
- en: 'We then have a `char` class called `type`. This `type` variable will determine
    exactly what any particular `GameObject` might be. It will be used extensively.
    The last member variable for now is `bitmapName`. We will see that it will become
    useful to know the name of the graphic, which represents the appearance of each
    of our individual objects. Add the member variables we have just discussed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个名为`type`的`char`类。这个`type`变量将确切地确定任何特定的`GameObject`可能是什么。它将被广泛使用。目前最后一个成员变量是`bitmapName`。我们将看到，知道代表我们每个单独对象外观的图形的名称将非常有用。添加我们刚刚讨论的成员变量：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can look at the first part of the functionality of `GameObject`. We
    have the abstract method `update()`. The plan was that all objects will need to
    update themselves. Turns out that this was over ambitious in just four chapters,
    and some of our objects (mainly the platforms and scenery) will just provide an
    empty `update()` implementation. However, there is nothing to stop you making
    the scenery more interactive than we have time for now, or make the platforms
    more dynamic and adventurous once we see how things work. Add the abstract `update`
    method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看`GameObject`功能的第一部分。我们有一个抽象方法`update()`。我们的计划是所有对象都需要更新自身。在四章内容中，这显得有些过于雄心勃勃，我们的一些对象（主要是平台和场景）将只提供一个空的`update()`实现。但是，这并不妨碍你让场景比我们现在有时间处理的更具互动性，或者在我们了解事物如何运作后，让平台更具动态性和冒险性。添加以下抽象`update`方法：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We handle our methods that manage our graphics. We have a getter to retrieve
    `bitmapName`. Then, we have `prepareBitmap()`, which uses the string `bitmapName`
    to make an Android resource ID from a `.png` image file. This file must be present
    in the `drawable` folder of the project. A bitmap is created as we have seen before.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理管理我们图形的方法。我们有一个获取器来检索`bitmapName`。然后，我们有一个`prepareBitmap()`方法，它使用字符串`bitmapName`从`.png`图像文件制作一个Android资源ID。这个文件必须存在于项目的`drawable`文件夹中。就像我们之前看到的那样创建位图。
- en: Now our `prepareBitmap` method does something new. It uses the `createScaledBitmap`
    method to change the size of the bitmap we just created. It not only uses the
    `animFrameCount`, which we already discussed, but also the `pixelsPerMetre` variable,
    which is a parameter of the method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`prepareBitmap`方法做了些新的事情。它使用`createScaledBitmap`方法来改变我们刚刚创建的位图的大小。它不仅使用我们之前讨论的`animFrameCount`，还使用方法的参数`pixelsPerMetre`变量。
- en: 'The idea being, that each device has a `pixelsPerMetre` value that is appropriate
    for the device, which will help us create an identical view of the game across
    devices with different resolutions. We will see exactly where we get this `pixelsPerMetre`
    value from, when we discuss the `Viewport` class. Enter the following methods
    in the `GameObject` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，每个设备都有一个适合该设备的`pixelsPerMetre`值，这将帮助我们跨不同分辨率的设备创建一个相同的游戏视图。当我们讨论`Viewport`类时，我们将确切地了解我们从哪里获取这个`pixelsPerMetre`值。在`GameObject`类中输入以下方法：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also want to be able to know where in the world each `GameObject` is and,
    of course, to set where in the world it is. Here are a getter and a setter, which
    do just that.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够知道每个`GameObject`在世界的哪个位置，当然，也要设置它在世界的哪个位置。以下是一个获取器和设置器，它们正好实现了这个功能。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also want to be able to both, get and set many of the member variables we
    have already discussed. These getters and setters will do that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够获取和设置我们之前已经讨论过的许多成员变量。这些获取器和设置器将实现这一功能。
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Furthermore, we will want to check and change the status of our active and visible
    variables as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将希望能够检查和更改我们活动变量和可见变量的状态。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Set and get `type` of each `GameObject`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和获取每个`GameObject`的`type`。
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will create our first of many child classes from `GameObject`. Right-click
    on the package name in the Android Studio explorer and create a class called `Grass`.
    This will be our first basic tile type that the player can walk about on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从`GameObject`创建我们的第一个子类。在Android Studio资源管理器中右键点击包名，并创建一个名为`Grass`的类。这将是我们第一个基本的地砖类型，玩家可以在上面走动。
- en: This straightforward code uses the constructor to initialize height, width,
    type, and its location in the game world. Note that all this information is passed
    in as parameters to the constructor. The only thing the `Grass` class "knows",
    and one of the few things that will differentiate it from some of the other simple
    `GameObject` child classes, is the value used for `bitmapName`, which in this
    case is `turf`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码使用构造函数来初始化高度、宽度、类型以及游戏世界中的位置。请注意，所有这些信息都是作为参数传递给构造函数的。`Grass`类唯一“知道”的，以及与其他简单的`GameObject`子类区别开来的少数几件事之一，就是`bitmapName`的值，在这个情况下是`turf`。
- en: 'As discussed previously, we also provide an empty implementation of the `update`
    method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如先前讨论的，我们还提供了一个空的`update`方法的实现：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, add the `turf.png` graphic from the `Chapter5/drawable` folder in the download
    bundle to the `drawable` folder in Android Studio.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将下载包中`Chapter5/drawable`文件夹里的`turf.png`图形添加到 Android Studio 的`drawable`文件夹中。
- en: Finally, we will do an absolute barebones implementation of our `Player` class
    that will also extend `GameObject`. We will not be putting any functionality into
    this class just an *x* and *y* world location. This is so that the `Viewport`
    class, which we will implement next, knows where to focus.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对我们的`Player`类进行一个最基础的实现，该类也将扩展`GameObject`。我们不会在这个类中放置任何功能，只需一个*x*和*y*的世界位置。这样，我们接下来要实现的`Viewport`类就知道要聚焦在哪里了。
- en: Here is the `Player` class, which will represent Bob our hero. The class at
    this stage is as simple and straightforward as, and nearly identical to the `Grass`
    class. This will change and evolve substantially as we progress. Note that we
    set the type to `p`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代表我们的英雄Bob的`Player`类。在这个阶段，这个类和`Grass`类一样简单直接，几乎与`Grass`类相同。随着我们进展，这将会有实质性的变化和发展。注意，我们将类型设置为`p`。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add the `player.png` graphic from the `drawable` folder in the download bundle
    to the `drawable` folder in Android Studio. The graphic is a multiframe sprite
    sheet, so it won't display nicely until we animate it in [Chapter 6](ch06.html
    "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob, Beeps, and
    Bumps* , but it will serve its purpose as a placeholder for now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载包中`drawable`文件夹里的`player.png`图形添加到 Android Studio 的`drawable`文件夹中。这个图形是一个多帧的精灵表，所以在[第6章](ch06.html
    "第6章. 平台游戏 – Bob, Beeps, 和 Bumps")*平台游戏 – Bob, Beeps, 和 Bumps*中进行动画处理之前，它不会很好地显示，但现在它可以作为一个占位符。
- en: As we will see next, the view of the game world that the player sees, will focus
    on Bob, as you will probably expect.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们接下来将看到的，玩家看到的游戏世界的视图，将聚焦于Bob，这应该是在你意料之中的。
- en: The view through a viewport
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过视口看到的视图。
- en: A viewport can be thought of as the movie camera that follows the action of
    our game. It defines the area of the game world that is to be shown to the player.
    Typically, it will center on Bob.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将视口视为跟随我们游戏动作的电影摄像机。它定义了要向玩家展示的游戏世界区域。通常，它会以Bob为中心。
- en: It also serves the combined function of making our draw method more efficient
    by determining which objects are inside and outside the player's field of vision.
    There is no point drawing or processing a bunch of enemies, if they are not relevant
    at any given moment.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过确定哪些物体在玩家的视野内外，使我们的绘图方法更加高效。如果在一特定时刻它们并不相关，那么绘制或处理一堆敌人是毫无意义的。
- en: This will significantly speed up tasks like collision detection by implementing
    a first phase of detection by removing objects off screen from the list of objects
    to check for collisions, and it is surprisingly simple to do.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现第一阶段检测，即从需要检查碰撞的对象列表中移除屏幕外的对象，这将显著加快碰撞检测等任务的速度，而且这样做出奇地简单。
- en: Furthermore, our `Viewport` class will have the task of translating game world
    coordinates into appropriate pixel coordinates for drawing on the screen. We will
    also see how this class calculates the `pixelsPerMetre` value that our `GameObject`
    class used in the `prepareBitmap` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`Viewport`类将负责将游戏世界的坐标转换为屏幕上绘制的适当像素坐标。我们还将了解这个类是如何计算`GameObject`类在`prepareBitmap`方法中使用的`pixelsPerMetre`值的。
- en: The `Viewport` class really is an all singing and dancing thing. So let's get
    coding.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewport`类确实是一个功能全面的东西。那么，让我们开始编程吧。'
- en: First, we will declare a whole bunch of useful variables. We have another `Vector2Point5D`,
    which will just be used to represent whatever point in the world is currently
    the central focus in the viewport. Then, we have separate integer values for `pixelsPerMetreX`
    and `pixelsPerMetreY`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一大堆有用的变量。我们还有一个 `Vector2Point5D`，它将用于表示当前视口中焦点的世界上的任意点。然后，我们分别为 `pixelsPerMetreX`
    和 `pixelsPerMetreY` 分配了整数值。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, in this implementation, there is no distinction between `pixelsPerMetrX`
    and `pixelsPerMetreY`. However, the `Viewport` class can be upgraded to take into
    account different ratios of width to height of the device, based on screen size,
    rather than just resolution. We don't do so in this implementation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个实现中，`pixelsPerMetrX` 和 `pixelsPerMetreY` 之间没有区别。但是，`Viewport` 类可以升级，以考虑基于屏幕尺寸而不是仅分辨率的不同设备宽高比。在这个实现中我们没有这样做。
- en: 'Next, we simply have the resolution of the screen in both axes: `screenXResolution`
    and `screenYResolution`. We then have `screenCentreX` and `screenCentreY`, which
    are basically the two previous variables divided by two to find the middle.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地在两个轴上都有屏幕的分辨率：`screenXResolution` 和 `screenYResolution`。然后我们有 `screenCentreX`
    和 `screenCentreY`，它们基本上是前两个变量除以二以找到中间位置。
- en: In our list of declared variables, we have `metresToShowX` and `metresToShowY`
    that will be the number of meters we will squash into our viewport. Changing these
    values will show more or less of the game world on screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明的变量列表中，我们有 `metresToShowX` 和 `metresToShowY`，它们将是我们将压缩到视口中的米数。改变这些值将显示屏幕上更多或更少的游戏世界。
- en: The last member, we will declare at this point, is the `int numClipped`. This
    we will use to output debugging text to see what effect our `Viewport` class is
    having with regard to making drawing, updates, and multiphase collision detection,
    more efficient.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将声明的最后一个成员是 `int numClipped`。我们将使用它输出调试文本，以查看 `Viewport` 类在提高绘图、更新和多阶段碰撞检测的效率方面有何影响。
- en: 'Create a new class called `Viewport` and declare the variables we have just
    discussed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Viewport` 的新类，并声明我们刚刚讨论过的变量：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let's look at the constructor. The constructor just needs to know the resolution
    of the screen. This is obtained in parameters *x* and *y*, which, of course, we
    assign to `screenXResolution` and `screenYResolution`, respectively.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构造函数。构造函数只需要知道屏幕的分辨率。这是通过参数 *x* 和 *y* 获取的，当然，我们分别将其分配给 `screenXResolution`
    和 `screenYResolution`。
- en: Then, as previously suggested, we divide those two previous variables by two
    and assign the results to `screenCentreX` and `screenCentreY`, respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如前所述，我们将这两个变量除以二，并将结果分别分配给 `screenCentreX` 和 `screenCentreY`。
- en: The `pixelsPerMetreX` and `pixelsPerMetreY` are calculated by dividing by 32
    and 18 (again, respectively), so a device with a resolution of 840 x 400 pixels
    will have pixels per meter *x/y* of 32/22\. Now, we have variables that refer
    to the number of pixels of screen real estate on the current device that represents
    a meter of our game world. We will see a number of times in our code, where this
    will be useful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`pixelsPerMetreX` 和 `pixelsPerMetreY` 是通过分别除以32和18来计算的，因此一个分辨率为840 x 400像素的设备将会有每米*x/y*的像素数为32/22。现在，我们有变量表示当前设备上表示游戏世界一米的屏幕像素数量。在代码中我们会多次看到，这将非常有用。'
- en: We will actually draw a slightly wider area than this, to make sure we don't
    have any unsightly gaps/lines around the edge of the screen and assign 34 to `metresToShowX`
    and 20 to `metresToShowY`. Now, we have variables that refer to the amount of
    our game world that we will draw each frame.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上会绘制一个比这稍宽的区域，以确保屏幕边缘不会有难看的缝隙/线条，并将34分配给 `metresToShowX`，20分配给 `metresToShowY`。现在，我们有变量表示我们每一帧将绘制多少游戏世界。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once we have some screen output, you can experiment with these values to create
    a more or less zoomed-in or zoomed-out experience for the player.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了屏幕输出，你可以通过调整这些值来为玩家创建放大或缩小的体验。
- en: Nearing the end of the constructor, we create a new `Rect` object called `convertedRect`
    that we will see in action soon. We call `new()` on `currentViewportWorldCentre`,
    so it is ready for action shortly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数即将结束时，我们创建了一个名为 `convertedRect` 的新 `Rect` 对象，我们很快就会看到它的实际应用。我们在 `currentViewportWorldCentre`
    上调用 `new()` 方法，所以它很快就能投入使用。
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If some of the screenshots throughout this project look slightly different to
    the results you get, it is because some images have been taken using different
    viewport settings to highlight different aspects of the game world.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个项目中的某些截图看起来与您得到的结果略有不同，那是因为一些图片是使用不同的视口设置来突出游戏世界的不同方面。
- en: The first method we write for the `Viewport` class is `setWorldCentre()`. It
    receives an *x* and a *y* parameter, which is promptly assigned as the `currentWorldCentre`.
    We need this method because of course the player will be moving around in the
    world, and we need to let the `Viewport` class know where Bob is. Also, as we
    will see in [Chapter 8](ch08.html "Chapter 8. Platformer – Putting It All Together"),
    *Putting It All together*, we will also have a situation where we don't want Bob
    as the center of attention.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`Viewport`类编写的第一个方法是`setWorldCentre()`。它接收一个*x*和*y*参数，并立即分配给`currentWorldCentre`。我们需要这个方法，因为玩家当然会在世界中移动，我们需要让`Viewport`类知道Bob的位置。同样，正如我们将在[第8章](ch08.html
    "第8章. 平台游戏 - 组合在一起")，*组合在一起*中看到的，我们也会有不想让Bob成为关注焦点的情况。
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, a few simple getters and setters that will be useful to us as we progress.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些简单的获取器和设置器将在我们进行时非常有用。
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We fulfil one of the primary roles of the `Viewport` class with the `worldToScreen()`
    method. As the name suggests, this is the method that converts the locations of
    all the objects currently in the visible viewport from world coordinates to pixel
    coordinates that can actually be drawn to the screen. It returns our previously
    prepared `rectToDraw` object as the result.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`worldToScreen()`方法实现了`Viewport`类的主要功能之一。顾名思义，这个方法是用来将当前可见视口中的所有对象的位置从世界坐标转换为可以实际绘制在屏幕上的像素坐标。它返回我们之前准备好的`rectToDraw`对象作为结果。
- en: This is how `worldToScreen()` works. It receives the *x* and *y* world locations
    of an object along with that object's width and height. With these values, each
    in turn, subtracts the objects world coordinate multiplied by the pixels per meter
    for the current screen, from the appropriate current world viewport center (*x*
    or *y*). Then, for the left and top coordinates of the object, the result is subtracted
    from the pixel screen center value and for the bottom and right coordinates, it
    is added.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`worldToScreen()`方法就是这样工作的。它接收一个对象的*x*和*y*世界位置以及该对象的宽度和高度。利用这些值，分别从当前屏幕的世界视口中心（*x*或*y*）减去对象的世界坐标乘以每米的像素数。然后，对于对象的左和上坐标，从像素屏幕中心值中减去结果，对于下和右坐标，则加上。'
- en: 'These values are then packed into the left, top, right, and bottom values of
    `convertedRect` and returned to the `draw` method of `PlatformView`. Add the `worldToScreen`
    method to the `Viewport` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值随后被包装进`convertedRect`的左、上、右和下值中，并返回给`PlatformView`的`draw`方法。将`worldToScreen`方法添加到`Viewport`类中：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we implement the second primary function of the `Viewport` class, removing
    objects that are currently of no interest to us. We call this clipping, and the
    method we will call; `clipObjects()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现了`Viewport`类的第二个主要功能，即移除当前对我们没有兴趣的对象。我们称这个过程为剪辑，我们将要调用的方法是`clipObjects()`。
- en: Once again, we receive as parameters the `x`, `y`, `width`, and `height` of
    an object. The test starts by assuming that we want to clip the current object
    and we assign `true` to clipped.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们接收作为参数的物体的`x`、`y`、`width`和`height`。测试首先假设我们想要剪辑当前对象，并将`true`分配给`clipped`。
- en: 'Then, the four nested `if` statements test whether each and every point of
    the object is within the bounds of the related side of the viewport. If it is,
    we set `clipped` to `false`. Some of the levels we will design have in excess
    of a thousand objects, but we will see that we rarely need to process (update,
    collision detection, and draw) more than a quarter of them in any given frame.
    Enter the code for the `clipObjects` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，四个嵌套的`if`语句测试对象的每一个点是否都在视口相关侧边的范围内。如果是，我们将`clipped`设置为`false`。我们设计的某些级别将包含超过一千个对象，但我们将会看到，在任何给定帧中，我们很少需要处理（更新、碰撞检测和绘制）超过四分之一的对象。输入`clipObjects`方法的代码：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we provide access to the `numClipped` variable so that it can be read and
    reset to zero each frame.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提供了对`numClipped`变量的访问权限，以便它可以每帧被读取并重置为零。
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s declare and initialize our `Viewport` object. Add this code right after
    we initialize our `Paint` object in the `PlatformView` constructor. The new code
    is shown highlighted here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明并初始化我们的`Viewport`对象。在`PlatformView`构造函数中初始化我们的`Paint`对象之后，添加以下代码。新代码在这里高亮显示：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can now describe and position objects in our game world and focus on the
    precise parts of the world we are interested in. Let's see how we will actually
    get our objects into that world, so we can then update and draw them as we have
    done before. We will also look at the concept of a level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以描述并定位游戏世界中的对象，并专注于我们感兴趣的世界精确部分。让我们看看我们实际上是如何将对象放入那个世界的，这样我们就可以像以前一样更新和绘制它们。我们还将探讨关卡的概念。
- en: Creating the levels
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建关卡
- en: Here, we will see how to build our `LevelManager`, `LevelData`, and our first
    real level, `LevelCave`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将了解如何构建我们的`LevelManager`、`LevelData`和我们第一个真正的关卡`LevelCave`。
- en: The `LevelManager` class will eventually need a copy of our `InputController`
    class. Therefore, in order to try and keep to our intentions of not having to
    delete any code, we will include a parameter for `InputController` in our `LevelManager`
    constructor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager`类最终将需要我们`InputController`类的一个副本。因此，为了尽量遵循我们不需要删除任何代码的意图，我们将在`LevelManager`构造函数中包含一个`InputController`的参数。'
- en: 'Let''s quickly create a blank template for our `InputController` class. Create
    a new class in the usual way and call it `InputController`. Add this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速为我们的`InputController`类创建一个空白模板。按照通常的方式创建一个新类，并将其命名为`InputController`。添加以下代码：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let's look at our, initially, very simple `LevelData` class. Create a new
    class, call it `LevelData`, and add this code. At this stage, it holds just an
    `ArrayList` object for `Strings`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们最初非常简单的`LevelData`类。创建一个新类，将其命名为`LevelData`，并添加此代码。在这个阶段，它仅包含一个用于`Strings`的`ArrayList`对象。
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we can start on what will eventually become our first playable level.
    Create a new class, call it `LevelCave`, and add this code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始创建最终将成为我们第一个可玩关卡的代码。创建一个新类，将其命名为`LevelCave`，并添加此代码：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The position of `p` for player in the `LevelCave` file is arbitrary. As long
    as it is on there, the `Player` object will be initialized. The actual spawn location
    of the player character is determined by the call to a `loadLevel` method, as
    we will soon see. I usually put the `p` for player as the first element on the
    first line of the map, then it is less likely to be forgotten.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LevelCave`文件中，`p`代表玩家的位置是任意的。只要它在里面，`Player`对象就会被初始化。玩家角色的实际生成位置由对`loadLevel`方法的调用决定，我们很快就会看到。我通常将代表玩家的`p`作为地图第一行第一个元素，这样就不太可能被遗忘。
- en: Now, let's talk about how this level design is going to work. We will enter
    alpha-numeric characters in the `LevelCave` class within the `tiles.add("..."`
    parts of the code. We will enter a different alpha-numeric character depending
    on which `GameObject` we want to place into the level. At the moment, we just
    have `p` to represent the `Player` object, a `1` to represent a `Grass` object,
    and a period (`.`) to represent an empty space of one game world meter square.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈这个关卡设计将如何工作。我们将在`LevelCave`类中的代码的`tiles.add("..."`部分输入字母数字字符。我们将根据要放入关卡的`GameObject`输入不同的字母数字字符。目前，我们只有一个`p`代表`Player`对象，一个`1`代表`Grass`对象，以及一个句点（`.`）代表一个游戏世界一平方米的空地。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This implies that the positioning of the `Grass` objects with the `1` character
    in the previous block of code can be arranged exactly how you like. This is the
    case, and whenever we look at the code for our `LevelCave` class please feel free
    to improvise and experiment as you like.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着上一代码块中使用`1`字符定位`Grass`对象的方式可以完全按照你的喜好来安排。确实如此，每当我们查看`LevelCave`类的代码时，请随意即兴发挥和实验。
- en: As the project continues, we will add more than twenty different `GameObject`
    child classes. Some will be inanimate like `Grass`, others will be thinking, aggressive
    enemies. All will be placeable within our level design.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的进行，我们将添加超过二十个不同的`GameObject`子类。有些将像`Grass`一样是静止的，其他的将是具有思考能力的侵略性敌人。所有这些都可放置在我们的关卡设计中。
- en: Now, we can implement the class to manage our levels. Create a new Java class
    and call it `LevelManager`. Enter the code for the `LevelManager` class as we
    go through, and discuss it a block at a time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个类来管理我们的关卡。创建一个新的Java类，将其命名为`LevelManager`。随着我们逐步进行，输入`LevelManager`类的代码，一次讨论一个代码块。
- en: First, a few import directives.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是一些导入指令。
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the constructor is where we have a `String` `level` to hold the name of
    the level, `mapWidth` and `mapHeight` to store the width and height in game world
    meters of the current level, a `Player` object because we know we will always
    have one of them, and an `int` type called `playerIndex`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构造函数是我们有一个`String`类型的`level`来保存关卡名称，`mapWidth`和`mapHeight`以游戏世界米为单位存储当前关卡的宽度和高度，一个`Player`对象，因为我们知道我们总会有一个，以及一个名为`playerIndex`的`int`类型。
- en: Soon, we will have an `ArrayList` object of many `GameObject` classes, and it
    will be handy to always have the index of the `Player` object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不久，我们将拥有许多`GameObject`类的`ArrayList`对象，始终拥有`Player`对象的索引将非常方便。
- en: Moving on, we have the Boolean `playing` because we will need to know when the
    game is being played or being paused and a float called `gravity`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有布尔值`playing`，因为我们需要知道游戏是在进行中还是暂停，以及一个名为`gravity`的浮点数。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the context of this project, gravity will not be used to its full potential,
    but it can easily be manipulated so that different levels have a different gravity.
    This is why it is in the `LevelManager` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的背景下，重力不会发挥其全部潜力，但可以轻松地操纵它，使不同级别的重力不同。这就是为什么它在`LevelManager`类中的原因。
- en: Finally, we declare an object of type `LevelData`, an `ArrayList` object to
    hold all our `GameObject` objects, an `ArrayList` object to hold representations
    of the players control buttons and a regular array to hold the majority of all
    the `Bitmap` objects we will need.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明一个`LevelData`类型的对象，一个用于保存所有`GameObject`对象的`ArrayList`对象，一个用于保存玩家控制按钮表示的`ArrayList`对象，以及一个常规数组用于保存我们大部分需要的`Bitmap`对象。
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then, in the constructor, we examine the signature and see that it receives
    a `Context` object, `pixelsPerMetre` that will have been determined when the `Viewport`
    class was constructed, `screenWidth` again direct from the `Viewport` class, a
    copy of our `InputController` class, and then the name of the level to load. The
    `int` parameters, `px` and `py`, are the starting coordinates for the player.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中，我们检查签名并看到它接收一个`Context`对象，`pixelsPerMetre`（在`Viewport`类构造时确定），再次直接来自`Viewport`类的`screenWidth`，我们`InputController`类的一个副本，以及要加载的关卡名称。`int`参数`px`和`py`是玩家的起始坐标。
- en: We assign the level parameter to our member level, then we switch to determine
    which class will be our current level. Of course, at the moment, we only have
    `LevelCave`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关卡参数赋值给我们的成员级别，然后切换以确定哪个类将是我们的当前关卡。当然，目前我们只有一个`LevelCave`。
- en: 'Then, we initialize our `gameObject ArrayList` and our `bitmapsArray`. We then
    call `loadMapData()`, which is a method we will write shortly. After this, we
    set `playing` to `true`, and finally we have a getter method to find out what
    the state of `playing` is. Enter the code we have just discussed in the `LevelManager`
    class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化我们的`gameObject ArrayList`和`bitmapsArray`。然后我们调用`loadMapData()`，这是我们很快会编写的一个方法。在此之后，我们将`playing`设置为`true`，最后我们有一个获取器方法来找出`playing`的状态。在`LevelManager`类中输入我们刚刚讨论的代码：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we have a really simple method which will enable us to get any `Bitmap`
    object based on the type of `GameObject` we are currently dealing with. This way,
    each `GameObject` does not have to hold its own `Bitmap` object. For example,
    we can design a level with hundreds of `Grass` objects. This can easily use up
    the memory of even a modern tablet.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个非常简单的方法，可以基于我们当前处理的`GameObject`类型获取任何`Bitmap`对象。这样，每个`GameObject`不必持有自己的`Bitmap`对象。例如，我们可以设计一个包含数百个`Grass`对象的关卡。这很容易就会用尽即使是现代平板电脑的内存。
- en: 'Our `getBitmap` method takes an `int` value as an index and returns a `Bitmap`
    object. We will see how we access the appropriate value for `index` in the next
    method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getBitmap`方法接收一个`int`类型的索引值，并返回一个`Bitmap`对象。我们将在下一个方法中看到如何访问`index`的适当值：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This next method will enable us to get the `index` with which to call the `getBitmap`
    method. As long as the `char` cases correspond with the `type` values held by
    the various `GameObject` child classes we create, and the index returned by this
    method matches the index of the appropriate `Bitmap` held in the `bitmapsArray`,
    we will only ever need one copy of each `Bitmap` object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法将使我们能够获得调用`getBitmap`方法的`index`。只要`char`案例与我们创建的各种`GameObject`子类持有的`type`值相对应，并且此方法返回的索引与`bitmapsArray`中适当`Bitmap`的索引相匹配，我们就只需要每个`Bitmap`对象的一个副本。
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we do the real work with the `LevelManager` class, and load our level from
    our design. The method needs the `pixelsPerMetre` and the `Player` objects coordinates
    in order to do its work. As this is a large method, the explanations and the code
    have been split into a few sections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`LevelManager`类进行实际的工作，并从我们的设计中加载关卡。该方法需要`pixelsPerMetre`和`Player`对象的坐标才能执行其工作。由于这是一个大方法，解释和代码已经被分成几个部分。
- en: In this first part, we simply declare an `int` type called `index` and set it
    to `-1`. As we loop through our level design, it will help us keep track of where
    we are up to.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们简单声明一个名为`index`的`int`类型，并将其设置为`-1`。当我们遍历我们的关卡设计时，它将帮助我们跟踪当前的位置。
- en: Then, we calculate the height and width of the map using the size of `ArrayList`
    and the length of the first element of `ArrayList`, respectively.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ArrayList`的大小和`ArrayList`的第一个元素的长度分别计算地图的高度和宽度。
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We enter a nested `for` loop starting with the first element of the first string
    in our `ArrayList` object. We work from left to right across the first string
    before moving on to the second string.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ArrayList`对象的第一个字符串的第一个元素开始进入嵌套的`for`循环。我们在移动到第二个字符串之前，从左到右遍历第一个字符串。
- en: We check to see if an object other than an empty space (.) is present at the
    current location, and if it is, we enter a switch block to create the appropriate
    object at the designated location.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查当前位置是否除了空格（.）之外还有其他对象，如果有，我们就进入一个开关块，在指定位置创建适当的对象。
- en: If we encounter a `1`, then we add a new `Grass` object to `ArrayList`, and
    if we encounter a `p`, we initialize the `Player` object at the location passed
    in to the constructor of this `LevelManager` class. When a new `Player` object
    is created, we also initialize our `playerIndex` and `player` object ready for
    future use.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到一个`1`，那么我们向`ArrayList`中添加一个新的`Grass`对象；如果遇到一个`p`，我们就在传递到`LevelManager`类构造函数的位置初始化`Player`对象。当一个新`Player`对象被创建时，我们还会初始化我们的`playerIndex`和`player`对象，以备将来使用。
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If a new object has been added to `gameObjects ArrayList`, we need to check
    if the corresponding bitmap has been added to the `bitmapsArray`. If it hasn''t,
    we add one using the `prepareBitmap` method of the current `GameObject` class
    under consideration. Here is the code to perform this check and prepare the bitmap,
    if necessary:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新的对象被添加到`gameObjects ArrayList`中，我们需要检查相应的位图是否已经被添加到`bitmapsArray`中。如果没有，我们使用当前考虑的`GameObject`类的`prepareBitmap`方法添加一个。以下是执行此检查并在必要时准备位图的代码：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Back in the `PlatformView` class, to put all our level objects to use, we call
    `loadLevel()` just after where we initialized our `Viewport` class in the `PlatformView`
    constructor. The new code has been highlighted, and the existing code is provided
    for context:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`PlatformView`类中，为了使用我们的所有关卡对象，我们在`PlatformView`构造函数中初始化`Viewport`类之后立即调用`loadLevel()`。新代码已经突出显示，并提供现有代码作为上下文：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, now we need to implement the `loadLevel` method within the `PlatformView`
    class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们需要在`PlatformView`类中实现`loadLevel`方法。
- en: The `loadLevel` method needs to know which level to load, so the `switch` statement
    in the `LevelManager` constructor can do its work, and it also needs the coordinates
    to spawn our hero Bob.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadLevel`方法需要知道要加载哪个关卡，这样`LevelManager`构造函数中的`switch`语句才能执行其工作，它还需要坐标来生成我们的英雄Bob。'
- en: We initialize our `LevelManager` object by calling its constructor with the
    viewport data retrieved from `vp` and the level/player data we have just discussed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从`vp`获取的视口数据以及我们刚刚讨论的关卡/玩家数据调用其构造函数来初始化我们的`LevelManager`对象。
- en: We then create a new `InputController` class, again passing in some data from
    `vp`. We will see exactly what we do with this data when we build our `InputController`
    class in [Chapter 6](ch06.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"),
    *Bob, Beeps, and Bumps*. Finally, we call `vp.setWorldCentre()` and pass it in
    the player's location as the coordinates. This centers the screen on Bob.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个新的`InputController`类，同样从`vp`中传递一些数据。在[第6章](ch06.html "第6章. 平台游戏 – Bob,
    Beeps, 和 Bumps")，*Bob, Beeps, 和 Bumps*中构建我们的`InputController`类时，我们会确切地看到如何使用这些数据。最后，我们调用`vp.setWorldCentre()`，并将玩家的位置坐标传递给它，这样屏幕就居中了Bob。
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can add some code to our `update` method that will be first to utilize a
    primary function of our new `Viewport` class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`update`方法中添加一些代码，这将首先利用我们新的`Viewport`类的主要功能。
- en: The enhanced update method
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的更新方法
- en: 'At last, we can use our handy `ArrayList` of game objects and our `Viewport`
    functionality to flesh out our enhanced `update` method. In the code that follows,
    we simply use an enhanced `for` loop to go through each `GameObject`. We check
    if it `isActive()`, and then send the object''s location and dimensions to `clipObjects()`
    wrapped in an `if` statement. If `clipObjects()` returns `false`, then the object
    is not clipped and the object is flagged as visible by calling `go.setVisible(true)`.
    Otherwise, it is flagged as not visible calling `go.setVisible(false)`. This is
    the only aspect of any object that is updated at the moment. We will see when
    we run the game, at the end of the chapter, that it is already useful. Enter the
    new code in the `update` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用我们的`ArrayList`游戏对象和`Viewport`功能来完善我们的增强型`update`方法。在下面的代码中，我们仅使用增强的`for`循环遍历每个`GameObject`。我们检查它是否`isActive()`，然后通过`if`语句将对象的位置和尺寸传递给`clipObjects()`。如果`clipObjects()`返回`false`，则对象没有被剪辑，并通过调用`go.setVisible(true)`将对象标记为可见。否则，通过调用`go.setVisible(false)`将其标记为不可见。这是此刻更新任何对象的唯一方面。我们将在本章末尾运行游戏时看到，它已经很有用了。在`update`方法中输入新代码：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The enhanced draw method
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的绘制方法
- en: Now, we can be more precise about which objects we need to draw. First, we declare
    and initialize a new `Rect` object called `toScreen2d`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更精确地确定我们需要绘制哪些对象。首先，我们声明并初始化一个新的名为`toScreen2d`的`Rect`对象。
- en: Then, we loop through our `gameObjects ArrayList` once for each layer starting
    with the lowest layer. This isn't strictly necessary at this stage because all
    our objects are, by default, currently on layer zero. We will add objects on layer
    -1 and 1 before the end of the project, and we don't want to have to rewrite code
    if we can help it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从最低层开始，针对每一层遍历一次`gameObjects ArrayList`。在这个阶段，这并不是严格必要的，因为我们的所有对象默认都当前在零层。在项目结束前，我们将添加位于-1层和1层的对象，如果我们能够避免，则不想重写代码。
- en: 'Next, we check if the object is visible and on the current layer. If it is,
    we pass the current object''s location and dimensions to the `worldToScreen` method,
    which returns the result to our previously prepared `toScreen2d Rect` object.
    Then, we call `drawBitmap()` using our `bitmapArray` to provide the appropriate
    bitmap, and pass in the coordinates of `toScreen2d`. Update the `draw` method
    as highlighted:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查对象是否可见并且是否在当前层。如果是，我们将当前对象的位置和尺寸传递给`worldToScreen`方法，该方法将结果返回给我们之前准备的`toScreen2d
    Rect`对象。然后，我们使用`bitmapArray`调用`drawBitmap()`以提供适当的位图，并传入`toScreen2d`的坐标。更新突出显示的`draw`方法：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, still in the `draw` method, we print debugging info to the screen, including
    the size of our `gameObjects ArrayList` compared to the number of objects that
    were clipped this frame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在`draw`方法中，我们将调试信息打印到屏幕上，包括我们的`gameObjects ArrayList`的大小与这一帧中被剪辑的对象数量比较。
- en: 'Then, we finish the `draw` method by the usual call to `unlockCanvasAndPost()`.
    Note that at the end of the `if(debugging)` block, we call `vp.resetNumClipped`
    to set the `numClipped` variable back to zero ready for the next frame. Add this
    code straight after the previous block of code in the `draw` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过常规调用`unlockCanvasAndPost()`来完成`draw`方法。注意，在`if(debugging)`块的末尾，我们调用`vp.resetNumClipped`将`numClipped`变量重置为零，为下一帧做准备。在`draw`方法中的上一代码块之后直接添加此代码：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the first time in this project, we can actually run our game and see some
    results:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们第一次实际运行游戏并看到了一些结果：
- en: '![The enhanced draw method](img/B04322_05_03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![增强的绘制方法](img/B04322_05_03.jpg)'
- en: Note in the image the precise layout of the grass from our `LevelCave` design.
    You can also see our squashed Bob sprite sheet and the fact that there are 28
    objects, but 10 of them have been clipped. As our levels get bigger, the ratio
    of clipped to unclipped will dramatically increase in favor of the vast majority
    being clipped.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图像中我们`LevelCave`设计中草地的精确布局。您还可以看到我们压缩的Bob精灵表和有28个对象，但其中10个已被剪辑。随着我们的关卡变得越来越大，剪辑与未剪辑的比例将大幅增加，绝大多数对象将被剪辑。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot of ground in this chapter, and now have a well fleshed-out
    game engine.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了许多内容，现在拥有了一个完善的游戏引擎。
- en: As we have done much of the setup work, from now on, most of the code we add
    will also have a visible (or audible) result and be much more satisfying, as we
    will be able to regularly run our game to see the improvements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了大部分设置工作，从现在开始，我们添加的大部分代码也将有可见（或可听）的结果，并将更加令人满意，因为我们将能够定期运行我们的游戏以查看改进。
- en: In the next chapter, we will add sound effects and input detection, thus bringing
    Bob to life. Then, we will see how dangerous his world can be, and will promptly
    add collision detection so that he can stand on a platform.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加声音效果和输入检测，从而让Bob栩栩如生。然后，我们将会看到他的世界可能多么危险，并将迅速添加碰撞检测，使他能够站在平台上。
