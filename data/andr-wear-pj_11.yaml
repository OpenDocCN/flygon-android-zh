- en: More About Wear 2.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Wear 2.0的更多信息
- en: Android Wear 2.0 is a prominent update with plenty of new features bundled in,
    including Google Assistant, standalone applications, new watch faces, and support
    for third-party complications. In previous chapters, we explored how to write
    different kinds of Wear applications. Wear 2.0 offers more with the current market
    research and Google is working with partner companies to build a powerful ecosystem
    for Wear.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 2.0是一个重要的更新，包含了许多新功能，包括Google助手、独立应用程序、新手表表盘以及支持第三方复杂功能。在前面的章节中，我们探讨了如何编写不同类型的Wear应用。Wear
    2.0根据当前市场研究提供了更多功能，谷歌正在与合作伙伴公司合作，为Wear构建强大的生态系统。
- en: 'In this chapter, let''s understand how we can take our existing skills forward
    with the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们了解如何通过以下概念将我们的现有技能向前推进：
- en: Standalone applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立应用程序
- en: Curved layouts and more UI components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲面布局和更多的UI组件
- en: Complications API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂功能API
- en: Different navigations and actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的导航和动作
- en: Wrist gestures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手腕手势
- en: Input method framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入法框架
- en: Distributing Wear apps to the Play store
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Wear应用分发到Play商店
- en: Standalone applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立应用程序
- en: In Wear 2.0, standalone applications are powerful feature of the wear ecosystem.
    How cool it will be using wear apps without your phone nearby! There are various
    scenarios in which Wear devices used to be phone dependent, for example, to receive
    new e-mail notifications, Wear needed to be connected to the phone for Internet
    services. Now, wear devices can independently connect to Wi-Fi and can sync all
    apps for new updates. The user can now complete more tasks with wear apps without
    a phone paired to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Wear 2.0中，独立应用程序是穿戴生态系统的强大功能。在没有手机的情况下使用穿戴应用是多么酷啊！有许多场景，Wear设备曾经需要依赖手机，例如，接收新电子邮件通知，Wear需要连接到手机以使用互联网服务。现在，穿戴设备可以独立连接Wi-Fi，并且可以同步所有应用进行新更新。用户现在可以在没有配对手机的情况下，使用穿戴应用完成更多任务。
- en: Identifying an app as a standalone
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用标识为独立应用
- en: The idea of a standalone application is a great feature of the wear platform.
    Wear 2.0 differentiates the standalone app through a metadata element in the Android
    manifest file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 独立应用程序的理念是穿戴平台的一个伟大特性。Wear 2.0通过Android清单文件中的元数据元素区分独立应用。
- en: 'Inside the application tag `<application>`, the `</application>` metadata element
    is placed with `com.google.android.wearable.standalone` with the value true or
    false. The new metadata element indicates whether the wear app is a standalone
    app and doesn''t require the phone to be paired to operate. When the metadata
    element is set to true, the app a can also be available for wear devices working
    with iPhone. Generally, the watch app can be categorized as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<application>`应用标签内部，`</application>`元数据元素与`com.google.android.wearable.standalone`一起放置，值为true或false。新的元数据元素指示穿戴应用是否为独立应用，不需要配对手机即可操作。当元数据元素设置为true时，应用也可以适用于与iPhone合作的穿戴设备。通常，手表应用可以分为以下几类：
- en: Completely independent of the phone app
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全独立于手机应用
- en: Semi-independent (without phone pairing, wear app will have limited functionality)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半独立（没有手机配对，穿戴应用的功能将有限）
- en: Dependent on the phone app
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于手机应用
- en: 'To make a Wear app completely independent or semi-independent, set the value
    of the metadata to true, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Wear应用完全独立或半独立，请将元数据的值设置为true，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, any platform, such as iPhone or Android phones without the Play store on
    them, can also use wear apps, downloading them directly from the Play store present
    in wear. By setting the value of the metadata to false, we tell Android Wear that
    this Wear app is dependent on a phone with the Play store app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何平台，比如没有Play商店的iPhone或Android手机，也可以使用穿戴应用，直接从穿戴设备中的Play商店下载。通过将元数据值设置为false，我们告诉Android
    Wear这个穿戴应用依赖于带有Play商店应用的手机。
- en: '**Note:** Regardless of the possibility that the value is false, the watch
    application can be installed before the corresponding phone application is installed.
    In this way, if a watch application identifies that a companion phone does not
    have a necessary phone application, the watch application ought to incite the
    user to install the phone application.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**不管值可能是错误的，手表应用可以在相应的手机应用安装之前安装。这样，如果手表应用识别到配套手机没有必要的手机应用，手表应用应该提示用户安装手机应用。'
- en: Standalone apps storage
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立应用存储
- en: You can use standard Android storage APIs to store data locally. For instance,
    you can use the SharedPreference API, SQLite, or internal storage. We have, up
    until now, explored how to integrate ORM libraries, such as Realm, into wear applications
    not simply to store away data, but to likewise share code between a wear application
    and a phone application. On the other hand, code that is specific to a shape component
    and form factor can be in a different module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的Android存储API在本地存储数据。例如，你可以使用SharedPreference API、SQLite或内部存储。到目前为止，我们已经探讨了如何将ORM库（如Realm）集成到穿戴应用中，不仅仅是为了存储数据，同时也为了在穿戴应用和手机应用之间共享代码。另一方面，特定于形状组件和外形尺寸的代码可以放在不同的模块中。
- en: Detecting wear app on another device
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在另一台设备上检测穿戴应用。
- en: Android wear apps and Android mobile apps can recognize support apps using the
    Capability API. Phone and wear apps can advertise to paired devices statically
    and dynamically. At the point when an application is on the node in a user's wear
    network, the **Capability API** enables another application to identify the correspond
    installed applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android穿戴应用和Android手机应用可以使用Capability API识别支持的应用。手机和穿戴应用可以静态和动态地向配对的设备广播。当应用在用户的穿戴网络中的节点上时，**Capability
    API**使另一个应用能够识别相应安装的应用。
- en: Advertise capability
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广告功能。
- en: 'To launch an activity on a handheld device from a wearable device, use the
    `MessageAPI` class to send the request. Multiple wearables can be associated with
    the handheld Android device; the wearable application needs to determine that
    an associated node is fit to launch the activity from a handheld device application.
    To advertise the capability of the handheld application, perform the following
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要从穿戴设备在手持设备上启动活动，请使用`MessageAPI`类发送请求。多个穿戴设备可以与手持Android设备关联；穿戴应用需要确定关联的节点是否适合从手持设备应用启动活动。要广告手持应用的功能，请执行以下步骤：
- en: Create an XML configuration file in the `res/values/` directory of your project
    and name it `wear.xml`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`res/values/`目录中创建一个XML配置文件，并将其命名为`wear.xml`。
- en: Add a resource named `android_wear_capabilities` to `wear.xml`
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wear.xml`中添加一个名为`android_wear_capabilities`的资源。
- en: Define the capabilities that the device provides
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义设备提供的功能。
- en: 'Note: Capabilities are custom strings that you characterize and should be unique
    within your application.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：功能是自定义字符串，由你定义，并且在你的应用中应该是唯一的。
- en: 'The following example shows how to add a capability named `voice_transcription`
    to `wear.xml`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何向`wear.xml`添加一个名为`voice_transcription`的功能：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Retrieving the nodes with the required capability
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取具有所需功能的节点。
- en: 'Initially, we can detect the capable nodes by calling the `CapabilityAPI.getCapability()`
    method. The following examples show how to manually retrieve the results of reachable
    nodes with the `voice_transcription` capability:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们可以通过调用`CapabilityAPI.getCapability()`方法来检测有能力的节点。以下示例展示了如何手动检索具有`voice_transcription`功能的可达节点的结果：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To detect the capable nodes as they connect to a wearable device, register
    a `CapabilityAPI.capabilityListner()` instance to `googleAPIclient`. The following
    example shows how to register the listener and retrieve the results of reachable
    nodes with the `voice_transcription` capability:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在穿戴设备连接时检测到有能力的节点，请将`CapabilityAPI.capabilityListner()`实例注册到`googleAPIclient`。以下示例展示了如何注册监听器并检索具有`voice_transcription`功能的可达节点的结果：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note: On the off chance that you create a service that extends `WearableListenerService`
    to identify capability changes, you might need to override the `onConnectedNodes()`
    method to listen in to finer-grained connectivity details, for example, when a
    wearable device changes from Wi-Fi to a Bluetooth connection with the handset.
    For more data on the most proficient method to listen for important events, read
    **Data Layer Events**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你创建了一个扩展`WearableListenerService`的服务来识别功能变化，你可能需要重写`onConnectedNodes()`方法，以监听更细粒度的连接细节，例如，当穿戴设备从Wi-Fi更改为与手机通过蓝牙连接时。有关如何监听重要事件的信息，请阅读**数据层事件**。
- en: In the wake of recognizing the capable nodes, figure out where to send the message.
    You ought to pick a node that is in close proximity to your wearable device to
    limit message routing through numerous nodes. A nearby node is characterized as
    one that is directly associated with the device. To decide whether a node is nearby,
    call the `Node.isNearby()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别出有能力的节点后，确定消息发送的位置。你应该选择一个与你的可穿戴设备接近的节点，以减少通过多个节点路由消息。一个附近的节点被定义为直接与设备连接的节点。要确定一个节点是否在附近，请调用`Node.isNearby()`方法。
- en: Detecting and guiding the user to install a phone app
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测并指导用户安装手机应用
- en: Now, we know how to detect the wear and mobile applications using the Capability
    API. It's an opportunity to guide the user to install the corresponding application
    from the Play Store.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何使用Capability API检测穿戴和手机应用。现在是引导用户从Play商店安装相应应用的时候了。
- en: Use the `CapabilityApi` to check whether your phone application is installed
    on the paired phone. For more data, see the Google samples. In the event that
    your phone application isn't installed on the phone, use `PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`
    to check what sort of phone it is.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CapabilityApi`检查你的手机应用是否已安装在配对的手机上。有关更多信息，请参见Google示例。如果你的手机应用没有安装在手机上，使用`PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`检查它是什么类型的手机。
- en: 'If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE` is returned valid,
    it implies the phone is an Android phone with the Play store installed. Call `RemoteIntent.startRemoteActivity()`
    on the wear device to open the Play Store on the phone. Use the market URI for
    your telephone application (which might not be the same as your phone URI). For
    instance, use a market URI: `market://details?id=com.example.android.wearable.wear.finddevices`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE`有效，这意味着手机是一部安装了Play商店的Android手机。在穿戴设备上调用`RemoteIntent.startRemoteActivity()`，在手机上打开Play商店。使用你的电话应用的市场URI（可能与你的手机URI不同）。例如，使用市场URI：`market://details?id=com.example.android.wearable.wear.finddevices`。
- en: In the event that `PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE` is
    returned, it implies the phone is likely an iOS phone (with no Play Store accessible).
    Open the App Store on the iPhone by calling `RemoteIntent.startRemoteActivity()`
    on the wear device. You can indicate your application's iTunes URL, for instance,
    [https://itunes.apple.com/us/application/yourappname.](https://itunes.apple.com/us/application/yourappname.)
    Likewise, observe opening a URL from a watch. On an iPhone, from Android Wear,
    you can't programmatically determine whether your phone application is installed.
    As a best practice, give a mechanism to the user (for example, a button) to manually
    trigger the opening of the App Store.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE`，这意味着手机很可能是iOS手机（无法访问Play商店）。通过在穿戴设备上调用`RemoteIntent.startRemoteActivity()`，在iPhone上打开App
    Store。你可以指定你的应用在iTunes的URL，例如，[https://itunes.apple.com/us/application/yourappname.](https://itunes.apple.com/us/application/yourappname。)同样，注意从手表打开URL。在iPhone上，从Android
    Wear，你不能编程确定你的手机应用是否已安装。作为最佳实践，为用户提供一种机制（例如，一个按钮）手动触发打开App Store。
- en: Using the `remoteIntent` API portrayed earlier, you can determine that any URL
    can be opened on the phone from a wear device and no phone application is required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前描述的`remoteIntent` API，你可以确定任何URL都可以从穿戴设备在手机上打开，而不需要手机应用。
- en: Getting just the important information
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只获取重要的信息
- en: In most use cases, when we get data from the Internet, we just get the necessary
    information. Any more than that and we may encounter pointless idleness, memory
    use, and battery use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数用例中，当我们从互联网获取数据时，我们只获取必要的信息。超出这个范围，我们可能会遇到不必要的延迟、内存使用和电池消耗。
- en: 'At the point when a wear device is associated with a Bluetooth LE association,
    the Wear application may have the entrance to a data transfer capacity of just
    4 kilobytes for each second. Depending on wear, the accompanying steps are prescribed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当穿戴设备与蓝牙LE连接关联时，穿戴应用可能只能访问每秒4千字节的数据传输能力。根据穿戴设备的不同，建议采取以下步骤：
- en: Review your network requests and responses for additional information, that
    is for a phone application
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查你的网络请求和响应，以获取更多信息，这是针对手机应用的。
- en: Shrink huge pictures before sending them over a network to a watch
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过网络发送到手表之前缩小大图片
- en: Cloud messaging
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云消息传递
- en: For the tasks identified for notifications, applications can specifically use
    **Firebase Cloud Messaging** (**FCM**) in Wear applications; Google Cloud informing
    is not supported in wear 2.0.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通知任务，应用可以直接在手表应用中使用 **Firebase云消息传递** （**FCM**）；在2.0版本的手表中不支持Google云消息传递。
- en: 'There are no particular FCM APIs for wear applications; it takes after the
    comparative configuration for the mobile application notification: FCM functions
    admirably with wear and in doze mode. FCM is the recommended approach to send
    and receive notifications for wear devices.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的FCM API用于手表应用；它遵循与移动应用通知相似的配置：FCM与手表以及休眠模式下的工作良好。推荐使用FCM来发送和接收手表设备的通知。
- en: 'The procedure for receiving notifications from the server is that the application
    needs to send the device a unique Firebase `registration_id` to the server. The
    server can then distinguish the `FCM_REST` endpoint and can send the notification.
    An FCM message is in the JSON format and can incorporate either of the accompanying
    payloads:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器接收通知的过程是，应用需要将设备的唯一Firebase `registration_id` 发送到服务器。然后服务器可以识别 `FCM_REST`
    端点并发送通知。FCM消息采用JSON格式，并可以包含以下任一负载：
- en: '**Notification payload**: Generic notification data; when a notification reaches
    Wear, the application can check the notification and users can launch the application
    that received the notification.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知负载**：通用通知数据；当通知到达手表时，应用可以检查通知，用户可以启动接收通知的应用。'
- en: '**Data Payload**: The payload will have custom key-value sets. The payload
    will be conveyed as data to wear applications.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据负载**：负载将包含自定义的键值对。该负载将被作为数据传输给手表应用。'
- en: Wear applications incorporate many concerns when we are developing applications
    specific to wear devices, acquiring high-bandwidth networks and reducing the picture
    quality particular to wear benchmarks. What's more, UI outlines and keeping up
    background services, and so on. Having this at the top of the priority list when
    we create applications will make them stand out in the crowd.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发特定于手表设备的应用时，手表应用包含了许多关注点，比如获取高带宽网络和根据手表标准降低图片质量等。此外，还有UI设计和保持后台服务等。在开发应用时牢记这些，将使它们在众多应用中脱颖而出。
- en: Complications API
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂功能API
- en: Complications are surely just the same old thing for watches. The internet says
    the first pocket watch with complications was revealed in the sixteenth century.
    Smart watches are the ideal place for all the components that we consider for
    complications. In Android wear, the watch face shows more data than just the time
    and date, such as a step counter, climate forecast, and so on. How these complications
    have functioned so far has had a major constraint. until now, each custom watch
    face application needed to execute its own rationale to get information to show.
    For instance, if two watch faces had a comparative component to get step counts
    and show relevant information, then it would be an exercise in futility. Android
    Wear 2.0 intends to take care of this issue with the new Complications API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂功能对手表来说肯定不是什么新鲜事物。互联网上说，第一个带有复杂功能的怀表是在十六世纪被展示的。智能手表是我们考虑复杂功能组件的理想之地。在Android
    Wear中，手表表盘显示的不仅仅是时间和日期，还包括步数计数器、天气预报等。到目前为止，这些复杂功能的工作方式有一个主要限制。到目前为止，每个自定义手表表盘应用都需要执行自己的逻辑来获取显示信息。例如，如果两个表盘都有获取步数并显示相关信息的功能，那么这将是一种浪费。Android
    Wear 2.0旨在通过新的复杂功能API解决这个问题。
- en: In the event of complications, a watch face communication data provider assumes
    the principle part. It incorporates logic to get the information. The watch face
    won't have immediate access to the data provider; it will get callbacks when there
    is other data with the selected complications. On the other hand, data providers
    won't know how the data will be utilized; that is up to the watch face.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂功能的情况下，手表表盘通信数据提供者扮演着主要角色。它包含获取信息的逻辑。手表表盘不会直接访问数据提供者；当有选择复杂功能的其他数据时，它会得到回调。另一方面，数据提供者不会知道数据将如何被使用；这取决于手表表盘。
- en: 'The accompanying depiction discusses how watch faces get complications data
    from the data provider:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下列描述讨论了手表表盘如何从数据提供者获取复杂功能数据：
- en: '![](img/00134.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: Complication data provider
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂功能数据提供者
- en: 'The new complications API has immense potential; it has access to battery level,
    climate, step counts, and so on. The complication data provider, which is a service,
    extends `ComplicationProviderService`. This base class has a set of callbacks,
    keeping in mind the end goal, which is to know when a provider is chosen as a
    data source for the current watchface:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新的并发症API具有巨大的潜力；它可以访问电池电量、气候、步数等。并发症数据提供商是一个服务，扩展了 `ComplicationProviderService`。这个基类有一组回调，目的是为了知道提供商何时被选为当前表盘的数据源：
- en: '(`onComplicationActivated`): This callback method is called when complication
    is activated.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(`onComplicationActivated`): 当并发症被激活时，会调用此回调方法。'
- en: '(`onComplicationDeactivated`): This callback method is called when complication
    is deactivated.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(`onComplicationDeactivated`): 当并发症被停用时，会调用此回调方法。'
- en: '(`onComplicationUpdate`): This callback is called when the complication has
    updated information for the particular complication id.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(`onComplicationUpdate`): 当特定并发症ID的并发症更新信息时，会调用此回调。'
- en: 'The `ComplicationProviderService` class is an abstract class, which extends
    out to a service. A provider service must implement `onComplicationUpdate` (int,
    int and `ComplicationManager`) to respond to requests for updates from the complication
    system. The manifest declaration of this service must incorporate an intent filter
    for `ACTION_COMPLICATION_UPDATE_REQUEST`. Metadata to determine the supported
    types, refresh period, and config action, if required, ought to also be incorporated:
    (`METADATA_KEY_SUPPORTED_TYPES`, `METADATA_KEY_UPDATE_PERIOD_SECONDS`, and `METADATA_KEY_PROVIDER_CONFIG_ACTION`).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComplicationProviderService` 类是一个抽象类，扩展到了一个服务。提供商服务必须实现 `onComplicationUpdate`（整型，整型和
    `ComplicationManager`）以响应并发症系统对更新的请求。此服务的清单声明必须包含对 `ACTION_COMPLICATION_UPDATE_REQUEST`
    的意图过滤器。如果需要，还应该包含确定支持的类型、刷新周期和配置动作的元数据：(`METADATA_KEY_SUPPORTED_TYPES`, `METADATA_KEY_UPDATE_PERIOD_SECONDS`,
    和 `METADATA_KEY_PROVIDER_CONFIG_ACTION`)。'
- en: 'The manifest entry for the service ought to likewise incorporate an android:
    Icon attribute. The icon given there ought to be a single-color white icon that
    represents the provider. This icon will appear in the provider chooser interface,
    and may likewise be incorporated into `ComplicationProviderInfo`, given to watch
    faces to show in their configuration activities.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的清单条目还应包含一个 android:Icon 属性。那里给出的图标应该是一个单色的白色图标，代表提供商。此图标将出现在提供商选择器界面中，并且可能还会被包含在
    `ComplicationProviderInfo` 中，提供给表盘在它们的配置活动中显示。
- en: 'The accompanying code demonstrates a builder pattern of `ComplicationsData`
    to a short text type to populate `ComplicationData` with the date of the next
    event and an optional icon:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了使用 `ComplicationsData` 的构建器模式将 `ComplicationData` 填充为短文本类型，并带有下一个事件日期和可选图标：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding complications to a watch face
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向手表表盘添加并发症
- en: Android Wear 2.0 conveys numerous new components to your smartwatch. Yet, one
    of the more discernible is the expansion of adaptable *complications* on the watch
    face. Complications are a two-part system; watch face engineers can plan their
    watch faces to have open slots for complications, and application developers can
    surface parts of their applications to incorporate them as complications. The
    Wear watch face app can receive complication data and enable users to select the
    data providers. Android wear provides a user interface for data source. We can
    add complications, or data from applications, to some watch faces. Your wear 2.0
    has complications that demonstrate your battery life and the date, and that's
    just the beginning. You can also include complications from some third-party applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 2.0 为您的智能手表带来了许多新组件。然而，更引人注目的是在表盘上增加了可适应的*并发症*。并发症是一个两部分的系统；手表表盘工程师可以设计他们的表盘以拥有并发症的开放插槽，应用程序开发人员可以将应用程序的一部分作为并发症整合进来。手表表盘应用可以接收并发症数据，并允许用户选择数据提供商。Android
    Wear 提供了一个数据源的用户界面。我们可以向某些表盘添加并发症，或来自应用程序的数据。您的 Wear 2.0 表盘上的并发症可以显示电池寿命和日期，这只是开始。您还可以包含一些第三方应用程序的并发症。
- en: Receiving data and rendering complications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收数据和渲染并发症
- en: To begin receiving complication data, a watch face calls `setActiveComplications`
    in the `WatchFaceService.Engine` class with a list of watch face complication
    IDs. A watch face creates these IDs to remarkably identify slots on the watch
    face where complications can appear, and passes them to the `createProviderChooserIntent`
    method to enable the user to choose which complication ought to go in which slot.
    Complication data is conveyed by means of the `onComplicationDataUpdate` (of `WatchFaceService.Engine`)
    callback.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始接收并发症数据，表盘会在 `WatchFaceService.Engine` 类中调用 `setActiveComplications`，并传入表盘并发症
    ID 列表。表盘创建这些 ID 以便显著标识出并发症可以出现的位置，并将它们传递给 `createProviderChooserIntent` 方法，使用户能够选择哪个并发症应出现在哪个位置。并发症数据通过
    `onComplicationDataUpdate`（`WatchFaceService.Engine` 的回调）来传达。
- en: Allowing users to choose data providers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户选择数据提供商
- en: Android Wear gives a UI (through an activity) that enables users to pick providers
    for a specific complication. Watch faces can call the `createProviderChooserIntent`
    method to obtain an intent that can be used to demonstrate the chooser interface.
    This intent must be used with `startActivityForResult`. At the point when a watch
    face calls `createProviderChooserIntent`, the watch face supplies a watch face
    complication ID and a list of supported types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 提供了一个 UI（通过一个活动），使用户能够为特定并发症选择提供商。表盘可以调用 `createProviderChooserIntent`
    方法来获取一个可用于展示选择器界面的意图。这个意图必须与 `startActivityForResult` 一起使用。当表盘调用 `createProviderChooserIntent`
    时，表盘提供一个表盘并发症 ID 和支持的类型列表。
- en: User interactions with complications
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户与并发症的交互
- en: Providers can specify an action that occurs if the user taps on a complication,
    so it should be possible for most complications to be tap-able. This action will
    be specified as `PendingIntent`, included in the `ComplicationData` object. The
    watch face is responsible for detecting taps on complications and should fire
    the pending intent when a tap occurs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提供商可以指定用户点击并发症时发生的动作，因此大多数并发症应该是可以被点击的。这个动作将被指定为 `PendingIntent`，包含在 `ComplicationData`
    对象中。表盘负责检测并发症上的点击，并在点击发生时触发挂起意图。
- en: Permissions for complication data
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发数据权限
- en: 'The Wear app must have the following permission to receive the complications
    data and open the provider chooser:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 应用必须拥有以下权限才能接收并发症数据并打开提供商选择器：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Opening the provider chooser
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开提供商选择器
- en: 'A watch face that has not been granted the preceding permission will be unable
    to start the provider chooser. To make it easier to request the permission and
    start the chooser, the `ComplicationHelperActivity` class is available in the
    Wearable Support Library. This class should be used instead of `ProviderChooserIntent`
    to start the chooser in almost all cases. To use `ComplicationHelperActivity`,
    add it to the watch face in the manifest file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表盘没有获得前面的权限，将无法启动提供商选择器。为了更容易请求权限并启动选择器，Wearable Support Library 提供了 `ComplicationHelperActivity`
    类。在几乎所有情况下，应使用此类别代替 `ProviderChooserIntent` 来启动选择器。要使用 `ComplicationHelperActivity`，请在清单文件中将它添加到表盘：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To start the provider chooser, call the `ComplicationHelperActivity.createProviderChooserHelperIntent`
    method to obtain an intent. The new intent can be used with either `startActivity`
    or `startActivityForResult` to launch the chooser:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动提供商选择器，请调用 `ComplicationHelperActivity.createProviderChooserHelperIntent`
    方法来获取意图。新的意图可以与 `startActivity` 或 `startActivityForResult` 一起使用来启动选择器：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the helper activity is started, the helper activity checks whether the
    permission was granted. If the permission was not granted, the helper activity
    makes a runtime permission request. If the permission request is accepted (or
    is unneeded), the provider chooser is shown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当帮助活动启动时，它会检查权限是否已授予。如果未授予权限，帮助活动会提出运行时权限请求。如果权限请求被接受（或不必要），则会显示提供商选择器。
- en: For watch face, there are many scenarios to be considered. Check all of them
    before you implement the complications in your watch face. How are you receiving
    complication data? Is it from the provider, remote server, or the rest service?
    Are the provider and watch face from the same app? You should also check for a
    lack of appropriate permissions and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表盘来说，有许多场景需要考虑。在您的表盘实现并发症之前，请检查所有这些场景。您是如何接收并发症数据的？是来自提供商、远程服务器还是 REST 服务？提供商和表盘是否来自同一个应用？您还应该检查是否缺少适当的权限等。
- en: Understanding different navigation for wear
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Wear 的不同导航方式
- en: 'Android wear is evolving in every way. In wear 1.0, switching between screens
    used to be tedious and confusing to wear users. Now, Google has introduced material
    design and interactive drawers, such as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓穿戴在各个方面都在演进。在穿戴1.0中，屏幕之间的切换曾经让用户感到繁琐和困惑。现在，谷歌引入了材料设计和交互式抽屉，例如：
- en: '**Navigation drawer**: The navigation drawer is a similar component to the
    mobile app navigation drawer. It will allow the user to switch between views.
    Users can reach to the navigation drawer on a Wear device by going to the top
    of the content area and scrolling down from the flings. We can allow the drawer
    to be opened anywhere within the scrolling parent''s content by setting the `setShouldOnlyOpenWhenAtTop()`
    method to false and we can restrict it by setting it to true.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航抽屉**：导航抽屉与移动应用导航抽屉类似的组件。它将允许用户在视图之间切换。用户可以通过在内容区域的顶部向下轻扫来在穿戴设备上访问导航抽屉。我们可以通过将`setShouldOnlyOpenWhenAtTop()`方法设置为false，允许在滚动父内容内的任何位置打开抽屉，并且可以通过设置为true来限制它。'
- en: '**Single page navigation drawer**: A wear app can present the views to users
    on a single page and multiple pages. The new navigation drawer component allows
    content to be on a single page by setting `app:navigation_style to single_page`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页导航抽屉**：穿戴应用可以在单页和多页上向用户展示视图。新的导航抽屉组件通过将`app:navigation_style`设置为`single_page`，允许内容保持在单页上。'
- en: '**Action drawer**: There are common actions that every category of apps does.
    Action drawer provides an access to all such actions in a wear application. Usually,
    action drawer sits in the bottom area of the wear app and it will help to offer
    context-specific user actions, similar to the action bar on a phone application.
    It''s the developer''s choice to have the action drawer positioned at the bottom
    or top, and the action drawer can be triggered when a user is scrolling content.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作抽屉**：有一些每个类别应用都会进行的通用操作。操作抽屉为穿戴应用提供了访问所有这些操作的途径。通常，操作抽屉位于穿戴应用的底部区域，它可以帮助提供与手机应用中的操作栏类似的上下文相关用户操作。开发者可以选择将操作抽屉定位在底部或顶部，并且当用户滚动内容时可以触发操作抽屉。'
- en: 'The following image is a quick look of the navigation drawer for wear 2.0:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是穿戴2.0导航抽屉的快速预览：
- en: '![](img/00135.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: 'The following example illustrates the action reply performed in the messenger
    app using action:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了在消息应用中使用操作执行的动作回复：
- en: '![](img/00136.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: Implementation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: To have the newly introduced components in your app, declare your user interface
    with a `WearableDrawerLayout` object as the root view of your layout. Within `WearableDrawerLayout`,
    add one more view that implements `NestedScrollingChild` to contain the main content,
    as well as additional views to contain content for the drawer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用中使用新引入的组件，请使用`WearableDrawerLayout`对象作为您布局的根视图来声明用户界面。在`WearableDrawerLayout`内，添加一个实现`NestedScrollingChild`的视图来包含主要内容，以及额外的视图来包含抽屉的内容。
- en: 'The following XML code illustrates the way in which we can bring life to `WearableDrawerLayout`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的XML代码展示了我们如何为`WearableDrawerLayout`赋予生命：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Single-page navigation drawer
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页导航抽屉
- en: 'A single-page navigation drawer is faster and more streamlined to different
    views in the Wear app. To create a single page navigation drawer, apply the attribute
    `navigation_style="single_page"` to the drawer. For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单页导航抽屉在穿戴应用中更快、更流畅地切换不同视图。要创建单页导航抽屉，请在抽屉上应用`navigation_style="single_page"`属性。例如：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, the next major thing is to populate the data on drawer layout. We can do
    it in the XML layout with the help of the `app:using_menu` attribute in the drawer
    layout and by loading the XML file from the menu directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个主要任务是填充抽屉布局上的数据。我们可以在XML布局中通过抽屉布局的`app:using_menu`属性以及从菜单目录加载XML文件来完成这个任务。
- en: 'Using `WearableDrawerView`, we can design our own custom drawer layout. The
    following code illustrates the custom drawer layout:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WearableDrawerView`，我们可以设计自己的自定义抽屉布局。下面的代码展示了自定义抽屉布局：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are major drawer events, such as `onDrawerOpened()`, `onDrawerClosed()`,
    and `onDrawerStateChanged()`. We can create custom events as well; by default,
    we can use the earlier set of callbacks to listen to drawer activities.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有主要的抽屉事件，如`onDrawerOpened()`、`onDrawerClosed()`和`onDrawerStateChanged()`。我们也可以创建自定义事件；默认情况下，我们可以使用早期的一组回调来监听抽屉活动。
- en: Notifications in wear 2.0
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 穿戴2.0的通知
- en: Wear 2.0 updates the visual style and interaction paradigm of notifications.
    Wear 2.0 introduces expandable notifications, which provide more content area
    and actions to give the best experience. The visual updates include material design,
    touch targets of notifications, dark background colors, and a horizontal swipe
    gesture for notifications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0更新了通知的视觉风格和交互范式。Wear 2.0引入了可扩展通知，提供了更多内容区域和动作，以提供最佳体验。视觉更新包括材料设计、通知的触摸目标、深色背景以及通知的水平滑动手势。
- en: Inline action
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联动作
- en: Inline action allows users to perform context-specific actions inside the notification
    stream card. If the notification is configured for inline action, it will display
    at the bottom section of notifications. Inline actions are optional; Google recommends
    it for different use cases wherein a user has to perform a certain action after
    checking the notification, for example, text message reply and stopping fitness
    activity. A notification can have only one inline action and, to enable it, we
    need to set `setHintDisplayActionInline()` to true.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 内联动作允许用户在通知流卡片内执行特定于上下文的操作。如果通知配置了内联动作，它将显示在通知的底部区域。内联动作是可选的；谷歌推荐在不同使用场景中使用，例如用户在查看通知后需要执行某个操作，如短信回复和停止健身活动。通知只能有一个内联动作，要启用它，我们需要将`setHintDisplayActionInline()`设置为true。
- en: 'To add inline actions to notifications, perform the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要向通知添加内联动作，请执行以下步骤：
- en: 'Create an instance of `RemoteInput.Builder` as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式创建一个`RemoteInput.Builder`的实例：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the `addRemoteInput()` method, we can attach the `RemoteInput` object:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`addRemoteInput()`方法，我们可以附加`RemoteInput`对象：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add a hint to display action inline, and use add action method to
    the action to the notification:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个提示以显示内联动作，并使用添加动作方法将动作添加到通知中：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Expanded notifications
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展通知
- en: Wear 2.0 introduces expandable notifications, which have the ability to show
    substantial content and actions for each notification. Expanded notifications
    follow the material design standards, and when we attach additional content pages
    to the notification, they are available within the expanded notifications and
    the user will have an in-app experience while checking the actions and content
    in the notifications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0引入了可扩展通知，能够为每个通知显示大量内容和动作。扩展通知遵循材料设计标准，当我们向通知附加额外内容页面时，它们将在扩展通知内可用，用户在检查通知中的动作和内容时将获得应用内体验。
- en: Best practices for expanded notifications
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展通知的最佳实践
- en: 'When to use the expanded notifications:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用扩展通知：
- en: The notifications from the paired phone should use expanded notifications.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配对手机的通知应使用扩展通知。
- en: We should not use expanded notifications when the app notification is running
    locally and just launches the app by clicking on it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用通知在本地运行且仅通过点击启动应用时，我们不应使用扩展通知。
- en: Bridging mode for notifications
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知的桥接模式
- en: Bridging mode alludes to the system that wear and the companion application
    share the notification among themselves. The standalone application and companion
    application can get copied notifications. Android wear incorporates components
    to deal with the issue of copy notifications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式指的是穿戴设备和伴随应用之间共享通知的系统。独立应用和伴随应用可以获得复制通知。Android穿戴整合了处理复制通知问题的组件。
- en: 'Developers can alter the behavior of notifications as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以如下更改通知的行为：
- en: Specifying a bridging configuration in the manifest file
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清单文件中指定桥接配置
- en: Specifying a bridging configuration at runtime
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时指定桥接配置
- en: Setting a dismissal ID so notification dismissals are synced across devices
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个消除ID，以便通知消除在设备间同步
- en: 'Bridging configuration in manifest file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中的桥接配置：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Bridging configuration at runtime (uses the `BridgingManager` class):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时进行桥接配置（使用`BridgingManager`类）：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using dismissal ID to sync notification dismissals:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消除ID同步通知消除：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notification is an important component to draw the attention of users to use
    your app in wear devices. Android Wear 2.0 offers more, and will continue to offer
    more, smart replies in notifications, messaging style, and more.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是吸引用户在穿戴设备上使用应用的重要组件。Android Wear 2.0提供了更多智能回复、消息样式等，并将继续提供更多功能。
- en: Wear 2.0 input method framework
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wear 2.0输入方法框架
- en: We have seen the wear input mechanism in the apps we built in previous chapters.
    Wear 2.0 supports input methods beyond voice by extending the Android **Input
    Method Framework** (**IMF**) to Android Wear. IMF allows for virtual, onscreen
    keyboards and other input methods to be used for text entry. The IMF APIs used
    for wear devices are the same as other form factors, though the usage is slightly
    different due to the limited screen size. Wear 2.0 comes with the system default
    **Input Method Editor** (**IME**) and opens up the IMF APIs for third-party developers
    to create custom input methods for Wear.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中构建的应用程序中已经看到了穿戴设备的输入机制。Wear 2.0 通过将 Android 的**输入法框架**（**IMF**）扩展到
    Android Wear，支持除语音之外的其他输入方式。IMF 允许使用虚拟的、屏幕上的键盘和其他输入方法进行文本输入。尽管由于屏幕尺寸的限制，使用方式略有不同，但用于穿戴设备的
    IMF API 与其他设备形态的 API 是相同的。Wear 2.0 带来了系统默认的**输入法编辑器**（**IME**），并为第三方开发者开放了 IMF
    API，以便为 Wear 创建自定义输入方法。
- en: Invoking input method for wear
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用穿戴设备的 IMF
- en: 'To invoke the IMF for wear, your API level should be 23 or higher on the platform.
    In Android Wear apps that contain an EditText fields: Touching a text field places
    the cursor in the field and automatically displays the IMF on focus.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用穿戴设备的 IMF，您的平台 API 级别应为 23 或更高。在包含 EditText 字段的 Android Wear 应用中：触摸文本字段会将光标置于该字段，并在获得焦点时自动显示
    IMF。
- en: Wrist gestures
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手腕手势
- en: 'Wear 2.0 supports wrist gestures. When you cannot use the touch screen of your
    wear device, you can utilize the wrist gestures for quick, one-handed interaction,
    for example, when a user is jogging and he wants to perform a certain context-specific
    operation using a wrist gesture. There are few gestures that are not available
    for apps, such as push wrist down, raise wrist up, and shaking wrist. Every wrist
    gesture is mapped to an integer constant from the key event class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0 支持手腕手势。当您无法使用穿戴设备的触摸屏时，可以利用手腕手势进行快速的单手操作，例如，当用户在慢跑时，他想要使用手腕手势执行特定上下文的操作。有一些手势不适用于应用，例如，按下手腕、抬起手腕和摇动手腕。每个手腕手势都映射到按键事件类中的一个整型常量：
- en: '| Gesture | KeyEvent | Description |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 手势 | KeyEvent | 描述 |'
- en: '| Flick wrist out | `KEYCODE_NAVIGATE_NEXT` | This key code goes to the next
    item. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 向外挥动手腕 | `KEYCODE_NAVIGATE_NEXT` | 此按键代码跳转到下一个项目。 |'
- en: '| Flick wrist in | `KEYCODE_NAVIGATE_PREVIOUS` | This key code goes to the
    previous item. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 向内挥动手腕 | `KEYCODE_NAVIGATE_PREVIOUS` | 此按键代码返回上一个项目。 |'
- en: Best practices for using gestures in apps
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用中手势的最佳实践
- en: 'Following are the best practices for using gestures in apps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用应用中手势的最佳实践：
- en: Review the `KeyEvent` and `KeyEvent.Callback` pages for the delivery of key
    events to your view
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅 `KeyEvent` 和 `KeyEvent.Callback` 页面，了解将按键事件传递到您的视图的相关信息
- en: Have a touch parallel for a gesture
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为手势提供触摸平行支持
- en: Provide visual feedback
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供视觉反馈
- en: Don't reinterpret repeated flick gestures into your own new gesture. It may
    conflict with the system's *Shaking the wrist* gesture.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将重复的手势重新解释为您的自定义新手势。它可能与系统的*摇动手腕*手势发生冲突。
- en: Use `requestFocus()` and `clearFocus()` carefully
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小心使用 `requestFocus()` 和 `clearFocus()`。
- en: Authentication protocols
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证协议
- en: 'With standalone watches in place, wear apps can now run entirely on a watch
    without a companion app. This new capability also means that Android Wear standalone
    apps will need to manage authentication on their own when the apps need to access
    data from the cloud. Android Wear supports several authentication methods to enable
    standalone wear apps to obtain user authentication credentials. Now, wear supports
    the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着独立手表的出现，穿戴应用现在可以在不依赖伴随应用的情况下完全在手表上运行。这一新功能也意味着，当应用需要从云端访问数据时，Android Wear
    独立应用需要自行管理认证。Android Wear 支持多种认证方法，以使独立穿戴应用能够获取用户认证凭据。现在，穿戴支持以下功能：
- en: Google sign-in
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 登录
- en: OAuth 2.0 support
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0 支持
- en: Pass tokens via data layer
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数据层传递令牌
- en: Custom code authentication
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义代码认证
- en: All these protocols follow the same standard as mobile app programming; no big
    changes in integrating Google sign-in in wear or other protocols, but these protocols
    help in authorizing users.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些协议遵循与移动应用编程相同的标准；在穿戴设备上集成 Google 登录或其他协议时没有大的变化，但这些协议有助于授权用户。
- en: App distribution
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用分发
- en: We now know how to develop applications for wear 2.0 and, in our past experience,
    we might have published an Android app to the Play store. What does it take to
    publish a standalone wear application, or a general wear application, to the Play
    store through the Google developer console?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何为Wear 2.0开发应用，并且在过去的经验中，我们可能已经将一个Android应用发布到了Play商店。那么，通过谷歌开发者控制台将一个独立的可穿戴应用或一般的可穿戴应用发布到Play商店需要什么呢？
- en: Wear 2.0 bundles the Play Store app; users can search for wear-specific apps
    and can install them directly on Wear devices when they are connected to the Internet.
    Generally, wear 2.0 apps in the Play store need a minimum and target an API level
    of 25 or higher in the manifest file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0捆绑了Play商店应用；用户可以搜索特定的可穿戴应用，并在连接到互联网时直接在可穿戴设备上安装它们。通常，Play商店中的Wear 2.0应用需要在清单文件中至少和目标API级别25或更高。
- en: Publish your first wear app
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你的第一款可穿戴应用
- en: To make your app appear in the on-watch Play Store, generate a signed wear apk.
    Publishing the app will be similar to publishing a mobile app if it's a wear standalone
    app. If it is not a standalone and you need to upload a multiple apk, then follow
    [https://developer.android.com/google/play/publishing/multiple-apks.html](https://developer.android.com/google/play/publishing/multiple-apks.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要让你的应用在手表上的Play商店中显示，请生成一个已签名的可穿戴APK。如果这是一个独立的可穿戴应用，发布应用的过程将类似于发布移动应用。如果不是独立应用，且需要上传多个APK，请遵循[https://developer.android.com/google/play/publishing/multiple-apks.html](https://developer.android.com/google/play/publishing/multiple-apks.html)。
- en: Let's publish the Wear-Note app in the Play store. It is Google's dedicated
    dashboard for developers that lets you manage your apps in the Play store. Google
    has a one-time $25 registration fee, which you need to pay before you can upload
    an app. The reason behind the fee is to keep out fake, duplicate accounts and,
    hence, keep out unnecessary and poor apps flooding the Play Store.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Play商店中发布Wear-Note应用。这是谷歌为开发者提供的专用仪表板，让你可以管理Play商店中的应用。谷歌有一次性的25美元注册费用，你需要在上传应用之前支付。收取费用的原因是防止虚假、重复账户，从而避免不必要的低质量应用充斥Play商店。
- en: 'Following steps illustrates the story of how we can publish our wear application
    to playstore:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了我们如何将可穿戴应用发布到Play商店的过程：
- en: 'Visit [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/):'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://play.google.com/apps/publish/](https://play.google.com/apps/publish/)：
- en: '![](img/00137.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00137.jpeg)'
- en: Click on Create application and give your app a title.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建应用并为你的应用起一个标题。
- en: Thereafter, you will be shown a form to fill in the description and other details,
    which include screenshots of the app and icons and promo graphics.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你将看到一个表格，需要填写描述和其他详细信息，包括应用的屏幕截图和图标以及促销图形。
- en: In store listing, fill in all the correct information about the app.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在商店列表中，填写有关应用的所有正确信息。
- en: Now, upload the signed wear apk.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，上传已签名的可穿戴APK。
- en: Answer the questionnaire for content ratings, get a rating, and apply the rating
    to your app.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写内容评级问卷，获得评级，并将评级应用到你的应用中。
- en: In pricing and distribution, you need to have a merchant account to distribute
    your app in the pricing model. Now, wear note app is a free the Wear app and it
    lets you select free.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定价和分发方面，你需要拥有一个商家账户才能在定价模式下分发你的应用。现在，可穿戴笔记应用是一款免费的Wear应用，并允许你选择免费。
- en: 'Select all the countries on the list and choose wear device apk:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择列表中的所有国家并选择可穿戴设备APK：
- en: '![](img/00138.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00138.jpeg)'
- en: Google will review the wear binary and approve to distribute it in the Wear
    Play store when it is ready.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谷歌将审查可穿戴应用的二进制文件，并在准备好后批准其在Wear Play商店中分发。
- en: 'Congratulations! Now, your app is ready to be published:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜你！现在，你的应用已经准备好发布了：
- en: '![](img/00139.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00139.jpeg)'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have understood standalone applications and the Complications
    API. We have seen how to detect companion apps using Capability API, and we have
    a clear idea of standalone applications and publishing a wear app too.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了独立应用程序和Complications API。我们看到了如何使用Capability API检测伴随应用，并且对独立应用程序以及发布可穿戴应用有了清晰的认识。
- en: This chapter examined how we can reinforce the comprehension of wear 2.0 and
    its components, along with an exhaustive understanding of standalone apps, curved
    layouts and more UI components, and building Wear applications with navigation
    drawers and action drawers. It also offered a brief understanding of wrist gestures
    and using them in wear applications, using the input method framework, and distributing
    the wear application to the Google Play Store.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节探讨了如何加强我们对 Wear 2.0 及其组件的理解，包括对独立应用、曲线布局以及更多用户界面组件的详尽了解，以及使用导航抽屉和操作抽屉构建可穿戴应用。同时，本章还提供了关于手腕手势及其在可穿戴应用中的使用、输入法框架的使用，以及将可穿戴应用分发到
    Google Play 商店的简要了解。
