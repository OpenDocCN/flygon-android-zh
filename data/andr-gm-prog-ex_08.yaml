- en: Chapter 8. Platformer – Putting It All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章. 平台游戏——整合所有功能
- en: Finally, we will make the bullets do some damage. The ricochet sound is very
    satisfying when the bullets energy is absorbed by a clump of grass. We will add
    an abundance of new platform types and inanimate scenery objects to make our levels
    more interesting. We will provide a real sense of motion and immersion by implementing
    multiple scrolling parallax backgrounds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将让子弹造成一些伤害。当子弹的能量被一团草地吸收时，这种反弹声非常令人满意。我们将添加大量的新平台类型和非动画场景对象，使我们的关卡更有趣。通过实现多个滚动视差背景，我们将提供一种真正的运动感和沉浸感。
- en: We will also add an animated fire tile for the player to avoid, and in addition,
    a special `Teleport` class to link levels together into one playable game. Then,
    we will use all of our game objects and backgrounds to create four, linked, and
    fully playable levels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个动画火焰瓦片，让玩家避开，此外，还会添加一个特殊的`Teleport`类，将各个关卡连接成一个可玩的游戏。然后，我们将使用所有的游戏对象和背景创建四个连接、完全可玩的游戏关卡。
- en: Then, we will add a HUD to keep track of pickups and lives. Finally, we will
    discuss some of the neat things that couldn't be fitted into this project in just
    four chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个HUD来跟踪拾取物和生命值。最后，我们将讨论一些无法在这四章中容纳的精彩内容。
- en: Bullet collision detection
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子弹碰撞检测
- en: Detecting bullet collisions is fairly straightforward. We loop through all the
    existing `Bullet` objects held by our `MachineGun` object. Next, we convert the
    points of each bullet into a `RectHitBox` object and test it using `intersects()`
    against each object in our viewport.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 检测子弹碰撞相当直接。我们遍历由我们的`MachineGun`对象持有的所有现有`Bullet`对象。接下来，我们将每个子弹的点转换成`RectHitBox`对象，并使用`intersects()`方法测试我们的视口中的每个对象。
- en: If we get a hit, we check to see what type of object it has hit. We then switch
    to handle each type of object that we care about. If it is a `Guard` object, we
    knock it back a bit, if it is a `Drone` object, we destroy it, and if it is anything
    else, we just make the bullet disappear and play a kind of thudding/ricochet sound.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们受到攻击，我们会检查它击中的对象类型。然后，我们会切换到处理我们关心的每种类型的对象。如果是`Guard`对象，我们将其稍微击退一点；如果是`Drone`对象，我们将其销毁；如果是其他任何对象，我们只需让子弹消失，并播放一种沉闷的/反弹声。
- en: 'We simply place this logic we discussed after our `switch` block that handles
    collisions with the player, but before, we call `update()` on all our unclipped
    objects as shown next:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在我们处理玩家碰撞的`switch`块之后，但在我们调用所有未剪辑对象的`update()`之前，放置我们讨论过的这个逻辑，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Try it out, it is really satisfying, especially with a high rate of fire.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，尤其是高射速时，这真的很令人满意。
- en: Adding some fire tiles
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些火焰瓦片
- en: These new `GameObject` derived objects will mean instant death to Bob. They
    won't move, but they will be animated. We will see we can achieve this just by
    setting the already existing properties of `GameObject`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的基于`GameObject`的对象将对Bob造成即死的效果。它们不会移动，但它们将被动画化。我们将看到，只需设置`GameObject`已有的属性，我们就可以实现这一点。
- en: Adding this feature into our game is simple because we have already implemented
    all the features we need. We already have a way to locate and add new tiles, a
    way to detect and respond to a collision, sprite sheet animation, and so on. Let's
    do it step-by-step, then we can add these dangerous and life-threatening elements
    into our world.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个功能添加到我们的游戏中非常简单，因为我们已经实现了所需的所有功能。我们已经有了定位和添加新瓦片的方法，检测并响应碰撞的方法，精灵图动画等等。让我们一步步进行，然后我们就可以将这些危险且致命的元素添加到我们的世界中。
- en: We can put the entire functionality of the class into its constructor. All we
    do is configure the object much like we did our `Grass` object, but in addition,
    we configure it with all the animation settings, like we did to the `Player` and
    `Guard` objects. The `fire.png` sprite sheet has three frames of animation that
    we want to play over the course of one second.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类的所有功能都放入其构造函数中。我们所要做的就是像配置`Grass`对象那样配置这个对象，此外，我们还要为其配置所有动画设置，就像我们对`Player`和`Guard`对象所做的那样。`fire.png`精灵图有三种动画帧，我们希望在一秒钟内播放它们。
- en: '![Adding some fire tiles](img/B04322_08_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些火焰瓦片](img/B04322_08_01.jpg)'
- en: 'Create a new class, call it `Fire`, and add the following code to it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，将其命名为`Fire`，并向其中添加以下代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, of course, we need to add the `fire.png` sprite sheet from `Chapter8/drawable`
    in the download bundle to the `drawable` folder of the project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，我们需要将下载包中`Chapter8/drawable`目录下的`fire.png`精灵图添加到项目的`drawable`文件夹中。
- en: Then, we add to our `LevelManager` class, in the usual three ways that we have
    done for all our new `GameObject` derived classes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照为所有新的`GameObject`派生类所做的方式，以通常的三种方法将它们添加到我们的`LevelManager`类中。
- en: 'In the `getBitmap` method, add the highlighted code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap`方法中，添加突出显示的代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `getBitmapIndex` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmapIndex`方法中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `loadMapData()` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadMapData()`方法中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we add to our collision detection `switch` block to handle the consequences
    of touching this terrible tile.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在碰撞检测的`switch`块中添加处理触碰这个可怕瓦片的后果。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why not add a few `f` tiles to `LevelCave` and experiment with what the player
    is able to jump over. It will help us design some challenging levels later in
    the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不如在`LevelCave`中添加一些`f`瓦片，并实验玩家能够跳跃过哪些。这将帮助我们在本章后面设计一些具有挑战性的关卡。
- en: '![Adding some fire tiles](img/B04322_08_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些火焰瓦片](img/B04322_08_02.jpg)'
- en: We don't want our player to be walking on the grass the whole time, so let's
    add some more variety.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望玩家一直走在草地上，所以让我们添加一些多样性。
- en: Eye candy
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 眼前一亮
- en: The next three sections in this chapter will be purely aesthetic. We will add
    a whole bunch of different tile graphics with matching classes so that we can
    use a whole lot more artistic license to make our levels more interesting. The
    difference between the tiles will be purely visual, but it will be fairly simple
    to make them more functional than that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的三个部分将纯粹关注外观。我们将添加一整套不同的瓦片图像和匹配的类，这样我们可以使用更多的艺术许可来使我们的关卡更有趣。这些瓦片之间的区别将纯粹是视觉上的，但使它们具有比这更多的功能性将相当简单。
- en: For example, we can easily detect collision with a snow tile and have the player
    keep moving briefly after stopping to simulate skidding, or perhaps; the concrete
    tile can allow the player to move faster and therefore change the way we design
    big jumps and so on. The point is that you don't have to just copy paste the classes
    as they will be presented here.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以轻松检测与雪瓦片的碰撞，并让玩家在短暂停止后继续移动以模拟滑行，或者；混凝土瓦片可以让玩家移动得更快，因此改变我们设计大跳跃的方式等等。重点是，你不必仅仅复制粘贴这里呈现的类。
- en: 'We will also add some completely aesthetic props: mine carts, boulders, stalactites,
    and more. There will be no collision detection for these objects. They will allow
    the level designer to make the levels more visually interesting.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些完全为了美观的道具：矿车、巨石、石钟乳石等。这些对象不会有碰撞检测。它们将允许关卡设计师使关卡在视觉上更有趣。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It would be simple to make these aesthetics more functional. Just add a hitbox
    and a case in the collision detection switch block to handle the consequences.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些美观元素更具功能性很简单。只需添加一个碰撞箱并在碰撞检测`switch`块中添加一个案例来处理后果。
- en: Probably, the most visually significant improvement we add, will be scrolling
    backgrounds. We will add some classes to allow the level designer to add multiple
    different scrolling backgrounds to a level design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，我们添加的视觉上最重要的改进将是滚动背景。我们将添加一些类，允许关卡设计师向关卡设计中添加多个不同的滚动背景。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Why not add all the graphics from the `Chapter8/drawable` folder of the download
    bundle to the `drawable` folder of your project. Then, you will have all the graphics
    ready and in place, for this and the next two sections as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不妨将下载包中`Chapter8/drawable`文件夹的所有图像添加到项目的`drawable`文件夹中。这样，你将拥有所有图形，包括本节和接下来两节的图形都准备好了。
- en: The new platform tiles
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的平台瓦片
- en: 'Now, add all these classes with the filenames as shown. I have removed all
    comments from the code because they are all functionally the same as the `Grass`
    class. Create each of the following classes with the name shown and enter the
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照显示的文件名添加所有这些类。我移除了代码中的所有注释，因为它们在功能上都与`Grass`类相同。按照显示的名称创建以下每个类，并输入代码：
- en: 'Here is the code for the `Brick` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Brick`类的代码：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the code for the `Coal` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Coal`类的代码：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the code for the `Concrete` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Concrete`类的代码：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the code for the `Scorched` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Scorched`类的代码：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the code for the `Snow` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Snow`类的代码：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the code for the `Stone` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Stone`类的代码：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, as we are getting used to, we need to add them all into our `LevelManager`
    in the usual three places.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像我们习惯的那样，我们需要将它们全部添加到我们的`LevelManager`中，在通常的三个地方。
- en: In `getBitmap()`, we simply add them in as normal. Note that although the values
    are arbitrary, we will use numbers for the type 2,3,4, and so on. This makes it
    easy to remember, while designing levels, that all our actual platforms are numbers.
    The actual index numbers are unimportant to us, as long as they are the same as
    in the `getBitmapIndex` method. Also, remember that we have a list of types in
    our `LevelData` class's comments, for easy reference when designing levels.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap()`方法中，我们像平常一样将它们添加进去。请注意，尽管这些值是任意的，但我们将为类型2、3、4等使用数字。这样在设计关卡时容易记住，我们所有的实际平台都是数字。实际的索引编号对我们来说不重要，只要它们与`getBitmapIndex`方法中的相同即可。此外，记住我们在`LevelData`类的注释中有一个类型列表，以便在设计关卡时方便参考。
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `getBitmapIndex()`, we do the same thing:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmapIndex()`中，我们做同样的事情：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In `loadMapData()`, we just call `new()` on our new `GameObjects` to add them
    to our `gameObjects` list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadMapData()`中，我们只需在我们的新`GameObjects`上调用`new()`，将它们添加到`gameObjects`列表中。
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, go wild adding different terrains to the `LevelCave` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大胆地为`LevelCave`类添加不同的地形：
- en: '![The new platform tiles](img/B04322_08_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![新的平台瓦片](img/B04322_08_03.jpg)'
- en: Now, to add some scenery objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来添加一些景观对象。
- en: The new scenery objects
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的景观对象
- en: Here, we will add some objects that don't do anything but look pretty. We will
    let the game engine know by simply not adding a hitbox and setting them randomly
    to either z layer -1, or 1\. Then the player can appear either in front or behind
    them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们会添加一些除了看起来漂亮之外什么都不做的对象。我们只需不添加碰撞箱，并将它们随机设置为z层-1或1，让游戏引擎知道这一点。然后玩家可以出现在它们前面或后面。
- en: 'We will first add all the classes, and then update `LevelManager` in the usual
    three places. Create each of the new classes as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先会添加所有类，然后像往常一样更新`LevelManager`的三个地方。按照以下方式创建每个新类：
- en: 'Here is the `Boulders` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Boulders`类：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From now on, I removed all the comments to save digital ink. The class functionality
    is the same as it is in `Boulders`, just the attributes vary a bit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我删除了所有注释以节省墨水。该类的功能与`Boulders`中的相同，只是属性有些许不同。
- en: 'Here is the `Cart` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Cart`类：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the code for the `Lampost` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Lampost`类的代码：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the `Stalagmite` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Stalagmite`类：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the `Stalactite` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Stalactite`类：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the `Tree` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Tree`类：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And this is the `Tree2` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Tree2`类：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's all the new classes for the scenery objects. Now, we can update the `getBitmap`
    method with the seven new types in the `LevelManager` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有新的景观对象类。现在，我们可以在`LevelManager`类中用七种新类型更新`getBitmap`方法。
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the `getBitmapIndex` method in the same way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式更新`getBitmapIndex`方法：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, make sure our new scenery items are added to our `gameObjects` array
    list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保我们的新景观物品被添加到`gameObjects`数组列表中：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can design levels with scenery. Note the slight difference in appearance
    when an object is drawn on layer zero compared to layer one and how the player
    character passes either in front or behind:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设计带有景观的关卡。注意当对象在层零与层一上绘制时外观上的细微差别，以及玩家角色如何穿过它们前面或后面：
- en: '![The new scenery objects](img/B04322_08_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![新的景观对象](img/B04322_08_04.jpg)'
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, if you want to bump into lamposts, get skewered by stalagmites, or
    jump on top of mine carts, then just give them a hitbox.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想要碰撞到路灯、被石笋刺穿，或者跳到矿车顶上，只需给它们一个碰撞箱即可。
- en: We have one more way to beautify our game world.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一种美化游戏世界的方法。
- en: Scrolling parallax backgrounds
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动的视差背景
- en: Parallax backgrounds are scrolling backgrounds, where we scroll them slower
    the farther away they are. So, if we have a grass verge at the player's feet,
    we will scroll it quickly. However, if we have a mountain range in the distance,
    we will scroll it slowly. This effect can give the sense of motion to the player.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 视差背景是滚动的背景，我们根据它们距离的远近来减慢滚动速度。因此，如果玩家脚边有草地，我们会快速滚动它。然而，如果远处有山脉，我们会慢慢滚动它。这种效果可以给玩家带来运动的感觉。
- en: To implement them, we will first add a data structure to represent the parameters
    of a background. We will call this class `BackgroundData`, we will then implement
    a `Background` class, which has the functionality necessary to control the scrolling
    and then we will see how to position and define backgrounds in our level design.
    Finally, we will write a `drawBackground` method that we will call from our regular
    `draw` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能，我们首先将添加一个数据结构来表示背景的参数。我们将这个类称为`BackgroundData`，然后实现一个`Background`类，它具有控制滚动所需的功能，然后我们将会看到如何在我们的关卡设计中定位和定义背景。最后，我们将编写一个`drawBackground`方法，我们将会从常规的`draw`方法中调用它。
- en: Make sure you added all the graphics from the `Chapter8/drawable` folder of
    the download bundle to the `drawable` folder of your project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经将从下载包的`Chapter8/drawable`文件夹中的所有图像添加到你的项目的`drawable`文件夹中。
- en: First, let's build a simple class to hold the data structure which will define
    our backgrounds. As we can see in the next block of code, we have quite a large
    number of parameters and member variables. We will need to know which bitmap will
    represent a background, which layer on the *z* axis to draw it (in front on 1
    or behind on -1), where in the world on the *y* axis it starts and finishes, how
    fast the background will scroll, and how high the background will be.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个简单的类来保存定义我们背景的数据结构。正如在下一个代码块中我们可以看到的，我们有很多参数和成员变量。我们需要知道哪个位图将代表背景，在*z*轴上哪个层面绘制它（前面为1，后面为-1），在*y*轴上它在全球的哪个位置开始和结束，背景滚动的速度有多快，以及背景的高度是多少。
- en: The `isParallax` Boolean is intended to give the option to have a background
    which is static, but we will not be implementing this feature. When you see the
    code for the background class, you will see it is simple to add this functionality
    if you want to.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`isParallax`布尔值旨在提供一种让背景静止的选项，但我们不会实现这个功能。当你看到背景类的代码时，你会发现如果你想要，添加这个功能是非常简单的。'
- en: 'Create a new class and call it `BackgroundData`, then implement it with the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，将其命名为`BackgroundData`，然后用以下代码实现它：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we add an `ArrayList` of our new type to the `LevelData` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`LevelData`类中添加了一个我们新类型的`ArrayList`：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let's create the `Background` class itself. Create a new class and name
    it `Background`. First, we set up a bunch of variables to hold a copy of the background
    image along with a reversed copy. We will make the backgrounds seem *endless*
    by putting the images back to back alternating between the regular image and a
    reversed image. We will see how to achieve this further on in the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`Background`类本身。创建一个新类，并将其命名为`Background`。首先，我们设置一组变量来保存背景图像以及它的反转副本。我们将通过将图像背靠背交替使用常规图像和反转图像，使背景看起来*无限*。我们将在代码中进一步了解如何实现这一点。
- en: We also have variables for the width and height of the image in pixels. The
    `reversedFirst` Boolean will determine which copy of the image is currently drawn
    on the left-hand side of the screen (first) and will change as the player moves
    and the image scrolls. The `xClip` variable will hold the precise pixel of the
    *x* axis (of the image), where we will cut the image and start to draw it from
    the left hand edge of the screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有用于存储图像的宽度和高度的像素变量。`reversedFirst`布尔值将决定当前在屏幕左侧（首先）绘制哪个图像副本，并将在玩家移动和图像滚动时改变。`xClip`变量将保存我们将在屏幕左侧边缘开始绘制的图像的*x*轴的确切像素。
- en: 'The `y`, `endY`, `z`, and `speed` member variables are to hold the related
    values passed in as parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`、`endY`、`z`和`speed`成员变量用于保存作为参数传递的相关值：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, in the constructor, we create an Android resource ID from the name of the
    graphic file passed in as a parameter. Then, create the actual bitmap by calling
    `BitmapFactory.decodeResource()`. We set `reversedFirst` to `false`, so we will
    start with the regular (non-reversed) copy of the image on the left-hand side
    of the screen. We initialize our member variables and then scale the bitmap we
    just created by calling `Bitmap.createScaledBitmap()` and passing in bitmap, the
    width of the screen and the height (in the game world) of our background multiplied
    by the `pixelsPerMetre`, making the bitmap exactly the right size for the current
    devices screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们从作为参数传递的图形文件名创建一个Android资源ID。然后，通过调用`BitmapFactory.decodeResource()`创建实际的位图。我们将`reversedFirst`设置为`false`，因此将从屏幕左侧开始使用图像的正常（非反转）副本。我们初始化成员变量，并通过调用`Bitmap.createScaledBitmap()`并传入位图、屏幕宽度和背景在游戏世界中的高度乘以`pixelsPerMetre`来缩放我们刚刚创建的位图，使位图恰好适合当前设备屏幕的尺寸。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we must choose appropriate heights for our background designs or they
    will appear stretched.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须为背景设计选择适当的高度，否则它们会出现拉伸。
- en: The last thing we do in the constructor is create a `Matrix` object and send
    it to the `createScaledBitmap` method along with the bitmap, so we now have a
    reversed copy of our background image stored in the `bitmapReversed Bitmap` object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中最后要做的就是在调用`createScaledBitmap`方法时创建一个`Matrix`对象，并连同位图一起传递，这样我们现在在`bitmapReversed
    Bitmap`对象中存储了一个背景图像的反转副本。
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we add two backgrounds to our level design. We fill out the required parameters
    that we have already discussed. Note that the "grass" background on layer 1 scrolls
    much faster than the "skyline" background on layer -1\. This will create the desired
    parallax effect. Add this code right at the end of the `LevelCave` constructor:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在关卡设计中添加两个背景。我们填写已经讨论过的所需参数。请注意，第1层的“草地”背景滚动速度比-1层的“天际线”背景快得多。这将产生所需的视差效果。在`LevelCave`构造函数的末尾添加以下代码：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is certainly true that most caves do not have grass and a skyline. This is
    just a demonstration and to get the code working. We will redesign `LevelCave`
    and design some more appropriate levels a little later in this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数洞穴确实没有草地和天际线，这只是一个演示，让代码工作起来。我们将在本章稍后重新设计`LevelCave`，并设计一些更合适的关卡。
- en: Now, we load them with our `LevelManager` class by declaring a new `Arraylist`
    object as a member of our `LevelManager` class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过声明一个`Arraylist`对象作为`LevelManager`类的成员，用我们的`LevelManager`类加载它们。
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add a new method in `LevelManager` to load the background data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`LevelManager`中添加一个新方法来加载背景数据：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We call the new method in the `LevelManager` constructor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`LevelManager`构造函数中调用这个新方法：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And, not for the last time, we will upgrade our `Viewport` class to enable our
    `PlatformView` methods to get the information they need, to draw the parallax
    backgrounds.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，不是最后一次，我们将升级我们的`Viewport`类，让`PlatformView`方法能够获取它们需要的信息，以绘制视差背景。
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then, we will add a method which actually does the drawing in the `PlatformView`
    class. We will call this method from `onDraw()`, in just the right places, next.
    Note that we are using the new methods that we just added to the `Viewport` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在`PlatformView`类中添加一个实际执行绘图的方法。接下来，我们会在`onDraw()`中的恰当位置调用这个方法。请注意，我们正在使用刚刚添加到`Viewport`类中的新方法。
- en: First, we define four `Rect` objects that we will use to hold the start and
    end points of `bitmap` and `reversedBitmap`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义四个`Rect`对象，用来保存`bitmap`和`reversedBitmap`的起始和结束点。
- en: 'Implement the first part of the `drawBackground` method as shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照所示实现`drawBackground`方法的第一部分：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we simply loop through all our backgrounds using the `start` and `stop`
    parameters to decide which backgrounds have a *z* layer that we are currently
    interested in drawing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需遍历所有背景，使用`start`和`stop`参数来确定哪些背景具有我们当前感兴趣的*z*层。
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we send the world coordinates of the background to the `Viewport` class
    for clipping. If it isn't clipped (and should be drawn), we get the starting pixel
    coordinates, and ending pixel coordinates on the *y* axis with the help of the
    new methods we added to our `Viewport` class previously. Note that we cast the
    results to `int` variables ready to be drawn to the screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将背景的世界坐标发送到`Viewport`类进行裁剪。如果没有裁剪（并且应该绘制），我们将使用之前添加到我们的`Viewport`类中的新方法，获取*y*轴上的起始像素坐标和结束像素坐标。请注意，我们将结果转换为`int`变量，以便绘制到屏幕上。
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This next block of code is where the real action takes place. We initialize
    the four `Rect` objects with the starting and ending coordinates of the first
    and second of our two `Bitmap` objects. Note that the point (or pixel) that is
    calculated, is determined by `xClip`, which is initially zero. So, to start with,
    we will simply see `background` (if it is not clipped) stretched across the width
    of the screen. Soon, we will see that we modify `xClip` based on Bob''s velocity
    and cause different regions from each bitmap to be shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块是真正行动发生的地方。我们用两个`Bitmap`对象的起始和结束坐标初始化四个`Rect`对象。请注意，计算出的点（或像素）由`xClip`确定，最初为零。因此，首先我们会看到`background`（如果它没有被剪辑）拉伸到屏幕的宽度。很快，我们会看到根据Bob的速度修改`xClip`，并展示每个位图的不同区域：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we determine which background (regular or reversed) is currently being
    drawn first, and then draw that one first followed by the other.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们确定当前首先绘制的是哪种背景（正常或反向），然后先绘制该背景，接着绘制另一种。
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can scroll along based on the speed and direction of Bob, `lv.player.getxVelocity()`
    and if `xClip` has reached the end of the current first background, `if (bg.xClip
    >= bg.width)`, simply set `xClip` to zero and change which bitmap we show first.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据Bob的速度和方向滚动，`lv.player.getxVelocity()`，如果`xClip`已达到当前第一个背景的末端，`if (bg.xClip
    >= bg.width)`，只需将`xClip`设为零，并改变我们首先展示的位图。
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, we add a call to `drawBackground()` just before our game objects for backgrounds
    with a *z* layer less than zero.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*z*层小于零的背景的游戏对象之前，我们添加对`drawBackground()`的调用。
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Just after the bullets are drawn, but before the debugging text for those backgrounds
    with a *z* order more than zero.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制子弹之后，但在那些*z*顺序大于零的背景的调试文本之前。
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we can really start to get creative with our level designs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始发挥创意设计关卡。
- en: '![Scrolling parallax backgrounds](img/B04322_08_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![滚动视差背景](img/B04322_08_05.jpg)'
- en: Very soon, we will make some real playable levels that use all the features
    we have implemented over the last four chapters. Before we do that, let's have
    a bit of fun with the `Viewport` class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将制作一些真正可玩的关卡，使用我们在过去四章中实现的所有功能。在我们这样做之前，让我们在`Viewport`类中找点乐趣。
- en: It will be really useful for the player to scan around a level and plan a route.
    Equally, it will be helpful when designing levels, to zoom around the level to
    see how a particular part of the level looks without having to get the player
    character to that part in order to see it on the screen. So, let's make the pause
    screen into a moveable viewport.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家来说，在关卡中扫描并规划路线将非常有用。同样，在设计关卡时，放大并围绕关卡查看某个特定部分的外观，而无需让玩家角色到达该部分以便在屏幕上看到它，也会很有帮助。所以，让我们将暂停屏幕变成一个可移动视口。
- en: Pause menu with moveable viewport
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有可移动视口的暂停菜单
- en: This is nice and quick. We will just add a bunch of new methods to our `Viewport`
    class to change the center of focus. Then, we will call them from `InputController`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做既好又快。我们只需向`Viewport`类添加一堆新方法来改变焦点中心。然后，我们将在`InputController`中调用它们。
- en: If you remember when we implemented the `InputController` class back in [Chapter
    6](ch06.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob,
    Beeps and Bumps*, we wrapped all the control logic in an `if(playing)` test. We
    also implemented the pause button already in the `else` clause. All we will do
    is use the left, right, jump, and shoot buttons as left, right, up, and down,
    respectively, for moving the viewport.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们在[第6章](ch06.html "第6章. 平台游戏 – Bob, Beeps, 和 Bumps")实现`InputController`类时，*平台游戏
    – Bob, Beeps 和 Bumps*，我们将所有控制逻辑封装在一个`if(playing)`测试中。我们还在`else`子句中实现了暂停按钮。我们将要做的就是将左、右、跳跃和射击按钮分别用作左、右、上和下来移动视口。
- en: 'First, add these methods to the `Viewport` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向`Viewport`类添加以下方法：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, add these calls to the methods from the `else` clause of the `if` condition
    in the `InputController` class that we were just discussing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下调用添加到我们在`InputController`类中刚刚讨论的`if`条件的`else`子句中。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: On the pause screen, the player can look around and plan their route when they
    are on more complicated levels. They are probably going to need to.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停屏幕上，玩家可以四处查看并规划他们在更复杂关卡中的路线。他们可能需要这么做。
- en: Levels and game rules
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关卡和游戏规则
- en: We have implemented so many features, but we still don't have a way to put them
    altogether into a playable game. We need to be able to travel between levels,
    and have the player state persist when we do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了许多功能，但我们仍然没有一个方法将这些功能整合成一个可玩的游戏。我们需要能够在关卡之间移动，并且在移动时保持玩家状态。
- en: Traveling between levels
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关卡之间移动
- en: 'As we are going to design four levels, we want the player to be able to travel
    between them. First, let''s add code to the `switch` statement at the start of
    the `LevelManager` constructor to include all four levels that we are about to
    build:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将要设计四个关卡，我们希望玩家能够在它们之间移动。首先，让我们在`LevelManager`构造函数的开始部分的`switch`语句中添加代码，包括我们即将构建的所有四个关卡：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As we know, we start the game by calling `loadLevel()` from the `PlatformView`
    constructor. The arguments include the name of the level and the coordinates to
    spawn the player. If you are designing your own levels, then you need to decide
    which level and coordinates to start with. If you will be following along with
    the levels I have provided, set the call to `loadLevel()` in the constructor of
    `PlatformView` as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们通过从`PlatformView`构造函数中调用`loadLevel()`来开始游戏。参数包括关卡名称和玩家生成的坐标。如果你正在设计自己的关卡，那么你需要决定从哪个关卡和坐标开始。如果你将跟随我提供的关卡，请在`PlatformView`的构造函数中将`loadLevel()`的调用设置如下：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `if(lm.isPlaying())` block, in the `update` method, where we set the
    viewport to center on the player each frame; add the following code to detect
    (and brutally kill) the player if he falls out of the map as well as cause the
    game to restart with three lives, zero money, and no upgrades should he run out
    of lives:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if(lm.isPlaying())`块中，在`update`方法中，我们每一帧设置视口以玩家为中心；添加以下代码以检测（并残忍地消灭）玩家如果他掉出地图，以及当他的生命值耗尽时，使游戏重新开始，拥有三条生命，零金钱，没有升级：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, we can create a special `GameObject` class that when touched sends the
    player to a predetermined level and location. We can then strategically add these
    objects to our level designs, and they will act as the link between our levels.
    Create a new class and call it `Teleport`. If you haven't already done so, add
    the `door.png` file from `Chapter8/drawable` to the `drawable` folder of the project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个特殊的`GameObject`类，当玩家接触这个类时，会将玩家传送到一个预定的关卡和位置。然后我们可以策略性地将这些对象添加到我们的关卡设计中，它们将作为我们关卡之间的链接。创建一个名为`Teleport`的新类。如果你还没有这样做，请将`Chapter8/drawable`文件夹中的`door.png`文件添加到项目的`drawable`文件夹中。
- en: 'This is how our `Teleport` object will appear in the game:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Teleport`对象在游戏中的样子：
- en: '![Traveling between levels](img/B04322_08_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![在关卡之间移动](img/B04322_08_06.jpg)'
- en: 'Let''s make a simple class to hold the data that each `Teleport` object will
    need. Create a new class called `Location` like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的类来保存每个`Teleport`对象所需的数据。创建一个名为`Location`的新类，如下所示：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The actual `Teleport` class looks just like any other `GameObject` class, but
    note that it also has a member `Location` variable. We will see how the level
    design will hold the destination of the `Teleport`, the `LevelManager` class will
    initialize it, and then when the player collides with it, we can load the new
    location, sending the player off to his destination.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`Teleport`类看起来像任何其他的`GameObject`类，但请注意它还包含一个`Location`成员变量。我们将看到关卡设计将如何保存`Teleport`的目的地，`LevelManager`类将初始化它，然后当玩家与它碰撞时，我们可以加载新的位置，将玩家送往他的目的地。
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make our `Teleport` class work in a way that lets the level designer decide
    what it will do exactly, we need to add to our `LevelData` class like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的`Teleport`类以让关卡设计师决定它将确切执行什么的方式工作，我们需要像这样向我们的`LevelData`类中添加内容：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, we need to add a `t` to the level design wherever we want our teleport/door,
    and an entry like the next line of code, within the constructor of the class of
    the level we are designing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在想要设置传送门/门的关卡设计中的相应位置添加一个`t`，并在关卡类的构造函数中添加如下代码行。
- en: 'Note that you can have as many `Teleport` objects as you like in a map, as
    long as the order they are defined in code matches the order they appear in the
    design. We will see exactly how this works when we look at our actual level designs
    in a minute, but the code will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以在地图中设置任意数量的`Teleport`对象，只要它们在代码中定义的顺序与设计中出现的顺序相匹配。当我们稍后查看实际的关卡设计时，我们会确切地看到这是如何工作的，但代码将如下所示：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As usual, we need to update the `LevelManager` class to load and locate our
    teleport(s). Here is the new code for `getBitmap()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们需要更新`LevelManager`类以加载和定位我们的传送点。以下是`getBitmap()`的新代码：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'New code for `getBitmapIndex()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBitmapIndex()`的新代码：'
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also need to keep track of our `Teleport` objects during the loading phase
    in case there is more than one. So, add a new local variable as shown in the `loadMapData`
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载阶段，我们还需要跟踪我们的`Teleport`对象，以防有多个。所以，在`loadMapData`方法中添加一个新的局部变量，如下所示：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally for the `LevelManager` class, we initialize all the teleport data from
    the level design, tuck it away in the object and add it to our `gameObject ArrayList`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`LevelManager`类，我们最终需要初始化所有从关卡设计中获取的传送数据，将其存储在对象中，并添加到我们的`gameObject ArrayList`中。
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are really close to being able to teleport all over the place. We need to
    detect a collision with a teleport, and then load a new level with the player
    at the desired location. This code will go in our collision detection switch block
    in the `PlatformView` class like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常接近能够到处传送了。我们需要检测与传送点的碰撞，然后在玩家所需的位置加载新关卡。这段代码将放在`PlatformView`类中的碰撞检测开关块里，如下所示：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When a new level is loaded, the `Player`, `MachineGun`, and `Bullet` objects
    are all created from scratch. Therefore, we need to add a line to our `loadLevel`
    method to reload the current machine gun fire rate from the `PlayerState` class
    into the `MachineGun` class. Add the highlighted code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载新关卡时，`Player`、`MachineGun`和`Bullet`对象都将从头开始创建。因此，我们需要在`loadLevel`方法中添加一行代码，将当前的机枪射速从`PlayerState`类重新加载到`MachineGun`类中。添加高亮显示的代码：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we can work on the level designs for real.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始设计关卡了。
- en: The level designs
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关卡设计
- en: You can just copy and paste four classes from the `Chapter8/java` folder into
    your project and start playing, or you can start from the beginning and design
    your own. The levels are quite large, intricate, and tough to beat. It is not
    physically possible to print the level designs in a book or e-book in any meaningful
    way, so you will need to open up the `LevelCave`, `LevelCity`, `LevelForest`,
    and `LevelMountain` design files in order to see the detail of the four levels.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`Chapter8/java`文件夹中复制并粘贴四个类到你的项目中开始游戏，或者你可以从头开始设计自己的关卡。这些关卡相当大，复杂且难以通关。由于篇幅限制，无法在书籍或电子书中以有意义的方式呈现关卡设计，因此你需要打开`LevelCave`、`LevelCity`、`LevelForest`和`LevelMountain`设计文件，以查看四个关卡的详细信息。
- en: However, a brief discussion of the levels, pictures, and some screenshots, but
    not actual code from the four designs follows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下内容将简要讨论四个设计中的关卡、图片和一些截图，但不会包含实际的代码。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the following screenshots feature the new HUD that is the last thing
    we will cover in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下截图展示了本章最后将要介绍的新HUD。
- en: The cave
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洞穴
- en: The cave level is where the whole thing starts. It not only features modestly
    frustrating jumps, but also plenty of fire making a fall potentially deadly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴关卡是整个游戏的开始。它不仅包含一些令人稍微感到沮丧的跳跃，还有大量的火焰，一旦跌落可能致命。
- en: '![The cave](img/B04322_08_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![洞穴](img/B04322_08_07.jpg)'
- en: As the player starts with a puny machine gun, only a few drones are present
    in the level. But there are two awkward guards that will require vaulting.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家开始时只有一把微弱的机枪，因此关卡中只有少数无人机。但有两个别扭的守卫需要翻越。
- en: '![The cave](img/B04322_08_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![洞穴](img/B04322_08_08.jpg)'
- en: The city
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 城市
- en: The city holds vast rewards, especially in the bottom left-hand corner for coins
    and the top-left for machine gun upgrades.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 城市中拥有巨大的奖励，尤其是在左下角收集硬币和左上角升级机枪。
- en: '![The city](img/B04322_08_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![城市](img/B04322_08_09.jpg)'
- en: However, there is a very awkward-to-jump guard on the bottom level should the
    player want to get all those stray coins and not opt for leaving them behind.
    The near vertical ascent that must be traversed up the left-hand side is likely
    to frustrate and if the player opts not to go for the machine gun upgrades, he
    will probably struggle with the double-guard just outside the door to the next
    level.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果玩家想要收集所有散落的硬币而不选择放弃它们，底层有一个跳跃非常别扭的守卫。必须从左侧几乎垂直上升，这很可能会让玩家感到沮丧。如果玩家选择不去升级机枪，他可能会在与下一层门口外的双守卫战斗中遇到困难。
- en: '![The city](img/B04322_08_10.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![城市](img/B04322_08_10.jpg)'
- en: The forest
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 森林
- en: The forest may be the overall toughest level of them all with a brutally long
    run of jumps, which are very easy to over or under jump.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 森林可能是所有关卡中最困难的一个，有一段残酷的长距离跳跃，非常容易跳过或未跳够。
- en: '![The forest](img/B04322_08_11.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![森林](img/B04322_08_11.jpg)'
- en: And with in excess of a dozen drones waiting to swoop on Bob, as his pixels
    hang precariously off a platform.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当Bob的像素悬挂在平台边缘时，超过一打无人机正等着猛扑向他。
- en: '![The forest](img/B04322_08_12.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![森林](img/B04322_08_12.jpg)'
- en: The mountains
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 山脉
- en: The fresh mountain air means Bob has almost made it. Not a guard or a drone
    in sight.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 清新的山间空气意味着Bob几乎要成功了。四周没有守卫或无人机的踪影。
- en: '![The mountains](img/B04322_08_13.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![山脉](img/B04322_08_13.jpg)'
- en: However, look at that winding path of jumps, most of which will see Bob thrown
    right back to the bottom if he puts a pixel out of place.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看看那条蜿蜒的跳跃路径，如果Bob放错了一个像素的位置，大部分路径都会让他直接掉回底部。
- en: '![The mountains](img/B04322_08_14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![山脉](img/B04322_08_14.jpg)'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to try out each of the levels without completing the grueling level(s)
    that precede it, you can of course, just start at the level and location of your
    choice. To do this, just change the call to `loadLevel()` in the `PlatformView`
    constructor to one of the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在不完成前面的艰难关卡的情况下尝试每个关卡，当然，你可以直接从你选择的关卡和位置开始。为此，只需将`PlatformView`构造函数中的`loadLevel()`调用更改为以下之一：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The HUD
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HUD
- en: The finishing touch is to add a HUD. This code in the `draw` method of `PlatformView`
    uses the graphics from some of the existing game objects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 画龙点睛之笔是添加一个HUD。`PlatformView`的`draw`方法中的这段代码使用了现有游戏对象中的一些图像。
- en: 'Add the code after the last call to `drawBackground()` and before the debugging
    text is drawn:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次调用`drawBackground()`之后，并在绘制调试文本之前添加代码：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I think we are done!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们完成了！
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We finished the platform game because that is all there is space for. Why not
    try to implement some or all of the following improvements and features?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了这个平台游戏，因为篇幅有限。为什么不尝试实施以下一些或全部改进和功能呢？
- en: Change the code in the `Player` class to make Bob gradually accelerate and decelerate
    instead of always running at full speed. Simply increment the velocity for each
    frame that the player is holding down left or right, and decrement it for each
    frame they are not.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Player`类中的代码，使Bob逐渐加速和减速，而不是一直以全速运行。只需在玩家按住左右方向的每个帧增加速度，在他们不按的每个帧减少速度。
- en: Once you have achieved this, add the preceding code to the collision detection
    `switch` block in the `update` method to make the player skid on snow, speed up
    on concrete, and have a different walking/landing sound effect for each tile type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，将前面的代码添加到`update`方法中的碰撞检测`switch`块中，以使玩家在雪地上打滑，在混凝土上加速，并为每种瓦片类型提供不同的行走/着陆声效。
- en: Draw a gun on Bob, and adjust the height that the `Bullet` object is spawned
    at to appear as if it is coming from the barrel of his machine gun.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bob身上画一把枪，并调整`Bullet`对象生成的高度，使其看起来是从他的机枪枪管中射出的。
- en: Make some objects pushable. Add an `isPushable` member to `GameObject` and make
    the collision detection simply knock the object back a little. Perhaps, Bob could
    push mine carts into fire to jump over extra wide fire pits. Note that pushing
    objects that fall down to another level will be more complicated than pushing
    objects that remain at the same *y* coordinate.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让一些对象可以被推动。在`GameObject`中添加一个`isPushable`成员，并让碰撞检测简单地使对象后退一点。也许，Bob可以把矿车推入火中，以跳过特别宽的火坑。请注意，推动那些掉到另一个层次的对象将比推动保持在相同*y*坐标的对象复杂得多。
- en: Destructible tiles sound like fun. Give them a strength variable that decrements
    when hit by a bullet and is removed from `gameObjects` when it reaches zero.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可破坏的瓦片听起来很有趣。给它们一个力量变量，当被子弹击中时递减，当达到零时从`gameObjects`中移除。
- en: Moving platforms are a staple of great platformers. Simply add waypoints to
    a tile object and add the move code to the `update` method. The challenge will
    be assigning the waypoints. You can either have them all move a set number of
    spaces left and right or up and down, or do some kind of `setTileWaypoint` method
    similar to how we scripted the `Guard` object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平台是优秀平台游戏的重要组成部分。只需向瓦片对象添加航点，并在`update`方法中添加移动代码。挑战将是如何分配航点。你可以让它们都向左或向右，或者向上或向下移动固定的空间数量，或者像我们编写`Guard`对象那样，使用某种`setTileWaypoint`方法。
- en: Make the game more persistent by saving the total number of coins collected
    ever, remembering which levels are unlocked, and offering access to replay any
    unlocked levels from the menu screen.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保存玩家收集到的硬币总数，记住哪些关卡已被解锁，并在菜单屏幕上提供重新玩任何已解锁关卡的选项，使游戏更具持久性。
- en: Make the game easier with teleports used as waypoints. Adjust the viewport zoom
    for different screen sizes. The current zoom can be a little too low for some
    small phones.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传送点作为路标，让游戏变得更容易。调整视口缩放以适应不同屏幕尺寸。当前的缩放对于一些小手机来说可能有点太低了。
- en: Add timed runs for high scores, leaderboards, and achievements, and add more
    levels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 加入计时跑以获得高分、排行榜和成就，并增加更多关卡。
- en: In the next chapter, we will look at a much smaller project, but still an interesting
    one, as we will be using OpenGL ES for super-fast, smooth drawing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一个更小的项目，但仍然很有趣，因为我们将使用OpenGL ES进行超快速、流畅的绘制。
