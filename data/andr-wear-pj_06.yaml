- en: Ways to Get Around Anywhere - WearMap and the GoogleAPIclient
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任意地点的出行方式 - WearMap 和 Google API 客户端
- en: A Map is a visual representation of an area or a part of an area.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是区域或区域部分的视觉表示。
- en: We humans travel to different cities; they could be domestic or international
    cities. How about tracking the places you visit? We all use maps for different
    reasons, but in most cases, we use maps to plan a particular activity, such as
    outdoor tours, cycling, and other similar activities. Maps influence human intelligence
    to find the fastest route from the source location to the destination. In this
    project, we will build a Wear application that works with the Google Maps service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类会去不同的城市旅行，这些城市可能是国内的也可能是国际的。那么，追踪你所访问的地方怎么样？我们出于不同的原因使用地图，但在大多数情况下，我们使用地图来规划特定的活动，比如户外游览、骑自行车和其他类似活动。地图帮助人类智能找到从起点到目的地的最快路线。在这个项目中，我们将构建一个与
    Google Maps 服务配合工作的 Wear 应用程序。
- en: For record, Google Maps started as a C++ desktop program in October, 2004\.
    Google Maps officially released in February, 2005\. Google Maps offers an API
    that allows maps to be embedded in third-party applications; Google Maps offers
    aerial and satellite views of many places. Google Maps is the best compared to
    other map services; maps are optimize and its accuracy rate is very good.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 记录一下，Google 地图最初是在 2004 年 10 月作为一个 C++ 桌面程序开始的。Google 地图在 2005 年 2 月正式发布。Google
    地图提供了一个 API，允许将地图嵌入第三方应用程序中；Google 地图提供了许多地方的空中和卫星视图。与其他地图服务相比，Google 地图是最佳的，地图进行了优化且其准确率非常高。
- en: 'In this project, let''s build a standalone Wear map application. When a user
    clicks on the map, we shall allow the user to write a story about the location
    and save it in the SQLite database as a marker. When a user clicks on the marker,
    we should show the user what is saved. In this chapter, we will understand the
    following important concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，让我们构建一个独立的 Wear 地图应用程序。当用户点击地图时，我们将允许用户写下关于该地点的故事并将其保存到 SQLite 数据库中作为一个标记。当用户点击标记时，我们应该向用户展示已保存的内容。在本章中，我们将了解以下重要概念：
- en: Creating a project in the developer API console
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发者 API 控制台中创建项目
- en: Getting the Maps API key with the help of the SHA1 fingerprint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SHA1 指纹获取 Maps API 密钥
- en: SQLite integration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 集成
- en: Google Maps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 地图
- en: The Google API Client and more
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google API 客户端及更多功能
- en: GeoCoder
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理编码器
- en: Let's get started with creating WearMap
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始创建 WearMap
- en: We now know how to create a standalone application. In case if you are following
    this project directly without following Wear-note application which is covered
    in [Chapter 2](part0041.html#173720-4c29edad0fa44cd98c59653fa3b7fce0), *Let us
    Help Capture What is on Your Mind - WearRecyclerView and More* and [Chapter 3](part0061.html#1Q5IA0-4c29edad0fa44cd98c59653fa3b7fce0),
    *Let us Help Capture What is on Your Mind - Saving Data and Customizing the UI*.
    Please do follow the Wear-note application to learn more about standalone applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建一个独立的应用程序。如果你是直接跟随这个项目，而没有参考第 [第二章](part0041.html#173720-4c29edad0fa44cd98c59653fa3b7fce0)，*让我们帮助你捕捉心中所想
    - WearRecyclerView 和更多* 和第 [第三章](part0061.html#1Q5IA0-4c29edad0fa44cd98c59653fa3b7fce0)，*让我们帮助你捕捉心中所想
    - 保存数据和定制 UI* 中介绍的 Wear-note 应用程序，请务必跟进 Wear-note 应用程序以了解更多关于独立应用程序的信息。
- en: 'Let''s call this project **WearMapDiary**, since we store the locations and
    details about the location. The project package address up to the developer; in
    this project, the package address is `com.packt.wearmapdiary` and the API level
    25 Nougat. In the activity template, select the Google Maps Wear Activity, as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个项目称为 **WearMapDiary**，因为我们存储的是地点及其详细信息。项目的包地址由开发者决定；在这个项目中，包地址是 `com.packt.wearmapdiary`，API
    级别为 25 Nougat。在活动模板中，选择 Google Maps Wear 活动，如下所示：
- en: '![](img/00070.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: Select Google Maps Wear Activity template from the activity chooser
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从活动选择器中选择 Google Maps Wear 活动模板
- en: 'Once the project is created, we will see the necessary configuration for the
    project, which includes the map fragment already being added; it would have set
    the `DismissOverlays` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，我们将看到项目的必要配置，其中包括已经添加的地图片段；它将设置 `DismissOverlays` 组件：
- en: '![](img/00071.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: The sample code configured for working with the Wear map activity will be generated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将为与 Wear 地图活动一起工作而配置的示例代码生成。
- en: 'We need to add the Maps API key to the project in the `res/values` directory
    `google_maps_api.xml` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `res/values` 目录下的 `google_maps_api.xml` 文件中为项目添加 Maps API 密钥：
- en: '![](img/00072.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: The Google API console
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google API 控制台
- en: The Google API console is a web portal that allows developers to manage Google
    services for their project development and it can be accessed at [https://console.developers.google.com](https://console.developers.google.com).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Google API 控制台是一个网络门户，允许开发者为他们的项目开发管理 Google 服务，可以通过[https://console.developers.google.com](https://console.developers.google.com)访问。
- en: 'Visit the developer console with your Google account. Create a project `packt-wear`
    or something that is convenient for developers:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 Google 账户访问开发者控制台。创建一个项目 `packt-wear` 或对开发者来说方便的其他名称：
- en: '![](img/00073.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.jpeg)'
- en: 'After creating the project successfully, go to the API Manager | Library section
    and enable the Google Maps Android API:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功创建项目后，前往 API 管理器 | 库部分，并启用 Google Maps Android API：
- en: '![](img/00074.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: 'Click on the Enable button for enabling Maps for Android:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“启用”按钮，为 Android 启用地图：
- en: '![](img/00075.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: 'After enabling the API in the console facility, we need to create the API key
    with the development machine''s SHA1 fingerprint and the project''s package address,
    as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台启用 API 后，我们需要使用开发机器的 SHA1 指纹和项目的包地址创建 API 密钥，如下所示：
- en: '![](img/00076.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: 'To get your machine''s SHA1 fingerprint, open Android Studio. On the right-hand
    side of Android Studio, you will see the Gradle project menu. Then, follow these
    steps:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取你的设备的 SHA1 指纹，请打开 Android Studio。在 Android Studio 的右侧，你会看到 Gradle 项目菜单。然后，按照以下步骤操作：
- en: Click on Gradle (on the right-hand side panel, you will see the Gradle Bar)
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Gradle”（在右侧面板上，你会看到 Gradle 栏）
- en: Click on Refresh (click on Refresh; on the Gradle Bar, you will see a List of
    Gradle scripts for your project)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“刷新”（在 Gradle 栏中点击“刷新”；你将看到项目的 Gradle 脚本列表）
- en: Click on Your Project (your Project Name from **List** (root))
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你的项目（从**列表**（根）中的项目名称）
- en: Click on Tasks
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“任务”
- en: Click on Android
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“Android”
- en: 'Double-click on signingReport (you will get SHA1 and MD5 in Run Bar):'
  id: totrans-37
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 signingReport（你将在运行栏中获得 SHA1 和 MD5）：
- en: '![](img/00077.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'Copy your SHA1 fingerprint, paste it in the Google API console, and save:'
  id: totrans-39
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你的 SHA1 指纹，粘贴到 Google API 控制台，并保存：
- en: '![](img/00078.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: 'Now, copy the API key from the console and paste it in the project''s `google_maps_api.xml`
    file, as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从控制台复制 API 密钥，并将其粘贴到项目的 `google_maps_api.xml` 文件中，如下所示：
- en: '![](img/00079.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: 'Now, switch your Gradle scope to app and compile the project in the Wear emulator
    or your Wear device:'
  id: totrans-43
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将你的 Gradle 范围切换到应用，并在 Wear 模拟器或你的 Wear 设备中编译项目：
- en: '![](img/00080.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: 'If your Google Play services is not updated in your emulator, Wear throws an
    error screen to update Play services:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模拟器中没有更新 Google Play 服务，Wear 会显示一个错误屏幕以更新 Play 服务：
- en: '![](img/00081.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: If you have the actual Wear device, the Wear operating system will take care
    of downloading the latest Google Play services update when its available. For
    the emulator, we need to connect it to the actual device to add the account. First,
    connect the Android phone through **adb** and start the Wear emulator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个实际的 Wear 设备，当最新的 Google Play 服务更新可用时，Wear 操作系统将负责下载更新。对于模拟器，我们需要将其连接到实际设备以添加账户。首先，通过
    **adb** 连接 Android 手机并启动 Wear 模拟器。
- en: Install the Android Wear companion app from the Play store [https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en](https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Play 商店安装 Android Wear 伴侣应用[https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en](https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en)。
- en: '![](img/00082.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'In the android Wear application, select emulator, and in the Android Studio
    terminal, enter this command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Wear 应用程序中，选择模拟器，然后在 Android Studio 终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the emulator connects to your actual phone, you can add the account that
    is synced to your phone already or you can add a new account.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟器连接到你的真实手机后，你可以添加已经同步到手机的账户，或者添加一个新的账户。
- en: 'The following image illustrates the Wear account''s sync screen:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Wear 账户的同步屏幕：
- en: '![](img/00083.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: 'After successfully adding the account, start updating your Google Play services:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功添加账户后，开始更新你的 Google Play 服务：
- en: '![](img/00084.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: 'Now, after all this configuration, compile the program in Android Studio and
    see the map on the Wear device:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，完成所有这些配置后，在 Android Studio 中编译程序，并在 Wear 设备上查看地图：
- en: '![](img/00085.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: The Google API client
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google API 客户端
- en: '`GoogleApiClient` extends the **Object** class. The Google API Client provides
    a common entry point to all the Google Play services and manages the network connection
    between the user''s device and each Google service. Google recommends to use `GoogleApiClient`
    to get the user''s location programmatically.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoogleApiClient`扩展了**Object**类。Google API 客户端为所有 Google Play 服务提供了一个共同的入口点，并在用户设备与每个
    Google 服务之间管理网络连接。Google 建议使用`GoogleApiClient`以编程方式获取用户的位置。'
- en: Create `GoogleApiClient` on each thread. `GoogleApiClient` service connections
    are cached internally. `GoogleApiClient` instances are not thread-safe, so creating
    multiple instances is fast. `GoogleApiClient` is used with a variety of static
    methods. Some of these methods require that `GoogleApiClient` be connected; some
    will queue up calls before `GoogleApiClient` is connected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个线程上创建`GoogleApiClient`。`GoogleApiClient`服务连接在内部被缓存。`GoogleApiClient`实例不是线程安全的，因此创建多个实例很快。`GoogleApiClient`与各种静态方法一起使用。其中一些方法要求`GoogleApiClient`已连接；有些会在`GoogleApiClient`连接之前排队调用。
- en: 'Here is a code example that creates a `GoogleApiClient` instance that connects
    with the Google `LocationServices`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个与 Google `LocationServices` 连接创建`GoogleApiClient`实例的代码示例：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configuring the project for functionalities
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置项目以实现功能
- en: We know the importance of creating packages for better code management and maintaining
    code in the future. Let's create a package for the project with four different
    names, which are adapter, model, util, and view.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道为了更好的代码管理和将来维护代码，创建包的重要性。让我们为项目创建一个包含四个不同名称的包，分别是 adapter、model、util 和 view。
- en: We write our plain old Java objects inside the model package. We will configure
    all the database-related classes in the util package and the custom views, such
    as dialog fragments, `TextView`, and so on, in the view package. For the custom
    `infoWindow`, we have to create a `infoWindowAdapter` inside the `adapter` package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 model 包内编写我们的普通旧 Java 对象。我们将在 util 包中配置所有与数据库相关的类，以及在 view 包中配置自定义视图，如对话框片段、`TextView`等。对于自定义`infoWindow`，我们必须在`adapter`包内创建一个`infoWindowAdapter`。
- en: It is very important to fetch the location information using `GoogleApiClient`.
    Now that we have configured the Wear map activity and the map is drawn with the
    API key that we added, it is time to work on getting location details with the
    help of `GoogleApiClient`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GoogleApiClient`获取位置信息非常重要。现在我们已经配置了 Wear 地图活动，并使用我们添加的 API 密钥绘制了地图，是时候利用`GoogleApiClient`获取位置详情了。
- en: Getting users' location information with the help of GoogleApiClient
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用`GoogleApiClient`获取用户的位置信息
- en: 'Now, in the `MapActivity` class, we need to implement the following interfaces:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MapActivity`类中，我们需要实现以下接口：
- en: '`GoogleApiClient.ConnectionCallback`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient.ConnectionCallback`'
- en: '`GoogleApiClient.OnConnectionFailedListener`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleApiClient.OnConnectionFailedListener`'
- en: 'And, we need to override three methods from these two interfaces, which are
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从这两个接口重写三个方法，它们分别是：
- en: '`public void onConnected(..){}`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void onConnected(..){}`'
- en: '`public void onConnectionSuspended(..){}`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void onConnectionSuspended(..){}`'
- en: '`public void onConnectionFailed(..){}`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void onConnectionFailed(..){}`'
- en: 'In the `onConnected` method, we can instantiate the location service using
    the `GoogleApiClient` instance. First, let''s add the `GoogleApiClient` to the
    project. Create an instance of `GoogleApiClient` in the `MapActivity` global scope:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onConnected`方法中，我们可以使用`GoogleApiClient`实例实例化位置服务。首先，让我们将`GoogleApiClient`添加到项目中。在`MapActivity`的全局范围内创建一个`GoogleApiClient`实例：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a void method named `addGoogleAPIClient(){ }` for retrieving the location
    services API:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`addGoogleAPIClient(){ }`的 void 方法，用于获取位置服务 API：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To have the google play services to do the location related jobs, please add
    the following dependency in the gradle wear module:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Google Play 服务处理与位置相关的任务，请在 gradle wear 模块中添加以下依赖项：
- en: '`compile ''com.google.android.gms:play-services-location:11.0.2''`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile ''com.google.android.gms:play-services-location:11.0.2''`'
- en: 'Now, in the `onConnected` method, attach the `mGoogleApiClient`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onConnected`方法中，附加`mGoogleApiClient`：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Locationservice` needs a permission check before requesting the location.
    Let's add the permission in manifest and in Activity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Locationservice`在请求位置之前需要权限检查。让我们在 manifest 和 Activity 中添加权限。'
- en: 'Add the following permissions to Manifest:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Manifest 中添加以下权限：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write a method in the `MapActivity.java` class for checking the permission
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MapActivity.java`类中编写一个检查权限的方法，如下所示：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the method `onRequestPermissionsResult(..){}` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式重写`onRequestPermissionsResult(..){}`方法：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have the permission check method; handle it in the `onConnected` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了权限检查方法；在`onConnected`方法中处理它：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s write a method to check whether the GPS is available `onboard` on Wear
    devices. Using the `packagemanager` class, we can retrieve the available hardware
    in a Wear device. Let''s write a method called `hasGps()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个方法来检查Wear设备上是否内置了GPS。通过使用`packagemanager`类，我们可以检索Wear设备上可用的硬件。让我们写一个名为`hasGps()`的方法：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use this method in the `onCreate()` method if you want your users to know about
    whether their device has a GPS device or you just want to log it for development
    purposes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要用户知道他们的设备是否有GPS设备，或者在开发过程中只是想要记录下来，你可以在`onCreate()`方法中使用这个方法：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If your wearable app records data using the built-in GPS, you may want to synchronize
    the location data with the handset using the `LocationListner` interface by implementing
    the `onLocationChanged()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的可穿戴应用使用内置GPS记录数据，你可能想要通过实现`onLocationChanged()`方法，使用`LocationListner`接口将位置数据与手持设备同步。
- en: To make your application location-aware, use `GoogleAPIclient`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的应用能够感知位置，请使用`GoogleAPIclient`。
- en: 'Follow this link for understanding more about permission: [https://developer.android.com/training/articles/wear-permissions.html](https://developer.android.com/training/articles/wear-permissions.html).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于权限的信息，请点击这个链接：[https://developer.android.com/training/articles/wear-permissions.html](https://developer.android.com/training/articles/wear-permissions.html)。
- en: 'Now, let''s work with the `onMapclick` method for handling the process of adding
    the marker on maps. To do this, implement `GoogleMap.OnMapClickListener` in your
    activity and implement its callback method, which will give you the `onmapclick`
    with latlong. Add the click context to your `onMapReady` callback, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理`onMapclick`方法，以处理在地图上添加标记的过程。为此，在你的活动中实现`GoogleMap.OnMapClickListener`并实现其回调方法，这将为你提供带有经纬度的`onmapclick`。将点击上下文添加到你的`onMapReady`回调中，如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `onMapClick` method, we can add the following marker using `latLng`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onMapClick`方法中，我们可以使用`latLng`添加以下标记：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adding a marker in the `onMapclick` method uses `MarkerOptions()`. For custom
    markers designed by Google, we will use the `addmarker` method from maps and add
    the new `MarkerOptions` with position, title, and snippet, which is minimal description
    below the title:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onMapclick`方法中添加标记使用`MarkerOptions()`。对于谷歌设计的高级标记，我们将使用地图的`addmarker`方法，并添加带有位置、标题和摘要（标题下方的简短描述）的新`MarkerOptions`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding the marker with `infowindow`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 添加带有`infowindow`的标记后：
- en: '![](img/00086.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: Now, we have the map and we are adding the marker to the map, but we need to
    work with geocoding for fetching the address name of the coordinates.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了地图，并且正在向地图添加标记，但我们需要处理地理编码以获取坐标的地址名称。
- en: GeoSpatial data using GeoCoder
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GeoCoder的地理空间数据
- en: Fetch the address using coordinates using the `GeoCoder` class. Geocoding, usually,
    is a process of transforming a street address or other description of a location
    into a (latitude, longitude) coordinate. Reverse geocoding is the process of transforming
    a (latitude, longitude) coordinate into a (partial) address.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GeoCoder`类通过坐标获取地址。地理编码通常是将街道地址或位置的其它描述转换为（纬度，经度）坐标的过程。逆地理编码是将（纬度，经度）坐标转换为（部分）地址的过程。
- en: 'In the `OnMapClick` method, make the following changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnMapClick`方法中，进行以下更改：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code snippet adds the marker to the map with the location name
    in the info window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将标记添加到地图上，并在信息窗口中显示位置名称：
- en: '![](img/00087.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'The pop-up view on clicking the map is called `infowindow` in Android. It is
    a similar component to ToolTip in web development. In this project, we need to
    save the data wherever users click on the map; we need to show a custom map marker
    with the help of `infowindow`. We need to write an adapter implementing `GoogleMap.InfoWindowAdapter`
    with a custom layout, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击地图时弹出的视图在Android中称为`infowindow`。它类似于网页开发中的ToolTip组件。在这个项目中，我们需要在用户点击地图的任何地方保存数据；我们需要借助`infowindow`显示自定义地图标记。我们需要编写一个适配器，实现`GoogleMap.InfoWindowAdapter`与自定义布局，如下所示：
- en: Infowindow adapter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息窗口适配器
- en: 'The following implementation explains how to write our custom `infowindow`
    adapter for the map marker:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现解释了如何为地图标记编写我们自定义的`infowindow`适配器：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `windowadapter` class implements `GoogleMap.InfoWindowAdapter` with two
    callback methods `getInfoWindow(..){}` and `getInfoContents(..){}`. We can inflate
    our custom layout `getInfoContent` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`windowadapter`类实现了`GoogleMap.InfoWindowAdapter`，包含两个回调方法`getInfoWindow(..){}`和`getInfoContents(..){}`。我们可以通过`getInfoContent`方法来填充自定义布局：'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the preceding adapter class to the adapter package for better code access
    and maintenance. `InfoWindowAdapter` does not use any data to populate the view;
    we populate the view with whatever data is associated with the marker. If we want
    to add anything beyond the title and the snippet, we have no way of doing it in
    the adapter itself. We need to create a mechanism for achieving this programmatically.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的代码访问和维护，将前面的适配器类添加到adapter包中。`InfoWindowAdapter`没有使用任何数据来填充视图；我们使用与标记关联的任何数据来填充视图。如果我们想在标题和摘要之外添加任何内容，适配器本身无法做到这一点。我们需要创建一个机制以编程方式实现这一点。
- en: 'Create the `Memory` class in the model package. The `Memory` class is a place
    where users choose to add the marker:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在model包中创建`Memory`类。`Memory`类是用户选择添加标记的地方：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have our memory and the custom `infowindow` adapter is ready for working
    with the `onMapclick` implementation. For each marker, we shall add a memory class
    association. To save all our memory temporarily, let''s use `HashMap`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了memory，自定义`infowindow`适配器已准备好与`onMapclick`实现一起工作。对于每个标记，我们将添加一个memory类关联。为了临时保存所有memory，让我们使用`HashMap`：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s add our marker to `HashMap` for access to `Marker` properties, such
    as `Marker` ID and so on. The complete code for the adapter is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将标记添加到`HashMap`中，以便访问`Marker`属性，例如`Marker` ID等。适配器的完整代码如下：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `OnMapClick` method, add the following changes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnMapClick`方法中，添加以下更改：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Attach the new `Marker` to the maps with the following code in the `onMapready`
    method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码在`onMapready`方法中将新的`Marker`附加到地图上：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, compile the program. You should be able to see the updated `infoWindow`,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译程序。你应该能够看到如下更新的`infoWindow`：
- en: '![](img/00088.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: Custom DialogFragment for taking notes about the location
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于记录位置信息的自定义`DialogFragment`
- en: '`DialogFragment` is a dialog window that floats in activity. On Wear devices
    it will not float but it gives the Wear optimized design. Check the following
    code for implementing.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogFragment`是一个在活动中浮动的对话框窗口。在Wear设备上它不会浮动，但它提供了Wear优化的设计。查看以下实现代码。'
- en: 'Before moving forward, implement the Memory class to a serializable interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，将Memory类实现为可序列化接口：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following layout file to the layout directory and call the layout file
    as `memory_dialog_fragment.xml`. After creating the file, add the following code
    inside the layout file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在layout目录中添加以下布局文件，并将布局文件命名为`memory_dialog_fragment.xml`。创建文件后，在布局文件内添加以下代码：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After creating the layout file, let's work on the Java code for creating the
    custom dialog. Create a class called `MemoryDialogFragment` and extend it to `DialogFragment`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建布局文件后，让我们处理创建自定义对话框的Java代码。创建一个名为`MemoryDialogFragment`的类，并继承自`DialogFragment`。
- en: 'Create an interface for handling the `SaveClicked` and `cancelClicked` buttons
    of `DialogFragment`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接口来处理`DialogFragment`的`SaveClicked`和`cancelClicked`按钮：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, add the following instances to the `MemoryDialogFragment` global scope.:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下实例添加到`MemoryDialogFragment`的全局范围内。：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, work on inflating the layout with the right data in the right field:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理正确地在正确字段中填充布局的数据：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will fetch the serialized data from `Memory` in the `oncreate` method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`oncreate`方法中从`Memory`获取序列化的数据：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The complete code for the `MemoryDialogFragment` is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryDialogFragment`的完整代码如下：'
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `OnMapClick` method, make the following changes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnMapClick`方法中，进行以下更改：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, compile the program. You will see the following screen on `mapclick`.
    The user can input his or her thoughts about the map location in the edittext
    field:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译程序。在`mapclick`时，你将看到以下屏幕。用户可以在edittext字段中输入关于地图位置的自己的想法：
- en: '![](img/00089.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: Now that we have added the dialog for taking the input, let's work on saving
    the data to SQLite.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了输入对话框，让我们来处理将数据保存到SQLite的操作。
- en: Configuring SQLite and saving the markers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置SQLite并保存标记
- en: Persisting all the necessary data is the fundamental use case for any good software.
    Android SDK provides an SQLite storage solution built in. It has a very small
    footprint and is very fast. If a programmer is familiar with SQL queries and operations,
    SQLite is going to be easy and delightful to work with.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何优秀的软件来说，持久化所有必要的数据都是基本用例。Android SDK内置了SQLite存储解决方案。它占用的空间非常小，速度也非常快。如果程序员熟悉SQL查询和操作，那么使用SQLite将会轻松愉快。
- en: Schema and contract
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和合约
- en: Essentially, for a database, we need to create a data schema, which is a formal
    declaration of how the database is organized. The schema is reflected in the SQLite
    query statements. A contract class is a container for constants that define names
    for URIs, tables, and columns. The contract class allows the use of the same constants
    across all the other classes in the same package.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，对于数据库，我们需要创建一个数据模式，这是对数据库组织方式的正式声明。该模式反映在SQLite查询语句中。合约类是一个包含常量的容器，这些常量定义了URI、表和列的名称。合约类允许在同一个包中的所有其他类中使用相同的常量。
- en: 'For the scope of `WearMapDiary`, we will create all the instances in the `DBHelper`
    class. Now, let''s create the `DBhelper` class, which opens and connects the application
    to SQLite and processes the query:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`WearMapDiary`的范围，我们将在`DBHelper`类中创建所有实例。现在，让我们创建`DBhelper`类，它打开并连接应用程序到SQLite，并处理查询：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to create a `Datasource` for managing all the queries, and reading
    and writing the data to SQLite. Here, in this class, we will create multiple methods
    for creating data, reading the data, updating the data, and deleting the data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个`Datasource`来管理所有查询，以及读写SQLite中的数据。在这里，这个类中，我们将创建多个方法来创建数据、读取数据、更新数据和删除数据：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For executing all these queries in the background using `cursorLoader`, we
    will write another class and we will call this class `DBCurserLoader`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后台使用`cursorLoader`执行所有这些查询，我们将编写另一个类，我们将这个类称为`DBCurserLoader`：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create another class for loading all the memories from `memoryDatasource` and
    extend it to `DBCursorLoader`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个类，用于从`memoryDatasource`加载所有记忆，并扩展到`DBCursorLoader`：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we have the SQLite configuration working fine. Lets work with `MapActivity`
    to save the data inside SQLite `onMapclick`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的SQLite配置工作正常。让我们在`MapActivity`中处理保存数据到SQLite的`onMapclick`。
- en: Saving data in SQLite
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SQLite中保存数据
- en: 'To connect SQLite to the activity and to save the data in SQLite, implement
    the activity `LoaderManager.LoaderCallbacks<Cursor>` and instatiate the datasource
    in the `onCreate` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将SQLite连接到活动，并在SQLite中保存数据，请实现活动`LoaderManager.LoaderCallbacks<Cursor>`并在`onCreate`方法中实例化数据源：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement the callback methods for the `LoaderManager.LoaderCallbacks<Cursor>`
    interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`LoaderManager.LoaderCallbacks<Cursor>`接口的回调方法：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, refactor the `addingMarker` code in a method as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`addingMarker`代码重构为一个方法，如下所示：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We still need to work with dragging the marker for future implementation. Let''s
    make the draggable property true. Now, in the `OnMapClick` method, call the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理拖动标记以用于将来的实现。让我们将可拖动属性设置为true。现在，在`OnMapClick`方法中，调用以下代码：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s refactor the `UpdateMemoryPosition` method, which fetches the address
    from `latlng` and adds it to `Memory`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构`UpdateMemoryPosition`方法，它从`latlng`获取地址并将其添加到`Memory`：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we are saving the data inside SQLite. When we close and open the map,
    we are not reading and adding the marker data to the map:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在SQLite中保存数据。当我们关闭并重新打开地图时，我们没有读取并将标记数据添加到地图中：
- en: '![](img/00090.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Now, let's read the SQLite data and add it to the maps.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们读取SQLite数据并将其添加到地图中。
- en: 'The `onCreateLoader` callback method from the `LoaderManager` class adds the
    data through the `Datasource` instance to `MemoryLoader` as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoaderManager`类的`onCreateLoader`回调方法通过`Datasource`实例将数据添加到`MemoryLoader`，如下所示：'
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `onLoadFinished` method, fetch the data from the cursor and add it to
    the maps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onLoadFinished`方法中，从游标中获取数据并将其添加到地图中：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Adding the marker to map from fetched data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从获取的数据中向地图添加标记：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we have a functional Wear app called `WearMapDiary`, which finds the address
    and saves quick notes about the location in the map. It adds the marker to the
    SQLite database and attaches the marker to the map when we open the application
    in a Wear device:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`WearMapDiary`的功能性Wear应用，它查找地址并在地图上关于位置保存快速笔记。它将标记添加到SQLite数据库中，并在我们在Wear设备上打开应用程序时将标记附加到地图上：
- en: '![](img/00091.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: 'Retrieved notes and location information from the app:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用中检索笔记和位置信息：
- en: '![](img/00092.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.jpeg)'
- en: 'In this dialog, users can type in the data he or she wants to save in the current
    location:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框中，用户可以输入他或她想要保存在当前位置的数据：
- en: '![](img/00093.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00093.jpeg)'
- en: 'So far, we have explored how to integrate maps to Wear devices and had a clear
    understanding of getting the Maps API key. We are using `GoogleApiclient` for
    fetching the location service. We are checking for GPS hardware availability:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何将地图集成到穿戴设备上，并清楚地了解了如何获取地图API密钥。我们使用`GoogleApiclient`来获取位置服务。我们正在检查GPS硬件的可用性：
- en: Following steps briefly, explains how to write the custom marker.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤简要介绍了如何编写自定义标记。
- en: Explored the custom `InfoWindow` adapter by implementing `GoogleMap.InfoWindowAdapter`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现`GoogleMap.InfoWindowAdapter`探索了自定义`InfoWindow`适配器。
- en: Created a custom `dialogFragment` for Wear compatibility using `boxinsetlayout`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`boxinsetlayout`为Wear兼容性创建了自定义的`dialogFragment`。
- en: '`Geocoder` class fetching the `GeoSpatial` data'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Geocoder`类获取`GeoSpatial`数据'
- en: SQLite and its integration for map data
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite及其与地图数据的集成
- en: Now, it's time to understand more about maps on Wear devices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候了解关于穿戴设备上的地图的更多信息了。
- en: Difference between a standalone map and mobile-synced map application
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立地图应用与移动同步地图应用之间的区别
- en: A watch application that is target at the Wear 2.0 platform can connect to Wi-Fi
    through the onboard Wi-Fi transceiver. We can cache the maps and a lot more, but
    it still lacks the comforts that a mobile map application gives. Generally, for
    standalone Wear applications, the target API level is 25 and comes with runtime
    permissions for security operations. In this chapter, we have added the code for
    handling runtime permissions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 面向Wear 2.0平台的手表应用可以通过板载Wi-Fi传输器连接到Wi-Fi。我们可以缓存地图等更多内容，但它仍然缺乏移动地图应用程序的舒适性。通常，对于独立的Wear应用，目标API级别是25，并带有安全操作运行时权限。在本章中，我们添加了处理运行时权限的代码。
- en: Identifying the app as standalone
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用标识为独立应用
- en: 'Wear 2.0 requires a new metadata element in the Android `Manifest` file of
    watch apps, as a child of the `<application>` element. The name of the new metadata
    element is `com.google.android.wearable.standalone` and the value must be true
    or false:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0要求手表应用的Android `Manifest`文件中有一个新的元数据元素，作为`<application>`元素的子元素。新元数据元素的名称是`com.google.android.wearable.standalone`，值必须是true或false：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since standalone apps are independent or semi-independent, it can be installed
    by an iPhone user and Android phone that lacks the Play store (BlackBerry android
    forked OS and Nokia custom Android phones).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于独立应用是独立或半独立的，因此iPhone用户和缺少Play商店的Android手机（如BlackBerry android分叉操作系统和诺基亚定制Android手机）可以安装它们。
- en: If a watch app depends on a phone app, set the value of the previous metadata
    element to false.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手表应用依赖于手机应用，请将前一个元数据元素的值设置为false。
- en: Even if the value is false, the watch app can be installed before the corresponding
    phone app is installed. Therefore, if a watch app detects that a companion phone
    lacks a necessary phone app, the watch app should prompt the user to install the
    phone app.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 即使值是false，手表应用也可以在相应的手机应用安装之前安装。因此，如果手表应用检测到配套手机缺少必要的手机应用，手表应用应提示用户安装手机应用。
- en: Sharing data between a Wear app and phone app
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在手表应用和手机应用之间共享数据
- en: Data can be shared between a Wear application and a phone application or data
    that is specific to an application. You can use standard Android storage APIs
    to store data locally. For example, you can use [SharedPreferences APIs](https://developer.android.com/reference/android/content/SharedPreferences.html),
    SQLite, or internal storage (as you would in the case of a phone). The Messaging
    API Wear app can communicate with the corresponding phone application.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 手表应用和手机应用之间可以共享数据，或者共享特定于应用的数据。你可以使用标准的Android存储API在本地存储数据。例如，你可以使用[SharedPreferences
    APIs](https://developer.android.com/reference/android/content/SharedPreferences.html)，SQLite，或者内部存储（就像在手机上一样）。消息传递API的手表应用可以与对应的手机应用通信。
- en: Detecting your application from another device
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一台设备上检测你的应用
- en: 'In **CapabilityAPI**, your Wear application can detect the corresponding mobile
    application for a Wear application. Wear devices can advertise their events to
    the paired device spontaneously and statically as well. For checking the advertised
    capabilities of paired Wear devices, check this link for more information: [https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities](https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CapabilityAPI**中，你的Wear应用可以检测到与Wear应用对应的手机应用。Wear设备可以自发地以及静态地向配对的设备广播它们的事件。要检查配对Wear设备宣传的功能，更多信息请查看此链接：[https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities](https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities)。
- en: 'Note that not all the phones support the Play store (such as iPhones, and so
    on). This section describes the best practices for these scenarios: your standalone
    watch app needs your phone app and your phone app needs your standalone watch
    app.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有手机都支持Play商店（如iPhone等）。本节描述了这些情况的最佳实践：你的独立手表应用需要你的手机应用，而你的手机应用也需要你的独立手表应用。
- en: Specifying capability names to detect your apps
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定功能名称以检测你的应用
- en: 'For the app corresponding to each device type (watch or phone), specify a unique
    string for the capability name in the `res/values/wear.xml` file. For example,
    in your mobile module, the `wear.xml` file could include the following code in
    Wear and mobile modules:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种设备类型（手表或手机）对应的应用，请在`res/values/wear.xml`文件中为功能名称指定一个唯一的字符串。例如，在你的移动模块中，`wear.xml`文件可能包含以下代码，在Wear和移动模块中：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Detecting and guiding the user to install a corresponding phone app
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测并引导用户安装相应的手机应用
- en: 'Wear 2.0 introduces standalone applications. Wear apps are capable enough to
    function without the support of a mobile app. In a critical situation, when a
    mobile app is a must, a Wear app can guide the user to install the mobile support
    app and the Wear correspondent app with the following set of steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Wear 2.0引入了独立应用程序。Wear应用足够强大，可以在没有移动应用支持的情况下运行。在必须要有移动应用的紧急情况下，Wear应用可以指导用户安装移动支持应用和相应的Wear应用，通过以下步骤：
- en: 'Use `CapabilityApi` to check whether your phone app is installed on the paired
    phone. For more information, check this sample by Google: [https://github.com/googlesamples/android-WearVerifyRemoteApp.](https://github.com/googlesamples/android-WearVerifyRemoteApp)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CapabilityApi`检查你的手机应用是否已安装在配对的手机上。更多信息，请查看谷歌提供的这个示例：[https://github.com/googlesamples/android-WearVerifyRemoteApp.](https://github.com/googlesamples/android-WearVerifyRemoteApp)
- en: If your phone app isn't installed on the phone, use `PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`
    to check what type of phone it is.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的手机应用没有安装在手机上，使用`PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`来检查它是什么类型的手机。
- en: If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE` is returned `true`
    which addresses that Playstore is installed in the phone.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回`PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE`为`true`，表示手机中已安装Play商店。
- en: Call `RemoteIntent.startRemoteActivity()` on the Wear device to open the Play
    Store on the phone using the market URI ([market://details?id=com.example.android.wearable.wear.finddevices](http://use%20a%20market%20URI%20such%20as:%20market://details?id=com.example.android.wearable.wear.finddevices)).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wear设备上调用`RemoteIntent.startRemoteActivity()`，使用市场URI（[market://details?id=com.example.android.wearable.wear.finddevices](http://use%20a%20market%20URI%20such%20as:%20market://details?id=com.example.android.wearable.wear.finddevices)）在手机上打开Play商店。
- en: 'If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE` is returned, it
    means that the phone is likely an iOS phone (with no Play Store available). Open
    the App Store on the iPhone by calling `RemoteIntent.startRemoteActivity()` on
    the Wear device with this URI: [https://itunes.apple.com/us/app/yourappname](https://itunes.apple.com/us/app/yourappname).
    Also, see opening a URL from a watch. On an iPhone, from Android Wear, you cannot
    programmatically determine if your phone app is installed. As a best practice,
    provide a mechanism to the user (for example, a button) to manually trigger the
    opening of the App Store.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回`PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE`，这意味着该手机很可能是iOS手机（没有Play商店）。通过在Wear设备上调用`RemoteIntent.startRemoteActivity()`并使用此URI打开iPhone上的App
    Store：[https://itunes.apple.com/us/app/yourappname](https://itunes.apple.com/us/app/yourappname)。也请参阅从手表打开URL。在iPhone上，从Android
    Wear，你无法编程确定你的手机应用是否已安装。作为最佳实践，为用户提供一种机制（例如，一个按钮），以手动触发打开App Store。
- en: 'For a more detailed understanding about standalone applications, do check out
    the following link: [https://developer.android.com/wear/preview/features/standalone-apps.html.](https://developer.android.com/wear/preview/features/standalone-apps.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 若要更详细地了解独立应用，请查看以下链接：[独立应用介绍](https://developer.android.com/wear/preview/features/standalone-apps.html)
- en: Keeping your application active on a Wear device
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Wear 设备上保持应用活跃
- en: When we write an application for different contexts, we need to do certain alternatives.
    We know that when not using the application, we should make that app to sleep
    in Wear devices for better battery performance, but when we are building an application
    for maps, it is necessary that maps be visible and active for the user.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为不同的使用场景编写应用时，需要做出一些调整。我们知道，在不使用应用时，应该让应用在 Wear 设备上进入休眠状态，以获得更好的电池性能；但是，当我们为地图构建应用时，有必要让地图对用户可见且处于活跃状态。
- en: 'Android has a simple configuration for this: a method with few lines that activates
    the ambient mode:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Android 为此提供了一个简单的配置：一个激活环境模式的几行代码方法：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This starts the ambient mode on the map. The API swaps to a non-interactive
    and low-color rendering of the map when the user is no longer actively using the
    app:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在地图上启动环境模式。当用户不再积极使用应用时，API 切换到非交互式和低色彩渲染的地图：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following code exits the ambient mode on the WearMap. The API swaps to
    the normal rendering of the map when the user starts actively using the app:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码在 WearMap 上退出了环境模式。当用户开始积极使用应用时，API 切换到地图的正常渲染：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Configuring WAKE_LOCK for your application
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的应用配置 WAKE_LOCK
- en: Few Wear applications are very useful when they are constantly visible. Making
    an app constantly visible has an impact on battery life, so you should carefully
    consider that impact when adding this feature to your app.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些 Wear 应用始终可见时，它们非常有用。让应用始终可见会影响电池寿命，因此在你添加此功能到应用时，应仔细考虑这一影响。
- en: 'Add the `WAKE_LOCK` permission to manifest:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中添加 `WAKE_LOCK` 权限：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead of using the Input method framework for reading the input, users can
    also use the voice input, which requires active internet on your Wear device:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用语音输入，而不是使用输入法框架读取输入，这需要在你的 Wear 设备上保持网络活跃：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Understanding fully interactive mode and lite mode
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解完全交互模式和精简模式
- en: The Google Maps android API can serve static images as light mode maps.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps 安卓 API 可以作为精简模式地图提供静态图片。
- en: 'Adding Lite mode to Android Maps is similar to configuring the normal maps,
    because it will use the same classes and interfaces. We can set Google Maps to
    the Lite mode in the following two ways:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Android 地图添加精简模式与配置正常地图类似，因为它将使用相同的类和接口。我们可以通过以下两种方式设置 Google 地图为精简模式：
- en: As an XML attribute to your `MapView` or `MapFrgament`
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `MapView` 或 `MapFrgament` 的 XML 属性
- en: Using the `GoogleMapOptions` object
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GoogleMapOptions` 对象
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Or, using the `GoogleMapOptions` object as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，按照以下方式使用 `GoogleMapOptions` 对象：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Interactive mode allows the application to use all the lifecycle methods, including
    `onCreate()`, `onDestroy()`, `onResume()`, and `onPause()`, and all the Google
    API features to make the application fully interactive. As a cost, there will
    be a network dependency.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 交互模式允许应用使用所有的生命周期方法，包括 `onCreate()`、`onDestroy()`、`onResume()` 和 `onPause()`，以及所有
    Google API 功能，使应用完全交互。相应的代价是会有网络依赖。
- en: 'For more information about Interactive and Lite mode, check the following link:
    [https://developers.google.com/maps/documentation/android-api/lite.](https://developers.google.com/maps/documentation/android-api/lite)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有关交互模式和精简模式的更多信息，请查看以下链接：[交互与精简模式](https://developers.google.com/maps/documentation/android-api/lite)
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Here, we are at the chapter's end, looking forward to what improvements we can
    do in the WearMapDiary app. Now, we know about creating a `MapsActivity`, setting
    up the maps and Google API key, configuring Google Play services in a Wear emulator,
    runtime permissions check, checking for the GPS hardware, and fetching the location
    name using the `geocoder` class. We have understood the concept of the interactive
    mode and Lite mode for maps. In the next chapter, let's understand more Wear and
    map UI controls and other Google Map technologies, such as streetview, changing
    the map types, and so on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经来到了章节的末尾，期待着对WearMapDiary应用进行改进。现在，我们了解了如何创建一个`MapsActivity`，设置地图和Google
    API密钥，配置Wear模拟器中的Google Play服务，运行时权限检查，检查GPS硬件，以及使用`geocoder`类获取位置名称。我们已经理解了地图的交互模式和Lite模式的概念。在下一章中，让我们进一步了解Wear和地图用户界面控件以及其他Google地图技术，例如街景，更改地图类型等等。
