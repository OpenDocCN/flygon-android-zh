- en: Chapter 2. Tappy Defender – First Step
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章．Tappy Defender – 起步
- en: Welcome to the first game, which we will learn about in three chapters. In this
    chapter, we will closely examine the goals for the finished product. It helps
    a lot when building a game, if we know exactly what we are trying to achieve.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们将在三章内了解的第一个游戏。在本章中，我们将详细审视最终产品的目标。如果我们确切知道我们试图实现什么，那么在构建游戏时会非常有帮助。
- en: We can then look at the structure of our code, including an approximate design
    pattern that we will be adhering to. Then, we will put together the code skeleton
    of our first game engine. Finally, to finish the chapter, we will draw our first
    real object from the game and animate it on the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看看我们代码的结构，包括我们将遵循的近似设计模式。接着，我们将组装我们第一个游戏引擎的代码框架。最后，为了完成本章，我们将绘制游戏中的第一个真实对象，并在屏幕上为其添加动画。
- en: We will then be ready for [Chapter 3](ch03.html "Chapter 3. Tappy Defender –
    Taking Flight"), *Tappy Defender – Taking Flight*, where we can make really fast
    progress before completing our first game in [Chapter 4](ch04.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将准备好进入[第三章](ch03.html "第三章．Tappy Defender – 翱翔")，*Tappy Defender – 翱翔*，在那里我们在完成第一个游戏之前可以取得非常快的进展，并在[第四章](ch04.html
    "第四章．Tappy Defender – 回家")，*Tappy Defender – 回家*中完成它。
- en: Planning the first game
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划第一个游戏
- en: In this section, we will flesh out exactly what our game will be. The backstory;
    who is our hero and what are they trying to achieve? The game mechanics; what
    will the player actually do? What buttons will he press and in what way is that
    a challenge or fun thing to do? Then, we will look at the rules. What constitutes
    victory, death, and progress? Finally, we will get technical and start to examine
    how we will actually build the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细阐述我们的游戏将会是什么样子。背景故事；谁是我们的英雄，他们试图实现什么？游戏机制；玩家实际上会做什么？他会按哪些按钮，这种方式有何挑战性或乐趣？然后，我们将看看规则。什么构成了胜利、死亡和进步？最后，我们将从技术角度出发，开始探讨我们实际上将如何构建这个游戏。
- en: Backstory
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景故事
- en: Valerie has been defending the far outposts of humanity since the early '80s.
    Her brave exploits were originally immortalized in the 1981 arcade classic, Defender.
    However, after over 30 years on the front line, she is retiring and it is time
    to begin the journey home. Unfortunately, in a recent skirmish, her ship's engines
    and navigation systems were severely damaged. Therefore, now she must fly all
    the way home using only her boost thruster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦莱丽自20世纪80年代初以来一直在保卫人类的遥远前哨。她勇敢的壮举最初在1981年的街机经典游戏《Defender》中被永远铭记。然而，在30多年的前线生涯后，她即将退休，是时候开始回家的旅程了。不幸的是，在最近的一次小规模战斗中，她的飞船引擎和导航系统受到了严重损坏。因此，现在她必须仅使用她的推进器飞回家。
- en: This means that she must fly her ship by simultaneously thrusting up and forward,
    kind of bouncing really, while avoiding enemies who try to crash into her. In
    a recent communication with Earth, Valerie was heard to claim that it was, "Like
    trying to fly a lame bird." This is some concept art of Valerie in her damaged
    ship because it helps to visualize our game as early as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着她必须通过同时向上和向前推进，有点像是在弹跳，同时避开试图撞击她的敌人来驾驶她的飞船。在最近与地球的通讯中，瓦莱丽表示这就像是在“尝试驾驶一只跛脚的鸟”。这是瓦莱丽在她的受损飞船中的概念艺术，因为这样有助于我们尽早可视化我们的游戏。
- en: '![Backstory](img/B04322_02_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![背景故事](img/B04322_02_01.jpg)'
- en: Now that we have learned a little bit about our hero and her predicament, we
    take a closer look at the mechanics of the game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对我们的英雄和她的困境有了一些了解，我们将更仔细地看看游戏机制。
- en: The game mechanics
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏机制
- en: Mechanics are the key actions that a player must make and become good at, to
    be able to beat the game. When designing a game, you can rely on tried and tested
    ideas for mechanics or you can invent your own. In Tappy Defender, we will be
    using a mechanic where the player taps and holds the screen to boost the ship.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 机制是玩家必须掌握并熟练的关键动作，以能够通关游戏。在设计游戏时，你可以依赖经过尝试和测试的机制想法，或者你可以发明自己的。在Tappy Defender中，我们将使用一种机制，玩家通过轻敲并按住屏幕来推进飞船。
- en: This boosting will raise the ship up the screen, but will also make the ship
    speed up and therefore be more vulnerable. When the player removes their finger,
    the boost engine will cut out and the ship will fall downward and decelerate,
    thus making the ship slightly less vulnerable. Therefore, a very fine and masterful
    balance of boosting and not boosting is required to survive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加速功能会将飞船向上提升，但同时也会让飞船加速，因此更容易受到攻击。当玩家移开手指，加速引擎会关闭，飞船会向下坠落并减速，从而使得飞船稍微不那么脆弱。因此，为了生存，需要非常精细和熟练地平衡加速和不加速。
- en: Tappy Defender is of course heavily inspired by Flappy Bird and a multitude
    of similar games that followed its success.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Tappy Defender当然深受Flappy Bird以及其成功后涌现的大量类似游戏的启发。
- en: Instead of a how-far-can-I-get scoring system like Flappy Bird, Tappy Defender
    will have a goal of reaching "home". Then, the player can replay the game multiple
    times in order to try and beat their fastest time. Of course to go faster, the
    player must boost more frequently and put Valerie in greater peril.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flappy Bird的“我能走多远”计分系统不同，Tappy Defender的目标是到达“家”。然后，玩家可以多次重玩游戏，试图打破他们的最快时间。当然，为了更快，玩家必须更频繁地加速，并让Valerie面临更大的危险。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the unlikely event you have never played or seen Flappy Bird, it is well
    worth spending 5 minutes having a play with this type of game now. You can download
    one of the many Flappy Bird inspired apps from the Google Play store:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未玩过或见过Flappy Bird，花5分钟玩玩这类游戏是非常值得的。你可以从Google Play商店下载一个受Flappy Bird启发的应用程序：
- en: '[https://play.google.com/store/search?q=flappy%20bird&c=apps](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[在Google Play商店搜索Flappy Bird](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
- en: Rules for the game
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: 'Here, we will define things which balance the game and make it fair and consistent
    for the player:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一些平衡游戏并使其对玩家公平和一致的事物：
- en: The player's ship is much tougher than the enemy ships. This is because the
    player's ship has shields. Each time the player collides with an enemy, the enemy
    is instantly destroyed, but the player loses a shield. The player has three shields.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的飞船比敌人的飞船要坚固得多。这是因为玩家的飞船有护盾。每次玩家与敌人相撞，敌人会被立即摧毁，但玩家会失去一个护盾。玩家有三个护盾。
- en: The player will need to fly a set number of kilometers to reach home.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家需要飞行一定的公里数才能到达家中。
- en: Every time the player reaches home, they win the game. If their time was the
    fastest, they also get a new fastest time, like a high score.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次玩家到达家中，他们就赢得了游戏。如果他们用时最短，他们还会获得一个新的最快时间，就像是一个高分。
- en: Enemies will spawn at a random height on the far right of the screen and fly
    toward the player at a random speed.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将在屏幕最右侧的随机高度生成，并以随机速度向玩家飞行。
- en: The player is always positioned on the far left of the screen, but boosting
    will mean the enemies approach more quickly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家始终位于屏幕最左侧，但加速意味着敌人会更快地接近。
- en: The design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计理念
- en: We will use a loose design pattern, where we will separate our code based on
    a control part, model part, and view. This is how we will separate our code into
    three areas.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个宽松的设计模式，根据控制部分、模型部分和视图来分离我们的代码。这是我们如何将代码分为三个区域的方法。
- en: Control
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制
- en: This is the part of our code that will control all other parts. It will decide
    when to show the view, it will initialize all our game objects from the model,
    and it will prompt decisions based on the states of data to take place within
    the model.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的代码部分，它将控制所有其他部分。它将决定何时显示视图，它将初始化模型中的所有游戏对象，并根据数据的状况提示模型中发生的数据决策。
- en: Model
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: The model is our game data and logic. What do the ships look like? Where on
    the screen are our ships? How fast are they going, and so on. Furthermore, the
    model part of our code is the intelligence system for each of our game objects.
    Although our enemies in this game don't have sophisticated AI, they will know
    and decide for themselves how fast they are going, when to respawn and more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是我们的游戏数据和逻辑。飞船长什么样？它们在屏幕的哪个位置？它们移动得多快等等。此外，我们代码中的模型部分是每个游戏对象的智能系统。尽管这个游戏中的敌人没有复杂的AI，但它们会自行判断它们的速度、何时重生等。
- en: View
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: The view is exactly what it sounds like. It is the part of our code that will
    do the actual drawing based on the state of the models. It will draw when the
    control part of our code tells it. It will not have any influence over the game
    objects. For example, the view will not decide where an object is or even what
    it looks like. It just draws and then hands control back to the control code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 视图（View）正如其名所示，它是根据模型的状态进行实际绘制的代码部分。当控制代码告诉它时，它将进行绘制。它不会对游戏对象有任何影响。例如，视图不会决定一个对象在哪里，甚至它看起来是什么样子。它只是绘制，然后将控制权交还给控制代码。
- en: Design pattern reality check
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计模式现实检查
- en: In reality, the separation is not as clear as the discussion suggests. In fact,
    the code for drawing and control is within the same class. However, you will see
    that the logic of drawing and controlling is separate within that class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种分离并不像讨论中那么清晰。实际上，绘制和控制代码在同一个类中。但是，你会发现，即使在这个类中，绘制和控制的逻辑是分开的。
- en: By separating our game into these three parts, we will see how we simplify the
    development and avoid getting tied up in messy code that constantly expands as
    we add new features to our game.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将游戏分为这三个部分，我们可以看到如何简化开发过程，并避免在添加新功能时代码不断膨胀，变得混乱。
- en: Let's look more closely at where this pattern fits in with our code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这种模式如何与我们的代码契合。
- en: The game code structure
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏代码结构
- en: First of all, we must take account of the system we are working within. In this
    case, it is the Android system. If you have been making Android apps for a while,
    you may be wondering where this pattern stuff fits in with the Android Activity
    lifecycle. If you are new to Android, you might ask what the Activity lifecycle
    is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须考虑到我们所工作的系统。在这个案例中，它是安卓系统。如果你已经开发了一段时间的安卓应用，你可能会想知道这种模式与安卓Activity生命周期如何契合。如果你是安卓开发新手，你可能会问Activity生命周期是什么。
- en: The Android Activity lifecycle
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安卓Activity生命周期
- en: The Android Activity lifecycle is the framework we must work within to make
    any type of Android app. There is a class called `Activity` that we must derive
    from and is an entry point to our app. In addition, we need to be aware that this
    class, that our game is an object of, also has some methods we can override. These
    methods control the lifecycle of our app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓Activity生命周期是我们必须遵循的框架，以制作任何类型的安卓应用。有一个名为`Activity`的类，我们必须从中派生，它是我们应用的入口点。此外，我们需要知道这个类，我们的游戏是其对象，还有一些我们可以覆盖的方法。这些方法控制着应用的生命周期。
- en: When an app is started by the user, our `Activity` object is created and a number
    of the methods that we can override are called in sequence. This is what happens.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动一个应用时，我们的`Activity`对象将被创建，并且可以覆盖的一系列方法将按顺序被调用。以下是发生的情况。
- en: When the `Activity` object is created, three methods are called in sequence;
    `onCreate()`, `onStart()`, and `onResume()`. At this point, the app is now running.
    In addition, when the user quits an app or the app is interrupted, perhaps by
    a phone call, the `onPause` method is called. The user may decide, perhaps after
    completing their phone call, to return to the app. If this happens, the `onResume`
    method is called, following which the app is running again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`Activity`对象时，将按顺序调用三个方法：`onCreate()`、`onStart()`和`onResume()`。此时，应用正在运行。此外，当用户退出应用或应用被中断，比如一个电话，将调用`onPause`方法。用户可能会决定，在完成电话后返回应用。如果发生这种情况，将调用`onResume`方法，之后应用再次运行。
- en: Should the user not return to the app or the Android system decides that it
    wants the system resources for something else, two further methods are called
    to clean up. First `onStop()`, and then `onDestroy()`. The app is now destroyed
    and any attempt to return to the game again will result in the Activity lifecycle
    starting from the beginning.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有返回应用，或者安卓系统决定需要这些系统资源做其他事情，将调用两个进一步的方法来进行清理。首先是`onStop()`，然后是`onDestroy()`。现在应用已经被销毁，任何尝试返回游戏的行为都将以Activity生命周期的开始为结果。
- en: All we have to do as game programmers is be aware of this lifecycle and observe
    a few rules of good housekeeping. We will implement and explain the rules of good
    housekeeping as we proceed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏程序员，我们必须注意这个生命周期，并遵循一些良好的家务管理规则。在接下来的过程中，我们将实施并解释这些良好的家务管理规则。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Android Activity lifecycle is much more complex and far more nuanced than
    I have just explained it. However, we know everything we need to get programming
    our first game. If you want to know more please have a look at this article on
    the Android developer''s web site at:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓 Activity 生命周期比我刚才所解释的要复杂得多，也更为细致。然而，我们知道开始编程我们第一款游戏所需的一切。如果你想了解更多，请查看安卓开发者网站上的这篇文章：
- en: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
- en: 'Once we have catered for the Android Activity lifecycle, the core methods of
    our class representing the control part of the pattern will be as simple as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们考虑了 Android Activity 生命周期，代表控制部分模式的类核心方法将会像这样非常简单：
- en: Update the state of our game objects.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的游戏对象的状态。
- en: Draw the game objects based on their state.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据它们的状态绘制游戏对象。
- en: Pause to lock the frame rate.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停以锁定帧率。
- en: Get player input. Actually because parts 1, 2, and 3 happen in a thread, this
    part can happen at any time.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取玩家输入。实际上，因为第 1、2 和 3 部分在线程中发生，这部分可以在任何时候进行。
- en: Repeat.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复。
- en: One last bit of preparation, before we start to build our game for real.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正开始构建游戏之前，还有最后一点准备工作。
- en: The Android Studio file structure
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Studio 文件结构
- en: The Android system is quite particular about where we put our class files, including
    `Activity` and where in the file hierarchy we place our assets like sound files
    and graphics.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统非常讲究我们放置类文件的位置，包括`Activity`，以及我们在文件层次结构中放置如声音文件和图像等资源的位置。
- en: Here is a really quick overview of where we will be putting everything. You
    don't need to memorize this, as we will remind ourselves of the correct folder
    while adding assets. We will step through the activity/class creation process
    the first few times we need to do it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常快速的总览，介绍我们将要放置所有内容的地方。你不需要记住这个，因为我们在添加资源时会提醒自己正确的文件夹。在最初几次需要时，我们将逐步完成活动/类创建过程。
- en: 'As a heads up, here is an annotated diagram of what your Android Studio project
    explorer will look like by the end of the Tappy Defender project:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提前告知，以下是你的 Android Studio 项目浏览器在完成 Tappy Defender 项目后看起来会是什么样子的一份注释图解。
- en: '![The Android Studio file structure](img/B04322_02_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio 文件结构](img/B04322_02_02.jpg)'
- en: Now, we can actually start building Tappy Defender.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始构建 Tappy Defender。
- en: Building the home screen
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主屏幕
- en: Since we have done all the planning and preparation, we can get started with
    the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了所有规划和准备工作，我们可以开始编写代码了。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: '**Downloading the example code**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，这些文件对应你购买的所有
    Packt Publishing 的书籍。如果你在其他地方购买了这本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)注册，我们会直接将文件通过电子邮件发送给你。
- en: To use the code files, you will still need to create an Android Studio project.
    In addition, you will need to change the package name in the very first line of
    code of each of the JAVA files. Change the package name to match the package name
    of the project you created. Finally, you will need to make sure that any assets
    such as images or sound files are placed into the appropriate folder in the project.
    All the required assets for each project are supplied in the download bundle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用代码文件，你仍然需要创建一个 Android Studio 项目。此外，你还需要更改每个 JAVA 文件代码第一行的包名。将包名更改为与你创建的项目相匹配的包名。最后，你需要确保将任何资源（如图片或声音文件）放置到项目中的适当文件夹。每个项目所需的资源在下载包中都有提供。
- en: Creating the project
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: Fire up Android Studio and create a new project by following these steps. All
    the files to get the project to where we will be, by the end of this chapter,
    are in the download bundle in the `Chapter2` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Android Studio 并按照以下步骤创建一个新项目。到本章结束时，我们将要使用的所有文件都可以在下载包中的 `Chapter2` 文件夹找到。
- en: On the **Welcome to Android Studio** dialog, click on **Start a new Android
    Studio project**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**欢迎来到 Android Studio**对话框中，点击**开始一个新的 Android Studio 项目**。
- en: In the **Create New Project** window shown next, we need to enter some basic
    information about our app. These bits of information will be used by Android Studio
    to determine the package name.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来显示的**创建新项目**窗口中，我们需要输入一些关于我们应用的基本信息。这些信息将被Android Studio用来确定软件包名称。
- en: Note
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following image, you can see the **Edit** link where you can customize
    the package name if required.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到**编辑**链接，如果需要，你可以在这里自定义软件包名称。
- en: If you will be copy/pasting the supplied code into your project, then use `C1
    Tappy Defender` for the **Application name** field and `gamecodeschool.com` in
    the **Company Domain** field as shown in the following screenshot:![Creating the
    project](img/B04322_02_03.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将提供的代码复制粘贴到你的项目中，那么在**应用名称**字段中使用`C1 Tappy Defender`，在**公司域名**字段中使用`gamecodeschool.com`，如下截图所示：![创建项目](img/B04322_02_03.jpg)
- en: Click on the **Next** button when you're ready. When asked to select the form
    factors, your app will run on, we can accept the default settings (**Phone and
    Tablet**). So click on **Next** again.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好之后，点击**下一步**按钮。当被问及选择应用将运行的表单因素时，我们可以接受默认设置（**手机和平板电脑**）。因此再次点击**下一步**。
- en: On the **Add an activity to mobile** dialog, just click on **Blank Activity**
    followed by the **Next** button.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**向移动设备添加活动**对话框中，只需点击**空白活动**，然后点击**下一步**按钮。
- en: On the **Customize the Activity** dialog, again we can accept the default settings
    because `MainActivity` seems like a good name for our main Activity. So click
    on the **Finish** button.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**自定义活动**对话框中，我们再次可以接受默认设置，因为`MainActivity`看起来是我们主活动的不错名称。所以点击**完成**按钮。
- en: What we did
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的操作步骤
- en: Android Studio has built the project and created a number of files, most of
    which we will see and edit during the course of building this game. As mentioned
    earlier, even if you are just copying and pasting the code, you need to go through
    this step because Android Studio is doing things behind the scenes to make our
    project work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio已经构建了项目并创建了许多文件，我们将在构建这个游戏的过程中看到并编辑其中大部分文件。正如前面提到的，即使你只是复制粘贴代码，也需要完成这一步，因为Android
    Studio在幕后做了很多工作，以确保我们的项目能够运行。
- en: Building the home screen UI
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建主屏幕用户界面
- en: 'The first and simplest part of our Tappy Defender game is the home screen.
    All we need is a neat picture with a scene about the game, a high score, and a
    button to start the game. The finished home screen will look a bit like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Tappy Defender游戏的第一部分也是最为简单的部分就是主屏幕。我们需要的只是一个整洁的画面，包含有关游戏场景、最高分和开始游戏的按钮。完成后的主屏幕大致会是这样：
- en: '![Building the home screen UI](img/B04322_02_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![构建主屏幕用户界面](img/B04322_02_04.jpg)'
- en: 'When we built the project, Android Studio opens up two files ready for us to
    edit. You can see them as tabs in the following Android Studio UI designer. The
    files (and tabs) are `MainActivity.java` and `activity_main.xml`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建项目时，Android Studio会打开两个文件供我们编辑。你可以在以下Android Studio UI设计师的标签中看到它们。这些文件（以及标签）是`MainActivity.java`和`activity_main.xml`：
- en: '![Building the home screen UI](img/B04322_02_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![构建主屏幕用户界面](img/B04322_02_05.jpg)'
- en: The `MainActivity.java` file is the entry point to our game, and we will see
    this in more detail soon. The `activity_main.xml` file is the UI layout that our
    home screen will use. Now, we can go ahead and edit the `activity_main.xml` file,
    so it actually looks like our home screen should.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity.java`文件是我们游戏的入口点，我们很快会详细看到这一点。`activity_main.xml`文件是我们主屏幕将使用的UI布局。现在，我们可以继续编辑`activity_main.xml`文件，使其看起来像我们的主屏幕应该有的样子。'
- en: First of all, your game will be played with the Android device in landscape
    mode. If we change our UI preview window to landscape, we will see your progress
    more accurately. Look for the button shown in the next image. It is just preceding
    the UI preview:![Building the home screen UI](img/B04322_02_06.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你的游戏将在横屏模式下通过Android设备进行游戏。如果我们把UI预览窗口改为横屏，我们将会更准确地看到你的进度。寻找下一个图像中显示的按钮。它就在UI预览之前：![构建主屏幕用户界面](img/B04322_02_06.jpg)
- en: Click on the button shown in the preceding screenshot, and your UI preview will
    switch to landscape like this:![Building the home screen UI](img/B04322_02_07.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击前一个截图中显示的按钮，你的UI预览将切换到横屏，如下所示：![构建主屏幕用户界面](img/B04322_02_07.jpg)
- en: Make sure `activity_main.xml` is open by clicking on its tab.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过点击其标签打开`activity_main.xml`。
- en: Now, we will set in a background image. You can use your own or mine from `Chapter2/drawable/background.jpg`
    in the download bundle. Add your chosen image to the `drawable` folder of the
    project in Android Studio.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个背景图片。你可以使用自己的图片，或者使用下载包中`Chapter2/drawable/background.jpg`的我的图片。将你选择的图片添加到Android
    Studio中项目的`drawable`文件夹中。
- en: In the **Properties** window of the UI designer, find and click on the **background**
    property as shown in the next image:![Building the home screen UI](img/B04322_02_08.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI设计师的**属性**窗口中，找到并点击**background**属性，如下一个图像所示：![构建主屏幕UI](img/B04322_02_08.jpg)
- en: Also, in the previous image the button labelled **...** is outlined. It is just
    to the right of the **background** property. Click on that **...** button and
    browse to and select the background image file that you will be using.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在上一张图片中，标记为**...**的按钮被圈出。它位于**background**属性的右侧。点击那个**...**按钮，浏览并选择你将使用的背景图片文件。
- en: Next, we need a **TextView** widget that we will use to display the high score.
    Note that there is already a **TextView** widget on the layout. It says **Hello
    World**. You will modify this and use it for our high score. Left click on it
    and drag the **TextView** to where you want it. You can copy me if you intend
    using the supplied background or put it where it looks best with your background.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个**TextView**小部件，用来显示高分。注意，布局中已经有一个**TextView**小部件，显示的是**Hello World**。你会修改这个，将其用于我们的高分显示。左键点击它，并将**TextView**拖动到你想要的位置。如果你打算使用提供的背景，可以参考我的操作，或者将其放置在你背景上最佳的位置。
- en: Next, in the **Properties** window, find and click on the **id** property. Enter
    `textHighScore`. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it, to show
    the player's fastest time.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**属性**窗口中找到并点击**id**属性。输入`textHighScore`。务必按照显示的格式输入，因为在后面的教程中编写一些Java代码时，我们将引用这个ID以便操作它，显示玩家的最快时间。
- en: 'You can also edit the **text** property to say `High Score: 99999` or similar
    so that the **TextView** looks the part. However, this isn''t necessary because
    your Java code will take care of this later.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你还可以编辑**text**属性，使其显示为`High Score: 99999`或类似的文字，以便**TextView**看起来更合适。但这不是必须的，因为你的Java代码稍后会处理这个问题。'
- en: Now, we will drag a button from the widget palette as shown in the following
    screenshot:![Building the home screen UI](img/B04322_02_09.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按照以下截图所示从窗口小部件调色板中拖动一个按钮：![构建主屏幕UI](img/B04322_02_09.jpg)
- en: Drag it to where it looks good on your background. You can copy me if using
    the supplied background or put it where it looks best with your background.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖动到背景上看起来合适的位置。如果你使用提供的背景，可以参考我的操作，或者将其放置在你背景上最佳的位置。
- en: What we did
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的操作
- en: We now have a cool background with neatly arranged widgets (a **TextView** and
    a **Button**) for your home screen. We can add functionality via Java code to
    the **Button** widget next. Revisit the **TextView** for the player's high score
    in [Chapter 4](ch04.html "Chapter 4. Tappy Defender – Going Home"), *Tappy Defender
    – Going Home*. The important point is that both the widgets have been assigned
    a unique ID that we can use to reference and manipulate in your Java code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个酷炫的背景，以及为你主屏幕整齐排列的小部件（一个**TextView**和一个**Button**）。接下来，我们可以通过Java代码为**Button**小部件添加功能。在[第4章](ch04.html
    "第4章. Tappy Defender – Going Home") *Tappy Defender – Going Home*中重新访问玩家的最高分数**TextView**。重要的是，这两个小部件都被分配了一个唯一的ID，我们可以在你的Java代码中引用并操作它。
- en: Coding the functionality
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写功能代码
- en: Now, we have a simple layout for our game home screen. Now, we need to add the
    functionality that will allow the player to click on the **Play** button to start
    the game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为游戏主屏幕创建了一个简单的布局。接下来，我们需要添加功能，允许玩家点击**播放**按钮来开始游戏。
- en: Click on the tab for the `MainActivity.java` file. The code that was automatically
    generated for us is not exactly what we need. Therefore, we will start again as
    it is simpler and quicker than tinkering with what is already there.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`MainActivity.java`文件的标签页。自动为我们生成的代码并不是完全符合我们需要的。因此，我们将重新开始，因为这比调整现有的东西更简单、更快。
- en: Delete the entire contents of the `MainActivity.java` file except the package
    name and enter the following code in it. Of course, your package name may be different.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`MainActivity.java`文件中的全部内容，除了包名，并在其中输入以下代码。当然，你的包名可能有所不同。
- en: '[PRE0]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mentioned code is the current contents of our main `MainActivity` class
    and the entry point of our game, the `onCreate` method. The line of code that
    begins with `setContentView...` is the line that loads our UI layout from `activity_main.xml`
    to the players screen. We can run the game now and see our home screen, but let's
    make some more progress, following which we will look at how we run the game on
    a real device at the end of the chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所提及的代码是我们主要的`MainActivity`类的当前内容，也是我们游戏的入口点，即`onCreate`方法。以`setContentView...`开头的代码行是将我们的UI布局从`activity_main.xml`加载到玩家屏幕的代码。现在我们可以运行游戏并查看主屏幕，但让我们继续取得更多进展，本章末尾我们将了解如何在实际设备上运行游戏。
- en: Now, let's handle the **Play** button on our home screen. Add the two highlighted
    lines of the following code into the `onCreate` method just after the call to
    `setContentView()`. The first new line creates a new `Button` object and gets
    a reference to `Button` in our UI layout. The second line is the code that listens
    for clicks on the button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理主屏幕上的**播放**按钮。将下面高亮的两行代码添加到`onCreate`方法中，紧跟在`setContentView()`调用之后。第一行新代码创建了一个新的`Button`对象，并获取了UI布局中`Button`的引用。第二行是监听按钮点击的代码。
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we have a few errors in our code. We can resolve these errors by holding
    down the *Alt* keyboard key and then pressing *Enter*. This will add an import
    directive for the `Button` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的代码中有几个错误。我们可以通过按住*Alt*键然后按*Enter*来解决这些错误。这将添加对`Button`类的导入指令。
- en: 'We still have one error. We need to implement an interface so that our code
    listens to the button clicks. Modify the `MainActivity` class declaration as highlighted:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个错误。我们需要实现一个接口，以便我们的代码监听按钮点击。按照高亮显示的方式修改`MainActivity`类的声明：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we implement the `onClickListener` interface, we must also implement the
    `onClick` method. This is where we will handle what happens when a button is clicked.
    We can automatically generate the `onClick` method by right-clicking somewhere
    after the `onCreate` method, but within the `MainActivity` class, and navigating
    to **Generate** | **Implement methods** | **onClick(v:View):void. Or just add
    the given code.**
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`onClickListener`接口时，我们还必须实现`onClick`方法。这里就是处理按钮点击后发生情况的地方。我们可以在`onCreate`方法之后，但在`MainActivity`类内右键点击，导航到**Generate**
    | **Implement methods** | **onClick(v:View):void**来自动生成`onClick`方法，或者直接添加给定的代码。
- en: We also need to have Android Studio add another import directive for `Android.view.View`.
    Use the *Alt* | *Enter* keyboard combination again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要让Android Studio为`Android.view.View`添加另一个导入指令。再次使用*Alt* | *Enter*键盘组合。
- en: 'We can now scroll to near the bottom of the `MainActivity` class and see that
    Android Studio has implemented an empty `onClick` method for us. We should have
    no errors in your code at this point. Here is the `onClick` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以滚动到`MainActivity`类的底部附近，可以看到Android Studio已经为我们实现了一个空的`onClick`方法。此时你的代码中应该没有错误。以下是`onClick`方法：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we only have one `Button` object and one listener, we can safely assume that
    any clicks on our home screen are the player pressing our **Play** button.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个`Button`对象和一个监听器，我们可以安全地假设主屏幕上的任何点击都是玩家点击我们的**播放**按钮。
- en: 'Android uses the `Intent` class to switch between activities. As we need to
    go to a new activity when the **Play** button is clicked, we will create a new
    `Intent` object and pass in the name of our future `Activity` class, `GameActivity`
    to its constructor. We can then use the `Intent` object to switch activities.
    Add the following code to the body of the `onClick` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用`Intent`类在活动之间切换。由于我们需要在点击**播放**按钮时进入一个新的活动，我们将创建一个新的`Intent`对象，并将其构造函数中传入我们未来的`Activity`类名，`GameActivity`。然后我们可以使用`Intent`对象来切换活动。将以下代码添加到`onClick`方法的主体中：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again, we have errors in our code because we need to generate a new import
    directive, this time for the `Intent` class so use the *Alt* | *Enter* keyboard
    combination again. We still have one error in our code. This is because our `GameActivity`
    class does not exist yet. We will now solve this problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中再次出现了错误，因为我们需要生成一个新的导入指令，这次是为`Intent`类，所以再次使用*Alt* | *Enter*键盘组合。我们代码中还有一个错误。这是因为我们的`GameActivity`类尚未存在。我们现在将解决这个问题。
- en: Creating GameActivity
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GameActivity
- en: We have seen that when the player clicks on the **Play** button, main activity
    will close and game activity will begin. Therefore, we need to create a new activity
    called `GameActivity` that will be were your game actually executes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当玩家点击**播放**按钮时，主活动将关闭，游戏活动将开始。因此，我们需要创建一个名为`GameActivity`的新活动，你的游戏实际上将在这里执行。
- en: From the main menu, navigate to **File** | **New** | **Activity** | **Blank
    Activity**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单导航到**文件** | **新建** | **活动** | **空白活动**。
- en: In the **Customize the Activity** dialog, change the **Activity Name** field
    to `GameActivity`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**自定义活动**对话框中，将**活动名称**字段更改为`GameActivity`。
- en: We can accept all the other default settings from this dialog, so click on **Finish**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以接受此对话框中的其他默认设置，所以点击**完成**。
- en: As we did with your `MainActivity` class, we will code this class from scratch.
    Therefore, delete the entire code content from `GameActivity.java`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们对`MainActivity`类所做的那样，我们将从这个类开始编写代码。因此，删除`GameActivity.java`中的所有代码内容。
- en: What we did
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的操作
- en: Android Studio has generated two more files for us and done some work behind
    the scenes that we will investigate soon. The new files are `GameActivity.java`
    and `activity_game.xml`. They are both automatically opened for us in two new
    tabs, in the same place as the other tabs above the UI designer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio为我们生成了两个新文件，并在幕后完成了一些工作，我们很快就会研究这些内容。新文件是`GameActivity.java`和`activity_game.xml`。它们都会在UI设计师上方的两个新标签页中自动打开。
- en: We will never need `activity_game.xml` because we will build a dynamically generated
    game view, not a static UI. Feel free to close that now or just ignore it. We
    will come back to the `GameActivity.java` file, when we start to code our game
    for real, later in the chapter in the *Coding the game loop* section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不需要`activity_game.xml`，因为我们将构建一个动态生成的游戏视图，而不是静态UI。现在可以关闭它，或者直接忽略。在*编写游戏循环代码*部分，我们将在本章后面真正开始编写游戏代码时回到`GameActivity.java`文件。
- en: Configuring the AndroidManifest.xml file
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置`AndroidManifest.xml`文件
- en: We briefly mentioned that when we create a new project or a new activity, Android
    Studio does more than just creating two files for us. This is why we create new
    projects/activities the way we do.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，当我们创建新项目或新活动时，Android Studio不仅仅是为我们创建两个文件。这就是为什么我们要以这种方式创建新项目/活动。
- en: One of the things going on behind the scenes is the creation and modification
    of the `AndroidManifest.xml` file in the `manifests` directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后发生的一件事是在`manifests`目录中创建和修改`AndroidManifest.xml`文件。
- en: This file is required for our app to work. Also, it needs to be edited to make
    our app work the way we want it to. Android Studio has automatically configured
    the basics for us, but we will now do two more things to this file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序要运行需要这个文件。同时，它还需要被编辑，以便按照我们的意愿工作。Android Studio已经为我们自动配置了基本内容，但现在我们将对这个文件进行两项额外的操作。
- en: 'By editing the `AndroidManifest.xml` file, we will force both of our activities
    to run with a full screen, and we will also lock them to a landscape layout. Let''s
    make these changes here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`AndroidManifest.xml`文件，我们将强制我们的两个活动全屏运行，并且我们将它们锁定为横屏布局。让我们在这里进行这些更改：
- en: Open the `manifests` folder now, and double click on the `AndroidManifest.xml`
    file to open it in the code editor.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`manifests`文件夹，双击`AndroidManifest.xml`文件，在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE5]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Immediately following it, type or copy and paste these two lines to make `MainActivity`
    run full screen and lock it in the landscape orientation:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，输入或复制粘贴以下两行代码，使`MainActivity`全屏运行并锁定为横屏方向：
- en: '[PRE6]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE7]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Immediately following it, type or copy and paste these two lines to make `GameActivity`
    run full screen and lock it in the landscape orientation:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，输入或复制粘贴以下两行代码，使`GameActivity`全屏运行并锁定为横屏方向：
- en: '[PRE8]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What we did
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的操作
- en: We have now configured both activities from our game to be full screen. This
    presents a much more pleasing appearance to our player. In addition, we have disabled
    the player's ability to affect our game by rotating their Android device.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已将游戏的两个活动配置为全屏。这为我们的玩家提供了更加愉悦的外观。此外，我们还取消了玩家通过旋转他们的Android设备影响我们游戏的能力。
- en: Coding the game loop
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏循环代码
- en: We said that we will not be using a UI layout for our game screen, but instead
    a dynamically drawn view. This is where the view of our pattern comes in. Let's
    create a new class to represent our view, then we will put in the fundamental
    building blocks of our Tappy Defender game.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，我们的游戏屏幕不使用UI布局，而是动态绘制的视图。这就是我们模式中的视图部分。让我们创建一个新类来表示我们的视图，然后我们将放入“Tappy
    Defender”游戏的基本构建块。
- en: Building the view
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建视图
- en: We will leave our two activity classes alone for a while so that we can take
    a look at our class that will represent the view of our game. As we discussed
    at the start of this chapter, the view and the controller aspects will be part
    of the same class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时不处理两个活动类，这样我们就可以看看将代表游戏视图的类。正如本章开始时所讨论的，视图和控制器方面将包含在同一个类中。
- en: The Android API provides us with an ideal class for our requirements. The `android.view.SurfaceView`
    class not only provides us a view that is designed for drawing pixels, text, lines,
    and sprites onto, but also enables us to quickly handle player input as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Android API为我们提供了一个理想的类来满足我们的需求。`android.view.SurfaceView`类不仅为我们提供了一个专门用于绘制像素、文本、线条和精灵的视图，还使我们能够快速处理玩家输入。
- en: As if this wasn't useful enough, we can also spawn a thread by implementing
    the runnable interface allowing our main game loop to get player input and other
    system essentials at the same time. We will deal with the general structure of
    your new `SurfaceView` implementation now, so we can fill in the details as we
    progress with the project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这还不够有用一样，我们还可以通过实现可运行接口来生成一个线程，这样我们的主游戏循环可以同时获取玩家输入和其他系统要点。现在，我们将处理您新的`SurfaceView`实现的基本结构，随着项目的进行，我们可以填充细节。
- en: Creating a new class for the view
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为视图创建一个新类
- en: Without further delay, we can create a new class which extends `SurfaceView`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多延迟，我们可以创建一个扩展了`SurfaceView`的新类。
- en: Right-click the folder containing our `.java` files and select **New** | **Java
    Class** then click on **OK**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击包含我们的`.java`文件的文件夹，选择**新建** | **Java 类**，然后点击**确定**。
- en: In the **Create New Class** dialog, name the new class `TDView,` (Tappy Defender
    view). Now, click on **OK** to have Android Studio autogenerate the class.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建新类**对话框中，将新类命名为`TDView`（Tappy Defender视图）。现在，点击**确定**让Android Studio自动生成该类。
- en: 'The new class will open in the code editor. Amend the code to have it extend
    `SurfaceView` and implement `Runnable` as discussed in the previous section. Edit
    the highlighted parts of the code that follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新类将在代码编辑器中打开。修改代码，让它扩展`SurfaceView`并实现`Runnable`，如前一部分所述。编辑下面高亮显示的代码部分：
- en: '[PRE9]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use the *Alt* | *Enter* combination to import the missing classes.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Alt* | *Enter*组合键导入缺失的类。
- en: Note that we still have an error in our code. This is because we must provide
    a constructor for our `SurfaceView` implementation. Right-click just below the
    `TDView` class declaration and navigate to **Generate** | **Constructor** | **SurfaceView(Context:context)**.
    Or you can just type this in as shown in the next block of code. Now click on
    **OK**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们的代码中仍然有一个错误。这是因为我们必须为我们的`SurfaceView`实现提供一个构造函数。在`TDView`类声明下方右键点击，导航到**生成**
    | **构造函数** | **SurfaceView(Context:context)**。或者你可以像在下一块代码中显示的那样直接输入。现在点击**确定**。
- en: What we did
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做的工作
- en: We now have a new class called `TDView`, which extends `SurfaceView` for our
    drawing requirements and implements `Runnable` for our threading needs. We have
    also generated a constructor, which we will use soon to initialize our new class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`TDView`的新类，它扩展了`SurfaceView`以满足我们的绘图需求，并实现了`Runnable`以支持我们的线程需求。我们还生成了一个构造函数，我们很快会使用它来初始化我们的新类。
- en: The `Context` parameter that is passed into our constructor is a reference to
    the current state of our application within the Android system that is held by
    our `GameActivity` class. This `Context` parameter is useful/essential for a number
    of things that we will be implementing throughout this project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给我们的构造函数的`Context`参数是对当前应用状态的引用，在我们的`GameActivity`类中由Android系统保存。这个`Context`参数在实现我们整个项目中的许多功能时非常有用/至关重要。
- en: 'So far, our `TDView` class will look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`TDView`类将如下所示：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Structuring the class code
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组织类代码
- en: Now that we have our `TDView` class extended from the `SurfaceView` class, we
    can start coding it. To control the game, we need to be able to update all the
    game data/objects. This implies an `update` method. In addition, we are obviously
    going to want to draw all our game data once every frame after they have been
    updated. Let's keep all of our drawing code together in a method called `draw`.
    Furthermore, we need to control the frequency with which this happens. Therefore,
    a `control` method seems like it should be part of the class as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从`SurfaceView`类扩展了`TDView`类，我们可以开始编写代码了。为了控制游戏，我们需要能够更新所有的游戏数据/对象。这意味着需要一个`update`方法。此外，我们显然会在每次更新后，每一帧都绘制所有的游戏数据。让我们将所有的绘图代码放在一个名为`draw`的方法中。而且，我们还需要控制发生的频率。因此，一个`control`方法似乎也应该成为类的一部分。
- en: We also know that everything needs to happen in your thread; so to achieve this,
    we should wrap the code in the `run` method. Lastly, we need a way to control
    when the thread should and shouldn't do its work so we need an infinite loop controlled
    by a Boolean, perhaps, `playing`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也知道所有的事情都需要在您的线程中发生；因此，为了实现这一点，我们应该将代码包裹在`run`方法中。最后，我们需要一种方法来控制线程应该和不应该执行工作的时间，因此我们需要一个由布尔值控制的无限循环，或许可以使用`playing`。
- en: 'Copy the following code into the body of our `TDView` class to implement what
    we just discussed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到我们的`TDView`类中，以实现我们刚才讨论的内容：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the bare-bones of our game. The `run` method will execute in a thread,
    but it will only execute the game loop while the Boolean `playing` instance is
    true. Then, it will update all the game data, draw the screen based on that game
    data, and control how long it is until the `run` method is called again.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的游戏的基本框架。`run`方法将在一个线程中执行，但它只会在布尔实例`playing`为真时执行游戏循环。然后，它将更新所有的游戏数据，基于这些游戏数据绘制屏幕，并控制再次调用`run`方法的时间间隔。
- en: 'Now, we can quickly build on this code. First of all, we can implement the
    three methods that we call from the `run` method. Type the following code in the
    body of our `TDView` class before the closing curly brace of the `run` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以快速地在此基础上构建代码。首先，我们可以实现从`run`方法中调用的三个方法。在`TDView`类的`run`方法结束大括号之前，键入以下代码：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now need to declare our playing member variable. We can do this using the
    `volatile` keyword as it will be accessed from outside the thread and from within.
    Type this code just after the `TDView` class declaration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要声明我们的`playing`成员变量。我们可以使用`volatile`关键字这样做，因为它将从线程外部和内部访问。在`TDView`类声明后键入以下代码：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we know that we can control the execution of code within the run method
    with the infinite loop and the `playing` variable. We also need to start and stop
    the actual thread itself. Not just when we decide, but when the player unexpectedly
    quits the game. What if he gets a phone call or just taps the home button on his
    device.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道我们可以使用无限循环和`playing`变量来控制`run`方法内的代码执行。我们也需要开始和停止实际的线程本身。不仅在我们决定时，而且当玩家意外退出游戏时。如果他接到电话或者只是在他的设备上点击了主页按钮怎么办？
- en: 'To handle these events, we need the `TDView` class and `GameActivity` to work
    together. Now, in the `TDView` class, we can implement a `pause` method and a
    `resume` method. Within them, we put the code to stop and start our thread. Implement
    these two methods within the body of the `TDView` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些事件，我们需要`TDView`类和`GameActivity`协同工作。现在，在`TDView`类中，我们可以实现一个`pause`方法和一个`resume`方法。在其中，我们放置停止和启动线程的代码。在`TDView`类的主体中实现这两个方法：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need an instance of a `Thread` class called `gameThread`. We can declare
    it as a member variable of `TDView` just after the class declaration, right after
    our Boolean `playing` parameter. Like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个名为`gameThread`的`Thread`类实例。我们可以在类声明之后，紧接着布尔参数`playing`之后，将其声明为`TDView`的成员变量。如下所示：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `onPause` and `onResume` methods are public. We can now add code
    to our `GameActivity` class to call these methods at the appropriate time. Remember
    that `GameActivity` extends `Activity`. Therefore, use the overridden `Activity`
    lifecycle methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`onPause`和`onResume`方法是公开的。我们现在可以在`GameActivity`类中添加代码，在适当的时候调用这些方法。记住，`GameActivity`继承自`Activity`。因此，使用重写的`Activity`生命周期方法。
- en: By overriding the `onPause` method, whenever the activity is paused, we can
    shut down the thread. This avoids potentially embarrassing the player and having
    to explain to his caller, why they can hear sound FX in the background.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`onPause`方法，无论何时活动暂停，我们都可以关闭线程。这避免了可能让玩家尴尬的情况，以及向来电者解释为什么他们能听到背景中的音效。
- en: By overriding `onResume()`, we can have our thread start up in the last phase
    of the Android lifecycle before the app is actually running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`onResume()`，我们可以在应用程序实际运行之前，在Android生命周期的最后阶段启动我们的线程。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the distinction between the `pause` and `resume` methods of the `TDView`
    class and the overridden `onPause` and `onResume` methods of the `GameActivity`
    class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意区分`TDView`类的`pause`和`resume`方法与`GameActivity`类中重写的`onPause`和`onResume`方法。
- en: The game activity
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏活动
- en: Before you implement/override this method, note that all they will do is call
    the parent version of their respective methods followed by the public methods
    in the `TDView` class to which they correspond.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实现/重写这个方法之前，请注意，它们将执行的操作只是调用它们各自方法对应的父版本，然后调用`TDView`类中对应的方法。
- en: 'You might remember back to the section when we created our new `GameActivity`
    class, we deleted the entire code contents? With that in mind, here is the outline
    of the code we will need in `GameActivity.java` including the implementation of
    the overridden methods within the body of the `GameActivity` class that we discussed
    in the previous section. Type this code in `GameActivity.java`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们创建新的`GameActivity`类的那一节，我们删除了整个代码内容？考虑到这一点，以下是我们在`GameActivity.java`中需要的代码大纲，包括我们之前讨论的`GameActivity`类体内重写方法的实现。在`GameActivity.java`中输入以下代码：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let''s go ahead and declare an object of the `TDView` class. Do this
    just after the `GameActivity` class declaration:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们继续声明`TDView`类的一个对象。在`GameActivity`类声明之后立即这样做：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, within the `onCreate` method, we need to instantiate your object, keeping
    in mind that your constructor in `TDView.java` takes a `Context` object as an
    argument. Then, we use the newly instantiated object in a call to `setContentView()`.
    Remember when we built our home screen, we called `setContentView()` and passed
    in our UI design. This time, we are setting the player''s view to be the object
    of our `TDView` class. Copy the following code into the `onCreate` method of the
    `GameActivity` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，我们需要实例化你的对象，记住在`TDView.java`中的构造函数需要一个`Context`对象作为参数。然后，我们使用新实例化的对象在调用`setContentView()`时使用。记得我们构建主屏幕时，我们调用了`setContentView()`并传入了我们的UI设计。这次，我们将玩家的视图设置为我们的`TDView`类的对象。将以下代码复制到`GameActivity`类的`onCreate`方法中：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, we can actually run our game and click on the **Play** button
    to proceed to the `GameView` activity, which will use `TDView` as its view and
    start our thread. Obviously, there is nothing to see yet, so let's work on the
    model of our design pattern and build the basic outline of our first game object.
    At the end of the chapter, we will see how to run the game on an Android device.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以实际运行我们的游戏，并点击**播放**按钮进入`GameView`活动，它将使用`TDView`作为其视图并启动我们的线程。显然，现在还看不到任何东西，所以让我们着手构建我们设计模式的模型，并构建我们第一个游戏对象的基本大纲。在本章的最后，我们将看到如何在Android设备上运行游戏。
- en: The PlayerShip object
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PlayerShip`对象'
- en: We need to keep the model part of our code as separate as possible from the
    rest. We can do this by creating a class for our player's spaceship. Let's call
    our new class `PlayerShip`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要尽可能将代码的模型部分与其它部分分开。我们可以通过为玩家的太空飞船创建一个类来实现这一点。让我们将我们的新类命名为`PlayerShip`。
- en: Go ahead and add a new class to the project, and call it `PlayerShip`. Here
    are a few quick steps on how to do that. Now, right-click the folder with our
    `.java` files in it and navigate to **New** | **Java Class**, then enter `PlayerShip`
    as the name and click on **OK**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向项目中添加一个新类，并将其命名为`PlayerShip`。以下是几个快速步骤说明如何做到这一点。现在，右键点击包含我们的`.java`文件的文件夹，导航到**新建**
    | **Java类**，然后输入`PlayerShip`作为名称并点击**确定**。
- en: 'What do we need our `PlayerShip` class to be able to know about itself? As
    a bare minimum it needs to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`PlayerShip`类能够了解自己的哪些信息呢？至少它需要知道：
- en: Know where it is on the screen
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道它在屏幕上的位置
- en: What it looks like
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的外观
- en: How fast it is flying
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的飞行速度
- en: 'These requirements suggest a few member variables we can declare. Enter the
    code just after the class declaration that we generated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求提示我们可以声明一些成员变量。在我们生成的类声明之后输入以下代码：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As usual, use the *Alt* | *Enter* keyboard combination to import any missing
    classes. In the previous block of code, we see that we have declared an object
    of type `Bitmap` that we will use to hold the graphic which represents our ship.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，使用 *Alt* | *Enter* 键盘组合导入任何缺失的类。在之前的代码块中，我们看到我们声明了一个类型为 `Bitmap` 的对象，我们将用它来保存表示我们飞船的图像。
- en: We have also declared three `int` type variables; `x` and `y` to hold the spaceship's
    screen coordinates and another `int` type variable, `speed` to hold a value for
    how fast our spaceship is traveling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了三个 `int` 类型的变量；`x` 和 `y` 用来保存飞船的屏幕坐标，另一个 `int` 类型变量 `speed` 用来保存飞船的移动速度值。
- en: 'Now, let''s consider what our `PlayerShip` class needs to do. Again as a bare
    minimum it needs to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下我们的 `PlayerShip` 类需要做什么。同样，最低限度它需要：
- en: Prepare itself
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备自身
- en: Update itself
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新自身
- en: Share it's state with our view
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图共享其状态
- en: A constructor seems to be the ideal place to prepare itself. We can initialize
    its `x` and `y` coordinate variables and set a starting speed with the `speed`
    variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数似乎是准备自身的好地方。我们可以初始化其 `x` 和 `y` 坐标变量，并用 `speed` 变量设置一个起始速度。
- en: The other thing the constructor will need to do is to load the bitmap graphic,
    which represents its appearance. To load bitmaps, we require an Android `Context`
    object. This implies that the constructor that we write will need to receive a
    `Context` object from our view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还需要做另一件事，即加载表示其外观的位图图像。要加载位图，我们需要一个 Android `Context` 对象。这意味着我们编写的构造函数需要从视图接收一个
    `Context` 对象。
- en: 'With all this in mind, here is our `PlayerShip` constructor to implement point
    one from our to-do list:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，以下是我们的 `PlayerShip` 构造函数，以实现待办事项列表中的第一点：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As usual, we need to import some new classes using the *Alt* | *Enter* combination.
    After importing all the new classes required by the line which initializes our
    bitmap object, we can see we still have an error; `Cannot resolve symbol ship`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要使用 *Alt* | *Enter* 组合导入一些新类。导入初始化我们的位图对象所需的全部新类后，我们可以看到我们仍然有一个错误；`Cannot
    resolve symbol ship`。
- en: Let's dissect the line that loads the ship bitmap as we will be seeing this
    quite a lot throughout the book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析加载飞船位图的行，因为我们在书中会经常看到这个。
- en: The `BitmapFactory` class is using its static method `decodeResource()` to attempt
    to load our graphic of the player ship. It requires two parameters. The first
    is the `getResources` method supplied by the `Context` object that was passed
    from the view.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapFactory` 类正在使用其静态方法 `decodeResource()` 尝试加载玩家飞船的图像。它需要两个参数。第一个是由视图传递的
    `Context` 对象提供的 `getResources` 方法。'
- en: The second parameter `R.drawable.ship` is requesting a graphic called `ship`
    from the (R)esource folder named `drawable`. All we have to do to resolve this
    error is to copy our graphic, named `ship.png`, into the `drawable` folder of
    our project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `R.drawable.ship` 是从名为 `drawable` 的 (R)esource 文件夹中请求一个名为 `ship` 的图像。要解决这个错误，我们只需将名为
    `ship.png` 的图像文件复制到我们项目的 `drawable` 文件夹中。
- en: 'Simply drag and drop/copy and paste the `ship.png` graphic contained in the
    `Chapter2/drawable` folder from the download bundle into the `res/drawable` folder
    in the Android Studio project explorer window. The following is a `ship.png` image:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将下载包中 `Chapter2/drawable` 文件夹内的 `ship.png` 图像拖放/复制粘贴到 Android Studio 项目资源管理器窗口中的
    `res/drawable` 文件夹。以下是 `ship.png` 图像：
- en: '![The PlayerShip object](img/B04322_02_10.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![PlayerShip 对象](img/B04322_02_10.jpg)'
- en: 'Number two on our list of things that `PlayerShip` needs to do is, to update
    itself. Let''s implement a public `update` method that can be called from our
    `TDView` class. The method will simply increment the ship''s *x* value by 1 each
    time it is called. Clearly, we need to get more advanced than this. For now implement
    the method in the `PlayerShip` class like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `PlayerShip` 需要做的第二件事是更新自身。让我们实现一个公共 `update` 方法，该方法可以被 `TDView` 类调用。该方法将每次调用时简单地将飞船的
    *x* 值增加1。显然，我们需要比这更先进。现在在 `PlayerShip` 类中像这样实现该方法：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Number three on the to-do list is to share its state with the view. We can
    do this by providing a bunch of getter methods like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项列表的第三项是与视图共享其状态。我们可以通过提供一系列如下的获取器方法来实现这一点：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now your `TDView` class can be instantiated, and find out what it likes about
    any `PlayerShip` objects. However, only the `PlayerShip` class itself can decide
    how it should look, what properties it has, and how it behaves.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`TDView`类可以被实例化，了解它关于任何`PlayerShip`对象的喜好。然而，只有`PlayerShip`类本身才能决定它应该的外观，具有哪些属性以及如何表现。
- en: We can see how we will draw our player's ship to the screen and animate it as
    well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们如何将玩家的船只绘制到屏幕上并对其进行动画处理。
- en: Drawing the scene
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制场景
- en: As we will see, drawing a bitmap is really trivial. But the coordinate system
    that we use to draw our graphics onto needs a brief explanation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，绘制位图实际上非常简单。但是，我们需要简要解释我们用来绘制图形的坐标系统。
- en: Plotting and drawing
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图和绘制
- en: When we draw a `Bitmap` object to the screen, we pass in the coordinates we
    want to draw the object at. The available coordinates of a given Android device
    depend on the resolution of its screen.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Bitmap`对象绘制到屏幕上时，我们传递我们想要绘制对象的坐标。给定Android设备的可用坐标取决于其屏幕的分辨率。
- en: For example, the Samsung Galaxy S4 phone has a screen resolution of 1920 pixels
    (across) by 1080 pixels (down) when held in a landscape view.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三星Galaxy S4手机在横屏模式下，屏幕分辨率为1920像素（水平）乘1080像素（垂直）。
- en: The numbering system of these coordinates starts in the top-left hand corner
    at 0,0 and proceeds down and to the right until the bottom right corner is pixel
    1919, 1079\. The apparent 1 pixel disparity between 1920/ 1919 and 1080/ 1079
    is because the numbering starts at 0.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标的编号系统从左上角的0,0开始，向下和向右直到右下角是像素1919, 1079。1920/1919和1080/1079之间的1像素差异是因为编号从0开始。
- en: Therefore, when we draw a bitmap or any other drawable to the screen, we must
    specify *x*, *y* coordinates.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们绘制位图或任何其他可绘制对象到屏幕上时，我们必须指定*x*, *y*坐标。
- en: Furthermore, a bitmap is, of course, comprised of many pixels. So which pixel
    of a given bitmap is drawn at the *x*, *y* screen coordinate that we will be specifying?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，位图当然是由许多像素组成的。那么，给定位图的哪个像素会绘制在我们将要指定的*x*, *y*屏幕坐标上？
- en: The answer is the top-left pixel of the `Bitmap` object. Take a look at the
    next image, which should clarify the screen coordinates using the Samsung Galaxy
    S4 as an example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`Bitmap`对象的左上角像素。查看下一张图片，它应该能使用三星Galaxy S4作为例子来阐明屏幕坐标。
- en: '![Plotting and drawing](img/B04322_02_10b.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![绘图和绘制](img/B04322_02_10b.jpg)'
- en: For now, when drawing just a single ship at an arbitrary location, this information
    is of little consequence. It will become more important in the next chapter, when
    we start constraining our graphics to the visible screen and respawning them when
    they disappear.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在任意位置绘制单一船只时，这些信息并不重要。在下一章中，当我们开始限制图形在可见屏幕上并当它们消失时重新生成时，这将变得更加重要。
- en: So let's just bare this in mind and get on with drawing our ship to the screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们牢记这一点，继续将我们的船只绘制到屏幕上。
- en: Drawing PlayerShip
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制`PlayerShip`
- en: 'Now that we know all this, we can add some code to our `TDView` class, so we
    can see our `PlayerShip` class in action. First, we need a new `PlayerShip` object
    with class scope. The following code is the `TDView` class declaration:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道这些，我们可以在`TDView`类中添加一些代码，以便我们可以看到`PlayerShip`类的运行情况。首先，我们需要一个具有类作用域的新`PlayerShip`对象。以下是`TDView`类的声明代码：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also need a bunch of objects that we haven't seen yet to help us actually
    do some drawing. We need a canvas and some paint.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些我们尚未见过的对象来帮助我们实际进行绘制。我们需要一个画布和一些画笔。
- en: The Canvas and Paint objects
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Canvas`和`Paint`对象'
- en: The aptly named `Canvas` class provides just what you will expect—a virtual
    canvas to draw our graphics upon.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 名副其实的`Canvas`类提供了你所期望的东西——一个虚拟画布来绘制我们的图形。
- en: We can make a virtual canvas using the `Canvas` class and project it onto our
    `SurfaceView` object which is the view of your `GameActivity` class. We can actually
    add `Bitmap` objects and even manipulate individual pixels on our `Canvas` object
    using methods from our `Paint` object. In addition, we also need an object of
    the `SurfaceHolder` class. This allows us to lock your `Canvas` object while we
    are manipulating it and unlock it when we are ready to draw the frame.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Canvas`类创建一个虚拟画布，并将其投影到我们的`SurfaceView`对象上，这是`GameActivity`类的视图。我们实际上可以在`Canvas`对象上添加`Bitmap`对象，甚至可以使用`Paint`对象的方法操作单个像素。此外，我们还需要一个`SurfaceHolder`类的对象。这允许我们在操作`Canvas`对象时锁定它，并在准备好绘制帧时解锁。
- en: 'We will see in more detail how these classes work as we proceed. Type this
    code immediately following the previous line of code we typed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的内容中更详细地了解这些类是如何工作的。在输入我们刚才输入的代码行之后，立即输入以下代码：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, we need to use the *Alt | Enter* keyboard combination to import some
    new classes for the two lines of code that follow. From this point on, we will
    save digital link and just assume that you know to do this each time you add a
    new class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要使用 *Alt | Enter* 键盘组合导入一些新的类，用于接下来的两行代码。从这一点开始，我们将省略数字链接，并假设你知道每次添加新类时都要这样做。
- en: 'Next, we need to set up to prepare for drawing. The best place to do this is
    in the `TDView()`, constructor. Type the following code to prepare our `Paint`
    and `SurfaceHolder` objects for action:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置以准备绘制。做这件事最好的地方是在 `TDView()` 构造函数中。输入以下代码，为我们的 `Paint` 和 `SurfaceHolder`
    对象准备行动：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Immediately after the previous line of code, we can at last call `new()` to
    initialize our `PlayerShip` object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码之后，我们可以最后调用 `new()` 来初始化我们的 `PlayerShip` 对象：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can jump to our `TDView` class''s `update` method and do this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以跳到 `TDView` 类的 `update` 方法，并进行以下操作：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's it. The `PlayerShip` class (part of the model) knows what to do, and
    we can add all kinds of artificial intelligence into our `PlayerShip` class. The
    `TDView` class (the controller) just says when it is time to update. You can easily
    imagine that all we need to do is create lots of different game objects with different
    properties and behaviors and call their `update` methods once per frame.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。`PlayerShip` 类（模型的一部分）知道该做什么，我们可以在 `PlayerShip` 类中添加各种人工智能。`TDView` 类（控制器）只是说何时该更新。你可以很容易地想象，我们只需要创建具有不同属性和行为的各种游戏对象，并每帧调用一次它们的
    `update` 方法。
- en: 'Now, jump to the `TDView` class''s `draw` method. Let''s draw our `player`
    object by performing the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，跳到 `TDView` 类的 `draw` 方法。通过执行以下操作来绘制我们的 `player` 对象：
- en: Check that our `SurfaceHolder` class is valid.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们的 `SurfaceHolder` 类是否有效。
- en: Lock the `Canvas` object.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定 `Canvas` 对象。
- en: Clear the screen with a call to `drawColor()`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `drawColor()` 清屏。
- en: Splash some virtual paint on it by calling `drawBitmap()` and passing in the
    `PlayerShip` bitmap and an *x*, *y* coordinate.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `drawBitmap()` 并传入 `PlayerShip` 位图以及一个 *x*, *y* 坐标，在它上面喷上一些虚拟的油漆。
- en: Finally, unlock the `Canvas` object and draw the scene.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，解锁 `Canvas` 对象并绘制场景。
- en: 'To achieve these things, type this code in the `draw` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些事情，在 `draw` 方法中输入以下代码：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, we can actually run the game. If our eyesight is fast enough
    or our Android device slow enough, we will just about see our player spaceship
    fly across the screen with immense speed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们实际上可以运行游戏了。如果我们的视力足够快或者我们的安卓设备足够慢，我们就能看到玩家宇宙飞船以极快的速度飞过屏幕。
- en: There is just one more thing to do before we deploy our game so far.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署目前完成的游戏之前，还有一件事要做。
- en: Controlling the frame rate
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制帧率
- en: The reason we can barely see anything is that even though we only move our ship
    at one pixel per frame along the *x* axis (in the `PlayerShip` class's `update`
    method), our thread is calling the `run` method in an unrestricted manner. This
    is probably happening hundreds of times per second. What we need to do is control
    this rate.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎看不到任何东西的原因是，尽管我们每帧只让飞船在 *x* 轴上移动一个像素（在 `PlayerShip` 类的 `update` 方法中），但我们的线程正在不受限制地调用
    `run` 方法。这可能每秒发生数百次。我们需要做的是控制这个速率。
- en: 'Sixty frames per second (FPS) is a reasonable goal. This goal implies the need
    for timing. The Android system measures time in milliseconds (thousandths of a
    second). Therefore, we can add the following code to the `control` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒六十帧（FPS）是一个合理的目标。这个目标意味着需要计时。安卓系统以毫秒（千分之一秒）为单位测量时间。因此，我们可以向 `control` 方法中添加以下代码：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we paused the thread for 17 milliseconds (*1000(milliseconds)/60(FPS)*)
    by calling `gameThread.sleep` with `17` as the argument to the method. We wrap
    the code within a `try`/`catch` block.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过调用 `gameThread.sleep` 方法并传入 `17` 作为参数，让线程暂停了17毫秒（*1000(毫秒)/60(帧率)*)。我们将代码包裹在
    `try`/`catch` 块中。
- en: Deploying the game
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署游戏
- en: Now, we can run our game to see our spaceship floating through space (starting
    at 50 pixels on the *x* axis and 50 pixels on the *y* axis).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行游戏，看到我们的宇宙飞船在太空中漂浮（从 *x* 轴上的50像素和 *y* 轴上的50像素开始）。
- en: Android Studio enables us to fairly quickly create emulators, on which we can
    test our games on a development PC. However, even the most simple of games will
    not run well on an emulator. When we start testing things like player input, the
    experience is so awful that it is best to avoid using emulators completely.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio使我们能够相对快速地创建模拟器，在开发PC上测试我们的游戏。然而，即使是最简单的游戏在模拟器上运行也不好。当我们开始测试像玩家输入这样的东西时，体验是如此糟糕，最好完全避免使用模拟器。
- en: The solution is to carry out debugging on a real Android device. It is very
    easy to prepare for this.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在真实的Android设备上进行调试。为此做准备非常简单。
- en: Debugging on an Android device
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android设备上进行调试
- en: The first thing to do is to visit your device manufacturer's website and obtain
    and install any drivers that are required for your device and operating system.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是访问您的设备制造商的网站，获取并安装所需的驱动程序，以便在您的设备和操作系统上使用。
- en: The next few steps will setup the Android device for debugging. Note that different
    manufacturers structure the menu options slightly differently than others. The
    following sequence is probably very close, if not exact to enable debugging on
    most devices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个步骤将设置Android设备以进行调试。请注意，不同的制造商在菜单选项的结构上可能会有细微的差别。以下步骤可能非常接近，如果不是完全相同的话，可以在大多数设备上启用调试。
- en: Tap the **Settings** menu option or the **Settings** app.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置**菜单选项或**设置**应用。
- en: Tap **Developer** options.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开发者**选项。
- en: Tap the checkbox for **USB Debugging**.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**USB调试**的复选框。
- en: Connect your Android device to the USB port of your development system. The
    next image shows on the Android tab. At the bottom of the Android Studio UI, you
    can see that **Samsung GT-I9100 Android 4.1.2 (API 16)** has been detected:![Debugging
    on an Android device](img/B04322_02_11.jpg)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的Android设备连接到开发系统的USB端口。下一张图片显示在Android标签页上。在Android Studio界面的底部，您可以看到已经检测到**三星GT-I9100
    Android 4.1.2 (API 16)**：![在Android设备上调试](img/B04322_02_11.jpg)
- en: Click on the **Play** icon from the Android Studio toolbar:![Debugging on an
    Android device](img/B04322_02_12.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Android Studio工具栏中的**播放**图标：![在Android设备上调试](img/B04322_02_12.jpg)
- en: When prompted, click on **OK** to run the game on your chosen device.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，点击**确定**以在您选择的设备上运行游戏。
- en: 'The game will now run on the device. Any output or errors can be seen in the
    **logcat** window, also on the **Android** tab:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在将在设备上运行。任何输出或错误都可以在**logcat**窗口中查看，同样在**Android**标签页上：
- en: '![Debugging on an Android device](img/B04322_02_13.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![在Android设备上调试](img/B04322_02_13.jpg)'
- en: Watch with awe as our player's spaceship moves slowly from left to right.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 目睹我们玩家的太空船缓缓从左向右移动，令人惊叹。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we spent a lot of time setting up the structure, game loop,
    and thread. We also spent time handling the Android Activity lifecycle.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花了大量时间设置结构、游戏循环和线程。我们还花时间处理Android Activity的生命周期。
- en: Now, we have all this in place, and we can easily start adding more game objects
    to make Tappy Defender quickly feel more like a real game in the next chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了一切，可以在下一章中轻松添加更多游戏对象，让Tappy Defender迅速变得像一个真正的游戏。
