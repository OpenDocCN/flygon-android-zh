- en: Chapter 4. Tappy Defender – Going Home
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。Tappy Defender – 回家之路
- en: We are on the home straight of our first game. In this chapter, we will draw
    a HUD to show the player in-game information, and implement the rules of the game
    so that the player can win, lose, and get fastest times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将完成我们的第一款游戏。在本章中，我们将绘制一个HUD来显示玩家游戏内的信息，并实现游戏规则，以便玩家可以赢得胜利、失败，并获得最快时间。
- en: After that, we will make a pause screen so the player can admire their achievements
    (or not) after they win or lose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将制作一个暂停屏幕，以便玩家在赢得或输掉比赛后可以欣赏他们的成就（或不是）。
- en: In this chapter, we will also generate our own sound FX and then add them to
    the game. Following that, we will enable the player to save their fastest time,
    and finally we will add a whole bunch of minor improvements, including a bit of
    difficulty balancing based on the screen resolution of the player's Android device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将生成自己的声音效果，并将它们添加到游戏中。接下来，我们将允许玩家保存他们的最快时间，最后，我们将添加一系列小改进，包括根据玩家的Android设备屏幕分辨率进行一些难度平衡调整。
- en: Displaying a HUD
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示HUD
- en: We need to start making our game a bit more rounded. Games have a score or,
    in our case, a time, and other rules as well. For the player to keep check on
    their progress we need to display the stats of the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始使我们的游戏更加完善。游戏有得分，或者在我们的情况下是时间，还有其他规则。为了让玩家跟踪他们的进度，我们需要显示游戏的统计数据。
- en: Here, we will quickly set up a HUD that will show the player everything they
    need to know on screen while he is dodging enemies. We will also declare and initialize
    the variables required to supply data to the HUD. In the next section, *Implementing
    the rules*, we can begin to manipulate variables such as, shields, time, fastest
    time, and so on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速设置一个HUD，它将显示玩家在躲避敌人时需要知道的所有信息。我们还将声明并初始化为HUD提供数据的所需变量。在下一节*实现规则*中，我们可以开始操纵诸如护盾、时间、最快时间等变量。
- en: 'We can start by adding some member variables to the `TDView` class. We use
    a float value for the `distanceRemaining` variable because we will be using pseudo-kilometers
    and fractions of kilometers to represent the distance remaining until our hero
    makes it to her home planet. For the `timeTaken`, `timeStarted`, and `fastestTime`
    variables, we will use the **long** type because time is represented in milliseconds
    and the values get really big. Add this code after the `TDView` class declaration:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从为`TDView`类添加一些成员变量开始。我们使用浮点值作为`distanceRemaining`变量，因为我们将使用伪公里和公里分数来表示英雄到达她的家园星球前剩余的距离。对于`timeTaken`、`timeStarted`和`fastestTime`变量，我们将使用**长整型**，因为时间以毫秒表示，数值会变得非常大。在`TDView`类声明后添加以下代码：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For now, we will just leave these variables with their default values and concentrate
    on displaying them in our HUD. We will make them useful and meaningful in the
    next section, *Implementing the rules*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将这些变量保留为其默认值，并专注于在HUD中显示它们。在下一节*实现规则*中，我们将使它们变得有用和有意义。
- en: Now, we can go ahead and draw our HUD to display all the data the player may
    want to know while playing. As so often, we will be using our versatile `Paint`
    class object `paint` to do the bulk of the work. This time, we use the `drawText`
    method to add text to the screen, the `setTextAlign` method to justify our text,
    and `setTextSize` to scale the size of the text.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续绘制我们的HUD，以显示玩家在游戏过程中可能想要知道的所有数据。像往常一样，我们将使用多功能`Paint`类对象`paint`来完成大部分工作。这次，我们使用`drawText`方法向屏幕添加文本，`setTextAlign`方法来对齐文本，以及`setTextSize`来缩放文本的大小。
- en: 'We can now add this code to our `TDView` class''s `draw` method. Add it as
    the last thing to draw, just before the call to `unlockCanvasAndPost()`, as shown
    by the highlighted code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这段代码添加到`TDView`类的`draw`方法中。将其作为最后要绘制的内容，就在调用`unlockCanvasAndPost()`之前，如高亮代码所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After entering this code, we have some errors and probably some questions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这段代码后，我们遇到了一些错误，可能还有一些疑问。
- en: First, we will deal with the questions. We will look more closely at what we
    are doing to `fastestTime`, `timeTaken`, `distanceRemaining`, and the value returned
    by `getSpeed` in the next section, *Implementing the rules*. Simply put, they
    are representations of distance and time that serve to give the player a sense
    of how they are doing. They are not real simulations of distance, although the
    time is accurate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理这些问题。在下一节*实现规则*中，我们将更详细地了解我们对`fastestTime`、`timeTaken`、`distanceRemaining`以及`getSpeed`返回值的操作。简单来说，它们是表示距离和时间的量，旨在让玩家了解自己的表现如何。它们并不是真实的距离模拟，尽管时间是一致的。
- en: 'The first error we will deal with is caused by a call to a nonexistent method
    `player.getShieldStrength`. Add a member variable `shieldStrength` to the `PlayerShip`
    class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的第一 个错误是由于调用一个不存在的方法`player.getShieldStrength`引起的。在`PlayerShip`类中添加一个成员变量`shieldStrength`：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize it to `2` in the `PlayerShip` constructor:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerShip`构造函数中将其初始化为`2`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement your missing getter method in the `PlayerShip` class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerShip`类中实现你缺失的getter方法：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final errors are caused by the undeclared variables `screenX` and `screenY`.
    It is now apparent that we need the screen resolution in this part of our code.
    The fastest way to deal with this is to make some new class variables called `screenX`
    and `screenY`. Declare these now just after the `TDView` class declaration:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的错误是由于未声明的变量`screenX`和`screenY`引起的。现在显然我们需要在这部分代码中获取屏幕分辨率。处理这个问题的最快方式是声明两个名为`screenX`和`screenY`的新类变量。现在就在`TDView`类声明之后声明它们：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we will see, knowing the screen coordinates is useful in a number of places,
    so it makes sense to do this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，知道屏幕坐标在许多地方都很有用，所以这样做是有意义的。
- en: 'Now, in the `TDView` constructor, initialize `screenX` and `screenY` with the
    resolution passed in by the `GameActivity` class. Do this at the start of the
    constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`TDView`构造函数中，使用`GameActivity`类传递进来的分辨率初始化`screenX`和`screenY`。在构造函数开始时进行如下操作：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now run the game and see our HUD. The only parts of our HUD with meaningful
    data are the **Shield** and **Speed** labels. The speed is a pseudo-measurement
    of MPS (meters per second). Of course it has no bearing on reality, but it is
    relative to the speed of the whizzing stars, approaching enemies and soon, to
    the decreasing distance from the player''s goal, home:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行游戏并查看我们的HUD。我们HUD中唯一具有有意义数据的部分是**Shield**和**Speed**标签。速度是MPS（每秒米数）的伪测量值。当然，这并不反映现实，但相对于呼啸而过的星星、逼近的敌人，以及玩家目标距离的减少，它是有相对性的：
- en: '![Displaying a HUD](img/B04322_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![显示HUD](img/B04322_04_01.jpg)'
- en: Implementing the rules
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现规则
- en: Now, we should pause and think about what we need to do later in the project
    because it will affect what we do while implementing our rules. When the player's
    ship is destroyed or when player reaches their goal, the game will end. This implies
    that the game will need to be restarted. We don't want to quit back to the home
    screen each time, so we need a way to restart the game from within the `TDView`
    class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该暂停并思考后期项目中我们需要做什么，因为这会影响我们实现规则时的操作。当玩家的飞船被摧毁或玩家达到目标时，游戏将结束。这意味着游戏需要重新开始。我们不想每次都退回到主屏幕，所以我们需要一种方法从`TDView`类内部重新开始游戏。
- en: To facilitate this, we are going to implement a `startGame` method in our `TDView`
    class. The constructor will be able to call it and our game loop will also be
    able to call it when necessary as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在`TDView`类中实现一个`startGame`方法。构造函数将能够调用它，我们的游戏循环在必要时也能调用它。
- en: It will also be necessary to pass some of the tasks that the constructor currently
    performs onto the new `startGame` method so that it can properly do its job. Also,
    we will use `startGame` to initialize some of the variables that our game rules
    and HUD require.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要将构造函数当前执行的一些任务传递给新的`startGame`方法，以便它能正确地完成其工作。此外，我们还将使用`startGame`初始化游戏规则和HUD所需的一些变量。
- en: 'In order to accomplish what we discussed, `startGame()` will need a copy of
    the application''s `Context` object. So, like we did with `startX` and `startY`,
    we will now make `context` a member of `TDView`. Declare it after the `TDView`
    class declaration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们讨论的内容，`startGame()`需要应用程序`Context`对象的副本。所以，就像我们对`startX`和`startY`所做的那样，我们现在将`context`作为`TDView`的成员。在`TDView`类声明之后进行声明：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Initialize it in the constructor right after the call to `super()`, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，在调用`super()`之后立即进行初始化，如下所示：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can now implement the new `startGame` method. Most of the code is just moved
    from the constructor. Note that the subtle but important differences, like using
    the class version of the screen coordinates `screenX` and `screenY` instead of
    the constructor parameters *x* and *y*. Also, we initialize `distanceRemaining`,
    `timeTaken`, and `timeStarted`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现新的`startGame`方法。大部分代码只是从构造函数中移动过来的。注意一些微妙但重要的区别，比如使用类的版本`screenX`和`screenY`来代替构造函数参数*x*和*y*。同时，我们初始化`distanceRemaining`、`timeTaken`和`timeStarted`。
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Are you are wondering what is going on with the `timeStarted` initialization?
    We initialized `startTime` using a method of the `System` class, `currentTimeMillis`.
    Now, `startTime` holds the number of milliseconds since January 1, 1970\. We will
    see how this is used in the upcoming section, *Ending the game*. The `System`
    class has many uses. Here, we use it to get the number of milliseconds since January
    1, 1970\. This is a common system for measuring time in a computer. It is called
    Unix time and the moment before the 1st millisecond of January 1, 1970 is known
    as the Unix Epoch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在疑惑`timeStarted`初始化的部分是怎么回事？我们使用了`System`类的方法`currentTimeMillis`来初始化`startTime`，现在`startTime`保存的是自1970年1月1日以来的毫秒数。我们将在接下来的*结束游戏*部分看到如何使用这个值。`System`类有很多用途，这里我们用它来获取自1970年1月1日以来的毫秒数。这是计算机中测量时间的常见系统，称为Unix时间。1970年1月1日第一个毫秒之前的那一刻被称为Unix纪元。
- en: 'Now, comment out or delete the now unnecessary code from the `TDView` constructor
    but add the call to `startGame()` in its place:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注释掉或删除`TDView`构造函数中不再需要的代码，但要在相应位置添加对`startGame()`的调用：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we want to create a method to decrement the `PlayerShip` shield strength.
    This is so that when we detect a collision, we can reduce it by one each time.
    Add this simple method to the `PlayerShip` class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个方法来减少`PlayerShip`的护盾强度。这样，当我们检测到碰撞时，可以每次减少一点。在`PlayerShip`类中添加这个简单的方法：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can jump to the `TDView` class's `update` method and add code to implement
    our game rules a bit further. We will add a Boolean variable `hitDetected` just
    before we do all our collision detection. Inside each of the `if` blocks which
    detects a hit, we can set `hitDetected` to `true`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以跳到`TDView`类的`update`方法，并添加代码进一步实现我们的游戏规则。我们将在进行所有碰撞检测之前添加一个布尔变量`hitDetected`。在每个检测到击中的`if`块内部，我们可以将`hitDetected`设置为`true`。
- en: 'Then, after all the collision detection code, we can see if a hit has been
    detected and reduce the player''s shield strength accordingly. Here is the top
    part of the `TDView` class''s `update` method with the new lines of code highlighted:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在所有碰撞检测代码之后，我们可以检查是否检测到击中，并相应地减少玩家的护盾强度。以下是`TDView`类的`update`方法顶部部分，新的代码行已高亮显示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the nested if statement after the call to `player.reduceShieldStrength`.
    This detects when the player has lost all their shields and failed. We will deal
    with what happens here soon.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在调用`player.reduceShieldStrength`之后的嵌套if语句。这会检测玩家是否已经失去了所有护盾并失败。我们很快就会处理这里会发生的情况。
- en: We are really close to finishing off our game rules. We just need to decrease
    the `distanceRemaining` relative to the player's speed. This is so that we know
    when the player has succeeded. We also need to update the `timeTaken` variable
    so that the HUD is updated each time our draw method is called. This may not seem
    important, but thinking ahead a little, we can foresee a time when the game has
    ended, either because the player has failed or because the player has won. Let's
    talk about the end of the game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常接近完成游戏规则了。我们只需要根据玩家的速度减少`distanceRemaining`。这样我们才知道玩家何时成功。我们还需要更新`timeTaken`变量，以便每次调用我们的绘图方法时更新HUD。这可能看起来不重要，但如果我们稍微考虑一下未来，我们可以预见到游戏结束的时候，无论是玩家失败还是玩家获胜。让我们谈谈游戏的结束。
- en: Ending the game
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: 'If the game is not ended, the game is playing, and if the player has just died
    or won, the game is ended. We need to know when the game is ended and when it
    is playing. Let''s make a new member variable `gameEnded` and declare it after
    the `TDView` class declaration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有结束，那么游戏正在进行中，如果玩家刚刚死亡或获胜，那么游戏已经结束。我们需要知道游戏何时结束，何时在进行中。让我们在`TDView`类声明之后添加一个新的成员变量`gameEnded`并声明它。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can initialize `gameEnded` in the `startGame` method. Enter this code
    as the very last line in the method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`startGame`方法中初始化`gameEnded`。将这行代码作为该方法中的最后一行输入。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can finish the last few lines of our game rules logic, but wrap them
    in a test to see if the game has ended or not. Add the following code to conditionally
    update our game rules logic, right at the end of the `TDView` class''s `update`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以完成游戏规则逻辑的最后几行，但需要用测试来包裹它们，以查看游戏是否已经结束。在 `TDView` 类的 `update` 方法最后添加以下代码，有条件地更新我们的游戏规则逻辑：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our HUD will now have accurate data to keep the player informed of exactly
    how they are doing. We can also detect when the player arrives home and wins because
    `distanceRemaining` will pass zero. In addition, when distance remaining is less
    than zero, we can test to see if `timeTaken` is less than `fastestTime` and update
    `fastestTime` if it is. We can also set `gameEnded` to `true`. Add this code directly
    after the last block of code in the `TDView` class''s `update` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HUD现在将具有准确的数据，让玩家了解他们到底做得如何。我们还可以检测玩家是否回到家并获胜，因为 `distanceRemaining` 将通过零。此外，当剩余距离小于零时，我们可以测试
    `timeTaken` 是否小于 `fastestTime`，如果是，则更新 `fastestTime`。我们还可以将 `gameEnded` 设置为 `true`。在
    `TDView` 类的 `update` 方法的最后一块代码后直接添加以下代码：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We ended the game when the player won; now, add this next line of code to end
    the game when the player loses all their shields. Update this code in the `TDView`
    class''s `update` method. The new line of code is highlighted:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家获胜时我们结束了游戏；现在，添加这行代码，当玩家失去所有护盾时结束游戏。在 `TDView` 类的 `update` 方法中更新此代码。新的一行代码已高亮：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we just need to make something actually happen when `gameEnded` is set
    to true.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在 `gameEnded` 设置为 `true` 时实际执行一些操作。
- en: 'One way to do this is to alternate how we draw the HUD based on whether the
    `gameEnded` Boolean is true or false. Identify the HUD drawing code in the `draw`
    method, shown again here for easy reference:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是，根据 `gameEnded` 布尔值是真是假来交替绘制HUD。在 `draw` 方法中找到HUD绘制代码，再次展示在这里以便于参考：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We want to wrap that code in an `if`-`else` block. If the game is not ended,
    draw the normal HUD else draw an alternative. Wrap the HUD drawing code like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将那段代码包裹在一个 `if`-`else` 块中。如果游戏没有结束，就绘制正常的HUD，否则绘制一个替代的。像这样包裹HUD绘制代码：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s deal with the `else` block, which we will execute when the game
    is ended. What we will do is draw a big **Game Over**, and show the end game stats
    from the HUD. The thread continues on but the HUD stops updating. Enter this code
    in the `else` block:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理 `else` 块，当游戏结束时将执行这部分。我们将绘制一个大的**游戏结束**，并显示HUD中的结束游戏统计信息。线程继续运行，但HUD停止更新。在
    `else` 块中输入以下代码：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that we switch text sizes using `setTextSize()`, and we align all the
    text in the center of the screen using `setTextAlign()`. This is what it looks
    like when you run the game. We just need a way to restart the game after it has
    ended:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用 `setTextSize()` 切换文本大小，并使用 `setTextAlign()` 将所有文本对准屏幕中心。这就是运行游戏时的样子。我们只需要在游戏结束后找到一种重新开始游戏的方法：
- en: '![Ending the game](img/B04322_04_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![结束游戏](img/B04322_04_02.jpg)'
- en: Restarting the game
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新开始游戏
- en: 'To allow the player to restart after the game has ended, we just need to listen
    for a touch and call `startGame()`. Lets edit our `onTouchListener()` code to
    achieve this. The case `MotionEvent.ACTION_DOWN:` is the case we are interested
    in amending. We can simply add conditions here that if the screen is touched while
    the game is ended, restart. The new code to add to case `MotionEvent.ACTION_DOWN:`
    is highlighted:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家在游戏结束后可以重新开始，我们只需要监听触摸事件并调用 `startGame()`。让我们编辑我们的 `onTouchListener()`
    代码以实现这一点。我们感兴趣的是修改 `MotionEvent.ACTION_DOWN:` 的情况。我们只需在这里简单地添加条件，如果游戏结束时屏幕被触摸，就重新开始。要添加到
    `MotionEvent.ACTION_DOWN:` 情况中的新代码已高亮：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try it out. You can now restart the game from the pause menu by tapping the
    screen. Is it just me or is it a bit quiet round here?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。现在你可以在暂停菜单中通过点击屏幕重新开始游戏。是我太敏感还是这里有点安静？
- en: Adding sound FX
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音效果
- en: Adding sound effects in Android is really straightforward. First, let's look
    at where we can get our sound FX from. If you just want to get on with the coding,
    you can use my sound FX in the `Chapter4/assets` folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中添加声音效果真的很简单。首先，让我们看看我们可以在哪里获取声音效果。如果你只想继续编程，可以使用我在 `Chapter4/assets`
    文件夹中的声音效果。
- en: Generating the FX
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成效果音
- en: 'We require four sound FX for our Tappy Defender game:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要四个声音效果用于我们的Tappy Defender游戏：
- en: The sound for when our player crashes into an alien, which we will call `bump.ogg`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的玩家撞到外星人时的声音，我们将其称为 `bump.ogg`。
- en: The sound for when the player is destroyed, which we will call `destroyed.ogg`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被摧毁时的声音，我们将其称为 `destroyed.ogg`。
- en: A fun sound for when the game first begins, which we will call `start.ogg`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时一个有趣的声音，我们称之为`start.ogg`。
- en: Finally, a victory whoop-type sound, which we will call `win.ogg`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个胜利的欢呼声效，我们称之为`win.ogg`。
- en: Here is a very quick guide to make these sound FX using BFXR. Grab a free copy
    of BFXR from [www.bfxr.net](http://www.bfxr.net).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简短的指南，介绍如何使用BFXR制作这些音效。从[www.bfxr.net](http://www.bfxr.net)获取BFXR的免费副本。
- en: Follow the simple instructions on the website to set it up. Try out a few of
    these things to make our cool sound FX.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的简单说明进行设置。尝试其中一些功能，制作我们酷炫的音效。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a very condensed tutorial. You can do so much with BFXR. To learn more
    read the tips on the website at the previous URL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常精简的教程。你可以用BFXR做很多事情。想要了解更多，请访问前一个URL的网站上的小贴士。
- en: Run `bfxr.exe`.![Generating the FX](img/B04322_04_03.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`bfxr.exe`。![生成音效](img/B04322_04_03.jpg)
- en: Try out all the preset types, which generate a random sound of the type you
    are working on. When you have a sound that is close to what you want, move to
    the next step:![Generating the FX](img/B04322_04_05.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试所有预设类型，这些预设会生成你正在处理的类型的随机声音。当你找到一个接近你想要的声音时，进行下一步操作：![生成音效](img/B04322_04_05.jpg)
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Generating the FX](img/B04322_04_04.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块微调你新声音的音调、时长和其他方面：![生成音效](img/B04322_04_04.jpg)
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see we can save in formats other than `.wav` too.![Generating
    the FX](img/B04322_04_06.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**导出Wav**按钮保存你的声音。尽管这个按钮的名字是这样，但如我们所见，我们也可以保存除`.wav`以外的格式。![生成音效](img/B04322_04_06.jpg)
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file use the `.ogg` extension at the end of the filename. Remember we need to
    create `bump.ogg`, `destroyed.ogg`, `start.ogg`, and `win.ogg`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android喜欢使用OGG格式的声音，因此当要求你命名文件时，在文件名末尾使用`.ogg`扩展名。记住我们需要创建`bump.ogg`，`destroyed.ogg`，`start.ogg`和`win.ogg`。
- en: Repeat steps 2 to 5 and create the four sound FX that we discussed.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2至5，创建我们讨论过的四种音效。
- en: Right-click the `app` folder in Android Studio. From the pop-up menu, navigate
    to **New** | **Android resource directory**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中右键点击`app`文件夹。在弹出菜单中，导航到**新建** | **Android资源目录**。
- en: In the **Directory name** field, type `assets`. Click on **OK** to create the
    `assets` folder.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目录名称**字段中，输入`assets`。点击**确定**创建`assets`文件夹。
- en: Use your operating system's file manager to add a folder called `assets` to
    the main folder of the project, then add the four sound files to the new assets
    folder in your project.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的操作系统的文件管理器，在项目的主文件夹中添加一个名为`assets`的文件夹，然后将四个声音文件添加到项目中的新`assets`文件夹中。
- en: The SoundPool class
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SoundPool`类'
- en: To play our sounds, we will use the `SoundPool` class. We are using the deprecated
    version of the `SoundPool` constructor because the new version needs API 21 or
    newer and it is likely that lots of readers will be using an earlier version of
    Android. We can dynamically get the Android version and provide a different version
    of the code for pre- and post-API level 21, but the older constructor meets our
    needs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了播放我们的声音，我们将使用`SoundPool`类。我们使用`SoundPool`构造函数的弃用版本，因为新版本需要API 21或更高版本，而且很可能有很多读者在使用更早版本的Android。我们可以动态获取Android版本，并为API级别21之前和之后提供不同版本的代码，但旧的构造函数满足了我们的需求。
- en: Coding the sound FX
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码音效
- en: 'Declare a `SoundPool` object and some integers to represent the individual
    sounds. Add this code just after the `TDView` class declaration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个`SoundPool`对象和一些整数来代表各个声音。在`TDView`类声明后立即添加此代码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we can initialize our `SoundPool` object and our integer sound IDs. We
    wrap the code in a `try`-`catch` block as required.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以初始化我们的`SoundPool`对象和我们的整型声音ID。我们将代码包裹在必需的`try`-`catch`块中。
- en: 'Note that the call to `load()` starts a process of converting our `.ogg` files
    to raw sound data. If the process is not finished when a call to `playSound()`
    is made, the sound won''t play. The calls to `load()` are in the likely order
    of them being used to minimize this possibility. Enter this code in the constructor
    of our `TDView` class as shown. The new code is highlighted:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用`load()`开始了一个将我们的`.ogg`文件转换为原始声音数据的过程。如果在进行`playSound()`调用时此过程尚未完成，声音将不会播放。`load()`的调用顺序是按照它们被使用的方式来最小化这种可能性。在`TDView`类的构造函数中输入如下代码。新代码已高亮显示：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add a call to `playSound()` using the appropriate reference at the points in
    our code which represent the appropriate event in our game. We have four sounds,
    so four calls to `playSound()` will be made.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们代码中表示游戏内适当事件的点处，使用适当的引用添加对`playSound()`的调用。我们有四种声音，所以将会有四次对`playSound()`的调用。
- en: 'The first goes at the very end of the `startGame()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个在`startGame()`方法的最后面：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next two are highlighted in the `if(hitDetected)` block:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行在`if(hitDetected)`块中被高亮显示：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last one is in the `if(distanceRemaining < 0)` block, as highlighted:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个在`if(distanceRemaining < 0)`块中被高亮显示：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It's time to run Tappy Defender now and hear the sound in action.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行Tappy Defender并听听动作中的声音的时候了。
- en: We will see how to save our player's high score by saving it to a file when
    they achieve it and loading it back up again when Tappy Defender starts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到当玩家在游戏中达到高分时如何将其保存到文件中，并在Tappy Defender启动时重新加载它。
- en: Adding persistence
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久性
- en: You may have noticed that the current fastest time is zero and can therefore
    never be beaten. The other problem is that every time the player quits the game
    the high score is lost. Now, we will load a default high score from a file. When
    a new high score is achieved, save it to the file. It doesn't matter if the player
    quits the game or even switches off their phone; their high score will remain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到当前的最快时间是零，因此永远无法被打破。另一个问题是，每次玩家退出游戏时，最高分都会丢失。现在，我们将从文件中加载一个默认的高分。当达到新的高分时，将其保存到文件中。无论玩家退出游戏还是关闭手机，他们的高分都会保留。
- en: 'First we need two new objects. Declare them as members of the `TDView` class
    after the `TDView` class declaration. The first is a `SharedPreferences` object
    and the second is an `Editor` object, which actually writes to the file for us:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要两个新的对象。在`TDView`类声明之后，将它们声明为`TDView`类的成员。第一个是`SharedPreferences`对象，第二个是`Editor`对象，它实际上为我们写入文件：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use `prefs` first as we just want to attempt to load a high score if one
    exists. We will also initialize `editor` ready for when we save our high score.
    We do this in the `TDView` constructor:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`prefs`，因为我们只是想尝试加载一个存在的高分。我们还会初始化`editor`，以便在我们保存高分时可以使用。我们在`TDView`构造函数中这样做：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s use our `Editor` object to write any new fastest times to the `HiScores`
    file when appropriate. Add the extra highlighted lines shown to add the proposed
    changes to our file, first into a buffer and then commit the changes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在适当的时候使用我们的`Editor`对象将任何新的最快时间写入到`HiScores`文件中。首先将显示的额外高亮行添加到我们的文件缓冲区中，然后提交更改以添加我们提议的修改：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last thing we need to do is get the home screen to load up the fastest time
    and display it to the player. We will load the fastest time in exactly the same
    way as we did in our `TDView` constructor. We will also get a reference to our
    `TextView` through its ID `textHighScore`, which we assigned way back at the beginning
    of [Chapter 2](ch02.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We then use the `setText` method to display it to the player.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是让主屏幕加载最快的游戏时间并将其展示给玩家。我们将以与在`TDView`构造函数中完全相同的方式加载最快的时间。我们还会通过其ID
    `textHighScore`获取对`TextView`的引用，这是我们在[第2章](ch02.html "第2章. Tappy Defender – 第一步")*Tappy
    Defender – First Step*开始时分配的。然后我们使用`setText`方法将其展示给玩家。
- en: 'Open up `MainActivity.java` and add the highlighted code to the `onCreate`
    method to achieve what we just discussed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`，在`onCreate`方法中添加我们刚才讨论过的那些高亮代码：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we have a complete working game. However, it is not really finished yet.
    To make a game that is genuinely playable and fun, we have to improve, refine,
    test, and iterate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了一个可以运行的游戏。然而，它还没有真正完成。为了制作一个真正可玩且有趣的游戏，我们必须改进、优化、测试并迭代。
- en: Iteration
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: How can we make our game better and more playable? Let's look at a number of
    possibilities and then go ahead and implement them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使游戏变得更好玩？让我们看看一些可能性，然后去实施它们。
- en: Multiple different enemy graphics
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个不同的敌人图形
- en: Let's make the enemies a bit more interesting by adding a few more graphics
    to the game. First, we need to add the extra graphics to the project. Copy and
    paste `enemy2.png` and `enemy3.png` from the `Chapter4/drawables` folder of the
    download bundle into the `drawables` folder in Android Studio.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为游戏添加更多图形使敌人更有趣。首先，我们需要将额外的图形添加到项目中。将下载包中`Chapter4/drawables`文件夹中的`enemy2.png`和`enemy3.png`复制并粘贴到Android
    Studio中的`drawables`文件夹中。
- en: '![Multiple different enemy graphics](img/B04322_04_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![多种不同的敌人图像](img/B04322_04_07.jpg)'
- en: enemy2 and enemy3
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: enemy2和enemy3
- en: 'Now, we just need to amend the `EnemyShip` constructor. This code generates
    a random number between 0 and 2, and then switches to load a different enemy bitmap
    accordingly. Our completed constructor now looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改`EnemyShip`构造函数。这段代码生成一个0到2之间的随机数，然后根据需要切换加载不同的敌人位图。我们完成的构造函数现在看起来像这样：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that we just need to move the `Random generator = new Random();` line of
    code to the top of the constructor, so we can use it to choose a bitmap as well
    as generate a random height later in the constructor, as usual.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只需要将`Random generator = new Random();`这行代码移到构造函数的顶部，这样我们就可以用它来选择位图以及在构造函数的后面像往常一样生成一个随机的高度。
- en: An exercise in balance
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是一个平衡的练习
- en: Probably the biggest playability issue in the game is the difference in difficulty
    when playing on a medium/high resolution screen as opposed to a low resolution
    screen. For example, one of my testing devices is a Samsung Galaxy S2\. It is
    a few years old now, and the screen resolution is 800 x 480 pixels when held in
    the landscape position. For comparison, I tested the game on a Samsung Galaxy
    S4 that has 1920 x 1080 pixels in landscape mode. This is more than double the
    resolution of the S2.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中最大的可玩性问题可能是，在中/高分辨率屏幕上玩游戏与在低分辨率屏幕上相比，难度差异的问题。例如，我的一个测试设备是三星Galaxy S2，现在它已经有些年头了，当横屏握持时，屏幕分辨率为800
    x 480像素。相比之下，我在横屏模式下使用1920 x 1080像素的三星Galaxy S4测试了游戏。这比S2的分辨率高出一倍多。
- en: On the S4, the player seems to effortlessly glide in between the almost insignificant
    enemies, while on the S2, the player is faced with an almost impenetrable wall
    of alien steel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在S4上，玩家似乎可以轻松地在几乎微不足道的敌人之间滑行，而在S2上，玩家面临的是几乎无法穿透的外星钢铁之墙。
- en: The real solution to this problem is to draw game objects at pseudo-real-world
    coordinates, and then map these coordinates back to the device at the same scale,
    regardless of resolution. This way, the game will look and play the same on both
    an S2 and an S4\. In the next project, we will build a more advanced game engine
    that does this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的真正解决方案是以伪现实世界坐标绘制游戏对象，然后将这些坐标以相同的比例映射回设备，无论分辨率如何。这样，无论在S2还是S4上，游戏看起来和玩起来的效果都是一样的。在下一个项目中，我们将构建一个更高级的游戏引擎来实现这一点。
- en: Of course, we will still have the consideration of the actual physical screen
    size, making the player's experience varied, but this is a much more accepted
    situation by gamers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然会考虑实际物理屏幕尺寸，使玩家的体验多样化，但这种情形更容易被游戏玩家接受。
- en: As a quick and dirty solution, we will vary the size of the ships and the number
    of enemies. So on lower resolutions, we will have three enemies, but we will shrink
    their size. On higher resolutions, we will increase the number of enemies gradually.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种快速而简便的解决方案，我们将改变战舰的大小和敌人的数量。因此，在低分辨率下，我们将有三个敌人，但会缩小它们的大小。在高分辨率下，我们将逐渐增加敌人的数量。
- en: 'In the `EnemyShip` class, just after the `switch` block that loads our enemy
    graphics into our `Bitmap` object, add the line shown highlighted to call a new
    method that we will write soon, `scaleBitmap()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EnemyShip`类中，在将敌人图像加载到我们的`Bitmap`对象的`switch`块之后，添加高亮显示的行，以调用我们将要编写的新方法`scaleBitmap()`：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we will write our new `scaleBitmap` method. This simple helper method
    takes a single argument, which as we have seen is the horizontal resolution of
    the screen. We then use the resolution and the static `createScaledBitmap` method
    to reduce our `Bitmap` objects on a scale of 2 or 3 depending on the resolution
    of the screen. Add the new `scaleBitmap` method to the `EnemyShip` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写新的`scaleBitmap`方法。这个简单的辅助方法接受一个参数，正如我们所见，是屏幕的水平分辨率。然后我们使用分辨率和静态的`createScaledBitmap`方法，根据屏幕分辨率按2或3的比例缩小我们的`Bitmap`对象。将新的`scaleBitmap`方法添加到`EnemyShip`类中：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The enemies will be scaled down in size on lower resolution screens. Now, let's
    increase the number of enemies for the higher resolutions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在低分辨率屏幕上，敌人的大小会被缩小。现在，让我们为高分辨率增加敌人的数量。
- en: For this, we will add code to the `TDView` class to add extra enemies to higher
    resolution screens.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在`TDView`类中添加代码，为高分辨率屏幕添加额外的敌人。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Warning! This code sucks, but it works and it shows us where we can make improvements
    in our next project. When planning a game, there is always a trade-off between
    good design and simplicity. By keeping things organized from the start, we can
    get away with a bit of hacking near the end. Yes, we can redesign the way we spawn
    and store our game objects, and if Tappy Defender was an ongoing project then
    this would be worthwhile.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！这段代码很糟糕，但它有效，它告诉我们可以在下一个项目中在哪里进行改进。在规划游戏时，总是在良好设计与简单性之间进行权衡。从一开始就保持事物有序，我们可以在最后稍微进行一些黑客行为。是的，我们可以重新设计我们生成和存储游戏对象的方式，如果Tappy
    Defender是一个持续的项目，那么这将是有价值的。
- en: 'Add two more enemy ship objects after the first three, as shown:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个之后，按照所示添加两个更多的敌人飞船对象：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, add code to conditionally initialize these two new objects in the `startGame`
    method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`startGame`方法中添加代码，有条件地初始化这两个新对象：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add code in the `update` method to update our fourth and fifth enemies and
    check for collisions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中添加代码，更新我们的第四和第五个敌人并检查碰撞：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, in the `draw` method, draw our extra enemies when appropriate:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`draw`方法中，在适当的时候绘制我们的额外敌人：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Of course, we now realize that we may like to scale the player as well. This
    makes it plain that perhaps we need a `Ship` class, from which we can derive `PlayerShip`
    and `EnemyShip`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在意识到我们可能还想缩放玩家。这使得或许我们需要一个`Ship`类，从中我们可以派生出`PlayerShip`和`EnemyShip`。
- en: Add to this the cumbersome manner in which we added the extra enemies for higher
    resolution screens and a much more polymorphic solution is probably worthwhile.
    We will see how we can seriously improve this and virtually every other aspect
    of our game engine in the next project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们为更高分辨率屏幕添加额外敌人的笨拙方式，一个更加多态的解决方案可能更有价值。我们将在下一个项目中看到如何彻底改进这一点以及我们游戏引擎的几乎所有其他方面。
- en: Format time
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化时间
- en: 'Look at how time is formatted in the player''s HUD:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 查看玩家HUD中时间是如何格式化的：
- en: '![Format time](img/B04322_04_08.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![格式化时间](img/B04322_04_08.jpg)'
- en: Yuck! Let's write a simple helper method to make this look a whole lot nicer.
    We will add a new method to the `TDView` class called `formatTime()`. The method
    uses the number of elapsed milliseconds in this game (`timeTaken`) and reorganizes
    them into seconds and fractions of a second. It pads the fractions with zeros
    where appropriate and returns the result as a `String` ready to be drawn in the
    `TDView` class's `draw` method. The reason the method takes an argument rather
    than just using the member variable `timeTaken` is so we can reuse this code in
    a minute.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 呕！让我们编写一个简单的辅助方法，让这个看起来更美观。我们将在`TDView`类中添加一个名为`formatTime()`的新方法。该方法使用游戏中经过的毫秒数（`timeTaken`）并将它们重新组织成秒和秒的小数部分。它适当地用零填充小数部分，并将结果作为`String`返回，以便在`TDView`类的`draw`方法中绘制。该方法之所以采用参数而不是直接使用成员变量`timeTaken`，是为了我们可以在一分钟内重用这段代码。
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We amend the line that draws the time in the player''s HUD. For context, in
    the next piece of code, I have commented out the entirety of the original line
    and provided the new line, which includes our call to `formatTime()`, and highlighted
    it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了绘制玩家HUD中时间的行。为了提供上下文，在下一段代码中，我注释掉了原始行的全部内容，并提供了新的行，其中包含我们对`formatTime()`的调用，并已高亮显示：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition, with one minor change, we can use this formatting on the **Fastest:**
    label in the HUD as well. Again, the old line is commented out and the new one
    is highlighted. Find and amend the code in the `TDView` class''s `draw` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过一个小的改动，我们也可以在HUD中的**最快时间：**标签上使用这种格式。同样，旧行已被注释掉，新行已高亮显示。在`TDView`类的`draw`方法中查找并修改代码：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We should also update the time formatting on the pause screen. The lines to
    change are commented out and the new lines to add are highlighted:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更新暂停屏幕上的时间格式。要更改的行已被注释掉，需要添加的新行已高亮显示：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Fastest:** is now formatted in the same way as **Time:** on both the in-game
    HUD and the pause screen HUD. Take a look at our neatly formatted time now:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**最快时间：**现在在游戏内HUD和暂停屏幕HUD上都与**时间：**的格式相同。看看我们现在整洁的时间格式：'
- en: '![Format time](img/B04322_04_09.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![格式化时间](img/B04322_04_09.jpg)'
- en: Handle the back button
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理返回按钮
- en: We will quickly add a small block of code to handle what happens when the player
    presses the back button on their Android device. Add this new method to both the
    `GameActivity` and `MainActivity` classes. We simply check if the back button
    was pressed, and if it was, call `finish()` to let the operating system know we
    are done with this activity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速添加一小段代码，以处理玩家在Android设备上按下返回键时会发生什么。将这个新方法添加到`GameActivity`和`MainActivity`类中。我们只需检查是否按下了返回键，如果是，就调用`finish()`让操作系统知道我们已经完成了这个活动。
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The finished game
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成的游戏
- en: 'Finally, in case you are following along for the theory and not the practical,
    here is the finished `GameActivity` on a high resolution screen with a few hundred
    extra stars and shields:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你是为了理论学习而不是实践而跟进的话，这里有一个在高分辨率屏幕上完成的`GameActivity`，其中包含了几百个额外的星星和盾牌：
- en: '![The finished game](img/B04322_04_10.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![完成的游戏](img/B04322_04_10.jpg)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have implemented the component parts of a basic game engine. We can do so
    much more. Of course, a modern mobile game will have a lot more going on than
    in ours. How will we handle collisions when there are lots more game objects?
    Couldn't we tighten up our class hierarchy a bit, as there were lots of similarities
    between our `PlayerShip` and `EnemyShip` classes? How can we add complex internal
    character animations without confusing the structure of our code, and what if
    we want smart enemies, enemies who can actually think?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个基本游戏引擎的各个组成部分。我们还可以做得更多。当然，一个现代移动游戏会比我们的游戏有更多内容。当有更多的游戏对象时，我们将如何处理碰撞？我们是否可以稍微收紧一下我们的类层次结构，因为我们的`PlayerShip`和`EnemyShip`类之间有很多相似之处？我们如何在不对代码结构造成混乱的情况下添加复杂的内部角色动画，如果我们想要智能敌人，能够实际思考的敌人，该怎么办？
- en: We need realistic backgrounds, side objectives, power-ups, and pick-ups. We
    want a game world with real-world coordinates that map back accurately regardless
    of the resolution of the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要逼真的背景、侧目标、能量升级和拾取物品。我们希望游戏世界具有真实世界的坐标，无论屏幕分辨率如何，都能准确映射回来。
- en: We need a smarter game loop that runs the game at the same speed regardless
    of the CPU it is being processed on. Most of all, what we really need, more than
    any of these things, is a dirty big machine gun. Let's build a classic platform
    game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更智能的游戏循环，无论在哪种CPU上处理，都能以相同的速度运行游戏。最重要的是，我们真正需要的，比这些更重要的，是一把大大的机枪。让我们构建一个经典平台游戏。
