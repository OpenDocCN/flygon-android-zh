- en: Chapter 8. Writing a Rendering Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 编写渲染引擎
- en: In one of the previous chapters, we learned how to organize a thin abstraction
    layer on top of mobile and desktop OpenGL. Now, we can move into actual rendering
    territory and use this layer to implement a 3D rendering framework capable of
    rendering geometry loaded from files using materials, lights, and shadows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何组织一个在移动和桌面OpenGL之上的薄抽象层。现在，我们可以进入实际的渲染领域，并使用这层来实现一个能够渲染从文件加载的几何图形的3D渲染框架，使用材质、光线和阴影。
- en: The scene graph
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景图
- en: A scene graph is a data structure commonly used to construct hierarchical representations
    of spatial graphical scenes. The main limitation of the classes introduced in
    [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. OpenGL ES 3.1 and Cross-platform
    Rendering"), *OpenGL ES 3.1 and Cross-platform Rendering* is that they lack information
    on the scene as a whole. Users of these classes have to do ad hoc bookkeeping
    of transformations, state changes and dependencies, making implementation and
    support of any somewhat complex scenes a very challenging task. Furthermore, a
    lot of rendering optimizations cannot be done unless the whole scene information
    for the current frame is accessible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图是一种常用的数据结构，用于构建空间图形场景的分层表示。第6章[《OpenGL ES 3.1与跨平台渲染》](part0057.xhtml#aid-1MBG21
    "第6章. OpenGL ES 3.1与跨平台渲染")中介绍类的主要局限在于，它们缺乏对整个场景的信息。这些类的用户必须对变换、状态更改和依赖关系进行临时记账，使得实现和支持任何相对复杂的场景变得非常具有挑战性。此外，除非可以访问当前帧的整个场景信息，否则许多渲染优化都无法完成。
- en: In our current low-level implementation, we describe all visible entities using
    the `clVertexArray` class and render them using a shader program accessible via
    the `clGLSLShaderProgram` class with an ugly manual binding of matrices and shader
    parameters. Let's learn how to put all these properties together into a higher
    level data structure. First, we will start with a scene graph node.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的低级实现中，我们使用`clVertexArray`类描述所有可见实体，并通过`clGLSLShaderProgram`类访问着色器程序进行渲染，这需要手动绑定矩阵和着色器参数。让我们学习如何将这些属性组合到一个更高级的数据结构中。首先，我们将从场景图节点开始。
- en: 'The `clSceneNode` class contains local and global transformations and a vector
    of child nodes. These fields are protected, and we access them using setters and
    getters:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSceneNode`类包含了局部和全局变换以及一个子节点向量。这些字段是受保护的，我们通过设置器和获取器来访问它们：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we need hierarchy, we have to distinguish global and local transformation
    of the node. The local transformation is easy to understand from a user''s point
    of view. This defines the position and orientation of a node relative to its parent
    node in a hierarchical spatial structure. The global transformation is used to
    render the geometry. *Per se*, it transforms the geometry from the model coordinate
    system into the world coordinate system. Local transformations can be intuitively
    modified by hand and global transformations should be subsequently reevaluated.
    The constructor of `clSceneNode` sets default transformation values:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要层次结构时，我们必须区分节点的全局和局部变换。从用户的角度来看，局部变换很容易理解。这定义了一个节点相对于其父节点在分层空间结构中的位置和方向。全局变换用于渲染几何体。*本质上*，它将几何体从模型坐标系转换到世界坐标系。局部变换可以直观地手动修改，而全局变换应随后重新评估。`clSceneNode`的构造函数设置默认的变换值：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `clSceneNode` class contains setters and getters to access and modify transformation
    matrices. The implementation is simple. However, it is quite cumbersome, so only
    the methods for the local transformation matrix are cited here. Check out the
    source code `1_SceneGraphRenderer` for the complete picture:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSceneNode`类提供了设置器和获取器，用于访问和修改变换矩阵。实现很简单。然而，它相当繁琐，因此这里只引用了局部变换矩阵的方法。查看源代码`1_SceneGraphRenderer`以获取完整信息：'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Besides this, we need a method to add a child node to this scene node. Our
    current implementation is very simple:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一种方法将子节点添加到此场景节点。我们当前的实现非常简单：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this method can be extended in the future to allow certain optimizations.
    For example, we can mark certain parts of a scene graph as dirty once we add new
    nodes. This will allow us to preserve inter-frame rendering queues constructed
    from the scene graph.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法将来可以扩展，以允许某些优化。例如，我们可以一旦添加新节点，就将场景图的某些部分标记为“脏”。这将允许我们保留从场景图构建的帧间渲染队列。
- en: 'Sometimes, it is required that you set the global transformation matrix directly.
    For example, if you want to use a physics simulation library in your 3D application.
    Once done, local transformations should be recomputed. The `RecalculateLocalFromGlobal()`
    method calculates relative local transformations for each node in the hierarchy.
    For the root node, local and global transformations coincide. For the children,
    each global transformation matrix must be multiplied by the inverse global transformation
    of its parent:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，需要直接设置全局变换矩阵。例如，如果你想在3D应用程序中使用物理模拟库。完成后，应该重新计算局部变换。`RecalculateLocalFromGlobal()`方法为层次结构中的每个节点计算相对局部变换。对于根节点，局部和全局变换是重合的。对于子节点，每个全局变换矩阵必须与父节点的逆全局变换相乘：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We multiply the parent''s node global inverse transformation by the global
    transformation of the current node:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父节点的全局逆变换与当前节点的全局变换相乘：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The process is repeated down the hierarchy:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 过程在层次结构中逐级重复：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is one more interesting thing left in the declaration of `clSceneNode`.
    This is the pure virtual method `AcceptTraverser()`. To render a scene graph,
    a technique known as the *visitor design pattern* is used ([https://en.wikipedia.org/?title=Visitor_pattern](https://en.wikipedia.org/?title=Visitor_pattern)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSceneNode`声明中还有一个更有趣的东西。这就是纯虚拟方法`AcceptTraverser()`。为了渲染场景图，使用了名为*访问者设计模式*的技术（[https://en.wikipedia.org/?title=Visitor_pattern](https://en.wikipedia.org/?title=Visitor_pattern)）：'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `iSceneTraverser` interface is used to define different operations on a
    scene graph. Since the number of different types of scene graph nodes is limited
    and constant, we can add new operations simply by implementing the `iSceneTraverser`
    interface:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSceneTraverser`接口用于定义场景图上的不同操作。由于不同类型的场景图节点的数量是有限且恒定的，我们可以通过实现`iSceneTraverser`接口简单地添加新操作：'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The interface is declared as a friend of all descendants of `clSceneNode` to
    allow direct access to the fields of these classes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接口被声明为`clSceneNode`所有后代的友元，以允许直接访问这些类的字段：
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The implementation of `Traverse()` is shared between all traversers. It resets
    the traverser and calls the virtual method `clSceneNode::AcceptTraverser()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traverse()`的实现被所有遍历器共享。它重置遍历器并调用虚拟方法`clSceneNode::AcceptTraverser()`：'
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the declaration of `iSceneTraverser`, you can see two additional types of
    scene nodes. A tree of `clSceneNode` objects can hold a hierarchy of spatial transformations.
    Obviously, this is not enough to render anything yet. To do this, we need at least
    geometry data and a material.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iSceneTraverser`的声明中，你可以看到两种额外的场景节点类型。`clSceneNode`对象的树可以保持空间变换的层次结构。显然，这还不足以渲染任何东西。为此，我们至少需要几何数据和一个材质。
- en: 'Let''s declare two more classes for this purpose: `clMaterialNode` and `clGeometryNode`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们再声明两个类：`clMaterialNode`和`clGeometryNode`。
- en: 'For the first example of this chapter, a material will contain only ambient
    and diffuse colors ([https://en.wikipedia.org/wiki/Phong_shading](https://en.wikipedia.org/wiki/Phong_shading)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个示例中，材质将只包含环境光和漫反射颜色（[https://en.wikipedia.org/wiki/Phong_shading](https://en.wikipedia.org/wiki/Phong_shading)）：
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The field `m_MaterialClass` contains a material identifier, which can be used
    to distinguish special materials, for example, enable alpha transparency, for
    particle rendering:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_MaterialClass`字段包含一个材质标识符，可以用来区分特殊材质，例如，为粒子渲染启用alpha透明度：'
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, a material scene node can be declared. It is a simple data container:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以声明一个材质场景节点。它是一个简单的数据容器：
- en: '[PRE13]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s take a look at the `AcceptTraverser()` method implementation. It is
    very simple and pretty efficient:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AcceptTraverser()`方法的实现。它非常简单且高效：
- en: '[PRE14]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Geometry nodes are a bit more complex. This is because the API-independent
    geometry data representation in `clVertexAttribs` should be fed into the instance
    of `clGLVertexArray`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 几何节点更为复杂。这是因为`clVertexAttribs`中的API独立几何数据表示应该被输入到`clGLVertexArray`的实例中：
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we feed the geometry data into OpenGL in a lazy way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们以懒惰的方式将几何数据输入到OpenGL中：
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The implementation of `AcceptTraverser()` is very similar to the one inside
    `clMaterialNode`. Just take a look into the bundled source code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`AcceptTraverser()`的实现与`clMaterialNode`内部的实现非常相似。只需查看捆绑的源代码即可。'
- en: 'As you can see, the whole bunch of scene node classes is nothing but a simple
    data container. Actual operations happen in the traverser classes. The first implementation
    of `iSceneTraverser` is the `clTransformUpdateTraverser` class, which updates
    the global—which means relative to the root of the graph—transformation of each
    scene node:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这一大堆场景节点类只不过是一个简单的数据容器。实际操作在遍历器类中发生。`iSceneTraverser`的第一个实现是`clTransformUpdateTraverser`类，它更新每个场景节点的全局变换——即相对于图根的变换：
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The private field `m_ModelView` contains a stack of matrices implemented as
    `std::vector`. The top element of this stack is the current global transformation
    of the node. The `Reset()` method clears the stack and pushes the identity matrix
    on the stack, which is later used as the global transformation of the root scene
    node:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段`m_ModelView`包含一个作为`std::vector`实现的矩阵栈。这个栈的顶部元素是节点的当前全局变换。`Reset()`方法清除栈，并在栈上推入单位矩阵，这后来用作根场景节点的全局变换：
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `PreAcceptSceneNode()` method pushes a new value of the current global
    transformation onto the `m_ModelView` stack, and then uses it as the global transformation
    of incoming nodes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreAcceptSceneNode()` 方法将当前全局变换的新值推送到`m_ModelView`栈上，然后将其作为传入节点的全局变换使用：'
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `PostAcceptSceneNode()` method pops the topmost, now unused, matrix from
    the stack:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostAcceptSceneNode()` 方法从栈中弹出最顶层的、现在未使用的矩阵：'
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This traverser is used in the beginning of every frame before any geometry
    is rendered:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个遍历器在每一帧开始时使用，在渲染任何几何体之前：
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are now almost ready to proceed with the actual rendering. To do this, we
    need to linearize the scene graph into a vector of rendering operations. Let''s
    take a look into the `ROP.h` file. Each rendering operation is a freestanding
    piece of geometry, a material, and a bunch of transformation matrices. The required
    matrices are stored within the `sMatrices` structure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎准备好进行实际渲染了。为此，我们需要将场景图线性化为渲染操作的向量。让我们看看`ROP.h`文件。每个渲染操作都是独立的几何体、材质和一系列变换矩阵。所需的矩阵存储在`sMatrices`结构中：
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The projection, view, and model matrices are set explicitly from the external
    state:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 投影、视图和模型矩阵从外部状态明确设置。
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Other matrices that are necessary for lighting and shading are updated using
    the `UpdateMatrices()` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UpdateMatrices()`方法更新光照和着色所需的其它矩阵：
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This structure can be easily extended with additional matrices on an as-needed
    basis. Furthermore, it is very convenient to pack the values of this structure
    into a Uniform Buffer Object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构可以根据需要轻松地扩展额外的矩阵。此外，将这个结构的值打包到统一缓冲区对象中非常方便。
- en: 'Now, our rendering operation can look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的渲染操作可以如下所示：
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A minimalistic implementation of `clRenderOp::Render()` can be found in `ROP.cpp`.
    There are two shaders defined there. First, a generic vertex shader to transform
    normals into the world space:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`clRenderOp::Render()`的最小化实现在`ROP.cpp`中可以找到。那里定义了两个着色器。首先是一个通用的顶点着色器，用于将法线变换到世界空间：'
- en: '[PRE26]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, a fragment shader that does simple per-pixel lighting using a single
    directional light source pointing in the same direction as the camera:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个片段着色器使用单个方向光源进行简单的逐像素光照，该光源指向与相机相同的方向：
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The camera is statically positioned and lighting is done in the world space:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相机是静态定位的，光照在世界空间中进行：
- en: '[PRE28]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A static global variable holds a shader program linked using the shaders mentioned
    in the preceding code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 静态全局变量保存了使用前述代码中提到的着色器链接的着色器程序：
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The actual rendering code updates all the matrices, sets parameters of the
    shader program and renders the geometry:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的渲染代码更新所有矩阵，设置着色器程序的参数并渲染几何体：
- en: '[PRE30]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following piece of code will become a bottleneck once the number of rendering
    operations and uniforms increases. It can be improved using precached uniform
    locations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染操作和统一变量的数量增加，以下代码段将成为瓶颈。它可以通过预缓存统一位置来进行优化：
- en: '[PRE31]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s convert a scene graph into a vector of rendering operations, so we can
    see the actual rendered image. This is done by the `clROPsTraverser` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将场景图转换为渲染操作的向量，这样我们就可以看到实际渲染的图像。这是由`clROPsTraverser`类完成的：
- en: '[PRE32]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Clear everything before constructing the new queue of rendering operations:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新的渲染操作队列之前清除所有内容：
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Return a reference to the most recently constructed queue:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对最近构造的队列的引用：
- en: '[PRE34]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we implement the `iSceneTraverser` interface. Most of the methods here
    will be empty:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现了`iSceneTraverser`接口。这里的大多数方法将是空的：
- en: '[PRE35]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As the next geometry node comes in, use the topmost material from the materials
    stack and create a new rendering operation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当下一个几何节点进入时，使用材质堆栈中最顶层的材质并创建一个新的渲染操作：
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The materials stack is updated on every incoming `clMaterialNode`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有`clMaterialNode`进入时，都会更新材质堆栈：
- en: '[PRE37]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, this framework can now be used to render the actual 3D graphics. The
    example scene is created in `1_SceneGraphRenderer/main.cpp`. First, the root of
    our scene is created:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个框架现在可以用来渲染实际的3D图形。示例场景在`1_SceneGraphRenderer/main.cpp`中创建。首先，创建我们场景的根节点：
- en: '[PRE38]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A red material is created and binded to a material scene node:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个红色材质并将其绑定到材质场景节点：
- en: '[PRE39]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s create a cube centered in the origin:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个以原点为中心的立方体：
- en: '[PRE40]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And add it in to the scene:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其添加到场景中：
- en: '[PRE41]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Rendering is straightforward and very generic:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染直接且非常通用：
- en: '[PRE42]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Rotate the cube around its diagonal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 绕其对角线旋转立方体：
- en: '[PRE43]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Update global transformations of the nodes and construct a rendering queue:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更新节点的全局变换并构建一个渲染队列：
- en: '[PRE44]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Set up the matrices. The camera has only a dummy implementation, which currently
    returns an identity view matrix:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置矩阵。摄像机目前只提供了一个虚拟实现，它返回一个单位视图矩阵：
- en: '[PRE45]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Clear the screen before the frame will be rendered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染帧之前清除屏幕：
- en: '[PRE46]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Iterate over the rendering queue and render everything:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历渲染队列并渲染所有内容：
- en: '[PRE47]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The resulting image will look like the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图像将如下面的截图所示：
- en: '![The scene graph](img/image00225.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![场景图](img/image00225.jpeg)'
- en: Let's now extend our scene graph rendering example with lights and shadows,
    and make sure everything works on Android.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展场景图渲染示例，加入灯光和阴影，并确保在Android上一切正常工作。
- en: Lighting and shading
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光和着色
- en: To render lights and shadows, we need to extend the approach shown in the previous
    paragraphs. The next code example we will discuss is `2_ShadowMaps`. Shadow mapping
    will be done using projected shadow maps ([https://en.wikipedia.org/wiki/Shadow_mapping](https://en.wikipedia.org/wiki/Shadow_mapping)).
    This way a scene is rendered into an off-screen depth buffer from the light's
    point of view. Next, the scene is rendered as usual and every fragment is projected
    onto the lights shadow map and the depth value relative to the light is compared
    to the value in the constructed shadow map. The fragment is in shadow if the depth
    value is larger than the corresponding depth value from the shadow map. To do
    an off-screen rendering, we need to revisit our OpenGL wrapper introduced in [Chapter
    6](part0057.xhtml#aid-1MBG21 "Chapter 6. OpenGL ES 3.1 and Cross-platform Rendering"),
    *OpenGL ES 3.1 and Cross-platform Rendering*, and add a framebuffer abstraction
    to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染灯光和阴影，我们需要扩展前文展示的方法。接下来我们要讨论的代码示例是`2_ShadowMaps`。阴影映射将使用投影阴影映射（[https://en.wikipedia.org/wiki/Shadow_mapping](https://en.wikipedia.org/wiki/Shadow_mapping)）。这样，场景从光线的视角渲染到一个离屏深度缓冲区。接下来，像往常一样渲染场景，并将每个片段投影到光的阴影映射上，并将与光相关的深度值与构建的阴影映射中的值进行比较。如果深度值大于阴影映射中相应的深度值，则片段处于阴影中。要进行离屏渲染，我们需要回顾[第6章](part0057.xhtml#aid-1MBG21
    "第6章. OpenGL ES 3.1与跨平台渲染")中引入的*OpenGL ES 3.1与跨平台渲染*，并为其添加一个帧缓冲区抽象。
- en: 'The `clGLFrameBuffer` class is declared in `GLFrameBuffer.h`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`clGLFrameBuffer`类在`GLFrameBuffer.h`中声明：'
- en: '[PRE48]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The method `InitRenderTargetV()` accepts a vector containing integer values
    of width, height, and bits per channel:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitRenderTargetV()`方法接受一个包含宽度、高度和每个通道位数整数值的向量：'
- en: '[PRE49]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This method provides access to the private data members, those are width, height,
    and bits per channel, which were passed into `InitRenderTargetV()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了对私有数据成员的访问，这些成员包括宽度、高度和每个通道的位数，它们被传递到`InitRenderTargetV()`中：
- en: '[PRE50]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The most important ability of a framebuffer is being able to provide its content
    as textures—a color texture and a depth texture:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区最重要的能力是能够将其内容作为纹理提供——一个颜色纹理和一个深度纹理：
- en: '[PRE51]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Bind()` method sets this framebuffer as the current OpenGL framebuffer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind()`方法将此帧缓冲区设置为当前的OpenGL帧缓冲区：'
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The protected method `CheckFrameBuffer()` is used to check the completeness
    of the frame buffer according to the OpenGL specification:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的`CheckFrameBuffer()`方法用于根据OpenGL规范检查帧缓冲区的完整性：
- en: '[PRE53]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The private section of the class contains an OpenGL buffer identifier, two
    `clGLTexture` objects for color and depth textures, respectively, and two fields
    containing framebuffer parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有部分包含一个OpenGL缓冲区标识符，分别用于颜色和深度纹理的两个`clGLTexture`对象，以及包含帧缓冲区参数的两个字段：
- en: '[PRE54]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Correct construction of a framebuffer for Android and other platforms requires
    some work and careful selection of parameters. Let''s take a look at the implementation
    of the `InitRenderTargetV()` member function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android和其他平台正确构建帧缓冲区需要一些工作和仔细选择参数。让我们看看`InitRenderTargetV()`成员函数的实现：
- en: '[PRE55]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At first, we store framebuffer''s parameters in private data members. These
    values are used later for viewport aspect computation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在私有数据成员中存储帧缓冲区的参数。这些值稍后用于视口宽高比计算：
- en: '[PRE56]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we will call the OpenGL function to create a framebuffer object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用OpenGL函数创建帧缓冲区对象：
- en: '[PRE57]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the framebuffer object is created, we can bind it as the current framebuffer
    to set up its properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帧缓冲区对象后，我们可以将其绑定为当前帧缓冲区以设置其属性：
- en: '[PRE58]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create and attach a color texture to the framebuffer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并附加一个颜色纹理到帧缓冲区：
- en: '[PRE59]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The only difference here between Android and desktop implementations is the
    selection of buffer data formats. OpenGL 4 Core Profile requires the number of
    bits in the internal format and depth format to be specified explicitly while
    OpenGL ES 3 wants generic `GL_RGBA` and `GL_DEPTH_COMPONENT` respectively. We
    declare two constants in a platform-specific way:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里Android和桌面实现之间的唯一区别在于缓冲数据格式的选择。OpenGL 4 Core Profile要求显式指定内部格式和深度格式的位数，而OpenGL
    ES 3则分别希望通用的`GL_RGBA`和`GL_DEPTH_COMPONENT`。我们以平台特定的方式声明两个常量：
- en: '[PRE60]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will call the `SetFormat()` method of `clGLTexture` to set up the format
    of the color texture:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`clGLTexture`的`SetFormat()`方法来设置颜色纹理的格式：
- en: '[PRE61]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `AttachToCurrentFB()` methods attaches the created color texture to the
    currently binded framebuffer. The value of `GL_COLOR_ATTACHMENT0` specifies an
    OpenGL attachment point:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttachToCurrentFB()`方法将创建的颜色纹理附加到当前绑定的帧缓冲区。`GL_COLOR_ATTACHMENT0`的值指定了一个OpenGL附着点：'
- en: '[PRE62]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A shadow map contains depth buffer values, so we create a depth texture the
    following way on an as-needed basis:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影图包含深度缓冲区的值，因此我们按需以下列方式创建深度纹理：
- en: '[PRE63]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The depth buffer should have the same dimensions as the color buffer:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲区应与颜色缓冲区具有相同的尺寸：
- en: '[PRE64]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The setup of the depth buffer is similar to that of the color buffer:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲区的设置与颜色缓冲区类似：
- en: '[PRE65]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To ensure correct operation, we will check the error code and unbind the buffer:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保正确操作，我们将检查错误代码并解绑缓冲区：
- en: '[PRE66]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `CheckFrameBuffer()` member function uses OpenGL calls to check the current
    state of a framebuffer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckFrameBuffer()`成员函数使用OpenGL调用来检查当前帧缓冲区的状态：'
- en: '[PRE67]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Convert an error code into a string and print it into the system log:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误代码转换为字符串并将其打印到系统日志中：
- en: '[PRE68]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'OpenGL ES is missing some of the capabilities of OpenGL. Here, we omit them
    to make the code portable:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES缺少OpenGL的一些功能。这里，我们省略它们以使代码可移植：
- en: '[PRE69]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By default, nothing is printed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，不打印任何内容：
- en: '[PRE70]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let's proceed further so that we can make use of this class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，以便我们可以使用这个类。
- en: Lights and light nodes
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照和光照节点
- en: 'It is very convenient to represent a light source as a part of a 3D scene.
    When we write "a 3D scene", we mean a scene graph. In order to attach a light
    source to a scene graph, we need a special node for it. Here is the `clLightNode`
    class that holds a pointer to `iLight` with all light properties:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将光源表示为3D场景的一部分非常方便。当我们提到“3D场景”时，我们指的是场景图。为了将光源附加到场景图，我们需要一个特殊的节点。以下是持有指向具有所有光照属性的`iLight`的`clLightNode`类：
- en: '[PRE71]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `AcceptTraverser()` method is similar to those in `clGeometryNode` and
    `clMaterialNode`. But this time, we will call the `PreAcceptLightNode()` and `PostAcceptLightNode()`
    methods of `iSceneTraverser`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`AcceptTraverser()`方法与`clGeometryNode`和`clMaterialNode`中的方法类似。但这次，我们将调用`iSceneTraverser`的`PreAcceptLightNode()`和`PostAcceptLightNode()`方法：'
- en: '[PRE72]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This new scene node type forces us to extend the interface of `iSceneTraverser`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的场景节点类型迫使我们扩展`iSceneTraverser`的接口：
- en: '[PRE73]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Traversers can now handle light nodes in a special way. We will use this ability
    to maintain a list of active lights within the scene on a per-frame basis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在遍历器可以以特殊方式处理光照节点。我们将利用这一能力在每帧基础上维护场景中的活动光照列表。
- en: 'The `iLight` class encapsulates light parameters. It calculates the required
    projection and view matrices of a light source, passes them into a shader program
    and holds a shadow map. We should note that holding an initialized shadow map
    for possible unused light source is certainly non-optimal. The least we can do
    in our minimalistic example is to postpone the creation of a shadow map to the
    moment when it is really needed. In our example, we will deal only with spotlights.
    However, this approach can be easily extended with directional and point lights:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`iLight`类封装了光参数。它计算了光源所需的投影和视图矩阵，将它们传递给着色器程序并持有一个阴影贴图。我们应该注意到，为可能未使用的光源保持一个初始化的阴影贴图肯定不是最优的。在我们这个最小化的示例中，最少可以做到将阴影贴图的创建推迟到真正需要的时候。在我们的示例中，我们只处理聚光灯。然而，这种方法可以很容易地扩展到方向光和点光源：'
- en: '[PRE74]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In case you want to implement multiple types of lights, it is advisable to
    push this field down to a class representing a spot light. Since our example has
    only lights of a single type, putting this value here is a reasonable compromise:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实现多种类型的光源，建议将这个字段推送到表示聚光灯的类中。由于我们的示例只有单一类型的光源，在这里放置这个值是合理的折中：
- en: '[PRE75]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `UpdateROPUniforms()` method updates all the uniforms within a shader program
    required for shadow map rendering. The `clMaterialSystem` class is described in
    details after we finish with `iLight`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateROPUniforms()`方法更新了阴影贴图渲染所需的着色器程序中的所有uniform。在完成`iLight`之后，将详细描述`clMaterialSystem`类：'
- en: '[PRE76]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To render the scene from the light''s point of view, we need to calculate two
    matrices. The first one is the standard *look-at* matrix defining the light''s
    view matrix and the second one is a perspective projection matrix defining the
    light''s frustum:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从光的角度渲染场景，我们需要计算两个矩阵。第一个是标准的*look-at*矩阵，定义了光的视图矩阵；第二个是透视投影矩阵，定义了光的截锥体：
- en: '[PRE77]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `GetShadowMap()` function returns a lazy-initialized shadow map buffer
    attached to this light source:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetShadowMap()`函数返回一个延迟初始化的阴影贴图缓冲区，该缓冲区附加到此光源：'
- en: '[PRE78]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The properties of the light source include its diffuse and ambient colors used
    in a simple lighting model, position, and direction for viewing matrix calculation
    and the spot light cone angle:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 光源的性质包括在简单光照模型中使用的漫反射和环境颜色，用于视图矩阵计算的位置和方向，以及聚光灯锥角：
- en: '[PRE79]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the end, we declare a framebuffer holding a shadow map:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明一个持有阴影贴图的帧缓冲区：
- en: '[PRE80]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s see how uniforms of a shader program are updated. This happens in the
    `UpdateROPUniforms()`, which is called for every render operation before each
    shadow map is rendered:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看着色器程序的uniform是如何更新的。这发生在`UpdateROPUniforms()`中，该函数在每个渲染操作之前对每个阴影贴图进行渲染时被调用：
- en: '[PRE81]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `GetProjScaleBiasMat()` helper routine returns a scaling matrix, which
    maps [-1..1] normalized device coordinates to the [0..1] range:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetProjScaleBiasMat()`辅助例程返回一个缩放矩阵，该矩阵将[-1..1]标准化设备坐标映射到[0..1]范围：'
- en: '[PRE82]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `clMaterialSystem` class mentioned in this code requires some additional
    explanation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中提到的`clMaterialSystem`类需要一些额外的解释。
- en: Material system
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质系统
- en: 'In our previous example, `1_SceneGraphRenderer`, we used a single shader program
    to render all objects in the scene. Now, our renderer will become multipass. We
    need to create shadow maps, and then render shadowed objects and calculate lighting.
    This is done using three different shader programs in three different rendering
    passes. To distinguish between passes, we define the `ePass` enum as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例`1_SceneGraphRenderer`中，我们使用单个着色器程序来渲染场景中的所有对象。现在，我们的渲染器将变为多通道。我们需要创建阴影贴图，然后渲染带阴影的对象并计算光照。这是通过在三个不同的渲染通道中使用三个不同的着色器程序完成的。为了区分通道，我们定义了`ePass`枚举如下：
- en: '[PRE83]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To handle different shader programs based on passes and material properties,
    we implement the `clMaterialSystem` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基于通道和材质属性处理不同的着色器程序，我们实现了`clMaterialSystem`类：
- en: '[PRE84]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `GetShaderProgramForPass()` method returns the shader program for the specified
    pass stored in `std::map`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetShaderProgramForPass()`方法返回指定通道在`std::map`中存储的着色器程序：'
- en: '[PRE85]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The constructor of this class creates each shader program required for rendering
    and inserts it into the map:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数创建了渲染所需的每个着色器程序，并将其插入到映射中：
- en: '[PRE86]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, a map can be replaced with a simple C-style array. However,
    later on, we will use different material types with different shader programs,
    so a map would fit just right.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，映射可以用一个简单的C风格数组替换。但是，稍后我们将使用不同材质类型和不同的着色器程序，所以使用映射会更合适。
- en: 'As in the previous example, the source code of each shader is stored in a static
    string variable. This time, the code is a bit more complicated. The vertex shader
    source code is shared between the ambient and per-light passes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，每个着色器的源代码存储在一个静态字符串变量中。这次，代码有点复杂。顶点着色器源代码在环境传递和每个光线传递之间共享：
- en: '[PRE87]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The same function was used in the C++ code to transform values from the [-1..1]
    to [0..1] range:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个函数在C++代码中被用来将值从[-1..1]范围转换到[0..1]范围：
- en: '[PRE88]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Values are passed to the subsequent fragment shaders:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 值传递给后续的片段着色器：
- en: '[PRE89]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here is the fragment shader for the ambient pass. Just output the ambient color
    to the framebuffer, and we are done:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是环境传递的片段着色器。只需将环境色输出到帧缓冲区，我们就完成了：
- en: '[PRE90]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The fragment shader for per-light passes computes the actual lighting and shading
    based on light''s parameters and the shadow map. This is why it is so long compared
    to all of our previous shaders:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个光线传递的片段着色器根据光线的参数和阴影映射计算实际的光照和着色。这就是为什么它比我们之前的着色器要长得多：
- en: '[PRE91]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Shadows are computed using the technique called *percentage closer filtering*.
    If we use a naïve shadow mapping approach, the resulting shadows will have a lot
    of aliasing. The idea of **percentage closer filtering** (**PCF**) is to sample
    from the shadow map around the current pixel and compare its depth to all the
    samples. By averaging the results of comparison (not the results on the sampling),
    we can get smoother edges between light and shadow. Our example uses a 5 X 5 PCF
    filter with 26 taps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影是使用称为*百分比接近过滤*的技术计算得出的。如果我们使用简单的阴影映射方法，得到的阴影将有很多锯齿。**百分比接近过滤**（**PCF**）的理念是在当前像素周围的阴影映射中进行采样，并将其深度与所有样本进行比较。通过平均比较的结果（而不是采样的结果），我们可以得到光与影之间更平滑的边缘。我们的示例使用了带有26个抽头的5
    X 5 PCF滤波器：
- en: '[PRE92]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here''s the function to evaluate whether a given fragment is in shadow:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是评估给定片段是否在阴影中的函数：
- en: '[PRE93]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Do a perspective division to project the shadow map onto the object:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 进行透视除法，将阴影映射投影到物体上：
- en: '[PRE94]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `DepthBias` coefficient is used to prevent shadow acne. Here are two renderings
    of the same scene with the zero `DepthBias` (left) and `-0.0002` (right):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`DepthBias`系数用于防止阴影痘痘。以下是同一场景的两次渲染，一次是零`DepthBias`（左），一次是`-0.0002`（右）：'
- en: '![Material system](img/image00226.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![材质系统](img/image00226.jpeg)'
- en: 'In general, it requires manual tweaking and should be a part of light''s parameters.
    Take a look at the following link for more ideas on how to improve shadows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这需要手动调整，并应该是光线参数的一部分。查看以下链接，了解更多关于如何改善阴影的想法：
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx)。'
- en: 'Now, multiply the coefficients and return the resulting value:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，乘以系数并返回结果值：
- en: '[PRE95]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now we can compute a simple lighting model based on the actual light direction
    and its shadow map:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据实际的光线方向及其阴影映射计算一个简单的光照模型：
- en: '[PRE96]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To construct a shadow map used in the previous shader, we need an additional
    rendering pass. For each light, the following vertex and fragment shaders are
    used:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建上一个着色器中使用的阴影映射，我们需要一个额外的渲染传递。对于每个光线，使用以下顶点和片段着色器：
- en: '[PRE97]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now we can render a nicer image with all shadows and much more accurate lighting.
    Let's take a look at the `2_ShadowMaps/main.cpp` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以渲染一个更美观的图像，包含所有阴影和更精确的光照。让我们看看`2_ShadowMaps/main.cpp`文件。
- en: Demo application and a rendering technique
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示应用程序和渲染技术
- en: The most important part of the new code is in the `OnDrawFrame()` method. It
    uses the `clForwardRenderingTechnique` class to render the scene. Let's take a
    look at `Technique.cpp.`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码最重要的部分在`OnDrawFrame()`方法中。它使用`clForwardRenderingTechnique`类来渲染场景。让我们看看`Technique.cpp`文件。
- en: 'A helper function `RenderROPs()` is used to render a vector of rendering operations:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数`RenderROPs()`用于渲染渲染操作的向量：
- en: '[PRE98]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, all the passes can be described in terms of this function. Take a look
    at the function `clForwardRenderingTechnique::Render()`. First, let''s construct
    two rendering queues, for opaque and transparent objects. Transparent objects
    are those with the string `Particle` as their material class. We will make use
    of transparent objects in the next chapter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有传递都可以用这个函数来描述。看看`clForwardRenderingTechnique::Render()`函数。首先，让我们构建两个渲染队列，一个用于不透明物体，一个用于透明物体。透明物体是指其材质类别为字符串`Particle`的物体。我们将在下一章中使用透明物体：
- en: '[PRE99]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Prepare matrices for shaders and clear OpenGL buffers:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为着色器准备矩阵并清除OpenGL缓冲区：
- en: '[PRE100]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, render all the objects with their ambient color. This is it, the ambient
    pass does not require any lights. As a by-product, we will have a Z-buffer filled
    with values, so we can disable depth writes in the subsequent passes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用它们的环境色渲染所有对象。这就是全部内容，环境传递不需要任何光照。作为副产品，我们将得到一个充满值的Z缓冲区，因此在后续传递中我们可以禁用深度写入：
- en: '[PRE101]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'For the subsequent per-light passes, we need a vector of lights from the scene.
    Get it from the traverser and update all the shadow maps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后续的每个光照传递过程，我们需要从场景中获取一个光照向量。从遍历器中获取它，并更新所有的阴影贴图：
- en: '[PRE102]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `UpdateShadowMaps()` function iterates over a vector of light nodes and
    renders shadow casters into the corresponding shadow maps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateShadowMaps()`函数遍历光照节点向量，并将阴影投射器渲染到相应的阴影贴图中：'
- en: '[PRE103]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Bind and clear the shadow map framebuffer:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定并清除阴影贴图帧缓冲区：
- en: '[PRE104]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The light knows its projection and view matrices. This code is quite generic
    to be extended for use with light types, including lights with multiple viewing
    frustums:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 光源知道其投影和视图矩阵。这段代码相当通用，可以扩展用于包括具有多个视锥体的光源在内的光类型：
- en: '[PRE105]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Update uniforms within the shader program:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器程序中更新uniform变量：
- en: '[PRE106]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Render into the shadow map and unbind the framebuffer:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染到阴影贴图并解绑帧缓冲区：
- en: '[PRE107]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'All the shadow maps are now ready to be used in the rendering code. Let''s
    continue with the `OnDrawFrame()` function. Per-light passes accumulate lighting
    from all light sources and look as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的阴影贴图现在都准备好在渲染代码中使用。让我们继续`OnDrawFrame()`函数。每个光照传递会累积所有光源的光照，如下所示：
- en: '[PRE108]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Last but not the least, render the ambient lighting for transparent objects:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，为透明对象渲染环境光照：
- en: '[PRE109]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Don''t forget to reset the OpenGL state. A good idea to extend the renderer
    would be to encapsulate states such as depth test, depth mask, blending mode,
    and others into a pipeline state object and update pipeline states only once they
    are changed. If you want to extend the examples into a full-scale rendering code,
    this improvement is a must-have:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记重置OpenGL状态。扩展渲染器的一个好主意是将深度测试、深度掩码、混合模式等状态封装到管道状态对象中，并且只在状态改变时更新管道状态。如果您想将示例扩展到完整的渲染代码，这个改进是必须的：
- en: '[PRE110]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We covered all the low-level rendering code. Let's go one level higher and see
    how a scene can be constructed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有低级渲染代码。让我们提高一个层次，看看如何构建一个场景。
- en: Scene construction
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景构建
- en: 'Our test scene is constructed in `main()` and the process looks the following
    way. First, global objects are instantiated:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试场景在`main()`中构建，过程如下所示。首先实例化全局对象：
- en: '[PRE111]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'After this, materials and material nodes are set up:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，设置材质和材质节点：
- en: '[PRE112]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, we can create geometry of the scene using a bunch of boxes and a 3D model
    of Deimos ([https://en.wikipedia.org/wiki/Deimos_(moon)](https://en.wikipedia.org/wiki/Deimos_(moon)))
    loaded from an `.obj` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用一推箱子和一个从`.obj`文件加载的Deimos（[https://en.wikipedia.org/wiki/Deimos_(moon)](https://en.wikipedia.org/wiki/Deimos_(moon)）的3D模型来创建场景几何：
- en: '[PRE113]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This function can be found in the `Loader_OBJ.cpp` file and does parsing of
    Wavefront OBJ file format ([https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以在`Loader_OBJ.cpp`文件中找到，并解析Wavefront OBJ文件格式（[https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)）：
- en: '[PRE114]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And last but not least, we will add two lights to the scene, which will produce
    two distinct shadows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将向场景中添加两个光源，这将产生两个不同的阴影：
- en: '[PRE115]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Assemble it all together and proceed to the application main loop:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起，并进入应用程序主循环：
- en: '[PRE116]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The resulting application renders the following image with a rotating cube
    and shadows from two light sources:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应用程序渲染了以下图像，包含旋转的立方体和两个光源的阴影：
- en: '![Scene construction](img/image00227.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![场景构建](img/image00227.jpeg)'
- en: The demo application is runnable on Android as well. Just go and try it!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序也可以在Android上运行。去试试吧！
- en: User interaction with 3D scenes
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户与3D场景的交互
- en: We hope that you tried to run the `2_ShadowMaps` example. As you may have noticed,
    the 3D scene can be rotated with a gesture on a touch screen or using mouse on
    a desktop machine.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您尝试运行了`2_ShadowMaps`示例。您可能已经注意到，3D场景可以通过触摸屏上的手势或在桌面计算机上使用鼠标进行旋转。
- en: 'It is done using the `clVirtualTrackball` class, which emulates a virtual trackball
    by calculating a view matrix based on the provided touch points:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`clVirtualTrackball`类完成的，它通过根据提供的触摸点计算视图矩阵来模拟虚拟轨迹球：
- en: '[PRE117]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Get the view matrix, corresponding to the new touch point:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 获取与新的触摸点相对应的视图矩阵：
- en: '[PRE118]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If we are not touching the screen, return an identity matrix:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有触摸屏幕，返回一个单位矩阵：
- en: '[PRE119]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Project the touch point onto the virtual trackball sphere and find the distance
    between the current and the previous projection points:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将触摸点投影到虚拟轨迹球上，并找到当前投影点与上一个投影点之间的距离：
- en: '[PRE120]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If the distance is non-zero, calculate and return a rotation matrix:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离不为零，计算并返回一个旋转矩阵：
- en: '[PRE121]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Get the current matrix:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前矩阵：
- en: '[PRE122]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Reset the state of the trackball when a user touches the screen for the first
    time:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次触摸屏幕时，重置轨迹球的状态：
- en: '[PRE123]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Projection math goes here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 投影数学计算如下：
- en: '[PRE124]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Convert normalized point coordinated to the `-1.0...1.0` range:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准化点坐标转换为`-1.0...1.0`范围：
- en: '[PRE125]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The class is used in the `UpdateTrackball()` function, which is called from
    `OnDrawFrame()`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 该类在`UpdateTrackball()`函数中使用，该函数是从`OnDrawFrame()`中调用的：
- en: '[PRE126]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This class enables you to rotate a 3D scene on a touchscreen and serves the
    purpose of debugging the scene on your device.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许你在触摸屏上旋转3D场景，并可用于在设备上调试场景。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to build higher level scene graph abstractions
    on top of our platform-independent OpenGL wrapper. We can create scene objects
    with materials and light sources and render the scene with lighting and shading.
    In the next chapter, we will step away from rendering for a while—well, not entirely—and
    learn how to implement a game logic in C++.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在我们平台独立的OpenGL封装之上构建更高级的场景图抽象。我们可以创建带有材质和光源的场景对象，并使用光照和阴影渲染场景。在下一章中，我们将暂时离开渲染——好吧，不是完全离开——并学习如何用C++实现游戏逻辑。
