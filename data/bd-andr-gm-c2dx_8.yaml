- en: Chapter 8. Adding Native Java Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 添加原生Java代码
- en: Until now, we have been creating our game by using only the programming language
    in which the Cocos2d-x game framework has been written (C++); nevertheless, the
    Android API written by Google is only available in the Java layer of the application.
    In this chapter, you will learn how to communicate our native C++ code with the
    higher end Java core by using the **Java Native Interface** (**JNI**) capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Cocos2d-x游戏框架编写的编程语言（C++）来创建我们的游戏；然而，由Google编写的Android API仅在应用程序的Java层可用。在本章中，你将学习如何使用**Java
    Native Interface** (**JNI**)的能力，将我们的原生C++代码与高端的Java核心进行通信。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: Understanding the Cocos2d-x structure for the Android platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Cocos2d-x在Android平台的架构
- en: Understanding the JNI capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JNI的能力
- en: Adding the Java code to the Cocos2d-x game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Cocos2d-x游戏中添加Java代码
- en: Adding ads to the game by inserting the Java code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插入Java代码向游戏中添加广告
- en: Understanding the Cocos2d-x structure for the Android platform
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Cocos2d-x在Android平台的架构（再次注意原文重复，不重复翻译）
- en: In [Chapter 1](ch01.html "Chapter 1. Setting Up Your Development Environment"),
    *Setting Up Your Development Environment*, when we were installing all the required
    components for building the Cocos2d-x framework, we told you to download and install
    Android **Native Development Kit** (**NDK**), which allows us to build the Android
    applications by using the C++ language instead of using the mainstream Java technology
    core for which the Android API has been written.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 设置你的开发环境")，*设置你的开发环境*中，我们在安装构建Cocos2d-x框架所需的所有组件时，告诉你要下载并安装Android
    **原生开发工具包** (**NDK**)，它允许我们使用C++语言而非主流的Java技术核心来构建Android应用程序，Android API就是用这种技术核心编写的。
- en: 'When an Android application is launched, it looks in its `AndroidManisfest.xml`
    file for an activity definition that has the intent filter `android.intent.action.MAIN`,
    and then it will run the Java class. The following listing shows the segment of
    the `AndroidManifest.xml` file generated by the Cocos new script, where the activity
    to be launched when the Android application starts is specified:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Android应用程序启动时，它会查看其`AndroidManisfest.xml`文件，寻找带有意图过滤器`android.intent.action.MAIN`的活动定义，然后运行Java类。以下列表展示了由Cocos新脚本生成的`AndroidManifest.xml`文件片段，其中指定了当Android应用程序启动时要启动的活动：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Cocos2d-x project creation script has created a Java class named `AppActivity`
    and it is located in the `src` folder of the `proj.android` directory under the
    `org.cocos2dx.cpp` Java package name. This class has no body and extends from
    the `Cocos2dxActivity` class, as we can appreciate in the following code listing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x项目创建脚本已经创建了一个名为`AppActivity`的Java类，它位于`proj.android`目录下的`src`文件夹中的`org.cocos2dx.cpp`
    Java包名中。这个类没有主体，并继承自`Cocos2dxActivity`类，正如我们可以在以下代码列表中欣赏到的那样：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Cocos2dxActivity` class loads the native C++ framework core in its `onCreate`
    method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cocos2dxActivity`类在其`onCreate`方法中加载原生C++框架核心。'
- en: Understanding the JNI capabilities
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JNI的能力（请注意，这里原文有重复，根据注意事项，我不会重复翻译）
- en: JNI offers a bridge between the C++ code and the Java code. The Cocos2d-x framework
    provides us with a JNI helper, which makes it easier to integrate the C++ code
    and the Java code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JNI提供了C++代码和Java代码之间的桥梁。Cocos2d-x框架为我们提供了JNI助手，这使得集成C++代码和Java代码变得更加容易。
- en: The `JniHelper` C++ class has a method called `getStaticMethodInfo`. This receives
    as parameters, a `JniMethodInfo` object to store all the data that is required
    to invoke the corresponding Java code, the class name where the static method
    is located, the name of the method, and its signature.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`JniHelper` C++类有一个名为`getStaticMethodInfo`的方法。这个方法接收以下参数：一个`JniMethodInfo`对象来存储调用相应Java代码所需的所有数据，静态方法所在的类名，方法名以及它的签名。'
- en: 'In order to find out the method signature for JNI, you could use the `javap`
    command: so, for instance, if we would like to know what the signatures of the
    methods contained in the `AppActivity` class are , then we just need to open a
    console window , go to your `proj.android\bin\classes` directory, and type the
    following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出JNI的方法签名，你可以使用`javap`命令：例如，如果我们想知道`AppActivity`类中包含的方法的签名，那么我们只需要打开一个控制台窗口，前往你的`proj.android\bin\classes`目录，并输入以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this particular case you will receive as a response, the signature of the
    `null` constructor created automatically for the class as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，你将收到如下自动为类创建的`null`构造函数的签名：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, through the property `env` attached to the `JniMethodInfo` instance,
    we can invoke the Java method with a set of methods contained by this object,
    all starting with `Call…`. In the code that we are going to write in the next
    section, we will use the `CallStaticVoid` method in order to call a static method
    that does not return any value, as its name suggests. Please note that if you
    want to pass a Java string as a parameter, then you will need to call the `NewStringUTF`
    method of the `env` property, pass `const char*`, and it will return a `jstring`
    instance, which you can use to pass to a Java method that receives a string, as
    we show in the following code listing:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`JniMethodInfo`实例附加的`env`属性，我们可以调用一系列以`Call…`开头的对象方法来调用Java方法。在下一节我们将编写的代码中，我们将使用`CallStaticVoid`方法来调用一个不返回任何值的静态方法，顾名思义。请注意，如果你想传递一个Java字符串作为参数，那么你需要调用`env`属性的`NewStringUTF`方法，传递`const
    char*`，它将返回一个`jstring`实例，你可以用它来传递给一个接收字符串的Java方法，如下面的代码清单所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, if you have created instances of `jstring` or any other Java abstraction
    class within your C++ code, then make sure that you delete those after passing
    the value to the Java core, so that we don''t have unnecessary references in the
    memory. This can be achieved by calling the `DeleteLocalRef` method located in
    the `env` property of the `JniMethodInfo` instance and passing the Java abstraction
    reference that you want to remove:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在C++代码中创建了`jstring`或其他任何Java抽象类的实例，那么在将值传递给Java核心之后，请确保删除这些实例，这样我们就不必在内存中保留不必要的引用。可以通过调用`JniMethodInfo`实例的`env`属性中的`DeleteLocalRef`方法，并传递你想移除的Java抽象引用来实现这一点：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The concepts exposed in this section will be applied to the code listings in
    the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍的概念将应用于下一节的代码清单。
- en: Adding Java code to the Cocos2d-x game
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java代码添加到Cocos2d-x游戏
- en: Now we are going to create a simple integration between these two technologies,
    which will allow our Cocos2d-x C++ game to show a toast message using the Android
    Java API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的集成，将这两项技术结合起来，使我们的Cocos2d-x C++游戏能够使用Android Java API显示提示框消息。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A toast in Android is a pop-up message that is displayed for a specified amount
    of time without the option of being hidden before the predefined time. The screenshot
    at the end of this section shows what a toast message looks like.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓中的提示框（Toast）是一种弹出的消息，它会显示一段指定的时间，在这段时间内无法被隐藏。本节的最后附有提示框消息的截图，以供参考。
- en: 'Cocos2d-x runs within a Java activity, so in order to show the native Android
    toast message, we will create a Java class that will have a static method called
    `showToast`. This will receive a string, and then it will show it in a toast.
    In order to have access to the Cocos2d-x game activity, we will add a static attribute
    of type `Activity` to that class and will initialize it in the overridden `onCreate`
    method. Then, we will create a public static method that will allow us to access
    this instance from anywhere within our Java code. After these modifications our
    `AppActivity` Java class code will look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x运行在一个Java活动中，为了显示原生的Android提示框消息，我们将创建一个Java类，它将有一个名为`showToast`的静态方法。这个方法将接收一个字符串，并在提示框中显示它。为了访问Cocos2d-x游戏活动，我们将在该类中添加一个类型为`Activity`的静态属性，并在重写的`onCreate`方法中初始化它。然后，我们将创建一个公共的静态方法，这将允许我们从Java代码的任何地方访问这个实例。在这些修改之后，我们的`AppActivity`
    Java类代码将如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let us create the referred `JniFacade` Java class inside our `com.packtpub.jni`
    package, which in its body will only have one static void method that receives
    a string as a parameter, and then shows a toast on the UI thread with the received
    message as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`com.packtpub.jni`包内创建所提到的`JniFacade` Java类，该类体内将只有一个接收字符串作为参数的静态void方法，然后如下所示在UI线程中以接收到的消息显示提示框：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have our code in the Java side, let us add the `JniBridge` C++ class
    to our `classes` folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了Java端的代码，让我们将`JniBridge` C++类添加到我们的`classes`文件夹中。
- en: 'In the `JniBridge.h` header file we will write the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JniBridge.h`头文件中，我们将编写以下内容：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let us create the implementation file, `JniBridge.cpp`, where we are going
    to invoke our static Java method called `showToast`, which receives a string as
    a parameter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建实现文件`JniBridge.cpp`，在这里我们将调用名为`showToast`的静态Java方法，该方法接收一个字符串作为参数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, here we are using the `JniMethodInfo` structure and the `JniHelper`
    class bundled with the Cocos2d-x framework in order to invoke the `showToast`
    method and send it the c string in our C++ code, which was converted into a Java
    string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里我们使用了Cocos2d-x框架中捆绑的`JniMethodInfo`结构和`JniHelper`类，以调用`showToast`方法，并向它发送C++代码中的c字符串，该字符串被转换成了Java字符串。
- en: 'Now let us include our `JniBridge.h` header file in our `HelloWorldScene.cpp`
    implementation file, so that we can have access to our bridge to the Java code
    from within our main scene class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`HelloWorldScene.cpp`实现文件中包含`JniBridge.h`头文件，这样我们就可以从主场景类内部访问到Java代码的桥梁：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now at the end of the `init` method located in the `HelloWorld.cpp` implementation
    file, we are going to call the `showToast` static method in order to use the Android
    Java API for displaying a native toast message, displaying the text sent from
    our C++ code as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在位于`HelloWorld.cpp`实现文件中的`init`方法末尾，我们将调用`showToast`静态方法，以便使用Android Java
    API显示一个原生提示消息，显示从我们的C++代码发送的文本，如下所示：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This yields the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![Adding Java code to the Cocos2d-x game](img/B04193_08_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![将Java代码添加到Cocos2d-x游戏](img/B04193_08_01.jpg)'
- en: As we can appreciate from the previous screenshot, we have achieved our goal
    of displaying a native Java toast message from our C++ game logic code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的截图中可以看出的，我们已经实现了从C++游戏逻辑代码中显示原生Java提示消息的目标。
- en: Adding ads to the game by inserting Java code
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过插入Java代码将广告添加到游戏中
- en: In the previous section, we have created an interaction between our C++ game
    logic code and the Java layer of our Android app by using JNI. In this section,
    we are going to modify our Android-specific code in order to show the Google **AdMob**
    banners in our Android game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们通过使用JNI，在我们的C++游戏逻辑代码和Android应用的Java层之间创建了一个交互。在本节中，我们将修改我们的Android特定代码，以便在Android游戏中显示谷歌**AdMob**横幅。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: AdMob is a Google platform that allows you to monetize your app by displaying
    ads, it also has analytics tools, and tools for in-app purchases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AdMob是谷歌的一个平台，通过展示广告，它可以让你的应用实现盈利，同时它还具备分析工具和应用程序内购买的工具。
- en: Configuring the environment
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置环境
- en: 'In order to show the Google AdMob banners, we need to add the `Google Play
    Services` library to our project. In order to do this, we first need to download
    it and its dependency, the Android Support Library, by using the Android SDK Manager:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示谷歌AdMob横幅，我们需要将`Google Play Services`库添加到我们的项目中。为此，我们首先需要通过使用Android SDK管理器下载它及其依赖项，即Android支持库：
- en: '![Configuring the environment](img/B04193_08_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![配置环境](img/B04193_08_02.jpg)'
- en: 'After you have successfully downloaded the **Google Play Services** and its
    dependencies, you will need to add the Android.support.v4 to your project, since
    it is required by the Google Play Services library. For this, we are going to
    copy the `android-support-v4.jar` file located on the following path: `<ADT PATH>\sdk\extras\android\support\v4`
    to the `libs` folder contained in our Android project, then we are going to add
    it to our build path by right-clicking on our project in the Eclipse''s package
    explorer , then click on **Build Path**, and then click on **Configure Build Path**.
    The **Java Build Path** configuration window will show up, click on the **Add
    JARS…** button and add the `android-support-v4.jar` file in the `libs` folder.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 成功下载**Google Play Services**及其依赖项后，你需要将Android.support.v4添加到你的项目中，因为Google Play
    Services库需要它。为此，我们将复制位于以下路径的`android-support-v4.jar`文件：`<ADT PATH>\sdk\extras\android\support\v4`到Android项目中的`libs`文件夹，然后我们通过在Eclipse的包资源管理器中右键点击项目，选择**构建路径**，然后点击**配置构建路径**，将其添加到我们的构建路径中。**Java构建路径**配置窗口将出现，点击**添加JARS…**按钮并在`libs`文件夹中添加`android-support-v4.jar`文件。
- en: 'Now, we are going to copy the Google Play Services code that we have just downloaded.
    This is now located on the `<ADT PATH>\sdk\extras\google\google_play_services`
    to our workspace path. You can find out what the path to your workspace is by
    right-clicking on your Eclipse Java project, then clicking on the **properties**,
    and finally, selecting the **Resource** option on the left; there you will see
    the **Location** information as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将复制我们刚刚下载的Google Play Services代码。该代码现在位于`<ADT PATH>\sdk\extras\google\google_play_services`到我们的工作空间路径。您可以通过右键点击您的Eclipse
    Java项目，然后点击**属性**，最后选择左侧的**资源**选项来找出您的工作空间路径；在那里您将看到**位置**信息，如下面的截图所示：
- en: '![Configuring the environment](img/B04193_08_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![配置环境](img/B04193_08_03.jpg)'
- en: 'We have set up the dependency, so let us now add the Google Play Services library,
    by navigating to **File** | **import** | **Android** | **Existing Android Code
    Into Workspace** | **Browse …**. Then, browse to the location where you have copied
    the Google Play Services from the previous step. Deselect all projects but `google-play-services_lib`
    and click on **Finish**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了依赖项，现在让我们通过导航到**文件** | **导入** | **Android** | **将现有Android代码导入工作空间**
    | **浏览…**来添加Google Play Services库。然后，浏览到您在上一步中复制Google Play Services的位置。取消选择除`google-play-services_lib`之外的所有项目，并点击**完成**：
- en: '![Configuring the environment](img/B04193_08_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![配置环境](img/B04193_08_04.jpg)'
- en: 'Now that we have the `google-play-services_lib` project in our workspace, let
    us configure it as a library for our Cocos2d-x game project. For this, we are
    going to right-click our project on the package explorer again, click on the **properties**,
    click on the **Android** section in the left pane, and then at the lower bottom
    section of the screen, we are going to click the **Add…** button in order to add
    the `google-play-services_lib` library to our Eclipse project, as shown in the
    following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的工作空间中已经有了`google-play-services_lib`项目，让我们将其配置为Cocos2d-x游戏项目的库。为此，我们再次在包资源管理器中右键点击我们的项目，点击**属性**，在左侧窗格中选择**Android**部分，然后在屏幕底部的下方，我们将点击**添加…**按钮，以便将`google-play-services_lib`库添加到我们的Eclipse项目中，如下面的截图所示：
- en: '![Configuring the environment](img/B04193_08_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![配置环境](img/B04193_08_05.jpg)'
- en: Now we are all set and ready to move to our next section, where we are going
    to use the libraries that we have just added for displaying the Google AdMob ads.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以进入下一部分，我们将使用刚刚添加的库来显示Google AdMob广告。
- en: 'Now that our AdMob banner is going to be shown at the top of the screen, we
    are now going to move our mute button to the bottom, so that it is not covered
    by the banner. We are going to achieve this by changing the position of the mute
    and unmute buttons. Instead of assigning the height of the screen minus half of
    the mute sprite height as its vertical position, we will now set its *y* component
    as the screen height minus the double of the mute button''s height, as we show
    in the following line of code in the `initMuteButton` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的AdMob横幅将显示在屏幕顶部，我们现在将把静音按钮移动到底部，这样就不会被横幅覆盖。我们将通过更改静音和取消静音按钮的位置来实现这一点。不再将屏幕高度减去静音精灵高度的一半作为其垂直位置，我们现在将其*y*组件设置为屏幕高度减去静音按钮高度的两倍，如下面的代码行所示，在`initMuteButton`方法中：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Modifying the Android manifest
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Android清单
- en: In this section, we are going to modify our Android manifest in order to insert
    it in the required configuration for using the Google Play Services library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将修改Android清单，以便插入使用Google Play Services库所需的配置。
- en: 'We just need to add two snippets, one of which will be just next to the opening
    application tag that will indicate the version of the Google Play Services being
    used, as we can appreciate in the following code listing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要添加两个代码片段，其中之一将紧邻打开的应用程序标签，指示正在使用的Google Play Services版本，如下面的代码列表所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second snippet that we are going to add is the `AdActivity` declaration,
    which will be added just next to the declaration of our game activity, so that
    our game is aware of this built-in activity located in the Google Play Services
    library:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的第二个代码片段是`AdActivity`声明，它将紧邻我们游戏活动的声明添加，以便我们的游戏能够识别Google Play Services库中的这个内置活动：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the Java code
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Java代码
- en: Now that we have the libraries configured and the Android manifest modified,
    the ads library is ready for use. We are going to add an ad initialization method
    to our `AppActivity` class, and we are going to call it after we call the implementation
    of its superclass.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经配置了库并且修改了Android清单，广告库就可以使用了。我们将在`AppActivity`类中添加一个广告初始化方法，并在调用其超类的实现之后调用它。
- en: For the sake of the following example, we are going to use a sample AdMob ID,
    which you may substitute with your own ID. You can find more information about
    how to create your own AdMob ID at [http://www.google.com/admob](http://www.google.com/admob).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以下示例，我们将使用一个示例AdMob ID，您可以将其替换为自己的ID。您可以在[http://www.google.com/admob](http://www.google.com/admob)找到有关如何创建自己的AdMob
    ID的更多信息。
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In contrast to the previous section we are not using JNI, since we are not interacting
    at all with the C++ code; instead, we are modifying the Android activity that
    was created by the `cocos` command in order to add more graphic elements to view
    a side of the OpenGL E's view that was defined in the template.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节相比，我们不使用JNI，因为我们根本不与C++代码交互；相反，我们修改了由`cocos`命令创建的Android活动，以便添加更多图形元素以查看在模板中定义的OpenGL
    E视图的另一侧。
- en: We simply created a frame layout programmatically and added an `adView` instance
    to it; finally, we added this frame layout as a content view to the game activity,
    then we specified its desired position by using the gravity layout parameters,
    and this is how we were finally able to display the Google ad at the top of the
    screen. Please note that you could modify the location of the ad, that is, where
    you want it to be displayed, by simply modifying the layout parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是以编程方式创建了一个帧布局，并向其中添加了一个`adView`实例；最后，我们将这个帧布局作为内容视图添加到游戏活动中，然后通过使用重力布局参数指定其期望的位置，这样我们就能够在屏幕顶部显示Google广告。请注意，您可以修改广告的位置，即您希望它显示的位置，只需修改布局参数即可。
- en: Be aware that we have added `adView` to our frame layout after the ad was successfully
    loaded. By using `AdListener`, if you add the `adView` instance before the ad
    finishes launching, then it will not be displayed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在广告成功加载后，我们将`adView`添加到了我们的帧布局中。使用`AdListener`，如果您在广告完成启动之前添加`adView`实例，那么它将不会显示。
- en: 'This is what our Google AdMob looks like after tying everything together:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有内容整合之后，这是我们的Google AdMob的样子：
- en: '![Adding the Java code](img/B04193_08_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![添加Java代码](img/B04193_08_06.jpg)'
- en: Putting everything together
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: We have accomplished our goal of embedding the core Java code in our Cocos2d-x
    game. Now we are going to show all the parts of our game that have been modified
    throughout this chapter together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了将核心Java代码嵌入到我们的Cocos2d-x游戏中的目标。现在我们将展示本章中所有修改过的游戏部分。
- en: 'Here, we show the header file of the C++ JNI bridge (`JniBridge.h`) that we
    have created from scratch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了从零开始创建的C++ JNI桥（`JniBridge.h`）的头文件：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have defined the header of our `JniBridge`, let us write the implementation
    file (`JniBridge.cpp`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了我们的`JniBridge`的头文件，让我们编写实现文件（`JniBridge.cpp`）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let us see what our gameplay class header (`HelloWorldScene.h`) looks like
    after including our `JniBridge`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在包含了我们的`JniBridge`之后，我们的游戏玩法类头文件（`HelloWorldScene.h`）的样子：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we will show you what the `HelloWorldScene.cpp` method looks like at the
    end of this, the final chapter of the book:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向您展示在本书的最后一章末尾，`HelloWorldScene.cpp`方法的样子：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have changed the position of the mute button in the code, so that it is
    not covered by the ad:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中更改了静音按钮的位置，使其不被广告覆盖：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is what our `AppActivity.java` class looks like after all our modifications:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的修改之后，这是我们的`AppActivity.java`类的样子：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is what our `JniFacade.java` class file looks like at the end of this
    chapter: package `com.packtpub.jni`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们本章末尾的`JniFacade.java`类文件的样子：包`com.packtpub.jni`：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is what our `Android.mk` file located at `proj.android\jni` looks like
    after we add our `JniBridge.cpp` file in this chapter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中添加了我们的`JniBridge.cpp`文件后，这是我们位于`proj.android\jni`的`Android.mk`文件的样子：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, this is what our `AndroidManifest.xml` file looks like at the end
    of this book:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是本书末尾的`AndroidManifest.xml`文件的样子：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括
- en: In this chapter, we have seen how to add the interaction between our C++ game
    logic code and the Android core Java layer by using JNI, we have also displayed
    the Google AdMob banner in our game by directly modifying the Java `Activity`
    class code that was created during the invocation of the `cocos` command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用JNI，在C++游戏逻辑代码与Android的核心Java层之间添加交互，我们还通过直接修改在执行`cocos`命令时创建的Java
    `Activity`类代码，在游戏中展示了Google AdMob横幅广告。
