- en: Chapter 5. Getting Around – Pathfinding and AI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 穿梭自如 - 路径寻找与人工智能
- en: In the previous chapter, we learned about camera and lighting effects. We added
    skybox, lights, and shadows to our Tank Battle game. We created lightmaps to make
    our scene dynamic. We took a look at cookies by giving our tank headlights. We
    also took a look at projectors by creating a blob shadow for the tank. A turbo
    boost was also created for the tank. By adjusting the viewing angle of the camera,
    we were able to make the tank look as if it was going much faster than it really
    was. When we finished the chapter, we had a dynamic and exciting-looking scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了相机和光照效果。我们在坦克大战游戏中添加了天空盒、灯光和阴影。我们创建了光照图来使我们的场景动态化。我们通过给坦克车头灯添加“饼干”效果来了解了投影仪。我们还通过为坦克创建了一个斑点阴影来了解了投影仪。我们还为坦克创建了一个涡轮增压功能。通过调整相机的视角，我们能够让坦克看起来比实际速度快得多。当我们完成这一章时，我们已经拥有了一个动态且令人兴奋的场景。
- en: This chapter is all about the enemy. No longer will the player be able to just
    sit in one place to gather points. We will be adding an enemy tank to the game.
    By using Unity's NavMesh system, the tanks will be able to do pathfinding and
    chase the player. Once the player is found, the tanks will shoot and reduce the
    player's score.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全面介绍敌人。玩家将不能仅仅待在一个地方来积累分数。我们将向游戏中添加一个敌方坦克。通过使用 Unity 的 NavMesh 系统，坦克将能够进行路径寻找并追逐玩家。一旦发现玩家，坦克就会射击并减少玩家的得分。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: NavMesh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NavMesh
- en: NavMeshAgent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NavMeshAgent
- en: Pathfinding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径寻找
- en: Chase and attack AI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追逐和攻击 AI
- en: Spawn points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生点
- en: We will be adding modifications to the Tank Battle game from [Chapter 4](ch04.html
    "Chapter 4. Setting the Stage – Camera Effects and Lighting"), *Setting the Stage
    – Camera Effects and Lighting*, so load it up and we can begin.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对第 [四章](ch04.html "第四章. 设置舞台 - 相机效果与光照")《设置舞台 - 相机效果与光照》中的坦克大战游戏进行修改，所以加载它，我们可以开始。
- en: Understanding AI and pathfinding
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人工智能与路径寻找
- en: '**AI** is, as you might have guessed, **Artificial Intelligence**. In the broadest
    sense, this is anything an inanimate object might do to appear to be making decisions.
    You are probably most familiar with this concept from video games. When a character,
    not controlled by the player, selects a weapon to use and a target to use it on,
    this is AI.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，**AI** 是 **人工智能**。在最广泛的意义上，这是任何非生命体可能做的，使其看起来像是在做决定。你对此概念最熟悉的可能来自视频游戏。当一个不由玩家控制的角色选择一个武器和一个使用它的目标时，这就是
    AI。
- en: In its most complex form, AI attempts to mimic full human intelligence and learning.
    However, there is still far too much happening incredibly fast for this to truly
    succeed. Video games do not need to reach this far. We are primarily concerned
    with making our characters appear intelligent but still conquerable by our players.
    Usually, this means not allowing characters to act on more information than what
    a real player might have. Adjusting how much information characters have and can
    act on is a good way to adjust the level of difficulty in a game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最复杂的形式中，人工智能试图模仿完整的人类智能和学习。然而，对于这一切真正成功来说，发生的事情仍然太多太快。视频游戏无需达到这一步。我们主要关注的是让我们的角色看起来智能，但仍然能被玩家征服。通常，这意味着不允许角色根据比真实玩家更多的信息采取行动。调整角色拥有和可以采取行动的信息量是调整游戏难度的一个好方法。
- en: '**Pathfinding** is a subset of AI. We use it all the time, though you have
    probably never realized it. Pathfinding is, as the word suggests, the act of finding
    a path. Every time you need to find your way between any two points, you are doing
    pathfinding. As far as our characters are concerned, the simplest form of pathfinding
    is to follow a straight line to the goal point. Obviously, this method works best
    on an open plain, but tends to fail when there are any obstacles in the way. Another
    method is to overlay the game with a grid. Using the grid, we can find a path
    that goes around any obstacles and reaches our target.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径寻找** 是 AI 的一个子集。我们一直在使用它，尽管你可能从未意识到。路径寻找正如其名，是寻找路径的行为。每次你需要找到两点之间的路时，你都在进行路径寻找。就我们的角色而言，最简单的路径寻找形式是直接向目标点直线前进。显然，这种方法在开阔平原上最有效，但当遇到任何障碍物时往往会失败。另一种方法是给游戏覆盖一个网格。使用网格，我们可以找到一个绕过任何障碍物并到达我们目标的路径。'
- en: An alternative method to pathfinding, and perhaps the one most often chosen,
    makes use of a special navigation mesh, or NavMesh. This is just a special model
    that is never seen by the player but covers all of the area that a computer character
    can move around in. The player is then navigated in a way that is similar to the
    grid; the difference is that the triangles of the mesh are used rather than the
    squares of the grid. This is the method that we will be using in Unity. Unity
    provides a nice set of tools for creating the NavMesh and utilizing it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为路径查找的替代方法，或许最常被选择的一种是使用特殊的导航网格，即NavMesh。这只是一个玩家永远看不到的特殊模型，但它覆盖了计算机角色可以移动的所有区域。然后以类似于网格的方式导航玩家；不同之处在于，这里使用的是网格的三角形，而不是网格的方形。这就是我们在Unity中将使用的方法。Unity提供了一套很好的工具用于创建和利用NavMesh。
- en: The NavMesh
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavMesh
- en: Creating the navigation mesh in Unity is very simple. The process is similar
    to the one that we used for making lightmaps. We just mark some meshes to be used,
    adjust some settings in a special window, and hit a button. So, load up the Tank
    Battle game in Unity if you haven't already done so, and we can get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中创建导航网格非常简单。这个过程与我们用于制作光照图的过程类似。我们只需标记一些要使用的网格，调整特殊窗口中的某些设置，然后点击一个按钮。所以，如果你还没有加载Unity中的坦克大战游戏，现在就加载它，我们可以开始操作了。
- en: 'Unity can automatically generate a NavMesh from any meshes that exist in a
    scene. To do so, the mesh must first be marked as static, just as we did for lightmaps.
    However, we do not want or need to be able to navigate the roofs of our city,
    so we make use of a special list of settings to dictate what type of static each
    object will be. Let''s start with the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity可以自动从场景中存在的任何网格生成NavMesh。为此，首先需要将网格标记为静态，就像我们对光照图所做的那样。然而，我们并不希望或需要能够导航城市的屋顶，因此我们使用一组特殊的设置列表来指定每个对象将是什么类型的静态。让我们从以下步骤开始：
- en: Select the city from the **Hierarchy** window and click on the down arrow to
    the right of **Static** in the **Inspector** window:![The NavMesh](img/4691OT_05_01.jpg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择城市，并在**检查器**窗口中点击**Static**右侧的向下箭头：![The NavMesh](img/4691OT_05_01.jpg)
- en: 'We can take a look at the options available for static objects as follows:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以查看以下静态对象的可用选项：
- en: '**Nothing**: This option is used to quickly deselect all the other options.
    If all the other options are unchecked, this one will be checked.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：此选项用于快速取消选中所有其他选项。如果所有其他选项都未被选中，此选项将被选中。'
- en: '**Everything**: Using this option, you can quickly select all the other options.
    When all of them are checked, this one will also be checked. The checkbox next
    to the **Static** label in the **Inspector** window performs the same function
    as checking and unchecking the **Everything** checkbox.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一切**：使用此选项，你可以快速选择所有其他选项。当所有选项都被选中时，此选项也将被选中。**检查器**窗口中**Static**标签旁边的复选框与选中或取消选中**一切**复选框执行相同的功能。'
- en: '**Lightmap Static**: This option needs to be checked when working with lightmaps
    in order for them to work. Any mesh that does not have this checked will not be
    lightmapped.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照图静态**：在处理光照图时，需要选中此选项才能使它们正常工作。任何未勾选此选项的网格将不会被光照图处理。'
- en: '**Occluder Static**: This is an option for working with occlusion. **Occlusion**
    is a method of runtime optimization that involves only rendering objects that
    can actually be seen, whether or not they are within the camera''s view space.
    An **occluder** is an object that will block other objects from being seen. It
    works in conjunction with the **Occludee Static** option. The best object choices
    for this option are large and solid.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡静态**：这是用于处理遮挡的选项。**遮挡**是一种运行时优化方法，只渲染实际上可以看到的对象，无论它们是否在摄像机的视图空间内。**遮挡物**是会阻止其他对象被看到的对象。它与**被遮挡静态**选项一起工作。此选项的最佳对象选择是大型且实心的。'
- en: '**Batching Static**: This is another option for runtime optimization. Batching
    is the act of grouping objects together before rendering them. It greatly increases
    the overall render speed of a game.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量静态**：这是另一个运行时优化的选项。批量渲染是将对象组合在一起然后再渲染它们的操作。它大大提高了游戏的整体渲染速度。'
- en: '**Navigation Static**: This is the option that we are primarily concerned with
    at this point. Any mesh that has this option checked will be used when calculating
    the NavMesh.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航静态**：这是我们目前主要关心的选项。任何勾选此选项的网格在计算NavMesh时将被使用。'
- en: '**Occludee Static**: As mentioned a moment ago, this option works in conjunction
    with **Occluder Static** for the good of occlusion. An **occludee** is an object
    that will be obscured by other objects. When covered by an occluder, this object
    will not be drawn.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡对象静态**：正如刚才提到的，这个选项与**遮挡器静态**配合使用，以实现遮挡的好处。**遮挡对象**是会被其他对象遮蔽的物体。当被遮挡器覆盖时，这个物体将不会被绘制。'
- en: '**Off Mesh Link Generation**: This option also works with the NavMesh calculation.
    An off-mesh link is a connection between two parts of the NavMesh that aren''t
    physically connected, such as the roof and the street. Using a few settings in
    the **Navigation** window and this option, the links are automatically generated.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离网格链接生成**：这个选项同样与 NavMesh 计算有关。离网格链接是 NavMesh 两个不物理连接部分之间的连接，例如屋顶和街道。使用**导航**窗口中的几个设置和此选项，链接会自动生成。'
- en: '**Reflection Probe Static**: The last option allows the object to be recorded
    by reflection probes. These record everything around them and generate a cubemap
    that can be used by reflective shaders.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反射探针静态**：最后一个选项允许物体被反射探针记录。这些探针记录它们周围的一切，并生成一个可以用作反射着色器的立方体贴图。'
- en: 'In order to make the NavMesh work properly, we need to change the settings
    so that only the streets of the city can be navigated. When was the last time
    you saw a tank jump or fall from the roof of a building? So, we need to change
    the static options so that only the streets have **Navigation Static** checked.
    This can be done in one of the following two ways:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使 NavMesh 正常工作，我们需要更改设置，以便只能导航城市的街道。你上次看到坦克从建筑物屋顶跳下或掉下来是什么时候？因此，我们需要更改静态选项，使得只有街道勾选了**导航静态**。这可以通过以下两种方法之一完成：
- en: The first way is to go through and uncheck the option for each object that we
    want changed.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是我们逐一取消要更改的每个对象的选项。
- en: The second is to uncheck **Navigation Static** for the top-level object in the
    **Hierarchy** window, and when Unity asks whether we want to make the change for
    all children objects, reply with a yes. Then, go to just the objects that we want
    to navigate and recheck the option.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是，在**层级**窗口中取消勾选顶级对象的**导航静态**选项，当 Unity 询问是否要对所有子对象进行更改时，回答“是”。然后，只需对我们希望导航的对象重新勾选该选项。
- en: Now, open the **Navigation** window by going to Unity's toolbar and click on
    **Window** and then click on **Navigation** at the bottom of the menu. The following
    screenshot displays the window where all the work of making the NavMesh happens:![The
    NavMesh](img/4691OT_05_02.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过转到 Unity 的工具栏，点击**窗口**，然后点击菜单底部的**导航**来打开**导航**窗口。以下屏幕截图显示了制作 NavMesh 的所有工作发生的地方：![NavMesh](img/4691OT_05_02.jpg)
- en: 'This window consists of three pages and a variety of settings:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个窗口由三个页面和众多设置组成：
- en: When an object is selected, the settings will appear on the **Object** page.
    The two checkboxes correspond directly with the **Static** options of the same
    name that we set a moment ago. The drop-down list in **Navigation Area** lets
    us group different parts of our NavMesh. These groups can be used to affect the
    pathfinding calculation. For example, a car can be set to only travel on the road
    area and the human can follow the sidewalk area.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选择一个对象时，设置将出现在**对象**页面上。这两个复选框直接对应于我们刚才设置的同名的**静态**选项。在**导航区域**的下拉列表中，我们可以将
    NavMesh 的不同部分分组。这些组可以用来影响路径查找计算。例如，可以设置汽车只在地面上行驶，而人类可以沿着人行道区域行走。
- en: 'The **Bake** page is the one that we are interested in; it is full of options
    to change how the NavMesh will be generated. It even includes a nice visual representation
    of the various settings at the top:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**烘焙**页面是我们感兴趣的页面；它充满了改变 NavMesh 生成方式的选项。它甚至包括了一个很好的可视化表示，展示了各种设置在顶部：'
- en: '**Agent Radius**: This should be set to the size of the thinnest character.
    It is used to keep characters from walking too close to walls.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色半径**：这应该设置为最瘦的角色的大小。它用于防止角色走得太靠近墙壁。'
- en: '**Agent Height**: This is the height of your characters. Using this, Unity
    can calculate and remove areas that are too low for them to pass. Anything lower
    than this value is deemed too small, so it should be set to the height of your
    shortest character.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色高度**：这是你的角色的高度。利用这一点，Unity 可以计算出并移除那些对他们来说太低而无法通过的区域。任何低于这个值的区域都被认为是太小，因此应该将其设置为你的最矮角色的高度。'
- en: '**Max Slope**: Anything steeper than this value is ignored when calculating
    the NavMesh.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大坡度**：在计算 NavMesh 时，任何比这个值更陡的斜坡都会被忽略。'
- en: '**Step Height**: When making use of stairs, one must use this value. This is
    the maximum height of a stair that a character can step on.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步高**：在使用楼梯时，必须使用这个值。这是角色可以踏上的楼梯的最大高度。'
- en: '**Drop Height**: This is the height from which characters can fall. With it,
    paths will include jumping off ledges, if it is faster to do so.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掉落高度**：这是角色能够掉落的高度。有了这个设置，路径将包括从边缘跳下，如果这样做更快的话。'
- en: '**Jump Distance**: Using this value, characters can jump across gaps in the
    NavMesh. This value represents the longest distance that can be jumped.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳跃距离**：使用这个值，角色可以在.NavMesh的缺口处跳跃。这个值表示可以跳跃的最远距离。'
- en: '**Manual Voxel Size / Voxel Size**: By checking the **Manual Voxel Size** box,
    you can adjust the value of **Voxel Size**. This is a level of detail for the
    NavMesh. Lower values will make it more accurate to the visible mesh, but it will
    take longer to calculate and require more memory to store.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动体素大小/体素大小**：勾选**手动体素大小**复选框，你可以调整**体素大小**的值。这是.NavMesh的细节级别。值越低，与可见网格的匹配度越高，但计算时间会更长，存储所需的内存也更多。'
- en: '**Min Region Area**: If parts of the NavMesh are smaller than this value, they
    will not be used in the final NavMesh.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小区域面积**：如果.NavMesh的部分小于这个值，那么在最终的.NavMesh中将不会使用这些部分。'
- en: '**Height Mesh**: With this option checked, the original height information
    is maintained in NavMesh. Unless you have a special need for it, this option should
    remain off. It takes the system longer to calculate and requires more memory to
    store.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度网格**：勾选此选项后，原始高度信息将在.NavMesh中保持不变。除非你有特殊需要，否则这个选项应该保持关闭。系统计算需要更长的时间，存储也需要更多的内存。'
- en: The third page, **Areas**, allows us to adjust the cost of movement for each
    of our defined areas. Essentially, how difficult is it to move though different
    parts of our game world? With cars, we could adjust the layers so that it is twice
    as costly for them to move through the field than to move along the road.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三页**区域**允许我们调整我们定义的每个区域的移动成本。本质上，我们的游戏世界中不同部分的移动难度如何？对于汽车，我们可以调整层次，使其在田野中移动的成本是道路上的两倍。
- en: 'At the bottom of the window, we have the following two buttons:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在窗口底部，我们有以下两个按钮：
- en: '**Clear**: This button removes the previously created NavMesh. After using
    this button, you will need to rebake the NavMesh before you can make use of pathfinding
    again.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**：这个按钮移除之前创建的.NavMesh。使用这个按钮之后，你需要在再次使用路径查找之前重新烘焙.NavMesh。'
- en: '**Bake**: This button starts the work and creates the NavMesh.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙**：这个按钮开始工作并创建.NavMesh。'
- en: Our city is very simple, so the default values will suit us well enough. Hit
    **Bake** and watch the progress bar in the bottom-right corner. Once it is done,
    a blue mesh will appear. This is the NavMesh and it represents all of the area
    that a character can move through.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的城市非常简单，所以默认值对我们来说已经足够适用。点击**烘焙**，并观察右下角的进度条。完成之后，会出现一个蓝色网格。这就是.NavMesh，它表示角色可以移动的所有区域。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It may happen that your tanks will poke through the walls of the buildings a
    little as they move around. If they do, increase the **Agent Radius** in the **Navigation**
    window until they no longer do this.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能你的坦克在移动时会稍微穿过后建筑物墙壁。如果发生这种情况，请在**导航**窗口中增加**代理半径**，直到它们不再这样做。
- en: There is one last thing we need to do. Our NavMesh is just right, but if you
    look closely, it goes through the fountain at the center of the city. It would
    be just wrong if enemy tanks start driving through the fountain. To fix this,
    start by selecting the mesh that forms the wall around the fountain.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做最后一件事。我们的导航网格.NavMesh很完美，但如果你仔细观察，会发现它穿过了城市中心的喷泉。如果敌方坦克开始从喷泉中驶过，那就太不对了。要修复这个问题，首先选择围绕喷泉形成的网格。
- en: In Unity's toolbar, click on **Component**, followed by **Navigation**, and
    finally **Nav Mesh Obstacle**. This simply adds a component that tells the navigation
    system to go around when searching for a path. Since we had already selected the
    wall, the new component will be sized to fit; we just need to select **Capsule**
    from the **Shape** drop-down list. You can see it represented as a wire cylinder
    in the **Scene** view.![The NavMesh](img/4691OT_05_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity的工具栏中，点击**组件**，然后是**导航**，最后是**导航网格障碍**。这仅仅添加了一个告诉导航系统在寻找路径时绕道的组件。由于我们已经选择了墙壁，新组件的大小将自动适应；我们只需要从**形状**下拉列表中选择**胶囊**。你可以在**场景**视图中看到一个线框圆柱体表示它。![导航网格](img/4691OT_05_03.jpg)
- en: We created the NavMesh. We made use of the **Navigation** window and the **Static**
    options to tell Unity which meshes to use when calculating the NavMesh. The Unity
    team put a lot of work into making this process quick and easy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了NavMesh。我们利用了**导航**窗口和**静态**选项，告诉Unity在计算NavMesh时要使用哪些网格。Unity团队投入了大量工作，使得这个过程快速而简单。
- en: Remember, in [Chapter 3](ch03.html "Chapter 3. The Backbone of Any Game – Meshes,
    Materials, and Animations"), *The Backbone of Any Game – Meshes, Materials, and
    Animations*, when the challenge was to create obstacles for the player, you were
    encouraged to create additional meshes, such as tank traps and rubble. It would
    be a bad idea to let the enemy tanks drive through these as well. So, have a go
    at turning these into obstacles for the navigation system. This will be done just
    as with the fountain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第三章](ch03.html "第三章. 任何游戏的支柱 - 网格、材质和动画") *任何游戏的支柱 - 网格、材质和动画* 中，当挑战是为玩家创建障碍时，我们鼓励你创建额外的网格，比如坦克陷阱和瓦砾。让敌方坦克也驶过这些障碍是个糟糕的想法。因此，尝试将这些设置为导航系统的障碍，就像对喷泉所做的那样。
- en: The NavMeshAgent component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavMeshAgent组件
- en: 'You might be thinking that it is all well and good that we have a NavMesh,
    but there are no characters to navigate it. In this section, we will start the
    creation of our enemy tank. We will need to import and do a little setup for this
    second tank before we can do any AI type of programming. Using these steps, we
    can create it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，我们有了NavMesh是很好，但是没有角色来导航它。在本节中，我们将开始创建我们的敌方坦克。在我们可以进行任何AI编程之前，我们需要导入并进行一些设置。使用这些步骤，我们可以创建它：
- en: Select `Tanks_Type03.png` and `Tanks_Type03.blend` from the starting assets
    for the chapter and import them to the `Tanks` folder under the `Models` folder.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本章的起始资源中选择 `Tanks_Type03.png` 和 `Tanks_Type03.blend`，并将它们导入到 `Models` 文件夹下的
    `Tanks` 文件夹中。
- en: Once Unity has finished importing, select the new tank in the **Project** window
    and take a look at it in the **Inspector** window.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity导入完成后，在**项目**窗口中选择新的坦克，并在**检查器**窗口中查看它。
- en: This tank has no animations, so the **Animation Type** can be set to **None**
    and **Import Animation** can be unchecked from the **Rig** and **Animations**
    pages respectively.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个坦克没有动画，所以可以将**动画类型**设置为**无**，并分别从**骨骼**和**动画**页面取消选中**导入动画**。
- en: Drag the tank from the **Project** window to the **Scene** window; any clear
    patch of street will work just fine.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坦克从**项目**窗口拖到**场景**窗口；任何街道上的清晰区域都可以。
- en: For starters, rename the model in the **Scene** view to `EnemyTank`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**场景**视图中将模型重命名为 `EnemyTank`。
- en: Now, we need to change the parenting of the tank so that the turret can turn
    and the cannon will follow, just as we did for the player's tank. To do this,
    create an empty **GameObject** and rename it as `TurretPivot`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要改变坦克的父子关系，以便炮塔可以转动，炮管跟随，就像我们对玩家坦克所做的那样。为此，创建一个空的**游戏对象**，并将其重命名为 `TurretPivot`。
- en: Position `TurretPivot` to be at the base of the turret.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TurretPivot` 定位到炮塔底部。
- en: In the **Hierarchy** window, drag and drop `TurretPivot` onto `EnemyTank` to
    make `EnemyTank` its parent.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，将 `TurretPivot` 拖放到 `EnemyTank` 上，使 `EnemyTank` 成为它的父对象。
- en: Next, make another empty **GameObject** and rename it as `CannonPivot`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再创建一个空的**游戏对象**，并将其重命名为 `CannonPivot`。
- en: The `CannonPivot` GameObject must be made a child of `TurretPivot`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CannonPivot` 游戏对象必须设置为 `TurretPivot` 的子对象。'
- en: In the **Hierarchy** window, make the turret mesh a child of `TurretPivot` and
    the cannon mesh a child of `CannonPivot`. When Unity asks whether you are sure
    that you want to break the prefab connections, be sure to click on **Yes**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，将炮塔网格设置为 `TurretPivot` 的子对象，将炮管网格设置为 `CannonPivot` 的子对象。当Unity询问你是否确定要断开预制件连接时，一定要点击**是**。
- en: The tank is a little large, so adjust the **Scale Factor** of the tank's **Import
    Settings** in the **Inspector** window to `0.6` to give us a tank that is similar
    to the size of the player's tank.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个坦克模型有点大，因此需要在**检查器**窗口中调整坦克的**导入设置**中的**缩放因子**为 `0.6`，以便得到一个与玩家坦克大小相似的坦克。
- en: In order for the tank to navigate our new NavMesh, we need to add a **NavMeshAgent**
    component. First, select `EnemyTank` in the **Hierarchy** window, go to Unity's
    toolbar and navigate to **Component** | **Navigation** | **Nav Mesh Agent**. In
    the **Inspector** window, we can see the new component and the settings associated
    with it, as shown in the following screenshot:![The NavMeshAgent component](img/4691OT_05_04.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让坦克在我们的新NavMesh上导航，我们需要添加一个**NavMeshAgent**组件。首先，在**层次结构**窗口中选择`EnemyTank`，然后导航到Unity的工具栏，选择**组件**
    | **导航** | **Nav Mesh Agent**。在**检查器**窗口中，我们可以看到新组件及其相关设置，如下面的截图所示：![NavMeshAgent组件](img/4691OT_05_04.jpg)
- en: 'All of these settings let us control how the NavMeshAgent interacts with our
    game world. Let''s take a look at what each of them does:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些设置让我们可以控制NavMeshAgent与游戏世界的交互方式。让我们看看每个设置的作用：
- en: '**Radius**: This is simply how big the agent is. By working in conjunction
    with the value of **Radius** that we set in the **Navigation** window, this keeps
    the object from walking partly in the walls and into other agents.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：这仅表示智能体的大小。结合我们在**导航**窗口中设置的**半径**值，可以防止对象部分进入墙壁和其他智能体中。'
- en: '**Height**: This setting affects the cylinder that appears in the editor, around
    the agent. It simply sets the height of the character and affects what overhangs
    they might be able to walk under.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**：此设置影响编辑器中围绕智能体的圆柱体。它仅设置角色的高度，并影响他们可能能够走下的悬垂部分。'
- en: '**Base Offset**: This is the vertical offset of the colliders that is attached
    to the agent. It allows you to adjust what the **NavMeshAgent** component considers
    to be the bottom of your character.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基座偏移**：这是附加到智能体的碰撞体的垂直偏移量。它允许你调整**NavMeshAgent**组件认为的角色底部位置。'
- en: '**Speed**: The **NavMeshAgent** component automatically moves the connected
    object when it has a path. This value dictates how fast to follow the path in
    units per second.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：**NavMeshAgent**组件在拥有路径时自动移动连接的对象。此值决定了对象每秒沿路径移动的单位距离。'
- en: '**Angular Speed**: This is the degrees per second that the agent can turn.
    A person would have a very high angular speed, while a car''s angular speed would
    be low.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度**：这是智能体每秒可以转动的度数。人的角速度会非常高，而汽车的角速度会较低。'
- en: '**Acceleration**: This is how many units per second in speed that the agent
    gains until it reaches its maximum capacity.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度**：这是智能体每秒增加的速度单位数，直到达到其最大容量。'
- en: '**Stopping Distance**: This is the distance from the target destination at
    which the agent will start to slow down and stop.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止距离**：这是从目标目的地开始，智能体将开始减速并停止的距离。'
- en: '**Auto Braking**: With this box checked, the agent will stop as soon as it
    reaches the destination, rather than overshooting because of the irregular frame
    rate that tends to average to around 60 to 90 FPS for most games.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动刹车**：勾选此选项后，由于大多数游戏的帧率通常平均在60到90 FPS之间，导致不规则帧率，智能体到达目的地时会立即停止，而不会超出目标。'
- en: '**Obstacle Avoidance Quality / Priority**: The quality is how much effort the
    agent will put in to find a smooth path around obstacles. A higher quality means
    more effort is made to find the path. The **Priority** option dictates who has
    the right of way. An agent with a high value will go around an agent with a low
    value.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避障质量/优先级**：质量表示智能体在寻找绕过障碍物的平滑路径时付出的努力程度。质量越高，寻找路径的努力越大。**优先级**选项决定了谁有先行权。值高的智能体将绕过值低的智能体。'
- en: '**Auto Traverse Off Mesh Link**: With this box checked, the agent will use
    the off-mesh links when pathfinding, such as jumping gaps and falling off ledges.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动穿越非网格链接**：勾选此选项后，智能体在进行路径寻找时会使用非网格链接，例如跳跃间隙和从边缘跌落。'
- en: '**Auto Repath**: If the path that was found is incomplete for any reason, this
    checkbox allows Unity to automatically try to find a new one.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重新寻路**：如果找到的路径由于任何原因不完整，此复选框允许Unity自动尝试寻找新路径。'
- en: '**Area Mask**: Remember the areas that were mentioned earlier when discussing
    the **Navigation** window? This is where we can set which areas the agent is able
    to traverse. Only the areas in this list that are checked will be used for pathfinding
    by the agent.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域遮罩**：还记得之前在讨论**导航**窗口时提到的区域吗？这里我们可以设置智能体能穿越哪些区域。只有在此列表中勾选的区域才会被智能体用于路径寻找。'
- en: Now that we understand the settings, let's use them. For the enemy tank, a value
    of `2.4` for the **Radius** and `4` for the **Height** will work well. You should
    be able to see another wire cylinder in the **Scene** window, which is our enemy
    tank.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们理解了这些设置，让我们来使用它们。对于敌人坦克，**Radius**设置为`2.4`，**Height**设置为`4`将会很好。你应该能够在**场景**窗口中看到另一个线框圆柱体，那是我们的敌人坦克。
- en: The last thing to do is to turn `EnemyTank` into a prefab. Do this just as we
    did with the targets, by dragging it from the **Hierarchy** window and dropping
    it on the `Prefabs` folder in the **Project** window.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要做的最后一件事是将`EnemyTank`转变为预制体。就像我们对目标所做的那样，通过从**层次结构**窗口中拖拽它，并将其放置在**项目**窗口中的`Prefabs`文件夹里。
- en: Here, we created an enemy tank. We also learned about the settings for the **NavMeshAgent**
    component. However, if you try to play the game now, nothing will appear to happen.
    This is because the **NavMeshAgent** component is not being given a destination.
    We will resolve this in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个敌人坦克。我们还了解了**NavMeshAgent**组件的设置。但是，如果你现在尝试运行游戏，似乎什么也不会发生。这是因为**NavMeshAgent**组件没有被指定一个目的地。我们将在下一节解决这个问题。
- en: Making the enemy chase the player
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让敌人追踪玩家
- en: Our next task is to make our enemy tank chase the player. We will need two scripts
    for this. The first will simply advertise the player's current position. The second
    will use that position and the **NavMeshAgent** component that we set up earlier
    to find a path to the player.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个任务是让我们的敌人坦克追踪玩家。为此我们需要两个脚本。第一个脚本将简单地广播玩家的当前位置。第二个脚本将使用这个位置和我们之前设置的**NavMeshAgent**组件找到通往玩家的路径。
- en: Revealing the player's location
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示玩家的位置
- en: 'With a very short script, we can easily allow all our enemies to know the location
    of the player. A few short steps to create it are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个非常简短的脚本，我们可以轻松地让所有敌人知道玩家的位置。创建它的几个简短步骤如下：
- en: Start by creating a new script in the `Scripts` folder of the **Project** window.
    Name it `PlayerPosition`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**项目**窗口的`Scripts`文件夹中创建一个新的脚本。将其命名为`PlayerPosition`。
- en: This script will start with a single static variable. This variable will simply
    hold the current position of the player. As it is static, we will be able to easily
    access it from the rest of our scripts.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本将从单一的静态变量开始。这个变量将简单地保存玩家的当前位置。由于它是静态的，我们可以很容易地从其他脚本访问它。
- en: '[PRE0]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We chose to use a static variable here for its simplicity and speed. Alternatively,
    we could have added a few extra steps to our enemy tank; it could have used the
    `FindWithTag` function when the game started to actually find the player tank
    and store it in a variable. Then, it could query that variable when it looks for
    the player's position. This is just one more way, among the multitude of ways,
    in which we could have gone about it.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择在这里使用静态变量，因为它的简单性和速度。另外，我们也可以为敌人坦克增加几个额外步骤；它可以在游戏开始时使用`FindWithTag`函数实际找到玩家坦克并将其存储在一个变量中。然后，在寻找玩家位置时查询该变量。这是我们可以采取的多种方法中的另一种。
- en: For the next few lines of code, we make use of the `Start` function. This function
    is automatically called when a scene is first loaded. We use it so that the `position`
    variable can be filled and used as soon as the game starts.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的几行代码中，我们将使用`Start`函数。这个函数在场景首次加载时自动调用。我们使用它是为了让`position`变量在游戏开始时就能填充并使用。
- en: '[PRE1]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last segment of the code simply updates the `position` variable in every
    frame to the player's current position. We also do this in the `LateUpdate` function
    so that the update is done after the player has moved. The `LateUpdate` function
    is called at the end of every frame. With this, the player is able to move during
    the `Update` function and their position is updated later.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后一段只是简单地更新了每一帧中的`position`变量，使其等于玩家的当前位置。我们还选择在`LateUpdate`函数中这样做，以便在玩家移动后再更新。`LateUpdate`函数在每一帧的末尾被调用。这样，玩家可以在`Update`函数中移动，而他们的位置会在稍后更新。
- en: '[PRE2]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last thing to do with this script is to add it to the player's tank. So,
    return to Unity and drag and drop the script from the **Project** window to the
    tank to add it as a component, just as we did it for all our other scripts.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个脚本需要做的最后一件事是将其添加到玩家的坦克中。因此，回到Unity，将脚本从**项目**窗口拖放到坦克上，以添加它作为一个组件，就像我们对所有其他脚本所做的那样。
- en: Here, we created the first script that is needed for our chase AI. This script
    simply updates a variable with the player's current position. We will make use
    of it in our next script where we will make the enemy tank move around.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了追逐AI所需的首个脚本。这个脚本只是用一个变量更新玩家的当前位置。我们将在下一个脚本中使用它，让敌方坦克四处移动。
- en: Chasing the player
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追逐玩家
- en: 'Our next script will control our simple chase AI. Since we are making use of
    the **NavMesh** and **NavMeshAgent** components, we can leave nearly all the difficult
    portions of pathfinding to Unity. Let''s create the script by performing these
    steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个脚本将控制我们简单的追逐AI。由于我们使用了**NavMesh**和**NavMeshAgent**组件，我们可以将路径查找的大部分困难部分留给Unity。通过执行以下步骤来创建脚本：
- en: Again, create a new script. This time, name it `ChasePlayer`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，创建一个新的脚本。这次，将其命名为`ChasePlayer`。
- en: The first line of this script holds a reference to the **NavMeshAgent** component
    that we set up earlier. We need access to this component in order to move the
    enemy tank.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的第一行保存了之前设置的**NavMeshAgent**组件的引用。我们需要访问这个组件以便移动敌方坦克。
- en: '[PRE3]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last segment of the code first makes sure that we have our **NavMeshAgent**
    reference and then updates our goal destination. It uses the `PlayerPosition`
    script's variable that was set up earlier and the `SetDestination` function from
    the **NavMeshAgent**. Once we tell the function where to go, the **NavMeshAgent**
    component does all the hard work of getting us there. We update our goal destination
    in the `FixedUpdate` function because we do not need to update the destination
    in every frame. Updating this too often could cause a serious lag issue if there
    are a whole lot of enemies. The `FixedUpdate` function is called at regular intervals
    and is slower than the frame rate, so it is perfect.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后一段首先确保我们有**NavMeshAgent**的引用，然后更新我们的目标目的地。它使用了之前设置的`PlayerPosition`脚本的变量和**NavMeshAgent**的`SetDestination`函数。当我们告诉函数去哪里时，**NavMeshAgent**组件就会完成所有到达那里的艰苦工作。我们在`FixedUpdate`函数中更新我们的目标目的地，因为我们不需要在每一帧都更新目的地。如果有很多敌人，过于频繁地更新这可能会导致严重的滞后问题。`FixedUpdate`函数以固定的时间间隔被调用，并且比帧率慢，所以它非常合适。
- en: '[PRE4]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now need to add the script to our enemy tank. Select the prefab in the **Project**
    window and drag and drop the script in the **Inspector** panel, underneath the
    **NavMeshAgent** component.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将脚本添加到我们的敌方坦克中。在**项目**窗口中选择预制体，并将脚本拖放到**检查器**面板中，位于**NavMeshAgent**组件下方。
- en: Be sure to connect the reference, as we did previously. Drag the **NavMeshAgent**
    component to the **Agent** value in the **Inspector** window.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保像之前一样连接引用。将**NavMeshAgent**组件拖到**检查器**窗口中的**Agent**值。
- en: Play the game now to try it out. Irrespective of the location where the enemy
    starts, it finds its way around all the buildings and makes it to the player's
    position. As you drive around, you can watch the enemy follow. However, the enemy
    tank could end up going through our tank and we could drive through it as well.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行游戏来尝试一下。无论敌人从哪里开始，它都会绕过所有建筑物，到达玩家的位置。当你在周围驾驶时，你可以看到敌人跟随。然而，敌方坦克可能会穿过我们的坦克，我们也可能会驾驶穿过它。
- en: The first step to fix this is to add some colliders. Add a **Box Collider**
    component by using the **Physics** option in the **Component** menu for the turret,
    chassis, and each of the **TreadCase** objects. Neither the cannon nor the treads
    need colliders. The tread casings already cover the area of the treads, and the
    cannon is too small a target to be shot at properly.![Chasing the player](img/4691OT_05_05.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复这个问题的第一步是添加一些碰撞器。使用**组件**菜单中的**物理**选项，为炮塔、底盘和每个**TreadCase**对象添加**盒状碰撞器**。炮管和履带不需要碰撞器。履带箱体已经覆盖了履带的区域，而炮管作为目标太小，无法被准确射击。![追逐玩家](img/4691OT_05_05.jpg)
- en: Note
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are making any of these changes in the **Scene** view, be sure to click
    on the **Apply** button in the **Inspector** window to update the root prefab
    object.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你是在**场景**视图中进行这些更改，请确保点击**检查器**窗口中的**应用**按钮，以更新根预制对象。
- en: The last thing to change is the **Stopping Distance** property on the **NavMeshAgent**
    component. When the tanks engage, they move into range and start firing. They
    do not try to occupy the same space as the enemy, unless that enemy is small and
    squishy. By setting **Stopping Distance** to `10`, we will be able to replicate
    this behavior.![Chasing the player](img/4691OT_05_06.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要更改的最后一点是**NavMeshAgent**组件上的**停止距离**属性。当坦克交战时，它们会移动到射程内并开始开火。除非敌人小而脆弱，否则它们不会试图占据与敌人相同的空间。将**停止距离**设置为`10`，我们将能够复制这种行为。[追逐玩家](img/4691OT_05_06.jpg)
- en: In this section, we created a script that causes a **NavMeshAgent** component,
    in this case our enemy tank, to chase the player. We added colliders to stop us
    from driving through the enemy. In addition, we adjusted the value of **Stopping
    Distance** to give us a better tank behavior.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个脚本，使**NavMeshAgent**组件（在本例中是我们的敌人坦克）追逐玩家。我们添加了碰撞器以防止我们驶过敌人。此外，我们调整了**停止距离**的值，以获得更好的坦克行为。
- en: Try adding a blob shadow to the enemy tank. This will give it a better visual
    sense of being grounded. You can just copy the one that was made for the player's
    tank.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为敌人坦克添加一个斑点阴影。这将使它有更好的视觉接地感。你可以直接复制为玩家坦克制作的那个。
- en: Being attacked by the enemy
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被敌人攻击
- en: What fun is a game without a little conflict; the nagging choice is whether
    to fight to the death or the doom of the cosmos? Every game needs some form of
    conflict to drive the player towards seeking a resolution. Our game will become
    a battle for points. Before, this just involved shooting some targets and getting
    some points.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一点冲突，游戏还有什么乐趣；是选择战斗至死还是宇宙毁灭的烦恼？每个游戏都需要某种形式的冲突来推动玩家寻求解决方案。我们的游戏将变成一场分数争夺战。之前，这只是涉及射击一些目标并获得一些分数。
- en: 'Now, we will make the enemy tank shoot at the player. Every time the enemy
    scores a hit, we will reduce the player''s score by a few points. The enemy will
    shoot in a similar manner to how the player fires, but we will use some basic
    AI to control the direction and firing speed and replace the player''s input controls.
    These steps will help us do it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使敌人坦克向玩家开火。每次敌人得分，我们都会减少玩家的分数。敌人将以与玩家开火类似的方式射击，但我们将使用一些基本的AI来控制方向和射击速度，并替换玩家的输入控制。这些步骤将帮助我们实现它：
- en: We will start this off with a new script called `ShootAtPlayer`. Create it in
    the `Scripts` folder.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从名为`ShootAtPlayer`的新脚本开始。在`Scripts`文件夹中创建它。
- en: As with all our other scripts, we start this one out with two variables. The
    first variable will hold the last position of the enemy tank. The tank will not
    be shooting if it is in motion, so we need to store its last position to see whether
    it has moved. The second variable will be the maximum speed at which we can move
    and shoot. If the tank moves faster than this, it will not fire.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们所有的其他脚本一样，我们从两个变量开始。第一个变量将保存敌人坦克的最后位置。如果坦克在移动，它不会射击，因此我们需要存储其最后位置以查看它是否移动。第二个变量将是我们可以移动和射击的最大速度。如果坦克移动速度超过这个速度，它将不会开火。
- en: '[PRE5]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next two variables dictate how long it takes for the tank to ready a shot.
    It is unrealistic to be shooting at the player in every single frame. So, we use
    the first variable to adjust the length of time it takes to ready a shot and the
    second to store when the shot will be ready:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个变量决定了坦克准备射击所需的时间。在每一帧都对玩家射击是不现实的。因此，我们使用第一个变量来调整准备射击所需的时间长度，第二个变量来存储射击将准备好的时间：
- en: '[PRE6]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next variable contains the value of how fast the turret can rotate. While
    the tank is readying its shot, the turret will not be rotating to point at the
    player. That gives the player an opportunity to move out of the way. However,
    we need a speed variable to keep the turret from snapping to face the player after
    it has finished shooting.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量包含了炮塔旋转的速度值。当坦克准备射击时，炮塔不会旋转指向玩家。这给了玩家一个移开的机会。然而，我们需要一个速度变量，以防止炮塔在射击完毕后立即转向面对玩家。
- en: '[PRE7]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last three variables here hold references to other parts of the tank. The
    `turretPivot` variable is, of course, the pivot of the turret that we will rotate.
    The `muzzlePoint` variable will be used as the point from where our cannon will
    be fired. These will be used in the same manner as the ones for the player's tank.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的最后三个变量引用了坦克其他部分的引用。`turretPivot`变量当然是我们要旋转的炮塔的支点。`muzzlePoint`变量将被用作我们开火的大炮的起点。这些将和玩家坦克的使用方式相同。
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the first function of the script, we will make use of the `Update` function.
    It starts by calling a function that will check to see whether it is possible
    to fire the cannon. If we can fire, we will perform some checks on our `readyTime`
    variable. If it is less than zero, we have not yet begun to ready our shot and
    call a function to do so. However, if it is less than the current time, we have
    finished the preparation and call the function to fire the cannon. If we are unable
    to fire, we first call a function to clear any preparations and then rotate the
    turret to face the player.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于脚本的第一个函数，我们将使用`Update`函数。它首先调用一个函数来检查是否可以开火。如果我们能开火，将对`readyTime`变量进行一些检查。如果它小于零，说明我们还没有开始准备射击，并调用一个函数来进行准备。然而，如果它小于当前时间，说明我们已经完成了准备，并调用开火的函数。如果我们无法开火，我们首先调用一个函数来清除任何准备，然后将炮塔转向玩家。
- en: '[PRE9]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will create our `CheckCanFire` function. The first part of the code
    checks to see whether we have moved too fast. First, we use `Vector3.Distance`
    to see how far we have moved since the last frame. By dividing the distance by
    the length of the frame, we are able to determine the speed with which we moved.
    Next, we update our `lastPosition` variable with our current position so that
    it is ready for the next frame. Finally, we compare the current speed with `maxSpeed`.
    If we moved too fast in this frame, we will be unable to fire and return a result
    as `false`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的`CheckCanFire`函数。代码的第一部分检查我们是否移动得太快。首先，我们使用`Vector3.Distance`来查看自上一帧以来我们移动了多远。通过将距离除以帧的长度，我们能够确定我们移动的速度。接下来，我们用当前的位置更新`lastPosition`变量，以便为下一帧做好准备。最后，我们将当前速度与`maxSpeed`进行比较。如果我们在这帧中移动得太快，我们将无法开火，并返回一个`false`的结果：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the second half of the `CheckCanFire` function, we will check to see whether
    the turret is pointed at the player. First, we will find the direction to the
    player. By subtracting the second point''s location from that of any given point
    in space, we will get the vector value of the first point with respect to the
    second point. We will then flatten the direction by setting the `y` value to `0`.
    This is done because we do not want to be looking up or down at the player. Then,
    we will use `Vector3.Angle` to find the angle between the direction to the player
    and our turret''s forward direction. Finally, we will compare the angle to a low
    value to determine whether we are looking at the player and return the result:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`CheckCanFire`函数的另一半，我们将检查炮塔是否指向玩家。首先，我们将找到指向玩家的方向。通过从空间中任意给定点的位置减去第二个点的位置，我们将得到第一个点相对于第二个点的向量值。然后，我们将通过将`y`值设置为`0`来使方向扁平化。这样做是因为我们不希望上下看玩家。然后，我们将使用`Vector3.Angle`来找到指向玩家的方向和我们的炮塔前方方向之间的角度。最后，我们将比较角度与一个低值，以确定我们是否在看着玩家并返回结果：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `PrepareFire` function is quick and easy. It simply sets our `readyTime`
    variable to the time in the future when the tank would have prepared its shot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrepareFire`函数简单快捷。它仅仅将我们的`readyTime`变量设置为一个未来的时间点，那时坦克将准备好射击：'
- en: '[PRE12]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Fire` function starts by making sure that we have a `muzzlePoint` reference
    to shoot from:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fire`函数首先确保我们有一个从`muzzlePoint`射击的引用：'
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function continues with the creation of a `RaycastHit` variable to store
    the result of our shot. We use `Physics.Raycast` and `SendMessage`, just as we
    did in the `FireControls` script, to shoot at anything and tell it that we hit
    it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数继续创建一个`RaycastHit`变量来存储我们射击的结果。我们使用`Physics.Raycast`和`SendMessage`，就像在`FireControls`脚本中所做的那样，射击任何东西并告诉它我们击中了它：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Fire` function finishes by clearing the fire preparations:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fire`函数最后通过清除射击准备来完成：'
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ClearFire` function is another quick function. It sets our `readyTime`
    variable to be less than zero, indicating that the tank is not preparing to fire:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClearFire`函数是另一个简单的函数。它将我们的`readyTime`变量设置为小于零，表示坦克没有准备开火：'
- en: '[PRE16]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last function is `RotateTurret`. It begins by checking the `turretPivot`
    variable and cancels the function if the reference is missing. This is followed
    by the finding of a direction that points at the player, just as we did earlier.
    This direction is flattened by setting the `y` axis to `0`. Next, we will create
    the `step` variable to specify how much we can move this frame. We use `Vector3.RotateTowards`
    to find a vector that is closer to pointing at our target than the current forward
    direction. Finally, we use `Quaternion.LookRotation` to create a special rotation
    that points our turret in the new direction.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数是`RotateTurret`。它首先检查`turretPivot`变量，如果引用缺失则取消函数。这之后是寻找指向玩家的方向，正如我们之前所做的。通过将`y`轴设置为`0`来扁平化这个方向。接下来，我们将创建`step`变量以指定我们这一帧可以移动多少。我们使用`Vector3.RotateTowards`来找到一个比当前向前方向更接近指向目标的向量。最后，我们使用`Quaternion.LookRotation`创建一个特殊的旋转，使我们的炮塔朝向新方向。
- en: '[PRE17]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, by returning to Unity, create an empty **GameObject** and rename it as
    `MuzzlePoint`. Position `MuzzlePoint` like we did for the player, at the end of
    the cannon.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到 Unity，创建一个空的**GameObject**并将其重命名为`MuzzlePoint`。将`MuzzlePoint`放置在炮管末端，就像我们对玩家所做的那样。
- en: Make `MuzzlePoint` a child of the cannon and zero out any **Y** rotation that
    might be on it in the **Inspector** window.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MuzzlePoint`设置为炮管的子对象，并在**Inspector**窗口中将可能存在的任何**Y**轴旋转归零。
- en: Next, add our new `ShootAtPlayer` script to the enemy tank. Additionally, connect
    the references to the `TurretPivot` and `MuzzlePoint` variables.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将我们新的`ShootAtPlayer`脚本添加到敌方坦克中。此外，连接到`TurretPivot`和`MuzzlePoint`变量的引用。
- en: Finally, for the enemy tank, hit the **Apply** button in the **Inspector** window
    to update the prefab.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于敌方坦克，在**Inspector**窗口中点击**Apply**按钮以更新预制体。
- en: If you play the game now, you will see the enemy rotating to point at you, but
    our score will not decrease. This is because of two reasons. First, the tank is
    slightly floating. It doesn't matter where in the world you place it; when you
    play the game, the tank will slightly float. This is because of the way the `NavMeshAgent`
    component functions. The fix is simple; just set **BaseOffset** to `-0.3` in the
    **Inspector** window. This adjusts the system and puts the tank on the ground.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩这个游戏，你会看到敌人旋转以指向你，但我们的分数不会减少。这是由于两个原因。首先，坦克略微浮空。无论你将其放置在世界上的哪个位置；当你玩游戏时，坦克会略微浮空。这是由于`NavMeshAgent`组件的工作方式。修复方法很简单；只需在**Inspector**窗口中将**BaseOffset**设置为`-0.3`。这调整了系统并将坦克放置在地面上。
- en: The second reason the score isn't changing is because the player is missing
    a function. To fix this, open the `ScoreCounter` script.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分数没有变化的第二个原因是玩家缺少一个函数。为了解决这个问题，打开`ScoreCounter`脚本。
- en: 'We will add the `RemovePoints` function. Given an amount, this function simply
    removes that many points from the player''s score:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加`RemovePoints`函数。给定一个数值，这个函数简单地将玩家分数中那么多点数减掉：
- en: '[PRE18]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If your enemy tank is still unable to hit the player, it may be too big and
    is shooting over the player. Just tilt the tank's cannon down so that when it
    is shooting at the player, it also points towards the center of the player's tank.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的敌方坦克仍然无法击中玩家，可能是因为它太大，射击时越过了玩家。只需将坦克的炮管向下倾斜，这样当它向玩家射击时，也会指向玩家坦克的中心。
- en: If you take a look at the score counter in the top-right corner, the score will
    go down when the enemy gets close. Remember, it will not start dropping immediately
    because the enemy needs to stop moving, to ready the cannon, before they can shoot.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你看看右上角的分数计数器，当敌人靠近时分数会下降。记住，分数不会立即开始下降，因为敌人需要停止移动，准备好炮管，然后才能射击。
- en: '![Being attacked by the enemy](img/4691OT_05_07.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![遭受敌人攻击](img/4691OT_05_07.jpg)'
- en: We gave the enemy the ability to attack the player. The new `ShootAtPlayer`
    script first checks to see whether the tank has slowed down and the cannon is
    trained on the player. If so, it will take regular shots at the player to reduce
    their score. The player is going to need to keep moving and aim at targets fast
    if they hope to be left with any points at the end of the game.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赋予了敌人攻击玩家的能力。新的`ShootAtPlayer`脚本首先检查坦克是否已经减速并且炮管是否对准了玩家。如果是这样，它将定期向玩家开火以减少他们的分数。如果玩家希望在游戏结束时还能留下一些分数，他们就需要不停地移动并快速瞄准目标。
- en: Unless you are paying close attention to your score, it is difficult to tell
    when you are being shot at. We will be working with explosions in a future chapter,
    but even so, the player needs some feedback to tell what is going on. Most games
    will flash a red texture on the screen when the player is hit, whether or not
    there are any explosions. Try creating a simple texture and drawing it on the
    screen for half a second when the player is hit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不密切关注你的得分，就很难判断你是否正在被攻击。我们将在未来的章节中处理爆炸效果，但即便如此，玩家需要一些反馈来了解发生了什么。大多数游戏会在玩家被击中时在屏幕上闪烁红色纹理，不管是否有爆炸效果。尝试创建一个简单的纹理，并在玩家被击中时在屏幕上绘制半秒钟。
- en: Attacking the enemy
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击敌人
- en: Players tend to become frustrated quickly when faced with an enemy that they
    are unable to fight against. So, we are going to give our player the ability to
    damage and destroy the enemy tank. This will function in a similar manner to how
    the targets are shot.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家面对一个无法对抗的敌人时，他们往往会很快感到沮丧。因此，我们将赋予玩家伤害和摧毁敌人坦克的能力。这将以与射击目标类似的方式运作。
- en: 'The easiest way to weaken our enemies is to give them some health that will
    reduce when they are shot. We can then destroy them when they run out of health.
    Let''s create a script with these steps to do this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 削弱敌人的最简单方法就是给它们一些生命值，当它们被击中时生命值会减少。然后当它们的生命值耗尽时，我们可以摧毁它们。让我们按照以下步骤创建一个脚本来实现这一点：
- en: We will start by creating a new script and naming it `Health`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建一个名为`Health`的新脚本开始。
- en: This script is rather short and starts with a single variable. This variable
    will keep track of the remaining health of the tank. By setting the default value
    to `3`, the tank will be able to survive three hits before being destroyed.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本相当简短，从一个变量开始。这个变量将跟踪坦克剩余的生命值。通过将默认值设置为`3`，坦克在遭到摧毁前能够承受三次打击。
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This script also contains only one function, `Hit`. As in the case of the targets,
    this function is called by the `BroadcastMessage` function when the player shoots
    at it. The first line of the function reduces `health` by one point. The next
    line checks to see whether `health` is below zero. If it is, the tank is destroyed
    by calling the `Destroy` function and passing the `gameObject` variable to it.
    We also give the player a handful of points.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本也只包含一个函数，`Hit`。与目标的情况一样，当玩家向它射击时，这个函数是由`BroadcastMessage`函数调用的。函数的第一行将`health`减少一个点数。下一行检查`health`是否小于零。如果是，通过调用`Destroy`函数并传递`gameObject`变量来摧毁坦克。同时我们也给玩家一些分数。
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It really is just that simple. Now, add the new script to the `EnemyTank` prefab
    in the **Project** window, and it will update all the enemy tanks that you currently
    have in the scene.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的就是这么简单。现在，在**项目**窗口中为`EnemyTank`预制体添加新的脚本，它将更新场景中你当前所有的敌人坦克。
- en: 'Try this out: add a few extra enemy tanks to the scene and watch them follow
    you around and disappear when you shoot them.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试这样做：向场景中添加几个额外的敌人坦克，观察它们跟随你并在你射击它们时消失。
- en: Here, we gave the enemy tank a weakness, health. By creating a short script,
    the tank is able to track its health and detect when it has been shot. Once the
    tank runs out of health, it is removed from the game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们给敌人坦克设置了一个弱点，即生命值。通过创建一个简短的脚本，坦克能够追踪自己的生命值并在被击中时检测到。一旦坦克的生命值耗尽，它就会从游戏中移除。
- en: 'We now have two targets to shoot at: the animated ones and the tank. However,
    they are both indicated with red slices. Try to make the ones that point at tanks
    to be of a different color. You will have to make a duplicate of the `IndicatorSlice`
    prefab and change the `IndicatorControl` script so that it can be told which type
    of slice to use when the `CreateSlice` and `NewSlice` functions are called.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个目标可以射击：一个是动画目标，另一个是坦克。然而，它们都用红色切片表示。尝试将指向坦克的切片设置为不同的颜色。你需要复制一个`IndicatorSlice`预制体，并更改`IndicatorControl`脚本，以便在调用`CreateSlice`和`NewSlice`函数时，它能知道应该使用哪种类型的切片。
- en: As a further challenge, the moment we give a creature some health, players want
    to be able to see how much damage they have done to it. There are two ways you
    could do this. First, you could put a cluster of cubes above the tank. Then, each
    time the tank loses health, you will have to delete one of the cubes. The second
    option is a little more difficult—drawing the bar in the GUI and changing its
    size based on the remaining health. To make the bar stay above the tank as the
    camera moves around, take a look at `Camera.WorldToScreenPoint` in the documentation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的挑战，一旦我们给一个生物体赋予生命值，玩家应该能够看到他们对它造成了多少伤害。有两种方法可以实现这一点。第一种是在坦克上方放置一组方块。然后，每次坦克失去生命值时，你将移除一个方块。第二种方法稍微复杂一些——在
    GUI 中绘制一个条形图，并根据剩余的生命值改变其大小。为了使条形图在摄像机移动时保持在坦克上方，请查看文档中的`Camera.WorldToScreenPoint`。
- en: Spawning enemy tanks
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成敌人坦克
- en: Having a limited number of enemies in the game at the beginning is not suitable
    for our game to have lasting fun. Therefore, we need to make some spawn points.
    As tanks are destroyed, these will make new tanks appear to keep the player on
    their toes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏初期拥有有限数量的敌人并不适合我们游戏的长久乐趣。因此，我们需要制作一些生成点。随着坦克的摧毁，这些生成点将使玩家保持警惕。
- en: 'The script that we will create in this section will keep our game world populated
    with all the enemies that our player might want to destroy. These steps will let
    us spawn the enemy tanks:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将创建的脚本将保持游戏世界中充满玩家可能想要摧毁的敌人坦克：
- en: We need another new script for this section. Once this is created, name it `SpawnPoint`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本节我们需要另一个新脚本。创建后，将其命名为`SpawnPoint`。
- en: This script begins simply with a few variables. The first variable will hold
    a reference to our `EnemyTank` prefab. We need it so that we can spawn duplicates.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从几个变量开始。第一个变量将保存对我们`EnemyTank`预制体的引用。我们需要它来生成副本。
- en: '[PRE21]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second variable tracks the spawned tank. When it is destroyed, we will create
    a new one. Using this variable, we prevent the game from becoming overwhelmed
    with the enemy. There will only be as many tanks as spawn points.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个变量用于跟踪已生成的坦克。当坦克被摧毁时，我们将创建一个新的。通过这个变量，我们防止游戏因敌人过多而变得混乱。生成的坦克数量将等同于生成点的数量。
- en: '[PRE22]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The third variable is for setting a distance between the spawning tanks and
    the player to prevent the spawning tanks from appearing on top of the player.
    If the player is outside this distance, a new tank can be spawned. If they are
    within, a new tank will not be spawned.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个变量用于设置玩家与生成坦克之间的距离，以防止坦克在玩家上方生成。如果玩家处于此距离之外，可以生成新坦克。如果玩家在范围内，则不会生成新坦克。
- en: '[PRE23]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first function that we will use is `FixedUpdate`. This will start by checking
    a function to see whether it needs to spawn a new tank. If it does, it will call
    the `SpawnTank` function to do so:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用的第一个函数是`FixedUpdate`。它会先检查是否需要生成一个新的坦克。如果需要，它会调用`SpawnTank`函数来进行生成：
- en: '[PRE24]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we create the `CanSpawn` function. The first line of the function checks
    to see whether we already have a tank and returns `false` if we do. The second
    line uses `Vector3.Distance` to determine how far away the player currently is.
    The last line compares that distance with the minimum distance that the player
    needs to be before we can spawn anything, and it then returns the result:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`CanSpawn`函数。该函数的第一行检查我们是否已经有了一个坦克，如果有则返回`false`。第二行使用`Vector3.Distance`来确定玩家当前的距禨。最后一行将这个距离与玩家需要达到的最小距离进行比较，然后返回结果：
- en: '[PRE25]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The last function, `SpawnTank`, starts by checking to make sure that the `tankPrefab`
    reference has been connected. It can't continue if there is nothing to spawn.
    The second line uses the `Instantiate` function to create a duplicate of the prefab.
    In order to store it in our variable, we use `as GameObject` to make it the proper
    type. The last line moves the new tank to the spawn point's position as we don't
    want the tanks to appear at random locations.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数`SpawnTank`，首先检查`tankPrefab`引用是否已连接。如果没有东西可以生成，它就不能继续。第二行使用`Instantiate`函数来复制预制体。为了将其存储在我们的变量中，我们使用`as
    GameObject`以确保正确的类型。最后一行将新坦克移动到生成点的位置，因为我们不希望坦克在随机位置出现。
- en: '[PRE26]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意：
- en: We again chose to use the `Instantiate` and `Destroy` functions to handle the
    creation and deletion of our enemy tanks due to their simplicity and speed. Alternatively,
    we could have created a list of available enemies. Then, every time our player
    kills one, we could turn it off (instead of completely destroying it), just move
    an old one to where we need it (instead of creating a new one), reset the old
    one's stats, and turn it on. There will always be multiple ways to program everything,
    and this is just one alternative.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次选择使用`Instantiate`和`Destroy`函数来处理敌军坦克的创建和销毁，因为它们的简单性和速度。另外，我们也可以创建一个可用敌人列表。然后，每当玩家消灭一个敌人，我们可以将其关闭（而不是完全销毁），只需将一个旧的移动到需要的位置（而不是创建一个新的），重置旧坦克的状态，并重新激活它。编程任何事情都会有多种方法，这只是其中一种替代方案。
- en: Return to Unity, create an empty **GameObject**, and rename it as `SpawnPoint`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，创建一个空的**GameObject**，并将其重命名为`SpawnPoint`。
- en: Add the `SpawnPoint` script, which we just created, to it.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加我们刚刚创建的`SpawnPoint`脚本。
- en: Next, with the spawn point selected, connect the prefab reference by dragging
    the `EnemyTank` prefab from the `Prefabs` folder and drop it on the appropriate
    value.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择出生点，通过将`EnemyTank`预制体从`Prefabs`文件夹拖拽到相应的值上，连接预制体引用。
- en: Now, turn the `SpawnPoint` object into a prefab by dragging and dropping it
    from the **Hierarchy** window into the `Prefabs` folder.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`SpawnPoint`对象通过从**Hierarchy**窗口拖拽并放入`Prefabs`文件夹中，将其转变为预制体。
- en: Finally, populate the city with the new points. Positioning one in each corner
    of the city will work well.![Spawning enemy tanks](img/4691OT_05_08.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用新的点来填充城市。在每个角落放置一个会工作得很好。![生成敌军坦克](img/4691OT_05_08.jpg)
- en: Here, we created spawn points for the game. Each point will spawn a new tank.
    When a tank is destroyed, a new one will be created at the spawn point. Feel free
    to build the game and try it out on your device. This section and chapter are
    now complete and ready to be wrapped up.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为游戏创建了出生点。每个点都会生成一辆新坦克。当一辆坦克被摧毁时，在出生点会创建一辆新的。随意构建游戏并在你的设备上尝试。这一节和这一章现在完成了，准备收尾。
- en: Having one spawn point per tank is great, until we want many tanks or we wish
    them all to spawn from the same location. Your challenge here is to make a single
    spawn point to track multiple tanks. If any one of the tanks is destroyed, a new
    one should be created. You will definitely need an array to keep track of all
    the tanks. In addition, you could implement a delay for the spawn process as you
    won't want multiple tanks spawning on top of each other. This could cause them
    to suddenly jump as the **NavMeshAgent** component does its best to keep them
    from occupying the same space. In addition, the player might also think that they
    are only fighting one tank, when in fact there are several tanks in the same spot.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为每辆坦克设置一个出生点是很好的，直到我们想要很多坦克，或者希望它们都从同一个位置出生。这里的挑战是，你需要让一个出生点跟踪多辆坦克。如果任何一辆坦克被摧毁，应该创建一辆新的。你肯定需要一个数组来跟踪所有坦克。此外，你还可以为出生过程实现一个延迟，这样就不会有多个坦克堆叠在同一个位置出生。这可能导致它们突然跳跃，因为**NavMeshAgent**组件会尽力防止它们占据同一空间。另外，玩家可能会认为他们只在与一辆坦克战斗，而实际上在同一个位置可能有几辆坦克。
- en: Now that you have all the knowledge and tools that you need, as a further challenge,
    try to create other types of enemy tanks. You can experiment with size and speed.
    They can also have different strengths, or you could give more points when enemy
    tanks are destroyed. Perhaps, there is a tank that actually gives the player points
    when shooting at them. Play around with the game and have some fun with it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经拥有所需的知识和工具，作为一个进一步的挑战，尝试创建其他类型的敌军坦克。你可以尝试改变大小和速度。它们也可以有不同的强度，或者你可以让摧毁敌军坦克时获得更多分数。也许，有一辆坦克实际上是在玩家射击时给玩家加分。尽情地玩这个游戏，享受其中的乐趣。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about NavMeshes and pathfinding. We also did a little
    work with AI. This was perhaps one of the simplest types of AI, but chase behaviors
    are highly important to all types of games. To utilize all of this, we created
    an enemy tank. It chased the player and shot at them to reduce their score. To
    give the edge back to the player, we gave health to the enemy tanks. The player
    could then shoot the enemy tanks as well as the targets for points. We also created
    some spawn points so that every time a tank was destroyed, a new one would be
    created. In terms of general game play, our Tank Battle game is pretty much complete.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 NavMeshes 和寻路。我们还进行了一些与人工智能相关的工作。这可能是最简单的人工智能类型之一，但追逐行为对所有类型的游戏都至关重要。为了利用这些功能，我们创建了一个敌方坦克。它追逐玩家并向他们开火以减少他们的得分。为了给玩家一些优势，我们给敌方坦克增加了生命值。玩家也可以射击敌方坦克以及目标来获得分数。我们还创建了一些生成点，这样每当一辆坦克被摧毁时，就会生成一辆新的。就整体游戏玩法而言，我们的坦克大战游戏基本上已经完成。
- en: In the next chapter, we will create a new game. In order to explore some of
    the special features of the mobile platform, we will create a Monkey Ball game.
    We will remove nearly all of the buttons from the screen in favor of new control
    methods. We will be turning the device's tilt sensors into our steering method.
    In addition, we will use the touchscreen to destroy enemies or collect bananas.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个新游戏。为了探索移动平台的一些特殊功能，我们将制作一个猴子球游戏。我们将几乎从屏幕上移除所有按钮，转而使用新的控制方法。我们将利用设备的倾斜传感器作为我们的转向方式。此外，我们还将使用触摸屏来摧毁敌人或收集香蕉。
