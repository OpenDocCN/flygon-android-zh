- en: Chapter 2. Fragments and UI Flexibility
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 片段与用户界面的灵活性
- en: This chapter builds on the concepts introduced in the previous chapter to provide
    solutions to addressing specific differences in device layouts. The chapter explains
    the use of adaptive Activity layout definitions to create apps that automatically
    rearrange their user interface in response to differences in device form factors.
    With adaptive Activity layout definitions, applications are able to support a
    wide variety of devices using just a few properly designed fragments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在上一章的基础上，提供了针对设备布局差异的具体解决方案。本章介绍了如何使用自适应Activity布局定义来创建应用，这些应用可以自动根据设备形态差异调整用户界面。通过自适应Activity布局定义，应用只需使用少数几个精心设计的片段，就能支持各种类型的设备。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Simplifying the challenge of supporting device differences
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化支持设备差异的挑战
- en: Dynamic resource selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态资源选择
- en: Coordinating fragment content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调片段内容
- en: The role of `FragmentManager`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FragmentManager`的角色'
- en: Supporting fragments across activities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持跨活动的片段
- en: By the end of this chapter, we will be able to implement a user interface that
    uses fragments to automatically adapt to differences in device layouts and coordinates
    user actions across the involved fragments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够实现一个用户界面，它使用片段来自动适应设备布局的差异，并协调涉及片段中的用户操作。
- en: Creating UI flexibility
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面的灵活性
- en: Utilizing fragments in our user interface design provides a good foundation
    for creating applications that more easily adapt to device differences, but we
    must go a little further to create truly flexible UIs. We must design our application
    such that the fragments that make up the UI are easily rearranged in response
    to the characteristics of the device on which the app is currently running.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面设计中使用片段为我们创建能够更容易适应设备差异的应用提供了一个良好的基础，但我们还必须更进一步，以创建真正灵活的用户界面。我们必须设计应用程序，使得构成用户界面的片段能够根据应用当前运行的设备的特性轻松重新排列。
- en: To achieve this, we must use some techniques to dynamically change the layout
    of individual fragments in response to the current device's characteristics. Once
    we employ such a technique, we must be sure that we implement our fragments in
    such a way that each fragment is able to function effectively independent of layout
    changes that might affect the behavior or even existence of other fragments within
    the activity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须使用一些技术来动态地根据当前设备的特性改变单个片段的布局。一旦我们采用了这种技术，我们必须确保我们实现的每个片段都能在布局变化中有效地独立运作，这些变化可能会影响活动中其他片段的行为甚至存在。
- en: Dynamic fragment layout selection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态片段布局选择
- en: As we mentioned in the previous section, creating a flexible UI requires that
    the layout and positioning of fragments within an activity must be able to change
    in response to differences in device characteristics. We can include code in our
    application to dynamically arrange fragments in response to the form factor of
    the device on which our app is running, but in most cases, doing so is not only
    unnecessary but also undesirable. The deeper the dependencies between the user
    interface and application code, the more difficult maintaining and enhancing an
    application becomes. Although there will always be some degree of dependency between
    our user interface and application code, we want to minimize such dependencies
    and instead do as much of our user interface layout-related work within layout
    resources as possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节提到的，创建灵活的用户界面需要片段在活动中的布局和定位能够根据设备特性的差异进行改变。我们可以在应用中包含代码，以动态响应设备形态因素来排列片段，但在大多数情况下，这样做不仅不必要，而且也不可取。用户界面与代码之间的依赖关系越深，维护和增强应用程序就越困难。尽管用户界面和应用程序代码之间总会有一定程度的依赖，但我们希望尽可能减少这种依赖，并在布局资源中尽可能完成与用户界面布局相关的所有工作。
- en: The easiest way to build flexibility into our application user interface is
    to take advantage of the Android resource system's built-in device adaptability.
    Android allows us to design different layout-related resources for our application
    with each optimized for and associated with a specific set of device characteristics.
    At runtime, the Android resource system takes care of automatically selecting
    and loading the appropriate resources for the current device. Although this feature
    can be used to dynamically modify the layout of any activity, we'll see that it
    is particularly effective when used in conjunction with fragments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的应用程序用户界面具有灵活性的最简单方法是利用 Android 资源系统内置的设备适应性。Android 允许我们为应用程序设计不同的布局相关资源，每种资源都针对一组特定的设备特性进行了优化和关联。在运行时，Android
    资源系统会自动选择并加载适合当前设备的适当资源。尽管此功能可用于动态修改任何活动的布局，但我们会发现当与片段结合使用时，它特别有效。
- en: 'To see Android resource selection in action, let''s continue with our application
    from the previous chapter. As you''ll recall, the layout for our activity is in
    the `activity_main.xml` resource file and looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 Android 资源选择的效果，让我们继续上一章的应用程序。你会记得，我们活动的布局在`activity_main.xml`资源文件中，看起来像这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This layout stacks our fragments, `BookListFragment` and `BookDescFragment`,
    one on top of the other. Although that layout renders well on a smartphone held
    vertically in the portrait orientation, rotating the phone so that it''s held
    horizontally in the landscape orientation creates a much less attractive appearance
    as seen here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局将我们的片段`BookListFragment`和`BookDescFragment`堆叠在一起。尽管这种布局在竖直握持智能手机的肖像方向上渲染良好，但是将手机旋转到水平握持的横屏方向时，会出现像这里一样不太吸引人的外观：
- en: '![Dynamic fragment layout selection](img/3095_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![动态片段布局选择](img/3095_02_01.jpg)'
- en: The current layout is clearly not making the best use of the available screen
    space in this orientation. When the phone is orientated in landscape, the application
    would look much better if we position the two fragments side-by-side.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当前布局显然没有充分利用这种方向下的可用屏幕空间。当手机以横屏方向定位时，如果我们将两个片段并排放置，应用程序看起来会更好。
- en: Adding an alternate layout resource
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个备用布局资源
- en: We can add support for an alternative layout to our application by creating
    a new resource file with the fragments appropriately arranged. To create the resource
    file, we first add another folder under the `res` folder of the project tree called
    `layout-land`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个适当排列片段的新资源文件，为我们的应用程序添加对备用布局的支持。要创建资源文件，我们首先在项目树的`res`文件夹下添加另一个名为`layout-land`的文件夹。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resource folder name creates the association between the resource file and
    the device characteristics, not any special behavior on the part of Android Studio.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件夹名称建立了资源文件与设备特性之间的关联，而不是 Android Studio 的任何特殊行为。
- en: 'To create the new folder in Android Studio, perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Android Studio 中创建新文件夹，请执行以下步骤：
- en: Expand the **src** folder in the project explorer window.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目浏览器窗口中展开**src**文件夹。
- en: Expand the **main** folder under **src**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开位于**src**下的**main**文件夹。
- en: Right-click on the **res** folder under **main**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**main**下的**res**文件夹上右键点击。
- en: Select **New**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建**。
- en: Select **Android resource directory** to open the **New Resource Directory**
    dialog.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Android 资源目录**以打开**新资源目录**对话框。
- en: Select **layout** as **Resource type:**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**布局**作为**资源类型：**。
- en: Highlight **Orientation** under **Available qualifiers:** and click on the **>>**
    button to move it to **Chosen qualifiers:**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮**可用限定符：**下的**方向**，并点击**>>**按钮将其移到**选定限定符：**。
- en: Select **Landscape** under **Screen orientation:**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**屏幕方向：**下选择**横屏**。
- en: 'The **New Resource Directory** dialog will appear similar to the following
    screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将会出现类似于以下截图的**新资源目录**对话框：
- en: '![Adding an alternate layout resource](img/3095_02_02_NEW.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个备用布局资源](img/3095_02_02_NEW.jpg)'
- en: 'Now copy the `activity_main.xml` resource file from the **layout** resource
    folder to the **layout-land** resource folder. We now have two copies of the `activity_main.xml`
    resource file as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**layout**资源文件夹中的`activity_main.xml`资源文件复制到**layout-land**资源文件夹中。我们在以下截图中可以看到现在有两个`activity_main.xml`资源文件：
- en: '![Adding an alternate layout resource](img/3095_02_03_NEW.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个备用布局资源](img/3095_02_03_NEW.jpg)'
- en: We can now modify the `activity_main.xml` resource file in the `layout-land`
    folder to arrange the fragments to render properly when the phone is in landscape
    orientation. First, we switch the `LinearLayout` element from a vertical to a
    horizontal orientation. We then change the `layout_width` values for each fragment
    to `0dp` and the `layout_height` values to `match_parent`. We can leave each of
    the fragment's `layout_weight` value as `1` so that `LinearLayout` spaces them
    equally left to right.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改位于`layout-land`文件夹中的`activity_main.xml`资源文件，以便当手机处于横屏方向时，正确地排列碎片。首先，我们将`LinearLayout`元素的垂直方向改为水平方向。然后，将每个碎片的`layout_width`改为`0dp`，`layout_height`改为`match_parent`。我们可以将每个碎片的`layout_weight`值设置为`1`，这样`LinearLayout`就会将它们从左到右均匀分布。
- en: 'The updated resource file looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的资源文件如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Having done nothing more than adding this simple resource file to our project,
    the application now displays the list of titles and book description next to one
    another when run on a device held in a landscape orientation as shown in the following
    screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是将这个简单的资源文件添加到我们的项目中，应用程序现在就可以在横屏模式下运行时，在设备上并排显示标题列表和书籍描述，如下面的截图所示：
- en: '![Adding an alternate layout resource](img/3095_02_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个替代布局资源](img/3095_02_04.jpg)'
- en: During runtime, when the `MainActivity` class loads the `R.layout.activity_main`
    resource, the Android resource system returns the appropriate version of the `activity_main.xml`
    resource file for that orientation. When the user rotates the device to a different
    orientation, Android automatically recreates the activity and loads the appropriate
    resource for the new orientation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，当`MainActivity`类加载`R.layout.activity_main`资源时，Android资源系统会返回适合该方向版本的`activity_main.xml`资源文件。当用户将设备旋转到不同的方向时，Android会自动重新创建活动，并加载适合新方向的相关资源。
- en: The Android environment detects a wide variety of device form factor characteristics.
    By taking advantage of fragments, we are able to create an application that easily
    adapts to device differences by simply providing different layout resource files
    that shift around the location of our fragments as if they are puzzle pieces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Android环境检测到各种设备形态因数的特性。通过利用碎片，我们可以创建一个应用程序，只需提供不同的布局资源文件，就可以轻松地适应设备差异，这些文件可以像拼图一样调整我们的碎片位置。
- en: Without fragments, we would've had to provide the entire layout for the activity,
    radio buttons, text views, everything, in both of the layout files. We would then
    find ourselves having to maintain two complex, almost identical files. By using
    fragments, the individual pieces are self-contained and non-duplicated. Fragments
    modify the layout in an easy manner and simplify our application maintenance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有碎片（Fragments），我们就需要为活动（Activity）提供完整的布局，包括单选按钮、文本视图等，在两个布局文件中都要包含。这样我们就会发现自己需要维护两个复杂且几乎相同的文件。通过使用碎片，各个独立的部分是自包含且不重复的。碎片以一种简单的方式修改布局，并简化我们的应用程序维护工作。
- en: Managing fragment layout by screen size
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据屏幕大小管理碎片布局
- en: The same technique we use to adapt our user interface to device orientation
    differences can be taken much further to work with differences in screen size.
    The Android resource system has device screen size awareness and therefore supports
    creating corresponding resource folders. The resource selection can be based on
    general screen size groups or specific screen size constraints.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来适应设备方向差异的相同技术可以进一步应用，以处理屏幕尺寸的差异。Android资源系统具有对设备屏幕尺寸的认知，因此支持创建相应的资源文件夹。资源选择可以基于一般的屏幕尺寸组或特定的屏幕尺寸限制。
- en: Differences in device screen size are one of the most common reasons for using
    layout resources to manage fragments. With this being the case, understanding
    how to use layout resources to deal with differences in screen size is essential
    to working effectively with fragments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设备屏幕尺寸的差异是使用布局资源管理碎片的最常见原因之一。在这种情况下，了解如何使用布局资源处理屏幕尺寸的差异对于有效地使用碎片至关重要。
- en: Resource screen size groups
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源屏幕尺寸组
- en: The configuration information of each Android device includes the screen size
    group to which the device belongs. The four screen size groups are small, normal,
    large, or xlarge.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备的配置信息包括该设备所属的屏幕尺寸组。四个屏幕尺寸组分别是小型、正常、大型和特大。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For specific information on the size of screens in each group, see *Range of
    screens supported* in the Android documentation available at [http://developer.android.com/guide/practices/screens_support.html#range](http://developer.android.com/guide/practices/screens_support.html#range).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每组屏幕尺寸的具体信息，请参见[Android文档](http://developer.android.com/guide/practices/screens_support.html#range)中的*支持屏幕范围*部分。
- en: Just as we created a specific layout resource file for landscape orientation,
    we can create a layout resource file targeting a particular screen size group.
    We associate the resource file with the desired screen size group by placing the
    file in the appropriately named resource folder. For example, we place a layout
    resource file designed for devices with a screen size group of large in the `layout-large`
    resource folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为横屏方向创建了一个特定的布局资源文件，我们也可以创建一个针对特定屏幕尺寸组的布局资源文件。通过将资源文件放置在适当命名的资源文件夹中，我们将资源文件与所需的屏幕尺寸组关联起来。例如，我们将为大型屏幕尺寸组设计的布局资源文件放置在`layout-large`资源文件夹中。
- en: 'Screen size groups date back to the early days of Android when there was little
    practical experience in dealing with the wide variety of device form factors that
    now exist. As time has gone on and the number of Android device form factors has
    grown, file size groups have turned out to be a less than ideal solution. Problems
    with screen size groups stem from two main issues:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕尺寸组的划分可追溯到Android早期时代，当时在处理现在存在的各种设备形态因素方面实际经验很少。随着时间的推移，Android设备形态因素的数量增长，文件尺寸组被证明是一个不太理想的解决方案。屏幕尺寸组的问题源于两个主要问题：
- en: The size range of the groups is not consistently applied, which results in the
    size range within the groups overlapping one another. One device with a 7-inch
    screen might be classified as large while another device with the same size screen
    might be classified as xlarge.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组的大小范围并不一致应用，导致组内的大小范围相互重叠。一个7英寸屏幕的设备可能被归类为大型，而另一个同样尺寸屏幕的设备可能被归类为xlarge。
- en: Groups are sometimes too broad. For example, the large group includes devices
    with 5-inch screens and devices with 7-inch screens. These screen sizes tend to
    have very different layout requirements. A device with a 5-inch screen tends to
    work best with handset-style layouts like that for a smartphone, whereas a device
    with a 7-inch screen tends to work best with a tablet-style layout.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时尺寸组过于宽泛。例如，大型组包括了5英寸屏幕的设备和7英寸屏幕的设备。这些屏幕尺寸往往有非常不同的布局要求。5英寸屏幕的设备更适合使用类似智能手机的手持式布局，而7英寸屏幕的设备更适合使用平板式布局。
- en: Size groups are still in use because they are the best option available for
    dealing with screen size differences on pre-API Level 13 devices. Fortunately,
    less than half of the Android devices in use today are pre-API Level 13, and the
    ratio is shrinking rapidly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸组仍然在使用中，因为它们是处理API级别13之前设备屏幕尺寸差异的最佳选择。幸运的是，目前使用的Android设备中不到一半是API级别13之前的，这一比例正在迅速缩小。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For information on the distribution of devices in use by API Level or by screen
    size group, see the Android developer, *Dashboards*, available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解按API级别或屏幕尺寸组划分的设备分布情况，请参见[Android开发者](http://developer.android.com/about/dashboards)提供的*Dashboards*。
- en: Resource screen size qualifiers
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源屏幕尺寸限定符
- en: At API Level 13 (Android 3.2), Android introduced a substantial improvement
    over screen size groups known as resource screen size qualifiers. Resource screen
    size qualifiers allow us to associate resources with specific screen size requirements.
    With screen size qualifiers, we have a very detailed level of control over which
    layout resources are associated with each device form factor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在API级别13（Android 3.2）中，Android引入了比屏幕尺寸组更实质性的改进，即资源屏幕尺寸限定符。资源屏幕尺寸限定符允许我们将资源与特定的屏幕尺寸要求相关联。使用屏幕尺寸限定符，我们可以非常详细地控制与每种设备形态因素关联的布局资源。
- en: To avoid the complications inherent in the wide variety of screen pixel densities
    and physical screen sizes available, Android uses a canonicalized unit of measure
    called the **density independent pixel** (**dp**) when managing screen sizes.
    If you've been working with Android for any length of time, you are probably already
    familiar with density independent pixels as they are the preferred unit of measure
    when positioning and sizing views within an Android user interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免处理各种屏幕像素密度和物理屏幕尺寸带来的复杂性，Android 在管理屏幕大小时使用了一个标准化的度量单位，称为**密度独立像素**（**dp**）。如果你已经在
    Android 领域工作了一段时间，你可能已经很熟悉密度独立像素，因为它们是在 Android 用户界面内定位和调整视图大小时的首选度量单位。
- en: A dp always corresponds to the physical size of a pixel on a 160 dpi device
    and therefore provides a consistent unit of measure independent of the physical
    pixel size of the device. For example, one 7-inch display device may have a physical
    pixel count of 1280x720 while another 7-inch display device has a physical pixel
    count of 1920x1080, but both devices have a dp count of approximately 1000x600\.
    The Android platform takes care of the details of mapping between density independent
    pixels and the physical pixels of a device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`dp` 总是等同于 160 dpi 设备上像素的物理尺寸，因此提供了一个与设备物理像素大小无关的恒定度量单位。例如，一个 7 英寸显示设备可能有 1280x720
    的物理像素计数，而另一个 7 英寸显示设备有 1920x1080 的物理像素计数，但这两个设备的 dp 计数大约都是 1000x600。Android 平台负责处理密度独立像素与设备物理像素之间的映射细节。'
- en: 'Android provides three types of screen size qualifiers: smallest width, available
    screen width, and available screen height:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了三种屏幕尺寸限定符：最小宽度、可用屏幕宽度和可用屏幕高度：
- en: '**Smallest width screen size qualifier:** This is referred to as smallest screen
    width in the Android Studio New Directory Resource dialog. It corresponds to the
    number of device independent pixels at the screen''s narrowest point independent
    of the device orientation. Changing the device orientation does not change the
    device''s smallest width. We specify the name of a resource folder based on the
    device''s smallest width by adding `sw`, followed by the desired screen size in
    device independent pixels, followed by `dp`. For example, a layout resource folder
    containing layout resource files for devices with a smallest width of at least
    600 dp is named `layout-sw600dp`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小宽度屏幕尺寸限定符：**这在 Android Studio 的新目录资源对话框中被称为最小屏幕宽度。它对应于屏幕最窄点的设备独立像素数，与设备方向无关。改变设备方向不会改变设备的最小宽度。我们通过添加
    `sw`，然后是所需的屏幕尺寸（以设备独立像素为单位），再加上 `dp` 来指定基于设备最小宽度的资源文件夹名称。例如，至少有 600 dp 最小宽度的设备所包含的布局资源文件夹名为
    `layout-sw600dp`。'
- en: '**Available width screen size qualifier:** This is referred to as screen width
    in the Android Studio New Directory Resource dialog. It corresponds to the number
    of device independent pixels measured left to right at the device''s current orientation.
    Changing the device orientation changes the available width. We specify the name
    of a resource folder based on available width by adding `w`, followed by the width
    in density independent pixels, followed by `dp`. A layout resource folder containing
    resource files for a device with an available width of at least 600 dp is named
    `layout-w600dp`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用宽度屏幕尺寸限定符：**这在 Android Studio 的新目录资源对话框中被称为屏幕宽度。它对应于设备当前方向上从左到右测量的设备独立像素数。改变设备方向会改变可用宽度。我们通过添加
    `w`，然后是密度独立像素的宽度，再加上 `dp` 来指定基于可用宽度的资源文件夹名称。一个包含至少 600 dp 可用宽度的设备所使用的布局资源文件夹名为
    `layout-w600dp`。'
- en: '**Available height screen size qualifier:** This is referred to as screen height
    in the Android Studio New Directory Resource dialog. It corresponds to the number
    of device independent pixels measured top to bottom, but otherwise behaves identically
    to the available width screen size qualifier, and follows the same naming pattern
    except that `h` is used instead of `w`. A layout resource folder containing resource
    files for a device with an available height of at least 600 dp is named `layout-h600dp`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用高度屏幕尺寸限定符：**这在 Android Studio 的新目录资源对话框中被称为屏幕高度。它对应于从上到下测量的设备独立像素数，但除此之外，其行为与可用宽度屏幕尺寸限定符完全相同，并遵循相同的命名模式，只是使用
    `h` 而不是 `w`。一个包含至少 600 dp 可用高度的设备所使用的布局资源文件夹名为 `layout-h600dp`。'
- en: Eliminating redundancy
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消除冗余
- en: As the number of form factors our application targets grow, managing the resource
    files within the different layout resource folders can become somewhat complicated
    due to the fact that we'll likely want to use the same layout resource file for
    different qualifiers. To demonstrate this problem, let's update our application
    to use the version of the `activity_main.xml` resource file we currently use for
    landscape-oriented devices on other devices. We'll use that same resource file
    on devices in the large screen size group and on devices with a current width
    of 600 dp or greater.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序目标形态因素数量的增长，由于我们可能希望为不同的限定符使用相同的布局资源文件，不同布局资源文件夹内的资源文件管理可能会变得有些复杂。为了演示这个问题，让我们更新我们的应用程序，在其他设备上使用我们目前在横屏设备上使用的`activity_main.xml`资源文件版本。我们将对大型屏幕尺寸组和当前宽度为600
    dp或更大的设备使用相同的资源文件。
- en: 'We first create two additional folders under our `res` folder: `layout-large`
    and `layout-w600dp`. We then copy the `activity_main.xml` file from the `layout-land`
    folder to the two folders we just created. Doing this is easy enough but we now
    have a maintenance headache. Every time we make a change to that layout, we have
    to be sure that we make it in all three folders.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`res`文件夹下创建两个额外的文件夹：`layout-large`和`layout-w600dp`。然后，我们将`layout-land`文件夹中的`activity_main.xml`文件复制到我们刚才创建的两个文件夹中。这样做足够简单，但现在我们面临维护的麻烦。每次我们更改该布局时，都必须确保在所有三个文件夹中都进行更改。
- en: To avoid this resource file duplication, we can use layout aliasing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种资源文件的重复，我们可以使用布局别名。
- en: Layout aliasing
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布局别名
- en: Layout aliasing allows us to have just a single copy of each layout resource
    file. We can then provide the resource system with information as to which file
    to choose for each form factor.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 布局别名功能让我们只需保留每个布局资源文件的单一副本。然后我们可以向资源系统提供信息，告知每种形态因素应选择哪个文件。
- en: To get started, we'll rename the `activity_main.xml` resource file in the `layout-land`
    resource folder as `activity_main_wide.xml`. We then move the file to the `layout`
    resource folder and delete the `layout-land` folder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`layout-land`资源文件夹中的`activity_main.xml`资源文件重命名为`activity_main_wide.xml`。然后，我们将文件移动到`layout`资源文件夹，并删除`layout-land`文件夹。
- en: We now create a new resource folder called `values-land` under the `res` folder.
    To create the folder in Android Studio, follow the same steps as we used earlier
    to create the `layout-land` folder except set the **Resource type:** as **values**
    rather than **layout**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`res`文件夹下创建一个名为`values-land`的新资源文件夹。在Android Studio中创建此文件夹，步骤与之前创建`layout-land`文件夹相同，但需将**资源类型**设置为**values**，而不是**layout**。
- en: 'Within this folder, we create a new resource file, the name of which doesn''t
    matter, but the file containing values for aliasing is often named `refs.xml`
    because it contains a list of references to other resources, so that''s what we''ll
    use. To create the file using Android Studio, perform the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件夹内，我们创建一个新的资源文件，文件名无关紧要，但通常包含别名值的文件命名为`refs.xml`，因为它包含了对其他资源的引用列表，所以我们也将这样做。使用Android
    Studio创建文件，请执行以下步骤：
- en: Right-click on the **values-land** resource folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**values-land**资源文件夹。
- en: Select **New**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建**。
- en: Select the **values** resource file.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**values**资源文件。
- en: Specify `refs.xml` as the filename.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定`refs.xml`作为文件名。
- en: 'In the `refs.xml` file, be sure that there is already a root element named
    `resources`. Within that element, add an `item` element with a `type` attribute
    value of `layout`. This indicates that we''re providing an alias entry for a layout
    resource. We set the value of the `name` attribute to be the name of the default
    layout resource, which in our case is `activity_main`. We then give the `item`
    element a value of `@layout/activity_main_wide`. The complete `refs.xml` resource
    file now appears as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refs.xml`文件中，请确保已经有一个名为`resources`的根元素。在此元素内，添加一个`item`元素，其`type`属性值为`layout`。这表示我们正在为布局资源提供一个别名条目。我们将`name`属性的值设置为默认布局资源的名称，在我们的例子中是`activity_main`。然后，我们将`item`元素的值设置为`@layout/activity_main_wide`。现在完整的`refs.xml`资源文件如下所示：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this file in place, any call to load the layout resource `R.layout.activity_main`
    will instead load `R.layout.activity_main_wide` when the application is running
    on a device in landscape orientation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个文件存在时，任何调用加载布局资源`R.layout.activity_main`的地方，在应用程序在横屏方向运行时，将改为加载`R.layout.activity_main_wide`。
- en: 'To add support for devices in the large group and those with a current width
    of at least 600 dp, we simply create two more resource folders, `values-large`
    and `values-w600dp`, and copy the `refs.xml` file from the `values-land` folder
    to each. The `layout` and `values` resource folders now appear as shown in the
    following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在大屏幕组和当前宽度至少为600 dp的设备上添加支持，我们只需创建两个额外的资源文件夹，`values-large` 和 `values-w600dp`，并将
    `values-land` 文件夹中的 `refs.xml` 文件复制到这两个文件夹中。现在，`layout` 和 `values` 资源文件夹如下截图所示：
- en: '![Layout aliasing](img/3095_02_05_NEW.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![布局别名](img/3095_02_05_NEW.jpg)'
- en: We now have support for all the desired form factors with no unnecessary duplication
    of layout resource files. We do have duplication of the `refs.xml` file, but it's
    a much simpler file than the `layout` resource file and is less likely to change.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经支持所有期望的形态因子，且没有不必要的布局资源文件重复。我们确实重复了 `refs.xml` 文件，但它比 `layout` 资源文件简单得多，且更不可能发生变化。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See *Table 2* of the Android *Providing Resources* guide for the order of precedence
    Android follows when performing layout aliasing,available at [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 Android *提供资源* 指南中的 *表2*，了解 Android 在执行布局别名时的优先顺序，可在 [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)
    查阅。
- en: Design fragments for flexibility
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计灵活的片段
- en: With our user interface well-partitioned and adaptable, we need to be sure that
    each fragment functions effectively, as layout differences cause the behavior
    and possibly even the existence of other fragments within the activity to change.
    When an application user interface is divided into fragments, the fragments exist
    completely independent of one another rarely. Very often a user's interaction
    with one fragment has some effect on other fragments within the same activity.
    In the case of our application, this issue arises when a user selects a book within
    `BookListFragment`. In response to the user's selection, the application is responsible
    for displaying the corresponding description in `BookDescFragment`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的用户界面良好分割且具有适应性时，我们需要确保每个片段都能有效地工作，因为布局差异会导致活动内其他片段的行为甚至存在发生变化。当应用程序用户界面被划分为片段时，片段很少完全独立于彼此存在。通常一个用户与一个片段的交互会对同一活动内的其他片段产生影响。在我们的应用程序中，当用户在
    `BookListFragment` 中选择一本书时，就会出现这个问题。响应用户的选择，应用程序负责在 `BookDescFragment` 中显示相应的描述。
- en: Avoiding tight coupling
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免紧密耦合
- en: One possible solution to coordinating fragment content is to allow the fragments
    to directly communicate with one another. To coordinate content within our application,
    we could pass the `BookDescFragment` reference into `BookListFragment` when we
    first create the activity. In response to each user selection within `BookListFragment`,
    `BookListFragment` would then directly update `TextView` contained within `BookDescFragment`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 协调片段内容的一个可能解决方案是允许片段直接相互通信。为了在我们的应用程序内协调内容，我们可以在首次创建活动时将 `BookDescFragment`
    引用传递给 `BookListFragment`。在 `BookListFragment` 中对每个用户选择的响应中，`BookListFragment`
    将直接更新 `BookDescFragment` 中包含的 `TextView`。
- en: Although simple to implement, this solution is problematic because it tightly
    couples the two `Fragment` classes to each other. The `BookListFragment` fragment
    is only usable within activities that also contain the `BookDescFragment` fragment,
    and making changes to the layout of `BookDescFragment` may potentially break `BookListFragment`.
    We always want to keep in mind that a key goal of using fragments is to be well-partitioned
    and adaptable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个解决方案易于实施，但它有问题，因为它将两个 `Fragment` 类紧密耦合在一起。`BookListFragment` 片段只能在同时包含 `BookDescFragment`
    片段的活动中使用，而且对 `BookDescFragment` 布局进行更改可能会潜在地破坏 `BookListFragment`。我们始终要记住，使用片段的一个关键目标是要做到良好分割和适应性。
- en: Abstracting fragment relationships
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象片段关系
- en: Instead of creating direct relationships between the fragments, we can take
    advantage of the abstraction provided by interfaces. By defining a simple callback
    interface to represent the act of a user making a book selection, we can completely
    eliminate tight coupling between fragments. The `BookListFragment` class can be
    written to provide notification of a user selection through the interface. By
    implementing the interface on the activity, the activity can then handle coordinating
    the user selection within `BookListFragment` with updating the displayed description
    within `BookDeskFragment`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用接口提供的抽象，而不是直接创建片段之间的关系。通过定义一个简单的回调接口来表示用户选择书籍的行为，我们可以完全消除片段之间的紧密耦合。`BookListFragment`类可以编写为通过接口提供用户选择的通知。通过在活动中实现该接口，活动可以处理协调`BookListFragment`中的用户选择与更新`BookDeskFragment`中显示的描述。
- en: Defining the callback interface
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义回调接口
- en: The callback interface should include methods for any interaction with the fragment
    that may be meaningful to the activity containing the fragment. At the same time,
    the interface should not burden the activity with unnecessary details. The interface
    should be focused on application-level actions such as selecting a book rather
    than implementation-level actions such as tapping on a radio button. The implementation-level
    details should be isolated within the fragment. We should also be sure to design
    the interface without any preconceived ideas of what the activity will do with
    the notification.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回调接口应包括任何与包含片段的活动可能有意义的交互方法。同时，接口不应让活动负担不必要的细节。接口应专注于应用程序级别的动作，如选择一本书，而不是实现级别的动作，如点击一个单选按钮。实现级别的细节应该被隔离在片段内部。我们还应确保在设计接口时不要有任何预定的想法，即活动将如何处理通知。
- en: In the case of `BookListFragment`, the only action of interest to the activity
    is the user selecting a book. This tells us the interface needs just a single
    method; we'll call the interface method `onSelectedBookChanged`. We know in the
    case of this application, the goal is to display the selected book description,
    so one possibility is to have the `onSelectedBookChanged` method include a parameter
    for the book description. The problem with passing the book description is that
    doing so limits the use of `BookListFragment` to just this one use case, displaying
    the book description. Instead, by passing an identifier for the book, `BookListFragment`
    is available for any use case in which the user selects a book. For simplicity,
    in our example, we'll use an array index as the identifier; in a real scenario,
    the identifier would more likely be a key to locate the book information within
    a data store or service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BookListFragment`的案例中，活动唯一感兴趣的动作是用户选择一本书。这告诉我们接口只需要一个方法；我们将这个接口方法称为`onSelectedBookChanged`。我们知道在这个应用程序的案例中，目标是显示所选书籍的描述，因此一个可能性是让`onSelectedBookChanged`方法包含一个书籍描述的参数。传递书籍描述的问题是这样做将限制`BookListFragment`仅用于这一个用例，即显示书籍描述。相反，通过传递书籍的标识符，`BookListFragment`可以用于任何用户选择书籍的用例。为了简单起见，在我们的示例中，我们将使用数组索引作为标识符；在真实场景中，标识符更可能是一个用于在数据存储或服务中定位书籍信息的关键。
- en: 'We''ll call our new interface `OnSelectedBookChangeListener`. The interface
    looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新的接口称为`OnSelectedBookChangeListener`。接口如下所示：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Making the fragment self-contained
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使片段自包含
- en: 'The `BookListFragment` class needs to hide the details of user selections and
    instead translate each selection to a book identifier, which in our case is an
    array index. We first need to update the `BookListFragment` class to handle the
    radio button selections by implementing the `RadioGroup.OnCheckedChangeListener`
    interface as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookListFragment`类需要隐藏用户选择的细节，而是将每个选择转换为书籍标识符，在我们的案例中是一个数组索引。首先，我们需要更新`BookListFragment`类以处理单选按钮的选择，实现`RadioGroup.OnCheckedChangeListener`接口如下：'
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the `BookListFragment` class'' `onCreateView` method, we set the radio
    group''s click listener as the `BookListFragment` class as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BookListFragment`类的`onCreateView`方法中，我们将单选组的点击监听器设置为`BookListFragment`类，如下所示：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a number of ways to determine the book index corresponding to the
    selected radio button such as setting the tag value on each radio button or using
    a lookup table. For simplicity, we''ll create a simple method containing a switch
    statement like the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确定与选中单选按钮对应的书籍索引有多种方法，如在每个单选按钮上设置标签值或使用查找表。为了简单起见，我们将创建一个包含 switch 语句的简单方法，如下代码所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fragment notification
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段通知
- en: 'A fragment can always access the activity on which it is placed using the `getActivity`
    method. Within the `BookListFragment` class'' `onClick` method, we can use the
    `getActivity` method to access the activity, cast it to the `OnSelectedBookChangeListener`
    interface, and then call the `onSelectedBookChanged` method and pass it the book
    index for the selected radio button as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 片段总是可以通过 `getActivity` 方法访问放置它的活动。在 `BookListFragment` 类的 `onClick` 方法中，我们可以使用
    `getActivity` 方法访问活动，将其转换为 `OnSelectedBookChangeListener` 接口，然后调用 `onSelectedBookChanged`
    方法，并传递选中单选按钮的书籍索引，如下代码所示：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `BookListFragment` class now completely handles notifying the parent activity
    of each change in the user book selection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `BookListFragment` 类完全负责通知父活动关于用户书籍选择的每次更改。
- en: Encapsulating fragment operations
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装片段操作
- en: 'Within the `BookDescFragment` class, we want to encapsulate any details about
    how the user interface is updated. We''ll do this by providing a simple method
    that accepts the book index and handles the details of locating and displaying
    the book description. Before we can implement that method, we first need to update
    the `BookDescFragment` class'' `onCreateView` method to retrieve the list of book
    descriptions, retrieve a reference to `TextView` identified by `R.id.bookDescription`,
    and assign both to class-level fields as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BookDescFragment` 类中，我们希望封装有关如何更新用户界面的任何细节。我们将通过提供一个接受书籍索引并处理查找和显示书籍描述的简单方法来实现这一点。在实现该方法之前，我们首先需要更新
    `BookDescFragment` 类的 `onCreateView` 方法，以获取书籍描述列表，获取到 `TextView` 的引用，该 `TextView`
    由 `R.id.bookDescription` 标识，并将两者分配给类级字段，如下所示：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now add a `setBook` method that accepts the book index, accesses the
    appropriate book description, and updates `mBookDescriptionTextView`. The `setBook`
    method appears as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个接受书籍索引的 `setBook` 方法，访问适当的书籍描述，并更新 `mBookDescriptionTextView`。`setBook`
    方法如下所示：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Loosely connecting the pieces
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散地连接各个部分
- en: 'Good use of interfaces and encapsulation greatly simplify using any component,
    and fragments are no different. With the work we''ve done on the `BookListFragment`
    and `BookDescFragment` classes, our activity can now coordinate user interaction
    in `BookListFragment` by updating `BookDescFragment` in three simple steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 合理使用接口和封装可以大大简化任何组件的使用，片段也不例外。通过对 `BookListFragment` 和 `BookDescFragment` 类所做的努力，我们的活动现在可以通过以下三个简单步骤在
    `BookListFragment` 中协调用户交互，通过更新 `BookDescFragment`：
- en: Implement the `OnSelectedBookChangeListener` interface.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `OnSelectedBookChangeListener` 接口。
- en: Get a reference to the `BookDescFragment` class.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取对 `BookDescFragment` 类的引用。
- en: Call the `BookDescFragment` class' `setBook` method.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `BookDescFragment` 类的 `setBook` 方法。
- en: Have a look at step 2 first. Unlike when working with views, an activity cannot
    directly reference the fragments contained within it. Instead, fragment handling
    is delegated to the `FragmentManager` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看第二步。与处理视图不同，活动不能直接引用其包含的片段。相反，片段处理被委托给 `FragmentManager` 类。
- en: Each activity has a unique instance of the `FragmentManager` class. The `FragmentManager`
    class handles access to and management of all fragments within that activity.
    An activity accesses its `FragmentManager` instance with the `getFragmentManager`
    method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动都有 `FragmentManager` 类的唯一实例。`FragmentManager` 类负责访问和管理该活动中的所有片段。活动通过 `getFragmentManager`
    方法访问其 `FragmentManager` 实例。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When working with the Android Support Library, use the `FragmentActivity` class'
    `getSupportFragmentManager` method in place of the standard `Activity` class'
    `getFragmentManager` method to access the current `FragmentManager` instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Android Support Library 时，应使用 `FragmentActivity` 类的 `getSupportFragmentManager`
    方法，代替标准 `Activity` 类的 `getFragmentManager` 方法来访问当前的 `FragmentManager` 实例。
- en: With `FragmentManager`, an activity can access the contained fragments by calling
    the `FragmentManager.findFragmentById` method and passing the desired fragment's
    id value from the layout resource.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FragmentManager`，活动可以通过调用 `FragmentManager.findFragmentById` 方法并传递布局资源中所需片段的
    id 值来访问包含的片段。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`FragmentManager` is an important class with a number of powerful capabilities.
    We''ll talk much more about `FragmentManager` in [Chapter 4](ch04.html "Chapter 4. Working
    with Fragment Transactions"), *Working with Fragment Transactions*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentManager`是一个重要的类，具有许多强大的功能。我们将在[第4章](ch04.html "第4章. 使用片段事务")《使用片段事务》中更详细地讨论`FragmentManager`。'
- en: By using `FragmentManager` to access `BookDescFragment`, we can now implement
    the `BookListFragment.OnSelectedBookChangeListener` interface on our activity
    to update the displayed description for each user selection in `BookListFragment`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`FragmentManager`访问`BookDescFragment`，我们可以在活动中实现`BookListFragment.OnSelectedBookChangeListener`接口，以更新`BookListFragment`中每个用户选择的显示描述。
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fragments protect against the unexpected
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段保护免受预期之外的影响
- en: The true test of user interface flexibility is in how well the user interface
    design and implementation hold up when encountering an unexpected change request.
    A well-designed fragment-based user interface allows us to create incredible dynamic
    user interfaces that can evolve and change with minimal impact on the code. As
    an example, let's make what could potentially be a major design change on our
    application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面灵活性的真正考验是在遇到意外的变更请求时，设计和实现能否经受住考验。一个设计良好的基于片段的用户界面可以让我们创建出能够以最小的影响力和代码变化而进化和改变的令人难以置信的动态用户界面。举个例子，让我们对应用程序进行可能是一个重大设计更改。
- en: Currently, the application always shows the book list and description on the
    same activity. The only difference is whether the fragments are positioned vertically
    or horizontally relative to one another. Imagine we receive feedback from our
    users that they don't like the way the app appears when viewed on a portrait-oriented
    handset. When viewed on a portrait-oriented handset, they would like the list
    and description to appear on separate activities. In all other cases, they want
    the app to continue to show the list and description side-by-side.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该应用总是在同一个活动中显示书籍列表和描述。唯一的区别是片段是相对于彼此垂直还是水平放置。设想我们收到了用户的反馈，他们不喜欢在竖屏手机上查看应用时的显示方式。在竖屏手机上查看时，他们希望列表和描述出现在不同的活动中。在其他所有情况下，他们希望应用继续同时并排显示列表和描述。
- en: Evolving layout resource files
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演进布局资源文件
- en: 'We first create a duplicate copy of the `activity_main.xml` resource file in
    the `layout` resource folder named `activity_book_desc.xml`. To do this in Android
    Studio, perform the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`layout`资源文件夹中创建`activity_main.xml`资源文件的副本，并将其命名为`activity_book_desc.xml`。在Android
    Studio中执行以下步骤来完成此操作：
- en: Right-click on the `activity_main.xml` file in the project explorer window and
    select **Copy**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口中右键点击`activity_main.xml`文件并选择**复制**。
- en: Right-click on the `layout` folder and select **Paste**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`layout`文件夹并选择**复制**。
- en: Change the filename to `activity_book_desc.xml`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名更改为`activity_book_desc.xml`。
- en: 'Remove the fragment element for `BookListFragment` from the `activity_book_desc.xml`
    file so it now shows only `BookDescFragment` as in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从`activity_book_desc.xml`文件中移除`BookListFragment`的片段元素，使其现在只显示`BookDescFragment`，如下代码所示：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `activity_main.xml` resource file, remove `BookDescFragment` so that
    it now appears as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`资源文件中，移除`BookDescFragment`，现在它看起来如下所示：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have layout resources for each of the activities. Remember that these
    changes will not affect the appearance of the app in scenarios that use the `activity_main_wide.xml`
    resource file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为每个活动都有了布局资源。请记住，这些更改不会影响使用`activity_main_wide.xml`资源文件的场景下的应用外观。
- en: Creating the book description activity
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建书籍描述活动
- en: 'To display the book description, we add a simple activity named `BookDescActivity`
    that uses the `activity_book_desc.xml` layout resource. The activity relies on
    an "Intent extra" to pass the book index. Since `BookDescFragment` contains all
    the logic necessary to display a book description, we can simply get a reference
    to `BookDescFragment` and set the book index just as we did in the `MainActivity`
    class as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示书籍描述，我们添加了一个名为`BookDescActivity`的简单活动，它使用`activity_book_desc.xml`布局资源。该活动依赖于“Intent
    extra”传递书籍索引。由于`BookDescFragment`包含了显示书籍描述所需的所有逻辑，我们可以简单地获取对`BookDescFragment`的引用，并像在`MainActivity`类中一样设置书籍索引，如下所示：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Making the MainActivity class adaptive
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让`MainActivity`类具有适应性
- en: The `MainActivity` class has some extra work to do now because the specific
    fragments contained within it will vary. When running on a device with a screen
    that is at least 600 dp wide or when running on a device in the large screen group,
    the `MainActivity` class always contains an instance of `BookDescFragment`. On
    the other hand, when running on other devices, the presence of `BookDescFragment`
    will depend upon the device's current orientation. We could add code to the `MainActivity`
    class to test for all of these various scenarios or we could take a simpler approach,
    that is, check whether the activity contains an instance of the `BookDescFragment`
    class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类现在需要做一些额外的工作，因为其中包含的特定片段会有所变化。在至少600 dp宽的屏幕设备上运行或在大型屏幕设备组中运行时，`MainActivity`类总是包含`BookDescFragment`的实例。另一方面，在其他设备上运行时，`BookDescFragment`的存在将取决于设备的当前方向。我们可以在`MainActivity`类中添加代码以测试所有这些不同的场景，或者我们可以采取更简单的方法，即检查活动是否包含`BookDescFragment`类的实例。'
- en: 'Using this approach, we have the `MainActivity` class'' `onSelectedBookChanged`
    method to check the validity of `BookDescFragment` returned by `FragmentManager`.
    If `FragmentManager` returns a valid reference, the method can call `setBook`
    on `BookDescFragment` just as it has been. If the returned reference is not valid,
    the `onSelectedBookChanged` method calls `startActivity` with an `Intent` instance
    containing the information to display `BookDescActivity` that includes `bookIndex`
    as an extra as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们让`MainActivity`类的`onSelectedBookChanged`方法来检查`FragmentManager`返回的`BookDescFragment`的有效性。如果`FragmentManager`返回有效引用，方法可以像之前一样在`BookDescFragment`上调用`setBook`。如果返回的引用无效，`onSelectedBookChanged`方法会调用带有`Intent`实例的`startActivity`，该实例包含显示`BookDescActivity`所需的信息，其中包括作为额外参数的`bookIndex`，如下代码所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice the `if` statement that checks the validity of `bookDescFragment`. In
    most cases, a simple check for whether the reference is null is all we need. The
    one exception is the case of when the app is run on a handset device on which
    the user has viewed the app in landscape orientation and then rotated the device
    to portrait. In this situation, the `BookDescFragment` instance is not visible
    but the activity's `FragmentManager` instance may be caching a reference to an
    invisible instance remaining from the landscape layout. For this reason, we check
    both for a null reference and for visibility. We'll discuss the details of fragment
    lifecycle, creation, and caching over the next two chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`if`语句检查`bookDescFragment`的有效性。在大多数情况下，仅需要简单检查引用是否为空。唯一的例外是在手持设备上，用户在横屏模式下查看应用程序后，将设备旋转为竖屏。在这种情况下，`BookDescFragment`实例不可见，但活动的`FragmentManager`实例可能会缓存来自横屏布局的不可见实例的引用。因此，我们同时检查引用是否为空和是否可见。我们将在接下来的两章中讨论片段的生命周期、创建和缓存的细节。
- en: 'We now have adaptability built into our app. The scenarios that use the `activity_main_wide.xml`
    resource file look as they always did. On portrait-oriented handset devices, our
    app provides the user interface with two separate activities: one for the book
    list and one for the book description. The application now appears on portrait-oriented
    handset devices as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已经内置了适应性。使用`activity_main_wide.xml`资源文件的场景看起来一如既往。在竖屏手持设备上，我们的应用程序为用户提供两个独立的界面：一个用于书籍列表，另一个用于书籍描述。应用程序现在在竖屏手持设备上的显示如下所示：
- en: '![Making the MainActivity class adaptive](img/3095_02_06_NEW.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使MainActivity类具有适应性](img/3095_02_06_NEW.jpg)'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Fragments provide our applications with a level of user interface flexibility
    that would be difficult to achieve otherwise. By properly designing our application
    to use fragments and associating the fragment resources with the appropriate device
    characteristics, we're able to build apps that contain a rich user interface that
    automatically adapts to the wide variety of Android device form factors that exist.
    We get all of these capabilities while writing only minimal code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 片段为我们应用程序提供了难以通过其他方式实现的用户界面灵活性。通过适当设计我们的应用程序以使用片段，并将片段资源与适当的设备特性相关联，我们能够构建出能够自动适应各种Android设备形态的应用程序，同时只需编写最少的代码量。
- en: In the next chapter, we dig into the lifecycle of fragments and explore how
    we can leverage the fragment lifecycle to create more responsive user interfaces
    and leverage specialized `Fragment` classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究片段的生命周期，并探讨如何利用片段生命周期来创建更具响应性的用户界面，以及利用专门的`Fragment`类。
