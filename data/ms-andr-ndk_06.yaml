- en: Chapter 6. OpenGL ES 3.1 and Cross-platform Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. OpenGL ES 3.1与跨平台渲染
- en: In this chapter, we will learn how to implement an abstraction layer on top
    of OpenGL 4 and OpenGL ES 3 in order to make our graphics applications runnable
    on Android and desktop machines. Let's start with some basic vector and linear
    algebra classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实现在OpenGL 4和OpenGL ES 3之上的抽象层，以便让我们的图形应用程序能在Android和桌面计算机上运行。首先，我们从一些基本的向量与线性代数类开始。
- en: Linear algebra and transformations
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性代数与变换
- en: 'In the `Core/VecMath.h` file, there is a bunch of vector and matrix specific
    classes and helpers. The main classes we use are `LVector2`, `LVector3`, `LVector4`,
    `LMatrix3`, `LMatrix4`, and `LQuaternion` for which basic algebraic operations
    are defined. There are shortcuts for them to makewriting of any math-heavy codr:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Core/VecMath.h`文件中，有一系列针对向量和矩阵的特定类和辅助工具。我们主要使用的类是`LVector2`、`LVector3`、`LVector4`、`LMatrix3`、`LMatrix4`和`LQuaternion`，这些类定义了基本的代数运算。它们有一些快捷方式，以便编写任何数学密集型代码：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tiny math library is basically a tight squeeze of some algebra code from
    Linderdaum Engine ([http://www.linderdaum.com](http://www.linderdaum.com)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型数学库基本上是从Linderdaum Engine ([http://www.linderdaum.com](http://www.linderdaum.com))压缩的一些代数代码。
- en: Besides this, there is a set of useful functions in the namespace `Math` dealing
    with different projection transformations calculation. They will be heavily used
    in the subsequent chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Math`命名空间中有一组有用的函数，用于处理不同的投影变换计算。在后续章节中，它们将被大量使用。
- en: Graphics initialization using SDL2
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SDL2进行图形初始化
- en: 'In our previous book, *Android NDK Game Development Cookbook*, *Packt Publishing*,
    we learned in great detail how to initialize OpenGL ES 2 on Android and OpenGL
    3 Core Profile on desktop using our own handcrafted code. Now, we will do it using
    the SDL2 library, which is available at [https://www.libsdl.org](https://www.libsdl.org).
    Let''s take a look at the `1_GLES3` example. The Java code for this example, besides
    SDL2 internals of course, is short and simple:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的书籍《*Android NDK Game Development Cookbook*, *Packt Publishing*》中，我们详细学习了如何初始化Android上的OpenGL
    ES 2和桌面上的OpenGL 3核心配置。现在，我们将使用SDL2库来完成这项工作，该库可在[https://www.libsdl.org](https://www.libsdl.org)获取。让我们看看`1_GLES3`示例。这个示例的Java代码（除了SDL2内部实现之外）简短且简单：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Everything else is done in the C++ code. There is the `main()` function, which
    is redefined by SDL2 using a macro to make our application look like a desktop
    one:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有操作都在C++代码中完成。有一个`main()`函数，它通过SDL2使用宏重新定义，使我们的应用程序看起来像是桌面应用程序：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, a window and an OpenGL rendering context are created using the `clSDLWindow`
    class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`clSDLWindow`类创建一个窗口和一个OpenGL渲染上下文：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can retrieve pointers to OpenGL functions. This abstraction is superior
    to statically linking against an OpenGL library since it makes our code more portable.
    For example, you cannot statically link to core OpenGL functions on Windows without
    using third-party libraries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以获取OpenGL函数的指针。这种抽象比静态链接到OpenGL库更优越，因为它使我们的代码更具可移植性。例如，在Windows上，如果不使用第三方库，你不能静态链接到核心OpenGL函数：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the callback we already used in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual Filesystem*,
    when dealing with virtual filesystems. We won''t need any path in this example,
    so let''s just use an empty string:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第四章](part0043.xhtml#aid-190861 "第四章. 组织虚拟文件系统")，*组织虚拟文件系统*中处理虚拟文件系统时已经使用的回调。在这个例子中我们不需要任何路径，所以让我们使用一个空字符串：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The event loop is done explicitly and contains a call to the `OnDrawFrame()`
    function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是显式完成的，并包含对`OnDrawFrame()`函数的调用：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These wrapper classes (`clSDL` and `clSDLWindow`) are declared in files `SDLLibrary.h`
    and `SDLWindow.h` respectively. The `clSDL` class is a RAII wrapper on top of
    SDL and does initialization and deinitialization of the library in its constructor
    and destructor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装类（`clSDL`和`clSDLWindow`）分别声明在`SDLLibrary.h`和`SDLWindow.h`文件中。`clSDL`类是基于SDL的RAII包装器，在构造函数和析构函数中进行库的初始化和反初始化：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `clSDLWindow` class represents a window abstraction with an OpenGL context
    and a system message pump attached to it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSDLWindow`类表示一个带有OpenGL上下文和系统消息泵的窗口抽象：'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This member function performs one iteration of the message loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个成员函数执行消息循环的一次迭代：
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Convert integer coordinates into floating point normalized coordinates 0..1
    to make it easier to use screens of different resolutions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数坐标转换为浮点数标准化坐标0..1，以便更容易使用不同分辨率的屏幕：
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following method is useful to construct a projection matrix for the current
    window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法对于构建当前窗口的投影矩阵很有用：
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A public static helper method to create an instance of `clSDLWindow` is as
    foows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公共静态辅助方法，用于创建`clSDLWindow`的实例：
- en: '[PRE12]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `HandleEvent()` member function does the job of dispatching an SDL2 event
    to our callcks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleEvent()`成员函数负责将SDL2事件分派给我们的回调函数：'
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implementation of `HandleEvent()` is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleEvent()`的实现如下：'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Not all of the case labels are implemented and not all SDL2 events are used.
    We will make use of this routing on an as-needed basis in the subsequent chapters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的案例标签都已实现，也并非所有的SDL2事件都被使用。我们将在后续章节根据需要使用这个路由。
- en: 'In our example, we render a rotating box using some useful OpenGL wrappers,
    which can hide the differences between mobile and desktop versions of OpenGL.
    Here is the code of `OnStart()` printing the version of OpenGL into the system
    log and initializing vertex buffer objects and shader programs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用一些有用的OpenGL包装器渲染一个旋转的盒子，可以隐藏移动版和桌面版OpenGL之间的差异。以下是`OnStart()`的代码，它将OpenGL的版本打印到系统日志中，并初始化顶点缓冲对象和着色器程序：
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we create an API-agnostic representation of a box mesh:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个与API无关的盒子网格表示：
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we feed it into OpenGL to create a vertex array using vertex buffer object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其输入到OpenGL中，使用顶点缓冲对象创建一个顶点数组：
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The shader program is constructed from two string variables containing the
    source code of vertex and fragment shaders:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序由包含顶点和片段着色器源代码的两个字符串变量构建而成：
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are the shaders written in GLSL 3.3 Core Profile. Transform the vertices
    using the model-view-projection matrix:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用GLSL 3.3核心配置编写的着色器。使用模型-视图-投影矩阵变换顶点：
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Paint the box using texture coordinates as RG color components:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理坐标作为RG颜色分量来绘制盒子：
- en: '[PRE20]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You may have noticed the source code of the shaders does not contain `#version`
    and `precision` lines. This is because the `clGLSLShaderProgram` class does some
    manipulations on the source code to abstract the differences between different
    versions of GLSL. We will familiarize ourselves with this class in the subsequent
    paragraphs. Before that, let''s take a look at `OnDrawFrame()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到着色器的源代码不包含`#version`和`precision`行。这是因为`clGLSLShaderProgram`类对源代码进行了一些操作，以抽象不同版本GLSL之间的差异。我们将在后续段落熟悉这个类。在此之前，让我们看看`OnDrawFrame()`：
- en: '[PRE21]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Rotate the cube around the `(1, 1, 1)` axis:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 绕`(1, 1, 1)`轴旋转立方体：
- en: '[PRE22]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: OpenGL API binding
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL API绑定
- en: 'As you can see, all OpenGL calls in the earlier mentioned code are done via
    the `LGL3` prefix. This is a structure called `sLGLAPI` declared in `LGLAPI.h`
    containing pointers to actual OpenGL API functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面提到的代码中所有的OpenGL调用都是通过`LGL3`前缀完成的。这是一个在`LGLAPI.h`中声明的名为`sLGLAPI`的结构，包含指向实际OpenGL
    API函数的指针：
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The fields of the `sLGLAPI` structure are set in the `LGL::GetAPI()` function.
    There are two distinct implementations of this function, one is for Windows in
    `LGL_Windows.h`, and the other is in `LGL_Android.h` for everything else. The
    difference is in the dynamic linking on Windows, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`sLGLAPI`结构的字段在`LGL::GetAPI()`函数中设置。这个函数有两个不同的实现，一个是Windows的`LGL_Windows.h`，另一个是`LGL_Android.h`中为其他所有平台。区别在于Windows上的动态链接，如下代码所示：'
- en: '[PRE24]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All other platforms use static linking against the system-provided OpenGL library:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他平台都使用静态链接系统提供的OpenGL库：
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, if you use vendor-specific OpenGL extensions, you can access them
    using dynamic linking and `glGetProcAddresss()` on any platform and that is where
    the `sLGLAPI` structure comes in handy:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你使用特定供应商的OpenGL扩展，可以使用动态链接在任何平台上通过`glGetProcAddresss()`访问它们，这时`sLGLAPI`结构就显得非常方便：
- en: 'This was the lowest of our abstraction levels on top of OpenGL. One might say
    this so -called layer does nothing. This is not true. Just take a look how a pointer
    to `glClearDepth()` is retrieved on Android. Instead of a direct function call,
    there is a stub for some reason:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在OpenGL之上的抽象层次最低的部分。有人可能会说这个所谓的层次什么也不做。这是不正确的。看看在Android上是如何获取`glClearDepth()`的指针的。出于某种原因，不是直接调用函数，而是一个存根：
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The stub is defined in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 存根定义如下：
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The reason is there was no `glClearDepth()` function in OpenGL ES, which accepts
    a `float` parameter but OpenGL 3 has one. This way the API difference between
    mobile and desktop OpenGL can be hidden from the client code behind a thin abstraction
    layer. Using this technique, you can transparently replace one OpenGL enums with
    the other. A tracing mechanism can be transparently implemented which can print
    the values of OpenGL function parameters into the log. This technique is crucial
    when porting existing applications to platforms where no graphics debugger is
    available (yes, we are looking at you, BlackBerry). We will leave that as an exercise
    for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是OpenGL ES中没有`glClearDepth()`函数，它接受一个`float`参数，但OpenGL 3有这个函数。这种方式可以将移动设备和桌面OpenGL之间的API差异隐藏在薄薄的抽象层后面。使用这种技术，你可以透明地替换一个OpenGL枚举为另一个。可以透明地实现跟踪机制，将OpenGL函数参数的值打印到日志中。在将现有应用程序移植到没有图形调试器可用的平台时，这种技术至关重要（是的，我们在说你，黑莓）。我们将这个作为你的练习。
- en: Let's now dive deeper and find out how higher-level abstractions are implemented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解高级抽象是如何实现的。
- en: Cross-platform OpenGL abstractions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台的OpenGL抽象概念
- en: Geometric objects can be represented by their surfaces. In this chapter, we
    are talking only about polygonal graphics, so the data structure of fundamental
    importance is the *triangular mesh*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几何对象可以通过它们的表面来表示。在本章中，我们只讨论多边形图形，因此最重要的数据结构是*三角网格*。
- en: Just as with the digital audio, our convenient API-agnostic data structures
    should be converted to something native for the graphics API before they can be
    rendered. Let's start with the representation of triangulated geometry in the
    3D space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数字音频一样，我们方便的API无关的数据结构在可以渲染之前需要转换成图形API的本地格式。让我们从3D空间中三角化几何的表示开始。
- en: 'A single triangle can be specified by three vertices. Each vertex stores at
    least its position in the 3D space, as shown in the following figure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一三角形可以通过三个顶点来指定。每个顶点至少存储其在3D空间中的位置，如下所示：
- en: '![Cross-platform OpenGL abstractions](img/image00223.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![跨平台的OpenGL抽象概念](img/image00223.jpeg)'
- en: 'The first thing in implementing a portable renderer, we need to separate geometry
    storage, which in the most simple case, is just a collection of vertices with
    their attributes and the order to iterate through these vertices to construct
    graphical primitives, from any API-specific functions and data types. This kind
    of data structure is implemented in the `clVertexAttribs` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现可移植渲染器的第一步，我们需要将几何存储分离出来，最简单的情况下，这只是带有属性和顶点的集合以及通过这些顶点构造图形原语的迭代顺序，与任何API特定的函数和数据类型分离。这种数据结构在`clVertexAttribs`类中实现：
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method returns a container of pointer to the actual vertex attributes,
    positions, texture coordinates, normals, and colors, which can be fed into an
    OpenGL vertex buffer object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个包含指向实际顶点属性、位置、纹理坐标、法线和颜色的容器，可以输入到OpenGL顶点缓冲对象中：
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We declare a bunch of helper methods to generate geometry data:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一组辅助方法来生成几何数据：
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We declare a set of public fields to store our data. The vertex 3D positions
    *x*, *y*, *z* are declared as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一组公共字段来存储我们的数据。顶点3D位置*x*，*y*，*z*声明如下：
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Texture coordinates `u` and `v`. This is a limitation of our vertex format
    since sometimes texture coordinates can contain more than two channels. However,
    for our applications, this limitation is appropriate and viable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标`u`和`v`。这是我们顶点格式的局限性，因为有时纹理坐标可能包含超过两个通道。然而，对于我们的应用程序来说，这种限制是合适且可行的：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The vertex normals are usually in the object space:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点法线通常在对象空间中：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'RGBA colors of the vertices. This container can be used for any custom data
    you want if you write the right shader, of course:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的RGBA颜色。如果你编写了正确的着色器，这个容器可以用于任何你想要的定制数据：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The implementation is simple; however, we suggest that you take a look at the
    `Geometry.cpp` and `Geometry.h` files before proceeding further.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单；但是，我们建议在进一步操作之前查看`Geometry.cpp`和`Geometry.h`文件。
- en: 'To populate instances of `clVertexAttribs` with useful data, a set of static
    methods is declared within the `clGeomServ` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将有用的数据填充到`clVertexAttribs`的实例中，`clGeomServ`类中声明了一组静态方法：
- en: '[PRE35]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All `Create*()` methods create a new geometry primitive and return an instance
    of `clVertexAttribs` containing it. Methods starting with `Add` add a primitive
    to the existing instance of the `clVertexAttribs` class assuming it has enough
    capacity to store the new primitive.Implementations ofmpleare trivial and can
    be found in `Geometry.cpp`. More sophisticated geometry generation routines will
    be added in the subsequent chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Create*()`方法创建一个新的几何图元并返回包含它的`clVertexAttribs`实例。以`Add`开头的方法将图元添加到现有的`clVertexAttribs`类实例中，假设它有足够的容量来存储新的图元。实现非常简单，可以在`Geometry.cpp`中找到。更复杂的几何生成例程将在后续章节中添加。
- en: Feeding the geometry data to OpenGL
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将几何数据提供给OpenGL
- en: 'To render the contents of `clVertexAttribs`, we need to convert its data into
    a set of API-specific buffers and API function invocations. This is done in the
    `clGLVertexArray` class by creating **Vertex Array Object** (**VOA**) and **Vertex
    Buffer Object** (**VBO**) OpenGL objects and fetching contents from `clVertexAttribs`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染`clVertexAttribs`的内容，我们需要将其数据转换为一组特定于API的缓冲区和API函数调用。这是通过在`clGLVertexArray`类中创建**顶点数组对象**（**VOA**）和**顶点缓冲区对象**（**VBO**）OpenGL对象，并从`clVertexAttribs`获取内容来完成的：
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Draw()` method does the actual rendering and it is the lowest level possible
    with our abstraction layer to actually render anything:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw()`方法执行实际渲染，它是我们抽象层中可能进行渲染的最低级别：'
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These pointers are actually offsets of vertex data inside the vertex buffer:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指针实际上是顶点数据在顶点缓冲区内的偏移量：
- en: '[PRE38]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And these pointers point to the actual data from `clVertexAttribs`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指针指向`clVertexAttribs`中的实际数据：
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation of this class includes some book-keeping and calling the
    OpenGL functions. The constructor and destructor initialize and destroy handles
    for VOA and VBO:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现包括一些簿记工作以及调用OpenGL函数。构造函数和析构函数分别初始化和销毁VOA和VBO的句柄：
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On Windows, we use OpenGL 4 where usage of vertex array object is mandatory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们使用OpenGL 4，其中使用顶点数组对象是强制性的：
- en: '[PRE41]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Destruction is done in a similar platform-specific way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁操作以特定于平台的方式进行：
- en: '[PRE42]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The private method `Bind()` sets this vertex array object as the source vertex
    stream for the OpenGL rendering pipeline:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法`Bind()`将此顶点数组对象设置为OpenGL渲染管线的源顶点流：
- en: '[PRE43]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After binding and enabling the vertex positions, we enable each additional
    non-empty attribute:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定并启用顶点位置后，我们启用每个额外的非空属性：
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Draw()` method binds the VOA and calls `glDrawArrays()` to render the
    geometry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw()`方法绑定VOA并调用`glDrawArrays()`来渲染几何图形：'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first parameter is the type of primitives. If the `Wireframe` parameter
    is `true`, we tell OpenGL to treat the data as a collection of lines, one for
    each sequential pair of points. If the parameter is `false`, each sequential point
    triple is used as three vertices of a triangle:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是图元的类型。如果`Wireframe`参数为`true`，我们告诉OpenGL将数据视为一系列线，每个连续的点对一条线。如果参数为`false`，则每个连续的点三元组被用作三角形的三个顶点：
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `SetVertexAttribs()` member function attaches the geometry to `GLVertexArray`
    and recreates all the required OpenGL objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetVertexAttribs()`成员函数将几何数据附加到`GLVertexArray`并重新创建所有必需的OpenGL对象：'
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After assigning a pointer, we acquire an array of pointers to individual vertex
    attribute streams:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分配指针后，我们获取一个指向各个顶点属性流的指针数组：
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Every stream is checked if it contains any data and the size of the vertex
    buffer is updated accordingly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个流是否包含任何数据，并相应地更新顶点缓冲区的大小：
- en: '[PRE49]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After this, we create a new vertex buffer object that will contain the geometry
    data:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个新的顶点缓冲区对象，该对象将包含几何数据：
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The most important thing here is to copy the data from `clVertexAttribs` object
    to GPU memory. This is done by calling `glBufferData()` with a `nullptr` value
    as the buffer pointer to allocate the storage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的事情是将数据从`clVertexAttribs`对象复制到GPU内存中。这是通过使用`nullptr`作为缓冲区指针调用`glBufferData()`来分配存储来完成的：
- en: '[PRE51]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can find more information about `glBufferData()` at [https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml)找到更多关于`glBufferData()`的信息。
- en: 'Here are subsequent calls to `glBufferSubData()` for each non-empty attribute
    array, those are vertex positions, texture coordinates, normals, and colors:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对每个非空属性数组的后续`glBufferSubData()`调用，这些属性数组包括顶点位置、纹理坐标、法线和颜色：
- en: '[PRE52]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Binding is somewhat specific for VAO and non-VAO versions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定对于VAO和非VAO版本来说有些特定：
- en: '[PRE53]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The VAO version can be used on OpenGL ES 3\. However, unmodified code also runs
    on OpenGL ES 2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: VAO版本可以在OpenGL ES 3上使用。然而，未经修改的代码也可以在OpenGL ES 2上运行。
- en: Shader programs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器程序
- en: Both desktop and mobile OpenGL versions use shader programs as parts of their
    rendering pipelines. Feeding just the geometry is not enough. However, there are
    several important differences between GLSL 3.00 ES and GLSL 3.30 Core we should
    deal with to create a portable rendering subsystem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面和移动OpenGL版本都将着色器程序作为其渲染管道的一部分。仅提供几何图形是不够的。然而，为了创建可移植的渲染子系统，我们应该处理GLSL 3.00
    ES和GLSL 3.30 Core之间的几个重要区别。
- en: 'Let''s start with the declaration of a `uniform` value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`uniform`值的声明开始：
- en: '[PRE54]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This class stores name and location of a uniform within a linked shader program.
    The shader program class looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类存储了在链接着色器程序中统一变量的名称和位置。着色器程序类的结构如下所示：
- en: '[PRE55]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The constructor takes the source code of vertex and fragment shaders as parameters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数以顶点和片段着色器的源代码作为参数：
- en: '[PRE56]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Bind()` method binds the shader program before usage:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind()`方法在使用前绑定着色器程序：'
- en: '[PRE57]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A group of methods dealing with uniforms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一组处理统一变量的方法：
- en: '[PRE58]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Link the program using the attached shaders:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用附加的着色器链接程序：
- en: '[PRE59]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to bind default locations of attributes and fragment data. This is
    done in the following method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要绑定属性和片段数据的默认位置。这将在以下方法中完成：
- en: '[PRE60]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It binds the shader variables `in_Vertex`, `in_Normal`, `in_TexCoord`, and `in_Color`
    to appropriate vertex streams. You can declare and use these `in` variables in
    your GLSL code. The `out_FragColor` output variable is associated with the single
    output of a fragment shader.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它将着色器变量`in_Vertex`、`in_Normal`、`in_TexCoord`和`in_Color`绑定到适当的顶点流。你可以在你的GLSL代码中声明并使用这些`in`变量。`out_FragColor`输出变量与片段着色器的单一输出相关联。
- en: 'Compile and attach a shader to this shader program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并将着色器附加到此着色器程序：
- en: '[PRE61]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Check and log any errors occurred while compiling and linking:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查编译和链接过程中发生的任何错误并记录：
- en: '[PRE62]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This method retrieves all uniforms from the linked shader program and stores
    them as `sUniform` structures within the `FUniforms` container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从链接的着色器程序检索所有统一变量，并将它们作为`sUniform`结构存储在`FUniforms`容器中：
- en: '[PRE63]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A collection of active uniforms in this shader program is stored as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此着色程序中所有活动的统一变量集合存储如下：
- en: '[PRE64]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'An OpenGL shader program and shader identifiers are stored in the following
    fields:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL着色器程序和着色器标识符存储在以下字段中：
- en: '[PRE65]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can destroy all the created OpenGL objects as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下销毁所有创建的OpenGL对象：
- en: '[PRE66]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s see how a shader object is created and attached to the shader program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建着色器对象并将其附加到着色器程序：
- en: '[PRE67]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since we use OpenGL ES 3 and OpenGL 4, the version of shaders should be specified
    accordingly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用OpenGL ES 3和OpenGL 4，着色器的版本应相应指定：
- en: '[PRE68]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The resulting shader is submitted to OpenGL API functions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的着色器提交给OpenGL API函数：
- en: '[PRE69]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Check the compilation status and log any errors detected while compiling the
    code. This code falls back to the previously compiled shader if the new one fails
    to compile. You can implement dynamic shader program reloading as an exercise
    using filesystem classes from the previous chapters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 检查编译状态，并记录编译代码时检测到的任何错误。如果新着色器编译失败，这段代码将回退到之前编译的着色器。你可以使用前几章中的文件系统类来实现动态着色器程序的重新加载：
- en: '[PRE70]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Error checking and logging is not that complicated to implement and is a must-have:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 错误检查和记录实现起来并不复杂，是必须的：
- en: '[PRE71]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A buffer for a shader program error message is allocated dynamically on the
    stack:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序错误消息的缓冲区在栈上动态分配：
- en: '[PRE72]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Deal with a shader object in a similar way as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式处理着色器对象：
- en: '[PRE73]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Relinking of the shader program is done when both vertex and fragment shader
    objects had been successfully compiled:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点和片段着色器对象都成功编译后，将重新链接着色器程序：
- en: '[PRE74]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Bind locations of all default vertex attributes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定所有默认顶点属性的定位：
- en: '[PRE75]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'At this point, we know the shader program was linked successfully, and we can
    use it as a part of our rendering pipeline. Replace the old program with this
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们知道着色器程序已成功链接，我们可以将其作为渲染管道的一部分使用。用以下代码替换旧程序：
- en: '[PRE76]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Retrieve the list of active uniforms from the linked program and store them:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从链接的程序中检索活动统一变量的列表并存储它们：
- en: '[PRE77]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Bind texture samplers to their default locations. You can add more texture
    units whenever you desire:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理采样器绑定到它们的默认位置。你可以在任何时候添加更多的纹理单元：
- en: '[PRE78]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Queuing of uniforms is done in the `RebindAllUniforms()` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RebindAllUniforms()`方法中完成统一变量的排队：
- en: '[PRE79]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `sUniform` object is constructed and pushed into the container for future
    access. As an improvement, the vector can be sorted or replaced with `std::map`
    to allow faster access:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`sUniform`对象被构造并推入容器以供将来访问。作为改进，可以排序向量或用`std::map`替换以允许更快地访问：'
- en: '[PRE80]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `SetUniform*()` group of methods sets the value for a named uniform in
    the GLSL shader program. These methods retrieve a handle of a uniform by calling
    `CreateUniform()`, and then use one of the `glUniform*()` OpenGL functions to
    set the new value. String names can be used for rapid prototyping of shaders.
    If you want to go for performance, retrieve the location of the uniform beforehand
    using the `CreateUniform()` member function and use that value with a corresponding
    call to `SetUniform*()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetUniform*()`方法组在GLSL着色器程序中设置一个命名统一变量的值。这些方法通过调用`CreateUniform()`获取统一变量的句柄，然后使用`glUniform*()`系列OpenGL函数之一来设置新值。字符串名称可以用于着色器的快速原型设计。如果你想要追求性能，可以事先使用`CreateUniform()`成员函数获取统一变量的位置，并使用该值与对应的`SetUniform*()`调用：'
- en: '[PRE81]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Vectors are converted to pointers. Notice the following trick, the `ToFloatPtr()`
    method returns a pointer to the `x` component of a vector. In the case when this
    vector in packed into an array of vectors, we also have the pointer to the beginning
    of the array. Thus, the `Count` parameter makes perfect sense and we may pass
    arrays of vectors to this method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向量被转换为指针。注意以下技巧，`ToFloatPtr()`方法返回一个指向向量`x`分量的指针。当这个向量被包装到一个向量数组中时，我们也拥有指向数组开头的指针。因此，`Count`参数非常有意义，我们可以将向量数组传递给这个方法：
- en: '[PRE82]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Methods for matrices differ from the previous ones only by parameter types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的方法与前面的方法不同，只是参数类型不同：
- en: '[PRE83]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `CreateUniform()` method used in `SetUniform*()` performs a search in the
    `FUniforms` container and returns the OpenGL identifier of the uniform:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetUniform*()`中使用的`CreateUniform()`方法在`FUniforms`容器中进行搜索，并返回统一变量的OpenGL标识符：
- en: '[PRE84]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This method is safe to use for any name, since the value of `-1` returned for
    uniforms not found in the shader program is accepted and ignored by OpenGL.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法用于任何名称都是安全的，因为对于在着色器程序中找不到的统一变量返回的`-1`值被OpenGL接受并忽略。
- en: 'The `Bind()` method binds the shader program to the current OpenGL rendering
    context:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind()`方法将着色器程序绑定到当前的OpenGL渲染上下文：'
- en: '[PRE85]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In a more sophisticated application, it makes sense to cache the value of the
    currently binded shader program and call the underlying API only if the value
    was changed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，缓存当前绑定的着色器程序的值是有意义的，并且只有当值发生变化时才调用底层API。
- en: Textures
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理
- en: 'The last component we need to wrap is a texture. Textures are represented as
    instances of the `clGLTexture` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包装的最后一个组件是纹理。纹理由`clGLTexture`类的实例表示：
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Bind the texture to a specified OpenGL texture unit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理绑定到一个指定的OpenGL纹理单元：
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Load texture pixels from an API-independent bitmap:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从API无关的位图中加载纹理像素：
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set the texture coordinates clamping mode:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设置纹理坐标的钳制模式：
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Deal with the data formats and dimensions of t texture:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 处理纹理的数据格式和尺寸：
- en: '[PRE90]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The implementation is quite compact. Here it is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现相当紧凑。下面就是代码：
- en: '[PRE91]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can set the format of the texture without uploading any pixels. This is
    useful if you want to attach the texture to a frame buffer object. We will use
    this functionality in [Chapter 8](part0069.xhtml#aid-21PMQ2 "Chapter 8. Writing
    a Rendering Engine"), *Writing a Rendering Engine*, to implement render-to-texture
    functionality:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置纹理的格式而不上传任何像素。如果你想要将纹理附加到帧缓冲对象，这非常有用。我们将在[第8章](part0069.xhtml#aid-21PMQ2
    "第8章 编写渲染引擎")，*编写渲染引擎*中使用这个功能来实现渲染到纹理的功能：
- en: '[PRE92]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Update `S` and `T` clamping modes as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式更新`S`和`T`的钳制模式：
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Choose an appropriate OpenGL texture format based on the bitmap parameters:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 根据位图参数选择合适的OpenGL纹理格式：
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Set the default filtering mode to `GL_LINEAR` to avoid building a mipmap chain:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认过滤模式设置为`GL_LINEAR`以避免构建mipmap链：
- en: '[PRE95]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Some OpenGL ES implementations does not allow zero-size textures (yes, we are
    looking at you, Vivante):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 某些OpenGL ES实现不允许零尺寸的纹理（是的，我们说的是你，Vivante）：
- en: '[PRE96]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Load raw bitmap data into OpenGL:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始位图数据加载到OpenGL中：
- en: '[PRE97]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Up to this point, we have enough instruments at our disposal to build portable
    mobile applications using OpenGL. The example application `1_GLES` for this chapter
    renders a colored rotating cube on Windows and Android:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有足够的工具来使用OpenGL构建可移植的移动应用程序。本章的示例应用程序`1_GLES`在Windows和Android上渲染了一个彩色的旋转立方体：
- en: '![Textures](img/image00224.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![纹理](img/image00224.jpeg)'
- en: 'The Windows version can be compiled with `>make all -j16 -B`. An `.apk` package
    for Android can be built by calling these commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows版本可以通过执行`>make all -j16 -B`来编译。可以通过调用以下命令来构建Android的`.apk`包： '
- en: '[PRE98]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned how to wrap raw OpenGL calls into a thin abstraction layer to hide
    many differences between OpenGL ES 3 and OpenGL 4\. Now, let's proceed to the
    next chapter and learn how to implement basic graphical user interface rendering
    using OpenGL and classes shown in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何将原始的OpenGL调用封装在一个轻薄的抽象层中，以隐藏OpenGL ES 3和OpenGL 4之间的许多差异。现在，让我们进入下一章，学习如何使用OpenGL和本章展示的类来实现基本的图形用户界面渲染。
