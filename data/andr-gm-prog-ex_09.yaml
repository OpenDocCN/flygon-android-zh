- en: Chapter 9. Asteroids at 60 FPS with OpenGL ES 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用OpenGL ES 2以60 FPS实现小行星游戏
- en: Welcome to the final project. Over the course of the next three chapters, we
    will build an Asteroids-like game using the OpenGL ES 2 graphics API. If you are
    wondering exactly what OpenGL ES 2 is, then we will discuss the details later
    in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到最终项目。在接下来的三章中，我们将使用OpenGL ES 2图形API构建一个类似小行星的游戏。如果你好奇OpenGL ES 2到底是什么，我们将在本章后面讨论其细节。
- en: We will build a very simple but fun and challenging game, where we can draw
    and animate hundreds of objects at a time, even on quite old Android devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个非常简单但有趣且具有挑战性的游戏，可以在一次绘制和动画化数百个对象，即使在相当老旧的Android设备上也能实现。
- en: With OpenGL, we will take our drawing efficiency to a much higher level, and
    with some not-too-tricky math, our movement and collision detection will be greatly
    enhanced compared to our previous projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL，我们将把绘图效率提升到一个更高的层次，通过一些不太复杂的数学运算，我们的移动和碰撞检测将比之前的项目大大增强。
- en: By the end of this chapter, we will have a basic working OpenGL ES 2 engine
    drawing our simple but temporarily static spaceship to the screen; at 60 FPS or
    higher.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将拥有一个基本的可工作的OpenGL ES 2引擎，以60 FPS或更高的帧率绘制我们简单但暂时静态的飞船到屏幕上。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have never seen or played the '80s arcade hit (released in November 1979)
    Asteroids, why not go and check out a clone of it or a video now?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过或玩过1979年11月发布的80年代街机游戏（Asteroids），为什么不去看看它的克隆版或视频呢？
- en: Free web game at [http://www.freeasteroids.org/](http://www.freeasteroids.org/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://www.freeasteroids.org/](http://www.freeasteroids.org/)免费玩网络游戏。
- en: On YouTube at [https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube上观看[https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo)。
- en: Let's discuss exactly what we intend to build.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确切地讨论一下我们打算构建的内容。
- en: Asteroids simulator
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小行星模拟器
- en: Our game will be set in a four directional scrolling world that the player will
    be able to traverse while hunting for asteroids. The world will be enclosed in
    a rectangular border to keep the asteroids from drifting off too far, and the
    border will also serve as another hazard for the player to avoid.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏设定在一个四个方向滚动的世界中，玩家可以在寻找小行星的同时穿越这个世界。世界将被一个矩形边界所包围，以防止小行星漂移得太远，这个边界也将成为玩家需要避开的另一个障碍。
- en: The game controls
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏控制
- en: We will reuse our `InputController` class with a few simple modifications and
    can even keep the same button layout. As we will see, however, we will draw the
    buttons on screen in a very different manner to our retro platformer. Also, instead
    of walking left and right, the player will rotate the ship left and right through
    360 degrees. The jump button will become a thrust toggle switch to turn on and
    off forward motion, and the shoot button will remain just that. We will also have
    the pause button in the same place.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新使用我们的`InputController`类，并进行一些简单的修改，甚至可以保持相同的按钮布局。然而，正如我们将看到的，我们将以与复古平台游戏非常不同的方式在屏幕上绘制按钮。此外，玩家将旋转飞船向左和向右360度，而不是左右走动。跳跃按钮将变成一个推进开关，以开启或关闭前进动力，而射击按钮将保持原样。我们还将保持暂停按钮在同一位置。
- en: Rules for the game
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: When an asteroid hits the border, it will bounce back into the game world. If
    the player hits the border, a life will be lost and the ship will respawn in the
    center of the screen. If an asteroid hits the ship this will be fatal too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当小行星撞击边界时，它将反弹回游戏世界。如果玩家撞击边界，将损失一条生命，并且飞船将在屏幕中心重新生成。如果小行星撞击飞船，这将是致命的。
- en: The player will start with three lives and must clear the asteroids simulator
    of all asteroids. The HUD will show a tally of the remaining asteroids and lives.
    If the player clears all the asteroids, then the next wave will start with more
    than the last. They will also move a little faster. Each wave cleared will be
    rewarded with an extra life.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家将从三条生命开始，必须清除所有小行星模拟器中的小行星。抬头显示（HUD）将显示剩余小行星和生命的计数。如果玩家清除了所有小行星，下一波将会比上一波更多，并且它们的移动速度会稍快一些。每清除一波，玩家将获得一条额外的生命。
- en: We will implement these rules as we proceed through the project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目进行中实施这些规则。
- en: Introducing OpenGL ES 2
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenGL ES 2
- en: OpenGL ES 2 is the second major version of the **Open Graphics Library** (**OpenGL**)
    for embedded systems. It is the mobile incarnation of OpenGL for desktop systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 2是针对嵌入式系统的**开放图形库**（**OpenGL**）的第二个主要版本。它是桌面系统OpenGL在移动设备上的化身。
- en: Why use it and how does it work?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用它以及它是如何工作的？
- en: OpenGL runs as a native process, not on the Dalvik virtual machine like the
    rest of our Java. This is one of the reasons it is super fast. The OpenGL ES API
    takes away all of the complexity of interacting with native code, and OpenGL itself
    also provides very efficient and fast algorithms within its native code base.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL作为一个本地进程运行，而不是像我们其他Java代码那样在Dalvik虚拟机上运行。这是它超级快速的一个原因。OpenGL ES API消除了与本地代码交互的所有复杂性，而OpenGL本身在其本地代码库中也提供了非常高效和快速的算法。
- en: The first version of OpenGL was completed in 1992\. The point is that even back
    then OpenGL used arguably the most efficient code and algorithms to draw graphics.
    Now, more than 20 years on, it has been continually refined and improved as well
    as adapted to work with the latest graphics hardware, both mobile and desktop.
    All the mobile GPU manufacturers specifically design their hardware to be compatible
    with the latest version of OpenGL ES.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版的OpenGL在1992年完成。重点是即使在那时，OpenGL也使用了可以说最高效的代码和算法来绘制图形。现在，20多年后，它一直在不断改进和完善，同时适配最新的图形硬件，包括移动端和桌面端。所有移动GPU制造商都专门设计硬件以兼容最新版本的OpenGL
    ES。
- en: Trying to improve on OpenGL ES is, therefore, probably a fool's errand.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，试图改进OpenGL ES可能是一项愚蠢的尝试。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is another viable Graphics API option when developing exclusively for
    Windows devices called DirectX.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当专门为Windows设备开发时，还有另一个可行的图形API选项，即DirectX。
- en: What is neat about Version 2?
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二版的亮点是什么？
- en: The first version of OpenGL ES certainly impressed at the time. I remember almost
    falling off my chair when I first played a 3D shooter on a phone! Now this is
    of course commonplace. However, compared to the desktop version of OpenGL, OpenGL
    ES 1 had a major drawback.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一版的OpenGL ES在当时的确令人印象深刻。我记得当我第一次在手机上玩3D射击游戏时，几乎从椅子上掉下来！现在这当然很常见。然而，与桌面版的OpenGL相比，OpenGL
    ES 1有一个重大缺点。
- en: OpenGL ES 1 had, what is known as, a fixed function pipeline. The geometry to
    draw went into the GPU and it was drawn, but any further manipulation of individual
    pixels needed to take place before OpenGL ES took over the drawing of a frame
    of the game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 1有一个所谓的固定功能管线。要绘制的几何图形输入到GPU中，它就会被绘制，但任何对单个像素的进一步操作都需要在OpenGL ES接管游戏帧的绘制之前进行。
- en: Now, with OpenGL ES 2, we have access to what is called a programmable pipeline.
    That is, we can send our graphics off to be drawn, but we can also write code
    that runs on the GPU that is capable of manipulating each and every pixel independently.
    This is a very powerful feature, although we will not get to explore it in much
    depth.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过OpenGL ES 2，我们可以使用所谓的可编程管线。也就是说，我们可以将图形发送出去进行绘制，同时我们还可以编写在GPU上运行的代码，这种代码能够独立操作每一个像素。这是一个非常强大的特性，尽管我们不会深入探讨它。
- en: This extra code that runs on the GPU is called a **shader** program. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually called a **fragment shader**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上运行的这段额外代码称为**着色器**程序。我们可以编写代码在所谓的**顶点着色器**中操作图形的几何（位置）。我们还可以编写代码，单独操作每一个像素的外观，这称为**片断着色器**。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Actually, we can do better than even pixel manipulation. A fragment is not
    necessarily a pixel. It depends on the hardware and the specific nature of the
    graphics being processed. It can be more than one pixel or a sub-pixel: one light
    of several that makes up a pixel in the screen hardware.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们甚至可以比像素操作做得更好。片断不一定是像素。这取决于硬件和正在处理的图形的具体性质。它可以是一个以上的像素或子像素：屏幕硬件中组成一个像素的多个光线之一。
- en: The disadvantage of OpenGL ES 2 for simple games like this is that you must
    provide at least one vertex and one fragment shader, even if you are not going
    to do a whole lot with them. As we will see, however, this is not very difficult.
    Although we will not be exploring shaders in any depth, we will write some shader
    code using **GL Shader Language** (**GLSL**) and get a glimpse at the possibilities
    they offer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单游戏而言，OpenGL ES 2的缺点在于，即使你不会大量使用它们，也必须至少提供一个顶点和片断着色器。然而，正如我们将看到的，这并不困难。虽然我们不会深入探讨着色器，但我们将使用**GL
    Shader Language** (**GLSL**)编写一些着色器代码，并一窥它们所提供的可能性。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the power of programmable graphics pipelines and shaders is just too exciting
    to leave for another day, then I can highly recommend *GLSL Essentials* by Jacobo
    Rodríguez.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可编程图形管线和着色器的力量让你兴奋到无法等待，那么我强烈推荐Jacobo Rodríguez编写的*GLSL Essentials*。
- en: '[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[GLSL基础](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
- en: The book explores OpenGL shaders on the desktop and is highly accessible to
    any reader with basic programming knowledge and a willingness to learn a different
    language (GLSL), yet one with some syntax similarities to Java.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书探讨了桌面上的OpenGL着色器，对于任何具有基本编程知识并愿意学习不同语言（GLSL）的读者来说，都是高度可访问的，尽管它有一些与Java相似的语法。
- en: How will we be using OpenGL ES 2?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何使用OpenGL ES 2？
- en: How we will use OpenGL ES 2?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何使用OpenGL ES 2？
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and also combine these elements
    to make the complex graphics that we see in today's modern mobile games.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，一切都是点、线或三角形。此外，我们可以将颜色和纹理附加到这种基本几何图形上，并将这些元素组合起来制作出现在现代移动游戏中的复杂图形。
- en: We will use some of each type of element (points, lines, and triangles) that
    are collectively referred to as primitives.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用各种类型的元素（点、线和三角形），这些元素统称为图元。
- en: We will not be using textures on this project. Fortunately, the appearance of
    untextured primitives is appropriate for building our Asteroids-like game.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将不使用纹理。幸运的是，未纹理化的图元的外观适合构建类似小行星的游戏。
- en: In addition to primitives, Open GL uses matrices. **Matrices** are a method
    and structure for performing arithmetic. This arithmetic can range from extremely
    simple high-school level calculations to move (translate) a coordinate or it can
    be quite complex to perform more advanced mathematics to convert our game world
    coordinates into OpenGL screen coordinates that the GPU can use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图元，OpenGL还使用矩阵。**矩阵**是一种进行算术的方法和结构。这种算术可以从非常简单的高中水平的计算来移动（转换）一个坐标，也可以进行更复杂的计算，将我们的游戏世界坐标转换为GPU可以使用的OpenGL屏幕坐标。
- en: The point is that both the matrices and methods to use them are entirely provided
    by the OpenGL API. This means that we just have to learn what methods do which
    graphical manipulation and do not have to concern ourselves with the potentially
    complex math that goes on behind the scenes (on the GPU).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重点在于，无论是矩阵还是使用它们的方法，完全由OpenGL API提供。这意味着我们只需了解哪些方法可以进行哪些图形操作，无需关心背后可能复杂的数学运算（在GPU上进行的）。
- en: The best way to learn about shaders, primitives, and matrices in OpenGL is to
    go ahead and start using them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 学习OpenGL中的着色器、图元和矩阵的最佳方式是继续使用它们。
- en: Preparing OpenGL ES 2
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备OpenGL ES 2
- en: First we start off with our `Activity` class, which as before is the entry point
    into our game. Create a new project and in the **Application Name** field enter
    `C9 Asteroids`. Choose **Phones and tablets**, then **Blank Activity** when prompted.
    In the **Activity Name** field type `AsteroidsActivity`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`Activity`类开始，这和之前一样，是进入我们游戏的入口点。创建一个新项目，在**应用名称**字段中输入`C9 Asteroids`。选择**手机和平板**，然后在提示时选择**空白活动**。在**活动名称**字段中输入`AsteroidsActivity`。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Obviously you don't have to follow my exact naming choices but just remember
    to make the minor alterations in code to reflect your own naming choices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不必遵循我确切的命名选择，但只需记得在代码中进行小改动，以反映你自己的命名选择。
- en: You can delete `activity_asteroids.xml` from the `layout` folder. You can also
    delete all the code within the `AsteroidsActivity.java` file. Just leave the package
    declaration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`layout`文件夹中删除`activity_asteroids.xml`。你也可以删除`AsteroidsActivity.java`文件中的所有代码。只需保留包声明。
- en: Locking the layout to landscape
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将布局锁定为横屏
- en: 'Just as we did for the previous two projects, we will make sure the game runs
    in landscape mode only. We will make our `AndroidManifest.xml` file, force our
    `AsteroidsActivity` class to run with a full screen, and lock it to a landscape
    orientation. Let''s make these changes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前两个项目中做的那样，我们将确保游戏只在横屏模式下运行。我们将使我们的`AndroidManifest.xml`文件，强制我们的`AsteroidsActivity`类以全屏运行，并将其锁定为横屏方向。让我们进行这些更改：
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`manifests`文件夹，双击`AndroidManifest.xml`文件，在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE0]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Immediately, type or copy and paste these two lines to make `PlatformActivity`
    run in full screen and lock it in the landscape orientation:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即输入或复制粘贴以下两行代码，使`PlatformActivity`全屏运行，并将其锁定为横屏方向：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can move on to implementing our Asteroids simulator game with OpenGL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用OpenGL实现我们的Asteroids模拟器游戏。
- en: Activity
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'First of all, we have our familiar `Activity` class. The only thing that is
    new here is the type of our view class. We declare a member called `asteroidsView`
    of type `GLSurfaceView`. This is the class that will provide us with easy access
    to OpenGL. We will see exactly how very soon. Note that all we do is initialize
    `GLSurfaceView` by passing in the `Activity` context and the screen resolution
    that we obtain in the usual manner. Implement the `AsteroidsActivity` class as
    shown:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个熟悉的`Activity`类。这里唯一的新事物是我们视图类的类型。我们声明了一个名为`asteroidsView`的成员，其类型为`GLSurfaceView`。这个类将为我们提供轻松访问OpenGL的途径。我们很快就会看到具体如何实现。注意，我们所做的一切就是通过传递`Activity`上下文和以通常方式获取的屏幕分辨率来初始化`GLSurfaceView`。按照所示实现`AsteroidsActivity`类：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we will get to see some OpenGL code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一些OpenGL代码。
- en: The view
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Here, we will implement the `GLSurfaceView` class. Actually, this isn't where
    the real action will take place but it does allow us to attach an OpenGL renderer.
    This is a class that implements the `Renderer` interface. As well as in this critical
    `Renderer`, the `GLSurfaceView` class enables us to override the `onTouchListener`
    method that will allow us to detect player input in the same way that `SurfaceView`
    did in the previous projects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现`GLSurfaceView`类。实际上，这里并不是真正的动作发生的地方，但它确实允许我们附加一个OpenGL渲染器。这是一个实现了`Renderer`接口的类。除了这个关键的`Renderer`之外，`GLSurfaceView`类还允许我们覆盖`onTouchListener`方法，这将允许我们以与前一个项目中`SurfaceView`相同的方式来检测玩家输入。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android Studio does not auto-import or even suggest all of the OpenGL imports
    required. Therefore, I included all of the imports for some classes in the code
    listings. In addition, you will note that sometimes we use static imports. This
    will make the code more readable too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 不会自动导入甚至建议所有必需的OpenGL导入。因此，我在代码清单中包含了一些类的所有导入。此外，你会注意到我们有时使用静态导入。这将使代码更具可读性。
- en: 'In the code that follows, we declare and initialize a new object of type `GameManager`
    that we will implement soon. We set the OpenGL version to two by calling `setEGLContextClientVersion(2)`,
    and we set our vital renderer object by calling `setRenderer()` and passing in
    our `GameManager` object. Create a new class called `AsteroidsView` and implement
    it as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们声明并初始化了一个即将实现的`GameManager`类型的新对象。我们通过调用`setEGLContextClientVersion(2)`将OpenGL版本设置为2，并通过调用`setRenderer()`并传入我们的`GameManager`对象来设置我们关键的渲染器对象。创建一个名为`AsteroidsView`的新类，并按以下方式实现它：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can take a look at what is involved in our `GameManager` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们的`GameManager`类涉及到哪些内容。
- en: A class to manage our game
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个管理我们游戏的类
- en: This class will control things like the level the player is on, the number of
    lives, as well as things like the overall size of the game world. It will evolve
    a little as the project progresses, but it will remain quite simple in comparison
    to the combined depth of the LevelManager and PlayerState classes from the previous
    project, although it effectively replaces both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将控制诸如玩家所在的关卡、生命数量以及游戏世界的整体大小之类的事情。随着项目的进行，它会有一些变化，但与之前项目中的`LevelManager`和`PlayerState`类的综合深度相比，它将保持相当简单，尽管它实际上取代了这两个类。
- en: In the code that follows, we declare `int` members to hold the width and height
    of the game world; we can make this much bigger or smaller as we see fit. We keep
    track of the games status with the Boolean `playing`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们声明了`int`类型的成员来保存游戏世界的宽度和高度；我们可以根据需要将其设置得更大或更小。我们使用布尔值`playing`来跟踪游戏的状态。
- en: The `GameManager` class also needs to know the height and width of the screen
    in pixels, and this information is passed in to the constructor when the object
    is initialized back in the `AsteroidsView` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager`类还需要知道屏幕的宽度和高度（以像素为单位），这个信息是在`AsteroidsView`类中初始化对象时传递给构造函数的。'
- en: 'Note also the `metresToShowX` and `metresToShowY` member variables. These probably
    sound familiar from our `Viewport` class from the last project. These variables
    will be used for exactly the same thing: defining the current viewable area of
    the game world. This time, however, OpenGL will take care of what objects to clip
    before drawing (using a matrix). We will soon see where this happens.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也请注意`metresToShowX`和`metresToShowY`成员变量。这些可能听起来很熟悉，因为它们来自上一个项目的`Viewport`类。这些变量将被用于完全相同的事情：定义游戏世界的当前可查看区域。然而这次，OpenGL将负责在绘制之前裁剪哪些对象（使用矩阵）。我们很快就会看到这是在哪里发生的。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that although OpenGL takes care of clipping and scaling the area of the
    game world that we want to show, it doesn't have any effect on which objects are
    updated each frame. As we will see, however, this is just what we want for this
    game because we want all our objects to update themselves each frame, even when
    they are offscreen. Therefore, no `Viewport` class is necessary for this game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管OpenGL负责裁剪和缩放我们想要显示的游戏世界区域，但它对每帧更新哪些对象没有任何影响。然而，正如我们将要看到的，这正是我们想要的游戏效果，因为即使对象在屏幕外，我们也希望所有对象每帧都能更新自己。因此，这个游戏不需要`Viewport`类。
- en: 'Lastly, we want a convenient way to pause and unpause the game, and we provide
    this functionality with the `switchPlayingStatus` method. Create a new class called
    `GameManager` and implement it as shown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个便捷的方式来暂停和继续游戏，我们通过`switchPlayingStatus`方法提供这个功能。创建一个名为`GameManager`的新类，并按照所示实现它：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can now take our first look at these all powerful shaders and how we will
    manage them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以第一次了解这些强大的着色器以及我们将如何管理它们。
- en: Managing simple shaders
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理简单的着色器
- en: An application can have many shaders. We can then attach different shaders to
    different game objects to create the desired effects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以有许多着色器。然后我们可以将不同的着色器附加到不同的游戏对象上，以创建所需的效果。
- en: We will only have one vertex and one fragment shader in this game. However,
    when you see how to attach a shader to primitives, it will be plain that it is
    simple to have more shaders.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们只会有一个顶点着色器和一个片段着色器。然而，当你了解到如何将着色器附加到图元上时，你会发现拥有更多着色器是非常简单的。
- en: First of all, we need the code for the shader that will be executed in the GPU.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在GPU中执行的着色器的代码。
- en: Then we need to compile that code.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要编译那段代码。
- en: Finally, we need to link together the two compiled shaders into a GL program.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将两个编译后的着色器链接成一个GL程序。
- en: As we implement this next simple class, we will see how we can bundle up this
    functionality into a single method call, which can be made by an object from our
    game and have the ready-to-run GL program returned to the game object. When we
    build our `GameObject` class later in the chapter, we will see how we use this
    GL program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现这个下一个简单的类时，我们将看到如何将这个功能打包到一个方法调用中，这个调用可以由游戏中的对象发出，并将准备运行的GL程序返回给游戏对象。在本章后面构建我们的`GameObject`类时，我们将看到如何使用这个GL程序。
- en: 'Let''s go ahead and implement the necessary three steps in a new class. Create
    a new class and call it `GLManager`. Add the static imports as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个新类中实现必要的三个步骤。创建一个新类，并将其命名为`GLManager`。添加如下所示的静态导入：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will add some public static final member variables that we can use
    in our `GameObject` class later in the chapter. Although we will see exactly how
    they work when we get around to using them, here is a quick preliminary explanation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些公共静态最终成员变量，我们可以在本章后面的`GameObject`类中使用它们。虽然我们将在使用它们时确切地看到它们是如何工作的，但这里有一个快速预览解释。
- en: '`COPONENTS_PER_VERTEX` is the number of values that will be used to represent
    a single vertex (point) in our primitives that will make up our game objects.
    As you can see, we initialize this to three coordinates: *x*, *y*, and *z*.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPONENTS_PER_VERTEX`是用于表示构成游戏对象的图元中的单个顶点（点）的值数量。如您所见，我们将这个值初始化为三个坐标：*x*，*y*和*z*。'
- en: We also have `FLOAT_SIZE`, which is initialized to `4`. This is the number of
    bytes in a Java float. As we will see soon, OpenGL likes all its primitives passed
    into it in the form of a `ByteBuffer`. We need to make sure we are precise about
    where in the `ByteBuffer` each piece of information is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`FLOAT_SIZE`，它被初始化为`4`。这是Java浮点数的字节数。正如我们很快将看到的，OpenGL喜欢所有传入它的图元以`ByteBuffer`的形式。我们需要确保精确地知道在`ByteBuffer`中的每个信息片段的位置。
- en: 'Next, we declare `STRIDE` and initialize it to `COMPONENTS_PER_VERTEX * FLOAT_SIZE`.
    As OpenGL uses the float type to hold virtually all of the data it works with,
    `STRIDE` now equals the size in bytes of the data that represents a single vertex
    of an object. Go ahead and add these members at the top of the class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`STRIDE`并将其初始化为`COMPONENTS_PER_VERTEX * FLOAT_SIZE`。由于OpenGL使用浮点类型来处理几乎所有其工作的数据，`STRIDE`现在等于表示单个物体顶点的数据大小（以字节为单位）。请将这些成员添加到类的顶部：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be utilized. Here, we declare and initialize some strings that
    we can use to refer to these variables more cleanly in our code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL是一种自身的语言，并且它也有自己的类型，这些类型的变量可以被利用。在这里，我们声明并初始化一些字符串，我们可以使用它们在代码中更清晰地引用这些变量。
- en: Discussion of these types is beyond the scope of this book, but simply explained
    they will represent a matrix (`u_matrix`), a location (`a_position`), and a color
    (`u_Color`). We will see examples of the actual GLSL types these variables are
    in our shader code very soon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的讨论超出了本书的范围，但简单来说，它们将代表一个矩阵（`u_matrix`）、一个位置（`a_position`）和一个颜色（`u_Color`）。我们很快将在我们的着色器代码中看到这些变量实际的GLSL类型。
- en: After the strings, we declare three `int` types. These three public static (but
    not final) members will be used to store the location of there namesake types
    within our shaders. This allows us to manipulate the values within the shader
    program before we give OpenGL the final instruction to draw our primitives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串之后，我们声明了三个`int`类型。这三个公共静态（但不是最终的）成员将用于存储我们着色器中同名类型的位置。这使得我们可以在给OpenGL最终的绘图指令之前，在着色器程序中操作这些值。
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At last, we come to our GLSL code that is a vertex shader packed up in a string.
    Note that we declare a variable called `u_Matrix` of type uniform `mat4` and `a_Position`
    of type attribute `vec4`. We will see in our `GameObject` class later how to get
    the locations of these variables to enable us to pass in values for them from
    our Java code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了打包在字符串中的顶点着色器GLSL代码。注意，我们声明了一个名为`u_Matrix`的统一变量，类型为`mat4`，以及一个类型为属性`vec4`的`a_Position`。稍后在我们`GameObject`类中，我们将看到如何获取这些变量的位置，以便我们可以从Java代码中为它们传递值。
- en: 'The line in the code that starts with `void main()` is were the actual shader
    code executes from. Note that `gl_position` is assigned the value of the product
    of the two variables we just declared. Also `gl_PointSize` is assigned the value
    of `3.0`. This will be the size we draw all our point primitives. Enter the code
    for the vertex shader right after the previous block of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以`void main()`开始的代码行是实际着色器代码执行的地方。注意`gl_position`被分配了我们刚才声明的两个变量的乘积值。同时`gl_PointSize`被分配了`3.0`的值。这将是我们绘制所有点图元的大小。在之前的代码块之后，输入顶点着色器的代码：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will implement the fragment shader. A few things are happening here.
    First, the line precision `mediump` float tells OpenGL to draw with medium precision
    and therefore medium speed. Then we can see our variable `u_Color` being declared
    to type uniform `vec4`. We will see how we can pass a `color` value to this variable
    in the `GameObject` class soon.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现片元着色器。这里发生了一些事情。首先，以`precision mediump float`开头的行告诉OpenGL以中等精度（因此也是中等速度）进行绘制。然后我们可以看到我们的变量`u_Color`被声明为统一类型`vec4`。我们很快会在`GameObject`类中看到如何将`color`值传递给这个变量。
- en: When execution begins at `void main()`, we simply assign `u_Color` to `gl_FragColor`.
    So, whatever color is assigned to `u_Colour`, all the fragments will be that color.
    Just after the fragment shader, we declare an `int` called `program` that will
    act as a handle to our GL program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`void main()`开始执行时，我们只需将`u_Color`分配给`gl_FragColor`。因此，无论分配给`u_Color`什么颜色，所有片段都将具有那个颜色。在片元着色器之后，我们声明了一个名为`program`的`int`，它将作为我们GL程序的句柄。
- en: 'Enter the code for the fragment shader right after the previous block of code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块之后，输入片元着色器的代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a getter method that returns a handle to the GL program:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取器方法，它返回GL程序的句柄：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This next method may look complex, but all it does is return a compiled and
    linked program to the caller. It does so by calling the OpenGL's `linkProgram`
    method with `compileVertexShader()` and `compileFragmentShader()` as arguments.
    Next, we see these two new methods and that all they need to do is call our method
    `compileShader()` with the OpenGL constant representing the type of shader and
    the appropriate string that holds the matching shader GLSL code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法可能看起来复杂，但它所做的只是将一个编译并链接的程序返回给调用者。它通过使用`compileVertexShader()`和`compileFragmentShader()`作为参数调用OpenGL的`linkProgram`方法来实现。接下来，我们看到这两个新方法，它们只需要使用代表着色器类型的OpenGL常量以及包含匹配着色器GLSL代码的适当字符串来调用我们的方法`compileShader()`。
- en: 'Enter the three methods that we have just discussed into the `GLManager` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们刚刚讨论的三个方法输入到`GLManager`类中：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we see what happens when our methods called `compileShader()`. First, we
    create a handle to a shader based on the `type` parameter. Then, we pass in that
    handle and the code to `glShaderSource()`. Finally, we compile the shader with
    `glCompileShader()` and return a handle to the calling method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解当调用方法`compileShader()`时会发生什么。首先，我们会根据`type`参数创建一个着色器的句柄。然后，我们将该句柄和代码传递给`glShaderSource()`。最后，我们使用`glCompileShader()`编译着色器，并将句柄返回给调用方法：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can see the final step in the process. We create an empty program with
    `glCreateProgram()`. Then we attach each of the compiled shaders in turn with
    `glAttachShader()`, and finally link them into a program we can actually use with
    `glLinkProgram()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到这个过程最后一步。我们使用`glCreateProgram()`创建一个空程序。然后依次使用`glAttachShader()`附加每个编译后的着色器，并最终使用`glLinkProgram()`将它们链接成一个我们可以实际使用的程序：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we created a program and we have access to it via its handle and the
    `getProgram` method. We also have access to all those public static members we
    created, so we will be able to tinker with the variables in the shader programs
    from our Java code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们创建了一个程序，并且可以通过其句柄和`getProgram`方法访问它。我们还可以访问我们创建的所有那些公共静态成员，因此我们将能够从Java代码中调整着色器程序中的变量。
- en: The game's main loop – the renderer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的主循环——渲染器
- en: 'Now we will see where the real meat of our code will go. Create a new class
    and call it `AsteroidsRenderer`. This is the class that we attached as our renderer
    to the `GLSurfaceView`. Add the import statements as follows, noting that some
    of them are static:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到代码的核心部分将如何进行。创建一个名为`AsteroidsRenderer`的新类。这是我们附加到`GLSurfaceView`的渲染器类。按照如下方式添加导入语句，注意其中有一些是静态的：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we will build the class. The first thing to note that we have mentioned
    before is that the class implements `Renderer`, so we need to override three methods.
    They are `onSurfaceCreated()`, `onSurfaceChanged()`, and `onDrawFrame()`. Also,
    into this class, we will initially add a constructor to get everything set up,
    a `createObjects` method where we will eventually initialize all our game objects,
    an `update` method were we will update all our objects each frame, and a `draw`
    method were we will draw all our objects each frame.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建这个类。首先要注意的是，我们之前提到过这个类实现了`Renderer`，因此我们需要重写三个方法。它们是`onSurfaceCreated()`、`onSurfaceChanged()`和`onDrawFrame()`。此外，我们将在该类中最初添加一个构造函数来设置一切，一个`createObjects`方法，我们最终将在其中初始化所有游戏对象，一个`update`方法，我们将在其中每帧更新所有对象，以及一个`draw`方法，我们将在其中每帧绘制所有对象。
- en: We will explore and explain each method as we implement it, and we will also
    see how our methods fit in to the OpenGL renderer system, which dictates the flow
    of this class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实现每个方法时探讨和解释它，我们还将看到我们的方法如何融入到OpenGL渲染器系统中，该系统决定了这个类的流程。
- en: To get started, we have some member variables that are worth looking at quite
    closely.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一些成员变量值得我们仔细查看。
- en: The Boolean debugging will be used to toggle output to the console on and off.
    The `frameCounter`, `averageFPS`, and `fps` variables will not only be used for
    checking what frame rates we are reaching but also for passing to our game objects
    that will update themselves based on the elapsed time each frame.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值`debugging`将被用来切换控制台输出的开启和关闭。`frameCounter`、`averageFPS`和`fps`变量不仅将被用来检查我们达到的帧率，而且还将被用来传递给我们的游戏对象，这些对象将根据每帧的流逝时间更新自己。
- en: Our first really interesting variable is the float array `viewportMatrix`. As
    the name suggests, it will hold a matrix that OpenGL can use to calculate the
    viewport into our game world.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个真正有趣的变量是浮点数数组`viewportMatrix`。顾名思义，它将保存一个OpenGL可以用来计算到我们游戏世界的视口的矩阵。
- en: We have a `GameManager` to hold a reference to the `GameManager` object, that
    `AsteroidsView` passed into this class's constructor. Finally, we have two `PointF`
    objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`GameManager`来保存对`GameManager`对象的引用，这是`AsteroidsView`在传递到这个类的构造函数中。最后，我们有两个`PointF`对象。
- en: We will initialize the `PointF` objects in the constructor and use them for
    a few different things to avoid dereferencing any objects in the main game loop.
    When the garbage collector starts cleaning up discarded objects, even OpenGL will
    slow down. Avoiding summoning the garbage collector will be a goal for the entire
    game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构造函数中初始化`PointF`对象，并将它们用于一些不同的事情，以避免在主游戏循环中取消引用任何对象。当垃圾收集器开始清理丢弃的对象时，即使是OpenGL也会减慢速度。避免召唤垃圾收集器将是整个游戏的目标。
- en: 'Enter the member variables at the top of the `AsteroidsRenderer` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`类的顶部输入成员变量：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is our constructor, where we initialize our `GameManager` reference from
    the parameter and create our two handy `PointF` objects ready for use:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的构造函数，我们从参数初始化`GameManager`引用，并创建两个方便的`PointF`对象以备使用：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the first overridden method. It is called every time a `GLSurfaceView`
    class with attached renderer is created. We call `glClearColor()` to set which
    color OpenGL will use each time it clears the screen. We then build our shader
    program using our `GLManager.buildProgram()` method and call our `createObjects`
    method that we will code soon.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个重写的方法。每次创建带有附加渲染器的`GLSurfaceView`类时都会调用它。我们调用`glClearColor()`来设置每次OpenGL清除屏幕时使用的颜色。然后我们使用`GLManager.buildProgram()`方法构建我们的着色器程序，并调用我们将很快编写的`createObjects`方法。
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This next overridden method is called once after `onSurfaceCreated()` and any
    time the screen orientation changes. Here, we call the `glViewport()` method to
    tell OpenGL the pixel coordinates to map the OpenGL coordinate system onto.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重写的方法在`onSurfaceCreated()`之后调用一次，并且在屏幕方向改变时调用。在这里，我们调用`glViewport()`方法，告诉OpenGL将OpenGL坐标系统映射到哪个像素坐标上。
- en: The OpenGL coordinate system is very different from the pixel coordinates we
    are used to deal with in the previous two projects. The center of the screen is
    0,0, the left and bottom are -1, and the top and right are 1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL坐标系统与我们之前在两个项目中习惯处理的像素坐标有很大不同。屏幕的中心是0,0，左下角是-1，右上角是1。
- en: '![The game''s main loop – the renderer](img/B04322_09_01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![游戏主循环 - 渲染器](img/B04322_09_01.jpg)'
- en: The preceding situation is further complicated by the fact that most screens
    are not square, yet the range -1 to 1 must represent both *x* and *y* axes. Fortunately,
    our `glViewport()` has dealt with this for us.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的情况由于大多数屏幕不是正方形而进一步复杂化，但-1到1的范围必须同时表示*x*和*y*轴。幸运的是，我们的`glViewport()`已经为我们处理了这个问题。
- en: The last thing we see in this method is calling the `orthoM` method with our
    `viewportMatrix` as the first parameter. OpenGL will now prepare `viewportMatrix`
    for use within OpenGL itself. The method `orthoM()` creates a matrix to convert
    coordinates into an orthographic view. If our coordinates are three-dimensional,
    it will have the effect of making all the objects appear the same distance away.
    As we are making a two-dimensional game, this is also suitable for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中最后我们看到的是调用`orthoM`方法，将我们的`viewportMatrix`作为第一个参数。OpenGL现在将准备使用`viewportMatrix`。`orthoM()`方法创建一个矩阵，将坐标转换为正交视图。如果我们的坐标是三维的，它将使所有物体看起来距离相同。由于我们正在制作一个二维游戏，这也适合我们。
- en: 'Enter the code for the `onSurfaceChanged` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`onSurfaceChanged`方法的代码：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is our `createObjects` method and, as you can see, we create an object
    of type `SpaceShip` and pass in the map height and width to the constructor. We
    will build the `SpaceShip` class and its parent class `GameObject` later in this
    chapter. Enter the `createObjects` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`createObjects`方法，如您所见，我们创建了一个`SpaceShip`类型的对象，并将地图的高度和宽度传递给构造函数。我们将在本章后面构建`SpaceShip`类及其父类`GameObject`。输入`createObjects`方法：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the overridden `onDrawFrame` method. It is called continuously by the
    system. We can control when this is called by setting a render mode when we attach
    the `AsteroidsRenderer` to the view but the default OpenGL controlled continuous
    calling is exactly what we need.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重写的`onDrawFrame`方法。系统会连续调用它。我们可以通过设置渲染模式来控制何时调用它，当我们把`AsteroidsRenderer`附加到视图上，但默认的OpenGL控制连续调用正是我们所需要的。
- en: We set `startFrameTime` to whatever the current system time is. Then, if `isPlaying()`
    returns `true`, we call our soon-to-be-implemented `update` method. Then, we call
    `draw()`, which will tell all of our objects to draw themselves.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`startFrameTime`设置为当前的系统时间。然后，如果`isPlaying()`返回`true`，我们调用即将实现的`update`方法。然后，我们调用`draw()`，这将告诉我们的所有对象绘制自己。
- en: We then update `timeThisFrame` and `fps` optionally outputting the average frames
    per second, every 100 frames, if we are debugging.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新`timeThisFrame`和`fps`，可以选择在每100帧输出一次平均每秒帧数，如果我们正在调试的话。
- en: Now we know that OpenGL will call `onDrawFrame()` up to hundreds of times per
    second. We will conditionally call our `update` method each time as well as call
    our `draw` method. We have effectively implemented our game loop apart from the
    actual `draw` and update methods themselves.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道OpenGL每秒最多可以调用`onDrawFrame()`数百次。我们将条件性地每次调用我们的`update`方法，以及调用我们的`draw`方法。除了实际的`draw`和`update`方法本身，我们已经有效地实现了游戏循环。
- en: 'Add the `onDrawFrame` method to the class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 向类中添加`onDrawFrame`方法：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is our `update` method, leave an empty body for now:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`update`方法，现在先留一个空体：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we come to our `draw` method, which is called once per frame from the `onDrawFrame`
    method. Here, we load up the ships current location into one of our handy `PointF`
    objects. Clearly, as we haven't implemented our `SpaceShip` class yet, this method
    call will produce an error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看`draw`方法，它从`onDrawFrame`方法中每帧调用一次。在这里，我们将飞船的当前位置加载到我们的便捷`PointF`对象之一中。显然，由于我们还没有实现`SpaceShip`类，这个方法调用将产生错误。
- en: The next thing we do in `draw()` is quite interesting. We modify our `viewportMatrix`
    based on the current location in the game world and the values assigned to `metresToShowX`
    and `metresToShowY`. Simply, we are centering on wherever the ship is and extending
    out by half the distance we wish to show in all four directions. Remember that,
    this happens in every frame, so our viewport will constantly follow the player
    ship.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`中我们接下来要做的事情相当有趣。我们根据游戏世界中当前的位置以及分配给`metresToShowX`和`metresToShowY`的值修改我们的`viewportMatrix`。简单来说，我们将视口中心定位在飞船所在的位置，并向四个方向扩展我们希望显示的一半距离。记住，这会在每一帧发生，所以我们的视口将始终跟随玩家飞船。
- en: Next, we call `glClear()` to clear the screen with the color we set in `onSurfaceCreated()`.
    The last thing we do in `draw()` is call a `draw` method on our `SpaceShip` object.
    This implies quite a fundamental design change from both of our previous games.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`glClear()`，用`onSurfaceCreated()`中设置的颜色清除屏幕。在`draw()`中我们做的最后一件事是在我们的`SpaceShip`对象上调用`draw`方法。这意味着这与我们之前的两款游戏有一个非常基本的设计变化。
- en: 'We mentioned this already, but here we can see it in action: each object will
    draw itself. Also, notice that we pass in our newly configured `viewportMatrix`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过这一点，但在这里我们可以看到它的实际应用：每个对象将绘制自己。同时，注意我们传递了新配置的`viewportMatrix`。
- en: 'Enter the code for the `draw` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`draw`方法的代码：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we can build our `GameObject` super class, closely followed by its first
    child, `SpaceShip`. We will see how these objects will manage to use OpenGL to
    draw themselves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的`GameObject`超类，紧接着是它的第一个子类`SpaceShip`。我们将看到这些对象如何设法使用OpenGL来绘制自己。
- en: Building an OpenGL-friendly, GameObject super class
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个对OpenGL友好的`GameObject`超类
- en: Let's dive straight into the code. As we will see, this `GameObject` will have
    a lot in common with the `GameObject` class from the previous project. The most
    significant difference will be that this latest `GameObject` will of course draw
    itself using a handle to the GL program, primitive (vertex) data from a child
    class, and the viewport matrix contained in `viewportMatrix`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入代码。正如我们将看到的，这个`GameObject`将与之前项目中的`GameObject`类有很多共同之处。最显著的区别将在于，这个最新的`GameObject`当然会使用GL程序的句柄、子类中的原始（顶点）数据以及`viewportMatrix`中的视口矩阵来绘制自己。
- en: 'Create a new class, call it `GameObject`, and enter these import statements,
    noting again that that some of them are static:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，将其命名为`GameObject`，并输入这些导入语句，再次注意其中一些是静态的：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are lots of member variables, many are self-explanatory and commented
    just to refresh our memories, but there are some totally new ones as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多成员变量，其中许多是自解释的并已加上注释以刷新我们的记忆，但也有一些全新的变量。
- en: For example, we have an `enum` to represent each type of `GameObject` we will
    create. The reason for this is we will draw some objects as points, some as lines,
    and one as a triangle. The way that we use OpenGL is consistent between different
    types of primitive; hence, it is why we have bundled the code into this parent
    class. However, the final call to draw the primitive varies dependent on the type
    of primitive. We can use the `type` variable in a `switch` statement to execute
    the correct type of a `draw` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个`enum`来表示我们将要创建的每种类型的`GameObject`。这样做的原因是，我们将某些对象绘制为点，一些绘制为线，一个绘制为三角形。我们使用OpenGL的方式在不同类型的图元之间是一致的；因此，我们将代码捆绑到这个父类中。然而，最终绘制图元的调用取决于图元的类型。我们可以使用`type`变量在`switch`语句中执行正确的`draw`方法。
- en: We also have an `int numElements` and `numVertices` that holds the number of
    points that make up any given `GameObject`. These will be set from the child class
    as we will see soon.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为`int numElements`和`numVertices`的变量，用于记录构成任何给定`GameObject`的点数。我们将在后面的子类中设置这些值。
- en: We have another float array called `modelVertices`, which will hold all the
    vertices that make up a model.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个浮点数数组`modelVertices`，它将存储构成一个模型的全部顶点。
- en: 'Enter the first batch of member variables in the `GameObject` class and take
    a look at the comments to refresh your memory or make clear what the various members
    will eventually be used for:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameObject`类中输入第一组成员变量，并查看注释以刷新您的记忆或明确各种成员最终将用于什么：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we will add another batch of member variables. First, and most notably,
    we have a `FloatBuffer` called `vertices`. As we know, OpenGL executes in native
    code and `FloatBuffers` are how it likes to consume its data. We will see how
    we pack all our vertices into this `FloatBuffer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一组成员变量。首先，最值得注意的是，我们有一个名为`vertices`的`FloatBuffer`。我们知道，OpenGL在本地代码中执行，而`FloatBuffers`是它喜欢消费数据的方式。我们将看到如何将所有顶点打包到这个`FloatBuffer`中。
- en: We will also use all the public static members from our `GLManager` class to
    help us get it right.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`GLManager`类中的所有公共静态成员来帮助我们正确处理。
- en: Probably the second most interesting new member where OpenGL is concerned is
    we have another three float arrays called `modelMatrix`, `viewportModelMatrix`,
    and `rotateViewportModelMatrix`. These will be instrumental in helping OpenGL
    to draw the `GameObject` class exactly as required. We will examine exactly how
    they are initialized and used when we get to the `draw` method of this class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL方面，可能第二个最有趣的新成员是我们还有另外三个浮点数数组，名为`modelMatrix`、`viewportModelMatrix`和`rotateViewportModelMatrix`。这些将帮助OpenGL精确地按照要求绘制`GameObject`类。我们将在到达本类的`draw`方法时详细检查它们是如何初始化和使用的。
- en: 'We also have a bunch of members that hold different angles and rotation rates.
    How we use and update these in order to inform OpenGL of the orientation of our
    objects, we will see soon:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些成员变量，用于保存不同的角度和旋转速率。我们如何使用和更新这些变量，以便通知OpenGL我们对象的方向，我们很快就会看到：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now implement the constructor. First, we check if we have previously compiled
    the shaders, because we only need to do it once. If we haven't, this is what happens
    inside the `if(glProgarm == -1)` block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实现构造函数。首先，我们检查是否之前已经编译过着色器，因为我们只需要做一次。如果我们没有，这就是`if(glProgarm == -1)`块内发生的事情。
- en: We call `setGLProgram()` followed by `glUseProgram()` with `glProgram` as the
    argument. That is all we have to do, `GLManager` does the rest and our OpenGL
    program is ready to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`setGLProgram()`，然后传入`glProgram`参数调用`glUseProgram()`。我们需要做的就这么多，`GLManager`会处理其余的工作，我们的OpenGL程序就可以使用了。
- en: Before we go on, however, we save the locations of our key shader variables
    by calling the respective methods (`glGetUniformLocation()` and `glGetAttrtibuteLocation`)
    to get their locations within our GL program. We will see in the `draw` method
    of this class how we use those locations to manipulate values within the shaders.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续之前，通过调用相应的方法（`glGetUniformLocation()`和`glGetAttrtibuteLocation`）来保存关键着色器变量的位置，这些位置在我们的GL程序中的位置。我们将在本类的`draw`方法中看到如何使用这些位置来操作着色器内的值。
- en: 'Finally, we set `isActive` to `true`. Enter this method into the `GameObject`
    class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`isActive`设置为`true`。将此方法输入到`GameObject`类中：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we have a few getters and setters including `getWorldLocation()`, which
    we called from the `draw` method in `AsteroidsRenderer` and `setGLProgram()`.
    This uses the `GLManager` class's static method `getGLProgram()` to get the handle
    to our GL program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些getters和setters，包括从`AsteroidsRenderer`中的`draw`方法调用的`getWorldLocation()`，以及`setGLProgram()`。这使用`GLManager`类的静态方法`getGLProgram()`来获取我们GL程序的句柄。
- en: 'Enter all these methods into the `GameObject` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameObject`类中输入所有这些方法：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The next method, `setVertices()` is a vital step in preparing an object to be
    drawn by OpenGL. In each of our child classes, we will build an array of float
    types to represent the vertices that make up the shape of the game object. Each
    game object will obviously be different in shape, but the `setVertices` method
    does not need to appreciate the difference, it just needs the data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法`setVertices()`是在准备由OpenGL绘制对象时的关键步骤。在我们的每个子类中，我们将构建一个浮点类型的数组来表示构成游戏对象形状的顶点。每个游戏对象在形状上显然都是不同的，但`setVertices`方法无需关注这些差异，它只需要数据。
- en: As we can see in the next block of code, the method receives a float array as
    a parameter. It then stores the number of elements that is equal to the length
    of the array in `numElements`. Note that the number of elements is different from
    the number of vertices the elements represent. It takes three elements (*x*, *y*,
    and *z*) to make one vertex. Therefore, we can store into `numVertices` the correct
    value by dividing `numElements` by `ELEMENTS_PER_VERTEX`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一个代码块中看到的，该方法接收一个浮点数组作为参数。然后它将等于数组长度的元素数量存储在`numElements`中。请注意，元素的数量与它们表示的顶点数量不同。需要三个元素（*x*，*y*和*z*）来表示一个顶点。因此，我们可以通过将`numElements`除以`ELEMENTS_PER_VERTEX`来将正确的值存储在`numVertices`中。
- en: Now we can actually initialize up our `ByteBuffer` by calling `allocateDirect()`
    and passing in our newly initialized variables along with `FLOAT_SIZE`. The `ByteOrder.nativeOrder`
    method simply detects if the particular system's endianness, and `asFloatBuffer()`
    tells `ByteBuffer` the type of data that will stored. We can now store our array
    of vertices into our vertices `ByteBuffer` by calling `vertices.put(modelVertices)`.
    This data is now ready to be passed to OpenGL.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`allocateDirect()`并传入我们新初始化的变量以及`FLOAT_SIZE`来实际初始化我们的`ByteBuffer`。`ByteOrder.nativeOrder`方法只是检测特定系统的字节序，而`asFloatBuffer()`告诉`ByteBuffer`将要存储的数据类型。现在，我们可以通过调用`vertices.put(modelVertices)`将顶点数组存储到我们的顶点`ByteBuffer`中。这些数据现在可以传递给OpenGL了。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to learn more about endianness, take a look at this Wikipedia article:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于字节序的信息，请查看这篇维基百科文章：
- en: '[http://en.wikipedia.org/wiki/Endianness](http://en.wikipedia.org/wiki/Endianness)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于字节序的维基百科文章](http://en.wikipedia.org/wiki/Endianness)'
- en: 'Enter the `setVertices` method into the `GameObject` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameObject`类中输入`setVertices`方法：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we get to see how we actually draw the contents of our `ByteBuffer`. At
    a glance, the following code may look complex, but when we discuss the nature
    of the data in our `ByteBuffer` and the steps that OpenGL goes through to draw
    this data, we will see that it is actually quite straightforward.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们是如何实际绘制我们的`ByteBuffer`的内容的。乍一看，以下代码可能看起来很复杂，但当我们讨论`ByteBuffer`中的数据性质以及OpenGL绘制这些数据的步骤时，我们会发现这实际上相当直接。
- en: As we have not written the code for our first `GameObject` child class, there
    is one key thing to point out. The vertices that represent the shape of a game
    object are zero based on its own center.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有编写第一个`GameObject`子类的代码，有一个关键点需要指出。表示游戏对象形状的顶点是基于其自身的中心为零的。
- en: 'The OpenGL coordinate system has **0,0** as its center but, to make it clear,
    this is not related. This is called model space. The next image is a representation
    of our spaceship, in model space, that we will soon create:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL坐标系统的中心是**0,0**，但为了明确起见，这与我们无关，这被称为模型空间。下一张图片展示了我们即将创建的飞船，在模型空间中的表示：
- en: '![Building an OpenGL-friendly, GameObject super class](img/B04322_09_02.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个对OpenGL友好的GameObject超类](img/B04322_09_02.jpg)'
- en: It is this data that is contained within our `ByteBuffer`. This data takes no
    account of orientation (is the ship or asteroid rotated), it takes no account
    of its position in the game world and, as a reminder, it is totally unrelated
    to the OpenGL coordinate system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据包含在我们的`ByteBuffer`中。这些数据不考虑方向（飞船或小行星是否旋转），不考虑在游戏世界中的位置，并且再次提醒，它与OpenGL坐标系统完全无关。
- en: Therefore, before we draw our `ByteBuffer`, we need to convert this data, or,
    more accurately, we need to prepare an appropriate matrix, which we will pass
    into OpenGL with the data so that OpenGL will know how to use or convert the data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们绘制`ByteBuffer`之前，我们需要转换这些数据，或者更准确地说，我们需要准备一个合适的矩阵，并将其与数据一起传递给OpenGL，以便OpenGL知道如何使用或转换数据。
- en: I have split the `draw` method up into six chunks to talk about how we do this.
    Note that our `viewPort` matrix is prepared in our `AsteroidsRenderer` class's
    `draw` method, which is centered upon the location of the ship and based around
    the proportion of game world we want to show and is passed in as a parameter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`draw`方法分成了六个部分来讲解我们是如何做到这一点的。请注意，我们的`viewPort`矩阵在我们的`AsteroidsRenderer`类的`draw`方法中准备，该方法以飞船的位置为中心，基于我们想要显示的游戏世界比例，并作为参数传入。
- en: First, we call `glUseProgram()` and pass in the handle to our program. Then
    we set the internal pointer of our `ByteBuffer` to the start with `vertices.position(0)`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`glUseProgram()`并传入我们程序的句柄。然后我们将`ByteBuffer`的内部指针设置为起始位置，使用`vertices.position(0)`。
- en: 'The `glVertexAttributePointer` method uses our `aPositionLocation` variable
    along with our `GLManager` static constants and of course the `vertices` `ByteBuffer`
    to associate our vertices with the `aPosition` variable in the vertex shader.
    Finally, for this chunk of code, we tell OpenGL to enable the attribute array:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttributePointer`方法使用我们的`aPositionLocation`变量以及我们的`GLManager`静态常量，当然还有`vertices`
    `ByteBuffer`，将我们的顶点与顶点着色器中的`aPosition`变量相关联。最后，对于这段代码，我们告诉OpenGL启用属性数组：'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, we put our matrices to work. We create an identity matrix out of our `modelMatrix`
    array by calling `setIndentityM()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将矩阵投入使用。通过调用`setIndentityM()`，我们从`modelMatrix`数组中创建一个单位矩阵。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we will see, we are going to be using and combining quite a lot of matrices.
    An identity matrix acts as a starting point or container on which we can build
    a matrix, which combines all the transformations that we need to occur. A very
    simple but not entirely accurate way of thinking about an identity matrix is that
    it is like the number 1\. When you multiply by an identity matrix, it doesn't
    cause any alteration to the other part of the sum. However, the answer is correct
    for moving on to the next part of the equation. If this is annoying you and you
    want to know more, take a look at these really quick tutorials on matrices and
    the identity matrix.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，我们将使用和组合相当多的矩阵。单位矩阵作为一个起点或容器，我们可以在其上构建一个矩阵，该矩阵结合了我们需要发生的所有变换。一种非常简单但并不完全准确的方式来考虑单位矩阵是，它就像数字1。当你乘以一个单位矩阵时，它不会对和的其它部分造成任何改变。然而，这个答案对于继续方程的下一部分是正确的。如果这让你感到烦恼，并且你想了解更多，请查看关于矩阵和单位矩阵的以下快速教程。
- en: 'Matrices:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵：
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[矩阵介绍](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
- en: 'Identity matrix:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵：
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[单位矩阵教程](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
- en: 'We then pass our new `modelMatrix` into the `translateM` method. Translate
    is math speak for move. Look closely at the arguments passed into `translateM()`.
    We are passing in the *x* any *y* world locations of the object. This is how OpenGL
    knows where the object is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新的`modelMatrix`传递给`translateM`方法。在数学术语中，translate意为移动。仔细观察传递给`translateM()`的参数。我们正在传递物体的*x*和*y*世界坐标。这就是OpenGL知道物体位置的方式：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We know that OpenGL has a matrix to translate our object to its world location.
    It also has a `ByteBuffer` class with the model space coordinates, but how does
    it convert translated model space coordinates to our viewport drawn using OpenGL
    coordinate system?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道OpenGL有一个矩阵可以将我们的对象转换到它的世界位置。它还有一个`ByteBuffer`类，其中包含模型空间坐标，但它如何将转换后的模型空间坐标转换为使用OpenGL坐标系统绘制的视口呢？
- en: 'It uses the viewport matrix, which is modified by each frame and passed into
    this method. All we need to do is multiply `viewportMatrix` and the recently translated
    `modelMatrix` together using `multiplyMM()`. This method creates the combined
    or multiplied matrix and stores the result in `viewportModelMatrix`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了视口矩阵，该矩阵每帧都会被修改并传入这个方法。我们需要做的就是使用`multiplyMM()`将`viewportMatrix`和最近转换的`modelMatrix`相乘。这个方法创建了组合或乘积矩阵，并将结果存储在`viewportModelMatrix`中：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are almost done creating our matrix. The only other possible distortion that
    OpenGL will need to make to the vertices in the `ByteBuffer` is to rotate them
    to the `facingAngle` parameter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了矩阵的创建。OpenGL需要对`ByteBuffer`中的顶点进行的唯一其他可能的扭曲就是根据`facingAngle`参数旋转它们。
- en: Next, we create a rotation matrix appropriate to the current object's facing
    angle and storing the result back in `modelMatrix`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个适合当前物体面向角度的旋转矩阵，并将结果重新存储在`modelMatrix`中。
- en: 'Then, we combine or multiply the newly rotated `modelMatrix` with our `viewportModelMatrix`
    and store the result in `rotateViewportModelMatrix`. This is our final matrix
    that we will pass into the OpenGL system:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新旋转的`modelMatrix`与我们的`viewportModelMatrix`组合或相乘，并将结果存储在`rotateViewportModelMatrix`中。这是我们最终要传入OpenGL系统的矩阵：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we pass in the matrix using the `glUniformMatrix4fv()` method and use the
    `uMatrixLocation` variable (which is the location of the matrix-related variable
    in the vertex shader) and our final matrix in the arguments.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`glUniformMatrix4fv()`方法传入矩阵，并在参数中使用`uMatrixLocation`变量（这是顶点着色器中与矩阵相关的变量的位置）和我们最终的矩阵。
- en: We also choose the color by calling `glUniform4f()` with the `uColorLocation`
    and an RGBT (Red, Green, Blue, Transparency) value. All values are set to 1.0,
    so the fragment shader will draw white.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过调用`glUniform4f()`并使用`uColorLocation`和一个RGBT（红、绿、蓝、透明度）值来选择颜色。所有值都设置为1.0，因此片段着色器将绘制白色。
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we switch based on the object type and draw either points, lines,
    or triangle primitives:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据对象类型进行切换，并绘制点、线或三角形图元：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we have the fundamentals of our `GameObject` class, we can make a class
    to represent our spaceship and draw it to the screen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了`GameObject`类的基础知识，我们可以创建一个类来表示我们的飞船并在屏幕上绘制它。
- en: The spaceship
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞船
- en: This class is nice and simple, although it will evolve with the project. The
    constructor receives the starting location within the game world. We set the ship's
    type and world location using the methods from the `GameObject` class, and we
    set a width and height.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，尽管它会随着项目的发展而演变。构造函数接收游戏世界中起点的位置。我们使用`GameObject`类的方法设置飞船的类型和世界位置，并设置宽度和高度。
- en: We declare and initialize some variables to simplify the initialization of the
    model space coordinates, and then we go ahead and initialize a float array with
    three vertices that represent the triangle that is our ship. Note that the values
    are based around a center of *x = 0* and *y = 0*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化一些变量，以简化模型空间坐标的初始化，然后继续初始化一个浮点数组，其中包含三个顶点，这些顶点表示我们的飞船的三角形。请注意，这些值是基于*x
    = 0*和*y = 0*中心的。
- en: 'All we do next is, call `setVertices()`, and `GameObject` will prepare the
    `ByteBuffer` ready for OpenGL:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需调用`setVertices()`，`GameObject`就会准备好`ByteBuffer`供OpenGL使用：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At last, we can see the fruits of our labor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到我们努力的成果。
- en: Drawing at 60 + FPS
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以60 + FPS的速度绘制
- en: 'In three simple steps, we will be able to glimpse our spaceship:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过三个简单的步骤，我们将能够看到我们的飞船：
- en: 'Add a `SpaceShip` object to the `GameManager` member variables:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GameManager`成员变量中添加一个`SpaceShip`对象：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a call to the new `SpaceShip()` to the `createObjects` method:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`createObjects`方法中添加对新的`SpaceShip()`的调用：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the call to draw the spaceship in each frame in the `draw` method of `AsteroidsRenderer`:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`draw`方法中，添加每一帧绘制飞船的调用：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the game and see the output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并查看输出：
- en: '![Drawing at 60 + FPS](img/B04322_09_03.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![以60 + FPS的速度绘制](img/B04322_09_03.jpg)'
- en: Not exactly impressive visuals, but it is running between 67 and 212 frames
    per second in debug mode while outputting to the console on an ageing Samsung
    Galaxy S2 phone.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果并不令人印象深刻，但在调试模式下，在老旧的三星Galaxy S2手机上输出到控制台时，它的运行帧数在67到212之间。
- en: '![Drawing at 60 + FPS](img/B04322_09_04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![以60 + FPS的速度绘制](img/B04322_09_04.jpg)'
- en: It will be our aim throughout the project to add hundreds of objects and keep
    the frames per second over 60.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，我们的目标是在保持每秒60帧以上的情况下添加数百个对象。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One of the book's reviewers reported frame rates in excess of 1000 per second
    on a Nexus 5! It will therefore be worth considering a maximum frame rate locking
    strategy to save battery life if you were planning to release this to the Google
    Play store.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一位书籍评论者在 Nexus 5 上报告了每秒超过 1000 帧的速率！因此，如果你打算将此应用发布到 Google Play 商店，考虑采用最大帧率锁定策略以节省电池寿命将是非常值得的。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Setting up a drawing system was a little bit long-winded. However, now that
    it is done, we can churn out new objects much more easily. All we have to do is
    define the type and the vertices, then we can draw them with ease.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 设置绘图系统可能有些繁琐。然而，现在它已经完成，我们可以更轻松地快速生成新对象。我们只需定义类型和顶点，然后就可以轻松地绘制它们。
- en: It is because of this ground work that the next chapter will be much more visually
    rewarding. Next, we will create blinking stars, a game world border, spinning
    and moving asteroids, whizzing bullets, and a HUD, as well as add full controls
    and motion to the spaceship.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为有了这些基础工作，下一章内容将更加视觉上令人满意。接下来，我们将创建闪烁的星星、游戏世界的边界、旋转移动的小行星、呼啸而过的子弹、以及一个 HUD（平视显示器），同时为太空飞船添加完整的控制和动作。
