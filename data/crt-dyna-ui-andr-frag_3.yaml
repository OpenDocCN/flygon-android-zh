- en: Chapter 3. Fragment Lifecycle and Specialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 片段生命周期与专业化
- en: This chapter discusses the relationship of the lifecycle of fragments to that
    of activities, and demonstrates the appropriate programming actions at the various
    points in the lifecycle. The special purpose fragment classes `ListFragment` and
    `DialogFragment` are introduced with coverage of their use and how their behavior
    in the activity lifecycle differs from that of standard fragments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了片段的生命周期与活动生命周期的关系，并在生命周期的各个阶段演示了适当的编程操作。引入了特殊用途的片段类`ListFragment`和`DialogFragment`，涵盖了它们的使用以及它们在活动生命周期中的行为与标准片段的不同之处。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了以下主题：
- en: Fragment setup/display event sequence
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段设置/显示事件序列
- en: Fragment teardown/hide event sequence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段拆卸/隐藏事件序列
- en: Working with the `ListFragment` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListFragment`类
- en: Working with the `DialogFragment` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DialogFragment`类
- en: Interacting with a `DialogFragment` class as a traditional `Dialog` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为传统的`Dialog`类与`DialogFragment`类交互
- en: Wrapping an existing `Dialog` class in a `DialogFragment` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的`Dialog`类包装在`DialogFragment`类中
- en: By the end of this chapter, we will be able to coordinate the setup and teardown
    of fragments within their host activities, and be able to effectively utilize
    the `ListFragment` and `DialogFragment` classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章末，我们将能够协调片段在它们宿主活动中的设置和拆卸，并能够有效地利用`ListFragment`和`DialogFragment`类。
- en: Understanding the fragment lifecycle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解片段生命周期
- en: One of the challenges of developing Android applications is assuring that our
    applications effectively handle the lifecycle of the application's activities.
    During the lifetime of an application, a given activity may be created, destroyed,
    and recreated many times. A simple action such as a user rotating a device from
    a portrait to landscape orientation, or vice-versa, normally causes the visible
    activity to be completely destroyed and recreated using the appropriate resources
    for the new orientation. Applications that do not cooperate effectively with this
    natural lifecycle will often crash or behave in some other undesirable manner.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Android应用程序的挑战之一是确保我们的应用程序能够有效地处理应用程序活动的生命周期。在应用程序的生命周期中，一个给定的活动可能会被创建、销毁和重新创建多次。例如，用户将设备从纵向旋转到横向，或者相反，通常会导致可见活动完全销毁并使用适合新方向资源的活动重新创建。那些不能与这一自然生命周期有效协作的应用程序经常会崩溃或表现出其他不良行为。
- en: As we know, each fragment instance exists within a single activity; therefore,
    that fragment must cooperate in some way with the activity lifecycle. In fact,
    not only do fragments cooperate with the activity lifecycle but also they are
    intimately connected.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，每个片段实例只存在于单一活动中；因此，该片段必须以某种方式与活动生命周期协作。实际上，片段不仅与活动生命周期协作，而且与之紧密相连。
- en: In both the setup and display phase and hide and teardown phase, fragments provide
    many of the same lifecycle-related callback methods as activities. In addition,
    fragments provide additional lifecycle-related callback methods that relate to
    the fragment's relationship to the containing activity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置和显示阶段以及隐藏和拆卸阶段，片段提供了与活动许多相同的与生命周期相关的回调方法。此外，片段还提供了与包含活动的片段关系相关的其他生命周期相关的回调方法。
- en: As our applications become more sophisticated and we work with more specialized
    implementations of the fragment class, understanding the fragment class' lifecycle
    and the relationship to the activity lifecycle is essential.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得更加复杂，我们使用更多专业化的片段类实现，理解片段类的生命周期及其与活动生命周期的关系是至关重要的。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with the basics of Android's activity lifecycle callback
    methods, please see the *Activity Lifecycle* section of the *Android Activity*
    documentation at [http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle](http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Android活动生命周期回调方法的基础知识不熟悉，请参阅*Android Activity*文档中的*Activity Lifecycle*部分，链接为：[http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle](http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle)。
- en: Understanding fragment setup and display
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解片段的设置和显示
- en: Fragment setup and display is a multiphase process involving the fragment's
    association with an activity, the fragments' creation, and the standard lifecycle
    events of moving the activity into the running state (also known as the resumed
    or active state). Understanding the behavior of the lifecycle events and the associated
    callback methods is essential for using fragments effectively. Once we have an
    understanding of the lifecycle events and the callback methods, we'll look at
    just how the event callback methods are used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 片段的设置和显示是一个多阶段的过程，涉及片段与活动的关联、片段的创建以及将活动移动到运行状态（也称为恢复或活动状态）的标准生命周期事件。理解生命周期事件的行为和相关回调方法对于有效使用片段至关重要。一旦我们了解了生命周期事件和回调方法，我们就会研究事件回调方法是如何被使用的。
- en: 'The following diagram shows the sequence of lifecycle-related callback method
    calls that occur on fragments and activities during setup and display:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在设置和显示期间，片段和活动上发生的生命周期相关回调方法的调用顺序：
- en: '![Understanding fragment setup and display](img/3095OS_03_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![理解片段设置和显示](img/3095OS_03_01.jpg)'
- en: As you might expect, in most cases, the first step in the setup and display
    of a fragment occurs in the activity's `onCreate` method. In most cases, the activity
    calls the `setContentView` method from within the activity's `onCreate` callback
    method, which then loads the layout resource and triggers the activity's association
    with the contained fragments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，在大多数情况下，片段的设置和显示第一步发生在活动的`onCreate`方法中。在大多数情况下，活动在其`onCreate`回调方法中调用`setContentView`方法，这会加载布局资源并触发活动与包含片段的关联。
- en: Notice what happens next. Before the fragment is ever created, the fragment
    is attached to the activity. The fragment is first notified of the attachment
    and receives a reference to the activity through the `onAttach` callback method.
    The activity is then notified and receives a reference to the fragment through
    the `onAttachFragment` callback method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意接下来发生的事情。在片段被创建之前，该片段就已经与活动关联。首先，片段会通过`onAttach`回调方法得知这一关联，并获得对活动的引用。然后活动得到通知，并通过`onAttachFragment`回调方法获得对片段的引用。
- en: Although attaching the fragment to the activity prior to creating the fragment
    may seem unexpected, doing so is useful. In many cases, the fragment needs access
    to the activity during the creation process, because the activity often contains
    information that the fragment will display or that is otherwise important to the
    fragment creation process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在创建片段之前将片段与活动关联可能看起来有些意外，但这样做是有用的。在许多情况下，片段在创建过程中需要访问活动，因为活动通常包含片段将显示或对片段创建过程重要的信息。
- en: With the fragment attached to the activity, the fragment then performs general
    creation work in the `onCreate` method and then constructs the contained view
    hierarchy in the `onCreateView` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 片段与活动关联后，片段在`onCreate`方法中进行一般的创建工作，然后在`onCreateView`方法中构建包含的视图层次结构。
- en: 'When an activity contains multiple fragments, Android calls the four methods:
    `Fragment.onAttach`, `Activity.onAttachFragment`, `Fragment.onCreate`, and `Fragment.onCreateView`
    in succession for one fragment before making any calls to these methods for the
    next fragment. This allows each fragment to complete the process of attachment
    and creation before the next fragment begins that process.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个活动包含多个片段时，Android会为一个片段连续调用四个方法：`Fragment.onAttach`、`Activity.onAttachFragment`、`Fragment.onCreate`和`Fragment.onCreateView`，然后再对下一个片段调用这些方法。这使得每个片段在下一个片段开始该过程之前，可以完成关联和创建的过程。
- en: Once the sequence of calling these four methods completes for all the fragments,
    the remaining setup and display callback methods are called individually in succession
    for each fragment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这四个方法的一系列操作完成所有片段后，其余的设置和显示回调方法会依次为每个片段单独调用。
- en: After the activity completes execution of its `onCreate` method, Android then
    calls each fragment's `onActivityCreated` method. The `onActivityCreated` method
    indicates that all views and fragments created by the activity's layout resource
    are now fully constructed and can be safely accessed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 活动执行完其`onCreate`方法后，Android会调用每个片段的`onActivityCreated`方法。`onActivityCreated`方法表明，由活动布局资源创建的所有视图和片段现在已完全构建，可以安全访问。
- en: At this point, the fragment receives the standard lifecycle callbacks on the
    `onStart` and `onResume` methods, just after the activity methods of the same
    name are each called. Any work performed in the fragment's `onStart` and `onResume`
    methods is very much like the work performed in the corresponding methods within
    an activity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，片段在活动的同名方法各自被调用之后，紧接着会收到标准的生命周期回调，即`onStart`和`onResume`方法。在片段的`onStart`和`onResume`方法中执行的工作与在活动内对应方法中执行的工作非常相似。
- en: For many fragments, the only methods in this part of their lifecycle that are
    overridden are the `onCreate` and `onCreateView` methods, as we saw in the examples
    in the previous chapters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多片段来说，它们生命周期这部分唯一被重写的方法是`onCreate`和`onCreateView`方法，正如我们在前面章节的例子中所看到的那样。
- en: Avoiding method name confusion
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免方法名称混淆
- en: The activity and fragment classes have a number of commonly named callback methods,
    and most of these commonly named methods have a common purpose. One important
    exception is the `onCreateView` method. The purpose of this method is very different
    for each class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和片段类有许多名称常见的方法回调，这些常见名称的方法大多数具有共同的目的。一个重要的例外是`onCreateView`方法。这个方法对于每个类的目的都大不相同。
- en: As mentioned previously, Android calls the `Fragment` class' `onCreateView`
    method to give the fragment an opportunity to create and return the fragment's
    contained view hierarchy. This method is commonly overridden within a fragment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Android调用`Fragment`类的`onCreateView`方法，让片段有机会创建并返回其包含的视图层次结构。这个方法通常在片段内部被重写。
- en: The method of the same name in the `Activity` class is called repeatedly by
    the `LayoutInflater` class during the process of inflating a layout resource.
    Most activity implementations do not override this method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Activity`类中同名的方法在膨胀布局资源的过程中会被`LayoutInflater`类多次调用。大多数活动实现并不重写这个方法。
- en: Understanding fragment hide and teardown
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解片段的隐藏和销毁
- en: 'Just as fragments behave in a similar way to activities during setup and display,
    they also behave in a similar way during hide and teardown, as shown in the following
    diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如片段在设置和显示阶段与活动表现相似一样，在隐藏和销毁阶段，它们的行为也类似，如下图所示：
- en: '![Understanding fragment hide and teardown](img/3095OS_03_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![理解片段的隐藏和销毁](img/3095OS_03_02.jpg)'
- en: Initially during hide and teardown, fragments behave just as activities. When
    the user switches to another activity, each fragment's `onPause`, `onSaveInstanceState`,
    and `onStop` methods are called. For each method, the fragment implementation
    is called first, followed by the activity implementation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐藏和销毁的初期，片段的行为与活动类似。当用户切换到另一个活动时，每个片段的`onPause`、`onSaveInstanceState`和`onStop`方法会被调用。对于每个方法，首先调用片段的实现，然后调用活动的实现。
- en: After the `onStop` method is called, fragments begin to behave a little differently
    than activities. Consistent with the separation of fragment creation from fragment
    view hierarchy creation, fragment view hierarchy destruction is separate from
    fragment destruction. Following the call to the activity's `onStop` method, the
    fragment's `onDestroyView` method is called indicating that the view hierarchy
    returned by the fragment's `onCreateView` method is being destroyed. The fragment's
    `onDestroy` method is then called followed by the fragment's `onDetach` method.
    At this point, the fragment has no association with an activity and any calls
    to the `getActivity` method will return null.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`onStop`方法之后，片段的行为开始与活动略有不同。与将片段创建与片段视图层次创建分离一致，片段视图层次的销毁也是与片段销毁分离的。在调用活动的`onStop`方法之后，会调用片段的`onDestroyView`方法，表示由片段的`onCreateView`方法返回的视图层次正在被销毁。然后调用片段的`onDestroy`方法，接着是片段的`onDetach`方法。此时，片段与活动没有任何关联，任何对`getActivity`方法的调用都将返回null。
- en: For activities containing multiple fragments, Android calls the sequence of
    the three methods, `onDestroyView`, `onDestroy`, and `onDetach`, for an individual
    fragment, before beginning the sequence of calling these three methods for the
    next fragment. This groups the process of destroying and detaching each fragment
    similar to the way Android groups the process of attaching and creating each fragment.
    Once this sequence completes for all fragments, Android then calls the activity's
    `onDestroy` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含多个片段的活动，在开始调用下一个片段的三个方法序列之前，Android会为一个单独的片段调用`onDestroyView`、`onDestroy`和`onDetach`这三个方法的序列。这类似于Android将附加和创建每个片段的过程分组在一起的方式，对销毁和分离每个片段的过程进行分组。当所有片段的这个序列完成后，Android然后调用活动的`onDestroy`方法。
- en: Maximizing available resources
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大化可用资源
- en: 'For the most part, lifecycle management for a fragment is very much like that
    of an activity. There is, however, one important exception: the two-phase nature
    of fragment creation and destruction. Fragments separate the creation and destruction
    of the fragment from the fragment''s contained view hierarchy. This is because
    fragments have the ability to exist and be associated with an activity in the
    absence of the fragment''s view hierarchy.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，片段的生命周期管理与活动非常相似。然而，有一个重要的例外：片段创建和销毁的两阶段性质。片段将片段的创建和销毁与其包含的视图层次结构分离。这是因为片段有能力在不存在片段视图层次结构的情况下与活动存在并关联。
- en: There are many scenarios where an activity may contain multiple fragments, but
    have only a subset of those fragments visible at any point in time. In such a
    case, the contained fragments can all have their `onAttach` and `onCreate` methods
    called. But the call to each fragment's `onCreateView` method is delayed until
    the time comes for the app to make the contents of that fragment visible. Similarly,
    when the time comes to hide the contents of a fragment, only the fragment's `onDestroyView`
    method is called, not the `onDestroy` and `onDetach` methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，活动可能包含多个片段，但在任何时刻只显示这些片段的一个子集。在这种情况下，包含的片段都可以调用其`onAttach`和`onCreate`方法。但是，直到应用程序需要使该片段的内容可见时，才会调用每个片段的`onCreateView`方法。同样，当需要隐藏片段内容时，只调用片段的`onDestroyView`方法，而不是`onDestroy`和`onDetach`方法。
- en: This behavior comes into play when fragments are dynamically managed within
    an activity. This behavior allows the overhead of associating a fragment with
    an activity and initializing the fragment's state to occur only once while being
    able to easily change the visibility of the fragment's view hierarchy. This is
    important when we explicitly manage the visibility of fragments using the `FragmentTransaction`
    class, and in certain action bar features that manage fragments. We'll talk about
    these issues in the next two chapters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当在活动中动态管理片段时，这种行为便发挥作用。这种行为允许将片段与活动关联的开销以及初始化片段状态的过程只发生一次，同时能够轻松地改变片段视图层次结构的可见性。当我们使用`FragmentTransaction`类明确管理片段的可见性，以及在某些管理片段的操作栏特性中，这一点非常重要。我们将在接下来的两章中讨论这些问题。
- en: Managing a fragment state
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理片段状态
- en: For many fragment implementations, the most important callback method in the
    lifecycle sequence is the `onSaveInstanceState` method. Just as with an activity,
    this callback method provides the fragment with an opportunity to persist any
    state before the fragment is destroyed, such as when the user moves to another
    activity or when the user rotates the device to a different orientation. In both
    of these cases, the activity and contained fragments may be completely torn down
    and recreated. By persisting the fragment state in the `onSaveInstanceState` method,
    that state is latter passed back to the fragment in both the `onCreate` and `onCreateView`
    methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多片段实现来说，生命周期序列中最重要的回调方法是`onSaveInstanceState`。与活动一样，这个回调方法为片段在销毁之前提供了持久化任何状态的机会，例如当用户移动到另一个活动或当用户将设备旋转到不同的方向时。在这两种情况下，活动和包含的片段可能会被完全拆除并重新创建。通过在`onSaveInstanceState`方法中持久化片段状态，该状态后来会在`onCreate`和`onCreateView`方法中传递回片段。
- en: When managing the state of a fragment, you want to be sure to separate work
    that is general to the fragment's overall existence from work specific to setting
    up the view hierarchy. Any expensive initialization work that's general to the
    fragment's existence such as connecting to a data source, complex calculations,
    or resource allocations should occur in the `onCreate` method rather than the
    `onCreateView` method. This way, if only the fragment's view hierarchy is destroyed
    and the fragment remains intact, you avoid unnecessarily repeating expensive initialization
    work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理片段的状态时，你需要确保将那些与片段整体存在相关的通用工作与特定于设置视图层次结构的工作分开。任何与片段存在相关的昂贵初始化工作，如连接数据源、复杂计算或资源分配，都应该在`onCreate`方法中而不是`onCreateView`方法中进行。这样，如果只是片段的视图层次结构被销毁而片段本身保持完整，你就可以避免不必要地重复昂贵的初始化工作。
- en: Special purpose fragment classes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定目的片段类
- en: Now that we understand the lifecycle of fragments, we can look at some of the
    specialized versions of the `Fragment` class. As we go through each of these specialized
    classes, remember they all ultimately inherit from the `Fragment` class and therefore
    experience the same lifecycle behavior. Many of these specialized classes have
    an impact on what operations are safe to perform at the various points in the
    lifecycle, and some of these classes even add their own lifecycle methods. Understanding
    each of these classes and their interaction with the fragment lifecycle is essential
    for using the classes effectively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了片段的生命周期，我们可以看看`Fragment`类的几种特殊版本。在了解这些特殊类时，请记住，它们最终都继承自`Fragment`类，因此具有相同生命周期行为。这些特殊类中的许多都会影响在生命周期的各个阶段可以安全执行的操作，有些类甚至还会添加自己的生命周期方法。为了有效地使用这些类，理解每个类及其与片段生命周期的交互是至关重要的。
- en: ListFragment
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表片段
- en: One of the simplest fragment-derived classes to use and yet one of the most
    helpful is the `ListFragment` class. The `ListFragment` class provides a fragment
    that encapsulates a `ListView` and, as the name implies, is useful for displaying
    lists of data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最有用的片段派生类之一是`ListFragment`类。`ListFragment`类提供了一个封装了`ListView`的片段，顾名思义，它非常适合用于显示数据列表。
- en: Associating data with the list
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据与列表关联
- en: Unlike the base `Fragment` class, we're not required to override the `onCreateView`
    callback method for the `ListFragment` class. The `ListFragment` class provides
    a standard appearance and only requires that we associate some data. The `ListFragment`
    class does all the work of creating the view hierarchy and displaying that data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与基础的`Fragment`类不同，我们不需要为`ListFragment`类重写`onCreateView`回调方法。`ListFragment`类提供了一个标准的外观，并且我们只需要关联一些数据。`ListFragment`类完成了创建视图层次结构并显示数据的所有工作。
- en: We associate data with the `ListFragment` class by calling the `ListFragment`
    class' `setListAdapter` method and passing a reference to an object that implements
    the `ListAdapter` interface. Android provides a number of classes that implement
    this interface such as `ArrayAdapter`, `SimpleAdapter`, and `SimpleCursorAdapter`.
    The specific class you use will depend on how your source data is stored. If none
    of the standard Android classes meet your specific requirements, you can create
    a custom implementation reasonably easy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`ListFragment`类的`setListAdapter`方法并将实现了`ListAdapter`接口的对象引用传递给该方法，来与`ListFragment`类关联数据。Android
    提供了许多实现此接口的类，如`ArrayAdapter`、`SimpleAdapter`和`SimpleCursorAdapter`。你使用的具体类将取决于你的源数据存储方式。如果标准的
    Android 类不能满足你的特定需求，你可以相对容易地创建一个自定义实现。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a discussion about creating a custom list adapter, see the Android tutorial
    *Displaying the Quick Contact Badge* at [http://developer.android.com/training/contacts-provider/display-contact-badge.html](http://developer.android.com/training/contacts-provider/display-contact-badge.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论创建自定义列表适配器，请参阅 Android 教程《*显示快速联系人徽章*》在[http://developer.android.com/training/contacts-provider/display-contact-badge.html](http://developer.android.com/training/contacts-provider/display-contact-badge.html)。
- en: The call to `setListAdapter` requires that the view hierarchy for the `ListFragment`
    be completely constructed. As a result, we normally do not call the `setListAdapter`
    method any earlier than the `onActivityCreated` callback method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setListAdapter`要求`ListFragment`的视图层次结构必须完全构建完成。因此，我们通常不会在`onActivityCreated`回调方法之前调用`setListAdapter`方法。
- en: The `ListFragment` class wraps an instance of the `ListView` class, which is
    accessible through the `getListView` method. In most scenarios, we can feel free
    to interact with the contained `ListView` instance directly and take advantage
    of any features offered by the `ListView` class. The one very important exception
    is when we set the `ListAdapter` instance. Both the `ListFragment` and `ListView`
    classes expose a `setListAdapter` method, but we must be sure to use the `ListFragment`
    version of the method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListFragment`类包装了一个`ListView`类的实例，通过`getListView`方法可以访问到它。在大多数情况下，我们可以直接与包含的`ListView`实例交互，并利用`ListView`类提供的任何功能。一个非常重要的例外是在我们设置`ListAdapter`实例时。`ListFragment`和`ListView`类都公开了一个`setListAdapter`方法，但我们必须确保使用`ListFragment`版本的方法。'
- en: The `ListFragment` class relies on certain initialization behaviors that occur
    within the `ListFragment.setListAdapter` method; therefore, the process of calling
    the `setListAdapter` method directly on the contained `ListView` instance bypasses
    this initialization behavior and may cause the application to become unstable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListFragment`类依赖于在`ListFragment.setListAdapter`方法中发生的某些初始化行为；因此，直接在包含的`ListView`实例上调用`setListAdapter`方法会绕过此初始化行为，可能导致应用程序变得不稳定。'
- en: Separating data from display
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据与显示分离
- en: Up until now, our application has used a fixed layout of several `RadioButton`
    views to display the list of books. Using a fixed layout to display such options
    is not generally a good choice, because any changes to the book list require that
    we go in and directly modify the fragment layout. In practice, we would prefer
    to have a layout that is independent of the specific titles. We could write code
    to dynamically generate the `RadioButton` views, but there is an easier way. We
    can instead use the `ListFragment` class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们的应用程序使用一组固定的`RadioButton`视图来显示书籍列表。使用固定布局来显示这类选项通常不是一个好的选择，因为书籍列表的任何更改都需要我们进入并直接修改片段布局。实际上，我们更愿意有一个与特定标题无关的布局。我们可以编写代码动态生成`RadioButton`视图，但有一种更简单的方法。我们可以使用`ListFragment`类。
- en: By switching our application to use the `ListFragment` class, we can simply
    store the list of book titles in an array resource and associate the contents
    of that array resource with the `ListFragment` instance. In the event of adding
    more titles or needing to change one of the titles, we simply modify the array
    resource file. There is no need for us to make any changes to the actual fragment
    layout.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的应用程序切换到使用`ListFragment`类，我们可以简单地将书名列表存储在数组资源中，并将该数组资源的内容与`ListFragment`实例关联。在添加更多标题或需要更改其中一个标题时，我们只需修改数组资源文件。我们没有必要对实际的片段布局进行任何更改。
- en: Our application already has all the book titles stored as individual string
    resources, so we just need to add an array resource for them. We'll add the book
    titles array to the `arrays.xml` resource file within the `values` resource folder
    where we currently have an array resource defined to hold the list of book descriptions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经将所有书名作为单独的字符串资源存储，因此我们只需要为它们添加一个数组资源。我们将在`values`资源文件夹中的`arrays.xml`资源文件中添加书名数组，该文件夹中我们已经有了一个定义用来保存书籍描述列表的数组资源。
- en: 'Within the `resources` root element of the `arrays.xml` resource file, add
    a `string-array` element that includes a `name` attribute with a value of `bookTitles`.
    Within the `string-array` element, add an `item` for each book title that references
    the string resource for each title. We want to be sure that we list the book title
    array entries in the same order as the `bookDescription` array entries because
    we use the array index as the ID value for each book when we notify the activity
    of the user''s book selection. The array resource entries for the book title and
    description arrays appear as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`arrays.xml`资源文件的`resources`根元素中，添加一个带有`name`属性值为`bookTitles`的`string-array`元素。在`string-array`元素内，为每个书名添加一个引用每个标题字符串资源的`item`。我们要确保书籍标题数组条目的列出顺序与`bookDescription`数组条目相同，因为当通知活动用户选择的书籍时，我们使用数组索引作为每本书的ID值。书名和描述数组的数组资源条目如下所示：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the titles stored as an array resource, we can now easily create a `ListFragment`
    derived class to display the book titles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题存储为数组资源后，我们现在可以轻松创建一个`ListFragment`派生类来显示书名。
- en: Creating the ListFragment derived class
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建`ListFragment`派生类
- en: 'The first step is to add a new class to our project. To do this, we''ll create
    a new class named `BookListFragment2` that extends the `ListFragment` class as
    shown in the following code line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为我们的项目添加一个新类。为此，我们将创建一个名为 `BookListFragment2` 的新类，该类继承自 `ListFragment` 类，如下面的代码行所示：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we override the `onActivityCreated` method as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写 `onActivityCreated` 方法，如下所示：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `onActivityCreated` method, we first call the base class implementation
    that is required by all classes that extend `ListFragment`. We then load the `bookTitles`
    array resource and associate it with an instance of the `ArrayAdapter` class named
    `bookTitlesAdapter`. The array adapter takes the context as the first parameter,
    which we get by accessing the activity, and takes the array as the third parameter.
    The second parameter is the ID of the resource to use to lay out each entry in
    the list. This resource can be a custom resource or one of the built-in Android
    resources. In our case, we're using the built-in Android layout resource `android.R.layout.simple_list_item_1`,
    which displays a single string value for each row within the `ListView`. The last
    step is to call the `setListAdapter` method and pass the `bookTitlesAdapter` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onActivityCreated` 方法中，我们首先调用所有扩展 `ListFragment` 的类所需的基类实现。然后加载 `bookTitles`
    数组资源，并将其与名为 `bookTitlesAdapter` 的 `ArrayAdapter` 类实例关联。数组适配器将上下文作为第一个参数，我们通过访问活动来获取它，将数组作为第三个参数。第二个参数是用于布局列表中每个条目的资源的
    ID。这个资源可以是自定义资源或 Android 内置资源之一。在我们的例子中，我们使用的是内置的 Android 布局资源 `android.R.layout.simple_list_item_1`，它为
    `ListView` 中的每一行显示一个字符串值。最后一步是调用 `setListAdapter` 方法，并传递 `bookTitlesAdapter`。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Creating a custom layout resource for the `ListFragment` class is just like
    doing so for the `ListView` class, and is discussed in detail in the Android developer
    documentation: [http://developer.android.com/reference/android/app/ListFragment.html.](http://developer.android.com/reference/android/app/ListFragment.html.)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `ListFragment` 类创建一个自定义布局资源与为 `ListView` 类创建类似，这在 Android 开发者文档中有详细讨论：[http://developer.android.com/reference/android/app/ListFragment.html.](http://developer.android.com/reference/android/app/ListFragment.html.)
- en: Handling ListFragment item selection
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理 `ListFragment` 项目选择的操作
- en: For our application to work correctly, we need to inform the activity each time
    the user selects one of the titles. Because we use an interface to loosely couple
    our fragment with the activity, this turns out to be a pretty simple task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序正常工作，每次用户选择其中一个标题时，我们需要通知活动。由于我们使用接口来将片段与活动松散耦合，因此这个任务相当简单。
- en: We first override the `ListFragment` class' `onListItemClick` method. The `ListFragment`
    class calls the `onListItemClick` method when the user selects an entry within
    the `ListFragment` instance. The `onListItemClick` method receives several selection-related
    parameters including the zero-based position of the selection. Our `ListFragment`
    is loaded from an array, so this position value corresponds to the selected title's
    array index.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先重写 `ListFragment` 类的 `onListItemClick` 方法。当用户在 `ListFragment` 实例中选择一个条目时，`ListFragment`
    类会调用 `onListItemClick` 方法。`onListItemClick` 方法接收几个与选择相关的参数，包括基于零的选择位置。我们的 `ListFragment`
    从数组中加载，因此这个位置值对应于所选标题的数组索引。
- en: 'With the `position` parameter value corresponding directly to the array index,
    all we have to do to inform the activity of the user selection is get a reference
    to the activity, cast it to our `OnSelectionChangeListener` interface, and call
    the interface''s `onSelectedBookChanged` method, passing the `position` parameter
    value as shown in this code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `position` 参数值直接对应于数组索引，我们只需获取对活动的引用，将其转换为我们的 `OnSelectionChangeListener`
    接口，并调用接口的 `onSelectedBookChanged` 方法，传递 `position` 参数值，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the activity classes in our application that will use our `BookListFragment2`
    class already implement the `OnSelectionChangeListener` interface, so there is
    no change required to the activity classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中所有将使用 `BookListFragment2` 类的活动类已经实现了 `OnSelectionChangeListener` 接口，因此无需更改活动类。
- en: Updating the layout resources
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新布局资源
- en: 'We now update the `activity_main.xml` resource file to use the `BookListFragment2`
    class instead of the original `BookListFragment` class as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更新 `activity_main.xml` 资源文件，使用 `BookListFragment2` 类替代原来的 `BookListFragment`
    类，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to make the same change in the `activity_main_wide.xml` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `activity_main_wide.xml` 文件中进行相同的更改。
- en: 'Our program is now fully functional using the `ListFragment` class and appears
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全使用 `ListFragment` 类使程序功能完整，如下所示：
- en: '![Updating the layout resources](img/3095_03_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![更新布局资源](img/3095_03_03.jpg)'
- en: Any changes that we need to make to the titles can now all be made in the resources
    file and require no changes to the user interface code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的任何标题更改都可以在资源文件中完成，不需要更改用户界面代码。
- en: DialogFragment
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DialogFragment
- en: Up until now we've been looking at fragments as a new way to divide our application's
    user interface into subsections of the available display area. Although fragments
    are new, the concept of having an aspect of our application user interface as
    a subsection of the available display area is not new. Any time an application
    displays a dialog, the application is doing exactly that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在将片段看作是一种将应用程序用户界面划分为可用显示区域子部分的新方法。尽管片段是新的，但将应用程序用户界面的一部分作为可用显示区域的子部分的概念并不是新的。每当应用程序显示一个对话框时，它实际上就是在这样做。
- en: Historically, the challenge of working with dialogs is that even though they
    are conceptually just another window within an application, we must handle many
    of the tasks related to dialogs differently than other aspects of our application
    user interface. Doing something as simple as handling a button click requires
    a dialog-specific interface, `DialogInterface.OnClickListener`, rather than the
    `View.OnClickListener` interface that we use when handling a `click` event from
    non-dialog related parts of our user interface code. An even more complicated
    issue is that of orientation changes. Dialogs automatically close in response
    to an orientation change and therefore can create inconsistent application behavior
    if a user changes device orientation while a dialog is visible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，使用对话框的挑战在于，尽管它们在概念上只是应用程序内的另一个窗口，但我们必须以不同于应用程序用户界面其他方面的处理方式来处理与对话框相关的许多任务。像处理按钮点击这样简单的事情就需要一个特定的对话框接口，`DialogInterface.OnClickListener`，而不是我们在处理非对话框相关部分用户界面代码中的
    `click` 事件时使用的 `View.OnClickListener` 接口。更复杂的问题是设备方向改变。对话框会响应方向改变而自动关闭，因此如果用户在对话框可见时改变设备方向，可能会导致应用程序行为不一致。
- en: The `DialogFragment` class eliminates much of the special handling related to
    dialogs. With the `DialogFragment` class, displaying and managing a dialog becomes
    much more consistent with other aspects of our application user interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogFragment` 类消除了与对话框相关的许多特殊处理。使用 `DialogFragment` 类，显示和管理对话框与其他应用程序用户界面方面的处理更为一致。'
- en: Styles
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'When an application displays an instance of the `DialogFragment` class, the
    window for the `DialogFragment` instance has up to three parts to it: layout area,
    title, and frame. A `DialogFragment` instance always contains the layout area,
    but we can control whether it includes the title and frame by setting the `DialogFragment`
    class'' style using the `setStyle` method. The `DialogFragment` class supports
    four styles with an instance of the `DialogFragment` class having exactly one
    style applied. The following table shows the four available styles:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序显示 `DialogFragment` 类的实例时，`DialogFragment` 实例的窗口最多有三个部分：布局区域、标题和边框。`DialogFragment`
    实例总是包含布局区域，但我们可以通过使用 `setStyle` 方法设置 `DialogFragment` 类的样式来控制它是否包括标题和边框。`DialogFragment`
    类支持四种样式，每个 `DialogFragment` 类的实例只能应用一种样式。下表展示了四种可用的样式：
- en: '| Style | Has Title | Has Frame | Accepts Input |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 样式 | 显示标题 | 显示边框 | 接收输入 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `STYLE_NORMAL` | Yes | Yes | Yes |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `STYLE_NORMAL` | 是 | 是 | 是 |'
- en: '| `STYLE_NO_TITLE` | No | Yes | Yes |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `STYLE_NO_TITLE` | 否 | 是 | 是 |'
- en: '| `STYLE_NO_FRAME` | No | No | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `STYLE_NO_FRAME` | 否 | 否 | 是 |'
- en: '| `STYLE_NO_INPUT` | No | No | No |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `STYLE_NO_INPUT` | 否 | 否 | 否 |'
- en: Notice that the styles remove features cumulatively. For example, `STYLE_NO_TITLE`
    indicates no title whereas `STYLE_NO_FRAME` indicates no frame and no title. If
    we do not call the `setStyle` method, Android creates the `DialogFragment` instance
    with the style set to `STYLE_NORMAL`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，样式会累积移除功能。例如，`STYLE_NO_TITLE` 表示没有标题，而 `STYLE_NO_FRAME` 表示没有边框和标题。如果我们不调用
    `setStyle` 方法，Android 会使用 `STYLE_NORMAL` 样式创建 `DialogFragment` 实例。
- en: The style affects the remainder of the behavior of the `DialogFragment` class
    and therefore must be set in the `onCreate` callback method. An attempt to set
    the `DialogFragment` class' style any later in the lifecycle is ignored.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 样式会影响 `DialogFragment` 类的其余行为，因此必须在 `onCreate` 回调方法中设置样式。如果在生命周期中的更晚阶段尝试设置 `DialogFragment`
    类的样式，则会被忽略。
- en: 'If you wish to provide the dialog with a special theme, the theme''s resource
    ID can also be passed to the `setStyle` method. To allow Android to select an
    appropriate theme based on the style, simply pass 0 as the theme resource ID.
    The following code sets the `DialogFragment` instance to have no title and use
    the Android-selected theme for that style:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为对话框提供一种特殊的主题，可以将主题的资源 ID 传递给 `setStyle` 方法。为了允许 Android 根据样式选择一个合适的主题，只需将
    0 作为主题资源 ID 传递。以下代码设置 `DialogFragment` 实例不显示标题，并使用该样式的 Android 选择的主题：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Layout
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局
- en: Populating the layout of an instance of the `DialogFragment` class is just like
    that of a standard fragment derived class. We simply override the `onCreateView`
    method and inflate the layout resource.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 填充 `DialogFragment` 类实例的布局与标准片段派生类的布局一样。我们只需重写 `onCreateView` 方法并充气布局资源。
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Creating a layout resource for use with a `DialogFragment` derived class works
    exactly as creating a layout resource for any other fragment derived class. To
    have our `DialogFragment` instance display a line of text and two buttons, we
    define the `fragment_my_dialog.xml` layout resource as shown in the following
    XML:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `DialogFragment` 派生类创建一个布局资源与为任何其他片段派生类创建布局资源完全一样。为了使我们的 `DialogFragment`
    实例显示一行文本和两个按钮，我们定义了如下所示的 `fragment_my_dialog.xml` 布局资源：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: DialogFragment display
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DialogFragment` 显示'
- en: 'Displaying our `DialogFragment` derived class is largely just a matter of creating
    the class instance and calling the `show` method. We need to keep in mind though
    that although our `DialogFragment` instance appears as a standard dialog when
    it displays, it is actually a fragment. Like all fragments, it is managed by the
    containing activity''s `FragmentManager` instance. As a result, we need to pass
    a reference to the activity''s `FragmentManager` instance as part of the call
    to the `DialogFragment` class `show` method as we do in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们的 `DialogFragment` 派生类主要是创建类实例并调用 `show` 方法的问题。但是我们需要记住，尽管我们的 `DialogFragment`
    实例显示时看起来像一个标准的对话框，但实际上它是一个片段。像所有片段一样，它由包含活动的 `FragmentManager` 实例管理。因此，在调用 `DialogFragment`
    类的 `show` 方法时，我们需要传递对活动 `FragmentManager` 实例的引用，就像以下代码中所做的那样：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With our `DialogFragment` derived class'' style set to `STYLE_NO_TITLE` and
    using the `fragment_my_dialog.xml` layout resource file shown earlier, the previous
    code displays the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置我们派生的 `DialogFragment` 类的风格为 `STYLE_NO_TITLE`，并使用前面展示的 `fragment_my_dialog.xml`
    布局资源文件，之前的代码将显示如下内容：
- en: '![DialogFragment display](img/3095_03_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![DialogFragment 显示](img/3095_03_04.jpg)'
- en: Event handling
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理
- en: One of the key values of the `DialogFragment` class is that it provides greater
    consistency in our code than is available when using the traditional `Dialog`
    class. Most aspects of working with the `DialogFragment` class are the same as
    when working with other fragments. No longer does displaying a dialog have to
    be handled so much differently than other aspects of our application user interface.
    For example, no special handling is required to deal with orientation changes.
    Another place where this greater consistency is evident is in event handling,
    because our button click event handling can use the standard view class event
    interfaces.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogFragment` 类的一个关键价值在于，它提供了比使用传统的 `Dialog` 类时更一致的代码。使用 `DialogFragment`
    类的大部分方面与其他片段的工作方式相同。显示对话框不必再像处理应用程序用户界面其他方面那样区别对待。例如，无需特殊处理来应对方向变化。在事件处理方面，这种更高的一致性也显而易见，因为我们的按钮点击事件处理可以使用标准的视图类事件接口。'
- en: 'To handle the button clicks, our `DialogFragment` derived class simply implements
    the `View.OnClickListener` interface. The following code shows setting the yes
    and no button click events to call back to our `DialogFragment` derived class
    in our class'' `onCreateView` callback method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理按钮点击事件，我们派生的 `DialogFragment` 类只需实现 `View.OnClickListener` 接口。以下代码展示了在类的
    `onCreateView` 回调方法中，设置“是”和“否”按钮点击事件，以回调到我们的 `DialogFragment` 派生类：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we're setting up the button click handling just as we would if we
    were working within any other fragment or even directly within the activity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们设置按钮点击处理的方式与在任何其他片段内工作或直接在活动中工作时的处理方式相同。
- en: 'We can also handle notifying the activity of the user''s interaction with the
    `DialogFragment` derived class consistently with the way we do with other fragments.
    Just as we did in the previous chapter, our `DialogFragment` derived class simply
    provides an interface for notifying the activity which of the available buttons
    the user selects, as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以与其他片段相同的方式一致地处理通知活动用户与 `DialogFragment` 派生类的交互。就像我们在前一章中所做的那样，我们的 `DialogFragment`
    派生类只需提供一个接口，以通知活动用户选择了哪个可用的按钮，如下代码所示：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As long as the activity implements the interface, our `DialogFragment` derived
    class can notify the activity of which button the user clicked.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只要活动实现了接口，我们的 `DialogFragment` 派生类就可以通知活动用户点击了哪个按钮。
- en: 'In the handler for our button click events, we''ll follow the same pattern
    we did in the previous chapter. We access the containing activity, cast it to
    the expected interface, and call the interface method, as shown in the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮点击事件的处理程序中，我们将遵循前一章中的相同模式。我们访问包含的活动，将其转换为预期的接口，并调用接口方法，如下代码所示：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that there is one bit of special handling in the previous method. Just
    as with the traditional `Dialog` class, we must call the `dismiss` method on the
    `DialogFragment` derived class when we no longer wish to display it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面方法中有一种特殊处理。就像传统的 `Dialog` 类一样，当不再希望显示 `DialogFragment` 派生类时，我们必须在其上调用
    `dismiss` 方法。
- en: Dialog identity
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对话框身份识别
- en: Although we treat our `DialogFragment` derived class as just another fragment,
    it still has a part of its identity that is tied to the traditional `Dialog` class.
    In fact, Android actually wraps our `DialogFragment` derived class within a traditional
    `Dialog` instance. This occurs in a callback method, specific to the `DialogFragment`
    class, named `onCreateDialog` that Android calls just prior to calling the `onCreateView`
    callback method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将 `DialogFragment` 派生类视为另一个片段，但它仍然有一部分身份与传统 `Dialog` 类相关联。实际上，Android 会将我们的
    `DialogFragment` 派生类包装在传统的 `Dialog` 实例中。这发生在特定于 `DialogFragment` 类的回调方法 `onCreateDialog`
    中，Android 在调用 `onCreateView` 回调方法之前立即调用它。
- en: The `Dialog` instance that the `onCreateDialog` method returns is the window
    that is ultimately displayed to the user. The layout we create within our `DialogFragment`
    derived class is simply wrapped within the `Dialog` window. We can access that
    `Dialog` instance later in the lifecycle to access `Dialog` related behavior or
    even override the method to provide our own `Dialog` instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateDialog` 方法返回的 `Dialog` 实例是最终展示给用户的窗口。我们在 `DialogFragment` 派生类中创建的布局只是被包装在
    `Dialog` 窗口内。我们可以在生命周期后期访问该 `Dialog` 实例，以访问与 `Dialog` 相关的行为，甚至可以重写方法以提供我们自己的 `Dialog`
    实例。'
- en: Accessing Dialog related behavior
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问与 Dialog 相关的行为
- en: Accessing the `Dialog` related behavior of our `DialogFragment` derived class
    requires a reference to the `Dialog` instance created in the `onCreateDialog`
    method. We retrieve that reference by calling the `getDialog` method. Once we
    have the reference to the `Dialog` instance, we can access aspects of the class'
    dialog identity that are not otherwise available.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们的 `DialogFragment` 派生类的 `Dialog` 相关行为需要引用在 `onCreateDialog` 方法中创建的 `Dialog`
    实例。我们通过调用 `getDialog` 方法来获取该引用。一旦我们有了对 `Dialog` 实例的引用，我们就可以访问类的对话框身份的其他不可用的方面。
- en: 'When we create a `DialogFragment` derived class with the style set to `STYLE_NORMAL`,
    the displayed dialog includes a title area above the layout area. The value of
    the title can only be set by calling the `setTitle` method on the `Dialog` instance
    that wraps our `DialogFragment` instance. A similar issue comes up in dealing
    with the dialog cancellation behavior. By default, the user can cancel a dialog
    by tapping on the activity behind the dialog. In many cases, this may be unacceptable
    as we want to require the user to acknowledge one of the choices within the dialog.
    The following code sets these `Dialog` related behaviors after the button click
    handling is set up:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个将样式设置为 `STYLE_NORMAL` 的 `DialogFragment` 派生类时，显示的对话框在布局区域上方包括一个标题区域。标题的值只能通过调用包装我们的
    `DialogFragment` 实例的 `Dialog` 实例上的 `setTitle` 方法来设置。在处理对话框取消行为时也会出现类似的问题。默认情况下，用户可以通过点击对话框背后的活动来取消对话框。在许多情况下，这可能无法接受，因为我们需要用户在对话框内确认一个选择。以下代码在设置按钮点击处理之后设置了这些与
    `Dialog` 相关的行为：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code first sets the dialog title and then sets the option to prevent the
    user from closing the dialog by tapping on the activity window. For the call to
    the `setTitle` method to work, we will need to change the call to the `setStyle`
    method in the `onCreate` callback method to set the style to `STYLE_NORMAL` so
    that the dialog will have a title area.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先设置对话框标题，然后设置选项以防止用户通过点击活动窗口来关闭对话框。为了使`setTitle`方法的调用生效，我们需要在`onCreate`回调方法中更改对`setStyle`方法的调用，将样式设置为`STYLE_NORMAL`，这样对话框才会具有标题区域。
- en: Wrapping an existing dialog in a fragment
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在片段中包装现有的对话框
- en: There may be times where we like the programming consistency that the `DialogFragment`
    class offers, but want to take advantage of the features provided by a class that
    derives from the traditional `Dialog` class. By overriding the `DialogFragment`
    class' `onCreateDialog` method, we can do exactly that. Overriding the `onCreateDialog`
    method allows us to replace the `DialogFragment` class' default `Dialog` instance
    with one we create. A great example of when this is useful is in leveraging the
    Android `AlertDialog` class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们喜欢`DialogFragment`类提供的编程一致性，但同时也想利用从传统的`Dialog`类派生的类所提供的特性。通过重写`DialogFragment`类的`onCreateDialog`方法，我们可以做到这一点。重写`onCreateDialog`方法允许我们用自己创建的`Dialog`实例替换`DialogFragment`类的默认`Dialog`实例。一个典型的使用场景是利用Android的`AlertDialog`类。
- en: 'The `AlertDialog` class provides a variety of default behaviors and allows
    us to display text, an icon, and buttons all without having to create a layout
    resource. There is something we must keep in mind when we''re leveraging a class
    that inherits from the traditional `Dialog` class. Although outside interaction
    with our class will be consistent with other `DialogFragment` derived classes,
    any interactions with the traditional `Dialog` class that occur within our `DialogFragment`
    derived class will be done in the traditional `Dialog` class way. For example,
    to create a `DialogFragment` derived class that utilizes the `AlertDialog` class
    requires that our class implements the `Dialog` class way of handling click events
    that is to implement the `DialogInterface.OnClickListener` interface as shown
    in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlertDialog`类提供了各种默认行为，允许我们显示文本、图标和按钮，而无需创建布局资源。当我们利用从传统`Dialog`类继承的类时，我们必须记住一点。尽管与我们的类的交互与其他`DialogFragment`派生类一致，但在我们的`DialogFragment`派生类中发生的与传统`Dialog`类的任何交互都将按照传统的`Dialog`类的方式进行。例如，要创建一个利用`AlertDialog`类的`DialogFragment`派生类，需要我们的类实现`Dialog`类处理点击事件的方式，即实现`DialogInterface.OnClickListener`接口，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Within our class'' `onCreateDialog` method, we create the `AlertDialog` instance
    using the `AlertDialog.Builder` class just as if we were going to display the
    `AlertDialog` instance directly. Within the `onCreateDialog` method we set all
    the options on the `AlertDialog.Builder` instance, including the title, message,
    icon, and buttons. Notice, though, that we never call the `AlertDialog.Builder`
    class'' `show` method, but instead call its `create` method. We then take the
    reference to the newly created `AlertDialog` instance and return it from the `onCreateDialog`
    method. All of these steps are shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们类的`onCreateDialog`方法中，我们使用`AlertDialog.Builder`类创建`AlertDialog`实例，就像我们直接显示`AlertDialog`实例一样。在`onCreateDialog`方法中，我们设置`AlertDialog.Builder`实例上的所有选项，包括标题、消息、图标和按钮。但是请注意，我们从不对`AlertDialog.Builder`类的`show`方法进行调用，而是调用其`create`方法。然后我们获取对新创建的`AlertDialog`实例的引用，并从`onCreateDialog`方法中返回它。以下代码展示了所有这些步骤：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Dialog` instance we create is now managed as a part of the `DialogFragment`
    instance. Everything else we do with our `AlertDialogFragment` class will be just
    as it is with the other `DialogFragment` derived classes we create.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`Dialog`实例现在作为`DialogFragment`实例的一部分进行管理。我们对`AlertDialogFragment`类执行的其余操作将与我们对创建的其他`DialogFragment`派生类的操作一样。
- en: 'When our app shows our `AlertDialogFragment` class, it appears as the following
    screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用显示`AlertDialogFragment`类时，它看起来如下面的截图所示：
- en: '![Wrapping an existing dialog in a fragment](img/3095_03_05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![在片段中包装现有的对话框](img/3095_03_05.jpg)'
- en: Notice that we didn't need to override the `onCreateView` callback method, because
    the `Dialog` instance we create in the `onCreateDialog` callback method provides
    the desired display characteristics.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要重写`onCreateView`回调方法，因为我们在`onCreateDialog`回调方法中创建的`Dialog`实例提供了所需的显示特性。
- en: Overriding the `DialogFragment` class' `onCreateDialog` callback method is a
    powerful technique that allows us to enjoy the benefits of the `DialogFragment`
    class while still leveraging existing investment we may have in traditional `Dialog`
    classes, whether they be a built-in class such as the `AlertDialog` class or some
    custom `Dialog` class we may have as part of our own code library.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`DialogFragment`类的`onCreateDialog`回调方法是一种强大的技术，它让我们在享受`DialogFragment`类的好处的同时，还能利用我们可能在传统`Dialog`类上已有的投资，无论是内置的如`AlertDialog`类，还是我们自己的代码库中可能拥有的某些自定义`Dialog`类。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Understanding the fragment lifecycle empowers us to leverage the phases of creation
    and destruction of fragments to more efficiently manage fragments and the data
    associated with them. By working with this natural lifecycle, we can take advantage
    of the specialized fragment classes to create a rich user experience, while following
    a more consistent programming model than was previously available.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 理解碎片生命周期使我们能够利用碎片的创建和销毁阶段，更有效地管理碎片及其相关数据。通过遵循这个自然生命周期工作，我们可以利用专门的碎片类来创建丰富的用户体验，同时遵循比以前更一致的编程模型。
- en: In the next chapter, we build on our understanding of the fragment lifecycle
    to take more direct control of fragments to dynamically add and remove them within
    individual activities.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于对碎片生命周期理解的基础上，更直接地控制碎片，以便在单个活动中动态地添加和删除它们。
