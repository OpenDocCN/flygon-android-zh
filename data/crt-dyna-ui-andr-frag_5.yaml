- en: Chapter 5. Creating Rich Navigation with Fragments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 使用片段创建丰富的导航
- en: This chapter demonstrates the role of fragments in creating a rich user interface
    navigation experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了片段在创建丰富的用户界面导航体验中的作用。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: Swipe navigation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动导航
- en: The role of the Android action bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓操作栏的角色
- en: The close relationship between the action bar and fragments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作栏与片段之间紧密的关系
- en: Associating menus with fragments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将菜单与片段关联
- en: List navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表导航
- en: Tab navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签导航
- en: By the end of this chapter, we will be able to implement solutions that utilize
    fragments to provide rich user navigation, including swipe navigation, tab navigation,
    and drop-down list navigation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将能够实现利用片段提供丰富用户导航的解决方案，包括滑动导航、标签导航和下拉列表导航。
- en: A brave new world
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个勇敢的新世界
- en: 'As we''ve seen, fragments provide us with the ability to closely control and
    manage our application user interface. Through the use of the `FragmentTransaction`
    class we can provide the user with the experience of moving from one screen to
    another by simply switching between different fragments. This takes us to an entirely
    new way of thinking: a brave new world of application design.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，片段为我们提供了紧密控制和管理工作应用程序用户界面的能力。通过使用`FragmentTransaction`类，我们可以让用户通过简单地切换不同的片段，体验到从一个屏幕移动到另一个屏幕的感觉。这让我们进入了一个全新的思考方式：一个勇敢的应用设计新世界。
- en: When we create our user interface in this way, the activity acts as a sort of
    screen manager with the fragments implementing the screens themselves. This concept
    of managing the individual application screens as fragments within an activity
    is so powerful that it has become the foundation of some of the most compelling
    navigation features of the Android platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式创建用户界面时，活动充当了一种屏幕管理器的角色，而片段实现了屏幕本身。这种将应用程序的各个屏幕作为活动内的片段进行管理的方法非常强大，它已经成为Android平台一些最引人注目的导航功能的基础。
- en: Android provides classes that cooperate with this design pattern to enable us
    to create rich navigation and screen management experiences, in a simple way.
    These classes provide a variety of features, including transition effects along
    with some familiar user interface metaphors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓提供了与这种设计模式合作的类，使我们能够以简单的方式创建丰富的导航和屏幕管理体验。这些类提供了各种功能，包括过渡效果以及一些熟悉用户界面隐喻。
- en: Making navigation fun with swipe
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过滑动使导航变得有趣
- en: 'Many applications involve several screens of data that a user might want to
    browse or flip through to view each screen. As an example, think of an application
    where we list a catalogue of books with each book in the catalogue appearing on
    a single screen. A book''s screen contains an image, title, and description like
    the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序包含用户可能想要浏览或翻阅的多个数据屏幕，以查看每个屏幕。例如，考虑一个列出书籍目录的应用程序，目录中的每本书出现在一个单独的屏幕上。书籍的屏幕包含图像、标题和描述，如下面的截图所示：
- en: '![Making navigation fun with swipe](img/3095_05_01_NEW.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![通过滑动使导航变得有趣](img/3095_05_01_NEW.jpg)'
- en: 'To view each book''s information, the user needs to move to each screen. We
    could put a next button and a previous button on the screen, but a more natural
    action is for the user to use their thumb or finger to swipe the screen from one
    edge of the display to the other and have the screen with the next book''s information
    slide into place as represented in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看每本书的信息，用户需要移动到每个屏幕。我们可以在屏幕上放置一个下一个按钮和一个上一个按钮，但更自然的操作是用户使用他们的拇指或手指从显示的一侧滑动到另一侧，下一个包含书籍信息的屏幕就会像下面的截图所示那样滑入视野：
- en: '![Making navigation fun with swipe](img/3095_05_02_NEW.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![通过滑动使导航变得有趣](img/3095_05_02_NEW.jpg)'
- en: This creates a very natural navigation experience, and honestly, is a more fun
    way to navigate through an application than using buttons.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一个非常自然的导航体验，老实说，这比使用按钮更是一种有趣的浏览应用程序的方式。
- en: Implementing swipe navigation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现滑动导航
- en: Implementing swipe navigation is pretty simple, and fragments are at the core.
    Each of the screens is implemented as a fragment derived class. Each screen can
    be a completely different fragment derived class or the screens can be instances
    of the same fragment derived class with different data. To create a book browser
    app such as the one shown in the previous screenshot, we can use a simple fragment
    derived class that sets the book image, title, and description.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实现滑动导航非常简单，碎片是其核心。每个屏幕都作为碎片派生类实现。每个屏幕可以是完全不同的碎片派生类，或者屏幕可以是具有不同数据的相同碎片派生类的实例。为了创建如前所示截图中的书籍浏览器应用，我们可以使用一个简单的碎片派生类，设置书籍图片、标题和描述。
- en: 'There is one thing about the fragment derived class that is a bit unusual.
    At the time of this writing, the classes involved in managing swipe navigation
    are relatively new and are only available in the `android.support.v4.app` package.
    As a result, the fragment derived class created by us must inherit from the support
    package version of the `Fragment` class, `android.support.v4.app.Fragment`, even
    when our app is targeting the Android versions that natively support fragments.
    The fragment class definition will appear similar to the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于碎片派生类（fragment derived class）有一点比较特别。在撰写本文时，管理滑动导航的类相对较新，仅在`android.support.v4.app`包中可用。因此，即使我们的应用目标是本地支持碎片的Android版本，我们创建的碎片派生类也必须继承自支持包版本的`Fragment`类，即`android.support.v4.app.Fragment`。碎片类的定义将类似于以下代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Managing the swipe fragments
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理滑动碎片
- en: 'Presenting the individual fragments that represent the application screens
    requires an adapter to manage the creation and delivery of each fragment. The
    Android support library includes two classes that provide this capability: `FragmentPagerAdapter`
    and `FragmentStatePagerAdapter`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 展现代表应用屏幕的各个碎片需要一个适配器来管理每个碎片的创建和传递。Android支持库包括两个提供此功能的类：`FragmentPagerAdapter`和`FragmentStatePagerAdapter`。
- en: The `FragmentPagerAdapter` class is useful for scenarios where there are a small
    number of fragments. When a given fragment instance is created, it is directly
    stored in the `FragmentManager` class and that same instance is re-used each time
    that fragment's page is displayed. The fragment's `onDestroyView` method is called
    when the user switches to a different fragment, but not the `onDestroy` method.
    It's important that we only use the `FragmentPagerAdapter` class in cases where
    there's a relatively small number of fragments, because we should assume that
    once a fragment is created, it will exist as long as the `FragmentPagerAdapter`
    class exists.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentPagerAdapter`类适用于只有少量碎片（fragments）的场景。一旦创建了给定碎片实例，它会被直接存储在`FragmentManager`类中，并且每次显示该碎片的页面时都会重新使用这个实例。当用户切换到另一个不同碎片时，会调用碎片的`onDestroyView`方法，但不会调用`onDestroy`方法。重要的是，我们只在碎片数量相对较少的情况下使用`FragmentPagerAdapter`类，因为我们应该假定一旦创建了碎片，只要`FragmentPagerAdapter`类存在，它就会一直存在。'
- en: The `FragmentStatePagerAdapter` class is useful for scenarios where there is
    a large number of fragments, because fragments may be destroyed when they are
    no longer visible. Fragments managed by `FragmentStatePagerAdapter` will always
    have their `onDestroyView` method called, and may have their `onDestroy` method
    called as well. The call to the `onDestroy` method does not necessarily occur
    as soon as the user swipes to another fragment it may occur much later depending
    on the device's available resources. The `FragmentStatePagerAdapter` class gives
    the fragment an opportunity to save its state through the platform's call to the
    `onSaveInstanceState` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentStatePagerAdapter`类适用于有大量碎片的情况，因为当碎片不再可见时，它们可能会被销毁。由`FragmentStatePagerAdapter`管理的碎片将始终调用其`onDestroyView`方法，并且也可能调用其`onDestroy`方法。调用`onDestroy`方法不一定会立即在用户滑动到另一个碎片时发生，它可能会根据设备可用资源的情况在稍后发生。`FragmentStatePagerAdapter`类让碎片有机会通过平台调用`onSaveInstanceState`方法来保存其状态。'
- en: The ability to discard and recreate the contained fragments also makes the `FragmentStatePagerAdapter`
    class useful for scenarios where the list of fragments being displayed may change.
    The details of implementing an updatable `FragmentStatePagerAdapter` instance
    are beyond the scope of this book, but an example is available at [http://bit.ly/UpdateFragmentStatePagerAdapter](http://bit.ly/UpdateFragmentStatePagerAdapter).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentStatePagerAdapter`类能够丢弃和重新创建包含的片段，这使得它也适用于显示的片段列表可能发生变化的情况。实现可更新的`FragmentStatePagerAdapter`实例的细节超出了本书的范围，但可以在[http://bit.ly/UpdateFragmentStatePagerAdapter](http://bit.ly/UpdateFragmentStatePagerAdapter)找到一个示例。'
- en: 'To create a book browser app as seen in the previous screenshot, we''ll extend
    the `FragmentPagerAdapter` class because we''ll be displaying just a few books.
    We''ll name our class as `BookPagerAdapter`, the declaration of which is shown
    in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建如前截图所示的书籍浏览器应用，我们将扩展`FragmentPagerAdapter`类，因为我们只会显示几本书。我们将我们的类命名为`BookPagerAdapter`，其声明如下面的代码所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To implement our `BookPagerAdapter` class, we just need to override a few methods.
    The primary method, `getItem`, is responsible for returning each fragment instance.
    Our `getItem` method appears as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的`BookPagerAdapter`类，我们只需要覆盖几个方法。主要的方法`getItem`负责返回每个片段实例。我们的`getItem`方法如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the app displays a particular book's page for the first time, the `getItem`
    method is called with the index of the page as a parameter named `idx` in our
    code. Before creating the fragment, we retrieve the book title, description, and
    image resource ID from arrays containing those values and store them in a `Bundle`
    instance. We then create an instance of our `BookFragment` class and associate
    the argument `Bundle` instance with it. Finally, we return the `BookFragment`
    reference. When our `BookFragment` instance is displayed, it will access the values
    in the argument `Bundle` instance and display them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用首次显示特定书籍的页面时，会调用`getItem`方法，并以名为`idx`的参数传递页面索引。在创建片段之前，我们从包含这些值的数组中检索书籍标题、描述和图像资源ID，并将它们存储在`Bundle`实例中。然后，我们创建`BookFragment`类的实例，并将其与参数`Bundle`实例关联。最后，我们返回`BookFragment`的引用。当我们的`BookFragment`实例被显示时，它将访问参数`Bundle`实例中的值并将其显示出来。
- en: 'We now must override two additional methods: `getPageTitle` and `getCount`.
    The `getPageTitle` method returns the string that is visible in the thin bar above
    each fragment. Like the `getItem` method, the `getPageTitle` method receives the
    index of the page being displayed. The `getPageTitle` method simply returns a
    value from an array containing short versions of the page title, as shown in the
    following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须覆盖另外两个方法：`getPageTitle`和`getCount`。`getPageTitle`方法返回在每片段上方的细条中可见的字符串。与`getItem`方法一样，`getPageTitle`方法接收正在显示的页面的索引。`getPageTitle`方法仅从包含页面标题简短版本的数组中返回一个值，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `getCount` method is responsible for returning the number of screens we''ll
    be displaying. We can simply return the length of the array we''re using in the
    `getPageTitle` method, as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCount`方法负责返回我们将要显示的屏幕数量。我们可以简单地返回在`getPageTitle`方法中使用的数组的长度，如下面的代码所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implementing our `BookPagerAdapter` class takes care of the code that manages
    our fragments. Now, we just need to put the appropriate layout within our activity
    and connect it with the adapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们的`BookPagerAdapter`类处理了管理我们片段的代码。现在，我们只需要在我们的活动中放置适当的布局，并将其与适配器连接起来。
- en: Putting the swipe UI into place
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现滑动用户界面
- en: 'The swipe user interface behavior and effects come from two Android classes:
    `ViewPager` and `PagerTitleStrip`. The `ViewPager` class is the primary class.
    It manages the user interaction, provides the swipe animation effects, and cooperates
    with the adapter class that provides each screen''s fragment. The `PagerTitleStrip`
    class handles the displaying of the thin title bar above each fragment. The string
    values returned from our `BookPagerAdapter` class'' `getPageTitle` method are
    displayed within the `PagerTitleStrip` instance.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动用户界面行为和效果来自两个Android类：`ViewPager`和`PagerTitleStrip`。`ViewPager`类是主要的类。它管理用户交互，提供滑动动画效果，并与提供每个屏幕片段的适配器类合作。`PagerTitleStrip`类处理在每个片段上方的细标题栏的显示。从我们的`BookPagerAdapter`类的`getPageTitle`方法返回的字符串值显示在`PagerTitleStrip`实例中。
- en: 'We''ll create a layout resource file for our application''s activity called
    `activity_main.xml` containing the `ViewPager` and `PagerTitleStrip` classes,
    as shown in the following XML layout:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为应用程序的活动创建一个名为`activity_main.xml`的布局资源文件，其中包含`ViewPager`和`PagerTitleStrip`类，如下面的
    XML 布局所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our layout resource file contains `ViewPager` as the root node, and is set to
    occupy the entire activity. The `ViewPager` class has an ID value of `pager`.
    The `PagerTitleStrip` class is set to fill the full width of `ViewPager`, and
    to be positioned at the top. Alternatively we could set the `layout_gravity` attribute
    to a value of `bottom` to position `PagerTitleStrip` at the bottom of the `ViewPager`
    class' display area. Although, other values for the `layout_gravity` attribute
    are technically valid, they tend to be problematic. As a general rule, we want
    to limit our choices for the `layout_gravity` attribute to be either `top` or
    `bottom`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局资源文件以`ViewPager`作为根节点，并设置为占据整个活动。`ViewPager`类的 ID 值为`pager`。`PagerTitleStrip`类被设置为填充`ViewPager`的整个宽度，并位于顶部。另外，我们也可以将`layout_gravity`属性设置为`bottom`，以将`PagerTitleStrip`定位在`ViewPager`类显示区域的底部。尽管技术上`layout_gravity`属性的其他值是有效的，但它们往往会出现问题。通常，我们希望将`layout_gravity`属性的选择限制为`top`或`bottom`。
- en: 'We have our complete layout and have already created the adapter that will
    manage the fragments within our application. We''re now ready to declare our activity
    class, which we''ll name `MainActivity`. The class declaration appears as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了布局设计，并已经创建了管理应用内片段的适配器。现在我们准备声明我们的活动类，我们将其命名为`MainActivity`。类的声明如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that we're inheriting from the support library class `FragmentActvity`
    rather than the regular `Activity` class. This is due to the same issue we discussed
    when we declared our `BookFragment` class. The classes that provide the swipe
    behavior are in the support library; therefore, they expect all fragment-related
    classes to be from that library. Our activity class includes member variables
    for our `BookPagerAdapter` and `ViewPager` classes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从支持库类`FragmentActvity`继承，而不是常规的`Activity`类。这是我们声明`BookFragment`类时讨论的同样问题。提供滑动行为的类在支持库中；因此，它们期望所有与片段相关的类都来自该库。我们的活动类包括`BookPagerAdapter`和`ViewPager`类的成员变量。
- en: 'The last thing we need to do is connect our `BookPagerAdapter` class to the
    `ViewPager` class. We''ll do that in our `onCreate` method, which appears as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将我们的`BookPagerAdapter`类连接到`ViewPager`类。我们将在`onCreate`方法中这样做，如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, our job here is pretty easy. We call the `setContentView` method
    with the `R.layout.activity_main` resource we just created. When the `setContentView`
    method returns, we create our `BookPagerAdapter` instance passing the activity's
    `FragmentManager` instance and the activity's `this` pointer so our `BookPagerAdapter`
    can use it as the context. With our `BookPagerAdapter` created, we use the activity
    class' `findViewById` method to get a reference to the `ViewPager` class that
    we created with the layout resource file. Finally, we call the `ViewPager` instance's
    `setAdapter` method to connect the `BookPagerAdapter` instance to our `ViewPager`
    instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里的工作相当简单。我们调用`setContentView`方法，并传入我们刚刚创建的`R.layout.activity_main`资源。当`setContentView`方法返回后，我们创建`BookPagerAdapter`实例，传入活动的`FragmentManager`实例和活动的`this`指针，以便我们的`BookPagerAdapter`可以使用它作为上下文。创建`BookPagerAdapter`后，我们使用活动类的`findViewById`方法获取我们用布局资源文件创建的`ViewPager`类的引用。最后，我们调用`ViewPager`实例的`setAdapter`方法，将`BookPagerAdapter`实例连接到我们的`ViewPager`实例。
- en: We now have everything in place. Our book browser is all ready for the user
    to browse through our list of books using swipe navigation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一切。我们的书籍浏览器已经可以使用滑动导航让用户浏览我们的书籍列表。
- en: Android Studio and swipe navigation
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android Studio 和滑动导航
- en: 'If we''re working with Android Studio, getting started at building an app with
    swipe navigation is easy. In the **New Project** wizard, on the dialog where we
    set the activity and layout name, select **Scrollable Tabs + Swipe** for **Navigation
    Type** as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Android Studio，那么开始构建带有滑动导航的应用程序是很容易的。在**新建项目**向导中，在设置活动和布局名称的对话框里，选择**可滚动标签
    + 滑动**作为**导航类型**，如下面的截图所示：
- en: '![Android Studio and swipe navigation](img/3095_05_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio 和滑动导航](img/3095_05_03.jpg)'
- en: The resulting project will include a layout resource file containing `ViewPager`
    and `PagerTitleStrip`, along with stubbed-out code for the `FragmentPagerAdapter`,
    `Fragment`, and `Activity` derived classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目将包括一个布局资源文件，其中包含 `ViewPager` 和 `PagerTitleStrip`，以及 `FragmentPagerAdapter`、`Fragment`
    和 `Activity` 派生类的存根代码。
- en: Improving navigation with the ActionBar
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ActionBar 改进导航
- en: 'Beginning at API Level 11 (Android 3.0), Android moved away from using traditional
    menus to instead use the ActionBar. The ActionBar provides action items that are
    a combination of button-based actions that appear directly on the ActionBar and
    menu-based actions that appear in a drop-down list when the user taps on the Action
    overflow button. The following screenshot shows the available ActionBar actions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 级别 11（Android 3.0）开始，Android 从使用传统的菜单转而使用 ActionBar。ActionBar 提供的操作项是直接出现在
    ActionBar 上的基于按钮的操作和当用户点击操作溢出按钮时出现在下拉列表中的基于菜单的操作的组合。以下屏幕截图显示了可用的 ActionBar 操作：
- en: '![Improving navigation with the ActionBar](img/3095_05_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ActionBar 改进导航](img/3095_05_04.jpg)'
- en: 'What many developers don''t realize is that the button-based and menu-based
    actions are just a small subset of what the ActionBar actually does. The ActionBar
    now serves as a central point for many navigation-related behaviors. Two of these
    behaviors are tied directly to fragments: tab navigation and drop-down navigation.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者没有意识到，基于按钮和菜单的操作只是 ActionBar 实际功能的冰山一角。现在，ActionBar 已成为许多与导航相关行为的核心点。其中两种行为直接与片段相关：标签导航和下拉导航。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: To incorporate the ActionBar in applications targeting versions of Android with
    an API Level below 11, use the `ActionBarCompat` class available in the Android
    Support Library. For more information on the `ActionBarCompat` class visit [http://bit.ly/ActionBarCompat](http://bit.ly/ActionBarCompat).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在针对 API 级别低于 11 的 Android 版本的应用程序中包含 ActionBar，请使用 Android 支持库中提供的 `ActionBarCompat`
    类。有关 `ActionBarCompat` 类的更多信息，请访问 [http://bit.ly/ActionBarCompat](http://bit.ly/ActionBarCompat)。
- en: Navigating randomly with tabs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过标签随机导航
- en: Tabs are an effective navigation model. They're well understood by users, and
    make moving between screens within an app easy. Unlike swipe navigation that requires
    the user to move through screens in order, tab navigation allows the user to move
    from one screen to another in any order they like. Android has supported tab navigation
    since the original release of the platform. Historically, the challenge of implementing
    tab navigation was that it was unrelated to other navigation models and required
    using a special activity class and other tab-specific classes. With the ActionBar,
    this is all changed. Now, tab navigation is just another use of the common fragment
    programming model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一种有效的导航模型。它们被用户广泛理解，并使应用程序内屏幕之间的移动变得简单。与需要用户按顺序通过屏幕的滑动导航不同，标签导航允许用户按照自己喜欢的任何顺序从一个屏幕移动到另一个屏幕。自
    Android 平台最初发布以来，就支持标签导航。历史上，实现标签导航的挑战在于它与其他导航模型无关，需要使用特殊的活动类和其他特定于标签的类。现在有了 ActionBar，这一切都改变了。现在，标签导航只是通用片段编程模型的另一种用途。
- en: 'The ActionBar allows us to associate an instance of a fragment derived class
    with each tab. The following screenshot shows the top portion of the screen of
    two different devices, with the ActionBar displaying tabs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ActionBar 允许我们将一个片段派生类的实例与每个标签关联。以下屏幕截图显示了两个不同设备屏幕顶部的部分，ActionBar 显示了标签：
- en: '![Navigating randomly with tabs](img/3095_05_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![通过标签随机导航](img/3095_05_05.jpg)'
- en: Notice that the ActionBar automatically adapts the way the tabs are displayed
    in response to the available screen space. On the narrower device, the ActionBar
    places the tabs under the main portion of the ActionBar, whereas on the wider
    device with more horizontal screen space, the tabs appear directly on the main
    portion of the ActionBar.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ActionBar 会根据可用的屏幕空间自动调整标签的显示方式。在较窄的设备上，ActionBar 将标签放置在 ActionBar 的主体下方，而在具有更多水平屏幕空间的较宽设备上，标签直接出现在
    ActionBar 的主体上。
- en: Managing tab selection
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理标签选择
- en: 'The ActionBar manages all the heavy lifting when it comes to implementing tab
    navigation. It draws the tabs, indicates which tab is currently selected, and
    even takes care of beginning and committing a fragment transaction. All we have
    to do is handle which fragment is visible, based on the tab currently selected.
    We do this by providing an implementation of the `ActionBar.TabListener` interface
    for each tab. The following code shows the declaration of a class implementing
    the interface:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到实现标签导航时，ActionBar处理所有繁重的工作。它绘制标签，指示当前选定的标签，甚至负责开始并提交片段事务。所有我们需要做的就是根据当前选定的标签处理哪个片段可见。为此，我们为每个标签提供了一个`ActionBar.TabListener`接口的实现。以下代码展示了实现该接口的类的声明：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `TabListener` implementation has two member variables. The boolean member
    variable, `mFirstSelect`, is used to control the special handling that's necessary
    the first time the fragment managed by our `SimpleTabListener` class is selected.
    The other member variable, `mFragment`, holds a reference to the fragment that
    is managed by the `TabListener` instance, which is set in our `SimpleTabListener`
    constructor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TabListener`实现有两个成员变量。布尔成员变量`mFirstSelect`用于控制第一次由我们的`SimpleTabListener`类管理的片段被选定时的特殊处理。另一个成员变量`mFragment`保存了由`TabListener`实例管理的片段的引用，在`SimpleTabListener`构造函数中设置。
- en: 'The first `TabListener` interface method we''ll implement is the `onTabSelected`
    method. As the method name indicates, `onTabSelected` is called each time the
    tab associated with this `TabListener` instance becomes the selected tab. The
    `onTabSelected` method is implemented as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的首个`TabListener`接口方法是`onTabSelected`方法。顾名思义，每次与此`TabListener`实例关联的标签被选定时，都会调用`onTabSelected`方法。如下代码所示实现了`onTabSelected`方法：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Two parameters are passed to the `onTabSelected` method. The first parameter
    is a reference to the tab instance that is associated with our `TabListener` implementation.
    The second parameter is the `FragmentTransaction` instance that is managed by
    the ActionBar. The ActionBar starts this transaction, and will commit the transaction
    after `onTabSelected` returns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTabSelected`方法接收两个参数。第一个参数是与我们的`TabListener`实现相关联的标签实例的引用。第二个参数是由ActionBar管理的`FragmentTransaction`实例。ActionBar开始这个事务，并在`onTabSelected`返回后提交事务。'
- en: The first time the `onTabSelected` method is called, we use the passed `FragmentTransaction`
    instance to add our fragment to the display using the `add` method. As we discussed
    in the previous chapter, the first parameter to the `add` method is the ID of
    the view group under which we want the fragment to be placed. Just as when we're
    managing `FragmentsTransaction` ourselves, this can be any valid view group within
    the activity layout. In the previous code, we're using a special ID value that
    is predefined by Android, `android.R.id.content`. The `android.R.id.content` ID
    value indicates that we want the fragment to occupy the entire content area of
    the activity rather than be placed under a specific view group within the activity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onTabSelected`方法首次被调用时，我们使用传递进来的`FragmentTransaction`实例，通过`add`方法将我们的片段添加到显示中。正如在前一章中讨论的，`add`方法的第一参数是我们希望放置片段的视图组ID。就像我们自己管理`FragmentsTransaction`时一样，这可以是活动布局中的任何有效视图组。在之前的代码中，我们使用的是Android预定义的特殊ID值，`android.R.id.content`。`android.R.id.content`
    ID值表示我们希望片段占据活动的整个内容区域，而不是放在活动内的特定视图组中。
- en: We only use the `add` method the first time the tab is selected; every time
    thereafter, we use the `FragmentTransaction` class' `attach` method. We'll talk
    more about that in a moment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在标签首次选定时使用`add`方法；之后每次，我们都使用`FragmentTransaction`类的`attach`方法。我们稍后会进一步讨论这个问题。
- en: 'The next `TabListener` interface method we''ll implement is the `onTabUnselected`
    method, which is shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的下一个`TabListener`接口方法是`onTabUnselected`方法，如下代码所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `onTabUnselected` method receives the same parameters as the `onTabSelected`
    method. Our implementation of this method is simple, having only one line in which
    we call the `FragmentTransaction` class' `detach` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTabUnselected`方法接收与`onTabSelected`方法相同的参数。我们这个方法的实现很简单，只有一行代码，我们调用了`FragmentTransaction`类的`detach`方法。'
- en: The `detach` method call in the `onTabUnselected` method works together with
    the `attach` method call in the `onTabSelected` method. Once the fragment is initially
    added to the activity, as we do in the `onTabSelected` method the first time the
    fragment is shown, we can then call the `detach` method to tear down the fragment's
    view hierarchy, but leave the fragment associated with the activity. When we call
    the `attach` method within the `onTabSelected` method, the next time the user
    selects the tab for the fragment, the fragment's view hierarchy is rebuilt at
    the same place within the activity where the fragment was originally added.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTabUnselected`方法中的`detach`方法调用与`onTabSelected`方法中的`attach`方法调用协同工作。一旦碎片最初被添加到活动中，就像第一次显示碎片时在`onTabSelected`方法中所做的那样，我们可以随后调用`detach`方法来拆除碎片视图层次结构，但让碎片与活动关联。当我们再次在`onTabSelected`方法中调用`attach`方法时，下次用户选择该碎片的标签时，将在活动中原始添加碎片的位置重新构建碎片的视图层次结构。'
- en: This technique of calling the `detach` and `attach` methods allows us to manage
    the fragments more efficiently. When we call the `detach` method, the fragment's
    `onDestroyView` method is called, but not the `onDestroy` method. When we later
    call the `attach` method, the fragment's `onCreateView` method is called, but
    not the `onCreate` method, because the fragment does not need to be fully recreated
    just its view hierarchy needs to be recreated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用`detach`和`attach`方法的技术使我们能够更有效地管理碎片。当我们调用`detach`方法时，会调用碎片的`onDestroyView`方法，但不会调用`onDestroy`方法。稍后当我们调用`attach`方法时，会调用碎片的`onCreateView`方法，但不会调用`onCreate`方法，因为不需要完全重新创建碎片，只需重新创建其视图层次结构即可。
- en: There is a bit of potential confusion related to method names that we need to
    be aware of. When a fragment instance is passed to the `FragmentTransaction` class'
    `detach` method, the `Fragment` class' `onDetach` method does not get called.
    This is because the `detach` method tears down the fragment's view hierarchy but
    leaves the fragment associated with the activity; the fragment remains attached.
    Similarly, when a fragment instance is passed to the `FragmentTransaction` class'
    `attach` method, the `Fragment` class' `onAttach` method does not get called because
    the fragment is already attached to the activity. This is certainly a little confusing,
    but it ultimately comes down to a bad choice of method names on the part of the
    API designers rather than being a technical inconsistency.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意一些可能导致混淆的方法名称。当碎片实例传递给`FragmentTransaction`类的`detach`方法时，并不会调用`Fragment`类的`onDetach`方法。这是因为`detach`方法拆除了碎片的视图层次结构，但让碎片与活动关联；碎片仍然处于附着状态。同样，当碎片实例传递给`FragmentTransaction`类的`attach`方法时，不会调用`Fragment`类的`onAttach`方法，因为碎片已经与活动关联。这确实有些令人困惑，但最终这归咎于API设计者选择了糟糕的方法名称，而不是技术上的不一致性。
- en: 'The last method on the `TabListener` interface, `onTabReselected`, is called
    in scenarios where the user taps the tab that is already selected; in other words,
    the user reselects the same tab. In most cases, this method can be left empty,
    as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabListener`接口的最后一个方法`onTabReselected`，在用户点击已经选中的标签的场景下被调用；换句话说，就是用户重新选择了同一个标签。在大多数情况下，这个方法可以留空，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Connecting the fragments to the tabs
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将碎片连接到标签
- en: 'With our `TabListener` implementation in place, we can now connect the fragments
    to the tabs. We''ll do this in the activity''s `onCreate` method, which is shown
    in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了`TabListener`的实现，现在可以将碎片连接到标签。我们将在活动的`onCreate`方法中这样做，具体代码如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our `onCreate` implementation, we start by getting a reference to the ActionBar,
    and putting the ActionBar into tab navigation mode. This step is essential; without
    it, the tabs we add will never be visible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`onCreate`实现中，首先获取对ActionBar的引用，并将ActionBar设置为标签导航模式。这一步是必不可少的；如果没有这一步，我们添加的标签将永远不会显示。
- en: For the first tab, we create the fragment that will serve as the body of the
    tab. This can be virtually any fragment derived class. We then associate our `TabListener`
    implementation with the fragment. With the fragment and `TabListener` implementation
    in place, we create a new `ActionBar.Tab` instance with the call to the `newTab`
    method, we then set the text that will display within the tab, and associate our
    `TabListener` instance with the tab. Finally, we add the `ActionBar.Tab` instance
    to the ActionBar with the `addTab` method. We then repeat those steps for the
    second tab.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个标签，我们创建将作为标签主体的片段。这可以是几乎任何从片段派生的类。然后我们将`TabListener`实现与片段关联。在片段和`TabListener`实现就位后，我们通过调用`newTab`方法创建一个新的`ActionBar.Tab`实例，然后设置将在标签中显示的文本，并将我们的`TabListener`实例与标签关联。最后，我们使用`addTab`方法将`ActionBar.Tab`实例添加到ActionBar中。然后我们对第二个标签重复这些步骤。
- en: With that, we now have tab navigation implemented in our application. Using
    this technique, we're able to leverage all the capabilities of fragments and implement
    tab-based navigation in a way that is consistent with other ways we use fragments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的应用程序现在实现了标签导航。使用这种技术，我们能够利用片段的所有功能，并以与其他使用片段的方式一致的方式实现基于标签的导航。
- en: One thing that may appear unusual about our `onCreate` method implementation
    is the absence of a call to the `setContentView` method. In this case, we don't
    need to associate a layout resource with the activity, because we're using the
    special-purpose `android.R.id.content` resource ID when we call the `add` method
    in our `onTabSelected` implementation. As we mentioned earlier, the resource ID
    `android.R.id.content` indicates that the fragment occupies the entire content
    area. If we wanted the tab to control the display of a fragment within some view
    group, we would call `setContentView` with a resource containing the desired layout.
    We would then use the ID of the view group within that layout in our call to the
    `add` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`onCreate`方法实现中可能看起来不太寻常的一点是缺少了对`setContentView`方法的调用。在这种情况下，我们不需要将布局资源与活动关联，因为当我们在`onTabSelected`实现中调用`add`方法时，使用了特殊用途的`android.R.id.content`资源ID。正如我们之前提到的，资源ID
    `android.R.id.content`表示片段占据了整个内容区域。如果我们希望标签控制某个视图组内片段的显示，我们会用包含所需布局的资源调用`setContentView`。然后，我们会在调用`add`方法时使用该布局中视图组的ID。
- en: Providing direct access with drop-down list navigation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过下拉列表导航提供直接访问
- en: Tab navigation works well when an app has just a few predictable screens, but
    quickly becomes cluttered if there are a large number of screens. For those scenarios
    where an app has a large number of screens or possibly the number of screens might
    even change over time, drop-down list navigation provides a much better solution
    than tabs. Drop-down list navigation places a drop-down list on the ActionBar
    containing the list of available screen names. When the user chooses a screen
    name from the list, the app immediately displays the corresponding screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用只有少数可预测的屏幕时，标签导航工作得很好，但如果屏幕数量很多，它会很快变得杂乱。对于那些屏幕数量很多的应用，或者可能屏幕数量随时间变化的情况，下拉列表导航提供了一个比标签更好的解决方案。下拉列表导航在ActionBar上放置一个包含可用屏幕名称列表的下拉列表。当用户从列表中选择一个屏幕名称时，应用会立即显示相应的屏幕。
- en: 'Probably the most familiar use of this navigation model on Android is the Android
    e-mail app, which is shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，这种导航模型最熟悉的用途可能是Android电子邮件应用，如下面的截图所示：
- en: '![Providing direct access with drop-down list navigation](img/3095_05_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![通过下拉列表导航提供直接访问](img/3095_05_06.jpg)'
- en: In the Android e-mail app, the list of different available e-mail folder screens
    appears in the drop-down list. Tapping the ActionBar displays the list and then
    selecting the screen name from the list immediately displays the screen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android电子邮件应用中，不同的电子邮件文件夹屏幕列表显示在下拉列表中。点击ActionBar会显示列表，然后从列表中选择屏幕名称会立即显示该屏幕。
- en: Incorporating drop-down list navigation in our apps is very simple.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中整合下拉列表导航非常简单。
- en: Managing fragment selection
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理片段选择
- en: 'Unlike tab navigation, where the ActionBar takes a very active role in managing
    the transition from one fragment to another, in drop-down list navigation the
    ActionBar takes a much more hands-off approach. Basically, the ActionBar simply
    notifies the app that the selection has changed, and leaves the details of switching
    fragments up to the app. To handle the notification we need to provide an implementation
    of the `ActionBar.OnNavigationListener` interface. The implementation declaration
    is shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与标签导航不同，在ActionBar在管理从一个片段到另一个片段的过渡中扮演非常活跃的角色，而在下拉列表导航中，ActionBar采取了更为放手的方法。基本上，ActionBar只是通知应用选择已更改，而将切换片段的细节留给应用处理。为了处理这个通知，我们需要提供一个`ActionBar.OnNavigationListener`接口的实现。实现声明如下面的代码所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `ActionBar.OnNavigationListener` implementation has a single member variable,
    `mFragmentManager`, to hold a reference to the activity's `FragmentManager` instance.
    The `FragmentManager` reference is passed to our class in the constructor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ActionBar.OnNavigationListener`实现有一个成员变量`mFragmentManager`，用于保存对activity的`FragmentManager`实例的引用。`FragmentManager`引用在构造函数中传递给我们的类。
- en: 'Unlike in tab navigation where each tab instance is managed by a separate `TabListener`
    instance, in drop-down list navigation a single `OnNavigationListener` implementation
    handles all the selections. The `OnNavigationListener` interface''s only method,
    `onNavigationItemSelected`, is called each time the selection changes and is responsible
    for taking care of displaying the appropriate fragment, as shown in the following
    implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与标签导航中每个标签实例都由一个单独的`TabListener`实例管理不同，在下拉列表导航中，一个单独的`OnNavigationListener`实现处理所有选择。每次选择更改时都会调用`OnNavigationListener`接口的唯一方法`onNavigationItemSelected`，并负责处理显示适当的片段，如下面的实现所示：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We receive the zero-based index of the selection as the first parameter, `itemPosition`.
    We'll be populating the list of screen names from a simple `String` array so the
    second parameter, `itemId`, does not have value to us. If we were to use a more
    structured data source, the `itemId` parameter would contain the ID of the selection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收基于零的选中项索引作为第一个参数`itemPosition`。我们将从一个简单的`String`数组中填充屏幕名称列表，所以第二个参数`itemId`对我们没有价值。如果我们使用更结构化的数据源，`itemId`参数将包含选中项的ID。
- en: Using a `switch` statement, we create an instance of the appropriate fragment
    derived class. Once we have the fragment instance, we replace the currently visible
    fragment with the one we just created. We again use the layout resource ID, `android.R.id.content`,
    indicating that the fragment occupies the entire content area of the activity.
    Just as with tab navigation, we could instead use the ID value of a view group
    within the activity's layout, if we prefer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`语句，我们创建适当的片段派生类的实例。一旦我们有了片段实例，我们就会用刚刚创建的片段替换当前可见的片段。我们再次使用布局资源ID `android.R.id.content`，表示片段占据了activity整个内容区域。如果我们愿意，也可以使用activity布局中视图组的ID值，就像标签导航一样。
- en: Notice that we're explicitly creating and committing the `FragmentTransaction`
    instance in our code. This is another important difference from how tab navigation
    is managed; we're responsible for all the details. The test that the local variable,
    `fragment`, is not null is just a sanity check. As long as we don't display more
    than three values for the user to select from, the `fragment` variable will never
    be null.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的代码中，我们显式地创建并提交了`FragmentTransaction`实例。这是与标签导航管理方式的另一个重要区别；我们需要负责所有细节。检查局部变量`fragment`不为null只是一个健全性检查。只要我们为用户显示的选择不超过三个值，`fragment`变量就永远不会为null。
- en: Providing a method return value of `true` simply indicates that we have handled
    the event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`true`的方法值仅表示我们已经处理了该事件。
- en: Providing the navigation choices
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供导航选择
- en: 'We now need to provide the ActionBar with the information necessary to display
    the list of navigation choices. We do that in the activity''s `onCreate` method,
    which is shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要向ActionBar提供显示导航选择列表所需的信息。我们是在activity的`onCreate`方法中完成这一操作，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first step in setting up drop-down list navigation is to put the ActionBar
    into list navigation mode with the call to the `setNavigationMode` method. The
    drop-down list containing the screen choices appears directly on the ActionBar,
    which can be problematic if the ActionBar attempts to show both the drop-down
    list and the activity title text. To make room for the list, we call the `setDisplayShowTitleEnabled`
    method with a value of `false` so that the title doesn't display.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 设置下拉列表导航的第一步是使用`setNavigationMode`方法的调用将ActionBar设置为列表导航模式。包含屏幕选择的下拉列表直接出现在ActionBar上，如果ActionBar试图同时显示下拉列表和活动标题文本，这可能会出现问题。为了给列表腾出空间，我们使用`setDisplayShowTitleEnabled`方法并传递`false`值，这样标题就不会显示。
- en: 'We retrieve the list of display values from the array resource, which is a
    regular `String` array. We wrap the `String` array in an instance of the `ArrayAdapter`
    class just as we would if we were planning to associate the `String` array with
    a standard `ListView` instance appearing within a layout definition for an activity.
    The `String` array resource definition appears as shown in the following XML code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数组资源中检索显示值列表，这是一个常规的`String`数组。我们将`String`数组包装在`ArrayAdapter`类的一个实例中，就像我们计划将`String`数组与在活动布局定义中出现的标准`ListView`实例关联一样。`String`数组资源定义如下面的XML代码所示：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We then create an instance of `SimpleNavigationListener`, which we had defined
    earlier. Finally, we set the list of displayed screen names and the screen selection
    handler by calling the `setListNavigationCallbacks` method to associate the `ArrayAdapter`
    and `SimpleNavigationListener` implementations with the `ActionBar`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个之前定义的`SimpleNavigationListener`实例。最后，我们通过调用`setListNavigationCallbacks`方法来设置显示的屏幕名称列表和屏幕选择处理程序，从而将`ArrayAdapter`和`SimpleNavigationListener`实现与`ActionBar`关联。
- en: With that we have drop-down navigation fully implemented. When we run the application,
    the list of screen selections will appear as shown in the following screenshot.
    The ActionBar initially appears as shown on the left-hand side in the following
    screenshot, with the currently selected screen's name displayed. When the user
    taps on the currently selected screen name, the list expands to display the list
    of available screen names as shown on the right-hand side of the following screenshot.
    With the list expanded, the user can easily jump directly to any of the available
    screens by tapping on the desired screen's name within the list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就完成了下拉导航的完全实现。运行应用程序时，屏幕选择列表将如下截图所示出现。ActionBar最初如下截图左侧所示，显示当前选定屏幕的名称。当用户点击当前选定的屏幕名称时，列表将展开，如下截图右侧所示，显示可用的屏幕名称列表。列表展开后，用户只需点击列表中想要跳转的屏幕名称，就可以轻松直接跳转到任何可用的屏幕。
- en: '![Providing the navigation choices](img/3095_05_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![提供导航选择](img/3095_05_07.jpg)'
- en: Android Studio and drop-down list navigation
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android Studio 和下拉列表导航
- en: If we're working with Android Studio, we can create a project that supports
    drop-down list navigation directly from the **New Project** wizard by selecting
    **Dropdown** as the **Navigation Type**, similar to the way we created a project
    with swipe navigation. The resulting project will contain a stubbed-out `ActionBar.OnNavigationListener`
    implementation along with the code within the activity to put the ActionBar into
    drop-down list navigation mode, and associate the `ActionBar.OnNavigationListener`
    implementation with the ActionBar.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是Android Studio，可以通过**新建项目**向导直接创建一个支持下拉列表导航的项目，方法是选择**Dropdown**作为**导航类型**，这与我们创建带有滑动导航的项目的方式类似。生成的项目将包含一个`ActionBar.OnNavigationListener`实现的存根以及活动中的代码，以将ActionBar设置为下拉列表导航模式，并将`ActionBar.OnNavigationListener`实现与ActionBar关联。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Fragments are the foundation of modern Android app development, allowing us
    to display multiple application screens within a single activity. Thanks to the
    flexibility provided by fragments, we can now incorporate rich navigation into
    our apps with relative ease. Using these rich navigation capabilities, we're able
    to create a more dynamic user interface experience that make our apps more compelling
    and that users find more fun to work with.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是现代Android应用开发的基础，它允许我们在单个活动中显示多个应用程序屏幕。由于片段提供的灵活性，我们现在可以相对容易地将丰富的导航功能集成到我们的应用程序中。使用这些丰富的导航功能，我们可以创建更加动态的用户界面体验，使我们的应用程序更具吸引力，用户也会觉得使用起来更有趣。
