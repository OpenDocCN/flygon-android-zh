# 第六章：*第六章*：Android 生命周期

在本章中，我们将熟悉 Android 应用程序的生命周期。起初，这可能听起来有点奇怪，一个计算机程序有一个生命周期，但很快就会有意义。

生命周期是所有 Android 应用程序与 Android 操作系统交互的方式。就像人类的生命周期与周围世界互动一样，我们别无选择，必须与之互动，并且必须准备好处理不经通知的不同事件，如果我们希望我们的应用程序能够生存下来。

我们将看到应用程序从创建到销毁经历的生命周期阶段，以及这如何帮助我们知道根据我们想要实现的目标在何处放置我们的 Java 代码。

简而言之，在本章中我们将看到以下内容：

+   Android 应用程序的生活和时代

+   什么是方法重写

+   Android 生命周期的阶段

+   我们确切需要了解和做什么来编写我们的应用程序

+   一个生命周期演示迷你应用程序。

+   快速查看代码结构，准备在下一章中进行 Java 编码

让我们开始学习 Android 的生命周期。

# 技术要求

您可以在 GitHub 上找到本章中的代码文件[`github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006`](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2006)。

# Android 应用程序的生活和时代

我们已经谈到了我们代码的结构；我们知道我们可以编写类，并且在这些类中我们有方法，方法包含我们的代码，从而完成任务。我们也知道当我们想要方法中的代码运行时，我们通过使用方法的名称来调用该方法。

此外，在*第二章**，初次接触：Java，XML 和 UI 设计师*中，我们了解到 Android 本身在应用程序准备启动之前调用`onCreate`方法。当我们输出到 logcat 并使用`Toast`类向用户发送弹出消息时，我们看到了这一点。

在本章中，我们将看到我们编写的每个应用程序在其生命周期内发生的情况 - 启动和结束以及中间的一些阶段。我们将看到 Android 在每次运行时都与我们的应用程序进行交互。

# Android 如何与我们的应用程序交互

它通过调用包含在`Activity`类中的方法来实现。即使该方法在我们的 Java 代码中不可见，Android 也会在适当的时间调用它。如果这看起来毫无意义，那么请继续阅读。

你是否曾想过为什么`onCreate`方法之前有一行奇怪的代码？

```kt
@Override
```

这里发生的是，我们在告诉 Android，当你调用`onCreate`时，请使用我们重写的版本，因为我们在那个时候有一些事情要做。

此外，您可能还记得`onCreate`方法中奇怪的第一行代码：

```kt
super.onCreate(savedInstanceState)
```

这是在告诉 Android 在继续使用我们重写的版本之前调用`onCreate`的原始/官方版本。这不仅仅是 Android 的一个怪癖 - **方法** **重写**内置在 Java 中。

还有许多其他方法，我们可以选择重写，它们允许我们在 Android 应用程序的生命周期中的适当时间添加我们的代码。就像`onCreate`在应用程序显示给用户之前被调用一样，还有更多在其他时间被调用的方法。我们还没有看到它们，我们还没有重写它们，但它们存在，它们被调用，它们的代码执行。

我们需要关心 Android 在何时调用我们应用程序的方法，因为它们控制着我们代码的生死。例如，如果我们的应用程序允许用户输入重要的提醒。然后，在输入提醒的一半时，他们的手机响了，我们的应用程序消失了，数据（提醒）也消失了。

我们需要学会何时、为什么以及 Android 将调用我们应用程序生命周期的哪些方法，这是非常重要的，幸运的是也相当简单。然后我们就知道在哪里需要重写方法来添加我们自己的代码，以及在哪里添加定义我们应用程序的真正功能（代码）。

让我们先来研究一下 Android 的生命周期，然后我们可以继续深入了解 Java 的方方面面，我们就会知道在哪里放我们编写的代码。

# Android 生命周期的简化解释

如果你曾经使用过 Android 设备，你可能已经注意到它的工作方式与许多其他操作系统有很大不同。例如，你可能正在使用一个应用程序——比如你正在查看 Facebook 上的人在做什么。然后，你收到一封电子邮件通知，你点击通知来阅读它。在阅读电子邮件的过程中，你可能会收到 Twitter 的通知，因为你正在等待某个关注者的重要消息，所以你中断了阅读电子邮件，触摸屏幕切换到 Twitter。

阅读完推文后，你想玩愤怒的小鸟，但在第一次投掷的过程中，你突然想起了 Facebook 的帖子。所以，你退出愤怒的小鸟，点击 Facebook 图标。

然后你恢复 Facebook，可能在你离开的地方。你可以恢复阅读电子邮件，决定回复推文，或者开始一个全新的应用程序。

所有这些来回都需要操作系统进行相当多的管理，独立于应用程序本身。

在我们刚刚讨论的情境中，例如 Windows PC 和 Android 之间的区别是：在 Android 中，尽管用户决定使用哪个应用程序，但操作系统决定何时关闭（销毁）应用程序以及**我们用户的数据**（比如假设的笔记）也会一并销毁。我们在编写应用程序时需要考虑到这一点。仅仅因为我们可能编写代码来处理用户的输入，这并不意味着 Android 会让代码执行。

## 生命周期阶段的解密

Android 系统有多个不同的阶段，任何给定的应用程序都可能处于其中之一。根据阶段，Android 系统决定应用程序如何被用户查看，或者是否被用户查看。

Android 有这些阶段，这样它可以决定哪个应用程序正在使用，并且可以给予正确数量的资源，如内存和处理能力。

此外，当用户与设备进行交互时，例如触摸屏幕，Android 必须将该交互的细节传递给正确的应用程序。例如，在愤怒的小鸟中，拖动并释放意味着射击，但在消息应用中，它可能意味着删除短信。

我们已经提出了一个问题，当用户退出我们的应用程序来接听电话时，他们会丢失他们的进度/数据/重要笔记吗？

Android 有一个系统，简化一下以便解释，意味着 Android 设备上的每个应用程序都处于以下阶段之一：

+   创建中

+   启动

+   恢复

+   运行

+   暂停

+   停止

+   被销毁

阶段列表希望看起来是合乎逻辑的。例如，用户按下 Facebook 应用程序图标，应用程序被**创建**。然后它被**启动**。到目前为止一切都很简单，但接下来是**恢复**。

如果我们能暂时接受应用程序在启动后恢复，那么这并不像它一开始看起来那么不合逻辑，随着我们的继续，一切都会变得清晰起来。

**恢复**后，应用程序是**运行**的。这时，Facebook 应用程序控制着屏幕和大部分系统内存和处理能力，并接收用户输入的细节。

现在，我们的例子是什么，当我们从 Facebook 应用切换到电子邮件应用时呢？

当我们点击去阅读我们的电子邮件时，Facebook 应用程序将进入**暂停**阶段，然后是**停止**阶段，而电子邮件应用程序将进入**创建中**阶段，然后是**恢复**，然后是**运行**。

如果我们决定重新访问 Facebook，就像之前的情况一样，Facebook 应用程序可能会直接跳过创建并直接**恢复**，然后再次**运行**，很可能会恰好停留在我们离开的地方。

请注意，随时，Android 都可以决定**停止**然后**销毁**一个应用程序。在这种情况下，当我们再次运行应用程序时，它将需要在第一个阶段重新**创建**。

因此，如果 Facebook 应用程序长时间不活动，或者 Angry Birds 需要很多系统资源，以至于 Android 已经**销毁**了 Facebook 应用程序，那么我们之前阅读的确切帖子的体验可能会有所不同。

如果所有这些阶段的东西开始变得令人困惑，那么您会很高兴地知道提到它的唯一原因是以下：

+   您知道它存在

+   我们偶尔需要与之交互

+   当我们这样做时，我们将一步一步地进行

现在我们了解了生命周期阶段，让我们学习如何处理它们。

# 我们如何处理生命周期阶段

当我们编写应用程序时，我们如何与这种复杂性进行交互？好消息是，当我们创建第一个项目时自动生成的 Android 代码大部分都为我们完成了。

正如我们所讨论的，我们只看不到处理此交互的方法，但是我们有机会**覆盖**它们并在需要时向该阶段添加我们自己的代码。

这意味着我们可以继续学习 Java 并制作 Android 应用程序，直到我们遇到偶尔需要在某个阶段执行某些操作的情况。

重要说明

如果我们的应用程序有多个活动，它们将各自拥有自己的生命周期。这并不复杂，总体上对我们来说会更容易。

接下来是 Android 提供的方法的简要解释，以方便我们管理生命周期阶段。为了澄清我们对生命周期方法的讨论，它们将列在我们正在讨论的相应阶段旁边。但是，正如您将看到的，方法名称本身清楚地说明了它们在哪个阶段适用。

还有一个简短的解释或建议，说明我们何时可以使用特定的方法，并在特定阶段进行交互。随着我们在书中的进展，我们将遇到大部分这些方法。当然，我们已经看到了`onCreate`：

+   `onCreate`：当活动正在`setContentView`（设置内容视图），图形和声音时，将执行此方法。

+   `onStart`：当应用程序处于**启动**阶段时执行此方法。

+   `onResume`：此方法在`onStart`之后运行，但也可以在我们的活动在先前暂停后恢复时（最合理地）进入。我们可能会重新加载先前保存的用户数据（例如重要笔记），这些数据是在应用程序被中断时保存的，例如电话呼叫或用户运行其他应用程序。

+   `onPause`：当我们的应用程序是`onResume`时发生。当另一个 UI 元素显示在当前活动的顶部（例如弹出对话框）或活动即将停止时（例如，用户导航到不同的活动）时，活动总是转换到暂停状态。

+   `onStop`：这与`onCreate`有关，例如释放系统资源或将信息写入数据库。如果我们到达这里，我们很可能很快就会被销毁。

+   `onDestroy`：这是当我们的活动最终被**销毁**时。从这个阶段开始就没有回头路了。这是我们有序拆除我们的应用程序的最后机会。如果我们到达这里，下次我们将从头开始经历生命周期阶段。

此图显示了方法之间可能的执行流程：

![图 6.1 - 执行流程](img/B16773_06_01.jpg)

图 6.1 - 执行流程

所有的方法描述及其相关阶段应该都很简单。唯一真正的问题是运行阶段是什么？当我们在其他方法/阶段中编写代码时，我们将看到`onCreate`，`onStart`和`onResume`方法将准备应用程序，然后持续形成运行阶段。然后`onPause`，`onStop`和`onDestroy`方法将随后发生。

现在我们可以通过一个迷你应用程序来观察这些生命周期方法的作用。我们将通过重写它们并为每个方法添加一个`Log`消息和一个`Toast`消息来做到这一点。这将直观地证明我们的应用程序经过了哪些阶段。

# 生命周期演示应用程序

在这一部分，我们将进行一个快速实验，帮助我们熟悉应用程序使用的生命周期方法，并让我们有机会玩一些更多的 Java 代码。

按照以下步骤开始一个新项目，然后我们可以添加一些代码：

1.  开始一个新项目。

1.  选择**基本活动**模板。

1.  将项目命名为**生命周期演示**。当然，如果您希望参考或复制粘贴，代码在*第六章*文件夹中的下载包中。

1.  等待 Android Studio 生成项目文件，然后在代码编辑器中打开`MainActivity.java`文件。

您已经使用所有默认设置创建了一个新项目。对于这个演示，我们只需要`MainActivity.java`文件，不需要构建 UI。

## 编写生命周期演示应用程序

在`MainActivity.java`文件中，找到`onCreate`方法，并在闭合大括号`}`之前添加以下两行代码，标志着`onCreate`方法的结束：

```kt
Toast.makeText(this, "In onCreate", Toast.LENGTH_SHORT).show();
Log.i("info", "In onCreate");
```

整个`onCreate`方法现在应该看起来像下面的代码，其中高亮显示的代码是我们刚刚添加的两行，`…`是我们跳过一些自动生成的代码行，以使书更易读。有关完整的代码清单，请检查下载包中的`MainActivity.java`文件。以下是代码：

```kt
@Override
protected void onCreate(Bundle savedInstanceState) {
   super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);    
             Toast.makeText(this, "In onCreate", 
             Toast.LENGTH_SHORT).show();
       Log.i("info", "In onCreate");
}
```

提示

请记住，您需要使用*Alt* + *Enter*键盘组合两次来导入`Toast`和`Log`所需的类。

在`onCreate`方法的闭合大括号`}`之后，留出一行空白，并添加以下五个生命周期方法及其包含的代码。还要注意，我们添加重写方法的顺序并不重要。Android 将根据我们输入的顺序正确调用它们：

```kt
@Override
public void onStart() {
   // First call the "official" version of this method
   super.onStart();
   Toast.makeText(this, "In onStart", 
         Toast.LENGTH_SHORT).show();
   Log.i("info", "In onStart");
}
@Override
public void onResume() {
   // First call the "official" version of this method
   super.onResume();
   Toast.makeText(this, "In onResume",
         Toast.LENGTH_SHORT).show();
   Log.i("info", "In onResume");
}
@Override
public void onPause() {
   // First call the "official" version of this method
   super.onPause();
   Toast.makeText(this, "In onPause", 
         Toast.LENGTH_SHORT).show();
   Log.i("info", "In onPause");
}
@Override
public void onStop() {
   // First call the "official" version of this method
   super.onStop();
   Toast.makeText(this, "In onStop", 
         Toast.LENGTH_SHORT).show();
   Log.i("info", "In onStop");
}
@Override
public void onDestroy() {
   // First call the "official" version of this method
   super.onDestroy();
   Toast.makeText(this, "In onDestroy", 
         Toast.LENGTH_SHORT).show();
   Log.i("info", "In onDestroy");
}
```

首先，让我们谈谈代码本身。请注意，方法名称都对应于我们在本章前面讨论过的生命周期方法和阶段。请注意，所有方法声明都在`@Override`代码行之前。还要看到每个方法内部的第一行代码是`super.on...`。

这里到底发生了什么是以下内容：

+   Android 在我们已经讨论过的各个时间调用我们的方法。

+   `@Override`关键字表示这些方法替换/重写了作为 Android API 的一部分提供的方法的原始版本。请注意，我们看不到这些重写的方法，但它们是存在的，如果我们没有重写它们，Android 将调用这些原始版本而不是我们的版本。

在重写方法的每个方法内部的第一行代码`super.on...`，然后调用这些原始版本。因此，我们不仅仅是重写这些原始方法以添加我们自己的代码 - 我们还调用它们，它们的代码也被执行。

提示

对于好奇的人，关键字`super`是用于超类。随着我们的进展，我们将在几章中探讨方法重写和超类。

最后，您添加的代码将使每个方法输出一个`Toast`消息和一个`Log`消息。但是，输出的消息是不同的，可以通过双引号`""`之间的文本看出。输出的消息将清楚地表明是哪个方法产生了它们。

## 运行生命周期演示应用程序

现在我们已经查看了代码，我们可以玩一下我们的应用程序，并从发生的事情中了解生命周期：

1.  在设备或模拟器上运行应用程序。

1.  观察模拟器屏幕，您将看到以下`Toast`消息依次出现在屏幕上：**在 onCreate**，**在 onStart**和**在 onResume**。

1.  注意日志窗口中的以下消息。如果有太多的消息，请记住您可以通过将**日志级别**下拉菜单设置为**信息**来过滤它们。

```kt
             info:in onCreate
             info:in onStart
             info:in onResume
```

1.  现在点击模拟器或设备上的返回按钮。注意您会按照以下顺序收到三条`Toast`消息：**在 onPause**，**在 onStop**和**在 onDestroy**。验证我们在 logcat 窗口中有匹配的输出。

1.  接下来，运行另一个应用程序 - 也许是*第一章**，开始 Android 和 Java*中的*Hello Android*应用程序（但任何应用程序都可以）- 通过点击模拟器/设备屏幕上的图标。

1.  现在尝试以下操作：在模拟器上打开任务管理器。

1.  如果您不确定，可以参考*第三章**，探索 Android Studio 和项目结构*以及*在模拟器上使用模拟器作为真实设备*部分。

1.  现在您应该在设备上看到所有最近运行的应用程序。

1.  点击**Lifecycle Demo**应用程序，注意到通常的三个启动消息被显示出来。这是因为我们的应用程序先前被销毁了。

1.  然而，现在再次点击**任务管理器**按钮，并切换到**Hello Android**应用程序。注意这次只显示了**在 onPause**和**在 onStop**消息。验证我们在 logcat 中有匹配的输出。应用程序*没有*被销毁。

1.  现在，再次使用`onCreate`不需要重新运行应用程序。这是预期的，因为应用程序先前并没有被销毁，只是停止了。

接下来，让我们谈谈我们运行应用程序时看到的情况。

## 检查生命周期演示应用程序的输出

当我们第一次启动生命周期演示应用程序时，我们看到`onCreate`，`onStart`和`onResume`方法被调用。然后，当我们使用`onPause`，`onStop`和`onDestroy`方法关闭应用程序时被调用。

此外，我们从我们的代码中知道，所有这些方法的原始版本也被调用了，因为我们在每个重写的方法中都使用了`super.on...`代码，这是我们做的第一件事。

我们应用程序行为的怪癖出现在我们使用任务管理器在应用程序之间切换时 - 当从生命周期演示切换时，它没有被销毁，因此，当切换回来时，不需要运行`onCreate`。

我的 Toast 在哪里？

开头的三个和结尾的三个`Toast`消息被排队了，并且这些方法在它们被显示的时候已经完成了。您可以通过再次运行实验来验证这一点，会发现所有三个启动/关闭日志消息在第二个`Toast`消息甚至显示之前就已经输出了。然而，`Toast`消息确实加强了我们对顺序的了解，尽管不是时机。

当您按照上述步骤进行时，可能会得到略有不同的结果，这是完全可能的（但不太可能）。我们确定的是，当我们的应用程序在成千上万不同的设备上由数百万不同的用户运行时，这些用户对与设备交互的偏好也不同，Android 会在我们无法轻易预测的时候调用生命周期方法。

例如，当用户按下主页按钮退出应用程序时会发生什么？当我们连续打开两个应用程序，然后使用返回按钮切换到先前的应用程序时，会销毁还是只是停止应用程序？当用户在任务管理器中有十几个应用程序，操作系统需要销毁一些先前只是停止的应用程序时，我们的应用程序会成为“受害者”之一吗？

当然，你可以在模拟器上测试所有前面的场景。但结果只对你测试的那一次有效。不能保证每次都会显示相同的行为，当然也不会在每个不同的 Android 设备上显示相同的行为。

最后一些好消息！解决所有这些复杂性的方法是遵循一些简单的规则：

+   在`onCreate`方法中设置你的应用程序准备运行。

+   在`onResume`方法中加载用户的数据。

+   在`onPause`方法中保存用户的数据。

+   在`onDestroy`方法中整理你的应用程序，使其成为一个良好的 Android 公民。

+   在整本书中要注意一些情况，我们可能会想使用`onStart`和`onStop`。

如果我们按照上面提到的做（我们将在本书的过程中看到如何做），我们可以不再担心所有这些生命周期的东西，让 Android 来处理它！我们还可以重写一些其他方法。所以，让我们来看看它们。

## 一些其他重写的方法

你可能已经注意到，在使用基本活动模板的所有项目的代码中，还有另外两个自动生成的方法。它们是`onCreateOptionsMenu`和`onOptionsItemSelected`。大多数 Android 应用程序都有一个弹出菜单，所以 Android Studio 默认生成一个；包括使其工作的基本代码。

你可以在项目资源管理器中的`res/menu/menu_main.xml`中看到描述菜单的 XML。XML 代码的关键行是这样的：

```kt
<item
      android:id="@+id/action_settings"
      android:orderInCategory="100"
      android:title="@string/action_settings"
      app:showAsAction="never" />
```

这描述了一个带有文本**设置**的菜单**项目**。如果你运行使用我们迄今为止创建的基本活动模板构建的任何应用程序，你将会看到下面显示的按钮：

![图 6.2 - 设置按钮](img/B16773_06_02.jpg)

图 6.2 - 设置按钮

如果你点击按钮，你将会看到它的动作如下所示：

![图 6.3 - 设置选项](img/B16773_06_03.jpg)

图 6.3 - 设置选项

那么，`onCreateOptionsMenu`和`onOptionsItemSelected`方法是如何产生这些结果的呢？

`onCreateOptionsMenu`方法使用以下代码从`menu_main.xml`文件加载菜单：

```kt
getMenuInflater().inflate(R.menu.menu_main, menu);
```

它是由`onCreate`方法的默认版本调用的，这就是为什么我们没有看到它发生。

提示

我们将在*第十七章**，* *数据持久性和共享*中使用弹出菜单，在我们的应用程序的不同屏幕之间切换。

`onOptionsItemSelected`方法在用户点击菜单按钮时被调用。这个方法处理当项目被选中时会发生什么。现在什么都不会发生 - 它只是`返回 true`。

随意在这些方法中添加`Toast`和`Log`消息，以测试我刚刚描述的顺序和时间。我只是觉得现在是一个好时机来快速介绍这两个方法，因为它们一直潜伏在我们的代码中，没有介绍，我不想让它们感到被忽视。

现在我们已经了解了 Android 生命周期的工作方式，并介绍了一大堆可以重写以与生命周期交互的方法，我们最好学习一下 Java 的基础知识，这样我们就可以编写一些代码放入这些方法以及我们自己的方法了。

# Java 代码的结构 - 重新审视

我们已经看到，每次创建一个新的 Android 项目时，我们也会创建一个新的 Java**包**作为我们编写的代码的一种容器。

我们还学习了并尝试了`Log`和`Toast`。我们还使用了`AppCompatActivity`类，但使用方式与`Log`和`Toast`不同。你可能还记得迄今为止我们所有项目中的第一行代码，在`import`语句之后使用了`extends`关键字：

```kt
public class MainActivity extends AppCompatActivity {
```

当我们扩展一个类而不仅仅是导入它时，我们就把它变成了我们自己的。事实上，如果你再看一下代码行，你会发现我们正在创建一个新的类，名为`MainActivity`，但是基于 Android API 中的`AppCompatActivity`类。

重要提示

`AppCompatActivity`类是`Activity`类的稍微修改版本。它为较旧版本的 Android 提供了额外的功能，否则这些功能将不存在。关于`Activity`的所有讨论同样适用于`AppCompatActivity`。随着我们的进展，我们将看到`Activity`类中的一些变化。有可能你的`AppCompatActivity`已经被其他类替代，这取决于自此书写以来发生的变化。Android Studio 的更新有时会更改创建新项目时使用的默认`Activity`类。如果名称以`...Activity`结尾，那没关系，因为我们讨论过的和将要讨论的一切同样适用。我将简单地将这个类称为`Activity`。

总之：

+   我们可以导入类来使用它们。

+   我们可以扩展类来使用它们。

+   我们最终会创建自己的类。

这里的关键点是：

类以各种形式是 Java 代码的基础。Java 中的一切都是类或是类的一部分。

我们自己的类和其他人编写的类是我们代码的构建块，类中的方法包装了功能代码 - 执行工作的代码。

我们可以在扩展的类中编写方法；就像我们在*第二章**，初次接触：Java，XML 和 UI 设计师*中所做的`topClick`和`bottomClick`一样。此外，我们还重写了其他人已经编写的类中的方法，比如`onCreate`和`onPause`等等。

然而，我们在这些方法中放入的唯一代码是使用`Toast`和`Log`进行了一些调用。我们不会仅凭这些编写下一个杀手级应用程序。但现在我们可以迈出更多的步伐。

# 引入片段和生命周期

你可能还记得从*第二章**，初次接触：Java，XML 和 UI 设计师*中，Basic Activity 模板中的 Java 代码不仅包含在`MainActivity.java`文件中。还有`FirstFragment.java`和`SecondFragment.java`文件。我们了解到，这些文件包含了控制用户在 Basic Activity 模板应用的两个屏幕之间导航时发生的事情的代码。这两个文件中的代码结构与`MainActivity.java`文件中的代码不同。这里快速看一下`FirstFragment.java`：

```kt
public class FirstFragment extends Fragment {
    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState
    ) 
     {
        ...
    }

     ...
}
```

我从这个文件中省略了大部分代码，因为它对于这个介绍性讨论来说是不必要的。一个`Fragment`可以，而且在这个应用程序中确实代表着应用程序的一个屏幕。这个应用程序和其他包含`Fragment`类的应用程序的`Fragment`类由`Activity`类控制。我们将在*第二十四章**，设计模式，多个布局和片段*中仔细研究`Fragment`类。这里需要注意的是`Fragment`类有一个`onCreateView`方法。

当我们的应用程序使用一个或多个`Fragment`类的实例时，它们也将成为 Android 生命周期的一部分，`Fragment`类有自己的一组生命周期方法，其中`onCreateView`是其中之一。

操作系统的生命周期、`Activity`类和`Fragment`类之间的交互将在*第二十四章**，设计模式，多个布局和片段*中得到解释。现在只需要知道它们是相互关联的。

# 总结

我们已经了解了 Android 生命周期以及操作系统在特定时间调用设置方法。

我们还看到不仅我们可以调用我们的代码。操作系统也可以调用我们重写的方法中包含的代码。通过在各种重写的生命周期方法中添加适当的代码，我们可以确保在正确的时间执行正确的代码。

现在我们需要做的是学习如何编写更多的 Java 代码。在下一章中，我们将开始专注于 Java，因为我们已经在 Android 上有了很好的基础，所以我们将毫无问题地练习和运用我们所学到的一切。
