# 第七章。Kotlin 变量，运算符和表达式

在本章和下一章中，我们将学习和实践 Kotlin 的核心基础知识。事实上，我们将探索编程的主要原则。在本章中，我们将重点关注数据本身的创建和理解，在下一章中，我们将探索如何操作和响应数据。

本章将重点介绍 Kotlin 中最简单的数据类型-变量。我们将在第十五章 *处理数据和生成随机数*中重新讨论更复杂和强大的数据类型。

我们将学习的核心 Kotlin 基础知识适用于我们继承的类（例如`Activity`和`AppCompatActivity`）以及我们自己编写的类（正如我们将在第十章 *面向对象编程*中开始做的）。

由于在编写自己的类之前学习基础知识更为合理，我们将学习基础知识，然后使用扩展的`Activity`类`AppCompatActivity`来将这个新理论付诸实践。我们将再次使用`Log`和`Toast`来查看我们编码的结果。此外，我们将使用更多我们自己编写的函数（从按钮调用），以及`Activity`类的重写函数来触发我们代码的执行。然而，我们将在第九章 *Kotlin 函数*中学习有关函数的全部细节。

当我们转到第十章 *面向对象编程*，并开始编写我们自己的类，以及了解其他人编写的类如何工作时，我们在这里学到的一切也将适用于那时。

在本章结束时，您将能够舒适地编写 Kotlin 代码，在 Android 中创建和使用数据。本章将带您了解以下主题：

+   学习行话

+   学习更多关于代码注释

+   什么是变量？

+   变量类型

+   声明变量的不同方式

+   初始化变量

+   运算符和表达式

+   表达自己的演示应用程序

让我们首先找出变量究竟是什么。

# 学习行话

在整本书中，我将用简单的英语来解释许多技术概念。我不会要求您阅读以前未用非技术语言解释的 Kotlin 或 Android 概念的技术解释。

### 注

致新接触 Kotlin 的 Java 程序员的一句话：如果您已经做过一些 Java 编程，那么事情将变得奇怪！您甚至可能会发誓我犯了一些错误；也许您甚至会认为我忘记了在所有代码行的末尾添加分号！我敦促您继续阅读，因为我认为您会发现 Kotlin 比 Java 有一些优势，因为它更为简洁和表达力强。学习 Java 仍然有其存在的价值，因为大多数 Android API 仍然是 Java，即使整个 Android 社区立即放弃 Java（他们没有），也会有多年的遗留 Java 代码。我不会不断指出 Java 和 Kotlin 之间的差异，因为差异太多，这样的分析是不必要的。如果您感兴趣，我建议阅读这篇文章：[`yalantis.com/blog/kotlin-vs-java-syntax/`](https://yalantis.com/blog/kotlin-vs-java-syntax/)。最终，Kotlin 和 Java 编译为完全相同的 Dalvik 兼容 Java 字节码。事实上，Java 和 Kotlin 是 100%可互操作的，甚至可以在项目中混合使用。您甚至可以将 Java 代码粘贴到 Kotlin 项目中，它将立即转换为 Kotlin。

Kotlin 和 Android 社区充满了使用技术术语的人；因此，要加入并从这些社区中学习，您需要理解他们使用的术语。

因此，本书的方法是使用简单的语言学习概念或获得大致轮廓，同时将行话或技术术语作为学习的一部分引入。

Kotlin 语法是我们将 Kotlin 语言元素组合成可执行代码的方式。Kotlin 语法是我们使用的单词和将这些单词组成类似句子的结构的组合，这就是我们的代码。

这些 Kotlin“单词”数量众多，但是，分成小块来学习，它们肯定比任何人类语言更容易学习。我们称这些单词为**关键字**。

我相信，如果您能阅读简单的英语，那么您就可以学会 Kotlin，因为学习 Kotlin 比学习阅读英语要容易得多。那么，是什么让完成了这样一个初级 Kotlin 课程的人和专业程序员之间有所不同呢？

答案是语言学生和大师诗人之间的区别正是相同的东西。掌握 Kotlin 并不在于我们知道如何使用 Kotlin 关键字的数量，而在于我们如何使用它们。语言的掌握来自于实践、进一步的学习，以及更熟练地使用关键字。许多人认为编程与科学一样是一门艺术，这也有一定道理。

# 更多关于代码注释

随着您在编写 Kotlin 程序方面变得更加高级，您用于创建程序的解决方案将变得更长、更复杂。此外，正如我们将在后面的章节中看到的，Kotlin 旨在通过将代码分成单独的类（通常跨越多个文件）来管理复杂性。

**代码注释**是 Kotlin 文件的一部分，在程序执行中没有任何功能；也就是说，编译器会忽略它们。它们用于帮助程序员记录、解释和澄清他们的代码，以便在以后更容易理解自己，或者其他需要使用或更改代码的程序员。

我们已经看到了单行注释：

```kt
// this is a comment explaining what is going on
```

前面的注释以两个斜杠字符`//`开头。注释在行末结束。因此，该行上的任何内容仅供人阅读，而下一行上的内容（除非是另一个注释）需要是符合语法的 Kotlin 代码：

```kt
// I can write anything I like here
but this line will cause an error
```

我们可以使用多个单行注释，如下所示：

```kt
// Below is an important note
// I am an important note
// We can have as many single line comments like this as we like
```

单行注释也很有用，如果我们想临时禁用一行代码。我们可以在代码前面加上`//`，这样它就不会包含在程序中。回顾一下这段代码，它告诉 Android 加载我们的布局：

```kt
// setContentView(R.layout.activity_main)
```

在这种情况下，布局将不会加载，当运行时应用程序将显示空白屏幕，因为整行代码被编译器忽略。

### 注意

我们在第五章中看到了这一点，*使用 CardView 和 ScrollView 创建美丽的布局*，当我们暂时注释掉函数中的一行代码时。

Kotlin 中还有另一种类型的注释，称为**多行注释**。多行注释适用于跨越多行的较长注释，以及在代码文件顶部添加版权信息等内容。与单行注释一样，多行注释可以用于临时禁用代码；在这种情况下，通常跨越多行。

在`/*`字符和`*/`字符之间的所有内容都将被编译器忽略。看一下以下示例：

```kt
/*
   You can tell I am good at this because my
   code has so many helpful comments in it.
*/
```

多行注释中没有行数限制；最好使用的注释类型将取决于具体情况。在本书中，我将始终在文本中明确解释每一行代码，但您通常会在代码本身中发现大量的注释，这些注释会进一步解释、洞察或提供上下文。因此，彻底阅读所有代码总是一个好主意：

```kt
/*
   The winning lottery numbers for next Saturday are
   9,7,12,34,29,22
   But you still want to make Android apps?
*/
```

### 提示

所有最优秀的程序员都会在他们的代码中大量使用注释！

# 变量

我们可以将**变量**看作是一个命名的存储盒。我们选择一个名称，也许是`variableA`。这些名称是程序员进入用户 Android 设备内存的途径。

变量是内存中的值，当需要时可以通过它们的名称引用它们。

计算机内存有一个高度复杂的地址系统，幸运的是，我们不需要直接与之交互。Kotlin 变量允许我们为应用程序需要处理的所有数据制定自己方便的名称。操作系统将与物理（硬件）内存进行交互。

因此，我们可以将我们的 Android 设备内存看作是一个巨大的仓库，等待我们添加我们的变量。当我们为变量分配名称时，它们存储在仓库中，以备我们需要时使用。当我们使用我们的变量名称时，设备知道我们在引用什么。然后我们可以告诉它做一些事情，比如以下内容：

+   为`variableA`分配一个值

+   将`variableA`添加到`variableB`

+   测试`variableB`的值，并根据结果采取行动

在典型的应用程序中，我们可能会有一个名为`unreadMessages`的变量；也许用于保存用户未读消息的数量。当有新消息到达时，我们可以将其添加到其中，当用户阅读消息时，我们可以从中减去，并在应用程序的布局中的某个地方向用户显示它，以便他们知道有多少未读消息。

可能出现的情况包括以下几种：

+   用户收到三条新消息，所以将三条消息添加到`unreadMessages`的值中。

+   用户登录应用程序，因此使用`Toast`显示一条消息以及存储在`unreadMessages`中的值。

+   用户看到有几条消息来自他们不喜欢的人，并删除了两条消息。然后我们可以从`unreadMessages`中减去两个。

变量名是任意的，如果您不使用 Kotlin 限制的任何字符或关键字，可以随意命名变量。

然而，在实践中，最好采用**命名约定**，以便您的变量名称保持一致。在本书中，我们将使用一个简单的变量命名约定，以小写字母开头。当变量名中有多个单词时，第二个单词将以大写字母开头。这被称为**驼峰命名法**。

以下是一些驼峰命名法变量名称的示例：

+   `unreadMessages`

+   `contactName`

+   `isFriend`

在我们查看一些使用变量的实际 Kotlin 代码之前，我们需要首先看一下我们可以创建和使用的变量的**类型**。

## 变量的类型

即使是一个简单的应用程序也很容易想象会有相当多的变量。在前一节中，我们介绍了`unreadMessages`变量作为一个假设的例子。如果应用程序有一个联系人列表，并需要记住每个联系人的名字，那么我们可能需要为每个联系人创建变量。

当应用程序需要知道联系人是否也是朋友，还是普通联系人时，该怎么办？我们可能需要测试朋友状态的代码，然后将该联系人的消息添加到适当的文件夹中，以便用户知道它们是来自朋友还是其他人的消息。

计算机程序的另一个常见要求，包括 Android 应用程序，是正确或错误的测试。计算机程序使用**true**和**false**表示正确或错误的计算。

为了涵盖您可能想要存储或操作的许多其他类型的数据，Kotlin 使用不同**类型**的变量。

有许多类型的变量，我们甚至可以发明自己的类型。但是，现在我们将看一下最常用的 Kotlin 类型，这些类型将涵盖我们可能遇到的几乎所有情况。解释类型的最佳方法是通过一些示例。

我们已经讨论了假设的`unreadMessages`变量。这个变量当然是一个数字。

另一方面，假设的`contactName`变量将保存组成联系人姓名的字符或字母。

保存常规数字的类型称为**Int**（整数的缩写）类型，保存类似名称的数据的类型称为**String**。

以下是本书中将使用的变量类型列表：

+   `Int`：`Int`类型用于存储整数和整数。此类型可以存储超过 20 亿的值，包括负值。

+   `Long`：顾名思义，当需要更大的数字时，可以使用`Long`数据类型。`Long`变量可以存储高达 9,223,372,036,854,775,807 的数字。那是很多未读消息。`Long`变量有很多用途，但如果较小的变量可以胜任，我们应该使用它，因为我们的应用程序将使用更少的内存。

+   `Float`：此变量用于浮点数。也就是说，小数点后有精度的数字。由于数字的小数部分占用的内存空间与整数部分一样，因此与非浮点数相比，`Float`变量中可能的数字范围会减少。因此，除非我们的变量将使用额外的精度，否则`Float`不会是我们的数据类型选择。

+   `Double`：当`Float`变量中的精度不够时，我们有`Double`。

+   `Boolean`：我们将在整本书中使用大量布尔值。`Boolean`变量类型可以是`true`或`false`；没有其他选项。布尔值回答问题，例如：

+   联系人是朋友吗？

+   有新消息吗？

+   两个布尔值的例子足够了吗？

+   `Char`：这个类型存储单个字母数字字符。它本身不会改变世界，但如果我们把它们放在一起，它可能会有用。

+   `String`：字符串可以用来存储任何键盘字符。它类似于`Char`变量，但长度几乎可以是任意的。从联系人的姓名到整本书都可以存储在一个`String`中。我们将经常使用字符串，包括在本章中。

+   `Class`：这是最强大的数据类型，我们已经稍微讨论过了。我们将在第十章中深入探讨类，面向对象编程。

+   `Array`：这种类型有很多不同的变体，对于处理和组织大量数据至关重要。我们将在第十五章中探讨`Array`的变体，处理数据和生成随机数。

现在我们知道了变量是什么，以及有各种类型可供选择，我们几乎准备好看一些实际的 Kotlin 代码了。

## 声明和初始化变量

在我们可以使用刚讨论的变量类型之前，我们必须**声明**它们，以便编译器知道它们的存在，并且我们还必须**初始化**它们，以便它们保存一个值。

对于 Kotlin 中的每种变量类型，如`Int`、`Float`和`String`，我们可以使用两个关键字来声明它们：`val`和`var`。

`val`类型用于存储在应用程序启动之前或初始化期间由程序员决定的值，并且在执行过程中不能再次更改。`var`类型用于可以在执行过程中操作和更改的值。

因此，`val`类型只能读取。在技术术语中，它被称为**不可变**。`var`类型可读可写，这被称为**可变**。在执行过程中尝试更改`val`类型的值的代码将导致 Android Studio 显示错误，代码将无法编译。我们将在后面探讨`var`的规则。

有两种方式可以声明和初始化`String`类型；首先，通过使用`val`，如下所示：

```kt
val contactName: String = "Gordon Freeman"
```

在前面的代码中，声明了一个名为`contactName`的新`val`变量，类型为`String`，现在持有`Gordon Freeman`的值。

此外，`Gordon Freeman`文本现在是`contactName`在应用程序执行期间唯一可以持有的值。你可以尝试使用以下代码更改它：

```kt
contactName = "Apple Crumble" // Causes an error 
```

如果你将前面的代码粘贴到 Android 项目的`onCreate`函数中，你将看到以下内容：

![声明和初始化变量](img/B12806_07_01.jpg)

Android Studio 正在帮助我们强制执行我们的决定，使变量成为**常量**。当然，我们经常需要更改变量持有的值。当我们这样做时，我们将使用`var`；看一下接下来的两行代码：

```kt
var contactName: String = "Gordon Freeman" 
contactName = "Alyx Vance" // No problem
```

在前面的代码中，我们使用`var`声明了一个`String`类型，这次成功地将`contactName`持有的值更改为`Alyx Vance`。

这里要记住的一点是，如果变量在应用程序执行期间不需要更改，那么我们应该使用`val`，因为编译器可以帮助我们避免犯错。

让我们声明和初始化一些不同类型的变量：

```kt
val battleOfHastings: Int = 1066
val pi: Float = 3.14f
var worldRecord100m: Float = 9.63f
var millisecondsSince1970: Long = 1544693462311 
// True at 9:30am 13/12/2018
val beerIsTasty: Boolean = true
var isItRaining: Boolean = false
val appName: String = "Express Yourself"
var contactName: String = "Geralt"

// All the var variables can be reassigned
worldRecord100m = 9.58f
millisecondsSince1970 = 1544694713072 
// True at 9:51am 13/12/2018
contactName = "Vesemir"
```

请注意，在前面的代码中，当变量不太可能改变时，我将其声明为`val`，而当它可能会改变时，我将其声明为`var`。在开发应用程序时，你可以猜测是使用`val`还是`var`，如果有必要，你可以将`var`变量更改为`val`变量，或者反过来。另外，在前面的代码中，请注意`String`类型是用引号中的值进行初始化的，但`Int`、`Float`、`Long`和`Boolean`却不是。

## 使用类型推断节省击键

Kotlin 的设计目标是尽可能简洁。JetBrains 团队的目标之一是让开发人员用尽可能少的代码完成尽可能多的工作。我们将在整个 Kotlin 语言中看到这样的例子。如果你之前在其他语言，特别是 Java 中编码过，你会注意到输入量的显著减少。这种减少的第一个例子就是**类型推断**。

Kotlin 通常可以从上下文中推断出你需要的类型，如果是这种情况，那么你就不需要显式地写出类型；考虑下面的例子：

```kt
var contactName: String = "Xian Mei"
```

在前面的代码中，声明了一个名为`contactName`的`String`类型，并使用"Xian Mei"进行了初始化。如果你仔细想一想，它必须是一个`String`。幸运的是，Kotlin 编译器也能明白这一点。我们可以（而且应该）改进前面的代码，使用类型推断，就像下面的代码一样：

```kt
var contactName = "Xian Mei"
```

冒号和类型已被省略，但结果是相同的。

### 提示

Java 程序员也会注意到，Kotlin 代码不需要在每行末尾加上分号。然而，如果你喜欢分号，编译器也不会抱怨你在每行末尾加上分号：

```kt
var contactName = "Xian Mei"; // OK but superfluous
```

然而，我们必须记住，尽管我们没有明确指定`String`，它仍然是一个`String`类型——只是一个`String`类型。如果我们尝试对`String`类型不合适的操作，那么我们将会得到一个错误；例如，当我们尝试将其重新初始化为一个数字值时，就像这段代码中所做的那样：

```kt
contactName = 3.14f // Error
```

前面的代码将在 Android Studio 中标记，并且编译不会成功。以下是前一节代码中的所有声明和初始化，但这次使用了类型推断：

```kt
val battleOfHastings = 1066
val pi = 3.14f
var worldRecord100m = 9.63f
var millisecondsSince1970 = 1544693462311 
// True at 9:30am 13/12/2018
val beerIsTasty = true
var isItRaining = false
val appName = "Express Yourself"
var contactName =  "Geralt"
```

在接下来的两个部分中，我们将看到更多关于变量的类型推断，在后面的章节中，我们将使用类型推断来处理更复杂的类型，比如类、数组和集合。类型推断也将成为一个很好的时间节省器，使我们的代码更短、更易管理。

这可能听起来很明显，但值得一提的是，如果你在声明一个变量以便稍后初始化，那么类型推断是不可能的，就像下面的代码所示：

```kt
var widgetCount // Error
```

前面的代码会导致错误，应用程序将无法编译。

在使用类型推断时，变量的类型通常是显而易见的，但如果有任何疑问，您可以在 Android Studio 中选择一个变量，同时按*Shift* + *Ctrl* + *P*来获得一个方便的屏幕提示：

![使用类型推断节省按键](img/B12806_07_02.jpg)

偶尔省略`String`、`Int`或冒号（`:`）类型本身不会有太大变化，所以让我们学习如何通过将它们与**运算符**结合来制作**表达式**。

# 运算符和表达式

当然，在几乎任何程序中，我们都需要用这些变量的值来“做事情”。我们可以使用运算符来操作和改变变量。当我们将运算符和变量组合以获得结果时，这被称为表达式。

以下各节列出了最常见的 Kotlin 运算符，允许我们操作变量。您不需要记住它们，因为我们将在第一次使用它们时查看每行代码。

我们在上一节初始化变量时已经看到了第一个运算符，但我们将再次看到它变得更加冒险。

## 赋值运算符

这是赋值运算符：

```kt
=

```

它使运算符左侧的变量与右侧的值相同；例如，就像这行代码中的例子：

```kt
unreadMessages = newMessages
```

在前一行代码执行后，`unreadMessages`中存储的值将与`newMessages`中存储的值相同。

## 加法运算符

这是加法运算符：

```kt
+
```

它将运算符两侧的值相加。通常与赋值运算符一起使用。例如，它可以将具有数值的两个变量相加，就像下一行代码中的例子：

```kt
 unreadMessages = newMessages + unreadMessages 
```

一旦前面的代码执行了，`newMessages`和`unreadMessages`所保存的值的总和将存储在`unreadMessages`中。作为同样的例子，看看这行代码：

```kt
accountBalance = yesterdaysBalance + todaysDeposits
```

请注意，同时在运算符的两侧同时使用同一个变量是完全可以接受的（并且非常常见）。

## 减法运算符

这是减法运算符：

```kt
-
```

它将从运算符左侧的值中减去运算符右侧的值。通常与赋值运算符一起使用，就像这个例子中：

```kt
unreadMessages = unreadMessages - 1
```

减法运算符的另一个例子如下：

```kt
accountBalance = accountBalance - withdrawals
```

在前一行代码执行后，`accountBalance`将保持其原始值减去`withdrawals`中保存的值。

## 除法运算符

这是除法运算符：

```kt
/
```

它将左侧的数字除以右侧的数字。同样，通常与赋值运算符一起使用；这是一个例子行代码：

```kt
fairShare = numSweets / numChildren
```

如果在前一行代码中，`numSweets`为 9，`numChildren`为 3，则`fairShare`现在将保存值为 3。

## 乘法运算符

这是乘法运算符：

```kt
*
```

它将变量和数字相乘，与许多其他运算符一样，通常与赋值运算符一起使用；例如，看看这行代码：

```kt
answer = 10 * 10 
```

乘法运算符的另一个例子如下：

```kt
biggerAnswer = 10 * 10 * 10
```

在前两行代码执行后，`answer`保存的值为 100，`biggerAnswer`保存的值为 1000。

## 递增运算符

这是递增运算符：

```kt
   ++
```

递增运算符是将某物加一的快速方法。例如，看看下一行代码，它使用了加法运算符：

```kt
myVariable = myVariable + 1 
```

前一行代码的结果与这个更紧凑的代码相同：

```kt
myVariable ++ 
```

## 递减运算符

这是递减运算符：

```kt
      -- 
```

递减运算符（你可能已经猜到）是从某物中减去一个的快速方法。例如，看看下一行代码，它使用了减法运算符：

```kt
myVariable = myVariable -1
```

前一行代码与`myVariable --.`相同。

现在我们可以将这些新知识应用到一个工作中的应用程序中。

# 表达自己的演示应用程序

让我们尝试使用一些声明、赋值和运算符。当我们将这些元素捆绑到一些有意义的语法中时，我们称之为**表达式**。让我们写一个快速的应用程序来尝试一些。然后我们将使用`Toast`和`Log`来检查我们的结果。

创建一个名为`Express Yourself`的新项目，使用**空活动**项目模板，并将所有其他选项保持在它们通常的设置中。我们将在下载包的`Chapter07`文件夹中找到我们将在这个项目中编写的完成代码。

切换到编辑器中的**MainActivity**选项卡，我们将写一些代码。在`onCreate`函数中，在闭合大括号（`}`）之前，添加这个突出显示的代码：

```kt
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

 val name = "Nolan Bushnell"
 val yearOfBirth = 1943
 var currentYear = 2019
 var age: Int
    }
}
```

我们刚刚在`onCreate`函数中添加了四个变量。前两个是`val`变量，不能被改变。它们是一个`String`类型，保存一个人的名字，和一个`Int`类型，保存出生年份。类型在代码中没有明确提到；它们是被推断出来的。

接下来的两个变量是`var`变量。我们有一个`Int`类型来表示当前年份，和一个未初始化的`Int`类型来表示一个人的年龄。由于`age`变量未初始化，它的类型无法被推断，所以我们必须指定它。

在前面的代码之后，仍然在`onCreate`内部，添加以下行：

```kt
age = currentYear - yearOfBirth
Log.i("info", "$age")
```

运行应用程序，注意在 logcat 窗口中的以下输出：

```kt
info: 76

```

在`Log.i…`代码的引号中使用`$`符号表示我们想要输出`age`变量中存储的*值*，而不是字面上的单词"age"。

实际的值本身（76），表示存储在`yearOfBirth`（1943）中的值被减去存储在`currentYear`（2019）中的值，结果被用来初始化`age`变量。正如你将看到的，我们可以在引号中包含尽可能多的`$`符号，并将它们与文本甚至 Kotlin 表达式混合使用。这个特性被称为**字符串模板**。让我们尝试另一个字符串模板。

在`onCreate`函数内的前面的代码之后添加这两行代码：

```kt
currentYear++
Log.i("info", "$name 
was born in $yearOfBirth and is $age years old. 
Next year he will be ${currentYear - yearOfBirth} years old)")
```

关于这段代码的第一件事是，尽管它在这本书中格式化为四行，但当你输入到 Android Studio 中时，它必须输入为两行。第一行`currentYear++`，增加（加一）到存储在`currentYear`中的值。所有其余的代码都是一行。

运行应用程序，观察 logcat 窗口中的以下输出：

```kt
Nolan Bushnell was born in 1943 and is 76 years old. Next year he will be 77 years old

```

这段代码之所以有效，是因为 Kotlin 字符串模板。让我们分解这行相当长的代码。首先，我们像以前做过很多次一样调用`Log.i`函数。在第一个字符串中，我们传递了`"info"`，在第二个字符串中，我们传递了一些变量名，前面加上`$`符号，混合了一些字面文本。分解中最有趣的部分是倒数第二部分，因为我们使用一个表达式来形成字符串的一部分：

+   `$name`打印出 Nolan Bushnell

+   `Was born in`是字面文本

+   `$yearOfBirth`打印出 1943

+   字面文本`and is`接下来

+   `$currentAge`打印出 76

+   接下来是字面文本`years old`

+   字面文本`Next year he will be`接下来

+   `${currentYear - yearOfBirth}`是一个表达式，表达式的结果（77）被打印出来

+   最后的字面文本`years old`被打印出来以结束输出

这表明我们可以使用以下形式在`String`类型中包含任何有效的 Kotlin 表达式：

`${expression}`

在下一章中，我们将看到更复杂和强大的表达式。

# 总结

在本章中，我们学习了 Kotlin 中数据的基本构建块。我们探讨了不同类型及其不同用途的概述。我们还学会了如何使用字符串模板从字面值、变量和表达式构建字符串。我们还看到了在可能的情况下，我们可以和应该使用类型推断使我们的代码更简洁。

我们没有看到太多关于布尔变量类型，但在下一章中，当我们学习 Kotlin 的决策和循环时，我们将纠正这一错误。
