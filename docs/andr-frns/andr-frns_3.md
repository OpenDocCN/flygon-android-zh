# 第四章

# Android 文件系统和数据结构

### 本章信息

• 壳层中的数据

• 内存类型

• 文件系统

• 挂载的文件系统和目录结构

## 引言

虽然支持 Android 设备的底层硬件和软件非常吸引人，但法医分析师和安全工程师的主要关注点是获取、分析和理解设备上存储的数据。与讨论的其他主题一样，为了有效分析，了解存储的数据类型、存储位置、存储方式以及存储介质的物理特性等许多细微差别非常重要。所有这些因素在决定哪些数据可以恢复以及如何分析这些数据方面起着主要作用。

## 壳层中的数据

法医分析师主要关注可以从他们调查的设备中恢复的数据遗迹。Android 结合了在 Linux 中发现的众所周知的遗迹以及完全新的遗迹，例如 Dalvik VM 和 YAFFS2 文件系统。不同制造商采用的多种架构增加了复杂性。

尽管没有一本书或检查员能够彻底涵盖这个话题，但 Android 设备有一些共同的基本概念。文件系统、文件和其他遗迹是法医分析师为了使调查效果最大化必须了解的 Android 核心内容。

### 存储的数据类型

Android 设备存储大量数据，通常结合了个人和工作数据。应用程序是这些数据的主要来源，应用程序的来源包括：

• 随 Android 提供的应用程序

• 制造商安装的应用程序

• 由无线运营商安装的应用程序

• 额外的 Google/Android 应用

• 用户安装的应用程序，通常来自 Android 市场

第七章，Android 应用程序和法医分析，将详细研究这些应用程序中的许多，尽管本书的范围当然不可能涵盖所有可能性。在 Android 设备上找到的数据样本包括以下内容：

• 短信（SMS/MMS）

• 联系人

• 通话记录

• 电子邮件信息（Gmail、Yahoo、Exchange）

• 即时通讯/聊天

• GPS 坐标

• 照片/视频

• 网络历史

• 搜索历史

• 驾驶方向

• Facebook、Twitter 和其他社交媒体客户端

• 设备上存储的文件

• 音乐收藏

• 日程安排

• 财务信息

• 购物历史

• 文件共享

### 应用数据存储目录结构

Android 应用程序主要在两个位置存储数据：内部存储和外部存储，这两部分将在本章后面详细介绍。然而，对数据存储目录结构有一个高层次的了解是有帮助的。

在外部数据存储区域（SD 卡和模拟 SD 卡），应用程序可以按意愿在任何位置存储数据。然而，内部数据存储由 Android API 控制。当应用程序安装后（通过市场或直接提供给消费者的构建版本），内部数据存储在以包名命名的/data/data/子目录中。例如，默认的 Android 浏览器具有包名 com.android.browser，因此数据文件存储在/data/data/com.android.browser 中。尽管应用程序不要求存储数据文件，但大多数都会存储。

在应用程序的/data/data 子目录内部，有许多在许多应用程序中都能找到的标准目录以及开发者控制的目录。表 4.1 列出了最常见的标准子目录。

表 4.1 常见/data/data/<packageName>子目录

| shared_prefs | 以 XML 格式存储共享偏好设置的目录 |
| --- | --- |
| lib | 应用程序所需的自定义库文件 |
| files | 开发者保存到内部存储的文件 |
| cache | 应用程序缓存的文件，通常是网页浏览器或其他使用 WebKit 引擎的应用程序的缓存文件 |
| databases | SQLite 数据库和日志文件 |

表 4.1 仅展示了应用程序的/data/data 文件中最常见的子目录。在本书的后续内容中，我们将详细列出许多额外的文件夹和数据文件。

### 数据存储方式

Android 为开发者提供了五种在设备上存储数据的方法。法医检查员至少可以在五种格式中的四种中找到数据。因此，详细理解每一种格式非常重要。

持久数据存储在 NAND 闪存、SD 卡或网络上。具体来说，五种方法包括：

1. 共享偏好设置

2. 内部存储

3. 外部存储

4. SQLite

5. 网络

除了应用开发者存储的数据外，Linux 内核和 Android 堆栈还通过日志、调试和其他标准信息服务提供信息。

#### 共享偏好设置

共享偏好设置允许开发者以轻量级的 XML 格式存储基本数据类型的键值对。可以在偏好设置文件中存储的基本数据类型包括以下几种：

1. boolean: 真或假

2. float: 单精度 32 位 IEEE 754 浮点数

3. int: 32 位有符号二进制补码整数

4. long: 64 位有符号二进制补码整数

5. strings: 字符串值，通常为 UTF-8 编码

利用这些基本类型，开发者可以创建并保存为他们的应用程序提供动力的简单值。

共享偏好设置文件通常存储在应用程序数据目录的 shared_pref 文件夹中，并以.xml 结尾。在我们参考的 HTC Incredible Android 手机上，共享偏好设置目录包含五个 XML 文件：

![图像](img/F100044u04-01-9781597496513.jpg)

com.android.phone_preferences.xml 首选项文件包含了 int、boolean 和 string 首选项的示例：

![图像](img/F100044u04-02-9781597496513.jpg)

如你所见，XML 文件在文件开始处描述了字符串编码类型，在这种情况下是 UTF-8。有三个首选项保存了各种设置和特性。从法医的角度来看，最有趣的可能就是 updateAreaCode.xml 了。

![图像](img/F100044u04-03-9781597496513.jpg)

该文件查询了移动目录号码（MDN）并将设备的区号存储在此文件中，推测是为了在支持该功能的地区提供七位数字拨号选项。

由于许多应用程序利用轻量级的 Shared Preferences 方法来存储键值对，因此它可以成为丰富的法医数据来源。特别是当检查员可以恢复 XML 首选项文件的旧版本或已删除版本时，这一点尤其正确。

#### 内部存储的文件

文件允许开发者存储更复杂的数据结构，并保存在文件内部存储的几个位置。这些文件存储在应用程序的/data/data 子目录中，开发者可以控制文件类型、名称和位置。默认情况下，只有应用程序可以读取这些文件，即使设备所有者没有 root 权限也无法查看这些文件。开发者可以覆盖安全设置，允许其他进程读取甚至更新文件。

提示

### 识别自定义文件

确定应用程序子目录中哪些文件属于这一类别的最佳方式是通过排除法。基本上，应用程序中/data/data/子目录下不属于 shared_prefs、lib、cache 或 databases 子目录的任何文件都是开发者创建和控制的文件。

让我们研究一下 com.google.android.apps.maps，它提供了保存于内部存储的文件的好例子：

![图像](img/F100044u04-04-9781597496513.jpg)

应用程序使用了大多数可用的存储机制，在内部存储的 app_ 和 files 目录中存储文件。app_ 目录有多个子目录和一个未知的 cache_r.m 文件格式：

![图像](img/F100044u04-05-9781597496513.jpg)

files 目录存储了应用程序显示和更新 Google Maps 所需的大量数据文件：

![图像](img/F100044u04-06a-9781597496513.jpg)

![图像](img/F100044u04-06b-9781597496513.jpg)

这些文件清楚地表明了可能对法医分析师或安全工程师感兴趣的数据。在第七章，Android 应用程序和法医分析中，将更详细地介绍应用程序及其存储数据的数据分析。

#### 外部存储的文件

虽然存储在内部设备存储上的文件具有严格的安全性和位置参数，但各种外部存储设备上的文件限制要少得多。

首先，使用可移动 SD 卡的一个重要动机（除了成本之外）是数据可以在其他设备上使用，可能是升级后的 Android 设备。如果消费者购买了一部新的 Android 设备，插入之前包含他们所有家庭成员照片和视频的 SD 卡，却发现自己无法访问这些内容，他们将会非常沮丧。

为了便于在桌面计算机上挂载 SD 卡以共享文件，SD 卡通常使用微软的 FAT32 文件系统格式化。虽然该文件系统得到了广泛支持，但它缺少如 ext3、ext4、yaffs2、hfsplus 等文件系统内置的细粒度安全机制。因此，默认情况下，文件无法强制执行权限。

例如，前面提到的 com.google.android.apps.maps 应用程序也会在 Android/data 子目录下的 SD 卡上存储数据。以下是来自参考的 HTC Incredible SD 卡（挂载在 /mnt/sdcard）的文件和目录列表：

![image](img/F100044u04-07-9781597496513.jpg)

同样，HTC Incredible 配备了一个存储在 NAND 闪存上的模拟 SD 卡。模拟 SD 卡挂载在 /mnt/emmc 上。以下是存储相册 JFIF 缩略图的子目录列表：

![image](img/F100044u04-08-9781597496513.jpg)

如你所见，开发者对外部 SD 卡和模拟 SD 卡上的文件名称、格式和位置有着很大的控制权。

#### SQLite

另一个开发者可以利用的 NAND/SD 卡存储方式是一种特定类型的文件——SQLite 数据库。数据库用于结构化数据存储，而 SQLite 是一个在许多移动系统以及传统操作系统上广泛出现的流行数据库格式。

SQLite 因多种原因而受到欢迎。值得注意的是整个代码库质量高，开源，并且发布到公共领域。文件格式和程序本身非常紧凑，在不到几百千字节的空间内实现了显著的功能。与 Oracle、MySQL 和 Microsoft 的 SQL Server 等更传统的关系数据库管理系统（RDBMS）不同，SQLite 整个数据库包含在一个跨平台的单一文件中。

Android SDK 提供了专门的 API，允许开发者在他们的应用程序中使用 SQLite 数据库。SQLite 文件通常存储在内部存储的 /data/data/<packageName>/databases 目录下。然而，创建数据库在其他位置并没有限制。

SQLite 数据库是丰富的法医数据来源。基于 WebKit 开源项目（[`webkit.org/`](http://webkit.org/)）的内置 Android 浏览器提供了一个很好的例子。在我们参考的 HTC Incredible 中，有 28 个 SQLite 数据库位于 /data/data/com.android.webkit 的子目录下。在这个例子中，五个子目录如下：

• app_icons：一个网页图标数据库

• app_cache：一个包含网页应用数据缓存的数据库

• app_geolocation: 与 GPS 位置和权限相关的 2 个数据库

• app_databases: 21 个数据库，为支持网站提供本地数据库存储

• databases: 浏览器和浏览器缓存的 3 个数据库

从这些文件中恢复具有取证价值的数据的可能性非常高。

#### 网络

开发者可用的最后一种数据存储机制是网络，这是设计为网络感知设备的一个关键优势。最初，很少有应用程序利用网络作为存储选项。然而，随着 SDK、应用程序和设备的成熟，网络存储选项正在被更多地利用。

安卓开发者网站为那些对网络存储感兴趣的人提供了非常少的详细信息。他们的整个文档只有短短两句话长(Data storage, n.d.)。

当网络可用时，您可以使用网络来存储和检索您自己的基于网络服务的数据。要进行网络操作，请使用以下软件包中的类：

• java.net.^∗

• android.net.^∗

文档中提到的软件包基本上为开发者提供了与网络、网络服务器等交互所需的基础 API。利用网络的程序需要更多的自定义编码，而且并非所有具有取证价值的数据都存储在设备上，但通常可以恢复重要的配置和数据库文件。

例如（作为对第七章，Android 应用程序和取证分析的预览），Dropbox 是一个受欢迎的文件共享网站，它有适用于 Android、黑莓和 iOS 设备的移动应用。他们当前的 Android 应用程序（版本 1.0.3.0）在 Android Market 上的下载量已超过 25 万次，拥有超过 35,000 个用户评分，大多数评分都很高。安装应用后，您可以在/data/data/com.dropbox.android 找到应用程序文件夹，其中包括四个标准目录：

![图像](img/F100044u04-09-9781597496513.jpg)

log.txt 是活动详细日志，以下提供几行以供参考：

![图像](img/F100044u04-10-9781597496513.jpg)

在上述列表中强调了一些可能感兴趣的项，具体包括：

1. 所有操作都有时间戳

2. 成功认证用户，提供了用户名

3. 从图库导入图片

4. SD 卡上的特定文件已上传

5. Dropbox 服务被电话中断

该应用还有一个共享偏好文件：

![图像](img/F100044u04-11-9781597496513.jpg)

使用 sqlite3 命令行程序快速检查 db.db，可以得到以下数据（您也可以使用图形化 SQLite 浏览器查看数据库）：

![图像](img/F100044u04-12-9781597496513.jpg)

数据库提供了关于 Dropbox 应用程序、设备以及最终用户和可能交互的人的重要法医和安全数据。"Android intro.pdf"文件在安装并登录 Android 应用时，由 Dropbox 自动同步到 Dropbox 账户。当查看共享的 PDF 文件时，它被缓存在 SD 卡上。关于文件及其使用的额外元数据包含在数据库中。尽管 Dropbox 在其应用程序中广泛使用网络数据存储，我们仍然可以恢复有用的信息。

#### 内核、系统和应用程序日志

在标准的 Linux 文件系统中，法医分析师和安全工程师还可以找到与调查或审计相关的文件和信息。不幸的是，这个范围相当广泛且令人望而却步，但我们可以至少提供一个查找相关信息起点的地方。

日志文件和调试是开发人员和系统管理员维护系统和应用程序的两种常见且有效的方法。它提供了对应用程序以及运行它们的系统的洞察。虽然并非在每种情况下都适用，但只需检查 Android 设备上的各种日志和调试文件，就可能获得重要信息。

##### Linux 内核日志

Linux 内核是 Linux 操作系统的底层抽象接口，它提供了访问设备硬件的能力。由于内核在设备上的所有功能中都起着核心作用，因此记录关键事件和活动的能力非常有价值。在 Linux（以及 Android）设备上，可以通过命令 dmesg 访问内核日志。这将把所有可用的内核信息打印到控制台，部分信息如下所示：

![image](img/F100044u04-13a-9781597496513.jpg)

![image](img/F100044u04-13b-9781597496513.jpg)

您可能会注意到，数据非常详细且属于低级别。然而，它可以提供重要时间戳和活动信息，以及关于设备启动的大量信息。但是，如果设备最近没有重启，那么启动时的初始日志将不再可用。

这个命令在设备上不需要任何特殊权限，只需启用 USB 调试即可。如果您在设备或模拟器上运行此命令，您会注意到屏幕上显示了过多的数据。您可以通过将 dmesg 的内容传递（或发送）到名为 wc（代表单词计数）的程序，并指示它计算日志中的行数来确定日志中的总行数：

![image](img/F100044u04-14-9781597496513.jpg)

因此，在参考的 HTC Incredible 上，我们有 1859 行内核日志。如果您需要更仔细地检查信息，或者将其包含在报告中，您可以使用以下命令将 dmesg 的输出重定向到文件中：

![image](img/F100044u04-15-9781597496513.jpg)

你现在可以通过在文本编辑器或显示程序中打开 dmesg.log 来检查可用内核日志的内容。

##### logcat

安卓有几个额外的调试技术可用。一个程序，logcat，显示一个持续更新的系统和应用程序调试信息列表。

![image](img/F100044u04-16a-9781597496513.jpg)

![image](img/F100044u04-16b-9781597496513.jpg)

快速浏览上述的小日志片段可以揭示

• 经度和纬度数据

• 日期/时间信息

• 应用程序详情

日志记录非常详细，这里提供的样本只是可用内容的一小部分。每个日志消息都以消息类型指示符开始，在表 4.2 中有描述。

表 4.2 日志方法类型

| 消息类型 | 描述 |
| --- | --- |
| V | 详细 |
| D | 调试 |
| I | 信息 |
| W | 警告 |
| E | 错误 |
| F | 致命 |
| S | 静默 |

logcat 程序还提供了完整的蜂窝无线调试日志，可以通过以下命令查看（仅包含部分无线日志）：

![image](img/F100044u04-17-9781597496513.jpg)

尽管日志记录详细且通常难以理解，但扫描上述日志可以提供如下信息：

• 事件时间（以 Unix 纪元时间表示，例如，t=1296218163）

• 用于与蜂窝调制解调器通信的 AT 命令

• 接收者、大小、时间和编码的短信信息

• 设备的蜂窝 IP 地址、网络和位置信息

• 无线运营商信息

这些信息属于非常底层的。然而，如果恢复这些日志，它们可以揭示关于设备的重要信息。

注意事项

### Unix 纪元时间

Unix 纪元时间是基于 Unix/Linux 系统的的时间戳常见格式。时间戳是一个整数值，表示自 1970 年 1 月 1 日以来的秒数（或毫秒数）。使用秒的时间戳通常有 10 位数字，而使用毫秒的时间戳将有 13 位数字。时间戳在第七章中有更详细的介绍。

logcat 最后一个特性是事件日志显示：

![image](img/F100044u04-18-9781597496513.jpg)

同样，这个日志非常详细。然而，随着系统内发生不同的事件，它们在这里记录了大量的信息。在之前的日志片段中，我们可以看到对 mmssms.db 的 INSERT 和 SELECT 语句，该数据库用于存储短信。

##### dumpsys

下一个日志机制是通过一个名为 dumpsys 的命令访问的。

Dumpsys 提供了有关服务、内存和其他系统详细信息的信息，这些信息可能很有帮助。提供的一些信息类型包括

• 当前正在运行的服务

• 每个服务的转储

• 当前活动管理器状态下的服务、广播、待定意图、活动和进程

• 包括内存、进程 ID（PIDs）、数据库等在内的进程信息

接下来列出了来自参考 HTC Incredible dumpsys 的样本部分，并简要解释了这些数据对法医分析师或安全工程师可能具有的价值。

首先，你按照如下方式运行 dumpsys 命令：

![图像](img/F100044u04-19-9781597496513.jpg)

涉及“account”服务详细信息的部分，包含了关于设备上使用的各种账户的宝贵信息。

![图像](img/F100044u04-20-9781597496513.jpg)

你不仅可以看到使用的程序，还可以看到特定于用户的账户名称。例如，上述信息透露了：

• 具有用户名 book@viaforensics.com 的 Google 账户

• 与用户名 book@viaforensics.com 的 Exchange ActiveSync (EAS) 账户（与上述 Google 账户分开）

• 安德鲁·胡格的 Facebook 账户

• viaforensics 的 Twitter 账户

• 为 personal@emailaddress.com 的 Google 账户（设备上的第二个）

在日志进一步内容中，同样提供了最后 10 次同步的实际时间戳：

![图像](img/F100044u04-21-9781597496513.jpg)

另一个服务被幽默地命名为“iphonesubinfo”，尽管名字相似，但显然与苹果的 iPhone 无关。

![图像](img/F100044u04-22-9781597496513.jpg)

从这一部分可以获取手机类型和设备 ID（已更改）。设备 ID 不是设备的序列号，而是移动设备标识符（MEID），在 CDMA 网络上唯一标识设备。

另一个重要的信息来源是位置服务，它显示最后已知的位置信息及时刻。

![图像](img/F100044u04-23-9781597496513.jpg)

安卓系统中的大多数时间戳是从 1970 年 1 月 1 日以来的毫秒数，这是 Unix 纪元时间——以毫秒为单位，而不是秒。由于大多数工具基于秒转换 Unix 纪元，你可以将数字除以 1000，然后使用标准公式。如果你构建了 Ubuntu 工作站，你可以使用以下命令行进行转换：

![图像](img/F100044u04-24-9781597496513.jpg)

这将在工作站时区输出。你可以使用命令行上的各种开关控制时区、格式和其他许多参数。要查看所有可能性，请运行“date --help”或“man date”。

检查上述三个缓存位置，我们可以看到系统从 GPS 卫星和蜂窝塔在以下时间缓存了位置信息：

1. GPS：2011 年 1 月 27 日 13:51:13 CST

2. 蜂窝：2011 年 1 月 28 日 09:56:48 CST

记录的位置信息是准确的，因此提供了设备位置的极佳历史信息。

网络状态部分提供了额外的信息，包括关于手机塔的更详细信息：

![图像](img/F100044u04-25a-9781597496513.jpg)

![图像](img/F100044u04-25b-9781597496513.jpg)

需要指出的是，尽管技术细节繁多，但内存信息部分对于每个进程 ID（PID）都会输出：

![image](img/F100044u04-26-9781597496513.jpg)

这不仅有助于确定哪些进程正在运行，还有助于确定它们访问的数据库。例如，在某些情况下，调查人员可能需要更好地了解收到电子邮件时更新了哪些信息。在上面的列表中，你可以看到电子邮件应用程序（com.htc.android.mail）不仅更新了 mail.db，还更新了与 people_db 相关联的两个与网络相关的数据库。在解释 Android 设备上的数据如何相互关联时，这些信息可能非常有用。

##### dumpstate

另一个调试命令是 dumpstate，它将之前的调试部分与系统信息结合在一起。与其他命令一样，你使用以下命令运行：

![image](img/F100044u04-27-9781597496513.jpg)

在运行 adbd 并以 root 权限的模拟器或设备上显示的第一个部分是应用程序的堆栈跟踪。然而，在参考的 HTC 设备上，dumpstate 命令返回权限被拒绝。紧接着是关于设备、构建版本、无线电、网络和内核详情的基本信息。剩余的日志包含了表 4.3 中概述的部分。

| 表 4.3 Dumpstate 部分 |

| 部分 | 文件或命令 |
| --- | --- |
| 堆栈跟踪 | N/A |
| 设备信息 | N/A |
| 系统 | N/A |
| 内存信息 | /proc/meminfo |
| CPU 信息 | top -n 1 -d 1 -m 30 -t |
| Procrank | (procrank) |
| 虚拟内存统计 | /proc/vmstat |
| Vmalloc 信息 | /proc/vmallocinfo |
| Slab 信息 | /proc/slabinfo |
| Zoneinfo | /proc/zoneinfo |
| 系统日志 | logcat -v time -d ^∗:v |
| 事件日志 | logcat -b events -v time -d ^∗:v |
| 无线电日志 | logcat -b radio -v time -d ^∗:v |
| 网络接口 | netcfg |
| 网络路由 | /proc/net/route |
| Arp 缓存 | /proc/net/arp |
| 转储 Wi-Fi 固件日志 | su root dhdutil -i eth0 upload /data/local/tmp/wlan_crash.dump |
| 系统属性 | N/A |
| 内核日志 | dmesg |
| 内核唤醒锁 | /proc/wakelocks |
| 内核 cpufreq | /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state |
| Vold 转储 | vdc dump |
| 安全容器 | vdc asec list |
| 进程 | ps -p |
| 进程和线程 | ps -t -p -p |
| Librank | librank |
| Binder 失败事务日志 | /proc/binder/failed_transaction_log |
| Binder 事务日志 | /proc/binder/transaction_log |
| Binder 事务 | /proc/binder/transactions |
| Binder 统计 | /proc/binder/stats |
| Binder 进程状态 | sh -c cat /proc/binder/proc/^∗ -p |
| 文件系统和空闲空间 | df |
| 包设置 | /data/system/packages.xml: 2011-01-26 09:18:02 |
| 包 UID 错误 | /data/system/uiderrors.txt: 2010-11-14 22:52:26 |
| 最后的 kmsg | /proc/last_kmsg |
| 最后的无线电日志 | parse_radio_log /proc/last_radio_log |
| 最后的恐慌控制台 | /data/dontpanic/apanic_console |
| 最后的恐慌线程 | /data/dontpanic/apanic_threads |
| 被阻塞进程的等待通道 | 不适用 |
| 背光 | 不适用 |
| `dumpsys` | `dumpsys` |

##### `bugreport`

最后一个调试命令在之前命令的基础上构建，并将`logcat`、`dumpsys`和`dumpstate`的调试输出组合在一个命令中，并在屏幕上显示，以便提交错误报告。该命令如下运行： 

![image](img/F100044u04-28-9781597496513.jpg)

它首先运行`dumpstate`。在针对参考的 HTC Incredible 运行时，输出被保存到文件中，然后执行了行数统计：

![image](img/F100044u04-29-9781597496513.jpg)

如您所见，报告生成了超过 42,000 行的调试信息，其中包含时间戳、应用数据以及系统信息。解析这些数据将得到有用的信息。然而，如果手动处理这些数据，任务将非常艰巨。

## 内存类型

如第二章所述，Android 设备有两种主要类型的内存，易失性（RAM）和非易失性（NAND 闪存）内存。每种内存都能从不同角度了解设备数据。

### RAM

系统使用 RAM 加载、执行和操作操作系统、应用程序或数据的关键部分，并在重启时不会保存。与传统计算机一样，RAM 可能包含非常重要的信息，应用程序使用这些信息来处理数据。以下是一些例子：

• 密码

• 加密密钥

• 用户名

• 应用数据

• 系统进程和服务的数据

最近，出现了用于检查 Android 内存的解决方案。其中一种技术由安全研究员 Thomas Cannon 在他的博客上记录，我们将详细逐步介绍（Android reverse engineering, n.d.）。

Android 提供了一个机制，通过向应用发送特殊信号（SIGUSR1）将应用的内存转储到文件中。要发送信号，你需要知道应用的 PID，你可以使用`ps`命令找到：

![image](img/F100044u04-30-9781597496513.jpg)

`ps`命令列出了所有系统和应用进程以及父进程 ID、内存信息以及名称。由于典型设备上有许多运行中的进程，上述列表仅显示输出的一部分。

接下来，我们需要在设备上以 root 权限运行交互式 shell，并设置`/data/misc`具有足够的权限来写入，然后读取内存转储：

![image](img/F100044u04-31-9781597496513.jpg)

警告

### 更改文件夹权限

`chmod`命令用于更改`/data/misc`文件夹的权限，授予系统上所有用户账户读、写和执行访问权限。进行此更改是为了成功进行内存转储。然而，这是法医分析师明显进行的系统更改。如果此类分析是合理的，应在报告中记录此更改，理想情况下，在内存转储后应将文件夹权限恢复到默认设置。

从这里，我们可以发送进行内存转储所需的信号，并显示目录内容：

![image](img/F100044u04-32-9781597496513.jpg)

文件 heap-dump-tm1296350817-pid1294.hprof 包含了内存转储，我们可以退出交互式 adb shell 并将文件拉取到本地工作站进行分析：

![图像](img/F100044u04-33-9781597496513.jpg)

从那里，使用你手头上的任何内存分析技术。例如，你可以使用 strings 命令提取 ASCII 字符串：

![图像](img/F100044u04-34-9781597496513.jpg)

然后查看文件内容。快速扫描 Gmail 的内存提供了有关应用程序引用的各种加密库以及 HTTP 流量的信息：

![图像](img/F100044u04-35-9781597496513.jpg)

使用名为 JSON 的文件格式的 Facebook 应用程序，产生了以下内容：

![图像](img/F100044u04-36-9781597496513.jpg)

在将以下示例包含在本书中之前，已经对其进行了清理。但是，你可以看到时间戳、资料更新、朋友信息、签到等信息。

对 Android 设备的内存分析可以深入了解设备的内部结构以及有关设备主人的关键信息。随着时间的推移，预计市场上会有更多解决方案来解决 Android 内存分析的问题。

#### NAND 闪存

与 RAM 不同，NAND 闪存是非易失性的，因此即使设备没有电源或重新启动，数据也能得到保留。NAND 闪存不仅用于存储系统文件，还用于存储用户数据的很大一部分。

NAND 闪存具有与现代硬盘中的磁性介质截然不同的特性。这些特性使 NAND 闪存成为移动设备的理想存储选择，同时也为程序员带来了许多挑战，为法医分析师提供了机会。

首先，NAND 闪存没有像传统磁性硬盘中的旋转盘片和机械臂那样的机械移动部件。这提高了耐用性，并减少了设备的大小和功耗。内存以一个或多个芯片的形式分布，这些芯片通常将 NAND 闪存和 RAM（MCP，请参阅第二章）集成在一起，并直接集成在设备的电路板上。

NAND 闪存还具有非常高的密度，并且制造起来成本效益高。这当然使其深受制造商的喜爱。一般而言，制造过程和技术的一个副作用是，NAND 闪存在出厂时实际上就带有坏块。制造商通常会在制造过程中测试内存，并在 NAND 闪存上的特定结构中标记坏块，这在他们的文档中有描述。直接与 NAND 闪存交互的软件可以读取制造商的坏块标记，并常常实现一个坏块表，该表可以在系统上逻辑跟踪坏块，并将其从运行中移除。这大大加快了坏块检测和管理的速度。因此，尽管 NAND 闪存在物理上比旋转盘片更耐用，但其错误率要高得多，在开发和使用过程中必须考虑这一点。

NAND 闪存的另一个重要限制是，在块(block)无法再存储数据之前，其写入/擦除的生命周期非常有限。这个生命周期因设备而异，在很大程度上受到每个 NAND 闪存单元存储的数据量影响，这是存储 1 或 0 位(bit)的核心构建块。如果单元仅存储单个位（单层单元或 SLC），则 NAND 闪存的评率为大约 10 万次写入/擦除周期，数据保持一年。然而，由于制造商（及消费者）要求在相似大小或更小的设备中存储更多的数据，NAND 闪存很少使用 SLC。该技术已经发展到多层单元（MLC），在这种单元中，每个单元可以存储两个、三个甚至更多的位。然而，这不仅使制造过程复杂化，减缓了写入/擦除周期，还显著降低了设备的耐用性。一个典型的存储每个单元两个位的 MLC NAND 闪存在耐久性（以一年数据保持期限衡量）上降低了 10 倍，大约为 1 万次写入/擦除周期。随着每个单元的位密度增加，耐久性继续下降，这显然必须由控制设备来解决。

与 RAM 和 NOR 闪存这类通常用于计算机基本输入输出系统或 BIOS 的闪存不同，NAND 闪存不能实现随机访问。相反，数据访问是通过一个分配单元来实现的，这个单元被称为页(page)或块(chunk)，通常大小在 512 到 2048 字节之间，但随着 NAND 闪存整体大小的增加，这个数值通常会增大。尽管 NAND 闪存不能像 RAM 那样提供快速随机访问，但其访问时间仍然相当快，因为它不需要像传统旋转硬盘那样使用机械盘片和磁臂移动。

注意

### 页(page)与块(chunk)的区别

在整本书中，我们将把“页”和“块”同义地使用，以指代 NAND 闪存中提到的低级数据分配单元。虽然分配单元通常被称为页，但作为 Android 关键组件的 YAFFS2 文件系统通常将分配单元称为块。

然后，这些数据块被组织成一个更大的逻辑单元，称为块，它通常比传统的 512B 硬盘扇区大得多。在大多数 Android 设备中，NAND 闪存块包含 64 个数据块，每个块 2048 字节。64 × 2 KB 的块大小为 128 KB。当然，随着时间的推移，这可能会发生变化，由 NAND 闪存制造商控制。当一个块被分配用于写入时，块内的数据块会按顺序写入。

NAND 闪存的另一个非常重要的特性是可用于读取和写入的操作：

• 读取（页）

• 写入（页）

• 擦除（块）

虽然可以读取或写入单个数据块，但擦除操作只能在块级别进行。当一个块被擦除时，整个块会用 1 或 0xFF（十六进制）覆盖。

注意

### NAND 闪存的擦除操作

*擦除操作是 NAND 闪存中将 0 更改为 1 的唯一机制。*这一点值得强调。在传统硬盘中，如果一个值从 0 更改为 1（或反之），程序只需在硬盘上找到该值并施加适当的电压以更改并存储新值。然而，NAND 闪存的基本架构只提供了一个机制来将 0 更改为 1，即通过在块级别应用的擦除功能，而不是单个页级别。因此，一个页只能写入一次，如果需要更改页的值，则必须擦除整个块，然后才能写入页。

这里举一个使用单个字节以简化说明的例子：假设这个特定的字节存储了十进制值 179，我们想要加上 39 得到总值为 218。对于那些不熟悉在十进制（base10）、十六进制（base16）和二进制（base2）之间转换数字的人来说，Windows、Mac OS X 和 Ubuntu Linux 的内置计算器程序提供了程序员模式，可以执行这些转换。对于上面的数字，我们在不同数制之间的转换如表 4.4 所示。

表 4.4 整数的十进制、十六进制和二进制表示

| 十进制（base10） | 十六进制（base16） | 二进制（base2） |
| --- | --- | --- |
| 179 | 0xB3 | 1011 0011 |
| 218 | 0xDA | 1101 1010 |

因此，值 179 包含三个 0，其中两个需要改变为 1 以表示我们新的值 218。然而，NAND 闪存在没有擦除整个块的情况下无法进行这种改变。所以，如果这个单个字节在没有擦除的情况下尝试，结果将是 146，而不是 218。以下是这种情况发生的原因：

![image](img/F100044u04-37-9781597496513.jpg)

由于字节并不全是 1（0xFF），写入周期中唯一成功的是 1 保持为 1 或变为 0 的部分。每当写入功能遇到 0 并请求变为 1 时，它就会失败并保持 0 值。结果字节为 0x92 或 10 进制的 146——明显不是预期的值。另一种描述写入功能的方式是，它只将带电的 1 值按需改为 0，这相当于两个值的“逻辑与”。

总结来说，一个数据块只能写入一次，如果需要重写，必须先擦除整个块。

如你所见，NAND 闪存有其各种限制，因此开发人员和文件系统必须了解闪存特性，才能在限制内有效工作。与带有固件来管理设备（包括坏块）的传统硬盘不同，Android 设备中使用的 NAND 闪存没有配备控制器。所有内存的管理都必须在软件层面实现，并与 NAND 闪存进行接口。部署的两个重要技术是错误校正码（ECC）和磨损均衡。这两者对法医分析和数据恢复都有重大影响。

首先，ECC 是一种在读写操作中检测数据错误并即时纠正某些错误的算法。由于 NAND 闪存在使用过程中会逐渐退化，系统必须能够检测到页面或块何时出现问题并恢复存储在那里的数据。当错误次数或失败操作超过一定数量（通常是三次失败操作）时，页面或块将被标记为坏块，并添加到坏块表中。

在 Android 上有效管理 NAND 闪存的第二个重要算法是磨损均衡代码，它将数据的写入分散到整个 NAND 闪存中，以避免过度使用单一区域，从而更快地磨损这些块。

许多使用 NAND 闪存的硬件设备，如可移动的 USB 闪存驱动器和固态硬盘（SSD），都带有与设备捆绑的控制器逻辑，提供上述功能，包括坏块管理、磨损均衡和错误校正码。然而，Android 设备设计为直接集成 NAND 闪存组件，因此需要一个软件管理层来提供这些重要功能。选定的管理 NAND 闪存的层是 Memory Technology Device（MTD）系统。

MTD 是为了满足 NAND 闪存及其类似设备的需要而开发的。在 MTD 之前，Linux 主要支持字符设备和块设备。这两种设备类型都没有解决新型存储设备独特的特性。此外，虽然 NAND 闪存严格来说不是块设备（像传统硬盘那样），但向开发者暴露块设备特性有助于开发和支持。通过利用 MTD，Android 现在有了与 NAND 闪存有效交互所需的 Flash Transition Layer（FTL）。通过这种方式，Android 没有将制造商限制在只能使用少数 NAND 闪存供应商和相关控制器。相反，他们可以自由使用任何可用的 NAND 闪存，然后“简单”地与支持广泛 NAND 闪存的 MTD 集成。

在 Android 中，MTD 不仅为 NAND 闪存提供了块接口，还提供了 ECC、磨损均衡和其他关键功能。ECC 和其他块元数据存储在一个被称为 OOB（带外）或备用区域的保留空间中。OOB 位于 NAND 闪存上每个块的后面。虽然块、块和 OOB 布局是可配置的，但到目前为止，大多数 Android 设备都有一个 128 KB 的块，包含 64 个每块 2048 字节（2k）的块，每个块都有一个 64 字节的 OOB，如图 4.1 所示。

![图像](img/F100044f04-01-9781597496513.jpg)

图 4.1 块（128 KB = 64 × 2k 块 + OOB）。

OOB 不仅存储由 MTD 管理的相关信息，还可以存储对文件系统至关重要的元数据，前提是文件系统要能识别 NAND 闪存。虽然系统将块呈现为 128 KB，但加上 64 个大小为 64 字节的 OOB 后，额外的 4096 字节（4 KB）使得 NAND 闪存上总共使用的字节数达到了 132 KB。

在 Android 设备上，您可以通过查看/proc/mtd 文件来确定 MTD 分区。在我们的参考设备 HTC Incredible 上，我们有以下分区：

![图像](img/F100044u04-38-9781597496513.jpg)

有七个 MTD 分区，下一节将检查它们的挂载位置，并提供一个关于找到的目录和文件的高级概述。在之前的列表中，size 和 erasesize 都是十六进制值，提供了重要的 MTD/NAND 闪存属性。erasesize 指定了每个块的大小，即 0x20000 或 131,072 字节或 128 KB（128×1024）的十进制数。这与块图一致，特别是 64 页，每页 2048（2 KB）的大小。size 列指定了该分区的整体大小。因此，在这个实例中，我们有如表 4.5 所示的 MTD 分区。

表 4.5 MTD 分区大小转换

![图像](img/T100044tabT0030.jpg)

表 4.5 中的值也可以使用 df（磁盘空闲）命令进行验证，该命令提供了已挂载文件系统及其总、已使用和可用空间的列表。以下是/system 的 df 数据：

![图像](img/F100044u04-39-9781597496513.jpg)

如你所见，/proc/mtd 中找到的大小在我们的转换和 df 命令显示中是一致的。

既然我们已经对 Android 中的 NAND 闪存和 MTD 有了基本的了解，我们将研究 Android 使用的各种文件系统。

## 文件系统

与大多数 Linux 系统一样，Android 中也使用了多个文件系统，其中许多用于启动和运行系统。虽然我们会提到多个文件系统，但主要关注的是存储用户数据的分区，特别是 EXT、FAT32 和 YAFFS2 文件系统。

要确定 Linux 内核（以及因此的 Android）支持哪些文件系统，你可以查看文件 /proc/filesytem 的内容。在我们参考的 HTC Incredible 上，它包含以下内容：

![image](img/F100044u04-40-9781597496513.jpg)

在 HTC Incredible 支持的 18 个文件系统中，只有五个是由物理设备（如 NAND 闪存或 SD 卡）支持的。其余的文件系统具有“nodev”属性，这意味着它们本质上是虚拟文件系统，不会写入任何物理设备。此外，实际上在设备上只使用了六个 nodev 文件系统：

1. rootfs

2. tmpfs

3. cgroup

4. proc

5. sysfs

6. devpts

有三个由设备支持的文件系统被使用：

1. ext3

2. yaffs2

3. vfat

下面的部分提供了大多数文件系统的简要概述，以及对存储大量用户数据的 YAFFS2 的深入分析。

### rootfs、devpts、sysfs 和 cgroup 文件系统

Linux 中的许多文件系统用于启动、操作或管理系统，通常不会包含在取证调查中有用的信息。然而，安全工程师和研究人员可能会仔细检查这些文件系统以及内核的内部工作，试图找出安全漏洞和其他弱点。我们将快速强调在 Android 中发现的四个与基础设施相关的文件系统。

首先，rootfs 是内核在启动时挂载根文件系统（目录树的顶部，用正斜杠表示）的位置。为了让内核完成启动过程，它需要访问核心文件和库，因此需要挂载根文件系统。随着内核完成启动过程，随后的文件系统作为根文件系统下的目录被挂载。例如（本章后面会详细介绍），根文件系统会被挂载在 / 并包含关键文件。然后一个更完整的系统目录会被挂载在 /system。你可以通过从 shell 运行“ls -l”命令或输入“mount”来查看已挂载的文件系统以及它们在根文件系统中的目录。

devpts 文件系统用于在 Android 设备上提供模拟的终端会话，类似于使用 telnet 或 ssh 连接到传统的 Unix 服务器。每次虚拟终端连接时，在/dev/pts 下都会创建一个新节点。例如，如果你有一个 adb shell 连接到 Android 设备，/dev/pts 将显示以下内容：

![图像](img/F100044u04-41-9781597496513.jpg)

然而，在下一个示例中，有两个 adb shell 连接和一个来自设备上安装的应用程序的终端应用连接：

![图像](img/F100044u04-42-9781597496513.jpg)

如你所见，原始的/dev/pts/0 连接存在。但是现在有两个额外的连接，并且来自终端应用的连接是在应用独特的用户 id（app_105）下运行的。

Sysfs 是另一个包含设备配置和控制文件的虚拟文件系统。在 HTC Incredible 上，存在以下顶级目录：

![图像](img/F100044u04-43-9781597496513.jpg)

出于好奇，你可以将/sys 目录下的文件通过 adb pull 命令拉取到你的取证工作站上，因为任何用户都可以读取这些文件。执行以下命令：

![图像](img/F100044u04-44-9781597496513.jpg)

如你所见，大量文件被拉取，你现在可以使用完整的 Linux 工具套件来检查数据。尽管这些信息的取证价值需要进一步研究，但它清楚地提供了关于设备的低级信息，有助于安全研究。例如，如果你想了解更多关于 NAND 设备的信息，你可以检查以下目录：

![图像](img/F100044u04-45-9781597496513.jpg)

然后是每个文件：

![图像](img/F100044u04-46-9781597496513.jpg)

详尽了解 NAND 设备显然是进行取证和安全分析的重要步骤。将近 3000 个文件，有大量数据需要检查。以下是一种快速查看文件名、路径和大小的方法，这将使你能够轻松检查相关文件（尝试在两个终端会话中列出文件，在一个终端中使用复制/粘贴来“cat”文件内容）：

![图像](img/F100044u04-47a-9781597496513.jpg)

![图像](img/F100044u04-47b-9781597496513.jpg)

提示

### 附加 sysfs 分析

除了手动检查 sysfs 文件系统外，互联网上还有详细资源提供了额外的背景信息。这样一个资源是 Patrick Mochel 的一篇论文，提供了有用的背景信息（The sysfs filesystem, n.d.）。

最后一个虚拟文件系统被称为 cgroups，用于跟踪和汇总 Linux 文件系统中的任务。在 HTC Incredible 上，创建了两个 cgroup 文件系统：一个在/dev/cpuctl，另一个在/acct。尽管可能通过进一步分析得到结果，但会计数据在取证分析中通常并不证明是有用的。

### proc

proc 文件系统在 /proc 目录下以结构化的方式提供了关于内核、进程和配置参数的详细信息。一些文件可以通过 shell 用户检查。然而，许多文件在你拥有 root 权限之前阻止访问。如前所述，探索 proc 文件系统的一种方法是将文件从 Android 设备拉到你的法医工作站上。这需要一些时间，并且在某些文件上可能会挂起，导致复制不完整。

![image](img/F100044u04-48-9781597496513.jpg)

在 HTC Incredible 上，上述过程在尝试复制进程 76 时挂起，不得不使用 Ctrl-C 取消：

![image](img/F100044u04-49-9781597496513.jpg)

在取消之前，我们成功提取了 25 MB 的数据和近 6000 个文件。与 sysfs 检查一样，你可以使用 find 命令手动检查数据，以定位并列出文件：

![image](img/F100044u04-50-9781597496513.jpg)

另外，你可以直接从 adb shell 检查 /proc 中的某些文件，如下所示：

![image](img/F100044u04-51-9781597496513.jpg)

设备的宝贵信息可以在 proc 文件系统中找到。检查员可以审计这些文件，并且应该从 /proc 目录中的文件开始，而不是子目录。

### tmpfs

tmpfs 是一个文件系统，它将所有文件存储在由 RAM 支持的虚拟内存中，如果有的话，还包括设备的交换或缓存文件。目前大多数 Android 设备没有交换空间。然而，一些售后固件启用了这个功能。tmpfs 的优点是，通过使用 RAM，存储速度非常快，而且是非永久的，因此在重启时不会被保存。

当然，对于法医检查员来说，这是一个挑战。如果重要数据位于 tmpfs 挂载点上，必须在设备重启或断电之前收集这些数据。这也提供了一个独特的机会，因为 tmpfs 通常可以被 shell 用户读取，并且法医程序可以复制并在 tmpfs 中执行，而无需修改 NAND 闪存或 SD 卡。这可能允许检查员在完全不修改 NAND 闪存或 SD 卡的情况下从 Android 设备获取法医数据。

警告

### 调查 tmpfs

如果你对设备内存分析的主要兴趣在于，除非你首先拥有你感兴趣的内存部分的法医级副本，否则不建议对 tmpfs 进行更改。

在 HTC Incredible 上，标准安装有四个 tmpfs 挂载点：

• /dev

• /mnt/asec

• /app-cache

• /mnt/sdcard/.android_secure

/dev 目录包含设备文件，允许内核读取和写入连接的设备，如 NAND 闪存、SD 卡、字符设备等。/mnt/asec 和 /mnt/sdcard/.android_secure 目录是 Android 的新增功能，允许应用存储在 SD 卡上，而不是 /data/data，从而提供更多存储空间。

有趣的是，/app-cache 也是一个新增加的项，似乎提供了 tmpfs 空间，应用程序可以使用。在 HTC Incredible 上，网页浏览器（com.andrew.browser）在/app-cache 中创建了一个目录，并存储了网页浏览的缓存文件。

![图像](img/F100044u04-52-9781597496513.jpg)

从第一个列表中，我们可以看到 app-cache 目录对所有用户设置了读、写和浏览权限。此外，权限“rwxrwxrwt”中的最后一个“t”表示只有 root 或目录所有者才能删除或重命名目录。

第二个列表显示了 app-cache 内部的目录，其中只有 com.android.browser。但是，当我们深入到目录中时，我们发现我们最感兴趣的目录和文件只允许应用程序本身（com.android.browser，应用程序的用户 ID 为 app_12）或 root 访问文件。

![图像](img/F100044u04-53-9781597496513.jpg)

由于我们在设备上拥有 root 权限，以下是目录包含的内容：

• 1.4 MB 的数据

• 64 个文件

• 18 个 ASCII 文件（主要是 CSS 和 JavaScript）

• 1 个空文件

• 9 个 GIF 文件

• 5 个 HTML 文件

• 11 个 JPEG 文件

• 17 个 PNG 文件

• 3 个 UTF-8 文件

![图像](img/F100044u04-54-9781597496513.jpg)

如果你从 Ubuntu 工作站浏览 webviewCache 目录，你可以轻松预览图像和其他文件（图 4.2）。

![图像](img/F100044f04-02-9781597496513.jpg)

图 4.2 从 Ubuntu 工作站浏览的浏览器 webviewCache。

/app-cache tmpfs 目录包含的信息在法医调查中非常重要。这强调了教育前线响应人员以确保设备得到妥善处理，以最大化法医调查有效性的日益需求。

### 扩展文件系统（EXT）

扩展文件系统（EXT）是 Linux 的默认文件系统，专门为操作系统开发。正如你已经知道的，Linux 支持大量的文件系统。然而，默认的是 EXT。自从 1992 年开发出 EXT 的原始版本以来，已经推出了三个额外的版本：EXT2、EXT3 和 EXT4。

尽管 EXT 已经集成到大多数笔记本电脑、台式机和服务器 Linux 发行版中，但在早期的 Android 设备中并未发现 EXT。然而，到了 2010 年，EXT 开始出现在设备中，2010 年 12 月 9 日，谷歌在他们的 Android 开发者博客上宣布，越来越多的 Android 设备将从 YAFFS 转移到 EXT（Android 开发者博客，未标明日期）。从 YAFFS 转向 EXT 似乎是由在线讨论的几个因素推动的（Way，未标明日期），包括

• 越来越多的 Android 设备从原始 NAND 闪存转向常规块设备（eMMC）

• EXT4 是一个标准的 Linux 文件系统，支持完整的 Unix 权限和语义

• EXT4 稳定且性能高

• YAFFS 是单线程的，在即将到来的双核系统上会遇到瓶颈

第一款使用 EXT4 的 Android 设备是 Google Nexus S，预计许多运行 Android Honeycomb 版本的平板设备也将使用这个新的文件系统。目前，Nexus 在以下挂载点使用 EXT4：

• 系统镜像（只读，/system）

• 本地用户数据（读写，/data/data）

• 缓存分区（读写，/cache 及其他可能）

从取证的角度来看，EXT4 只是一个需要取证工具理解和支持的文件系统。当然，目前大多数取证工具并不完全（甚至只是名义上）支持 EXT4，这确实带来了一些问题。文件雕刻技术是有效的，预计随着时间的推移，将会有更多的取证软件开始支持这个文件系统。

### FAT32/VFAT

Android 设备通常具有一个或多个 Microsoft FAT32 分区，通常位于 SD 卡和 eMMC 上。采用这种久经考验的文件系统并非因为其设计优越，而是因为其与其他操作系统的高度兼容性。FAT32 文件系统在大多数操作系统中都得到广泛支持，包括 Mac OS X、所有 Windows 版本（显然）、Linux 等等。这意味着，存储在 FAT32 分区上的 Android 数据可以轻松地在其他文件系统上被读取、修改甚至删除。

在 Linux 中，FAT32 分区的文件系统驱动被称为 VFAT，不要与微软早期桥接 FAT16 和 FAT32 实现的虚拟 FAT 文件系统混淆，后者增加了包括长文件名支持在内的其他功能。在 HTC Incredible 上，有 3 个使用 FAT32 的挂载点。

• `/mnt/sdcard`

• `/mnt/secure/asec`

• `/mnt/emmc`

如您在第三章关于 USB 接口的部分所记得的，当 Android 设备连接到另一台计算机时，可以选择暴露设备的 USB 大容量存储（UMS）接口以实现文件共享。在 HTC Incredible 上，`/mnt/sdcard`和`/mnt/emmc`分区可以通过 USB 连接作为 UMS 设备向其他操作系统呈现。

`/mnt/secure/asec`分区是 SD 卡上的一个加密分区，Android 设备可以在此存储应用程序。当引入了从 SD 卡运行应用程序的功能后，安全工程师们理所当然地担心应用程序数据可能会容易被损坏或泄露，因为 VFAT/FAT32 分区没有维护文件权限。因此，应用程序（.apk 文件）在物理设备上被加密，在使用时会被解密并临时存储在`/mnt/asec`或其他指定位置。

如前所述，可移动的 SD 卡被挂载在/mnt/sdcard 上，通常包含照片、视频、缩略图、下载的文件、文本语音临时文件以及 Google Maps 导航数据，还包括许多 Android Market 应用程序的数据。较新的/mnt/emmc 是一个 FAT32 分区，不可移动，位于设备架构的存储中。在迄今为止检查的设备中，eMMC 通常被格式化为 FAT32，这也是为了互操作性。

### YAFFS2

当第一个 Android 设备发布时，许多人对一个相对不知名的文件系统在系统中扮演关键角色感到惊讶。YAFFS（Yet Another Flash File System 的缩写）是一个专门为 NAND 闪存开发的开放源代码文件系统，同时遵循 GNU 公共许可证（GPL）和商业许可协议，后者适用于那些不想严格遵守 GPL 指导方针的人（YAFFS licence FAQs, n.d.）。Android 设备使用 YAFFS 的最新版本（YAFFS2），该版本遵循更严格的 NAND 闪存指导方针，旨在提高 NAND 闪存的耐久性，同时针对低内存移动或嵌入式设备进行优化。

YAFFS2 由新西兰的 Aleph One Ltd 公司开发。应客户要求，Aleph One 于 2001 年 12 月开始了 YAFFS 的设计工作，并于 2002 年 5 月发布了首个公开可用的源代码。主要开发者（或至少是最知名的）是 Charles Manning，他被描述为“嵌入式清洁工”，在过去的 20 年里一直在开发和完善嵌入式系统（YAFFS: the NAND-specific flash, n.d.）。Charles 在 YAFFS 邮件列表上非常活跃，是 YAFFS 和 YAFFS2 方面的公认专家。

提示

### 附加的 YAFFS2 资源

对于内部结构感兴趣的 分析师和工程师们，鼓励他们阅读完整的 YAFFS2 文档（如果感兴趣，还可以阅读源代码），访问[`www.yaffs.net/`](http://www.yaffs.net/)并订阅邮件列表。

YAFFS2 是专门为日益增长的 NAND 闪存设备而构建的，它具有许多重要特性，满足这一介质严格的需求。YAFFS2 是

• 支持日志结构文件系统（即使在意外断电情况下也能保护数据）

• 提供内置的磨损均衡和错误校正

• 能够处理坏块

• 快速且在 RAM 中占用空间小

然而，由于在 Android 之前其使用受到限制，目前没有（商业或开源）取证工具支持该文件系统。这使得取证分析师除了下载 YAFFS2 源代码，获取分区的取证映像，用你喜欢的十六进制编辑器打开并开始挖掘之外，几乎别无选择。尽管随着时间的推移可能会开发出一些工具，但 Android 转向 EXT4 可能会降低商业取证公司开发此类支持的积极性。

如 NAND 闪存部分所述，YAFFS2 通过 MTD 子系统以块的形式处理内存，每个块包含一定数量的页面（在 YAFFS 文档和代码中称为数据块）。当 YAFFS2 准备好将数据写入 NAND 闪存时，它将数据和元数据结构都传递给 MTD。MTD 然后负责将（以及读取）数据和元数据写入 NAND 闪存。

对于大多数 Android 设备，MTD 子系统以块的形式处理 NAND 闪存，这些块被划分为 64 个数据块，每个数据块包含 2048 字节（因此块为 128K），加上一个 64 字节的带外/备用区域（OOB），各种标签和元数据都存储在这里。当为写入分配一个块时，它会被分配一个从 1 开始并随每个新块增加的序列号。

YAFFS2 中存储的所有数据结构都被视为对象，可以是文件、目录、符号链接和硬链接。每个数据块要么存储一个 yaffs_ObjectHeader（对象元数据），要么存储对象的数据。yaffs_ObjectHeader 跟踪各种信息，包括对象类型、父对象、用于加速搜索的名称校验和、对象名称、权限和所有权、MAC 信息，如果对象是文件，还包括对象的大小。

在 64 字节的 OOB/备用区域中，YAFFS2 不仅存储关于数据块的 critical 信息，还与 MTD 子系统共享该区域。关键的 YAFFS2 标签如下：

• 1 字节：块状态（0xFF 表示块良好，其他值表示坏块）

• 4 字节：32 位数据块 ID（0 表示数据块存储 yaffs_ObjectHeader，否则为数据）

• 4 字节：32 位对象 ID（类似于传统的 Unix i 节点）

• 2 字节：此数据块中的数据块数（最后一个数据块除外，其余都会被完全分配）

• 4 字节：此块的序列号

• 3 字节：标签的 ECC（在 Android 中，由 MTD 处理）

• 12 字节：数据的 ECC（在 Android 中，由 MTD 处理）

如果对象被更改，新的 yaffs_ObjectHeader 将被写入闪存，因为 NAND 内存只能在擦除前写入一次。旧数据和头部仍然存在，但通过检查序列号的值，在文件结构中被忽略。这个过程符合 NAND 闪存中的块永远不会被重写（只写入一次，然后在不再需要时擦除）的指导原则。当然，这对于数据恢复过程可能具有巨大的好处，因为除非块经历了用于擦除块并准备接受新数据的垃圾回收过程，否则修改或删除的数据仍然存在于 NAND 闪存上。

同样，在 YAFFS2 中删除文件时，ObjectHeader 的父目录会被移动到一个特殊的隐藏目录中，称为未链接目录。文件将保留在此目录中，直到文件中的所有块段被擦除。为了实现这一点，文件系统跟踪系统中文件的块段数量。当它达到 0 时，文件残留部分不再存在。在这一点上，它将不再在未链接目录中跟踪对象。

虽然文件系统结构可以从 OOB 区域和 ObjectHeader 信息完全重新生成，但这并不高效——特别是随着 NAND 闪存大小的增长。因此，结构被加载到 RAM 中并维护（根据需要写入 NAND 闪存），使用树节点结构（T 节点）来跟踪所有已分配的块段。T 节点是固定的 32 字节，在其最低级别（级别 0）存储一个索引，用于定位第一个块段 ID。随着文件大小的增长，会添加额外的级别，这些级别由指向其他 T 节点的八个指针组成。

YAFFS2 通过从块的分配顺序的末尾开始，逆向读取每个块段来重新生成，并在 RAM 中填充文件系统结构作为 T 节点。这需要扫描整个 NAND，这是一个耗时的操作。为了解决这个问题，YAFFS2 开发了检查点机制，当它正常卸载时，该机制更喜欢将 RAM 结构保存到 NAND 闪存（使用 10 个块）。

为了让你更全面地了解 YAFFS2，还需要掌握一些其他关键概念。首先，垃圾回收是排队进行的，并且每次写入系统时如有需要都会执行。如果一个块中的所有块段都不再被使用，那么这个块就成为了垃圾回收的候选对象。系统还能够找到“最脏”的块，将已分配的块段复制到新块中，从而使该块可以进行垃圾回收。为了再次使用这个块，会通过写入全 1（0xFF）来擦除它。

在 Android 设备上，我们可以通过检查 `/proc/yaffs` 文件来找到关于 YAFFS2 文件系统的详细信息：

![图像](img/F100044u04-55a-9781597496513.jpg)

![图像](img/F100044u04-55b-9781597496513.jpg)

我们可以看到许多有用的详细信息，例如，在挂载于 `/data/data` 的 “datadata” YAFFS2 分区上。通过检查该分区的 `/proc/yaffs` 列表，我们可以了解到以下内容：

1. 有 1192 个块（从 0 到 1191），我们知道每个块有 64 个块段（2048 字节）。所以，128K × 1192 = 152,576K，你可以通过运行 df 命令或像我们上面那样检查 /proc/mtd 来确认。

2. 显示了页面读取、页面写入和块擦除的数量。这将提供一个关于 NAND 闪存使用情况的总体概念。

3. 垃圾回收过程中的一个策略是找到几乎空闲的块，将剩余数据复制出来，然后标记块为可收集。我们可以看到这个过程以很高的速率（323,313）发生。

4. 我们可以看到没有检测到 ECC 错误。

5. YAFFS2 元数据报告超过 63,000 个未链接的文件。

6. YAFFS2 不使用软件 ECC，而是依赖于 MTD 或 NAND 闪存。

如果你比较没有高读写使用的 `/data/data` 目录的系统分区，你会注意到明显的差异。检查 `/proc/yaffs` 文件可能有助于提供解释错误纠正代码、碎片化数据等时的必要背景信息。

深入理解 YAFFS2 的最佳方式是直接创建、修改和检查文件系统。所有这些在本书其他练习中创建的 Ubuntu 工作站上都是可能的。由于我们已经安装了 Linux 虚拟机和 build-essential 软件包（包括必要的 C 编译器和支持软件包），我们现在需要安装 mtd-utils 软件包：

![image](img/F100044u04-56-9781597496513.jpg)

然后，我们下载最新的 YAFFS2 源代码：

![image](img/F100044u04-57-9781597496513.jpg)

然后解压 yaffs2.tar.gz 并编译，这样我们就可以使用内核模块了：

![image](img/F100044u04-58-9781597496513.jpg)

接下来，我们将加载必要的内核模块在 RAM 中模拟 MTD（除非你恰好有一些可以直接连接的 NAND 闪存）然后挂载 YAFFS2 分区。

首先，我们将在主目录中创建一个挂载文件系统的地方：

![image](img/F100044u04-59-9781597496513.jpg)

接下来，我们需要加载几个内核模块以启用 MTD 支持：

![image](img/F100044u04-60-9781597496513.jpg)

接下来，我们使用 nandsim 内核模块创建模拟的 NAND 闪存：

![image](img/F100044u04-61-9781597496513.jpg)

提示

### 关于 Linux MTD 的额外信息

Linux MTD 网页提供了关于 nandsim 的更多详细信息。该网站提供了 MTD 的深入背景信息和支持，请访问以获取完整详情。

这里提供了来自 Linux MTD 网站的关于 nandsim 的额外详细信息以供直接参考（NAND FAQ, n.d.）：

“NAND 模拟器（nandsim）是一个极其有用的调试和开发工具，它可以在 RAM 或文件中模拟 NAND 闪存。要选择模拟的闪存类型，你应该指定你的闪存的 ID 字节——即通过“读取 ID”命令（0x90）返回的字节——请参阅闪存手册。以下是输入参数的示例：

• modprobe nandsim first_id_byte=0x20 second_id_byte=0x33—16MiB, 512 字节页”

• modprobe nandsim first_id_byte=0x20 second_id_byte=0x35—32MiB, 512 字节页；

• modprobe nandsim first_id_byte=0x20 second_id_byte=0x36—64MiB, 512 字节页；

• modprobe nandsim first_id_byte=0x20 second_id_byte=0x78—128MiB, 512 字节页；

• modprobe nandsim first_id_byte=0x20 second_id_byte=0x71—256MiB, 512 字节页；

• modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00 fourth_id_byte=0x15—64MiB, 2048 字节页；

• 使用`modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00 fourth_id_byte=0x15`创建一个 128MiB 的模拟 NAND 闪存，每页 2048 字节；

• 使用`modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00 fourth_id_byte=0x15`创建一个 256MiB 的模拟 NAND 闪存，每页 2048 字节；

• 首先使用`modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00 fourth_id_byte=0x15`创建一个 512MiB 的模拟 NAND 闪存，每页 2048 字节；

• 使用`modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95`创建一个 1GiB 的模拟 NAND 闪存，每页 2048 字节；

既然已经有了模拟的 NAND 闪存，我们可以像在 Android 设备上一样通过检查`/proc/mtd`来验证其大小和分区信息：

![image](img/F100044u04-62-9781597496513.jpg)

系统显示我们有一个 MTD 分区（mtd0），擦除大小为十六进制的 0x20000 字节（128 KB），总大小为十六进制的 0x4000000（65,536 KB 或 64 MB）。接下来，我们需要将 YAFFS2 内核模块加载到内存中：

![image](img/F100044u04-63-9781597496513.jpg)

在我们挂载 YAFFS2 文件系统之前，先在十六进制编辑器中查看未初始化的模拟 NAND 闪存。如果你尝试使用`dd`或仅仅是`xxd`这样的工具来查看 NAND 闪存设备，你将看不到 OOB 区域，因为它们对大多数工具是不可见的。这是为了防止那些不期望文件中有 OOB 的程序的混淆（想象一下尝试显示每个 2k 数据块后都有 64 字节二进制 OOB 数据的 PDF）。为了读取包括 OOB 在内的完整 NAND 闪存，我们使用之前安装的`mtd-utils`包中的`nanddump`程序。这将读取数据并以二进制形式返回它们。有几个选项可以考虑，可以很容易地查看：

![image](img/F100044u04-64-9781597496513.jpg)

对于我们的目的，我们想使用`nanddump`提取包含 OOB 的完整 NAND，并将输出管道到十六进制编辑器（xxd）进行查看：

![image](img/F100044u04-65-9781597496513.jpg)

注意，模拟的 NAND 闪存包含预期的 0xFF 值，这是空白或已擦除的 NAND 闪存应有的。上述命令将允许你检查在初始化和随后修改文件系统时，原始 NAND 闪存是如何被修改的。

因此，最后，我们准备挂载 YAFFS2 文件系统：

![image](img/F100044u04-66-9781597496513.jpg)

你可以验证文件系统是否已挂载并可访问：

![image](img/F100044u04-67-9781597496513.jpg)

因此，我们可以看到 YAFFS2 文件系统以读/写权限挂载在`~/mnt/yaffs2`目录下。尽管我们没有创建任何文件，但该目录包含一个`lost+found`虚拟目录，用于存放无法确定父目录的文件和目录。如果你再次使用`xxd`十六进制编辑器检查模拟的 NAND 闪存设备，它仍然会包含 0xFF。但是，如果你使用以下命令写入单个文件：

![image](img/F100044u04-68-9781597496513.jpg)

并在文件中放入“Android 取证与移动安全”的内容，然后当我们检查原始 NAND 闪存时，可以清楚地看到包括 ObjectHeaders、Objects 和文件内容的 YAFFS2 结构。以下是使用 nanddump 和稍微修改过的 xxd 命令（添加了-a 选项以跳过 0x00 行）的部分十六进制内容：

![图像](img/F100044u04-69-9781597496513.jpg)

从偏移量 0x0000000 开始，我们可以看到空白的 ObjectHeader，可以轻松地看到 ASCII 码中的文件名（book.txt）。从 0x0000800 到 0x000083F，我们可以看到由 YAFFS2 存储并由 MTD 作为打包二进制数据存储的 OOB 数据，必须进行解析。文件的实际内容被写入到 NAND 闪存的 0x0000840 位置。我们从 0x0001040 到 0x000107F 看到了另一个 OOB，然后在 0x0001080 位置再次写入 ObjectHeader 到 NAND 闪存，因为原始 ObjectHeader 表示的是空文件。一旦我们添加了内容并保存了文件，数据就被写入 NAND 闪存，并且一个*新的 ObjectHeader 被写入*到 NAND 闪存。新的 ObjectHeader 反映了关于对象的新元数据，包括哪些数据块保存了数据、MAC（修改、访问、更改）数据等。

需要理解的一个关键点是，YAFFS2 不能简单地将此信息更新到第一个 ObjectHeader，因为它首先需要擦除整个块。因此，它写入一个新的 ObjectHeader，为该头部生成一个高序列号，使其成为文件的最新 ObjectHeader。可以想象，旧的 ObjectHeader 和数据除非通过垃圾回收，否则会保留在 NAND 闪存上，从而为使用取证技术恢复文件元数据和内容提供了极大的机会。

#### YAFFS 示例

在关于 YAFFS2 的最后部分，提供了一个虚构的场景来说明 ObjectHeaders 和 Objects 是如何写入 NAND 闪存的。这个例子是由 Charles Manning 在他的“*Yaffs 如何工作*”（How YAFFS works, n.d.）中提出的。任何对 YAFFS 内部感兴趣的人都被鼓励打印、阅读或重新阅读这份文件。在示例中，我们使用了一个 NAND 闪存，为了简单起见，该闪存每个块有四个数据块，并且已被擦除（0xFF）。在描述每个更改后，一个表格将显示 NAND 闪存的内容。

首先，我们在 NAND 闪存上创建一个空文件，如表 4.6 所示。

表 4.6 创建空白文件

![图像](img/T100044tabT0035.jpg)

ObjectHeader 指向一个空文件。接下来，我们向文件写入三个数据块，如表 4.7 所示。

表 4.7 写入三个数据块

![图像](img/T100044tabT0040.jpg)

到目前为止，这可能看起来很简单。现在对象占据了第一个块的全部。

注意

### 虚构的 NAND 闪存

请记住，我们的虚构 NAND 闪存每个块有四个数据块，而不是我们在商用 NAND 闪存中常见的 64 个数据块。

接下来，我们将保存文件，这将导致新的 ObjectHeader 被写入 NAND 闪存，如表 4.8 所示。

表 4.8 保存文件的新 ObjectHeader

![图像](img/T100044tabT0045.jpg)

这里需要理解的关键点是，YAFFS2 无法回过头来用新的大小、数据块和其他信息更新原始 ObjectHeader。相反，它必须写入一个新的 ObjectHeader，其中包含更新文件所需的元数据。在 YAFFS2 中，新的 ObjectHeader 被赋予更大的序列号，因此它成为当前的 ObjectHeader，YAFFS2 简单地忽略了之前的那个（然而，它仍然留在磁盘上）。

接下来，文件将以读写权限打开，并给第一个数据块赋予新值。最后，保存并关闭文件，这会导致额外的数据写入 NAND 闪存，如表 4.9 所示。

表 4.9 保存新数据和 ObjectHeader

![图像](img/T100044tabT0050.jpg)

同样，由于我们不能简单更改文件中的原始第一个数据块，因此将新的数据块写入 NAND 闪存，并将之前的数据块标记为过时。这通过向 NAND 闪存写入另一个新的 ObjectHeader 来实现，该 ObjectHeader 指向文件的新的第一个数据块。接下来，我们将文件截断为零长度文件，表 4.10 展示了 NAND 闪存的变化。

表 4.10 截断文件并写入新的 ObjectHeader

![图像](img/T100044tabT0055.jpg)

由于文件被截断，块 0 中的所有数据块都不再使用。这使得该块可用于垃圾回收，将在下一个写入周期发生。这被称为懒惰垃圾回收，因为它使用现有的写入周期来执行必要的垃圾回收。与之前一样，新的 ObjectHeader 被写入 NAND 闪存，以解释被截断的文件。

最后，我们重命名文件，NAND 闪存的结果如表 4.11 所示。

表 4.11 重命名文件并写入新的 ObjectHeader

![图像](img/T100044tabT0060.jpg)

在这个周期中，块 0 进行了垃圾回收，现在可用于写入数据。由于文件被重命名，新的 ObjectHeader 被写入 NAND 闪存。块 1 中的所有数据块现在都过时了，它们可用于垃圾回收。然而，请记住，由于 NAND 闪存的有限耐久性，应避免写入/擦除周期。

对于法医调查来说，除非进行垃圾回收，否则 ObjectHeader 和 Object 数据块的整个历史都将保留在 NAND 闪存上。借助适当的软件，可以扫描 NAND 闪存，从而基本上重建文件系统的整个历史。时间线不仅会包含每次编辑的日期/时间，还有可能恢复文件的实际状态。实际上，YAFFS2 分区的状态并非这么简单。然而，这个基本原则仍然是相关的。

## 挂载的文件系统

我们已经详细介绍了 Android 内存系统的许多组成部分。我们不仅探讨了 RAM 和 NAND 闪存，还详细检查了许多文件系统。这些背景信息将帮助您对 Android 设备进行法医和安全性分析。为了更好地理解这些更学术的信息，我们现在将探讨在 Android 设备上找到的已挂载文件系统。

### 已挂载的文件系统

让我们从 HTC Incredible 上挂载的文件系统开始：

![图像](img/F100044u04-70-9781597496513.jpg)

当你运行不带参数的 mount 命令时，它会返回已挂载的文件系统及其选项的列表。表 4.12 是使用多个条目的输出描述。但是，请注意，上述每个条目都以“0 0”结尾，由于空间原因，在表中省略了这部分。“0 0”条目确定文件系统是否由 dump 命令归档以及确定文件系统检查器（fsck）在引导时检查设备/分区错误的顺序的传递编号。在大多数桌面或服务器 Linux 系统上，根文件系统具有 1 的传递编号，因此它会在其他文件系统之前被检查。

表 4.12 mount 命令输出概述

![图像](img/T100044tabT0065.jpg)

/mnt/sdcard 有许多选项。这些选项包括：

1. rw：挂载以允许读写

2. dirsync：对目录的所有更新都是同步进行的

3. nosuid：不允许设置 setuid（这会允许其他用户使用文件所有者的权限执行程序）

4. nodev：不将任何文件解释为特殊的块设备

5. noexec：不允许从文件系统执行所有文件

6. relatime：如果文件访问时间早于修改时间，则更新文件访问时间

7. uid=1000：将所有文件的所有者设置为 1000

8. gid=1015：将所有文件的组设置为 1015

9. fmask=0702：仅对常规文件应用 umask（设置权限---rwxr-x，或者用户=无，组=读写执行，其他=读执行）

10. dmask=0702：仅对目录应用 umask（设置权限---rwxr-x，或者用户=无，组=读写执行，其他=读执行）

11. allow_utime=0020：控制 mtime/atime 的权限检查。

12. codepage=cp437：为 FAT 和 VFAT 文件系统转换短名称字符设置代码页。

13. iocharset=iso8859-1：用于在 8 位字符和 16 位 Unicode 字符之间转换的字符集。默认为 iso8859-1。长文件名以 Unicode 格式存储在磁盘上。

14. shortname=mixed：定义了符合 8.3 字符限制的文件名的创建和显示行为。如果文件存在长文件名，它将始终优先显示。Mixed 模式会按原样显示短名称，并在短名称不全为大写时存储长名称。

15. utf8：将 CD 上的 16 位 Unicode 字符转换为 UTF-8。

16. errors=remount-ro：定义遇到错误时的行为；在这种情况下，重新以只读方式挂载文件系统。

所有挂载命令的选项在手册页（man 8 mount）中都有解释。然而，在大多数情况下，快速浏览将揭示审查员需要的信息，包括文件系统上的挂载点、类型和权限。

df 命令将提供有关已挂载文件系统上可用空间的免费信息：

![image](img/F100044u04-71-9781597496513.jpg)

如你所见，当 shell 用户尝试确定可用磁盘空间量时，其中一个挂载点（/mnt/secure/asec）返回了权限被拒绝。通过查看父目录，我们可以看到只有 root 用户可以访问该目录：

![image](img/F100044u04-72-9781597496513.jpg)

有趣的是，当通过 USB 大容量存储（UMS）选项暴露这两个文件系统/目录时，目录的权限会发生变化。如果未启用 UMS 选项，正如你可以看到 /mnt/emmc 和 /mnt/sdcard 的情况，文件系统对 Android 设备是完全可访问的。

然而，当 UMS 激活并且两个文件系统对连接的工作站可用时，权限会发生变化：

![image](img/F100044u04-73-9781597496513.jpg)

如你所见，/mnt/emmc 和 /mnt/sdcard 上的所有权限都被移除了，因此 Android 设备不能直接从手机访问 /mnt/emmc 或 /mnt/sdcard（即它是与连接的工作站独占共享的）。

## 摘要

Android 设备上的物理内存、文件系统及数据结构是数据存储的基本构建块。对这些结构的深入理解不仅能够帮助你理解 Android 设备，而且当面对新的文件系统和数据结构时，还能进行自己的研究和开发。

## 参考文献

1\. *Android 开发者博客：安全保存数据*。（未注明日期）。2011 年 2 月 2 日检索自 [`android-developers.blogspot.com/2010/12/saving-data-safely.html`](http://android-developers.blogspot.com/2010/12/saving-data-safely.html)。

2\. *Android 逆向工程*。（未注明日期）。[thomascannon.net](http://thomascannon.net)。2011 年 1 月 29 日检索自 [`thomascannon.net/projects/android-reversing/`](http://thomascannon.net/projects/android-reversing/)。

3\. *数据存储*。（未注明日期）。Android 开发者。2011 年 3 月 13 日检索自 [`developer.android.com/guide/topics/data/data-storage.html#netw`](http://developer.android.com/guide/topics/data/data-storage.html%23netw)。

4\. *YAFFS 的工作原理：内部机制*。（未注明日期）。YAFFS。2011 年 2 月 4 日检索自 [`www.yaffs.net/how-yaffs-works-internals`](http://www.yaffs.net/how-yaffs-works-internals)。

5\. Nand Faq. （未注明日期）。*Linux 的内存技术设备（MTD）子系统*，2011 年 3 月 13 日检索自 [`www.linux-mtd.infradead.org/faq/nand.html`](http://www.linux-mtd.infradead.org/faq/nand.html)。

6\. *sysfs 文件系统*。(未知日期)，引自 2011 年 2 月 1 日，来自[`www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf`](http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf)。

7\. Way, T. (未知日期)。*从姜饼开始，Android 将开始使用 ext4。Ted 的思考。欢迎来到* [<ce:italic>thunk.org</ce:italic>](http://thunk.org)，引自 2011 年 2 月 2 日，来自[`thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/`](http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/)。

8\. 许可证常见问题，Y. A. F. F. S. (未知日期)。YAFFS，引自 2011 年 2 月 4 日，来自[YAFFS 许可证常见问题](http://www.yaffs.net/yaffs-licence-faqs)。

9\. *YAFFS：NAND 专用闪存文件系统—介绍性文章*。(未知日期)。引自 2011 年 2 月 2 日，来自[YAFFS：NAND 专用闪存文件系统—介绍性文章](http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle)。
