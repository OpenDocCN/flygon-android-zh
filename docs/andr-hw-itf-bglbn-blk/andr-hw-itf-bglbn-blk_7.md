# 第七章：从这里出发

在上一章中，我们研究了 Android 应用如何同时与 GPIO、I2C 和 SPI 接口，以提供完整的硬件接口解决方案。尽管您可能认为这涵盖了 Android 下硬件接口的大部分问题，但还有许多其他因素需要考虑。

在本章中，我们将涵盖以下主题：

+   将您的解决方案集成到 Android 中

+   将您的硬件与其他硬件结合

+   探索 BBB 的其他接口

# 将您的解决方案与 Android 集成

BBB 提供了丰富的硬件功能，您在项目中使用的特定功能会随着系统中使用的 cape 和覆盖物的改变而变化。尽管这在原型设计期间为您提供了很大的灵活性，但您最终可能会将自定义硬件设计最终确定为一个单一的静态配置，并决定将其作为一个永久的基于 Android 的解决方案。

本书中的示例采用了让应用直接访问 BBB 硬件的设计决策。虽然这种方法使得创建硬件接口的 Android 应用变得简单，但这并不是理想的方法。一旦您有了满意的硬件设计并且软件能够正确地与硬件接口，那么就是完全将您的解决方案与 Android 集成的时候了。根据您的硬件解决方案的复杂程度，您可能最终会创建自定义内核设备驱动，甚至修改 Android OS 框架内的管理器！

## 创建自定义内核和 Device Tree

创建永久性 Android 解决方案的第一步是确保系统中 Linux 方面的所有内容都处于应有的状态。这意味着所有硬件支持（例如项目中需要的 Linux 内核驱动）应在内核中启用并配置，并在内核的 Device Tree 中分配（用于引脚复用和资源分配）。理想情况下，您需要的所有内容都应该直接静态构建到内核和 Device Tree 中。这样可以消除通过`init.{ro.hardware}.rc`文件内执行的显式命令加载覆盖物和内核模块的需求。

对于准备项目内核空间的建议是在 Linux 环境中开发这些部分。Linux 环境为内核驱动开发和调试提供了更多工具，你可以快速、轻松地构建独立的用户空间二进制文件，通过`open()`、`read()`、`write()`和`ioctl()`函数调用来与自定义和现有内核驱动交互。Linux 用户空间二进制文件的代码-编译-测试-调试周期可以非常快，因为包括编译器和调试器在内的完整开发工具链在 Linux 下都是可用的。在 Android 下，你必须使用 Android NDK 在开发机器上构建这样的测试二进制文件，然后使用`adb`将它们推送到 Android 系统上进行测试。这使得开发周期变得既慢又困难。

为你的解决方案开发一个静态的 Device Tree 需要类似的过程。Device Tree 及其覆盖层是使用`dtc`工具编译的，这个工具在 Linux 下可用，但在 Android 下不可用。使用标准的 Linux 内核调试技术，你可以开发和故障排除一个覆盖层，为你的项目复用引脚，并为这些引脚分配必要的内核驱动。一旦你的覆盖层正常工作，你可以将覆盖层永久地集成到 Device Tree 中。

### 提示

**我在哪里可以了解更多关于 BBB 的 Linux 开发？**

网上有许多教程和资源可以帮助你了解为 BBB 开发 Linux 软件和 Device Tree 覆盖层。我们能向你推荐的最好资源是 Derek Molloy 创建的 BeagleBone 视频教程系列。这些教程涵盖了诸如 C/C++开发环境设置和配置、调试、Device Tree 覆盖层创建和故障排除等主题。他们还有各种代码和电路示例，帮助你入门。你可以在 Derek 网站的 BeagleBone 部分观看这些教程，网址是[`derekmolloy.ie/beaglebone`](http://derekmolloy.ie/beaglebone)。

## 将硬件通信添加到内核中

虽然直接与 GPIO 和 I2C 及 SPI 总线接口很方便，但这并不是与硬件接口最高效的方式。在 I2C 存储和检索数据的章节中，I2C FRAM 的例子使用了 24c256 内核驱动来处理与 FRAM 芯片通信的低级细节。你能想象直接与 FRAM 芯片接口需要实现每一个细节会有多困难吗？除了需要了解 BBB 和 FRAM 芯片之间通信协议的每一个细节之外，这些协议还可能需要严格的定时保证，这在用户空间很难或不可能满足。

在用户空间与硬件接口不可行的情况下，使用内核驱动程序是必要的。内核驱动程序封装了与特定硬件通信的细节。这简化了接口应用，将这些细节保留在应用程序实现之外。内核驱动程序在与硬件通信时还提供了更为严格的时序保证。这是因为内核对于调度内核驱动通信事件以实现必要的最后期限有更深入的了解。在用户空间，如果内核的任务调度器决定给另一个进程执行的机会，进程可能会随时被挂起。即使用户空间进程的优先级大大提高，与基于内核的活动相比，它的调度优先级仍然会低。

创建内核驱动程序可能相当复杂，这远远超出了本书的范围。但是，如果你发现自己试图在与某块硬件通信时满足非常严格的时序限制，你最终可能需要探索内核设备驱动程序开发的细节。

### 提示

**我在哪里可以了解更多关于开发内核驱动程序的信息？**

学习内核驱动程序开发最好的起点是 Corbet、Rubini 和 Kroah-Hartman 所著的《Linux 设备驱动》一书。这本书提供了详尽的指导，带你了解开发过程。更好的是，这本书的第三版可以免费下载，网址是[`lwn.net/Kernel/LDD3`](http://lwn.net/Kernel/LDD3)。第三版最初于 2005 年出版，所以它有点过时，但书中提出的中心概念仍然是有效的。

## 集成到现有管理器中

在第五章中，*使用 SPI 与高速传感器接口*，你与基于 SPI 的温度和压力传感器进行了接口。虽然你使用 `spidev` 内核驱动从一个单一应用与传感器通信，但让管理器与传感器通信会更清晰。这样，所有应用都可以通过与管理器通信来请求访问传感器数据，而不是必须了解 SPI 通信的许多细节以及它们之间的协调访问。这也限制了哪些应用有权与 `spidev` 驱动程序交互。

实际上，Android 已经有一个管理器 `Android.SensorManager`，它旨在与手机和平板电脑中常见的硬件传感器资源进行通信。应用通过请求管理器的一个实例，然后请求代表特定类型传感器的对象来与管理器通信：

```java
Private final SensorManager mSensorManager;
Private final Sensor mPressure;
Private final Sensor mTemperature;

Public SensorActivity() {
  mSensorManager =
   (SensorManager)getSystemService(SENSOR_SERVICE);mPressure = 
    mSensorManager.getDefaultSensor(Sensor.TYPE_PRESSURE);
  mTemperature =
    mSensorManager.getDefaultSensor(Sensor.TYPE_TEMPERATURE);
}
```

如果`SensorManager`扩展到与您在第五章，*使用 SPI 与高速传感器接口*中使用的 SPI 传感器进行接口，那么您的应用只需几行 Java 代码就可以通过`SensorManager`与传感器通信！更妙的是，`spidev`设备的文件系统权限不需要设置为如此不安全的状态，以便应用与传感器通信。不幸的是，由于一些原因，将新的硬件功能集成到现有的管理器中可能会相当困难：

+   您必须重新构建 Android 的相应部分，这通常需要您至少一次完整构建 Android 源代码库。对于没有经验的人来说，这是一个耗时（且常常令人困惑）的过程。Android 开源项目在[`source.android.com/source`](https://source.android.com/source)提供了关于如何从源代码构建 Android 的指导。

+   必须将您新硬件的附加接口逻辑添加到您正在集成的管理器的 HAL 中。虽然这通常相当直接，但管理器 HAL 的部分可能散布在 Android 代码库的各个地方。

+   新硬件必须符合由管理器提供的框架 API 方法。除非您愿意打破 API 兼容性，向特定管理器类中添加额外的属性和方法，否则您必须确保您的硬件符合管理器提供的现有接口。

尽管这种集成可能比较困难，但通常非常直接。由于 Android 设计时考虑了平板电脑和手机，任何可能成为移动设备平台一部分的硬件可能已经有了一个设计用来与之接口的 Android 管理器。`SensorManager`就是一个很好的例子。它旨在提供来自各种不同类型传感器硬件的传感器信息。虽然您需要将一些本地代码集成到`SensorManager` HAL 中，以与特定的传感器通信，但 HAL 与`SensorManager` API 方法之间的通信过程相对简单。

### 提示

**我在哪里可以找到将自定义硬件集成到管理器的示例？**

德州仪器为它们生产和销售的各类处理器提供了一系列的**评估模块**（**EVMs**）。由于许多商业产品基于这些处理器，TI 免费提供文档和指导，介绍如何创建自定义的 HAL 代码，将通用硬件集成到 Android 管理器中。查找这些详细信息最好的地方是 TI 的 Sitara Android SDK 的文档。SDK 的网页位于[`www.ti.com/tool/androidsdk-sitara`](http://www.ti.com/tool/androidsdk-sitara)。

## 为自定义硬件创建新的管理器

如果你正在将独特的硬件集成到 Android 中，比如你在第六章《*创建一个完整的接口解决方案*》中创建的环境采样器，可能没有标准的 Android 管理器提供必要的 API 方法让应用与硬件正确通信。在这种情况下，你可以考虑创建一种新的管理器，专门处理这种独特硬件。

新的管理器可以专门针对与其交互的硬件进行定制。例如，BBB 提供了专门的硬件，允许软件与大多数现代汽车内部的计算机通信。这种功能在标准的 Android 移动设备中是不可用的，因此不存在处理此类通信的管理器。

创建一个新的管理器来处理使用此接口的具体细节，并提供自定义 API 以使用此管理器，使应用无需了解此类通信的细节。然而，以下原因应将其视为最后的手段：

+   这里没有现成的管理器代码可以作为基础。最多，你可能找到一个简单的管理器，从中复制代码作为起点。

+   必须修改 Android 构建过程以包含构建新的管理器代码。这需要将新管理器的源文件添加到 Android makefiles 中，并验证 Android 框架没有被破坏。构建 Android 是一个庞大而复杂的任务，因此对过程进行任何更改都不应轻率进行。

+   你必须设计一个适当的 API 来与新管理器接口。由于这个新的接口添加不是标准 Android API 的一部分，应用将无法包含这些 API 调用，除非你特别将它们添加到你的 Eclipse ADT 安装中。

+   你还必须增强 `android.Manifest.permission` 以包含一个或多个新的权限设置，允许应用访问新管理器的功能。作为替代方案，你可以依托现有权限，或者选择完全不用权限。

总的来说，构建一个自定义管理器是相当大的工作量，且不是胆小者所为。这个过程涉及到 Android 框架的许多不同部分，并需要所有这些部分功能的专长。如果你发现自己认为绝对需要创建一个新的管理器来通过 Android 框架正确处理你的硬件，你应该考虑跳过管理器，并使用与本例书中类似的方法：让你的应用直接使用 JNI 与硬件通信。

# 将你的项目与其他硬件结合

现在你已经考虑了如何最好地修改你的 Android 系统的软件方面，以完全集成你的定制硬件项目，让我们来看看硬件方面的事情。面包板可以很好地让你快速创建和更改你的硬件项目设计。硬件和软件共同设计是一个迭代过程，因此你可能会发现自己在开发接口软件时更改硬件设计。然而，携带面包板来展示你的硬件项目远非理想之选。

## 构建自己的原型斗篷

为什么不创建你自己的定制斗篷板项目呢？如果你为你的 Android 系统开发了完美的硬件项目，你应该考虑将其制作成独立的斗篷板。将你的项目设计成斗篷形式，可以轻松地与其他斗篷板集成。它还允许你将项目从一处移动到另一处，而不必担心干扰电路或意外断开面包板电线。

对于没有经验的人来说，创建一个专业布局的定制斗篷 PCB 是一项非常困难的任务。但是，只要你有一点焊接和规划，你仍然可以构建自己的斗篷板。Adafruit 的原型斗篷套件（产品 ID 572）是一个很好的起点。原型斗篷只不过是一个通用 PCB，用于固定那些被焊接成半永久电路的组件。如果你购买了我们在第一章中提到的 BeagleBone Black 入门包（产品 ID 703），*《Android 与 BeagleBone Black 的介绍》*，那么你已经有了原型斗篷，因为它包含在那个套件中。

![构建自己的原型斗篷](img/00031.jpeg)

用于构建半永久性斗篷电路的原型斗篷套件（来源：[www.adafruit.com](http://www.adafruit.com)）

### 注意

原型斗篷还具有一个重要的优势，那就是移除了阻挡 P8/P9 连接器开口的面包板电线。最多可以同时连接四个斗篷，通过*堆叠*斗篷（通过每个斗篷上的 P8/P9 连接器通行孔将一个斗篷插入另一个斗篷）。这为你提供了将不同的斗篷组合在一起的机会，创建一个定制的 Android 系统，充分利用你所设计的定制硬件。如果面包板电线阻挡了 P8/P9 连接，其他斗篷将无法插入连接器并堆叠在 BBB 的顶部。这使得如果堆叠中最顶层的斗篷没有通行 P8/P9 连接器（像大多数 LCD 斗篷一样），就无法使用面包板设计。

## 与 Android 接口的商业斗篷

市面上有许多现成的 BBB 扩展板可供购买，与 Android 配合使用效果良好。4D Systems（[`www.4dsystems.com.au/`](http://www.4dsystems.com.au/)）提供多种不同尺寸和分辨率的 LCD 扩展板，价格合理，既有触摸屏也有非触摸屏型号。BeagleBoard Toys（[`www.beagleboardtoys.com/`](http://www.beagleboardtoys.com/)）也提供各种扩展板，如 LCD、音频和电池扩展板。通过将不同的扩展板与 BBB 结合，你可以将你的 Android 系统转变为便携式 Android 设备！

![与 Android 接口的商业扩展板](img/00032.jpeg)

左侧的 4DCAPE-70T（800 x 480 像素）和右侧的 4DCAPE-43T（480 x 272 像素）4D Systems 触摸屏 LCD 扩展板（来源：[www.4dsystems.com.au](http://www.4dsystems.com.au)）

### 提示

**那么 USB 设备呢？**

其他需要考虑的硬件组件包括 USB 设备，如音频设备、鼠标、键盘、Wi-Fi 适配器、蓝牙适配器、游戏手柄和网络摄像头。由于 Linux 内核包含所有这些设备的驱动程序，你可以轻松地使用它们来扩展你的 Android 平台并开发各种创意应用。BBB 只有一个 USB 端口，但你可以将 USB 集线器连接到该端口，以支持同时使用多个 USB 设备。

你可能可以创建一个基于 Android 的手持游戏机，带有 GPIO 控制器输入和基于 SPI 或 I2C 的加速度计。或者，你可以设计一个带有触摸屏 LCD 的定制汽车控制台，从你的车辆中收集实时数据。你控制着整个平台的硬件和软件，而 Android 应用开发工具非常适合快速轻松地创建 UI。可能性是无限的！

![与 Android 接口的商业扩展板](img/00033.jpeg)

左侧的 5VDC 电池和右侧的音频 CODEC CircuitCo 扩展板（来源：[www.beagleboardtoys.com](http://www.beagleboardtoys.com)）

# 探索 BBB 的其他接口

到目前为止，我们已将 BBB 的 GPIO、SPI 和 I2C 功能用于我们的接口。但这些并不是 BBB 提供的唯一接口选项。在考虑 BBB 上的 Android 项目时，您应该记住以下一些其他接口。

## 可编程实时单元

BBB 的 AM335X 处理器内嵌有一对可编程实时单元（PRU）。这些单元的时钟频率为 200 MHz，因此它们每 5 ns 执行一条指令。内核将程序加载到 PRU 中，然后指示 PRU 开始执行。PRU 与内核之间的通信通过共享内存进行。PRU 的执行与主处理器的执行完全分离，除非处理器与 PRU 之间需要协调，否则将 PRU 推向极限不会对主处理器产生性能影响。

有许多 GPIO 引脚可以通过多路复用，使它们直接受到 PRU 的控制。PRU 可以在每个指令上检查或设置这些 GPIO 的值，这意味着 PRU 控制的 GPIO 可以足够快地切换以实现复杂数字接口（如 SPI 和 I2C）的“位碰撞”实现。如果你有一块定制的硬件，并且需要实现一个与之的高速接口，使用一个或两个 PRU 是一个选项。

## 串行通信

BBB 提供了五个串行通信 UART，可以通过多路复用器连接到 P8 和 P9 连接器的引脚上。此外，还有一个第六个 UART（UART0），通过 FTDI 电缆提供串行调试输出。如果你使用 BBB 来控制大量的串行控制设备，这些 UART 是非常有用的资源。

不幸的是，这些 UART 中的几个（UART 3、4 和 5）与提供视频数据到 LCD cape 和内部 HDMI cape 的 LCD 接口总线使用的引脚冲突。由于 Android 的强大之处很大程度上来自于其用户界面，禁用 LCD 接口以接收更多 UART 通常是非常不划算的。如果你发现你绝对需要在 Android 下使用这些 UART，所有 UART 都可以使用标准的 Linux 内核串行驱动程序和现有的 NDK 库访问文件系统中的`/dev/TTYS*`文件。

## 控制器区域网络

BBB 上有两个**控制器区域网络**（**CAN**）总线。CAN 是一种串行协议，也是用于车辆接口的**车载诊断**（**OBD**）标准的五种协议之一。车辆诊断硬件和软件使用 CAN 与大多数现代汽车的主控控制器进行通信。Linux 内核中的 CAN 驱动程序将每个 CAN 总线公开为网络接口，可以通过网络套接字编程与其通信。如果你有兴趣创建一个能够与你的车辆通信的 Android 设备，比如车内的状态显示屏或手持诊断单元，CAN 总线正是你所需要的。

CAN0 总线多路复用到 P9.19 和 P9.20 引脚上，这些引脚也是 capemgr 用于发现任何连接的 cape 身份的 I2C2 总线所使用的引脚。将 CAN1 总线多路复用到 P9.24 和 P9.26 引脚可能会与 I2C1 冲突，这取决于你是如何多路复用 I2C 通道的。通常，你不能同时使用 SPI、I2C 和 CAN。

## 模数转换器

BBB 不仅限于数字通信。它还提供了一个 8 通道、12 位的**模数转换器**（**ADC**），允许 BBB 接收 0 到 1.8V 之间的模拟电压水平。这对于与真实世界的传感器交互以及许多触摸屏显示非常有用。但是，你必须非常小心，确保施加在这些引脚上的电压永远不会超过 1.8 伏，否则你会损坏 BBB。

P9.32 至 P9.40 引脚已永久与 ADC 复用，因此你可以自由地将它们用于自己的项目。目前，CircuitCo 和 4D Systems 的带触摸屏支持的 LCD 扩展板使用了 ADC 通道 4-7 进行触摸屏操作，留下了通道 0-3 供你使用。

## 脉冲宽度调制

BBB 上的 AM3359 处理器拥有一个**脉冲宽度调制**（**PWM**）子系统，用于精确控制电动机。PWM 设置向电机供电的周期和占空比，以控制其转速。PWM 子系统包含三个**增强型高分辨率脉冲宽度调制器**（**eHRPWM**）模块和一个**增强型正交编码脉冲**（**eQEP**）模块。这四个模块总共提供了八个用于驱动电机的 PWM 通道。

尽管 PWM 通常用于控制工业制造设备、机器人伺服电机和各种其他机械系统，但它也可以用来控制照明的亮度以及其他可以利用 PWM 的可变占空比来模拟全强度开关之间的功率/亮度/速度级别的任务。如果你有兴趣使用 Android 操作系统控制机械系统，PWM 绝对是 BBB 上你应该进一步探索的功能。

# 总结

在本章中，我们研究了如何将你的自定义硬件项目完全集成到 BBB 上的 Android 中。我们讨论了如何将你的自定义设备驱动直接构建到 Linux 内核中，以及如何将你的自定义 Device Tree 覆盖层直接编译到主 Device Tree 中。这样可以避免在`init.{ro.hardware}.rc`文件中包含特殊模块和加载命令的覆盖层。

我们还探讨了如何定制标准的 Android 软件框架，以包括对自定义硬件项目的支持。现有的 Android 管理器可以被扩展以支持自定义硬件。

我们探讨了如何使用 Proto Cape 使你的自定义硬件设计半永久化。这可以避免在移动项目时意外断开面包板电线。它还通过避免面包板电线阻塞 P8/P9 连接器，使得与商业 BBB 扩展板的集成更加容易。我们还提到，有许多类型的 USB 设备也得到 Android 的支持，在考虑新项目时值得探索。

最后，我们探索了一些本书早期章节示例中未涵盖的其他 BBB 接口。BBB 的 PRU、串行 UART、CAN 总线、ADC 和 PWM 子系统都提供了额外的功能，以便与外部世界接口。
