# 第九章：测试代码和调试

“无 bug 的产品是一个神话”是开发行业中常见的短语。一个无问题和无故障的应用程序或任何其他产品在理性上是不可能的。然而，开发人员总是可以尽量减少 bug 和问题的数量，以便游戏可以尽可能少地出现问题，并以最大可能的效率支持最多的平台。

我们将通过以下主题讨论 Android 游戏开发中各种调试方面的范围：

+   Android AVD

+   Android DDMS

+   Android 设备调试

+   监控内存占用

+   不同调试语句的战略放置

+   Android 游戏中的异常处理

+   在跨平台引擎中工作时调试 Android

+   最佳测试实践

# Android AVD

AVD 是调试 Android 游戏最重要和重要的部分。在最初阶段，该概念始于模拟器。有一些预定义的模拟器可以用于在开发 PC 上运行构建。Android 模拟器提供了类似实时设备的界面。

AVD 具有一些功能，可以提供设备 RAM、Android 版本、屏幕大小、显示 dpi、键盘和不同的视觉皮肤。旧版 AVD 大多看起来都一样。

![Android AVDs](img/B05069_09_01.jpg)

在当前版本的 Android Studio 中，提供了大多数 Android 设备类别。开发人员可以根据目标开发平台创建 AVD。

类别如下：

+   Android 手机

+   Android 平板电脑

+   Android 电视

+   Android 可穿戴设备

AVD 可以通过 Android SDK 中提供的 AVD 管理器工具来创建或操作。AVD 管理器可以管理 AVD 的每个属性。该工具还可以帮助开发人员创建自定义 AVD。

让我们来看看每个不同 AVD 的属性因素：

+   名称

+   分辨率

+   显示尺寸

+   Android 版本 API 级别

+   Android 目标版本

+   CPU 架构

+   RAM 数量

+   硬件输入选项

+   其他选项

+   扩展 AVD 设置和创建

## AVD 的名称

名称仅用于识别 AVD。可以分配任何内容，并且以后可以更改。在创建时也可以更改预定义的 AVD 名称。

## AVD 分辨率

AVD 分辨率是可见性的最重要因素之一。有一些预定义的分辨率标准，但它们也可以更改。如今，大多数开发人员选择在实际硬件平台上广泛使用的分辨率。

分辨率的另一个用途是检查和验证游戏的显示可移植性。大多数游戏都是以目标分辨率制作的。然后，可以在各种分辨率上测试游戏以检查兼容性。

通常，如果纵横比相同，多个分辨率不会产生任何问题。然而，在 Android 的情况下，我们可以找到不同设备的多个纵横比。AVD 的分辨率因子有助于适应游戏并检查其在多个纵横比下的兼容性。

## AVD 显示尺寸

这是 AVD 上的可见空间或可见显示区域。一个高分辨率的 AVD 可以有一个小的显示区域。这直接意味着 AVD 具有高 dpi 值，这意味着更高的显示质量。

AVD 的这一部分有助于确保游戏的视觉质量。然而，在开发系统中设置实际显示区域并不总是可能的，因为开发系统有自己的显示限制。

## Android 版本 API 级别

在开发 Android 游戏时，开发人员需要将 API 使用限制在某个版本上。API 版本可能会在将来的 Android 版本中被弃用，甚至停止使用。为了检查这一因素，开发人员可以为 AVD 设置 API 版本。

## Android 目标版本

这是将用于运行 AVD 的 Android 版本。这可以验证清单目标 Android 版本和最低版本范围。

## CPU 架构

Android 设备主要使用三种 CPU 架构：armeabi、armeabi-v7 和 x86。这对游戏没有直接影响。然而，处理速度和质量会随着 CPU 架构的不同而有所变化。

开发人员应该记住，实际设备上具有不同 CPU 架构的游戏性能总是会与 AVD 上的表现不同。因此，它可能给开发人员一个性能的想法，但需要在实际设备上进行测试。

## RAM 数量

RAM 数量指定了 AVD 可用的总内存量，可用于检查游戏在各个级别的内存消耗。

最好预测各种设备的内存溢出问题。通过在 AVD 上同时运行多个应用程序，可以创建一个实时克隆。默认值设置为 66MB。开发人员可以根据需求设置任何值。

外部存储也可以定义为虚拟设备的 SD 卡。

## 硬件输入选项

在 Android 设备上，可以有许多类型的硬件输入分布在各种硬件中。最常见的变体如下：

+   触摸屏

+   触摸板

+   键盘

+   自定义控制器

+   硬件按钮

许多硬件平台选择了这些变体的组合。AVD 为所有这些输入系统创建了一个虚拟系统。

## 其他选项

还有一些其他选项可供操作。如果开发系统连接了摄像头，那么 AVD 也可以使用前置和后置摄像头。

此外，虚拟加速计、传感器等可以与 AVD 关联。

## 扩展 AVD 设置

通过现代 AVD 管理工具可以制作自定义 AVD。开发人员可以设计具有自定义外观和完全自定义硬件配置的虚拟设备。

# Android DDMS

DDMS 可用于分析运行中应用程序的所有运行时详细信息，如内存消耗、进程调用等。

Android DDMS 的主要功能是提供端口、在设备上进行屏幕截图、线程详细信息、堆详细信息和 Logcat 处理。此服务可用于欺骗呼叫和短信。

Android DDMS 广泛用于设备调试。特别是在游戏开发过程中，它经常被用作逐行调试系统。这对于识别不需要的加载对象和资产，以及跟踪运行时异常非常有用：

![Android DDMS](img/B05069_09_02.jpg)

Android DDMS 可用于执行以下活动。

## 连接 Android 设备文件系统

DDMS 可以连接到设备文件系统，并提供基于文件浏览器的操作，通过 PC 在设备上复制、修改或删除任何文件。然而，这种方法或功能对 Android 游戏开发并不是非常重要。

## 性能分析方法

另一个有趣的 DDMS 功能是对某些方法的分析或跟踪矩阵。它提供以下主题的信息：

+   执行时间

+   操作次数

+   单元格数量

+   执行期间的内存使用

扩展此功能，开发人员甚至可以通过调用`startMethodTracing()`和`stopMethodTracing()`来控制方法的数据分析。

开发人员需要关注两件事：

+   在 Android 2.1 之前，设备上必须安装有 SD 卡，并且应用程序需要有读写权限

+   从 Android 2.2 开始，设备可以直接将分析数据流式传输到开发 PC

## 线程信息监控

DDMS 提供了所选设备上每个进程运行的每个线程的详细信息。然而，游戏大多在单个线程上运行。随着设备的不断改进，游戏也在使用多线程功能来支持渲染、处理、文件 I/O 和网络等各种操作。

## 堆信息监控

DDMS 为运行中的进程提供了堆使用情况。对于游戏开发人员来说，跟踪执行期间的游戏进程堆非常有用。

## 跟踪内存分配

这对于跟踪运行时对象的每个内存分配非常有用。这可以给出每个类的每个特定对象的每个细节。这意味着开发人员可以找出每个类占用多少内存。这有助于以更有效的方式实现内存优化。

## 监控和管理网络流量

从 Android 4.0 开始，DDMS 具有**详细网络使用**选项卡，用于跟踪游戏何时发出网络请求。使用此功能，开发人员可以监视网络数据传输。这个选项对于优化网络开发非常有用。它可以通过在使用网络套接字之前对其应用“标签”来区分不同的流量类型。

## 使用 Logcat 跟踪日志信息

日志是跟踪几乎任何东西的最有用的调试技术。在运行时正确使用日志来检查某些对象的数据或值是一个很好的实践。对于游戏的逻辑开发非常有用。

在游戏开发中，不同游戏的逻辑需求将不同。因此，必须有大量的代码是第一次编写的。预定义的测试用例是不可用的。可以使用 DDMS 中的 Logcat 来克服这种不足。

Logcat 提供以下类型的日志信息：

+   冗长的

+   调试

+   错误

+   警告

+   信息

## 模拟设备操作

正如我们之前讨论过的 Android 虚拟设备一样，DDMS 也可以在 AVD 上工作。因此，模拟实时场景以调试正在开发的游戏变得更加容易。

最常用的仿真如下：

+   模拟来电

+   模拟收到消息

+   模拟运行时网络状态更改

这三种情况是运行时最常见的情况。因此，这些情况可以在没有物理设备的情况下进行检查。自 Android 设备开始以来，中断处理一直是困难的。事实上，如果中断没有得到正确处理，这对程序员来说可能是一场噩梦。

在中断后，游戏崩溃/冻结/重新启动的常见问题。很多时候，一些不必要的服务或进程可能会中断，并且它们可能会在中断期间改变游戏状态。在 AVD 上模拟每种可能的中断总是加快调试或中断处理过程的一个额外优势。

# Android 设备测试和调试

Android 设备调试是任何 Android 游戏开发过程中最重要的部分。让我们将这个主题分成两个部分：

+   设备测试

+   设备调试

## 设备测试

游戏开发者面临的主要挑战是在大量不同的设备上运行游戏。这些不同的设备包括不同的显示器、不同的分辨率、不同的 Android 操作系统版本、不同的处理器和不同的内存容量。由于这些原因，Android 设备测试很重要，必须付出很大的努力和计划。

通常，在游戏开发周期中，第一点测试由开发人员进行。这个过程确保游戏在设备上运行。

然后，测试人员或一组测试人员从各个方面在不同的设备上测试游戏。这是设备测试的主要部分。

通常，主要的测试阶段根据游戏开发阶段分为四个部分：

+   原型测试

+   完整测试

+   回归测试

+   发布测试或运行测试

换句话说，在每个类别中有类似的分布，如下所示：

+   Pre-alpha 测试

+   Alpha 测试

+   Beta 测试

+   发布候选测试

还有许多其他可能遵循典型软件测试的测试程序。然而，在游戏开发中，通常会遵循这些方法。让我们简要描述这些阶段。

### 原型测试

开发人员和设计师一起开发基本游戏想法的可玩阶段，具有初始的游戏规则。这些规则和游戏玩法在原型测试阶段进行测试。

理想情况下，核心游戏玩法在这个阶段进行测试，以分析游戏概念的可行性、潜力和范围。

原型测试可能是游戏开发过程中最重要的部分。这个阶段决定了游戏概念的未来，并有助于为概念开发元游戏和货币化模型。

### 全面测试

通常情况下，在每个阶段提交的前几个构建被提交进行全面测试。这会揭示游戏的每一个可能的问题，包括崩溃、冻结、视觉问题、可玩性、游戏规则和设计缺陷。

大多数问题通常在这个阶段报告，这最终意味着该游戏构建的可能完成时间和工作量。

### 回归测试

回归测试是在全面测试之后进行的。开发人员、设计师和制作人在全面测试期间对每个问题进行评估。他们选择要解决的问题，问题解决后，提交给测试团队进行回归测试。

在回归测试中，测试人员通常选择问题并专门检查它是否真的解决了。如果问题在修复的构建中发生，则测试人员会重新打开问题进行下一个回归周期。这个周期会持续，直到所有报告的问题都得到解决。

### 发布测试或运行测试

这可能是游戏测试中最机械化的测试阶段。在这个阶段，测试人员在各种目标设备上运行通过的回归测试构建，只是为了检查游戏是否在该硬件上运行。这就是为什么这个阶段经常被称为“运行测试”的原因。

尽可能多地使用物理设备进行此段测试以进行兼容性检查。在这个测试阶段之后，创建最终设备支持列表。几乎不可能安排所有可用的设备并对它们进行运行测试。因此，开发人员根据其配置和性能对设备进行分组。行为相似的设备被放在同一类别中，实际上只有一两个设备被安排用于整个组的运行测试。

## 设备调试

我们已经看到设备测试主要是测试人员的工作。现在，我们将看到设备调试基本上是开发人员的工作。然而，通常情况下，开发人员和测试人员都会进行调试。

在游戏行业中，设备调试主要用于查找运行时崩溃、冻结、内存问题、网络问题和性能问题。通过设备调试，开发人员收集以下信息：

+   运行时最大堆消耗

+   各种设备的平均 FPS 或多套设备

+   不必要的加载对象

+   硬件按钮行为

+   网络请求和响应

### 使用断点

在设备调试的情况下，断点非常有用。游戏线程在断点处暂停，可以通过 DDMS 获得状态信息。游戏编程主要涉及定制算法，可能在运行时产生一些异常行为。在这种情况下，断点非常有用。开发人员可以在断点后逐行调试逻辑，以找到并修复行为的根本原因。

# 监视内存占用

内存占用是在运行时使用内存的迹象和方式。从游戏内存使用优化的角度来看，监视内存占用非常重要：

+   检查日志消息

+   检查堆更新

+   跟踪内存分配

+   检查整体内存使用

+   跟踪内存泄漏

## 检查日志消息

使用日志消息一直是最有效和最直接的调试技术。消息日志对于跟踪程序控制流和运行时对象跟踪非常有用。

### Dalvik 消息日志

Dalvik 消息日志对于跟踪内存很有用。每当发生垃圾收集时，垃圾收集器可以通过 Dalvik 日志消息打印以下信息：

+   **垃圾收集原因**：此信息显示了触发垃圾收集的原因。原因可以是`GC_CONCURRENT`、`GC_FOR_MALLOC`、`GC_HPROF_DUMP_HEAP`、`GC_EXPLICIT`或`GC_EXTERNAL_ALLOC`。

+   **释放的内存量**：此部分说明了垃圾收集器释放的内存量（以 KB 为单位）。

+   **当前堆内存状态**：这显示了堆内存使用的百分比和活动对象内存/总堆内存。

+   **外部内存状态**：可能会有一些分配外部内存的操作。这部分显示了分配的内存/垃圾收集限制。

+   **垃圾收集器暂停时间**：暂停时间在垃圾收集开始时和结束时触发。通常，在堆较大的情况下，暂停时间会更长。

### ART 消息日志

ART 消息日志还能够显示或跟踪内存印记。但是，除非明确请求，否则不会触发。

如果垃圾收集器暂停时间超过 5 毫秒，或者垃圾收集器执行时间超过 100 毫秒，则会打印垃圾收集器日志。在 ART 的情况下，以下信息可以显示为日志：

+   **垃圾收集原因**：在 ART 日志消息中，开发人员可以将`Concurrent`、`Alloc`、`Explicit`、`NativeAlloc`、`CollectorTransition`、`HomogeneousSpaceCompact`、`DisableMovingGc`或`HeapTrim`作为收集原因。

+   **垃圾收集器的名称**：ART 有几种不同的垃圾收集器可以参与收集过程。可以通过收集日志的字段了解名称。ART 有这些收集器：**Concurrent** **Mark Sweep**（**CMS**）、**Concurrent** **Partial Mark Sweep**（**CPMS**）、**Concurrent Sticky Mark Sweep**（**CSMS**）和 Marksweep plus Semispace。

+   **释放的对象计数**：这显示了垃圾收集器从内存中释放的对象总数。

+   **释放的内存量**：这显示了垃圾收集器释放的总内存量。

+   **释放的大对象计数**：这显示了从大对象范围中由收集器释放的对象数量。

+   **从大对象中释放的内存量**：这显示了从大对象范围中由收集器释放的内存量。

+   **当前堆内存状态**：这与 Dalvik 日志中的相同——活动对象计数/总堆内存。

+   **GC 暂停时间**：在 ART 暂停时间部分，这与运行垃圾收集器修改的对象引用数量成正比。与 Dalvik 不同，ART CMS 垃圾收集器在收集过程结束时只有一个暂停时间。

## 检查堆更新

开发人员可以每次更新时检查堆使用情况。这可以清楚地显示内存印记。可以使用多种工具来监视堆。市场上有很多设备内存监视器可用。DDMS 设备监视器就是其中之一。它是一个强大的工具，在游戏运行时观察堆使用情况。

Android SDK 自带了一个内置的设备监视器，位于`<sdk>/tools/monitor`。

Android Studio 中的内存监视器对于 Android Studio 用户非常有用。监视器可以与 Android 应用程序交互，以观察每次垃圾收集时的堆更新。通过这种方式，Android 开发人员可以了解应用程序各个部分的确切内存使用情况。

有时，开发人员会打开/关闭方法来检查确切的堆使用情况。因此，进一步优化变得更容易。

## 跟踪内存分配

这对于内存优化很有帮助。内存分配可以通过**分配跟踪器**进行监视。

在一定阶段的内存优化之后，需要进行内存分配跟踪。这有助于识别每个对象的内存分配。通常，许多无用的对象会留在内存中。开发人员可以识别这些对象并将它们移除，以实现更大的内存优化。

内存分配跟踪器在 Android SDK 的设备监视器和 Android Studio 的分配跟踪器中都可用。

然而，并不需要从性能关键的代码路径中删除所有分配；然而，分配跟踪器可以帮助开发人员识别代码中的重要问题。例如，一些应用程序可能在每次绘制时创建一个新的`Paint`对象。将此对象移入全局成员是一个简单的修复方法，有助于提高性能：

![跟踪内存分配](img/B05069_09_03.jpg)

让我们快速查看所获得的分配信息：

+   **s1**：这是当前正在跟踪的对象包

+   **s2**：这显示已选择**分配**选项卡

+   **s3**：这用于启动/停止跟踪对象

+   **s4**：这更新包分配

+   **s5**：这显示分配详情

在游戏开发中，内存中的对象数量是巨大的，因此手动跟踪对象的分配和释放非常困难。这个监控工具有助于发现在优化过程中可能被忽视的隐藏点。

## 检查整体内存使用

Android 游戏的整体内存使用分布在 RAM 的不同段中。这为应用程序的性能和内存安全性提供了一个大致的概念。

基本上有两种类型的分配。

### 私有 RAM

这是游戏在运行时使用的专用内存部分。Android 操作系统将此内存分配给应用程序。私有 RAM 分为两个部分：

+   清理 RAM

+   脏 RAM

私有脏 RAM 是最昂贵的，因为它只能被特定应用程序使用（在我们的情况下，是一个 Android 游戏）。

### 比例设置大小（PSS）

这部分 RAM 被多个进程使用。基本上是共享内存。任何应用程序进程独有的 RAM 页面直接影响其 PSS，而与其他进程共享的页面仅按比例影响 PSS 值。

## 跟踪内存泄漏

内存泄漏对软件开发构成严重威胁。因此，追踪内存泄漏并解决它是绝对必要的。当一个进程分配内存并丢失引用指针时，就不可能在进程内释放内存。

有一些调试工具可以追踪内存泄漏。然而，还有另一个免费且更有效的解决方案。开发人员可以随时监视内存消耗。游戏在更新循环中运行。因此，可以跟踪不同游戏周期的内存峰值。如果峰值不断增加，意味着内存的分配/释放存在泄漏。现在，开发人员可以检查每个对象的大小并追踪泄漏。这个过程的另一个好处是在内存中找到不必要的对象以及内存泄漏。

# 不同调试语句的战略放置

调试语句是任何开发过程中最重要的部分。通过调试语句可以跟踪和追踪任何事物。然而，作为系统打印调用，每个调试语句都会对性能产生影响，这直接影响运行时的 FPS。这就是为什么调试语句的放置策略是绝对必要的。

让我们看看与以下类别相关的策略：

+   内存分配

+   跟踪对象状态

+   检查程序流程

+   跟踪对象值

## 内存分配

在游戏开发对象周期中，对象应该在初始化时分配一次，并在销毁时释放。然而，由于手动编程错误，开发人员忘记释放内存。在这种情况下，当系统自动调用垃圾收集器时，内存将被清理。这样就观察到了性能上的延迟。

现在，作为追踪这种错误的战略放置，应该在构造函数和析构函数中放置两个调试消息。

此外，初始化每个对象后放置一个调试语句可以确保对象成功初始化。这可以显示它消耗的内存量。

## 在运行时跟踪对象状态

对象可以在游戏过程中的任何时候初始化。现在，初始化过程中的任何外部依赖都可能导致分配失败。因此，对象进入空状态，如果不正确处理，可能会导致异常。

一个成功的调试语句和一个失败的调试语句（带有原因）可以帮助开发人员纠正问题。

很多时候，错误的释放也会改变对象的状态。因此，调试语句可以确定这个地方。开发人员可以借助调试语句来解决对象和程序流的问题。

## 检查程序流程

每个方法中的调试语句清楚地显示了调用层次结构和程序流程。一个模块化的程序可以通过这个系统进行测试。然后，每个模块的开始都可以用一个调试语句进行测试。

任何错误或不必要的调用都可以通过这个过程来移除或纠正。正确的程序流程可以确保运行时的一定帧率。因此，这种方法可以用来优化性能。

## 跟踪对象值

即使对象成功初始化，内容可能也不正确。因此，放置一个调试语句来检查加载/初始化的内容是必要的，以避免未来的冲突。

当从外部来源加载数据时，这是非常有用的。调试语句用于验证初始化后加载的数据。任何程序模块都可以使用对象跟踪方法进行设计，从而得到更好的编程结构。

# Android 游戏中的异常处理

异常处理可能不是调试的一部分，但它有助于减少异常和不必要的应用程序崩溃。

Android 中的异常处理与 Java 异常处理相同。

## 语法

异常处理的标准 Java 语法如下：

```kt
try
{
  // Handled code here
} 
catch (Exception e)
{
  // Put debug statement with exception reason
}
finally
{
  // Default instruction if any
}
```

可疑的代码应该放在`try`块中，并且异常应该在`catch`块中处理。如果模块需要执行一些默认任务，那么将其放在`finally`块中。`catch`和`finally`块可能并不总是在异常处理中定义。然而，建议在每个`try`块失败时处理异常，这是一个良好的编程实践。这个过程需要分析模块，找出任何脆弱的代码块。

这是一个处理异常的简单例子，还包括其他易受攻击的默认任务。

这是最初的程序设计：

```kt
try
{
  // Task 1 which might throw exception
}
catch ( Exception e)
{
  // Handles exception
}
finally
{
  // Task 2 which might throw exception
}
```

程序应该这样写：

```kt
void func1()
{
  try
  {
    funcTask();
  }
  catch ( Exception e)
  {
    // Handles exception
  }
}

void funcTask()
{
  try
  {
    // Task 1
  }
  finally
  {
    // Task 2
  }
}
```

开发人员应该记住以下几点：

+   `try`块只能与`catch`块一起使用

+   `try`块只能与`finally`块一起使用

+   `try`块可以与`catch`和`finally`块一起使用

+   `try`块不能单独使用

+   嵌套的`try...catch`是可能的，但不建议作为良好的编程实践

## 范围

根据异常类型和原因，有很多预定义的异常范围。然而，在游戏开发过程中处理的主要异常如下：

+   空指针异常

+   索引越界异常

+   算术异常

+   输入/输出异常

+   网络异常

+   自定义异常

### 空指针异常

这是游戏开发中最常见的异常之一。当代码中引用任何空对象时，会抛出`NullPointerException`。开发人员应该跟踪对象的初始化和使用来纠正这个问题。

这是一个例子：

```kt
class A
{
  public int num;
  public A()
  {
    num = 10;
  }
}
// some method in other class which is called during runtime.
void testFunc()
{
  A objA = null;
  Log.d("TAG", "num = " + objA.num);
}
```

这将抛出一个异常，因为`objA`被初始化为 null。因此，这个对象在内存中找不到，引用指针也不存在。现代智能编译器可以在编译时检测到这个明显的异常，但代码可能是这样的，我们定义了另一个包含`testFunc()`方法的类：

```kt
class RootClass
{
  public A objA;
  public RootClass()
  {
    objA = null;
    testFunc();
  }

  void testFunc()
  {
    Log.d("TAG", "num = " + objA.num);
  }
}
```

在这种情况下，大多数智能编译器无法检测到即将发生的异常。为了处理这个问题，开发人员应该在`testFunc()`方法中添加几行代码：

```kt
void testFunc()
{
  try
  {
    Log.d("TAG", "num = " + objA.num);
  }
  catch (NullPointerException e)
  {
    Log.d("TAG", "Exception:: " + e);
  }
}
```

### 索引超出范围异常

当访问一个索引地址时抛出此异常，该地址应该是连续内存分配的一部分，但实际上并不是。在游戏开发中，最常见的是`ArrayIndexOutOfBoundsException`。

例如，如果一个数组包含五个字段，程序尝试访问超过五个字段，那么就会抛出此异常。让我们看一下这段代码：

```kt
int[] arrayNum = new int[5];
for ( int i = 0; i < 5; ++ i)
  arrayNum[i] = i;

Log.d("TAG", "arrayNum[5] is " + arrayNum[5]);
```

在这里，异常将出现在日志语句中，因为`arrayNum[5]`表示数组中的第六个元素，而该元素不存在。

### 算术异常

数学表达式可以表示一个未定义的值，但在编程方面，“未定义”无法定义。因此，会抛出`ArithmeticException`。

例如，如果解释器尝试将任何值除以零，那么结果变为未定义，这将作为异常抛出。在计算 tan 90°的值时也会出现相同的结果。

一个简单的情况可能是这样的：

```kt
void divideFunct(int num, int deno)
{
  try
  {
    Log.d("TAG", "Division Result = " + (num / deno));
  }
  catch (ArithmeticException ae)
  {
    Log.d("TAG", "number cannot divided by zero");
  }
}
```

### 输入/输出异常

计算系统的输入/输出功能取决于其硬件。然而，在游戏中，输入/输出异常发生在读/写操作期间。大多数游戏都是数据驱动的。基本原则是向游戏软件提供数据以控制游戏中的元素。这些数据通常存储在单独的二进制、文本、XML 或 JSON 文件中。

作为位于特定路径的单独文件，这些文件可能会丢失，特别是当这些数据文件从其他位置下载时，因为可能会出现连接中断，文件可能无法保存。在这种情况下，当游戏软件尝试加载这些文件时，就会抛出`IOException`。

让我们看一个快速的例子：

```kt
try 
{
  File dir = Environment.getExternalStorageDirectory();
  File objFile = new File(dir, "tmpPath/myfile.txt");
}
catch (IOException e) 
{
  Log.d("TAG", "Error reading file :: " + e);
}
```

### 网络异常

这是多人游戏的时代，这需要强制性的网络连接。因此，应用程序取决于现有网络连接的质量和连接性。然而，移动网络连接状态可能随时发生变化。通常，游戏开发人员忽略网络错误，导致游戏运行中崩溃、冻结或某些故障。

常见的异常处理包括`HttpRetryException`、`UnresolvedAddressException`和`NetworkErrorException`。如果任何 HTTP 请求不能自动重试，那么就会抛出`HttpRetryException`。如果应用程序想要连接到某个地址，但该地址未找到，那么就会抛出`UnresolvedAddressException`。`NetworkErrorException`用于处理任何网络故障，如网络丢失/中断、使用错误协议的网络等。

### 自定义异常

这通常用于两个目的：

+   游戏异常处理

+   游戏支持工具异常处理

游戏过程中可能会在运行时创建逻辑异常。然而，在游戏开发中，这种异常的范围很小。大多数 Android 开发人员不会这样做。

工具编程也是游戏开发过程中的重要部分。因此，如果需要，可能的异常应该由自定义异常处理。

# 在使用跨平台引擎进行 Android 调试

现代游戏编程通常不针对单一平台。大多数游戏都是跨平台的。跨平台游戏引擎对这种开发非常有用。

大多数引擎都配备了内置的性能分析器，并提供一些调试游戏的功能。然而，性能分析器功能完全依赖于特定游戏引擎的制造商。

所有本地平台都提供完整的调试信息。游戏引擎创建一个包装器，自动从一个平台配置切换到另一个，并在一个共同的用户界面中显示性能分析器的详细信息。

然而，这些跨平台调试工具会消耗额外的处理和内存。在某种程度上，它们限制了游戏资源的消耗到一定水平，并带有误差范围。

# 最佳测试实践

在 Android 游戏开发行业中有许多用于测试的标准。测试确保应用程序发布后的正确性、稳定性、功能行为和耐久性。Android 游戏测试的最常见方法是手动测试。

然而，这个过程绝对不是最佳的。作为 Android 开发人员，单元测试始终是一种最佳实践，可以节省时间并获得准确的测试结果。

## 工具和 API

有几种工具和 Android API 可用于执行测试过程。其中一些是内置的，如 Android 测试支持库、Dumpsys、Monkeyrunner 等。

大多数这些测试工具可以通过命令行触发，并通过 Android 调试桥运行。

Monkey 工具创建一个虚拟环境，模拟用户的点击、触摸、滑动等操作，以确定实时结果。Monkey 可以通过以下命令运行：

```kt
adb shell monkey –p <Game Package Name> <Event Count>
```

Dumpsys 在 Android 应用程序运行时提供系统状态。可以通过以下命令触发：

```kt
adb shell dumpsys <option>
```

Dumpsys 能够提供关于运行服务、输入系统、网络状态、RAM 使用等信息。

## 测试技术

在游戏行业中，通常使用两种测试技术：自动化测试和手动测试。我们已经简要讨论了手动测试过程。现在让我们来看看自动化测试。

自动化测试需要工具和额外的编程工作。游戏 UI、内存消耗、网络连接和输入系统测试可以自动化。单独的测试在模拟器上或实际设备上运行，以确定测试结果，并将其保存在开发系统的指定位置。

可以编写单元测试代码来验证游戏的单个模块的逻辑。单元测试可用于测试应用程序的最小可能组件，如元素、类和方法。单元测试进一步分为两个阶段：

+   本地测试

+   仪器化测试

### 本地测试

这种类型的单元测试在本地机器上运行在 JVM 上。这节省了大量的测试时间。本地测试要么不依赖于 Android 框架，要么依赖有限，可以通过虚拟对象满足。

### 仪器化测试

仪器化测试对 Android 框架有完全的依赖，必须在 Android 模拟器或 Android 设备上运行。这种测试技术用于测试 Android 游戏的运行时行为。它可以提供正在运行的应用程序的所有系统和调试信息。然而，这种技术不能轻易地与虚拟对象一起使用。开发人员需要在 Android 环境中定义测试对象数据，然后才能运行测试。

# 总结

任何开发过程如果没有质量和性能保证都是不完整的。测试是开发阶段，需要在技术和逻辑上验证游戏是否能在真实市场中运行。

测试、调试和分析游戏的阶段确保了针对目标 Android 平台范围的最佳质量。通常，Android 游戏在少数 Android 设备上可以运行，但在所有目标设备上都不能运行。开发人员可以通过详细的测试程序识别和解决一些特定设备的问题。
