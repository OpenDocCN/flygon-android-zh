# 第五章：创建用户界面

现在你已经创建了你的第一个项目，并熟悉了代码编辑器及其功能，我们将通过创建用户界面开始我们的应用程序。有没有多种方法可以使用 Android Studio 创建用户界面？你如何向你的用户界面添加组件？你是否曾想过如何让你的应用程序支持不同的屏幕尺寸和分辨率？

本章重点介绍使用布局创建用户界面。布局可以通过图形视图或基于文本的视图创建。我们将学习如何使用它们来创建我们的布局。我们还将使用简单组件编写一个 *Hello World* 应用程序。我们将了解基于不同 Android 设备的碎片化问题，以及如何为这个问题准备我们的应用程序。我们将以了解如何在我们的应用程序上处理事件的基本概念结束本章。

这是我们将在本章中讨论的主题：

+   现有的布局编辑器

+   创建新布局

+   添加组件

+   支持不同的屏幕

+   更改 UI 主题

+   处理事件

# 图形编辑器

打开位于我们项目中的 `/src/main/res/layout/activity_main.xml` 的主布局。默认情况下会打开图形编辑器。最初，这个主布局只包含一个带有 **Hello world!** 消息的文本视图。要在图形和文本编辑器之间切换，请点击底部的 **Design** 和 **Text** 标签。

![图形编辑器](img/5273OS_05_01.jpg)

工具栏包含一些用于更改布局样式和预览的选项。本章将解释工具栏的选项。

![图形编辑器](img/5273OS_05_02.jpg)

组件树显示布局中放置的组件层次结构。属性检查器显示从布局中选择的组件的属性，并允许我们更改它们。

调色板列出了可以在布局中放置的现有**UI**（**用户界面**）组件。调色板将这些组件按不同类别组织起来。

+   **布局**：布局是一个容器对象，用于在屏幕上分布组件。用户界面的根元素是布局对象，但布局也可以包含更多布局，创建在布局中结构的组件层次。建议保持这个布局层次尽可能简单。我们的主布局有一个相对布局作为根元素。

+   **小部件**：按钮、复选框、文本视图、开关、图像视图、进度条、下拉列表或网页视图都属于这一类。它们是大多数布局中最常用的组件。

+   **文本字段**：这些是用户可以输入文本的输入框。它们之间的区别在于用户可以输入的文本类型。

+   **容器**：这些容器将共享常见行为的组件组合在一起。单选按钮组、列表视图、滚动视图或标签主机都属于这一类。

+   **日期和时间**：这些是与日期和时间相关的组件，如日历或时钟。

+   **专家**：这些组件不如小部件类别中的那些常见，但值得一看。

+   **自定义**：这些组件允许我们包含自定义组件，通常是项目中的其他布局。

# 文本编辑器

通过点击**文本**标签页，将图形编辑器更改为文本编辑器。

![文本编辑器](img/5273OS_05_03.jpg)

工具栏与图形编辑器相同。预览显示布局，但无法更改，应使用设计标签页。使用组件的 XML 声明将组件添加到布局中。属性也使用 XML 声明进行配置。与图形编辑器一样，文本编辑器仅显示根布局内的文本视图元素。

# 创建新布局

创建主活动时，关联的布局也会创建。这是在创建活动时创建布局的一种方式。

如果我们想在不创建新活动的情况下添加一个独立的布局，那么请右键点击布局文件夹（`res/layout/`）并导航到**新建** | **布局资源文件**。也可以导航到菜单选项**文件** | **新建** | **布局资源文件**。输入文件名和根元素。

创建布局后，可以从编辑器将关联的活动更改为另一个。如果布局没有活动，可以从编辑器将任何现有活动与其关联。为此，在布局编辑器的工具栏中查找活动选项，点击它，然后选择**与其他活动关联**的选项。将打开一个列出项目所有活动的对话框，以便您可以选择其中之一。

# 添加组件

我们的主布局是一个相对布局，包含一个显示**Hello world!**的文本视图，但让我们添加一个新组件。最简单的方法是使用图形编辑器，因此请打开设计标签页。选择一个组件并将其拖动到布局预览中，例如，导航到**文本字段** | **Person Name**并将其放置在文本视图下方。

在组件树视图中，现在有一个新的`EditText`对象。保持文本字段的选择状态，以便在属性检查器中检查其属性。让我们更改其中一些属性，并观察布局预览和组件树中的差异。

1.  **layout:width**：其当前值为`wrap_content`。此选项将使字段的宽度适应其内容。将其更改为`match_parent`以适应父布局的宽度（根相对布局）。

1.  **hint**：将字段的提示设置为`Enter your name`。提示是在字段为空时显示的文本，指示应输入的信息。由于字段具有默认值`Name`，提示不可见。

1.  **id**：其当前 ID 是 `@+id/editText`。这个 ID 将用于代码中访问此对象，是在组件树中显示的 ID。将其更改为 `@+id/editText_name` 以便于与其他文本字段区分。检查组件树中组件 ID 是否也已更改。![添加组件](img/5273OS_05_04.jpg)

1.  **text**：删除此字段的值。现在提示应该可见。

如果我们切换到文本编辑器，我们可以看到我们编辑过的文本字段的 XML 定义：

```java
<EditText
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:inputType="textPersonName"
android:ems="10"
android:id="@+id/editText_name"
android:layout_below="@+id/textView_greeting"
android:layout_alignLeft="@+id/textView_greeting"
android:layout_marginTop="15dp"
android:hint="Enter your name"
/>
```

从文本编辑器中，也可以更改现有组件及其属性。将文本视图 ID（`android:id` 属性）从 `@+id/textView` 更改为 `@+id/textView_greeting`。拥有一个描述性的 ID 很重要，因为它将用于我们的代码中。描述性变量名可以使代码自我文档化。

这一次，让我们使用文本编辑器添加另一个组件。按下开放标签键并开始输入 `Button`。让建议列表出现并选择一个 `Button` 对象。在 `Button` 标签内，添加以下属性：

```java
<Button
android:id="@+id/button_accept"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_below="@+id/editText_name"
android:layout_centerHorizontal="true"
android:text="Accept"
/>
```

创建 ID 属性，值为 `@+id/button_accept`。让宽度和高度适应按钮内容（`wrap_content` 值）。使用 `android:layout_below` 属性将按钮放置在名字文本字段下方。我们通过其 ID（`@+id/editText_name`）引用名字文本字段。使用 `layout_centerHorizontal` 属性在父布局中水平居中按钮。设置按钮的文本（`Accept`）。

按钮在布局预览中显示。下一张截图显示，如果我们切换到图形编辑器，按钮也会在其中和组件树中显示：

![添加组件](img/5273OS_05_05.jpg)

# 支持多屏幕

在创建 Android 应用程序时，我们必须意识到存在多种屏幕尺寸和屏幕分辨率。检查我们的布局在不同屏幕配置下的显示情况非常重要。为了实现这一点，Android Studio 提供了一个功能，可以在设计模式下更改布局预览。

我们可以在工具栏中找到这个功能，预览中使用的**设备定义**选项默认为**Nexus 4**。点击它打开可用设备定义的列表。

![支持多屏幕](img/5273OS_05_06.jpg)

尝试一些设备。平板设备与 Nexus 等设备的区别非常明显。我们应该调整视图以适应应用程序支持的所有屏幕配置，以确保它们能够最佳显示。

设备定义指出了屏幕英寸、分辨率和屏幕密度。Android 将屏幕密度分为 ldpi、mdpi、hdpi、xhdpi 甚至 xxhdpi。

+   **ldpi**（**低密度每英寸点数**）：大约 120 dpi

+   **mdpi**（**中密度每英寸点数**）：大约 160 dpi

+   **hdpi**（**高密度每英寸点数**）：大约 240 dpi

+   **xhdpi**（**超高密度每英寸点数**）：大约 320 dpi

+   **xxhdpi** (**超超高密度每英寸点数**): 大约 480 dpi

谷歌最近发布的数据显示，大多数设备具有高密度屏幕（34.3%），其次是 xxhdpi（23.7%）和 mdpi（23.5%）。因此，通过测试这三种屏幕密度，我们可以覆盖 81.5% 的设备。官方的 Android 数据面板可以在 [`developer.android.com/about/dashboards`](http://developer.android.com/about/dashboards) 上找到。

另一个需要考虑的问题是**设备方向**。我们是否希望应用程序支持横屏模式？如果答案是肯定的，我们必须在横屏方向上测试我们的布局。在工具栏上，点击布局状态选项，将模式从纵向切换到横向，或从横向切换到纵向。

如果我们的应用程序支持横屏模式，且布局在此方向上显示不如预期，我们可能需要创建布局的变体。点击工具栏上的第一个图标，即配置选项，并选择 **创建横屏变体** 选项。将在编辑器中打开一个新的布局。这个布局已经在资源文件夹中创建，位于 `layout-land` 目录下，并使用与纵向布局相同的名称：`/src/main/res/layout-land/activity_main.xml`。现在我们可以完美地编辑符合横屏模式的新布局变体。

同样，我们可以为 *xlarge* 屏幕创建布局的变体。选择 **创建 layout-xlarge 变体** 选项。新的布局将在 `layout-xlarge` 文件夹中创建：`/src/main/res/layout-xlarge/activity_main.xml`。Android 将实际屏幕尺寸分为 *small*、*normal*、*large* 和 *xlarge*。

+   **small**: 归入此类别的屏幕至少为 426 dp x 320 dp

+   **normal**: 归入此类别的屏幕至少为 470 dp x 320 dp

+   **large**: 归入此类别的屏幕至少为 640 dp x 480 dp

+   **xlarge**: 归入此类别的屏幕至少为 960 dp x 720 dp

**dp** 是一个与密度无关的像素单位，相当于在 160 dpi 屏幕上的一个物理像素。

谷歌最近发布的数据显示，大多数设备具有正常屏幕尺寸（79.6%）。如果你想覆盖更多比例的设备，还可以使用小屏幕（9.5%）测试你的应用程序，这样覆盖的设备比例将达到 89.1%。

要同时显示多个设备配置，请在工具栏上点击配置选项，并选择 **预览所有屏幕尺寸** 的选项，或者点击 **预览代表性样本** 来打开最重要的屏幕尺寸。我们还可以通过右键点击样本并选择菜单中的 **删除** 选项来删除任何样本。此菜单中的另一个有用操作是 **保存截图** 选项，它允许我们截取布局预览的屏幕截图。

![支持多屏幕](img/5273OS_05_07.jpg)

如果我们创建了一些布局变体，可以选择 **预览布局版本** 选项来预览所有这些变体。

# 更改 UI 主题

布局和小部件是使用我们项目的默认 UI 主题创建的。我们可以通过创建样式来改变 UI 元素的外观。样式可以分组以创建一个主题，主题可以应用于整个活动或应用程序。一些默认提供的主题，例如 Holo 风格。样式和主题是在 `/src/res/values` 文件夹下作为资源创建的。

使用图形编辑器打开主布局。我们布局所选的主题在工具栏中指示为：`AppTheme`。这个主题是为我们的项目创建的，可以在样式文件（`/src/res/values/styles.xml`）中找到。打开样式文件，注意到这个主题是另一个主题（`Theme.Light`）的扩展。

要自定义我们的主题，请编辑样式文件。例如，在 `AppTheme` 定义中添加下一行以更改窗口背景颜色：

```java
<style name="AppTheme" parent="AppBaseTheme">
<item name="android:windowBackground">#dddddd</item>
</style>
```

保存文件并切换到布局标签。现在背景是浅灰色。由于我们在主题中配置了此背景色，而不是仅在布局中，因此它将被应用到我们所有的布局中。

要完全更改布局主题，请在图形编辑器的工具栏中点击主题选项。现在打开了主题选择对话框，显示可用主题的列表。

![更改 UI 主题](img/5273OS_05_08.jpg)

我们自己项目中创建的主题列在**项目主题**部分。**清单主题**部分显示了在应用程序清单文件（`/src/main/AndroidManifest.xml`）中配置的主题。**所有**部分列出了所有可用的主题。

# 处理事件

如果应用程序的其余部分不能与用户界面交互，那么用户界面将毫无用处。在用户与我们的应用程序交互时，会在 Android 中生成事件。所有 UI 小部件都是 `View` 类的子类，它们共享一些由以下监听器处理的事件：

+   `OnClickListener`：捕获用户点击视图元素时的事件

+   `OnCreateContextMenu`：捕获用户在视图元素上执行长按操作并且我们想要打开上下文菜单时的事件

+   `OnDragListener`：捕获用户拖放事件元素时的事件

+   `OnFocusChange`：捕获用户在相同视图中从一个元素导航到另一个元素时的事件

+   `OnKeyListener`：捕获用户在视图元素具有焦点时按下任意键的事件

+   `OnLongClickListener`：捕获用户触摸并按住视图元素时的事件

+   `OnTouchListener`：捕获用户触摸视图元素时的事件

除了这些事件和监听器之外，一些 UI 小部件还有一些更具体的事件。复选框可以注册一个监听器来捕获其状态变化（`OnCheckedChangeListener`），或者下拉列表可以注册一个监听器来捕获点击项目的事件（`OnItemClickListener`）。

最常见的事件是捕获用户点击视图元素的时候。对于这个事件，有一种简单的方法来处理它，即使用视图属性。在我们的布局中选择接受按钮，并查找`onClick`属性。此属性指示当用户点击按钮时将执行的方法的名称。这个方法必须在关联当前布局的活动中创建，在本例中，是在我们的主活动`MainActivity.java`中创建。将`onAcceptClick`作为此属性的值输入。

打开主活动以创建方法定义。当一个视图被点击时的事件回调方法必须是公开的，返回类型为 void，并且接收被点击的视图作为参数。每次用户点击按钮时，都会执行此方法。

```java
public void onAcceptClick(View v) {
  // Action when the button is pressed
}
```

从主活动中，我们可以与界面上的所有组件进行交互，因此当用户点击接受按钮时，我们的代码可以读取名字字段的文本，并将问候语更改为包含名字的内容。

要获取对视图对象的引用，请使用从`Activity`类继承的`findViewById`方法。此方法接收组件的 ID 并返回与该 ID 对应的`View`对象。返回的视图对象必须转换为其特定的类，以便使用其方法，例如`EditText`类的`getText`方法，以获取用户输入的名字。

```java
public void onAcceptClick(View v) {
  TextView tv_greeting =
    (TextView) findViewById(R.id.textView_greeting);
  EditText et_name = (EditText) findViewById(R.id.editText_name);

  if(et_name.getText().length() > 0) {
    tv_greeting.setText("Hello " + et_name.getText());
  }
}
```

在方法的头两行中，获取了对布局元素的引用：包含问候语的文本视图和用户可以输入名字的文本字段。通过其 ID 找到组件，这是我们在布局文件中指定元素的属性中的相同 ID。所有资源的 ID 都包含在`R`类中。`R`类是在构建阶段自动生成的，我们不得编辑它。如果此类未自动生成，则我们的资源文件中可能包含错误。

下面的行是一个条件语句，用于检查用户是否输入了名字，如果是这种情况，文本将被替换为包含该名字的新问候语。在下一章中，我们将学习如何在模拟器中执行我们的应用程序，并且我们将能够测试这段代码。

如果我们要处理的事件不是用户点击，那么我们必须在活动的`onCreate`方法中通过代码创建并添加监听器。有两种选择：

+   在活动中实现监听器接口，然后添加未实现的方法。接口需要的方法是接收事件的方法。

+   在活动文件中创建一个私有的匿名监听器实现。在这个对象中实现了接收事件的方法。

最后，需要通过设置器方法（如`setOnClickListener`、`setOnCreateContextMenu`、`setOnDragListener`、`setOnFocusChange`、`setOnKeyListener`等）将监听器实现分配给视图元素。监听器的分配通常包含在活动的`onCreate`方法中。如果监听器是由活动直接实现的，那么传递给设置器方法的参数就是它自己的活动，使用关键字`this`，如下面的代码所示：

```java
Button b_accept = (Button) findViewById(R.id.button_accept);
b_accept.setOnClickListener(this);
```

活动应该实现监听器所需的`onClick`方法和监听器接口。

```java
public class MainActivity extends Activity 
implements View.OnClickListener {
  @Override
  public void onClick(View view) {
    // Action when the button is pressed
  }
```

# 总结

到本章结束时，我们已经学会了如何使用图形编辑器和基于文本的编辑器创建和编辑用户界面布局。我们完成了第一个小应用程序，并用一些基本组件对其进行了升级。用户现在应该能够创建一个简单的布局，并通过不同的样式、屏幕尺寸和屏幕分辨率进行测试。我们还了解了可用的不同 UI 主题，最后，我们学习了关于事件以及如何使用监听器处理它们。

在下一章中，我们将学习 Google Play 可用的服务以及如何使用 Android Studio 将它们集成到我们的项目中。我们将学习如何安装和集成不同的库，这些库可使用谷歌技术，如 Google Maps、Google Plus 等。
