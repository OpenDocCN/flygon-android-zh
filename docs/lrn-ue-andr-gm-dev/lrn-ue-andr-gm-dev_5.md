# 第五章：使用蓝图编写脚本

现在我们来到游戏中最重要的一个方面：互动性。没有它，我们的游戏只是玩家可以在其中移动的环境。以前使用过 UDK 的人可能已经熟悉视觉脚本的概念。UDK 有一个称为 Kismet 的强大的视觉脚本工具。这个工具的一个非常吸引人的特点是任何人都可以在没有任何编程知识的情况下使用它。您只需要知道您希望实现的事件背后的逻辑。您甚至可以在不写一行代码的情况下创建一个完整的游戏。

在虚幻 4 中，我们有蓝图，这在某种程度上是对 Kismet 的升级。基本设置是相同的：您有各种节点和表达式，可以用来编写游戏事件、动作等。界面简单易懂，易于使用，但功能强大。一旦掌握了它，您就可以创建复杂的序列和事件。

然而，尽管蓝图是一种易学易用的工具，但在功能上仍然存在一定的局限性。在这方面，C++比蓝图更加灵活和多功能。C++非常适合实现复杂的交互和机制，而蓝图可能提供或可能不提供。蓝图和 C++之间的另一个区别是，蓝图执行速度比 C++代码慢得多，但只有在游戏中有大量蓝图脚本时才会注意到这一点。蓝图和 C++之间还有其他几个区别；但最终都取决于您对游戏中所需功能、机制和功能的个人偏好。您可以选择使用其中一个或两者兼而有之。

在本章中，我们将涵盖以下主题：

+   蓝图是什么以及它们的工作原理

+   什么是级别蓝图以及如何使用级别蓝图进行脚本编写

+   级别蓝图用户界面

+   蓝图类是什么以及如何在游戏中使用它

+   如何编写基本 AI

# 蓝图的工作原理

蓝图中的脚本与创建流程图类似。您可以连接各种节点以创建动作序列。为了正确地在蓝图中编写脚本，您应该首先了解所需序列背后的逻辑。例如，假设您想要实现一个灯，当您靠近它时打开，当您远离它时关闭。在这种情况下，您首先会在灯周围放置一个触发器。然后，这背后的逻辑将是：

1.  如果玩家与触发器重叠，灯将被打开。

1.  如果玩家没有与触发器重叠，灯将被关闭。

现在我们已经找到了如何执行此操作，我们可以继续设置我们的节点。假设您的设置看起来像这样：

![蓝图的工作原理](img/image00317.jpeg)

当角色走进箱形触发器时，天花板灯（聚光灯）将被打开。切换灯的蓝图将看起来像这样：

![蓝图的工作原理](img/image00318.jpeg)

有各种类型的节点，您应该了解：

+   **事件节点**：红色条的节点是事件节点。这些在相应事件发生时被激活。它们通常在左上角有一个向右的箭头。

您还有输入事件节点，当玩家按下相应的输入时触发（例如，当玩家按下鼠标左键时开火）。

+   功能节点：蓝色顶部的节点是功能节点。通常在左上角有一个函数符号**f**，就像你在前面的截图中看到的那样。这些节点对演员或玩家执行特定操作。

有两种类型的功能节点：那些对演员产生影响的节点，以及返回特定值的节点。这些类型的节点具有绿色顶部（未在截图中显示）。这包括返回世界中演员的位置，返回演员的速度等。

+   **引用或变量节点**：屏幕截图中心的节点是一个变量节点（或引用）。当您希望函数节点作用于场景中的特定角色，或者如果您想要“获取”其某些属性，您需要在级别蓝图中创建其引用。变量节点也是如此。毫无疑问，变量在脚本或编码时起着非常重要的作用。因此，当您使用蓝图时，自然会创建变量。

在使用蓝图进行脚本编写时，请记住节点越少，性能越好。这也使您的工作区更有组织且更易于阅读。

当特定事件发生时，相应的事件节点会触发脉冲到其连接的任何节点。在我们的情况下，当玩家重叠触发器时，它将激活聚光灯的**切换可见性**功能（因为灯默认是关闭的，它将切换为开启）。当玩家停止重叠触发器（走出触发器）时，它将再次触发**切换可见性**功能（灯将关闭）。

![蓝图的工作原理](img/image00319.jpeg)

前面的屏幕截图演示了事件发生时蓝图的功能。当玩家重叠触发器（左上角）时，相应的事件会触发脉冲到**切换可见性**功能，切换灯光开启。当玩家移出触发器或停止重叠时，相应的事件再次触发脉冲到**切换可见性**功能节点，切换灯光开启。

您实际上可以看到每当节点被激活时脉冲被触发。这使得调试非常容易，因为您可以看到哪个节点导致了问题，并相应地进行修复。

除了了解逻辑，您还应该知道哪些节点可用以及它们可以用来做什么。这需要时间和实践。

虚幻 4 中有两种蓝图：级别蓝图和蓝图类。

级别蓝图对于 UE4 来说就像 Kismet 对于 UE3 一样。您在项目文件中创建的每个级别或地图都将有其自己独特的级别蓝图。您可以使用级别蓝图控制与级别相关的一切，例如播放过场动画，在您的级别中编辑角色的属性（可见性、位置等）等等。

另一方面，蓝图类是包含各种组件和脚本的特殊角色。这些组件包括静态或骨骼网格、摄像机、碰撞组件、触发器和音频组件等。通过脚本，您可以设置它们的属性并确定它们如何与世界交互。蓝图类不是特定于特定级别的；因此，您可以在您项目中制作的任何地图或级别中使用它们。您还可以将它们导出到其他项目中。

让我们继续讲解级别蓝图的用户界面。

# 级别蓝图用户界面

以下屏幕截图显示了级别蓝图的用户界面。继续我们将界面分成各个部分的风格，界面被分成了几个部分，我们将逐个介绍。

![级别蓝图用户界面](img/image00320.jpeg)

## 选项卡和菜单栏

选项卡栏与所有其他窗口中看到的相同。就像在 Web 浏览器中一样，您可以看到哪些窗口是打开的，在它们之间切换，并从那里关闭任何窗口。

![选项卡和菜单栏](img/image00321.jpeg)

菜单栏是您可以访问所有通用命令和操作的地方。

+   **文件**：在此菜单中，您可以保存您的级别，打开内容浏览器中的任何资产，编译蓝图，启用源代码控制等等。

+   **编辑**：从此菜单中，您可以执行撤消上一个操作、重做操作、搜索特定节点或表达式等操作。

+   **视图**：在这里，您可以隐藏/显示未使用的引脚和未连接的引脚（通过它们连接节点），在事件图中放大和缩小。

+   **调试**：如果您的蓝图序列中有问题，您无法解决，您可以使用调试菜单中提供的选项来查找和解决问题。这包括添加断点、观察特定变量在特定点的值等。

+   **窗口**：在这里，您可以设置要显示的窗口和不想显示的窗口。您可以从窗口菜单中自定义布局并保存它。

+   **帮助**：从这里，您可以访问 Epic 官方关于蓝图的文档。您还可以从这里访问 Wiki 页面、论坛和答案中心。

## 工具栏

**工具栏**包含最常用的操作：

![工具栏](img/image00322.jpeg)

最常用的操作解释如下：

+   **编译**：每当您在事件图中添加、删除或编辑任何节点时，请务必点击**编译**按钮。它会编译所有节点和序列，如果有任何错误或警告，它会在**编译器结果**面板中通知您，然后您可以进行修复。此外，如果您有一个变量节点，为了设置其默认值，您首先需要编译。

+   **搜索**：当您有大型和复杂的序列，有几个连接的节点时，尝试找到特定节点或变量可能是一项繁琐和耗时的任务。为了避免这种情况，您可以点击**搜索**按钮，然后输入您想要查找的内容的名称。结果将默认显示在屏幕底部，**编译器结果**面板所在的位置（它将打开一个名为**查找结果**的新选项卡）。

+   **类设置**：点击这个按钮将在**详细信息面板**中打开蓝图设置，您可以在那里设置某些选项，比如添加描述、类别等。

+   **类默认**：在这里，您可以设置蓝图类的默认或初始值。

+   **播放**：类似于**视口**工具栏中的**播放**按钮，这将打开一个新窗口，您可以在其中测试您的游戏。游戏运行时，点击*Esc*按钮将关闭游戏并返回到编辑器。您可能会注意到按钮旁边有一个小向下的箭头。这将打开一个菜单，您可以在其中设置选项，比如您想要预览游戏的方式，玩家应该从哪里开始等等。

## 详细信息面板

在**详细信息**面板中，您可以设置各种节点和变量的属性。它提供设置，比如您想要的变量类型（布尔值、浮点数、整数等）、变量名称等。

![详细信息面板](img/image00323.jpeg)

## 编译器结果面板

任何具有编程知识的人都会知道什么是编译。当您编写的代码从您编写代码的语言转换为计算机理解的机器语言时，就会发生编译，以便可以执行。这通常由编译器处理。（如果您在级别蓝图中看不到**编译器结果**面板，请转到窗口，然后点击**编译器结果**。）

![编译器结果面板](img/image00324.jpeg)

在**编译器结果**面板中，您可以看到编译器的输出日志。编译花费了多长时间，编译期间发现的任何错误，任何警告等都会显示在这里。

## 我的蓝图面板

在这个面板中，您可以看到您创建的所有事件、变量和事件分发器的列表。每当您创建一个事件节点，它都会显示在**事件图**下面。除此之外，您还可以创建各种函数、宏、变量等。要这样做，您可以点击**添加新**按钮，然后选择您想要创建的内容，或者点击名称前面的**+**按钮。

![我的蓝图面板](img/image00325.jpeg)

## 事件图

位于屏幕中央的**事件图**（也称为**图编辑器**）是您设置节点和序列的地方。默认情况下，已经设置了两个事件节点，即**事件开始播放**，在游戏开始时激活，以及**事件 Tick**，在每一帧激活。这两个事件不需要任何触发器来激活。

![事件图](img/image00326.jpeg)

在顶部，您可以看到选项卡。在选项卡下方，左上角有两个箭头。您可以使用它们在图表之间切换。在中心，您可以看到层次结构和蓝图结构。在极右边，您可以看到缩放比例—换句话说，您已经缩放了多少。

下表列出了您应该了解和记忆的**事件图**的控件：

| 控制 | 动作 |
| --- | --- |
| 鼠标左键单击 | 选择节点 |
| 左键单击+拖动 | 创建选择框 |
| 右键单击 | 打开操作菜单 |
| 右键单击+拖动 | 平移图编辑器 |
| 滚轮向上 | 放大 |
| 滚轮向下 | 缩小 |
| C | 在选定的节点周围创建注释框 |

### 注意

尽管它是可视化脚本，但使用蓝图进行编写时仍然可能会变得非常混乱。因此，为了避免混淆并保持一切有序，建议在节点周围创建注释框。

# 在游戏中使用关卡蓝图

现在，我们已经了解了所有基础知识，可以开始编写游戏了。您应该知道的一件事是，随着游戏的进行，我们可能会添加更多的触发器和角色。

## 钥匙立方体拾取和放置

我们要编写的第一件事是玩家拾取钥匙立方体。现在，当玩家靠近钥匙立方体并在屏幕上点击它时，他们将能够拾取立方体。在我们的情况下，为了让玩家产生拾取钥匙的错觉，当玩家在屏幕上点击时，我们将销毁该角色。此外，我们将在底座顶部放置一个钥匙立方体的复制品，并在游戏开始时将其隐藏起来。当玩家拾取了立方体并且靠近底座时，在屏幕上点击将使立方体从游戏中显示出来，给人一种角色已经将钥匙放在底座上的印象。所以，让我们设置一下。首先，选择钥匙立方体，按住*Alt*按钮，并借助变换工具，拖出一个副本。将这个副本放在底座顶部。

![钥匙立方体拾取和放置](img/image00327.jpeg)

在其**详细信息**面板中，在**渲染**部分下，选中**游戏中隐藏的角色**选项。这样做将在运行时隐藏游戏。

![钥匙立方体拾取和放置](img/image00328.jpeg)

现在，让我们打开关卡蓝图。要做到这一点，点击**视口**工具栏中的**蓝图**，然后选择**打开关卡蓝图**。

现在，在这种情况下，事件是玩家在屏幕上轻触，或者在技术术语中，提供触摸输入。因此，在**事件图**窗口中，右键单击打开**操作**菜单，然后键入`Touch`。这样应该可以找到并显示**Touch**事件节点。单击它以将其添加到**事件图**中。您可能会找到各种类型的**Touch**节点—您需要的是简单地说**Touch**的节点。

![钥匙立方体拾取和放置](img/image00329.jpeg)

在**InputTouch**事件节点中，我们只关注**Pressed**输出引脚。当玩家在屏幕上按下时，**Pressed**引脚将被激活。

为了从场景中移除盒子，我们将使用**销毁演员**功能节点。因此，在**图形编辑器**中的任何位置右键单击，键入`销毁演员`，然后点击结果（你也可以在**实用工具**部分手动找到它）。有了这两个节点后，将**按下**输出引脚连接到**销毁演员**输入引脚。现在，函数不知道它自己要销毁哪个演员。我们必须告诉它我们想要摆脱哪个演员。在蓝图术语中，我们必须创建一个对我们希望应用该函数的演员的引用。因此，在**视口**中，选择关键立方体。然后，在**图形编辑器**中，右键单击并选择**创建对 TemplateCube_Rounded 的引用**。

如果你的对象有不同的名称，而不是**TemplateCube_Rounded**，你会看到演员的名称。

![关键立方体的拾取和放置](img/image00330.jpeg)

这样做将创建一个带有演员名称的参考节点。将其连接到**销毁演员**目标引脚。

另一种方法是拖动参考节点的输出引脚，并将其释放到**事件图**中的任何位置。这样将打开一个菜单，你可以从中选择**销毁演员**节点。一旦创建，参考节点将自动连接到它。到目前为止，设置应该是这样的：

![关键立方体的拾取和放置](img/image00331.jpeg)

然而，这里有一个问题。如果你测试你的游戏，你会注意到无论你在屏幕上点击哪里，立方体都会被销毁。我们只希望当玩家足够靠近时才销毁立方体。

为了解决这个问题，我们要做的第一件事是在游戏开始时禁用输入。你可能还记得，当游戏开始时激活的事件节点**事件开始播放**已经存在于**图形编辑器**中。我们要在这个事件上附加一个**禁用输入**节点。右键单击并找到该节点，并将其连接到**事件开始播放**。

![关键立方体的拾取和放置](img/image00332.jpeg)

### 注意

虽然现在不是必需的，但如果你的游戏有多个玩家或控制器，你将不得不指定要禁用哪个玩家的控制器。首先创建一个**获取玩家控制器**节点，并将其附加到**禁用输入**节点中的**玩家控制器**。默认情况下，你所扮演的角色的**玩家索引**为 0。

如果你现在测试你的游戏，当你点击屏幕时，关键立方体不会被销毁（尽管角色会再次开始发射抛射物）。现在，回到我们的顺序，因为我们希望玩家只能在与我们放置在关键立方体周围的触发器重叠时才能拾取立方体，所以我们将在他们与触发器重叠时启用他们的输入。

选择触发器后，创建一个**事件开始重叠**节点。创建后，创建一个**启用输入**节点，并将其连接到**事件开始重叠**节点的输出引脚。

![关键立方体的拾取和放置](img/image00333.jpeg)

我们现在几乎完成了设置。如果你现在测试它，你会发现它的功能方式与我们打算的一样。然而，这还不完整。首先，如果你的房间里有多个关键立方体，当你点击其中一个时，它们都会消失。我们不希望这样；我们只希望玩家拾取的关键立方体消失。为此，我们将使用一个**Gate**节点。**Gate**节点用于根据你可以设置的某些条件来控制通过节点的脉冲。例如，你可以设置它在发生某个事件时**打开**，等等。例如，当玩家与触发器重叠时，它将打开门，允许脉冲通过它。

在**事件图**中的任何位置右键单击，然后键入`Gate`。然后，点击放置它。你也可以在**实用工具** | **流程控制** | **Gate**下找到它。

![关键立方体的拾取和放置](img/image00334.jpeg)

您希望控制的事件与**Gate**节点的**Enter**输入相连。其余的事件用于控制流程。将**Close**输入连接到事件将会阻止任何东西通过**Gate**当事件发生时。同样，将**Open**输入连接到事件或功能将允许脉冲通过节点。**Toggle**节点将打开**Gate**节点（如果最初关闭）或反之亦然。最后，您有一个**Start Closed**引脚，它设置了**Gate**节点的初始状态。如果选中，它最初将关闭，取消选中则最初将打开。

首先，断开**Pressed**引脚与**InputTouch**节点的连接，而是将其连接到 Gate 节点的**Enter**引脚。然后，将**Exit**引脚连接到**Destroy Actor**函数的输入引脚。完成后，我们需要一个事件来打开 Gate 节点。这个事件是玩家与触发器重叠时。因此，将**Enable Input**节点的输出引脚连接到 Gate 节点的**Open**输入引脚（确保**Start Closed**已选中）。您的设置应该如下所示：

![关键方块拾取和放置](img/image00335.jpeg)

现在，当玩家走出触发器，也就是停止与触发器重叠时，我们再次希望禁用输入。因此，选择触发框，创建一个**OnActorEndOverlap**节点。您可以在搜索栏中输入或在<actor 名称> | **Collision** | **Add On Actor End Overlap**下找到它。还要创建一个**Disable Input**节点。同样，您可以输入或在**Input** | **Disable Input**下找到它。设置好一切后，我们应该得到以下结果：

![关键方块拾取和放置](img/image00336.jpeg)

现在我们有了一个简单的拾取动作。但在完成之前，我们还有更多工作要做。我们只是编写了拾取方块的脚本。我们还需要为玩家放置关键方块编写脚本。这很简单。

我们需要做的第一件事是添加一个重叠事件，以启用玩家的输入。将它们与之前的触发器连接方式相同。接下来，我们将添加另一个触摸事件节点。我们将连接一个**Set Actor Hidden in Game**节点。首先，选择另一个关键方块（在游戏中隐藏的那个），然后在**Graph Editor**中的任意位置右键单击，并通过搜索栏找到它。您还可以在<所选角色名称> | **Rendering** | **Set Actor Hidden in Game**中找到它。当您创建此节点时，将自动创建一个关键方块的引用节点，并连接到**Target**输入。接下来，将**Pressed**输出引脚连接到**Set Actor Hidden in Game**节点的输入引脚。完成后，添加一个**Gate**节点，将其**Toggle**输入连接到**Enable Output**节点的输出。

最后，创建一个**OnActorEndOverlap**节点，并像之前的触发器一样连接一个**Disable Input**节点。

![关键方块拾取和放置](img/image00337.jpeg)

如果您进行测试，您会发现它完美地运行。但是，这里有一个问题：我们没有设置玩家何时可以放置或显示底座上的关键方块的条件。换句话说，如果玩家只是走到底座旁，而没有拾取第一个关键方块，他们仍然可以显示其他关键方块，因为这意味着玩家可以在不拾取关键方块的情况下通过房间。

为了解决这个问题，我们首先要改变基座上触发器的一些属性。我们需要首先关闭触发器的碰撞。我们将设置它，使得最初，基座上的触发器忽略所有类型的重叠事件，换句话说，将其关闭。要这样做，选择基座上的触发器，在详细面板中，转到**碰撞**部分。在这个部分下，你会看到一个名为**碰撞预设**的选项。默认情况下，它将被设置为**触发器**。点击条以打开预设菜单。从这里，选择**自定义**。

![关键立方体拾取和放置](img/image00338.jpeg)

接下来，点击**碰撞预设**旁边的小三角，以打开触发器对不同类型角色的碰撞响应列表。有三种一般的响应：

+   **忽略**：触发器不会对碰撞做出任何响应。触发器设置为忽略的角色既不会被阻挡，也不会被它注册。

+   **重叠**：触发器设置为重叠的角色不会被它阻挡，但碰撞会被它注册。这种碰撞注册是我们能够编写脚本的方式，比如当玩家重叠触发器时开灯。

+   **阻挡**：触发器设置为阻挡的角色将无法通过它。它会像一堵墙一样。

你可以为每个角色单独设置所需的响应，也可以选择所有角色所需的一般响应。我们将选择后者。在最顶部，有一个名为**碰撞响应**的选项。在它前面，有三个框，分别对应每种响应类型。简单地勾选**忽略**框，下面的所有内容都将被设置为忽略。这就是我们想要的。我们希望触发器最初忽略所有角色的碰撞。当玩家拾取了关键立方体后，我们将改变它的碰撞响应。

回到我们之前设置的拾取，我们需要向其中添加一些节点。在**事件图**中的任意位置右键单击，在**流程控制**部分，你会找到一个叫做**序列**的东西。选择并创建它。**序列**节点有一个输入和多个输出。如果你想要一个特定的节点来触发或设置各种不同的事件或功能，你应该使用**序列**节点。

![关键立方体拾取和放置](img/image00339.jpeg)

默认情况下，**序列**节点有一个输入引脚和两个输出引脚。第一个节点首先触发，然后是下一个，依此类推。如果你想要更多的输出引脚，只需点击**添加引脚**，它将创建另一个输出引脚。现在，将**门**节点的输出引脚连接到**序列**节点的输入引脚。然后，将**然后 0**连接到**销毁角色**节点。

![关键立方体拾取和放置](img/image00340.jpeg)

当玩家拾取了立方体后，我们将现在将触发器的**碰撞响应**改为**重叠**。选择触发器，右键单击它，首先取消选中**上下文敏感**框，它位于菜单右上角。当你在**视口**中选择一个角色并在**图形编辑器**中右键单击时，你可以看到的事件节点和函数节点通常与所选角色相关。它们只显示可以直接应用于角色的函数和表达式。否则，蓝图提供了相当多的节点，但其中一些不能直接或根本不能用于所选角色。

我们需要的节点是一个可以应用于触发器的节点，但不是直接的。我们需要的是一个**设置所有通道的碰撞响应**节点。这个节点可以用于在运行时改变角色的碰撞响应。在**事件图**中右键单击，输入节点的名称并创建它。

![关键立方体拾取和放置](img/image00341.jpeg)

在这里，您可以设置希望更改其**碰撞响应**的目标角色。如果单击下拉菜单，您将看到三种设置：**忽略**、**重叠**和**阻挡**。如果您回忆一下，这些是触发器**碰撞**部分中的三种响应类型。我们将其设置为**忽略**，但是我们希望在玩家拾起钥匙立方体后将其更改为**重叠**。因此，在下拉菜单中选择**重叠**。接下来，将**然后 1**引脚连接到此节点的输入。最后，选择**视口**中的触发器，在**图形编辑器**中右键单击，勾选**上下文敏感**框，并为<actor name>选择**创建引用**。将其连接到**设置所有通道的碰撞响应**节点的**目标**输入。当您这样做时，您会发现它并不直接连接到**目标**输入。相反，会创建一个新节点，该节点以触发器的引用作为其输入，并将**碰撞组件**作为其输出。这样做的作用是将触发器框转换为称为**基本组件引用**的东西。这是您可以将其连接到此节点的唯一方法。

![钥匙立方体拾取和放置](img/image00342.jpeg)

如果我们现在测试游戏，我们会发现事情正在按照我们想要的方式运行。我们将无法在没有先拾起它的情况下放置钥匙立方体。

我们在这里的设置几乎完成了。记得我们在钥匙立方体周围放置了一个**后期处理体**，它将作为玩家拾起钥匙立方体的视觉指示器？我们也需要对其进行脚本编写。我们最初将其设置为禁用状态。我们将通过**蓝图**启用它，然后在非常短的时间后销毁它。首先，向**序列**节点添加一个新的引脚。接下来，选择**后期处理体**，在**图形编辑器**中右键单击并为其创建一个引用。然后，单击其输出引脚，拖动它并释放左鼠标按钮以打开菜单。在这里，您可以输入**设置启用**，这将创建一个**布尔**节点（布尔节点为红色）。创建后，您将看到一个复选框，上面写着**启用**。选中该框，并将其连接到**序列**节点的**然后 2**输出引脚。

接下来，我们需要在短暂的时间后销毁角色。为此，我们需要创建一个**延迟**节点。**延迟**节点接收输入，并在一定时间后触发脉冲（您可以设置）。在**图形编辑器**中右键单击，输入**延迟**并创建它。您还可以在**实用工具** | **流程控制** | **延迟**下找到它。节点中有一个名为**持续时间**的选项。在这里，您可以设置在触发脉冲之前要等待多长时间。现在，将其保留在默认值（即`0.2`秒），并将其连接到**设置启用**节点。最后，创建一个**销毁角色**节点，将其连接到**延迟**节点，并将**后期处理体**设置为其目标。您可以通过单击*Ctrl* + *C*选择**设置启用**节点的后期处理引用，然后*Ctrl* + *V*）创建一个副本并将此副本连接到**销毁角色**节点的**目标**输入。

![钥匙立方体拾取和放置](img/image00343.jpeg)

就是这样！我们为我们的钥匙立方体设置了拾取和放置系统。我们还有一个视觉指示器，表明我们已经拾起了立方体（我们将在下一章中介绍如何编写门的开关）。尽管这是一个相当简单和小的设置，但为每个钥匙立方体都这样做将是一项繁琐的工作。想象一下，如果您的游戏有 10…20…50…100 个房间！您将不得不为游戏中的每个钥匙立方体编写脚本，并浪费大量时间。幸运的是，UE4 提供了一些方法来解决这种情况：**蓝图**类。

# 蓝图类

如前所述，为每个关键立方体编写脚本将是一项乏味且耗时的任务。使用蓝图类，您只需要进行一次所有脚本编写和其他操作。蓝图类是一个包含在其中进行脚本编写的演员（静态网格、体积、摄像机类、触发盒等）的实体。再次看看我们的例子，比如灯的开关，假设您想放置 10 盏这样的灯。使用蓝图类，您只需创建并编写一次，保存并复制。这真是 UE4 提供的一个令人惊叹的功能。

## 创建蓝图类

要创建蓝图类，请单击**视口**工具栏中的**蓝图**按钮，在下拉菜单中选择**新建空蓝图类**。然后会打开一个窗口，询问您选择父类，指示您希望创建的蓝图类的类型。

![创建蓝图类](img/image00344.jpeg)

在顶部，您将看到最常见的类。它们如下：

+   演员：如前所述，**演员**是可以放置在世界中的对象（静态网格、触发器、摄像机、体积等都算作演员）

+   棋子：**棋子**是可以由玩家或计算机控制的演员

+   **角色**：这类似于**棋子**，但具有四处走动的能力

+   **玩家控制器**：负责在游戏中为**棋子**或**角色**提供输入或控制

+   **游戏模式**：负责游戏规则的所有内容

+   演员组件：您可以使用这个创建一个组件并将其添加到任何演员

+   场景组件：您可以创建可以附加到其他场景组件的组件

除此之外，还有其他类可供选择。要查看它们，请单击**所有类**，这将打开一个菜单，列出您可以创建蓝图的所有类。对于我们的关键立方体，我们需要创建一个**演员蓝图类**。选择**演员**，然后会打开另一个窗口，询问您希望将其保存在何处以及如何命名。将其命名为**Key_Cube**，并将其保存在`蓝图`文件夹中。满意后，单击**确定**，**演员蓝图类**窗口将打开。

![创建蓝图类](img/image00345.jpeg)

蓝图类用户界面与关卡蓝图类似，但有一些区别。它有一些额外的窗口和面板，如下所述：

+   **组件面板**：**组件面板**是您可以查看并向蓝图类添加组件的地方。空蓝图类中的默认组件是**DefaultSceneRoot**。它无法重命名、复制或删除。但是，一旦您添加了组件，它就会被替换。同样，如果您删除了所有组件，它也会回来。要添加组件，请单击**添加组件**按钮，这将打开一个菜单，您可以从中选择要添加的组件。或者，您可以从内容浏览器中拖动资产并将其放入**图形编辑器**或**组件面板**中，它将作为组件添加到蓝图类中。组件包括静态或骨骼网格、光源演员、摄像机、音频演员、触发盒、体积、粒子系统等。当您放置一个组件时，它可以在**图形编辑器**中看到，您可以在**详细信息**面板中设置其属性，如大小、位置、移动性、材质（如果是静态网格或骨骼网格）等。

+   **图形编辑器**：**图形编辑器**与关卡蓝图类似，但在蓝图类中有一些额外的窗口和编辑器。第一个窗口是**视口**，与编辑器中的相同。它主要用于放置演员并设置它们的位置、属性等。大多数工具您将在主**视口**（编辑器的**视口**）工具栏中找到，这里也都有。

+   **事件图**：下一个窗口是**事件图**窗口，它与级别蓝图窗口相同。在这里，你可以编写在**视口**中添加的组件及其功能（例如，在玩家靠近时脚灯的开关/关闭）。请记住，你只能编写蓝图类中存在的组件的功能。你不能直接使用它来编写不是类组件的任何演员的功能。

+   **构建脚本**：最后，还有**构建脚本**窗口。这也类似于**事件图**，你可以设置和连接节点，就像在**事件图**中一样。不同之处在于这些节点在构建蓝图类时激活。它们在运行时不起作用，因为那时**事件图**脚本起作用。你可以使用**构建脚本**来设置属性，创建和添加你希望在构建过程中改变的任何组件的属性，等等。

让我们开始为关键立方体创建蓝图类。

### 视口

我们需要的第一件事是组件。我们需要三个组件：一个立方体，一个触发盒，和一个**后期处理体积**。在**视口**中，点击**添加组件**按钮，在**渲染**下选择**静态网格**。它会向类中添加一个**静态网格**组件。现在你需要指定要添加到类中的**静态网格**。选择**组件面板**中选中的**静态网格**演员，在演员的**详细信息**面板中，在**静态网格**部分，点击**无**按钮，选择**TemplateCube_Rounded**。一旦设置了网格，它将出现在**视口**中。选择立方体，将其比例（位于**详细信息**面板中）从`1`减少到`0.2`沿着所有三个轴。

我们需要的下一件事是一个触发盒。点击**添加组件**按钮，在**碰撞**部分选择**盒碰撞**。添加后，将其比例从`1`增加到`9`沿着所有三个轴，并将其放置在这样的方式，使其底部与立方体的底部齐平。

![视口](img/image00346.jpeg)

### 构建脚本

你可以通过在**详细信息**面板中点击**覆盖材质**按钮，并选择关键立方体材质来设置其材质。然而，我们将使用**构建脚本**来分配其材质。切换到**构建脚本**选项卡。你会看到一个名为**构建脚本**的节点，默认情况下存在。你无法删除此节点；这是脚本开始的地方。然而，在我们可以编写它之前，我们需要创建一个类型为`材质`的变量。在**我的蓝图**部分，点击**添加新**，在下拉菜单中选择**变量**。将此变量命名为`关键立方体材质`，并在**详细信息**面板中将其类型从**布尔**（默认变量类型）更改为**材质**。还要确保勾选**可编辑**框，以便我们可以从蓝图类外部进行编辑。

![构建脚本](img/image00347.jpeg)

接下来，从**我的蓝图**面板中拖动**关键立方体材质**变量，放入**图形编辑器**中，并在窗口打开时选择**设置**。将其连接到**构建脚本**节点的输出引脚。重复此过程，只是这次选择**获取**并将其连接到**关键立方体材质**的输入引脚。

在**图形编辑器**窗口中右键单击，然后在搜索栏中键入**设置材料**。您应该看到**设置材料（静态网格）**。单击它并将其添加到场景中。此节点已经引用了静态网格角色（**TemplateCube_Rounded**），因此我们不必创建引用节点。将其连接到**设置**节点。最后，从**我的蓝图**中拖动**关键立方体材料**，将其放入**图形编辑器**中，选择**获取**，并将其连接到**材料**输入引脚。完成后，点击**编译**。现在我们将能够在蓝图类之外设置立方体的材料。

![构造脚本](img/image00348.jpeg)

让我们来测试一下。将蓝图类添加到关卡中。您将看到一个**TemplateCube_Rounded**角色添加到场景中。在其**详细信息**面板中，您将在**默认**部分下看到一个**关键立方体材料**选项。这是我们在**构造脚本**中创建的变量。我们在这里添加的任何材料都将添加到立方体上。因此，点击**无**，然后选择**KeyCube_Material**。一旦您选择它，您将看到立方体上的材料。这是使用**构造脚本**可以做的许多事情之一。目前，只有这样做。

### 事件图

现在我们需要脚本化关键立方体的功能。这与我们在级别蓝图中使用第一个关键立方体所做的基本相同，只是有一些小的不同。在**事件图**面板中，我们要脚本化的第一件事是当玩家重叠和停止重叠触发框时启用和禁用输入。在**组件**部分，右键单击**框**。这将打开一个菜单。将鼠标悬停在**添加事件**上，然后选择**添加 OnComponentBeginOverlap**。这将在**图形编辑器**中添加一个**开始重叠**节点。接下来，我们需要一个**投射**节点。**投射**节点用于指定要使用的角色。在**图形编辑器**中右键单击，添加一个**投射到角色**节点。将其连接到**OnComponentBeginOverlap**节点，并将另一个角色引脚连接到**投射到角色**节点的**对象**引脚。最后，添加一个**启用输入**节点和一个**获取玩家控制器**节点，并像在级别蓝图中一样连接它们。

接下来，我们将为玩家停止重叠框时添加一个事件。同样，在**框**上右键单击，然后添加一个**OnComponentEndOverlap**节点。与**OnComponentBeginOverlap**节点做完全相同的事情；只是在这里，不是添加**启用输入**节点，而是添加一个**禁用输入**节点。设置应该看起来像这样：

![事件图](img/image00349.jpeg)

您可以移动我们之前放置在基座上的关键立方体，将其设置为隐藏，并将关键立方体蓝图类放在其位置。还要确保将触发器角色的碰撞响应设置为**忽略**。

![事件图](img/image00350.jpeg)

下一步是脚本化当玩家触摸屏幕时销毁关键立方体。这也与我们在级别蓝图中所做的类似，有一些不同之处。首先，添加一个**触摸**节点和一个**序列**节点，并将它们连接在一起。接下来，我们需要一个**销毁组件**节点，您可以在**组件** | **销毁组件**（静态网格）下找到它。此节点已经在其中引用了关键立方体（静态网格），因此您不必创建外部引用并将其连接到节点。将其连接到**然后 0**节点。

在玩家拾取关键立方体后，我们还需要激活触发器。现在，由于我们无法直接在蓝图类外部的演员上调用函数（就像我们在关卡蓝图中可以），我们需要创建一个变量。这个变量将是**Trigger Box**类型。它的工作方式是，当您创建了一个**Trigger Box**变量后，您可以将其分配给关卡中的任何触发器，并且它将调用该特定触发器的函数。考虑到这一点，在**我的蓝图**面板中，单击**添加新内容**并创建一个变量。将此变量命名为**Activated Trigger Box**，并将其类型设置为**Trigger Box**。最后，确保您选中了**可编辑**框；否则，您将无法将任何触发器分配给它。在这样做之后，创建一个**设置所有通道的碰撞响应**节点（取消选中上下文敏感框），并将**新响应**选项设置为**重叠**。对于目标，拖动**Activated Trigger Box**变量，将其放入**图形编辑器**中，选择**获取**，并将其连接到**目标**输入。

最后，对于后期处理体积，我们需要创建另一个类型为**PostProcessVolume**的变量。您可以将此变量命名为**Visual Indicator**，同时确保**可编辑**框已被选中。将此变量添加到**图形编辑器**中。接下来，单击它的引脚，将其拖出并释放，这将打开操作菜单。在这里，键入**Enabled**，选择**Set Enabled**，并选中**Enabled**。最后，添加一个**延迟**节点和一个**销毁演员**，并按顺序将它们连接到**Set Enabled**节点。您的设置应该看起来像这样：

![事件图](img/image00351.jpeg)

在**视口**中，您会发现在蓝图类演员的**默认**部分下，出现了两个新选项：**激活触发框**和**视觉指示器**（我们创建的变量）。使用这个，您可以指定要更改哪个特定触发框的碰撞响应，以及要激活和销毁哪个后期处理体积。在这两个变量的前面，您会看到一个眼睛滴管形状的小图标。您可以使用这个来选择您希望分配相应变量的外部演员。使用这些变量编写的任何内容都将对您在场景中分配的演员产生影响。这是蓝图类提供的众多令人惊叹的功能之一。现在我们只需要为剩下的关键立方体做以下几件事：

+   将它们放置在关卡中

+   使用位于变量名称旁边的眼滴图标，选择在玩家拾取关键立方体后要激活的触发器，以及要激活和销毁的后期处理体积。

在第二个房间中，我们有两个关键立方体：一个用于激活大门，另一个用于激活通往第三个房间的门。第一个关键立方体将放置在靠近大门的基座上。因此，选择第一个关键立方体，使用眼滴图标，为**Activated Trigger Box**变量选择靠近大门基座上的触发框。然后，为**Visual Indicator**变量选择放置关键立方体的后期处理体积。

我们需要做的下一件事是打开**关卡蓝图**，并编写当玩家将关键立方体放置在靠近大门的基座上时发生的事情。与前一个房间所做的一样，我们设置节点，将隐藏的基座上的关键立方体显示出来，并将大门周围的触发框的碰撞响应更改为**重叠**，确保最初设置为**忽略**。

![事件图](img/image00352.jpeg)

测试一下！你会发现一切都按预期工作。现在，对剩下的关键立方体做同样的操作。选择触发盒和后期处理体积在触摸屏幕时激活。然后，在关卡蓝图中，编写哪个关键立方体要显示，等等（将之前放置在基座上的关键立方体设置为**隐藏**），并将蓝图类关键立方体放在其位置上。

这是使用蓝图类的众多方法之一。你可以看到这需要很多工作和麻烦。现在让我们继续进行人工智能的工作。

# 脚本化基本 AI

回到第三个房间，我们现在要在游戏中实现 AI。我们在第三个房间中有一个 AI 角色，当激活时会移动。主要目标是通过开关为其制作一条路径，并防止其掉落。当 AI 角色到达目的地时，它将解锁关键立方体，玩家随后可以拾取并放置在基座上。我们首先需要创建另一个**Character**类型的蓝图类，并命名为`AI_Character`。创建后，双击打开它。你会看到**视口**中已经设置了一些组件。这些是**CapsuleComponent**（主要用于碰撞），**ArrowComponent**（用于指定角色的前面和后面），**Mesh**（用于角色动画）和**CharacterMovement**。所有这四个都是默认设置的，不能被移除。我们唯一需要做的是为我们的角色添加一个**静态网格**，它将是**TemplateCube_Rounded**。

点击“添加组件”，添加一个“静态网格”，并在其“详细信息”面板中分配“TemplateCube_Rounded”。接下来，将这个立方体沿着三个轴缩放为`0.2`，并将其移动到**CapsuleComponent**的底部，这样它就不会漂浮在空中了。

![脚本化基本 AI](img/image00353.jpeg)

这就是我们对 AI 角色的要求。其余的工作我们将在关卡蓝图中处理。接下来，将**AI_Character**放置在坑洞的玩家一侧，并放置所有开关。直接将其放置在目标点演员的正上方。

![脚本化基本 AI](img/image00354.jpeg)

接下来，打开关卡蓝图，让我们开始编写脚本。最左边的开关将用于激活 AI 角色，其余三个将用于绘制路径的部分，以便它可以走到另一侧。

为了移动 AI 角色，我们将需要一个**AI Move To**节点。我们首先需要一个触发第一个开关的重叠事件，这将启用输入，否则 AI 角色将在玩家触摸屏幕时开始移动，这是我们不想要的。设置一个**重叠**事件，一个**启用输入**节点和一个**门**事件。将**重叠**事件连接到**启用输入**事件，然后连接到**门**节点的**打开**输入。

接下来要做的是创建一个**触摸**节点。我们将附加一个**AI Move To**节点。你可以输入它，也可以在 AI 部分下找到它。创建后，将其连接到**门**节点的**退出**引脚。

![脚本化基本 AI](img/image00355.jpeg)

现在我们需要告诉节点我们要移动哪个角色，以及它应该移动到哪里。要指定我们要移动哪个角色，选择**视口**中的 AI 角色，在关卡蓝图的**图形编辑器**中，右键单击并为其创建一个引用。将其连接到**Pawn**输入引脚。接下来，对于位置，我们希望 AI 角色朝着坑洞另一侧的第二个**目标点**演员移动。但首先，我们需要获取它在世界中的位置。选择它，右键单击**图形编辑器**，输入`获取演员位置`。这个节点返回世界中一个演员的位置（坐标）（连接到它的那个）。这将创建一个**获取演员位置**，将**目标点**演员连接到其输入引脚。

最后，将其**返回值**连接到**AI 移动到**节点的**目的地**输入。

![脚本基本人工智能](img/image00356.jpeg)

如果你进行测试，你会发现它运行良好，除了一件事：当 AI 角色到达坑的边缘时会停止。我们希望它在没有路径时掉入坑。为此，我们需要一个**Nav 代理链接**角色。如前一章所述，当 AI 角色需要暂时离开 Nav Mesh（例如，在台阶之间跳跃）时，会使用**Nav 代理链接**角色。如果我们希望 AI 角色从悬崖上掉下来，我们将需要它。您可以在**模式**面板的**所有类**部分中找到它。将其放置在关卡中。

![脚本基本人工智能](img/image00357.jpeg)

该角色由两个带有弯曲箭头连接的圆柱表示。我们希望第一个圆柱位于坑的一侧，另一个圆柱位于另一侧。使用**缩放**工具，增加**Nav 代理链接**角色的大小。

![脚本基本人工智能](img/image00358.jpeg)

放置**Nav 代理链接**角色时，请记住两件事：

+   确保两个圆柱相交在绿色区域；否则，该角色将无法工作

+   确保两个圆柱与 AI 角色对齐；否则，它将不会沿直线移动，而是移动到圆柱所在的位置

放置后，您会发现当 AI 角色到达坑的边缘时会掉下来。我们还没有完成。我们需要将 AI 角色带回其起始位置，以便玩家可以重新开始（否则玩家将无法继续）。为此，我们首先需要在坑底放置一个触发器，确保如果 AI 角色掉入其中，它会重叠触发器。此触发器将执行两个操作：首先，它将将 AI 角色传送到其初始位置（借助第一个目标点）；其次，它将停止**AI 移动到**节点，否则即使已被传送，它也会继续移动。

![脚本基本人工智能](img/image00359.jpeg)

放置触发器后，打开关卡蓝图并为触发框创建一个重叠事件。为此，我们将添加一个**Sequence**节点，因为当玩家重叠触发器时，我们要调用两个单独的函数。我们要创建的第一个节点是**Teleport**节点。在这里，我们可以指定要传送的角色和位置。我们要传送的角色是 AI 角色，所以为其创建一个引用并将其连接到**目标**输入引脚。至于目的地，首先使用**获取角色位置**函数获取第一个目标点角色的位置（AI 角色最初放置在其上），并将其连接到**目标位置**输入。

![脚本基本人工智能](img/image00360.jpeg)

要停止 AI 角色的移动，在**图形编辑器**中右键单击任意位置，首先取消选中**上下文敏感**框，因为我们不能直接在 AI 角色上使用此功能。我们需要的是**停止活动移动**节点。在搜索栏中键入它并创建它。将其连接到**然后 1**输出节点，并将 AI 角色的引用连接到它。它将自动从**角色引用**转换为**角色移动**组件引用。

![脚本基本人工智能](img/image00361.jpeg)

这就是我们需要为第三个房间的 AI 编写的所有内容。还有一件事：如何解锁关键立方体。但我们将在下一章中介绍这一点，因为它涉及 Matinee。

在第四个房间，我们将使用相同的原理。在这里，我们将制作一系列**AI 移动到**节点，每个节点都连接到前一个节点的**成功时**输出引脚。这意味着当 AI 角色成功到达目的地（目标点演员）时，它应该移动到下一个目标，依此类推。利用这一点，以及我们刚刚讨论的关于 AI 的内容，编写 AI 将遵循的路径（回想一下上一章，在那里我们勾画了 AI 角色在第四个房间中将走的路径）。

![编写基本 AI 脚本](img/image00362.jpeg)

# 总结

在本章中，我们介绍了蓝图并讨论了它们的工作原理。我们还讨论了关卡蓝图和蓝图类，并介绍了如何编写 AI 脚本。我们还有一些脚本要做，但首先我们需要讨论虚幻 Matinee 的主题。在下一章中，我们将做到这一点。
