# 第十二章. 盈利、构建过程和发布

这是本书的最后一章；我们剩下要做的就是使我们的应用盈利，生成其不同版本，并将其发布并上传到 Play 商店。

我们将通过创建不同的构建类型来完成构建过程，生成不带广告的付费版本和带广告的免费版本的应用。所有这些都在同一个项目中，但将作为两个不同的应用导出。

构建过程完成后，我们将开始实施广告并解释关于广告盈利的关键点；这将使我们的应用程序能够产生收入。

最后，我们将发布应用，并使用发布证书对我们的 APK 进行签名，混淆代码以防止被反编译。我们将上传到 Play 商店，并解释在应用发布过程中需要牢记的关键点。

+   构建变体

+   盈利

    +   广告盈利的关键点

    +   添加广告

+   发布

    +   代码混淆和签名

    +   使用 Gradle 导出

+   上传至 Play 商店

# 使用构建变体

为了解释如何在 Android 上通过广告实现盈利，我们将在应用中添加广告，但在这一步之前，我们将设置一个构建过程，允许我们导出两个版本：付费版和免费版。这种策略在 Play 商店中很常见（提供一个带广告的免费版本和一个不带广告的付费版本），这样所有用户都能免费使用该应用，但那些不喜欢广告并希望支持你应用的用户可以选择购买付费版本。

实施此策略的另一种方法是只创建一个版本，并在应用内提供购买附加组件以移除广告的选项，通过应用内购买产品来实现。这种方式的缺点是，你的应用在 Play 商店中不会列为免费应用；它将被归类为“提供应用内购买”，因此可能有些用户对此感到不适应，或者家长不允许孩子使用付费应用或包含支付的应用。第二个问题是应用内购买不容易实现；这个过程非常复杂，涉及很多步骤，包括设置服务、在 Play 商店中创建产品、从应用中消费这些产品，以及设置一个测试环境，我们可以在不产生费用的前提下测试购买。

![使用构建变体](img/B04887_12_01.jpg)

构建变体是构建类型和产品风味的组合。

如果我们有构建类型`A`和`B`，以及产品风味`1`和`2`，那么结果将如下构建变体：

```java
A 1
A 2
B 1
B 2
```

为了更好地理解这一点，我们可以了解构建类型和构建风味的概念以及如何创建它们。

## 创建构建类型

构建类型允许我们为调试或发布目的配置应用的打包。

让我们先看看我们的 `build.gradle` 文件：

```java
buildTypes {
  release {
    minifyEnabled false
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}
```

在 `build.gradle` 中，我们可以看到构建类型 release 有两个属性，我们将在本章末尾解释它们。

默认情况下，我们有两个构建类型：**debug** 和 **release**。即使我们没有看到 debug 构建类型，所有变体也将在 release 和 debug 模式下生成。

我们可以创建更多具有不同参数的构建类型；我们可以使用的参数包括：

+   签名配置

+   调试签名标志

+   更改版本名称或包名后缀

这意味着我们可以拥有不同类型的签名，使用不同的证书，启用或禁用 debug 模式，以及不同的包名。

构建类型并不是用来创建我们应用程序的不同版本，如演示版或完整版，免费或付费等。为此，我们有产品风味。每个构建类型应用于每个构建风味，创建我们之前看到的构建变体。

## 产品风味

我们将创建两个产品风味，并在 `build.gradle` 中使用以下代码声明它们：

```java
productFlavors {
  paid {
    applicationId "com.packtpub.masteringandroidapp"
  }
  free {
    applicationId "com.packtpub.masteringandroidapp.free"
  }
}
```

我们有一个付费风味，即没有广告的应用，还有一种名为 *free* 的风味，包含广告的免费版本。对于每个产品风味，我们可以在项目的 `../src/` 级别创建一个文件夹。我们的付费版本默认是主要的，所以不需要文件夹。

![产品风味](img/B04887_12_02.jpg)

这样，我们可以为每个构建拥有不同的类和资源，甚至一个不同的 `AndroidManifest.xml` 文件。我们的应用程序将在 `main` 文件夹中共享付费和免费版本的通用代码，在 `free` 文件夹中有针对广告的特定代码。

要在不同版本之间切换，我们可以简单地更改构建变体窗口中的下拉菜单，如下面的截图所示：

![产品风味](img/B04887_12_03.jpg)

选择一个构建变体后，我们可以运行应用或导出它，相应地运行或导出所选的风味。这些可以配置为具有不同的包名和不同的版本名称。

现在，我们将看看如何向免费版本添加一个特定代码，该代码不会包含在主要付费版本中。

# 安卓的货币化

我们将描述通过应用程序赚钱的三种常见方式。

首先，我们可以在 Play Store 中为应用程序设定一个价格。在某些情况下，为你的应用收费比提供带有广告或应用内产品的免费应用更有意义。如果你为一小部分用户创造了高价值的应用，你绝对应该考虑这个选项。例如，如果我们发布一个为建筑师专业设计房屋的应用，我们知道我们的应用不会被数百万用户下载；它是针对特定和目标用户群的高质量软件需求。我们无法通过广告获得足够的利润，而我们的用户将愿意为使他们的工作更轻松的软件支付一笔不错的费用。要求用户预先支付费用总是存在风险的；即使用户可以选择退还应用费用，他/她可能也不够吸引人去尝试。这就是为什么我们应该考虑第二种模式的原因。

第二个选项被称为**免费增值**模式。我们发布一个免费的应用程序，但其中包括应用内购买。以同样的房屋设计应用为例，我们可以提供三种免费设计，以便当用户对我们的产品感到满意时，我们可以要求他/她购买一次性许可或订阅以继续使用该应用。这在游戏中非常常见，你可以为你的角色购买物品。在游戏中，我们可以看到这个模型也可以与第三种模型结合，以获得尽可能最大的收益。

第三种货币化模型是**广告模型**；我们在应用中放置广告，当用户点击它们时，我们获得收入。我们可以使用不同类型的广告——从全屏广告到底部的小横幅。我们将关注这个模型。其实施比你想象的要容易。但在实施之前，我们需要解释诸如**CPC**（**每次点击成本**）、**CTR**（**点击通过率**）、填充率等术语，这将帮助我们选择一个好的广告平台和提供商。这对于理解指标并能够阅读图表以了解应用中的广告表现也是必要的。在不同的位置放置广告可能会改变收入；然而，我们需要在不烦扰用户的情况下最大化收益。如果我们为用户提供以小额费用通过应用内产品或无广告的付费版本来移除广告的选项，我们可以增加广告的数量。如果用户知道他们有选择，这对他们来说是最好的。如果他们选择与广告共存，这是他们的决定，不会像我们没有提供移除广告的选项而放置大量广告那样让他们感到烦恼。

## 广告收益化的关键点

我们将解释基础知识，以了解广告收益化是如何运作的。商业中有一些带有缩写的概念，一开始可能会让人感到困惑。

一旦我们在广告平台上注册，我们就会看到一个关于我们应用的统计数据报告页面。以下是来自广告网络`AdToApp`的仪表盘示例：

![广告货币化的关键点](img/B04887_12_04.jpg)

在这里，我们可以看到请求、填充率、展示量、点击量、CTR、eCPM 和收入。让我们逐一考虑它们。

请求是指我们的应用向广告网络请求广告的次数。例如，如果我们决定在应用开始时添加一个全屏广告，那么每次启动应用时，都会向服务器发送请求以获取广告。

我们的应用中并没有实际的广告内容；我们拥有的是一个占位符、一个框架以及一个`AdView`，它将由广告网络提供的内容填充。有时，在请求时刻广告网络可能没有广告给我们，这就是下一个概念重要的原因。

填充率是通过已投放广告数除以请求广告数得出的百分比。例如，如果我们启动应用 10 次，只收到 5 次广告，那么我们的填充率为 50%。在一个好的广告网络中，我们希望填充率为 100%。我们希望展示尽可能多的广告，并且点击单价要高。

CPC，即每次点击成本，是指用户在我们的应用中点击广告时我们获得的收入；这个数值越高，我们获得的收入越多。广告商决定了广告的 CPC。一些广告商可能愿意为每次点击支付更多的费用。

许多低 CPC 的点击不一定比少量高 CPC 的点击更好。这就是为什么我们拥有的广告质量重要的原因。

展示量是指广告向用户展示的次数。在上一个例子中，如果有 10 次广告请求，其中 5 次失败，我们就会有 5 次展示量。如果用户不点击，展示量不会产生收入。

点击量是指用户点击广告的次数。这是基于 CPC 产生收入的方式。因此，5 次点击，每次点击 0.5 美元，将会产生 5x0.5，即 2.5 美元的收入。

CTR，即点击通过率，是通过应用收到的点击量除以展示量得出的百分比。如果我们有 100 次广告展示，并且有 1 次点击，我们的 CTR 为 1%。这个数值通常低于 5%，因为用户不会点击他们看到的每一个广告。如果你通过强制用户点击广告来作弊，比如**Admob**这样的广告平台可能会取消你的账户和支付。例如，如果我们在应用开始时显示一个对话框，要求用户点击广告才能继续使用我们的应用，这将基本上给我们带来 100%的 CTR；每个展示量都会有一次点击，这是不允许的。在任何情况下，我们都不可以推广点击。

广告提供商希望他们的广告能被对其感兴趣的人看到；他们不希望为那些对广告不感兴趣、一秒钟后就会关闭广告的人的点击付费。可能你有一个高的点击通过率（CTR），因为你在应用中有一个好的广告位置，而且广告对每个用户都有吸引力。如果发生这种情况，你将不得不向你的广告网络解释，或者像**Admob**这样的广告网络可能会关闭你的账户。但我们也不应该对他们太不公平；他们这样做是因为他们发现很多人试图破坏规则，这样一个庞大的公司无法专注于个人，所以他们需要有客观的筛选机制。

其他广告网络公司在这一点上更加灵活；他们通常会为你分配一个代理人，你可以通过 Skype 或电子邮件频繁联系他，在有任何问题时，他们通常会通知你。

eCPM 代表“每千次展示的有效成本”。它是通过将总收入除以总展示次数（以千为单位）来计算的。这基本上是一种只需查看一个数字就能快速了解你表现如何的方法——非常有助于比较广告网络。这个数字通常在$0 到 3$之间。

我们需要考虑到这并不包括填充率。它是每千次展示的成本，而不是每千次请求的成本。一个 3 美元的 eCPM，如果填充率为 50%，与 1.5 美元的 eCPM 和 100%的填充率是相同的。

一个优秀的广告网络应具备高填充率和高的 eCPM。我们需要这两者都高；如果广告点击费用昂贵但填充率不足，将无法产生收入，因为它们根本不会被展示。

**AdToApp**的团队制作了一张不错的图来解释这一点：

![广告货币化的关键点](img/B04887_12_05.jpg)

这张图展示了我们一直在讨论的内容；一个高端广告网络，其 eCPM 非常高而填充率低，被表现为一座高但空荡荡、灯光熄灭的大楼。

我们已经完成了理论学习，可以开始整合广告解决方案；在本例中，我们将选择 AdToApp。

## 使用 AdToApp 添加广告

没有办法知道哪个广告提供商更适合你；你能做的最好的事情就是尝试不同的提供商，并查看统计数据。

根据经验，我们喜欢使用 AdToApp，除了它良好的投放效果外，它真的很容易集成，即使你已经集成了其他网络，也可以将它包含在你的应用中。因此，衡量其性能真的很简单。

在这本书中使用它搭配`MasteringAndroidApp`非常理想，因为它允许我们使用不同类型的广告，包括全屏广告、横幅、视频等。

有超过 20 个不同广告网络的调解者，因此包含他们的 SDK，我们将有大量保证高填充率的广告可供选择。至于他们的 eCPM，他们会分析哪个网络能为你带来更好的结果；因此，如果他们可以从多个网络投放广告，他们会选择效果更好的。

![通过 AdToApp 添加广告](img/B04887_12_06.jpg)

我们可以开始创建一个账户，地址是[`adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow`](https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow)。

创建账户后，我们将使用我们应用的包名创建一个应用。

![通过 AdToApp 添加广告](img/B04887_12_07.jpg)

我们将点击 SDK 按钮下载他们的 SDK，并获取集成所需的配置值。

![通过 AdToApp 添加广告](img/B04887_12_08.jpg)

集成非常简单；SDK 将包含一个`AdToAppSDK.jar`文件，我们需要将其复制到`libs`目录中。我们还需要在`build.gradle`中添加 Google Play Services 和*v7*支持库，但我们已经有这些了。

我们需要在清单中添加基本权限，我们已经有这些了，使用以下代码：

```java
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
```

然后，我们需要在清单中添加额外的必要资产，这可以复制自同一网站；它包含我们账户的密钥。你可以在以下截图所示的第一部分找到它们：

![通过 AdToApp 添加广告](img/B04887_12_09.jpg)

最后，我们可以看看如何实现**插屏广告和横幅广告**或激励广告。激励广告是游戏中弹出的广告，提示*观看此视频并获得（金币、宝石等）*。是否观看这些广告完全取决于用户是否想要奖励。

![通过 AdToApp 添加广告](img/B04887_12_10.jpg)

如果我们选择插屏广告和横幅广告，我们需要根据是需要仅视频广告、仅图片（横幅）广告，还是插屏中同时包含图片和视频广告来初始化它们。

在网站上，根据你想要的广告类型，将展示必要的代码。

SDK 非常灵活；我们可以更进一步设置回调，以了解横幅广告何时加载和点击。这允许我们跟踪广告的点击次数，并验证它们与 AdToApp 控制台中的数据一致，使整个过程透明。

如果我们需要额外的帮助，可以在 SDK 中激活日志，它会在出现任何问题时通知我们。

现在请记住我们在本节开始时提到的良好实践，即在不过多打扰用户的前提下最大化广告数量，并在你的应用中实施这些方法，开始获得收益！

![通过 AdToApp 添加广告](img/B04887_12_11.jpg)

# 将我们的应用发布到 Play 商店。

最后，我们的应用准备好了！这是开发新应用时最美好的时刻；是时候将其上传到 Play 商店，获取用户的反馈，并希望获得成千上万的下载量。

我们需要将应用导出为 APK 文件；为了上传到 Play 商店，它必须使用发布证书进行签名。这一点非常重要；一旦应用程序用证书签名，如果我们将其上传到 Play 商店，并在将来想要上传新版本，就必须使用同一证书进行签名。

我们在发布过程中会创建这个证书。它需要一个别名和密码，因此请确保你记住这些细节并将证书文件保存在安全的地方。否则，假设你的应用得到了好的评分和大量的下载，当你想要更新版本时，如果没有证书或忘记了密码，就无法进行更新。在这种情况下，你将不得不上传一个具有不同包名的全新应用，并且它的下载量和评分将从零开始。

## 代码混淆

在发布应用时需要考虑的另一个重要事项是代码混淆。如果我们导出应用而不混淆代码，任何人都可以下载 APK 并反编译它，使他们能够看到你的代码，如果你在其中包含了 Parse IDs、服务器访问细节、GCM 项目编号等，这可能会成为一个安全问题。

我们可以使用**Proguard**混淆代码。Proguard 是 Android 构建系统中包含的一个工具。它混淆、缩小和优化代码，移除未使用的代码，并重命名类、字段和方法，以防止逆向工程。

注意类和方法的重命名，它可能会影响你的崩溃和错误报告，因为堆栈追踪将会被混淆。然而，这不是问题，因为我们可以在发布应用时保存一个映射文件，用它可以重新追踪，这将允许我们将崩溃和报告转换成可读的、未被混淆的代码。

要激活 Proguard，我们需要在`buildTypes`中将`minifyEnabled`属性设置为`true`。你可以执行以下代码来实现这一点：

```java
buildTypes {
  release {
    minifyEnabled true
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}
```

在我们的项目中，有一个`proguard-rules.pro`文件，我们可以在其中添加混淆时要考虑的规则。例如，如果我们混淆一些第三方库，它们可能无法正常工作，而这些库没有混淆的风险，因为它们不是我们创建的；我们只是将它们添加到我们的项目中。

![代码混淆](img/B04887_12_12.jpg)

为了防止第三方库被混淆，我们可以添加`-keep`规则以及`-dontwarn`规则来忽略警告。例如，我们添加了`calligraphy`以使用自定义字体；这样我们可以在混淆过程中忽略它：

```java
# DONT OBFUSCATE EXTERNAL LIBRARIES

# CALLIGRAPHY
-dontwarn uk.co.chrisjenx.calligraphy.**
-keep class uk.co.chrisjenx.calligraphy.** {*;}
# TIMBER
-dontwarn timber.log.**
-keep class timber.log.** {*;}
```

使用`keep`和包名，我们将保留该包内所有的类。

我们将在调试模式下添加 Proguard，故意创建一个崩溃，以查看混淆后的堆栈追踪的样子：

```java
Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.view.View.setVisibility(int)' on a null object reference
            at com.packtpub.masteringandroidapp.SplashActivity.onCreate(Unknown Source)
```

我们可以复制这个`stracktrace`到文本文件中，并前往`app/build/outputs/mapping/product_flavor_name/ release_or_debug/mapping.txt`获取我们的`mapping.txt`文件。

请考虑我们在`<sdk_root>/tools/proguard`中执行以下代码的 retrace 命令：

```java
retrace.sh [-verbose] mapping.txt [<stacktrace_file>]
```

在这种情况下，我们将有正确的行号出现崩溃，如下所示：

```java
Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.view.View.setVisibility(int)' on a null object reference
at com.packtpub.masteringandroidapp.SplashActivity.onCreate(SplashActivity.java:21)
at android.app.Activity.performCreate(Activity.java:6289)
```

请记住，在每次发布应用时保存`mapping.txt`文件的副本；每次发布时这个文件都会被覆盖，因此在每次发布时保存文件非常重要。或者，如果你有一个仓库，并且为每次发布标记提交，你可以回退并重新生成相同的发布，理论上这将具有相同的映射文件。

既然我们的应用已经针对逆向工程进行了保护，我们可以继续发布流程。

## 导出应用

当我们导出应用程序时，我们实际上是在发布模式下创建一个 APK 文件，并用证书对其进行签名。这个证书证明了 Play Store 中的应用程序属于我们，有了它，我们可以上传我们之前解释的同一个应用程序。这次我们将导出应用并创建一个证书。

要导出我们的应用程序，有两种方法：一种是在 Android Studio 中使用 Gradle 和终端，第二种是使用 Android Studio 中的向导。我们将了解这两种方法，但首先使用第二种方法创建证书。

导航到**构建** | **生成签名的 APK**；你会看到一个类似的对话框：

![导出应用](img/B04887_12_13.jpg)

如果我们之前导出过这个应用并为其创建了证书，那么我们只需选择一个路径并输入别名和密码，这将使用现有证书导出一个新版本的应用。

对我们来说，这是第一次导出`MasteringAndroidApp`，所以我们将点击**创建新的...**。在下一个屏幕上，我们需要选择保存证书的路径，这是一个`.keystore`文件。

我们还需要为`keystore`和证书中的别名设置密码。对于有效期为 100 年的日期来说是可以的；如果你的应用比你活得更长，那就不是你的问题了！最后，在这里至少需要一个字段填写个人信息：

![导出应用](img/B04887_12_14.jpg)

最后，它会询问我们想要导出哪个版本的应用，并创建`.apk`文件，同时指出文件的路径。

这种方法很直接，但还有一种使用命令行和 Gradle 自动导出应用的方法；如果我们想用 Jenkins 构建应用程序，这非常有用。

为此，我们需要在`build.gradle`中添加一个签名配置，以便在自动生成应用程序时，它知道要使用哪个`keystore`以及哪个别名和密码。以下代码将有助于实现这一点：

```java
signingConfigs {
  release {
    storeFile file("certificate.keystore")
    storePassword "android"
    keyAlias "android"
    keyPassword "android"
  }
}
```

不用说，这可能导致安全问题；密码写在 `build.gradle` 中，证书文件包含在我们的项目中。如果我们这样做，需要确保项目安全。如果这是一个关注点，你可以使用以下代码在运行时读取密码和别名：

```java
storePassword new String(System.console().readPassword("\n\$ Enter keystore password: "))
keyAlias System.console().readLine("\n\$ Enter key alias: ")
keyPassword new String(System.console().readPassword("\n\$ Enter key password: "))
```

当我们运行生成签名 APK 的命令时，它会要求我们输入密码别名和别名密码。我们可以使用以下代码行来完成这个操作：

```java
>./gradlew assembleRelease
```

![导出应用](img/B04887_12_15.jpg)

当我们的应用导出后，可以继续最后一步：上传到 Play 商店。

## 将我们的应用上传到 Play 商店

要发布一个应用，我们需要一个 Google 开发者账户。如果你没有，可以从 [`play.google.com/apps/publish/`](https://play.google.com/apps/publish/) 获取一个。

### 创建发布者账户

创建发布者账户的第一步是输入基本信息，并阅读并接受开发者分销协议。第二步是支付 25 美元的开发许可费用以创建账户。这是我们发布应用所需支付的全部费用，只需一次性支付——一次付费，终身许可。考虑到在 iOS 上，费用是每年 99 美元，我们不应该抱怨。

最后第三步需要开发者姓名，它将显示在我们应用程序名称下方。以下是 Google Inc 的一个示例：

![创建发布者账户](img/B04887_12_16.jpg)

我们还需要电子邮件、手机号码以及我们的网站（可选）。根据 Google 的说法，这是为了在有人需要就发布的内容联系我们时使用。

### Google Play 开发者控制台

当我们打开发布者账户时，如果我们还没有发布任何应用，我们将看到开发者控制台四个主要功能，如下面的图片所示：

![Google Play 开发者控制台](img/B04887_12_17.jpg)

第一个选项是发布一个 Android 应用，这是我们将在书中遵循的选项。然而，在此之前，我们将快速描述其他需要记住的选项。

第二个选项是关于 Google Play 游戏服务。如果你开发了一个游戏，希望玩家保存并提交他们的得分，并有一个得分排行榜，你需要一个服务器来存储这些分数并检索它们，甚至可能需要玩家用户名和登录。游戏服务为我们完成这些工作。

它提供了一个 API，跨游戏共享，与用户的 Google 账户关联，我们可以管理排行榜和成就。它甚至提供了 API 和基础设施来实现多人游戏，包括实时多人和回合制游戏。

左侧底部的第三个选项是关于分享开发者控制台的。我们可能希望允许其他开发者更新应用。例如，在公司中，这将有助于那些负责设置应用名称、描述、图片以及整体市场营销的人员，以及其他负责应用上传和开发的人员。我们可以配置对控制台和特定应用的访问权限。

![Google Play 开发者控制台](img/B04887_12_18.jpg)

第四个也是最后一个选项是商家账户；如果我们想要销售付费应用或应用内产品，就需要这个。这是来自付费应用的商家账户示例；我们可以看到完成的支付和取消的支付。如果用户购买了我们的应用，他/她在两小时内可以申请退款，如果他/她不喜欢这个应用。

![Google Play 开发者控制台](img/B04887_12_19.jpg)

因为我们还没有发布应用，所以我们看到了一个空的开发者控制台和四个主要选项；如果我们有已发布的应用，我们就会看到这个样子。在这种情况下，**发布**按钮在顶部：

![Google Play 开发者控制台](img/B04887_12_20.jpg)

在初始屏幕上，我们可以看到不同的应用，无论它们是免费的还是付费的，活跃安装数量和总安装数量。活跃安装意味着目前拥有该应用并且下载后没有卸载的人。总安装数量意味着应用被安装的所有次数的总计。

我们还可以看到评分和崩溃次数。如果我们点击应用并进入详细视图，我们还可以查看更多详细信息，例如用户的评论和错误崩溃报告。

### 发布应用

继续上传过程，当我们点击**+ 添加**新应用时，系统会要求我们输入名称和默认语言。在此之后，我们可以选择通过上传 APK 或准备商店列表来开始流程。

![发布应用](img/B04887_12_21.jpg)

这两个是不同的过程：一个是上传 APK 文件，另一个是设置应用的标题、描述、图片、是否付费或免费等——所有在 Play 商店中显示的不同选项。

让我们从上传 APK 文件和不同的测试组开始。

### 上传 APK 文件

请记住，当我们上传 APK 时，我们应用的包名必须在 Play 商店中是唯一的；如果我们想要更新之前由我们发布的某个应用，并且使用签名的初始下载的证书与签名新 APK 的证书相同，那么我们可以上传具有现有包名的 APK。

当我们点击**上传 APK**时，首先注意到的就是带有名称的三个不同标签：**生产环境**，**测试版**和**Alpha 版**。

![上传 APK 文件](img/B04887_12_22.jpg)

我们可以在两个测试组中以及生产环境中发布我们的应用。生产环境意味着它在 Play 商店中发布；它是公开的，每个人都可以看到。一段时间以来，开发人员控制台只有这个选项，直到他们添加了分阶段推出的功能。

分阶段推出使我们能够将应用发布给一组有限的用户。为了选择这些用户，我们有多种选项；我们可以通过电子邮件邀请这些用户，分享链接，或者创建一个 Google 群组或 G+ 社区，邀请用户加入该群组并在其中分享应用的链接。只有这些用户才会在 Play 商店中看到应用。这有助于在应用面向全球发布之前，从部分用户那里获取反馈，当然，还可以防止生产环境中的应用出现错误和负面评价。我们还可以选择在生产环境中发布我们应用的用户百分比；例如，如果我们有百万用户，可以先向 10%的用户发布，然后再进行双重检查，确保一切正常，再进行大规模发布。

我们的应用可以在不同的阶段有不同的版本；例如，我们可以发布版本 1.0.0，1.0.1 处于 beta 测试阶段，1.0.2 处于 alpha 测试阶段。我们可以从 alpha 向 beta 推出 APK，从 beta 向生产环境推出，但我们不能回滚。

我们现在要解释的概念非常重要。一旦我们发布了应用的一个版本，我们就不能回到之前的发布版本。可能会发生这样的情况：我们在 Play 商店中有一个应用的工作版本，我们开发了一个新版本，在我们的设备上运行良好，我们认为它已经可以上传了。现在是周五下午，我们不想进行测试，因为我们认为，“哦，我确信它没问题。我只是做了两行小改动，不会影响任何东西”。我们上传了版本 1.0.4。几小时后，我们开始收到来自 Play 商店的崩溃报告。这是恐慌的时刻；我们现在能做的唯一事情是撤销当前应用的发布，以防止更多损失，并尽快开始修复。然而，如果修复不容易，最明智的做法是再次生成最后一个已知的工作版本（1.0.3），将版本号和代码增加到 1.0.5，并将其上传到 Play 商店。

然而，情况可能会更糟；如果我们有一个数据库，并且其结构从 1.0.3 变化到 1.0.4，如果我们的代码还没有准备好接受从 1.0.4 到作为 1.0.5 重新命名的 1.0.3 的数据库降级，我们将知道我们整个周末都要工作，结果在周一早上被解雇。总之，我们的观点是，预防胜于治疗；因此，使用分阶段推出，在发布之前进行所有必要的测试，并且避免在周五下午发布，以防万一。

### 准备商店列表

对于开发者来说，准备商店列表可能是最无聊的部分，但为了发布应用，这是必须要做的；有一些我们不能跳过的必填资产和字段。

首先，我们需要为我们的应用起一个标题，一个最多 80 个字符的简短描述和一个最多 4000 个字符的长描述。标题将是我们搜索应用时首先看到的内容；简短描述例如在平板电脑浏览应用时可见。这是我们的应用的*elevator pitch*（电梯游说），我们需要在这里的主函数中描述它：

![准备应用商店列表](img/B04887_12_23.jpg)

长描述将在我们查看应用详情视图时显示。为了在更多搜索中出现并获得可见性，在描述中识别并添加与应用相关的关键词是很有帮助的。使用不相关关键词吸引用户下载是被 Google 禁止的，如果你这样做，你将在开发者控制台收到警告，并且你的应用在重新获得批准和发布之前需要做出一些更改。

在这一点上，我们有权选择国际化我们应用列表，重复这些前面提到的三个字段，以我们想要的任何语言，它们将根据用户的语言自动显示在不同的语言中。

下一步是开发图形，我们需要在这里拍摄截图。截图可以通过设备上的按键组合轻松完成；例如，在三星 Galaxy 3 上，这是通过同时按下*音量下*和*菜单*键完成的。也可以从 Android Studio 中通过选择 Android 视图中的相机图标来拍摄。

![准备应用商店列表](img/B04887_12_24.jpg)

除了截图，我们还需要一个 512 x 512 高分辨率的图标；这必须与我们在上传版本中为应用使用的图标相同或非常相似，否则它会发出警告。因此，始终创建 512 x 512 的图标，然后将其缩小以在我们的应用中使用是很好的做法。反其道而行之将导致图像质量差地放大。以下是图标显示的一个示例：

![准备应用商店列表](img/B04887_12_25.jpg)

我们需要的最后一张图片是功能图。这是一张 1024 x 500 的图片，展示了我们应用的功能。如果我们的应用在 Google Play 上被精选，这张图片将被展示。它将在 Play 商店应用中显示；如果我们有促销视频，当视频不播放时，功能图仍然会显示。

![准备应用商店列表](img/B04887_12_26.jpg)

我们需要继续进行分类；根据我们的应用是游戏还是应用程序，我们需要选择不同的类别。如果你不确定选择哪个类别，可以在 Play 商店查看与你应用相似的应用。

之后，我们需要选择内容评级；从 2015 年 5 月开始，每个应用程序都需要有新的评级系统。根据谷歌的说法，这个新的内容评级提供了一种简单的方法，向用户传达熟悉且与本地相关的内容评级，并通过针对您内容的目标受众来帮助提高应用程序的参与度，具体内容请参阅[`support.google.com/googleplay/android-developer/answer/188189`](https://support.google.com/googleplay/android-developer/answer/188189)。

我们的联系方式会自动填写，所以我们需要做的最后一件事是接受隐私政策，然后我们可以点击**定价与分发**。

![准备商店列表](img/B04887_12_27.jpg)

在这里，我们可以决定应用程序是免费还是付费；这一步无法撤销。如果应用程序是付费的，我们可以设置一个价格，谷歌会将它转换成不同国家的不同货币；尽管如此，我们可以为每个国家设置不同的价格。我们可以选择加入不同的开发者群体；例如，如果我们开发了一个儿童应用程序，我们可以将其包含在**为家庭设计**中。这将增加我们在儿童专区被突出显示的机会，并关联到与儿童应用程序相关的第三方网络。

在这一部分，我们还可以选择希望发布应用程序的国家。这也可以用作应用程序首次发布时的分阶段发布策略。

![准备商店列表](img/B04887_12_28.jpg)

完成以上所有步骤后，我们可以通过点击右上角的**发布**来发布我们的应用程序。

![准备商店列表](img/B04887_12_29.jpg)

如果按钮不可用，您可以点击**为什么我不能发布？**，它将在左侧列出要求。应用程序发布后，可能需要几个小时才能在 Play 商店中显示。确定应用程序是否已发布的最简单方法是使用包名在 URL 中导航到我们的应用程序。在我们的例子中，URL 将是[`play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp`](https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp)。

就这样！我们从初学者到更高级别完成了本书的学习，具备了上传设计良好、构建完善、向下兼容并能实现盈利的应用程序所需的知识。

我们祝愿您的应用程序取得成功，并希望您能打造出下一个《愤怒的小鸟》或下一个 WhatsApp！

### 注意

非常感谢您购买并读完这本书。对于建议、改进或任何反馈，请毫不犹豫地通过`<Antonio@suitapps.com>`联系我，或者在 Twitter 上关注我`@AntPachon`。

# 总结

在本书的最后一章中，我们开始学习如何创建应用程序的不同版本，将构建类型与产品风味结合以获得构建变体。

之后，我们学习了如何对我们的应用程序进行货币化，添加了不同类型的广告，并解释了广告货币化的关键要点。

我们还从 Android Studio 和使用 Gradle 命令行导出了应用程序，进行了混淆并使用发布证书进行了签名。

最后，我们在 Play 商店上传并发布了我们的应用程序。
