- en: Chapter 4. Tappy Defender – Going Home
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are on the home straight of our first game. In this chapter, we will draw
    a HUD to show the player in-game information, and implement the rules of the game
    so that the player can win, lose, and get fastest times.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will make a pause screen so the player can admire their achievements
    (or not) after they win or lose.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also generate our own sound FX and then add them to
    the game. Following that, we will enable the player to save their fastest time,
    and finally we will add a whole bunch of minor improvements, including a bit of
    difficulty balancing based on the screen resolution of the player's Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to start making our game a bit more rounded. Games have a score or,
    in our case, a time, and other rules as well. For the player to keep check on
    their progress we need to display the stats of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will quickly set up a HUD that will show the player everything they
    need to know on screen while he is dodging enemies. We will also declare and initialize
    the variables required to supply data to the HUD. In the next section, *Implementing
    the rules*, we can begin to manipulate variables such as, shields, time, fastest
    time, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by adding some member variables to the `TDView` class. We use
    a float value for the `distanceRemaining` variable because we will be using pseudo-kilometers
    and fractions of kilometers to represent the distance remaining until our hero
    makes it to her home planet. For the `timeTaken`, `timeStarted`, and `fastestTime`
    variables, we will use the **long** type because time is represented in milliseconds
    and the values get really big. Add this code after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For now, we will just leave these variables with their default values and concentrate
    on displaying them in our HUD. We will make them useful and meaningful in the
    next section, *Implementing the rules*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can go ahead and draw our HUD to display all the data the player may
    want to know while playing. As so often, we will be using our versatile `Paint`
    class object `paint` to do the bulk of the work. This time, we use the `drawText`
    method to add text to the screen, the `setTextAlign` method to justify our text,
    and `setTextSize` to scale the size of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add this code to our `TDView` class''s `draw` method. Add it as
    the last thing to draw, just before the call to `unlockCanvasAndPost()`, as shown
    by the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After entering this code, we have some errors and probably some questions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will deal with the questions. We will look more closely at what we
    are doing to `fastestTime`, `timeTaken`, `distanceRemaining`, and the value returned
    by `getSpeed` in the next section, *Implementing the rules*. Simply put, they
    are representations of distance and time that serve to give the player a sense
    of how they are doing. They are not real simulations of distance, although the
    time is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first error we will deal with is caused by a call to a nonexistent method
    `player.getShieldStrength`. Add a member variable `shieldStrength` to the `PlayerShip`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it to `2` in the `PlayerShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement your missing getter method in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final errors are caused by the undeclared variables `screenX` and `screenY`.
    It is now apparent that we need the screen resolution in this part of our code.
    The fastest way to deal with this is to make some new class variables called `screenX`
    and `screenY`. Declare these now just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, knowing the screen coordinates is useful in a number of places,
    so it makes sense to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `TDView` constructor, initialize `screenX` and `screenY` with the
    resolution passed in by the `GameActivity` class. Do this at the start of the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the game and see our HUD. The only parts of our HUD with meaningful
    data are the **Shield** and **Speed** labels. The speed is a pseudo-measurement
    of MPS (meters per second). Of course it has no bearing on reality, but it is
    relative to the speed of the whizzing stars, approaching enemies and soon, to
    the decreasing distance from the player''s goal, home:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a HUD](img/B04322_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we should pause and think about what we need to do later in the project
    because it will affect what we do while implementing our rules. When the player's
    ship is destroyed or when player reaches their goal, the game will end. This implies
    that the game will need to be restarted. We don't want to quit back to the home
    screen each time, so we need a way to restart the game from within the `TDView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, we are going to implement a `startGame` method in our `TDView`
    class. The constructor will be able to call it and our game loop will also be
    able to call it when necessary as well.
  prefs: []
  type: TYPE_NORMAL
- en: It will also be necessary to pass some of the tasks that the constructor currently
    performs onto the new `startGame` method so that it can properly do its job. Also,
    we will use `startGame` to initialize some of the variables that our game rules
    and HUD require.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish what we discussed, `startGame()` will need a copy of
    the application''s `Context` object. So, like we did with `startX` and `startY`,
    we will now make `context` a member of `TDView`. Declare it after the `TDView`
    class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the constructor right after the call to `super()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can now implement the new `startGame` method. Most of the code is just moved
    from the constructor. Note that the subtle but important differences, like using
    the class version of the screen coordinates `screenX` and `screenY` instead of
    the constructor parameters *x* and *y*. Also, we initialize `distanceRemaining`,
    `timeTaken`, and `timeStarted`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are you are wondering what is going on with the `timeStarted` initialization?
    We initialized `startTime` using a method of the `System` class, `currentTimeMillis`.
    Now, `startTime` holds the number of milliseconds since January 1, 1970\. We will
    see how this is used in the upcoming section, *Ending the game*. The `System`
    class has many uses. Here, we use it to get the number of milliseconds since January
    1, 1970\. This is a common system for measuring time in a computer. It is called
    Unix time and the moment before the 1st millisecond of January 1, 1970 is known
    as the Unix Epoch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, comment out or delete the now unnecessary code from the `TDView` constructor
    but add the call to `startGame()` in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to create a method to decrement the `PlayerShip` shield strength.
    This is so that when we detect a collision, we can reduce it by one each time.
    Add this simple method to the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can jump to the `TDView` class's `update` method and add code to implement
    our game rules a bit further. We will add a Boolean variable `hitDetected` just
    before we do all our collision detection. Inside each of the `if` blocks which
    detects a hit, we can set `hitDetected` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after all the collision detection code, we can see if a hit has been
    detected and reduce the player''s shield strength accordingly. Here is the top
    part of the `TDView` class''s `update` method with the new lines of code highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the nested if statement after the call to `player.reduceShieldStrength`.
    This detects when the player has lost all their shields and failed. We will deal
    with what happens here soon.
  prefs: []
  type: TYPE_NORMAL
- en: We are really close to finishing off our game rules. We just need to decrease
    the `distanceRemaining` relative to the player's speed. This is so that we know
    when the player has succeeded. We also need to update the `timeTaken` variable
    so that the HUD is updated each time our draw method is called. This may not seem
    important, but thinking ahead a little, we can foresee a time when the game has
    ended, either because the player has failed or because the player has won. Let's
    talk about the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the game is not ended, the game is playing, and if the player has just died
    or won, the game is ended. We need to know when the game is ended and when it
    is playing. Let''s make a new member variable `gameEnded` and declare it after
    the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can initialize `gameEnded` in the `startGame` method. Enter this code
    as the very last line in the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finish the last few lines of our game rules logic, but wrap them
    in a test to see if the game has ended or not. Add the following code to conditionally
    update our game rules logic, right at the end of the `TDView` class''s `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our HUD will now have accurate data to keep the player informed of exactly
    how they are doing. We can also detect when the player arrives home and wins because
    `distanceRemaining` will pass zero. In addition, when distance remaining is less
    than zero, we can test to see if `timeTaken` is less than `fastestTime` and update
    `fastestTime` if it is. We can also set `gameEnded` to `true`. Add this code directly
    after the last block of code in the `TDView` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We ended the game when the player won; now, add this next line of code to end
    the game when the player loses all their shields. Update this code in the `TDView`
    class''s `update` method. The new line of code is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we just need to make something actually happen when `gameEnded` is set
    to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to alternate how we draw the HUD based on whether the
    `gameEnded` Boolean is true or false. Identify the HUD drawing code in the `draw`
    method, shown again here for easy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to wrap that code in an `if`-`else` block. If the game is not ended,
    draw the normal HUD else draw an alternative. Wrap the HUD drawing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s deal with the `else` block, which we will execute when the game
    is ended. What we will do is draw a big **Game Over**, and show the end game stats
    from the HUD. The thread continues on but the HUD stops updating. Enter this code
    in the `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we switch text sizes using `setTextSize()`, and we align all the
    text in the center of the screen using `setTextAlign()`. This is what it looks
    like when you run the game. We just need a way to restart the game after it has
    ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game](img/B04322_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Restarting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow the player to restart after the game has ended, we just need to listen
    for a touch and call `startGame()`. Lets edit our `onTouchListener()` code to
    achieve this. The case `MotionEvent.ACTION_DOWN:` is the case we are interested
    in amending. We can simply add conditions here that if the screen is touched while
    the game is ended, restart. The new code to add to case `MotionEvent.ACTION_DOWN:`
    is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Try it out. You can now restart the game from the pause menu by tapping the
    screen. Is it just me or is it a bit quiet round here?
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding sound effects in Android is really straightforward. First, let's look
    at where we can get our sound FX from. If you just want to get on with the coding,
    you can use my sound FX in the `Chapter4/assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the FX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We require four sound FX for our Tappy Defender game:'
  prefs: []
  type: TYPE_NORMAL
- en: The sound for when our player crashes into an alien, which we will call `bump.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sound for when the player is destroyed, which we will call `destroyed.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fun sound for when the game first begins, which we will call `start.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a victory whoop-type sound, which we will call `win.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is a very quick guide to make these sound FX using BFXR. Grab a free copy
    of BFXR from [www.bfxr.net](http://www.bfxr.net).
  prefs: []
  type: TYPE_NORMAL
- en: Follow the simple instructions on the website to set it up. Try out a few of
    these things to make our cool sound FX.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a very condensed tutorial. You can do so much with BFXR. To learn more
    read the tips on the website at the previous URL.
  prefs: []
  type: TYPE_NORMAL
- en: Run `bfxr.exe`.![Generating the FX](img/B04322_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out all the preset types, which generate a random sound of the type you
    are working on. When you have a sound that is close to what you want, move to
    the next step:![Generating the FX](img/B04322_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Generating the FX](img/B04322_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see we can save in formats other than `.wav` too.![Generating
    the FX](img/B04322_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file use the `.ogg` extension at the end of the filename. Remember we need to
    create `bump.ogg`, `destroyed.ogg`, `start.ogg`, and `win.ogg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5 and create the four sound FX that we discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `app` folder in Android Studio. From the pop-up menu, navigate
    to **New** | **Android resource directory**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Directory name** field, type `assets`. Click on **OK** to create the
    `assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your operating system's file manager to add a folder called `assets` to
    the main folder of the project, then add the four sound files to the new assets
    folder in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SoundPool class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To play our sounds, we will use the `SoundPool` class. We are using the deprecated
    version of the `SoundPool` constructor because the new version needs API 21 or
    newer and it is likely that lots of readers will be using an earlier version of
    Android. We can dynamically get the Android version and provide a different version
    of the code for pre- and post-API level 21, but the older constructor meets our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the sound FX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declare a `SoundPool` object and some integers to represent the individual
    sounds. Add this code just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can initialize our `SoundPool` object and our integer sound IDs. We
    wrap the code in a `try`-`catch` block as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the call to `load()` starts a process of converting our `.ogg` files
    to raw sound data. If the process is not finished when a call to `playSound()`
    is made, the sound won''t play. The calls to `load()` are in the likely order
    of them being used to minimize this possibility. Enter this code in the constructor
    of our `TDView` class as shown. The new code is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Add a call to `playSound()` using the appropriate reference at the points in
    our code which represent the appropriate event in our game. We have four sounds,
    so four calls to `playSound()` will be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first goes at the very end of the `startGame()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two are highlighted in the `if(hitDetected)` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is in the `if(distanceRemaining < 0)` block, as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It's time to run Tappy Defender now and hear the sound in action.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to save our player's high score by saving it to a file when
    they achieve it and loading it back up again when Tappy Defender starts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the current fastest time is zero and can therefore
    never be beaten. The other problem is that every time the player quits the game
    the high score is lost. Now, we will load a default high score from a file. When
    a new high score is achieved, save it to the file. It doesn't matter if the player
    quits the game or even switches off their phone; their high score will remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need two new objects. Declare them as members of the `TDView` class
    after the `TDView` class declaration. The first is a `SharedPreferences` object
    and the second is an `Editor` object, which actually writes to the file for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `prefs` first as we just want to attempt to load a high score if one
    exists. We will also initialize `editor` ready for when we save our high score.
    We do this in the `TDView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use our `Editor` object to write any new fastest times to the `HiScores`
    file when appropriate. Add the extra highlighted lines shown to add the proposed
    changes to our file, first into a buffer and then commit the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is get the home screen to load up the fastest time
    and display it to the player. We will load the fastest time in exactly the same
    way as we did in our `TDView` constructor. We will also get a reference to our
    `TextView` through its ID `textHighScore`, which we assigned way back at the beginning
    of [Chapter 2](ch02.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We then use the `setText` method to display it to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `MainActivity.java` and add the highlighted code to the `onCreate`
    method to achieve what we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a complete working game. However, it is not really finished yet.
    To make a game that is genuinely playable and fun, we have to improve, refine,
    test, and iterate.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make our game better and more playable? Let's look at a number of
    possibilities and then go ahead and implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple different enemy graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the enemies a bit more interesting by adding a few more graphics
    to the game. First, we need to add the extra graphics to the project. Copy and
    paste `enemy2.png` and `enemy3.png` from the `Chapter4/drawables` folder of the
    download bundle into the `drawables` folder in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple different enemy graphics](img/B04322_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: enemy2 and enemy3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to amend the `EnemyShip` constructor. This code generates
    a random number between 0 and 2, and then switches to load a different enemy bitmap
    accordingly. Our completed constructor now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that we just need to move the `Random generator = new Random();` line of
    code to the top of the constructor, so we can use it to choose a bitmap as well
    as generate a random height later in the constructor, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: An exercise in balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the biggest playability issue in the game is the difference in difficulty
    when playing on a medium/high resolution screen as opposed to a low resolution
    screen. For example, one of my testing devices is a Samsung Galaxy S2\. It is
    a few years old now, and the screen resolution is 800 x 480 pixels when held in
    the landscape position. For comparison, I tested the game on a Samsung Galaxy
    S4 that has 1920 x 1080 pixels in landscape mode. This is more than double the
    resolution of the S2.
  prefs: []
  type: TYPE_NORMAL
- en: On the S4, the player seems to effortlessly glide in between the almost insignificant
    enemies, while on the S2, the player is faced with an almost impenetrable wall
    of alien steel.
  prefs: []
  type: TYPE_NORMAL
- en: The real solution to this problem is to draw game objects at pseudo-real-world
    coordinates, and then map these coordinates back to the device at the same scale,
    regardless of resolution. This way, the game will look and play the same on both
    an S2 and an S4\. In the next project, we will build a more advanced game engine
    that does this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will still have the consideration of the actual physical screen
    size, making the player's experience varied, but this is a much more accepted
    situation by gamers.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick and dirty solution, we will vary the size of the ships and the number
    of enemies. So on lower resolutions, we will have three enemies, but we will shrink
    their size. On higher resolutions, we will increase the number of enemies gradually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `EnemyShip` class, just after the `switch` block that loads our enemy
    graphics into our `Bitmap` object, add the line shown highlighted to call a new
    method that we will write soon, `scaleBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write our new `scaleBitmap` method. This simple helper method
    takes a single argument, which as we have seen is the horizontal resolution of
    the screen. We then use the resolution and the static `createScaledBitmap` method
    to reduce our `Bitmap` objects on a scale of 2 or 3 depending on the resolution
    of the screen. Add the new `scaleBitmap` method to the `EnemyShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The enemies will be scaled down in size on lower resolution screens. Now, let's
    increase the number of enemies for the higher resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will add code to the `TDView` class to add extra enemies to higher
    resolution screens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning! This code sucks, but it works and it shows us where we can make improvements
    in our next project. When planning a game, there is always a trade-off between
    good design and simplicity. By keeping things organized from the start, we can
    get away with a bit of hacking near the end. Yes, we can redesign the way we spawn
    and store our game objects, and if Tappy Defender was an ongoing project then
    this would be worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more enemy ship objects after the first three, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add code to conditionally initialize these two new objects in the `startGame`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code in the `update` method to update our fourth and fifth enemies and
    check for collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `draw` method, draw our extra enemies when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we now realize that we may like to scale the player as well. This
    makes it plain that perhaps we need a `Ship` class, from which we can derive `PlayerShip`
    and `EnemyShip`.
  prefs: []
  type: TYPE_NORMAL
- en: Add to this the cumbersome manner in which we added the extra enemies for higher
    resolution screens and a much more polymorphic solution is probably worthwhile.
    We will see how we can seriously improve this and virtually every other aspect
    of our game engine in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Format time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at how time is formatted in the player''s HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Format time](img/B04322_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yuck! Let's write a simple helper method to make this look a whole lot nicer.
    We will add a new method to the `TDView` class called `formatTime()`. The method
    uses the number of elapsed milliseconds in this game (`timeTaken`) and reorganizes
    them into seconds and fractions of a second. It pads the fractions with zeros
    where appropriate and returns the result as a `String` ready to be drawn in the
    `TDView` class's `draw` method. The reason the method takes an argument rather
    than just using the member variable `timeTaken` is so we can reuse this code in
    a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We amend the line that draws the time in the player''s HUD. For context, in
    the next piece of code, I have commented out the entirety of the original line
    and provided the new line, which includes our call to `formatTime()`, and highlighted
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, with one minor change, we can use this formatting on the **Fastest:**
    label in the HUD as well. Again, the old line is commented out and the new one
    is highlighted. Find and amend the code in the `TDView` class''s `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also update the time formatting on the pause screen. The lines to
    change are commented out and the new lines to add are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Fastest:** is now formatted in the same way as **Time:** on both the in-game
    HUD and the pause screen HUD. Take a look at our neatly formatted time now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Format time](img/B04322_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handle the back button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will quickly add a small block of code to handle what happens when the player
    presses the back button on their Android device. Add this new method to both the
    `GameActivity` and `MainActivity` classes. We simply check if the back button
    was pressed, and if it was, call `finish()` to let the operating system know we
    are done with this activity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The finished game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, in case you are following along for the theory and not the practical,
    here is the finished `GameActivity` on a high resolution screen with a few hundred
    extra stars and shields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The finished game](img/B04322_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented the component parts of a basic game engine. We can do so
    much more. Of course, a modern mobile game will have a lot more going on than
    in ours. How will we handle collisions when there are lots more game objects?
    Couldn't we tighten up our class hierarchy a bit, as there were lots of similarities
    between our `PlayerShip` and `EnemyShip` classes? How can we add complex internal
    character animations without confusing the structure of our code, and what if
    we want smart enemies, enemies who can actually think?
  prefs: []
  type: TYPE_NORMAL
- en: We need realistic backgrounds, side objectives, power-ups, and pick-ups. We
    want a game world with real-world coordinates that map back accurately regardless
    of the resolution of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We need a smarter game loop that runs the game at the same speed regardless
    of the CPU it is being processed on. Most of all, what we really need, more than
    any of these things, is a dirty big machine gun. Let's build a classic platform
    game.
  prefs: []
  type: TYPE_NORMAL
