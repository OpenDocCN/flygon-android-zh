- en: Chapter 4. Calling Java Back from Native Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 从本地代码回调 Java
- en: '*To reach its full potential, JNI allows calling back Java code from C/C++.
    "Back" because native code is first invoked from Java, which in turn calls it
    back. Such calls are performed through a reflective API, which allows doing almost
    anything that can be done directly in Java.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*为了发挥其最大潜力，JNI 允许从 C/C++ 回调 Java 代码。"回调"是因为本地代码首先从 Java 被调用，然后反过来调用 Java。这种调用是通过反射
    API 完成的，几乎可以做任何直接在 Java 中能做的事情。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Another important matter to consider with JNI is threading. Native code can
    be run on a Java thread, managed by the Dalvik VM, and also from a native thread
    created with standard POSIX primitives. Obviously, a native thread cannot call
    JNI code unless it is turned into a managed Java thread! Programming with JNI
    necessitates knowledge of all these subtleties. This chapter will guide you through
    the main ones.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在使用 JNI 时需要考虑的另一个重要问题是线程。本地代码可以在由 Dalvik VM 管理的 Java 线程上运行，也可以从使用标准 POSIX
    原语创建的本机线程上运行。显然，除非将本地线程转换为管理的 Java 线程，否则本地线程不能调用 JNI 代码！使用 JNI 编程需要了解所有这些细微之处。本章将引导你了解主要的几个问题。*'
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The last topic, which is specific to Android and not JNI, other: the Android-specific
    Bitmap API aims at giving full processing power to graphics applications running
    on these tiny (but powerful) devices.*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*最后一个主题是特定于 Android 而不是 JNI 的：特定的 Android 位图 API 旨在为运行在这些小型（但强大）设备上的图形应用程序提供完全的处理能力。*'
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Android NDK also proposes a new API to access natively an important type
    of object: bitmaps. The Bitmap API, which is Android-specific, gives full processing
    power to graphics applications running on these tiny (but powerful) devices.*'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android NDK 还提供了一个新的 API，以本地方式访问一种重要的对象类型：位图。特定的 Bitmap API，它是 Android 独有的，为运行在这些小型（但强大）设备上的图形应用程序提供了完全的处理能力。*'
- en: The `Store` project we started in the previous chapter is going to be our canvas
    to demonstrate JNI callbacks and synchronization. To illustrate Bitmap processing,
    we are going to create a new project that decodes a device's camera feed inside
    native code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中开始的 `Store` 项目将作为展示 JNI 回调和同步的画布。为了说明位图处理，我们将创建一个新项目，在本地代码中解码设备的摄像头馈送。
- en: 'To summarize, in this chapter, we are going to learn how to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中，我们将学习如何：
- en: Call Java back from native code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地代码调用 Java
- en: Attach a native thread to the Dalvik VM and handle synchronization with Java
    threads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地线程附加到 Dalvik VM，并与 Java 线程处理同步
- en: Process Java bitmaps in native code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中处理 Java 位图
- en: By the end of this chapter, you should be able to make Java and C/C++ communicate
    and synchronize reciprocally.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够使 Java 和 C/C++ 互相通信和同步。
- en: Calling Java back from native code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地代码回调 Java
- en: 'In the previous chapter, we discovered how to get a Java class descriptor with
    the JNI method `FindClass()`. However, we can get much more! Actually, if you
    are a regular Java developer, this should remind you of something: the Java Reflection
    API. JNI is similar in that it can modify Java object fields, run Java methods,
    and access static members, but from native code!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了如何使用 JNI 方法 `FindClass()` 获取 Java 类描述符。然而，我们还可以获得更多！实际上，如果你是一个常规的
    Java 开发者，这应该会让你想起一些东西：Java 反射 API。JNI 与其类似，它可以修改 Java 对象字段，运行 Java 方法，以及访问静态成员，但这一切都来自本地代码！
- en: For this last part with the `Store` project, let's enhance our store application
    so that it notifies Java when an entry has been successfully inserted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Store` 项目的最后一部分，让我们增强我们的商店应用程序，使其在成功插入条目时通知 Java。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part10`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的最终项目名为 `Store_Part10`。
- en: Time for action – determining JNI method signatures
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间——确定 JNI 方法签名
- en: 'Let''s define a Java interface that native C/C++ code will call back through
    JNI:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个 Java 接口，本地 C/C++ 代码将通过 JNI 调用这个接口：
- en: 'Create a `StoreListener.java`, which contains an interface defining a few callbacks,
    one for integers, one for strings, and one for colors, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `StoreListener.java`，其中包含一个定义几个回调的接口，一个用于整数，一个用于字符串，一个用于颜色，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open `Store.java` and make a few changes.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Store.java` 并进行一些更改。
- en: Declare a member delegate `StoreListener`, to which success callbacks are sent
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个成员委托 `StoreListener`，成功回调将被发送给它
- en: Change the `Store` constructor to inject the delegate listener, which is going
    to be `StoreActivity`
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改 `Store` 构造函数以注入委托监听器，这将是 `StoreActivity`
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, implement the `StoreListener` interface and its corresponding methods,
    which simply forwards calls to the delegate:'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，实现`StoreListener`接口及其相应的方法，这些方法只是将调用转发给委托：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open `StoreActivity.java` and implement the `StoreListener` interface in `PlaceholderFragment`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreActivity.java`并在`PlaceholderFragment`中实现`StoreListener`接口。
- en: 'Also, change the `Store` construction accordingly:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，相应地更改`Store`构造：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a success callback is received, a simple toast message is raised:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当接收到成功回调时，会弹出一个简单的提示消息：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open a terminal in the `Store` project's directory and run the `javap` command
    to determine method signatures.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store`项目的目录中打开终端，并运行`javap`命令以确定方法签名。
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Time for action – determining JNI method signatures](img/9645_04_01.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手实践——确定JNI方法签名](img/9645_04_01.jpg)'
- en: '*What just happened?*'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Calling back Java methods with the JNI API requires **descriptors**, as we will
    see in the next part. To determine a Java method descriptor, we need a **signature**.
    Indeed, methods in Java can be **overloaded**, which means that there can be two
    methods with the same name but different parameters. This is why a signature is
    required.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JNI API回调Java方法需要**描述符**，我们将在下一部分看到。为了确定一个Java方法描述符，我们需要一个**签名**。实际上，Java中的方法可以**重载**，这意味着可以有相同名称但不同参数的两个方法。这就是为什么需要签名的原因。
- en: 'We can determine a method''s signature with `javap`, a JDK utility to disassemble
    `.class` files. This signature can then be given to the JNI Reflection API. Formally
    speaking, a signature is declared in the following way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`javap`来确定一个方法的签名，`javap`是一个JDK实用程序，用于反汇编`.class`文件。然后这个签名可以传递给JNI反射API。正式地说，签名是以下这样声明的：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For example, the signature for the method `boolean myFunction(android.view.View
    pView, int pIndex)` would be `(Landroid/view/View;I)Z`. Another example, `(I)V`,
    means an integer is expected and a void is returned. A last example, `(Ljava/lang/String;)V`,
    means a String is passed in parameter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，方法`boolean myFunction(android.view.View pView, int pIndex)`的签名将是`(Landroid/view/View;I)Z`。另一个例子，`(I)V`，意味着需要整数并返回void。最后一个例子，`(Ljava/lang/String;)V`，意味着传递了一个String作为参数。
- en: 'The following table summarizes the various types available in JNI with their
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了JNI中可用的各种类型及其代码：
- en: '| Java type | Native type | Native array type | Type code | Array type code
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Java类型 | 本地类型 | 本地数组类型 | 类型代码 | 数组类型代码 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |'
- en: '| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |'
- en: '| `char` | `jchar` | `jcharArray` | `C` | `[C` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `jchar` | `jcharArray` | `C` | `[C` |'
- en: '| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |'
- en: '| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |'
- en: '| `int` | `jint` | `jintArray` | `I` | `[I` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `jint` | `jintArray` | `I` | `[I` |'
- en: '| `long` | `jlong` | `jlongArray` | `J` | `[J` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `jlong` | `jlongArray` | `J` | `[J` |'
- en: '| `Short` | `jshort` | `jshortArray` | `S` | `[S` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | `jshort` | `jshortArray` | `S` | `[S` |'
- en: '| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |'
- en: '| `String` | `jstring` | `N/A` | `L` | `[L` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `jstring` | `N/A` | `L` | `[L` |'
- en: '| `Class` | `jclass` | `N/A` | `L` | `[L` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Class` | `jclass` | `N/A` | `L` | `[L` |'
- en: '| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |'
- en: '| `void` | `void` | `N/A` | `V` | `N/A` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `void` | `N/A` | `V` | `N/A` |'
- en: All these values correspond to the one dumped by `javap`. For more information
    about descriptors and signatures, have a look at the Oracle documentation at [http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都与`javap`转储的值相对应。关于描述符和签名的更多信息，请查看Oracle文档 [http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3)。
- en: Now that we have the proper signature, we can start calling Java from C/C++.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了正确的签名，现在可以从C/C++中调用Java了。
- en: Time for action – calling back Java from native code
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——从本地代码回调Java
- en: 'Let''s continue our `Store` by calling back the interface we defined from native
    code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过从本地代码调用我们定义的接口来构建`Store`：
- en: 'In `com_packtpub_store_Store.cpp`, declare method descriptors with type `jmethodID`
    for each callback, which is going to be cached:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com_packtpub_store_Store.cpp`中，为每个回调声明类型为`jmethodID`的方法描述符，这将会被缓存：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, cache all the callback descriptors in `JNI_OnLoad()`. This can be done
    in two main steps:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`JNI_OnLoad()`中缓存所有回调描述符。这可以通过两个主要步骤完成：
- en: 'Getting a Class descriptor with the JNI method `FindClass()`. One can find
    a class descriptor, thanks to its absolute package path, here: `com./packtpub/store/Store`.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用JNI方法`FindClass()`获取类描述符。通过类的绝对包路径，可以找到类描述符，例如：`com./packtpub/store/Store`。
- en: 'Retrieving a method descriptor from the class descriptor with `GetMethodID()`.
    To differentiate several overloaded methods, the signatures retrieved earlier
    with `javap` must be specified:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`GetMethodID()`从类描述符中获取方法描述符。为了区分几个重载方法，必须指定之前用`javap`获取的签名：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notify the Java Store (that is, `pThis`) when an integer is successfully inserted
    in `setInteger()`. To invoke a Java method on a Java object, simply use `CallVoidMethod()`
    (which means that the called Java method returns void). To do so, we need:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在`setInteger()`中成功插入整数时，通知Java商店（即`pThis`）。要调用Java对象上的Java方法，只需使用`CallVoidMethod()`（这意味着被调用的Java方法返回void）。为此，我们需要：
- en: An object instance
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象实例
- en: A method signature
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名
- en: Effective parameters to pass, if applicable (here, an integer value)
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，传递有效的参数（这里是一个整数值）
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Repeat the operation for strings. There is no need to generate a Global reference
    when allocating the returned Java string as it is used immediately in the Java
    callback. We can also destroy the Local reference to this string right after usage,
    but JNI will take care of that when returning from the native callback:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对字符串重复该操作。在分配返回的Java字符串时不需要生成全局引用，因为它在Java回调中立即使用。我们也可以在使用后立即销毁这个字符串的局部引用，但JNI在从原生回调返回时会处理这个问题：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, repeat the operation for colors:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对颜色重复该操作：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*What just happened?*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Launch the application and insert an integer, a string, or color entry. A successful
    message is displayed with the inserted value. The native code called the Java
    side thanks to the JNI Reflection API. This API is not only useful to execute
    a Java method, it is also the only way to process `jobject` parameters passed
    to a native method. However, if calling C/C++ code from Java is rather easy, performing
    Java operations from C/C++ is a bit more involving!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并插入一个整数、字符串或颜色条目。系统会显示包含插入值的成功信息。原生代码通过JNI反射API调用了Java端。这个API不仅用于执行Java方法，也是处理传递给原生方法的`jobject`参数的唯一方式。然而，从Java调用C/C++代码相对简单，而从C/C++执行Java操作则要复杂一些！
- en: 'Although a bit repetitive and verbose, calling any Java method should always
    be as trivial as this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些重复和冗长，调用任何Java方法都应该像这样简单：
- en: 'Retrieve the class descriptor from those we want to call methods (here, the
    `Store` Java object):'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们想要调用方法的类描述符中获取类描述符（这里的`Store` Java对象）：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Retrieve the method descriptors for the callback we want to call (such as the
    `Method` class in Java). These method descriptors are retrieved from the class
    descriptor, which owns it (like a `Class` in Java):'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取我们想要调用的回调的方法描述符（如在Java中的`Method`类）。这些方法描述符是从拥有它的类描述符中获取的（如在Java中的`Class`）：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Optionally, cache the descriptors so that they can be used immediately in future
    native calls. Again, `JNI_OnLoad()` makes it easy to cache JNI descriptors before
    any native call is made. Descriptors whose names end with `Id`, such as `jmethodID`,
    can be freely cached. They are not references that can be leaked, or have to be
    made global on the opposite to `jclass` descriptors.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，缓存描述符以便它们可以在未来的原生调用中立即使用。同样，`JNI_OnLoad()`使得在执行任何原生调用之前缓存JNI描述符变得容易。以`Id`结尾的描述符，如`jmethodID`，可以自由缓存。它们不是可以泄漏的引用，或者相对于`jclass`描述符必须全局化。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Caching descriptors is definitely good practice, as retrieving Fields or Methods
    through the JNI reflection may cause some overhead.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存描述符绝对是好的实践，因为通过JNI反射获取字段或方法可能会产生一些开销。
- en: 'Invoke methods with the necessary parameters on an object. The same method
    descriptor can be reused on any object instance of the corresponding class:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象上使用必要的参数调用方法。相同的方法描述符可以用于相应类的任何对象实例：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whatever method you need to call on a Java object, the same process always applies.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你需要在一个Java对象上调用什么方法，同样的过程总是适用。
- en: More on the JNI Reflection API
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于JNI反射API的更多内容
- en: 'Once you know the Reflection API, you know most of the JNI. Here are some of
    the provided methods that may be useful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 了解反射API后，你基本上就掌握了JNI的大部分内容。以下是一些可能有用的方法：
- en: '`FindClass()` retrieves a (Local) reference to a `Class` descriptor object
    according to its absolute path:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindClass()`根据其绝对路径获取（局部）引用到`Class`描述符对象：'
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`GetObjectClass()` has the same purpose, except that `FindClass()` finds class
    definitions according to their absolute path, whereas the other finds the class
    directly from an object instance (such as `getClass()` in Java):'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetObjectClass()` 的目的相同，不同之处在于 `FindClass()` 根据它们的绝对路径查找类定义，而另一个直接从对象实例（如
    Java 中的 `getClass()`）查找类：'
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following methods allow you to retrieve JNI descriptors for methods and
    fields, and either static or instance members. These descriptors are IDs and not
    references to Java objects. There is no need to turn them into Global references.
    These methods require the method or field name and a signature to differentiate
    overloads. Constructor descriptors are retrieved in the same way as methods, except
    that their name is always `<init>` and they have a void return value:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下方法允许您获取方法和字段的 JNI 描述符，以及静态或实例成员。这些描述符是 ID，而不是对 Java 对象的引用。无需将它们转换为全局引用。这些方法需要方法或字段名称以及签名以区分重载。构造函数描述符的获取方式与方法的获取方式相同，不同之处在于其名称始终为
    `<init>` 并且具有 void 返回值：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a second set of methods to retrieve field values using their corresponding
    descriptors. There is one getter and one setter method per primitive type, plus
    another for objects:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有另一组方法可以通过对应的描述符来获取字段值。每种基本类型都有一对获取器和设置器方法，以及一个用于对象的方法：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same goes for methods according to their return values:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于根据它们的返回值分类的方法同样如此：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Variants of these methods exist with an `A` and `V` postfix. The behavior is
    identical, except that arguments are specified respectively using a `va_list`
    (that is, variable argument list) or `jvalue` array (`jvalue` being a union of
    all JNI types):'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些方法存在带有 `A` 和 `V` 后缀的变体。行为相同，不同之处在于参数分别使用 `va_list`（即可变参数列表）或 `jvalue` 数组（`jvalue`
    是所有 JNI 类型的联合体）指定：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Have a look at `jni.h` in the Android NDK `include` directory to see all the
    possibilities by the JNI reflective API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 Android NDK `include` 目录中的 `jni.h` 文件，以了解 JNI 反射 API 的所有可能性。
- en: Debugging JNI
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 JNI
- en: The goal of JNI calls is often performance. Thus, JNI does not perform advanced
    checking when its API methods are invoked. Hopefully, there exists an **extended
    checking** mode, which performs advanced checks and gives feedback in the Android
    Logcat.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 调用的目标通常是性能。因此，当调用其 API 方法时，JNI 并不执行高级检查。幸运的是，存在一种**扩展检查**模式，它执行高级检查并在 Android
    Logcat 中提供反馈。
- en: 'To activate it, run the following command from a command prompt:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活它，请从命令提示符运行以下命令：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The extended checking mode is available for applications started after this
    flag is set, until it is set to `0`, or until the device is rebooted. For rooted
    devices, the whole device can be started with this mode with the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此标志后，启动的应用程序可以使用扩展检查模式，直到将其设置为 `0`，或者直到设备重新启动。对于已获得根权限的设备，可以使用以下命令启动整个设备：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If everything works properly, a message **Late-enabling – Xcheck:jni** appears
    in the Logcat when your application starts. Then, check the Logcat regularly to
    find its JNI warning or error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，当你的应用程序启动时，Logcat 中会出现 **Late-enabling – Xcheck:jni** 的消息。然后，定期检查 Logcat
    以查找其 JNI 警告或错误。
- en: '![Debugging JNI](img/9645_04_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![调试 JNI](img/9645_04_04.jpg)'
- en: Synchronizing Java and native threads
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步 Java 和本地线程
- en: Parallel programming is a mainstream subject nowadays. Android makes no exception
    since the introduction of multicore processors. You can do the threading entirely
    on the Java side (with the Java Thread and Concurrency APIs), on the native side
    (with the **POSIX PThread** API, which is provided by the NDK), and, more interestingly,
    between the Java and native side using JNI.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程如今是一个主流课题。自从引入多核处理器以来，Android 也不例外。你可以在 Java 端完全进行线程处理（使用 Java Thread 和
    Concurrency API），在本地端（使用 NDK 提供的 **POSIX PThread** API），以及更有趣的是，使用 JNI 在 Java
    和本地端之间进行。
- en: In this part, we will create a background thread, the watcher, which keeps a
    constant eye on what is inside the data store. It iterates through all entries
    and then sleeps for a fixed amount of time. When the watcher thread finds a key
    of a specific type predefined in the code, it acts accordingly. For this first
    part, we are just going to clip integer values to a predefined range.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个后台线程，观察者，它始终关注数据存储中的内容。它遍历所有条目，然后休眠固定的时间。当观察者线程找到在代码中预定义的特定类型的键时，它会相应地采取行动。对于这一部分，我们只是将整数值裁剪到预定义的范围。
- en: Of course, threads need synchronization. The native thread is going to access
    and update the store only when a user understands the UI thread, and does not
    modify it. The native thread is created in C/C++ but the UI thread is a Java thread.
    We are going to use JNI monitors to synchronize both of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，线程需要同步。本地线程只在用户理解UI线程并且不修改它时访问和更新存储。本地线程在C/C++中创建，但UI线程是Java线程。我们将使用JNI监视器来同步它们两者。
- en: Time for action – allocating an object with JNI
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用JNI分配对象。
- en: 'Let''s define a background Watcher that will use an object shared between Java
    and C/C++ as a lock:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个后台观察者，它将使用在Java和C/C++之间共享的对象作为锁：
- en: 'In `Store.java`, add two new methods to start and stop a watcher thread. These
    methods respectively return and take a `long` as parameter. This value helps us
    hold a native pointer on the Java side:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store.java`中，添加两个新方法以启动和停止观察者线程。这两个方法分别返回和接受一个`long`类型的参数。这个值可以帮助我们在Java端保存本地指针：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new file, `StoreThreadSafe.java`. The `StoreThreadSafe` class inherits
    from the `Store` class and aims at making the `Store` instances thread-safe using
    `synchronized` Java blocks. Declare a static member field `LOCK` of type `Object`
    and define a default constructor:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`StoreThreadSafe.java`。`StoreThreadSafe`类继承自`Store`类，旨在使用`synchronized`
    Java代码块使`Store`实例线程安全。声明一个类型为`Object`的静态成员字段`LOCK`并定义一个默认构造函数：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Override the `Store` methods, such as `getCount()`, `getInteger()`, and `setInteger()`
    using Java blocks synchronized with the `LOCK` object:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Store`类的方法，如`getCount()`、`getInteger()`和`setInteger()`，使用与`LOCK`对象同步的Java代码块：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Do the same for all other methods, such as `getString()`, `setString()`, `getColor()`,
    `setColor()`, etc., and the `stopWatcher()` method. Do not override the `onSuccess`
    callbacks and the `startWatcher()` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有其他方法，如`getString()`、`setString()`、`getColor()`、`setColor()`等，以及`stopWatcher()`方法执行相同的操作。不要重写`onSuccess`回调方法和`startWatcher()`方法：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Do *not* override the `onSuccess` callbacks and the `startWatcher()` method.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不要*重写`onSuccess`回调方法和`startWatcher()`方法。'
- en: 'Open `StoreActivity.java` and replace the previous `Store` instance with an
    instance of `StoreThreadSafe`. Also, create a member field of type `long` to hold
    a native pointer to the watcher thread. When the fragment is resumed, start the
    watcher thread and save its pointer. When the fragment is paused, stop the watcher
    thread with the previously saved pointer:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreActivity.java`，并用`StoreThreadSafe`的实例替换之前的`Store`实例。同时，创建一个类型为`long`的成员字段以保存指向观察者线程的本地指针。当片段恢复时，启动观察者线程并保存其指针。当片段暂停时，使用先前保存的指针停止观察者线程：
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Edit `jni/Store.h` and include a new header `pthread.h`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/Store.h`并包含一个新的头文件`pthread.h`：
- en: '[PRE28]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The watcher works on a `Store` instance updated at regular intervals of time.
    It needs:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察者在定时间隔更新后的`Store`实例上工作。它需要：
- en: The instance of the `Store` structure it watches
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所监视的`Store`结构的实例。
- en: A `JavaVM`, which is the only object safely shareable among threads and from
    which `JNIEnv` can be safely retrieved
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`JavaVM`，它是线程间唯一可以安全共享的对象，并且可以从中安全获取`JNIEnv`。
- en: A Java object to synchronize on (corresponding to the `LOCK` object we defined
    on the Java side)
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于同步的Java对象（对应于我们在Java端定义的`LOCK`对象）
- en: A `pthread` variable dedicated to native thread management
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于本地线程管理的`pthread`变量。
- en: An indicator to stop the watcher thread
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止观察者线程的指示器。
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, define three methods to start and stop the watcher thread, run its
    main loop, and process an entry:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义三个方法以启动和停止观察者线程，运行它的主循环和处理一个条目：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. You should
    see two new methods, `Java_com_packtpub_store_Store_startWatcher()` and `Java_com_packtpub_store_Store_stopWatcher()`,
    in it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javah`刷新JNI头文件`jni/com_packtpub_Store.h`。你应在其中看到两个新方法，`Java_com_packtpub_store_Store_startWatcher()`和`Java_com_packtpub_store_Store_stopWatcher()`。
- en: In `com_packtpub_store_Store.cpp`, create a new static variable `gLock` that
    is going to hold the Java synchronization object.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`com_packtpub_store_Store.cpp`中，创建一个新的静态变量`gLock`，它将保存Java同步对象。
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create an instance of the `Object` class in `JNI_OnLoad()` using the JNI Reflection
    API:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI反射API在`JNI_OnLoad()`中创建`Object`类的一个实例：
- en: First, find its `Object` constructor with `GetMethodID()`. Constructors in JNI
    are named `<init>` and have no result.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用`GetMethodID()`找到它的`Object`构造函数。在JNI中，构造函数名为`<init>`并且没有返回结果。
- en: Then, invoke the constructor to create an instance and make it global.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，调用构造函数以创建一个实例并将其全局化。
- en: 'Finally, remove local references when they become useless:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当本地引用不再有用时，移除它们：
- en: '[PRE32]'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save the created `Object` instance in the `StoreThreadSafe.LOCK` field. This
    object is going to be used during the lifetime of the application to synchronize:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的`Object`实例保存在`StoreThreadSafe.LOCK`字段中。这个对象将在应用程序的生命周期内用于同步：
- en: First, retrieve the `StoreThreadSafe` class and its `LOCK` field using the JNI
    Reflection methods `FindClass()` and `GetStaticFieldId()`
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用JNI反射方法`FindClass()`和`GetStaticFieldId()`检索`StoreThreadSafe`类及其`LOCK`字段。
- en: Then, save the value into the `LOCK` static field with the JNI method `SetStaticObjectField()`,
    which requires a field signature (such as methods)
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用JNI方法`SetStaticObjectField()`将值保存到`LOCK`静态字段中，该方法需要字段签名（如方法）。
- en: 'Finally, remove the local reference to the `StoreThreadSafe` class when it
    becomes useless:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当`StoreThreadSafe`类不再有用时，移除对其的本地引用：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement `startWatcher()`, which calls the corresponding method defined earlier.
    It requires `JavaVM`, which can be retrieved from the `JNIEnv` object with `GetJavaVM()`.
    The pointer (that is, the memory address) to the created `Store` is returned as
    a `long` value to the Java side, which can then store it for alter use:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`startWatcher()`，它调用之前定义的相应方法。它需要`JavaVM`，可以从`JNIEnv`对象使用`GetJavaVM()`获取。创建的`Store`的指针（即内存地址）作为一个`long`值返回给Java端，然后可以保存它以供以后使用：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Terminate by implementing `stopWatcher()`, which casts the given `long` value
    back to a native pointer. Pass it to the corresponding method:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现`stopWatcher()`来结束，它将给定的`long`值转换回本地指针。将其传递给相应的方法：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*What just happened?*'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We used JNI to allocate a Java object from native code and save it in a static
    Java field. This example shows the power of the JNI Reflection API; almost anything
    that can be done in Java, can be done from native code with JNI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JNI从本地代码分配一个Java对象，并将其保存在一个静态的Java字段中。这个例子展示了JNI反射API的强大功能；几乎在Java中可以做的任何事情，都可以通过JNI从本地代码完成。
- en: 'To allocate Java objects, JNI provides the following methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配Java对象，JNI提供了以下方法：
- en: '`NewObject()` to instantiate a Java object using the specified constructor
    method:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`NewObject()`通过指定的构造方法实例化一个Java对象：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Variants of this method exist with an `A` and `V` postfix. Behavior is identical,
    except that arguments are specified respectively using a `va_list` or a `jvalue`
    array:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法存在带有`A`和`V`后缀的变体。行为相同，不同之处在于参数分别使用`va_list`或`jvalue`数组指定：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`AllocObject()` allocates a new object but does not invoke its constructor.
    A possible usage would be the allocation of many of the objects, which does not
    require initialization to get some performance gains. Use it only if you know
    what you are doing:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllocObject()`分配一个新对象但不调用其构造函数。可能的用途是分配许多不需要初始化的对象，以获得一些性能提升。只有在你清楚自己在做什么时才使用它：'
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous chapter, we used static variables for the native store because
    its life cycle was tied to the application. We want to remember values until the
    application exits. If a user leaves the activity and comes back to it later, values
    are still available while the process remains alive.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为本地存储使用了静态变量，因为其生命周期与应用程序相关联。我们希望记住值，直到应用程序退出。如果用户离开活动，稍后再回来，只要进程仍然存活，值仍然可用。
- en: For the watcher thread we used a different strategy because its life cycle is
    tied to the activity. When the activity gains focus, the thread is created and
    started. When activity loses focus, the thread is stopped and destroyed. Since
    this thread may need time to stop, several occurrences may run temporarily at
    the same time (if you turn the screen quickly multiple times in the `Store` example).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于观察者线程，我们使用了不同的策略，因为其生命周期与活动相关联。当活动获得焦点时，创建并启动线程。当活动失去焦点时，停止并销毁线程。由于这个线程可能需要时间来停止，因此在`Store`示例中快速多次切换屏幕时，可能会有几个实例同时运行。
- en: Thus, it is not safe to use static variables as it could be concurrently overwritten
    (leading to a memory leak), or, even worse, released (leading to memory corruption).
    These kind of problems can also arise when an activity starts another one. In
    that case, `onStop()` and `onDestroy()` of the first activity occurs after `onCreate()`
    and `onStart()` of the second activity, as defined in the Android Activity life
    cycle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用静态变量是不安全的，因为它们可能会被并发覆盖（导致内存泄漏），或者更糟糕的是，被释放（导致内存损坏）。当活动启动另一个活动时，也可能出现这类问题。在这种情况下，第一个活动的`onStop()`和`onDestroy()`在第二个活动的`onCreate()`和`onStart()`之后发生，如Android活动生命周期所定义。
- en: Instead, a better solution to handle this situation is to allow the Java side
    to manage the native memory. In our example, a pointer to a native structure allocated
    on the native side is returned to the Java side as a `long` value. Any further
    JNI calls must be performed with this pointer as a parameter. This pointer can
    then be given back to the native side when the life cycle of this piece of data
    ends.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，处理这种情况的一个更好的解决方案是允许Java端管理原生内存。在我们的示例中，一个指向在原生端分配的原生结构的指针被返回给Java端作为一个 `long`
    值。任何进一步的JNI调用必须使用此指针作为参数执行。然后，当这块数据生命周期结束时，可以将此指针还给原生端。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The use of a `long` value (represented on 64-bit) to save a native pointer is
    necessary in order to remain compatible with 64-bit versions of Android (with
    64-bit memory addresses) that arrived with Android Lollipop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `long` 值（在64位上表示）来保存原生指针是必要的，以便与从Android Lollipop开始的64位版本Android（具有64位内存地址）保持兼容。
- en: To summarize, use native static variables with care. If your variables are tied
    to the application life cycle, static variables are fine. If your variables are
    tied to the activity lifecycle, you should allocate an instance of them in your
    activity and manage them from there to avoid problems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，谨慎使用原生静态变量。如果你的变量与应用程序生命周期相关联，静态变量是可以的。如果变量与活动生命周期相关联，你应在活动中分配它们的实例，并从那里管理它们以避免问题。
- en: Now that we have a shared lock between the Java and the native side, let's continue
    our example by implementing the Watcher thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在Java和原生端之间有了共享锁，让我们通过实现观察线程继续我们的示例。
- en: Time for action – running and synchronizing a thread
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时刻——运行并同步线程
- en: 'Let''s create a native thread using the POSIX PThread API and attach it to
    the VM:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用POSIX PThread API创建一个原生线程并将其附加到VM：
- en: 'In `Store.cpp`, include `unistd.h`, which gives access to the `sleep()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Store.cpp` 中，包含 `unistd.h`，它提供了访问 `sleep()` 函数的权限：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Implement `startWatcher()`. This method is executed from the UI thread. To do
    so, first instantiate and initialize a `StoreWatcher` structure.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现 `startWatcher()` 方法。该方法从UI线程中执行。为此，首先实例化并初始化一个 `StoreWatcher` 结构。
- en: 'Then, initialize and launch a native thread with the `pthread` POSIX API:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `pthread` POSIX API 初始化并启动一个原生线程：
- en: '[PRE40]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, initialize and launch a native thread with the PThread POSIX API:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，使用PThread POSIX API初始化并启动一个原生线程：
- en: '`pthread_attr_init()` initializes the necessary data structure'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_attr_init()` 初始化必要的数据结构'
- en: '`pthread_create()` starts the thread'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_create()` 启动线程'
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement `stopWatcher()`, which turns off the running indicator to request
    the watcher thread to stop:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `stopWatcher()` 方法，关闭运行指示器以请求观察线程停止：
- en: '[PRE42]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Implement the thread's main loop in `runWatcher()`. Here, we are not on the
    UI thread anymore, but on the watcher thread.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `runWatcher()` 中实现线程的主循环。在这里，我们不再处于UI线程，而是处于观察线程。
- en: So first, attach the thread as a daemon to the Dalvik VM using `AttachCurrentThreadAsDaemon()`.
    This operation returns `JNIEnv` from the given `JavaVM`. This gives us direct
    access to the Java side from this new thread. Remember that `JNIEnv` is thread-specific
    and cannot be shared between threads directly.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，首先使用 `AttachCurrentThreadAsDaemon()` 将线程作为守护进程附加到Dalvik VM。此操作从给定的 `JavaVM`
    返回 `JNIEnv`。这使我们能从这个新线程直接访问Java端。记住 `JNIEnv` 是线程特定的，不能直接在线程间共享。
- en: 'Then, make this thread loop and take a nap for a few seconds during each iteration
    using `sleep()`:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使这个线程循环并在每次迭代中休眠几秒钟，使用 `sleep()`：
- en: '[PRE43]'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While in a loop iteration, delimit a critical section (where only one thread
    can go at the same time) with JNI methods `MonitorEnter()` and `MonitorExit()`.
    These methods require an object to synchronize on (like a `synchronized` block
    in Java).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环迭代中，使用JNI方法 `MonitorEnter()` 和 `MonitorExit()` 划定一个临界区（一次只能有一个线程进入）。这些方法需要一个对象来进行同步（就像Java中的
    `synchronized` 块）。
- en: 'Then, you can safely:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以安全地：
- en: Check whether the thread should be stopped, and leave the loop in that case
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查线程是否应该停止，并在那种情况下离开循环
- en: Process each entry from the store
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自存储的每个条目
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Before exiting, detach the thread when it is going to end and exit. It is very
    important to always detach an attached thread so that the Dalvik or ART VM stop
    managing it.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在退出之前，当线程即将结束和退出时，分离线程。始终分离已附加的线程非常重要，这样Dalvik或ART VM就不再管理它。
- en: 'Finally, terminate the thread using the `pthread_exit()` API method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `pthread_exit()` API方法终止线程：
- en: '[PRE45]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, write the `processEntry()` method, which does nothing more than check
    the boundaries of integer entries and limit them to the arbitrary range `[-100000,100000]`.
    You can also process any of the other entries you wish:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写`processEntry()`方法，该方法所做的不过是检查整数条目的边界，并将其限制在任意范围`[-100000,100000]`内。你也可以处理其他任何你希望处理的条目：
- en: '[PRE46]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'Compile and run the application in Debug mode using the Eclipse Java debugger
    (not the native one). When the application starts, a native background thread
    is created and attached to the Dalvik VM. You can see it in the **Debug** view.
    Then, the UI thread and the native background thread are synchronized together
    with the JNI Monitor API to handle concurrency issues properly. Finally, when
    leaving the application, the background thread is detached and destroyed. Thus,
    it disappears from the **Debug** view:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse Java调试器（不是本地调试器）以调试模式编译并运行应用程序。当应用程序启动时，会创建一个本地后台线程并将其附加到Dalvik VM。你可以在**调试**视图中看到它。然后，UI线程和本地后台线程使用JNI监视器API同步，以正确处理并发问题。最后，当离开应用程序时，后台线程会被分离并销毁。因此，它从**调试**视图中消失：
- en: '![What just happened?](img/9645_04_02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645_04_02.jpg)'
- en: Now, from the `Store` interface on your Android device, define a key and enter
    an integer value greater than `100,000`. Wait a few seconds and retrieve the value
    using the same key. It should appear clamped to `100,000` by the Watcher thread.
    This Watcher looks for each value in the store and changes it if needed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的Android设备上的`Store`接口中，定义一个键并输入一个大于`100,000`的整数值。等待几秒钟，然后使用相同的键检索该值。它应该会被观察者线程限制在`100,000`以内。这个观察者会检查存储中的每个值，并在需要时进行更改。
- en: The Watcher is running on a native thread (that is, not created directly by
    the Java VM). The NDK allows creating native threads using the PThread POSIX API.
    This API is a standard used commonly on Unix systems for multithreading. It defines
    a set of functions and data structures, all prefixed with `pthread_`, to create
    not only threads, but also **Mutexes** (which stands for Mutual Exclusion) or
    **Condition** **variables** (to make a thread wait for a specific condition).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者运行在一个本地线程上（即不是由Java虚拟机直接创建的）。NDK允许使用PThread POSIX API创建本地线程。这个API是一个在Unix系统上广泛用于多线程的标准。它定义了一系列以`pthread_`为前缀的函数和数据结构，不仅可以创建线程，还可以创建**互斥锁**（互斥的缩写）或**条件变量**（让一个线程等待特定条件）。
- en: The PThread API is a whole subject in itself and is outside the scope of this
    book. You will need to know it to master native multithreading on Android. For
    more information on this subject, have a look at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)
    and [http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: PThread API本身就是一个完整的主题，超出了本书的范围。你需要了解它才能掌握Android上的本地多线程。有关此主题的更多信息，请查看[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)和[http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/)。
- en: Synchronizing Java and C/C++ with JNI Monitors
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JNI监视器同步Java和C/C++
- en: 'On the Java side, we synchronize threads using `synchronized` blocks with an
    arbitrary lock object. Java also allows methods, whether native or not, to be
    `synchronized`. The lock object, in that case, is implicitly the one on which
    native methods are defined. For example, we could define a native method as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java端，我们使用带有任意锁对象的`synchronized`块来同步线程。Java还允许方法（无论是否为本地方法）被声明为`synchronized`。在这种情况下，锁对象是隐式地定义为本地方法的对象。例如，我们可以如下定义一个本地方法：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This would not have worked in our case, since there is a single static instance
    of the store on the native side. We need a single static instance of our lock
    object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这本来是无法工作的，因为本地端有一个单一的静态存储实例。我们需要一个单一的静态锁对象实例。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the pattern used here, that is, making `StoreThreadSafe` inherit
    from the `Store` class, override its methods and use static variables, should
    not be considered specifically as the best practice. It has been used for simplicity
    purposes in this book because the `Store` and the `lock` object are static.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用的模式，即让`StoreThreadSafe`继承自`Store`类，覆盖其方法并使用静态变量，不应特别认为是最佳实践。由于`Store`和`lock`对象是静态的，本书为了简单起见使用了这种方式。
- en: 'On the native side, synchronization is performed with a JNI monitor, which
    is equivalent to the `synchronized` keyword in Java:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地端，使用JNI监视器进行同步，这相当于Java中的`synchronized`关键字：
- en: '`MonitorEnter()` delimits the start of a critical section. The monitor is associated
    with an object, which can be considered as a kind of identifier. Only one thread
    at a time can go inside the section defined by this object:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorEnter()`表示临界区的开始。监视器与一个对象关联，该对象可以被视为一种标识符。一次只能有一个线程进入由这个对象定义的区间：'
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`MonitorExit()` delimits the end of a critical section. It must be called,
    along with `MonitorEnter()`, to ensure the monitor is released and other threads
    can go:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonitorExit()`表示临界区的结束。必须调用它，以及`MonitorEnter()`，以确保监视器被释放，其他线程可以继续执行：'
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because Java threads are based on POSIX primitives internally, it is also possible
    to implement thread synchronization entirely natively with the POSIX API. You
    can find more information about it at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Java线程在内部是基于POSIX原始操作，所以也可以完全本地实现线程同步，使用POSIX API。你可以在这个链接找到更多信息：[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java and C/C++ are different languages with similar, but somewhat different
    semantics. Thus, always be careful not to expect C/C++ to behave like Java. As
    an example, the volatile has a different semantic in Java and C/C++, since both
    follow a different memory model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C/C++是具有相似但略有不同语义的不同语言。因此，始终注意不要期望C/C++的行为像Java。例如，volatile在Java和C/C++中的语义是不同的，因为它们遵循不同的内存模型。
- en: Attaching and detaching native threads
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附着和分离本地线程
- en: 'By default, the Dalvik VM is unaware of the native threads that run in the
    same process. In return, the native threads cannot access the VM either... unless
    it is attached to it. The attachment is handled in JNI with the following methods:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Dalvik VM不知道在同一进程中运行的本地线程。作为回报，本地线程也无法访问VM...除非它附着到VM。在JNI中，以下方法处理附着：
- en: '`AttachCurrentThread()` to tell the VM to manage the current thread. Once attached,
    a pointer to the `JNIEnv` for the current thread is returned at the specified
    location:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AttachCurrentThread()`告诉虚拟机管理当前线程。一旦附着，当前线程的`JNIEnv`指针将在指定位置返回：
- en: '[PRE50]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`AttachCurrentThreadAsDaemon()` to attach a thread as a daemon. Java specification
    defines that the JVM does not have to wait for a daemon thread to exit before
    leaving, the opposite to normal threads. This distinction has no real meaning
    on Android, since an application can be killed at any time by the system:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AttachCurrentThreadAsDaemon()`将线程作为守护线程附着。Java规范定义了JVM在退出前不必等待守护线程结束，与普通线程相反。在Android上，这种区别没有实际意义，因为应用程序可以在任何时候被系统杀死：
- en: '[PRE51]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`DetachCurrentThread()` indicates to the VM that a thread does not need to
    be managed anymore. An attached thread like the Watcher thread must be eventually
    unattached before exiting. Dalvik detects threads that are not detached and reacts
    by aborting and leaving a dirty crash dump in your logs! When getting detached,
    any monitor held is released, and any waiting thread is notified:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetachCurrentThread()`表示线程不再需要被管理。像Watcher线程这样的已附着线程在退出前必须最终被分离。Dalvik会检测未分离的线程，并通过终止并在日志中留下不干净的崩溃转储来做出反应！在分离时，持有的任何监视器都会被释放，任何等待的线程都会被通知：'
- en: '[PRE52]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since Android 2.0, a technique to make sure a thread is systematically detached
    is to bind a destructor callback to the native thread with `pthread_key_create()`
    and call `DetachCurrentThread()` in it. A `JNIEnv` instance can be saved into
    thread local storage with `pthread_setspecific()` to pass it as an argument to
    the destructor.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自从Android 2.0起，确保线程被系统分离的一种技术是使用`pthread_key_create()`将析构函数回调绑定到本地线程，并在其中调用`DetachCurrentThread()`。可以使用`pthread_setspecific()`将`JNIEnv`实例保存到线程本地存储中，以便将其作为参数传递给析构函数。
- en: After a thread is attached, the **ClassLoader** JNI uses Java classes to correspond
    to the first object it finds on the call stack. For purely native threads, no
    `ClassLoader` might be found. In that case, JNI uses the system `ClassLoader`,
    which might not be able to find your own application classes, that is, `FindClass()`
    fails. In that case, either cache the necessary JNI elements globally in `JNI_OnLoad()`
    or share an application class loader with the needing thread.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线程附着后，**ClassLoader** JNI会使用Java类来对应调用堆栈上找到的第一个对象。对于纯本地线程，可能找不到`ClassLoader`。在这种情况下，JNI使用系统`ClassLoader`，它可能无法找到你自己的应用程序类，也就是说，`FindClass()`失败。在这种情况下，可以在`JNI_OnLoad()`中全局缓存必要的JNI元素，或者与需要线程共享应用程序类加载器。
- en: Processing bitmaps natively
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地处理位图
- en: The Android NDK proposes an API dedicated to bitmap processing, which gives
    direct access to the surface of Android bitmaps. This API is specific to Android
    and is not related to the JNI specification. However, bitmaps are Java objects
    and will need to be treated as such in native code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK提供了一个专门用于位图处理的API，可以直接访问Android位图的表面。这个API是特定于Android的，与JNI规范无关。然而，位图是Java对象，在本地代码中需要作为对象处理。
- en: To see more concretely how bitmaps can be modified from native code, let's try
    to decode a camera feed from native code. Raw video frames recorded on Android
    are generally encoded in a specific format, **YUV**, which is not compatible with
    classic RGB images. This is a situation where native code comes to the rescue
    to help us decode such images. In the following example, we are going to extract
    each color component (that is, red, green, and blue) into a separate bitmap.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体地了解位图如何从本地代码中修改，让我们尝试从本地代码解码一个摄像头馈送。在Android上记录的原始视频帧通常以特定的格式编码，即**YUV**，这与传统的RGB图像不兼容。在这种情况下，本地代码可以提供帮助，帮助我们解码这些图像。在以下示例中，我们将把每个颜色组件（即红、绿和蓝）提取到单独的位图中。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `LiveCamera`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的结果项目名为`LiveCamera`。
- en: Time for action – decoding a camera's feed
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——解码摄像头的馈送
- en: 'Let''s write the necessary Java code to record and display pictures in a fresh
    new project:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个全新的项目中编写必要的Java代码以记录和显示图片：
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第[二章](ch02.html "第二章. 开始一个本地Android项目") *开始一个本地Android项目*所示，创建一个新的混合Java/C++项目：
- en: Name it `LiveCamera`
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名为`LiveCamera`
- en: The main package is `com.packtpub.livecamera`
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主包是`com.packtpub.livecamera`
- en: The main activity is `LiveCameraActivity`
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要活动是`LiveCameraActivity`
- en: The main activity layout name is `activity_livecamera`
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主活动布局名为`activity_livecamera`
- en: Use the **Blank Activity** template
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**空白活动**模板
- en: 'Once created, turn the project into a native project as already seen. In the
    `AndroidManifest.xml` file, request access permission to the camera. Then, set
    the activity style to `fullscreen` and its orientation to `landscape`. Landscape
    orientation avoids most camera orientation problems that are met on Android devices:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，将项目转换为已知的本地项目。在`AndroidManifest.xml`文件中，请求访问摄像头的权限。然后，将活动样式设置为`fullscreen`，并将其方向设置为`landscape`。横屏方向避免了在Android设备上遇到的多数摄像头方向问题：
- en: '[PRE53]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define the `activity_livecamera.xml` layout as follows. It represents a 2x2
    grid containing one `TextureView` and three `ImageView` elements:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式定义`activity_livecamera.xml`布局。它表示一个包含一个`TextureView`和三个`ImageView`元素的2x2网格：
- en: '[PRE54]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open `LiveCameraActivity.java` and implement it as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LiveCameraActivity.java`文件，并按以下方式实现：
- en: First, extend `SurfaceTextureListener`, which is going to help us initialize
    and close the camera feed
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，扩展`SurfaceTextureListener`，这将帮助我们初始化和关闭摄像头馈送
- en: Then, extend the `PreviewCallback` interface to listen for new camera frames
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，扩展`PreviewCallback`接口以监听新的摄像头帧
- en: 'Do not forget to load the native static library, as follows:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记按以下方式加载本地静态库：
- en: '[PRE55]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a few member variables:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些成员变量：
- en: '`mCamera` is the Android camera API'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCamera`是Android摄像头API'
- en: '`mTextureView` displays the raw camera feed'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTextureView`显示原始摄像头馈送'
- en: '`mVideoSource` captures camera frames into a byte buffer'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mVideoSource`将摄像头帧捕获到字节缓冲区'
- en: '`mImageViewR`, `G`, and `B` display processed images, one for each color component'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImageViewR`、`G`和`B`显示处理过的图像，每个颜色组件一个'
- en: '`mImageR`, `G`, and `B` are the bitmaps backing the `ImageView` (the "back
    buffers")'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mImageR`、`G`和B`是`ImageView`的位图支持（即“后台缓冲区”）'
- en: '[PRE56]'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `onCreate()`, specify the layout defined in the previous step.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`onCreate()`中，指定在前一步中定义的布局。
- en: Then, retrieve the views to show images.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，获取要显示图像的视图。
- en: 'Finally, listen for `TextureView` events with `setSurfaceTextureListener()`.
    You can ignore some of the callbacks that are not necessary in this example:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`setSurfaceTextureListener()`监听`TextureView`事件。你可以忽略在这个例子中不必要的回调：
- en: '[PRE57]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `onSurfaceTextureAvailable()` callback in `LiveCameraActivity.java` is triggered
    after the `TextureView` surface is created. This is the place where surface dimensions
    and pixel formats get known.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LiveCameraActivity.java`中的`onSurfaceTextureAvailable()`回调在创建`TextureView`表面后被触发。在这里可以知道表面尺寸和像素格式。
- en: 'So, open the Android camera and set up `TextureView` as its preview target.
    Listen for new camera frames with `setPreviewCallbackWithBuffer()`:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，打开Android相机并将`TextureView`设置为它的预览目标。使用`setPreviewCallbackWithBuffer()`监听新的相机帧：
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, call `findBestResolution()`, which we will implement next to find a suitable
    resolution for the camera feed. Set up the latter accordingly with the `YCbCr_420_SP`
    format (which should be the default on Android).
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`findBestResolution()`，我们将在下一节实现它以找到适合相机馈送的合适分辨率。相应地设置后者为`YCbCr_420_SP`格式（这应该是Android上的默认格式）。
- en: '[PRE59]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After that, set up the video buffer and the bitmaps that display camera frames:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，设置视频缓冲区和显示相机帧的位图：
- en: '[PRE60]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, enqueue the video frame buffer and start the camera preview:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，将视频帧缓冲区入队并开始相机预览：
- en: '[PRE61]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Still in `LiveCameraActivity.java`, implement `findBestResolution()`. An Android
    camera can support various resolutions, which are highly dependent on the device.
    As there is no rule on what could be the default resolution, we need to look for
    a suitable one. Here, we select the biggest resolution that fits the display surface,
    or the default one if none can be found.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`LiveCameraActivity.java`中，实现`findBestResolution()`。Android相机可以支持多种分辨率，这些分辨率高度依赖于设备。由于没有规定默认分辨率应该是什么，我们需要寻找一个合适的分辨率。在这里，我们选择适合显示表面的最大分辨率，或者如果没有找到，则选择默认分辨率。
- en: '[PRE62]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Release the camera when the `TextureView` surface is destroyed in `onSurfaceTextureDestroyed()`,
    as it is a shared resource. Bitmap buffers can also be recycled and nullified
    to ease garbage collector work.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TextureView`表面在`onSurfaceTextureDestroyed()`中被销毁时，释放相机，因为这是一个共享资源。位图缓冲区也可以被回收和置空，以减轻垃圾收集器的工作。
- en: '[PRE63]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, decode raw video frames in `onPreviewFrame()`. This handler is triggered
    by the `Camera` class each time a new frame is ready.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onPreviewFrame()`中解码原始视频帧。每次有新帧准备好时，由`Camera`类触发此处理程序。
- en: Raw video bytes are passed to the native method `decode()`, along with the backing
    bitmap, and a filter to select each color component.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原始视频字节传递给本地方法`decode()`，以及支持的位图，并选择每个颜色分量的过滤器。
- en: Once decoded, invalidate the surface to redraw it.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解码完成后，使表面无效以重新绘制它。
- en: Finally, "re-enqueue" the raw video buffer to request the capture of a new video
    frame.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，"重新入队"原始视频缓冲区以请求捕获新的视频帧。
- en: '[PRE64]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*What just happened?*'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We captured live images from our device's camera thanks to the Android Camera
    API. After setting up the camera capture format and definition, we created all
    the necessary capture buffer and output images to display onscreen. Captures are
    saved in a buffer enqueued by the application when it requires a new frame. Then,
    this buffer is given with a bitmap to a native method, which we will write in
    the next section. Finally, the output image is displayed onscreen.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Android Camera API，我们从设备的相机捕获了实时图像。在设置相机捕获格式和定义之后，我们创建了所有必要的捕获缓冲区和输出图像以在屏幕上显示。当应用程序需要新帧时，捕获内容被保存在由应用程序入队的缓冲区中。然后，这个缓冲区与位图一起被传递给本地方法，我们将在下一节中编写它。最后，输出图像显示在屏幕上。
- en: The video feed is encoded in the YUV NV21 format. YUV is a color format originally
    invented in the old days of electronics to make black and white video receivers
    compatible with color transmissions and is still commonly used nowadays. The default
    frame format is guaranteed by the Android specification to be **YCbCr 420 SP**
    (or **NV21**) on Android.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 视频馈送以YUV NV21格式编码。YUV是一种最初在电子时代的早期发明的颜色格式，以使黑白视频接收器与彩色传输兼容，现在仍然被广泛使用。Android规范保证默认帧格式为**YCbCr
    420 SP**（或**NV21**）。
- en: Tip
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although YCbCr 420 SP is the default video format on Android, the emulator only
    supports YCbCr 422 SP. This defect should not cause much trouble as it basically
    swaps colors. This problem should not occur on real devices.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管YCbCr 420 SP是Android上的默认视频格式，但模拟器只支持YCbCr 422 SP。这个缺陷基本上是颜色交换，不应该造成太大麻烦。在真实设备上不会出现这个问题。
- en: Now that our live image is captured, let's process it on the native side.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的实时图像已经被捕获，让我们在本地处理它。
- en: Time for action – processing pictures with the Bitmap API
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间——使用Bitmap API处理图片
- en: 'Let''s continue our application by decoding and filtering images on the native
    side by the color channel:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过颜色通道在本地端解码和过滤图像：
- en: Create native C source, `jni/CameraDecoder.c` (not a C++ file, so that we can
    see the difference with JNI code written in C++).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地C源文件，`jni/CameraDecoder.c`（不是C++文件，这样我们可以看到与用C++编写的JNI代码的区别）。
- en: 'Include `android/bitmap.h`, which defines the NDK bitmap processing API and
    `stdlib.h` (not `cstdlib` as this file is written in C):'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含`android/bitmap.h`，它定义了NDK位图处理API和`stdlib.h`（不是`cstdlib`，因为此文件是用C编写的）：
- en: '[PRE65]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Write a few utility macros to help decode a video.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一些实用宏以帮助解码视频。
- en: '`toInt()` converts a jbyte to an integer, erasing all useless bits with a mask'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toInt()`函数将jbyte转换为整数，使用掩码擦除所有无用的位。'
- en: '`max()` gets the maximum between two values'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`函数获取两个值中的最大值。'
- en: '`clamp()` clamps a value inside a defined interval'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clamp()`函数将值限制在定义的区间内。'
- en: '`color()` builds an ARGB color from each color component'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color()`从每个颜色分量构建一个ARGB颜色。'
- en: '[PRE66]'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Implement the native method `decode()`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`decode()`本地方法。
- en: First, retrieve bitmap information and check whether its pixel format is a 32-bit
    RGBA. Then, lock it to allow drawing operations.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，获取位图信息并检查其像素格式是否为32位RGBA。然后，锁定它以允许绘图操作。
- en: 'After this, gain access to the input video frame content passed as a Java byte
    array with `GetPrimitiveArrayCritical()`:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，使用`GetPrimitiveArrayCritical()`获取作为Java字节数组传递的输入视频帧内容：
- en: '[PRE67]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Decode the raw video frame into the output bitmap. The video frame is encoded
    in the YUV format, which is quite different from RGB. The YUV format encodes a
    color in three components:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始视频帧解码为输出位图。视频帧以YUV格式编码，这与RGB有很大不同。YUV格式以三个分量编码颜色：
- en: One luminance component, that is, the grayscale representation of a color.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个亮度分量，即颜色的灰度表示。
- en: Two chrominance components, which encode the color information (also called
    **Cb** and **Cr** as they represent the blue-difference and red-difference).
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个色度分量，它们编码颜色信息（也称为**Cb**和**Cr**，因为它们代表蓝色差和红色差）。
- en: 'There are many frame formats based on YUV colors. Here, we convert frames by
    following the YCbCr 420 SP (or NV21) format. This kind of image frame is composed
    of a buffer of 8-bit Y luminance samples, followed by a second buffer of interleaved
    8-bit V and U chrominance samples. The VU buffer is subsampled, which means that
    there are less U and V samples compared to Y samples (1 U sample and 1 V sample
    for 4 Y samples). The following algorithm processes each pixel and converts each
    YUV pixel to RGB using the appropriate formula (see `http://www.fourcecc.org/fccyvrgb.php`
    for more information):'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多基于YUV颜色的帧格式。这里，我们按照YCbCr 420 SP（或NV21）格式转换帧。这种图像帧由一个8位Y亮度样本缓冲区组成，后面跟着一个交错的8位V和U色度样本缓冲区。VU缓冲区是子采样的，这意味着与Y样本相比，U和V样本较少（对于4个Y样本，有1个U样本和1个V样本）。以下算法处理每个像素，并使用适当的公式将每个YUV像素转换为RGB（更多信息请参见`http://www.fourcecc.org/fccyvrgb.php`）：
- en: '[PRE68]'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To finish, release the Java byte buffer acquired earlier and unlock the backing
    bitmap.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，释放之前获取的Java字节缓冲区并解锁背后的位图。
- en: '[PRE69]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Instead of relying on a naming convention to find native methods, JNI allows
    native methods to be registered manually in `JNI_OnLoad()`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JNI允许在`JNI_OnLoad()`中手动注册本地方法，而不是依赖命名约定来查找本地方法。
- en: So, define a table that describes the native methods to register their name,
    signature, and address. Here, only `decode()` needs to be specified.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，定义一个表来描述要注册其名称、签名和地址的本地方法。这里，只需指定`decode()`。
- en: 'Then, in `JNI_OnLoad()`, find the Java on which the native method `decode()`
    is declared (here, `LiveCameraActivity`), and tell JNI which method to use with
    `RegisterNatives()`:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在`JNI_OnLoad()`中，找到声明本地方法`decode()`的Java（这里是`LiveCameraActivity`），并使用`RegisterNatives()`告诉JNI使用哪个方法：
- en: '[PRE70]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Write the `Application.mk` makefile as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写`Application.mk` makefile：
- en: '[PRE71]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Write the `Android.mk` makefile as follows (link it to the `jnigraphics` module,
    which defines the Android Bitmap API):'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写`Android.mk` makefile（将其链接到定义Android Bitmap API的`jnigraphics`模块）：
- en: '[PRE72]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*What just happened?*'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Compile and run the application. The raw video feed is displayed in the top-left
    corner without any transformation. The raw video frame is decoded in native code
    and each color channel is extracted into three Java bitmaps. These bitmaps are
    displayed inside three `ImageView` elements in each of the corners of the screen.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。未经任何转换，原始视频馈送显示在左上角。原始视频帧在本地代码中解码，并将每个颜色通道提取到三个Java位图中。这些位图显示在屏幕每个角的三个`ImageView`元素内。
- en: '![What just happened?](img/9645_04_03.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/9645_04_03.jpg)'
- en: The algorithm used to decode the YUV frame originates from the Ketai open source
    project, an image and sensor processing library for Android. See [http://ketai.googlecode.com/](http://ketai.googlecode.com/)
    for more information. Beware that YUV to RGB is an expensive operation that is
    likely to remain a point of contention in your program (**RenderScript**, which
    we will discover in [Chapter 10](ch10.html "Chapter 10. Intensive Computing with
    RenderScript"), *Intensive Computing with RenderScript*, can help in that task).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解码YUV帧的算法源自Ketai开源项目，这是一个针对Android的图像和传感器处理库。更多信息请访问[http://ketai.googlecode.com/](http://ketai.googlecode.com/)。请注意，YUV到RGB是一项昂贵的操作，很可能会成为程序中的争议点（我们将在[第10章](ch10.html
    "第10章. 使用RenderScript进行密集计算")，*使用RenderScript进行密集计算*中介绍的**RenderScript**可以在该任务中提供帮助）。
- en: The code presented here is far from being optimal (the decoding algorithm can
    be optimized, the video frames, captured with multiple buffers, memory accesses
    can be reduced, and code can be multithreaded) but it gives an overview of how
    bitmap can be processed natively with the NDK.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码远非最优（解码算法可以进行优化，使用多个缓冲区捕获的视频帧，可以减少内存访问，并且代码可以是多线程的），但它概述了如何使用NDK本地处理位图。
- en: 'Native code is given direct access to the bitmap surface thanks to the Android
    NDK Bitmap API defined in the `jnigraphics` module. This API, which can be considered
    as an Android specific extension to JNI, defines the following methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 借助Android NDK位图API，在`jnigraphics`模块中定义，本地代码可以直接访问位图表面。这个API可以看作是JNI的Android特定扩展，定义了以下方法：
- en: '`AndroidBitmap_getInfo()` to retrieve bitmap information. The returned value
    is negative when a problem occurs, or else `0`:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_getInfo()`用于获取位图信息。当出现问题时，返回值将为负数，否则为`0`：'
- en: '[PRE73]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Bitmap information is retrieved in the `AndroidBitmapInfo` structure, which
    is defined as follows:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图信息在`AndroidBitmapInfo`结构中获取，定义如下：
- en: '[PRE74]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`AndroidBitmap_lockPixels()` gives exclusive access to the bitmap while processing
    it. The returned value is negative when a problem occurs, or else `0`:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_lockPixels()`在处理位图时提供对其的独占访问。当出现问题时，返回值为负数，否则为`0`：'
- en: '[PRE75]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`AndroidBitmap_unlockPixels()` releases the exclusive lock on the bitmap. The
    returned value is negative when a problem occurs, or else `0`:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidBitmap_unlockPixels()`释放对位图的独占锁定。当出现问题时，返回值为负数，否则为`0`：'
- en: '[PRE76]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Drawing operations on any bitmap occurs systematically in three main steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何位图的绘制操作都系统地分为三个主要步骤：
- en: First, the bitmap surface is acquired.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取位图表面。
- en: Then, bitmap pixels are modified. Here, video pixels are converted to RGB and
    written to the bitmap surface.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改位图像素。在这里，视频像素被转换为RGB并写入位图表面。
- en: Finally, the bitmap surface is released.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放位图表面。
- en: Bitmaps must be systematically locked and then unlocked when accessed natively.
    Drawing operations must occur imperatively between a lock/unlock pair. Have a
    look at the `bitmap.h` header file for more information.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地访问位图时，必须系统地锁定位图并在访问后解锁。绘制操作必须在锁定/解锁对之间强制执行。更多信息请查看`bitmap.h`头文件。
- en: Registering native methods manually
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动注册本地方法
- en: In our store example, native method prototypes have been generated automatically
    by `Javah` using a specific name and parameter convention. The Dalvik VM can then
    load them at runtime by "guessing" their names. However, this convention is easy
    to break and has no runtime flexibility. Hopefully, JNI lets you manually register
    native methods that are going to be called from Java. And what better place than
    `JNI_OnLoad()` to do that?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的商店示例中，本地方法原型已通过`Javah`使用特定的名称和参数约定自动生成。然后，Dalvik VM可以在运行时通过“猜测”它们的名称来加载它们。然而，这种约定很容易被打破，并且在运行时没有灵活性。幸运的是，JNI允许您手动注册将从Java中调用的本地方法。还有比`JNI_OnLoad()`更好的地方来做这件事吗？
- en: 'Registration is performed with the following JNI method:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注册是通过以下JNI方法完成的：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`jclass` is a reference to the Java class hosting the native method. We will
    see more about it through this chapter and the next one.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jclass`是对托管本地方法的Java类的引用。我们将在本章和下一章中更详细地了解它。'
- en: '`methods` is an array of `JNINativeMethod`, a structure describing the native
    methods to register.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methods`是一个`JNINativeMethod`数组，该结构描述了要注册的本地方法。'
- en: '`nMethods` indicates how many methods are described inside the `methods` array.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nMethods`表示`methods`数组内描述的方法数量。'
- en: 'The `JNINativeMethod` structure is defined as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNINativeMethod`结构定义如下：'
- en: '[PRE78]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The first and second elements are `name` and `signature` of the corresponding
    Java method, and the third parameter `fnPtr`, is a pointer to the corresponding
    method on the native side. That way, you can get rid of `javah` and its annoying
    naming convention and choose at runtime which method to call.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个元素是对应Java方法的`name`和`signature`，第三个参数`fnPtr`，是指向原生侧对应方法的指针。这样，你可以摆脱`javah`及其讨厌的命名约定，并在运行时选择要调用的方法。
- en: JNI in C versus JNI in C++
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C中的JNI与C++中的JNI对比。
- en: The NDK allows writing applications in either C (like our `LiveCamera` example)
    or C++ (like our `Store` example). So does JNI.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: NDK允许用C（如我们的`LiveCamera`示例）或C++（如我们的`Store`示例）编写应用程序。JNI也是如此。
- en: 'C is not an object-oriented language but C++ is. This is why you do not write
    JNI in C like in C++. In C, `JNIEnv` is in fact a structure containing function
    pointers. Of course, when `JNIEnv` is given to you, all these pointers are initialized
    so that you can call them a bit like an object. However, this parameter, which
    is implicit in an object-oriented language, is given as the first parameter in
    C (`env` in the following code). Also, `JNIEnv` needs to be dereferenced the first
    time to run a method:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: C不是一种面向对象的语言，但C++是。这就是为什么你不能像在C++中那样在C中编写JNI。在C中，`JNIEnv`实际上是一个包含函数指针的结构。当然，当你得到`JNIEnv`时，所有这些指针都已初始化，你可以像使用对象一样调用它们。然而，这个在面向对象语言中隐含的参数，在C中作为第一个参数给出（以下代码中的`env`）。此外，首次运行方法时需要取消引用`JNIEnv`：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The C++ code is more natural and simple. This parameter is implicit, and there
    is no need to dereference `JNIEnv`, as methods are not declared as function pointers
    anymore, but as real member methods:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码更自然、更简单。这个参数是隐式的，无需取消引用`JNIEnv`，因为方法不再声明为函数指针，而是作为真正的成员方法：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Thus, despite being really similar, you do not write JNI code in C in exactly
    the same way you write it in C++.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管非常相似，但你不能以完全相同的方式在C中编写JNI代码，就像在C++中编写一样。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Thanks to JNI, Java and C/C++ can be tightly integrated together. Android is
    now fully bilingual! Java can call C/C++ code with any type of data or object,
    and native code can call Java back.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于JNI，Java和C/C++可以紧密集成在一起。Android现在完全双语化了！Java可以使用任何类型的数据或对象调用C/C++代码，原生代码也可以回调Java。
- en: We also discovered how to call Java code from native code with the JNI Reflection
    API. Practically any Java operation can be performed from native code thanks to
    it. However, for best performance, class, method, or field descriptors must be
    cached.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了如何使用JNI反射API从原生代码调用Java代码。实际上，几乎任何Java操作都可以通过它从原生代码执行。然而，为了最佳性能，类、方法或字段描述符必须被缓存。
- en: We also saw how to attach and detach a thread to the VM and synchronize Java
    and native threads together with JNI monitors. Multithreaded code is probably
    one of the most difficult subjects in programming. Do it with care!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了如何将线程附加到虚拟机，并使用JNI监视器同步Java和原生线程。多线程代码可能是编程中最困难的主题之一。要谨慎处理！
- en: Finally, we also natively processed bitmaps thanks to JNI, and decoded a video
    feed by hand. However, an expensive conversion is needed from the default YUV
    format (which should be supported on every device according to Android specifications)
    to RGB.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过JNI原生处理了位图，并手动解码了视频流。然而，从默认的YUV格式（根据Android规范，每个设备都应该支持）到RGB的转换成本较高。
- en: When dealing with native code on Android, JNI is almost always in the way. It
    is a verbose and very technical API, not to mention cumbersome, which requires
    care. Its subtleties would require a whole book for an in-depth understanding.
    Instead, this chapter has given you the essential knowledge to integrate your
    own C/C++ module in your own Java application.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Android上的原生代码时，几乎总是离不开JNI。它是一个冗长且技术性很强的API，更不用说它还繁琐，需要小心处理。要深入理解它的细微之处，可能需要一整本书的篇幅。而本章则为你提供了将你自己的C/C++模块集成到Java应用程序中的基本知识。
- en: In the next chapter, we will see how to create a fully native application, which
    completely gets rid of JNI.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看到如何创建一个完全原生的应用程序，它完全摆脱了JNI。
