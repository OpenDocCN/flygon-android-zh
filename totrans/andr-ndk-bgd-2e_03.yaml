- en: Chapter 3. Interfacing Java and C/C++ with JNI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Android is inseparable from Java. Its kernel and core libraries are native,
    but the Android application framework is almost entirely written in Java or at
    least wrapped inside a thin layer of Java. Do not expect to build your Android
    GUI directly in C/C++! Most APIs are available only from Java. At best, we can
    hide it under the cover... Thus, native C/C++ code on Android would be nonsense
    if it was not possible to tie Java and C/C++ together.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This role is devoted to the Java Native Interface API. JNI is a standardized
    specification allowing Java to call native code and native code to call Java back.
    It is a two-way bridge between the Java and native side; the only way to inject
    the power of C/C++ into your Java application.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Thanks to JNI, one can call C/C++ functions from Java like any Java method,
    passing Java primitives or objects as parameters and receiving them as result
    of native calls. In turn, native code can access, inspect, modify, and call Java
    objects or raise exceptions with a reflection-like API. JNI is a subtle framework
    which requires care as any misuse can result in a dramatic ending…*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we will implement a basic key/value store to handle various
    data types. A simple Java GUI will allow defining an *entry* composed of a key
    (a character string), a type (an integer, a string, and so on), and a value related
    to the selected type. Entries are retrieved, inserted, or updated (remove will
    not be supported) inside a simple fixed size array of entries, which will reside
    on the native side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this project, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a native JNI library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert Java Strings in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass Java primitives to native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle Java object references in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage Java Arrays in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise and check Java exceptions in native code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able perform native calls with any
    Java type and use exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: JNI is a very technical framework that requires care, as any misuse can result
    in a dramatic ending. This chapter does not pretend to cover it exhaustively but
    rather focuses on the essential knowledge to bridge the gap between Java and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a native JNI library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before accessing their native methods, native libraries must be loaded through
    a Java call to `System.loadLibrary()`. JNI provides a hook, `JNI_OnLoad()`, to
    plug your own initialization code. Let's override it to initialize our native
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part4`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – defining a simple GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Java Graphical User Interface for our `Store` and bind it to
    the native store structure that we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewrite the `res/fragment_layout.xml` layout to define the graphical interface
    as follows. It defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **Key** `TextView` label and `EditText` to enter the key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Value** `TextView` label and `EditText` to enter the value matching the
    key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Type** `TextView` label and `Spinner` to define the type of the value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Get Value** and a **Set Value** `Button` to retrieve and change a value
    in the store
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The end result should look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – defining a simple GUI](img/9645_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Create a new class in `StoreType.java` with an empty enumeration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The GUI and native store need to be bound together. This is the role undertaken
    by the `StoreActivity` class. To do this, when `PlaceholderFragment` is created
    in `onCreateView()`, initialize all the GUI components defined earlier in the
    layout file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Spinner` content is bound to the `StoreType` enum. Use `ArrayAdapter` to bind
    together the `Spinner` and `enum` values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **Get Value** and **Set Value** buttons trigger the private methods `onGetValue()`
    and `onSetValue()`, which respectively pull data from and push data to the store.
    Use `OnClickListener` to bind buttons and methods together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `PlaceholderFragment`, define the `onGetValue()`method, which will retrieve
    entries from the store according to `StoreType` selected in the GUI. Leave the
    switch empty as it will not handle any kind of entries for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, still in `PlaceholderFragment`, define the `onSetValue()`method in `StoreActivity`
    to insert or update entries in the store. If the value format is incorrect, a
    message is displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, a little helper method `displayMessage()` in `PlaceholderFragment`
    will help warn the user when a problem occurs. It displays a simple Android Toast
    message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a basic Graphical User Interface in Java with a few visual components
    from the Android framework. As you can see, there is nothing specific to the NDK
    here. The moral of the story is that native code can be integrated with any existing
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we still have some work to do to make our native code perform some
    useful things for the Java application. Let's now switch to the native side.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initializing the native store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create and initialize all the structures we will use for the next
    section of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `jni/Store.h` file, which defines store data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `StoreType` enumeration will reflect the corresponding Java enumeration.
    Leave it empty for now.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StoreValue` union will contain any of the possible store values. Leave
    it empty for now too.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StoreEntry` structure contains one piece of data in the store. It is composed
    of a key (a raw C string made from `char*`), a type (`StoreType`), and a value
    (`StoreValue`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we will see how to set up and use C++ STL strings in [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Store` is the main structure that defines a fixed size array of entries and
    a length (that is, the number of allocated entries):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Include guards (that is, `#ifndef`, `#define`, and `#endif`), which ensure that
    a header file is included only once during compilation, and can be replaced by
    the non-standard (but widely supported) preprocessor instruction, `#pragma once`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `jni/com_packtpub_Store.cpp`, implement the `JNI_OnLoad()` initialization
    hook. Inside, initialize the unique instance of the `Store` data structure store
    into a static variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the native `store getCount()` method accordingly to reflect the store
    allocated entry count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We built the foundation of our store project with a simple GUI and a native
    in-memory data array. The containing native library is loaded with either a call
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.load()`, which takes the library full path in parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.loadLibrary()`, which requires only the library name without the path,
    prefix (that is, `lib`), or extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The native code initialization occurs in the `JNI_OnLoad()` hook, which is called
    only once during the lifetime of the native code. It is a perfect place to initialize
    and cache global variables. JNI elements (classes, methods, fields, and so on)
    are also often cached in `JNI_OnLoad()` to improve the performance. We will see
    more about this throughout this chapter and the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the pendent call `JNI_OnUnload()` defined in the JNI specification
    is almost useless in Android since there is no way to guarantee that a library
    is unloaded before process termination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JNI_OnLoad()` signature is systematically defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What makes `JNI_OnLoad()` so useful is its `JavaVM` parameter. From it, you
    can retrieve the **JNIEnv interface pointer** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `JNI_OnLoad()` definition in a JNI library is optional. However, if omitted,
    you may notice that a warning **No JNI_OnLoad found in <mylib>.so** is displayed
    in the **Logcat** when you start your application. This has absolutely no consequence
    and can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '`JNIEnv` is the main entry point for all JNI calls, which explains why it is
    passed to all native methods. It provides a set of methods to access Java primitives
    and arrays from native code. It is complemented with a reflection-like API to
    give full access to Java objects from native code. We are going to discover its
    features in more detail throughout this chapter and the next one.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `JNIEnv` interface pointer is thread-specific. You must not share it between
    threads! Use it only on the thread it was retrieved from. Only a JavaVM element
    is thread-safe and can be shared among threads.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Java strings in native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first kind of entry we will handle is strings. Strings, which are represented
    as (almost) classic objects in Java, can be manipulated on the native side and
    translated to native strings, that is, raw character arrays, thanks to JNI. Strings
    are a first-class citizen despite their complexity inherent to their heterogeneous
    representations.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will send Java strings to the native side and translate them
    to their native counterpart. We will also convert them back to a Java string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part5`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling strings in the native store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s handle String values in our store:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `StoreType.java` and specify the new String type our store handles in
    the enumeration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `StoreActivity.java`, retrieve string entries from the native `Store` in
    the `onGetValue()` method. Do it according to the type `StoreType` currently selected
    in the GUI (even if there is only one possible type for now):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert or update string entries in the store in the `onSetValue()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `jni/Store.h`, include a new `header jni.h` to access the JNI API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, integrate strings into the native `StoreType` enumeration and the `StoreValue`
    union:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Terminate by declaring utility methods to check, create, find, and destroy
    entries. `JNIEnv` and `jstring` are JNI types defined in the `jni.h` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file `jni/Store.cpp` to implement all these utility methods.First,
    `isEntryValid()` simply checks whether an entry is allocated and has the expected
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `findEntry()` method compares the key passed as a parameter with every key
    in the store until a match is found. Instead of working with classic native strings
    (that is, a `char*`), it receives a `jstring` parameter, which is the direct representation
    of a Java `String` on the native side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To recover a native string from a Java `String`, use `GetStringUTFChars()`
    from the JNI API to get a temporary character buffer containing the converted
    Java string. Its content can then be manipulated using standard C routines. `GetStringUTFChars()`
    must be systematically coupled with a call to `ReleaseStringUTFChars()` to release
    the temporary buffer allocated in `GetStringUTFChars()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Java strings are stored in memory as UTF-16 strings. When their content is extracted
    in native code, the returned buffer is encoded in Modified UTF-8\. Modified UTF-8
    is compatible with standard C String functions, which usually works on string
    buffers composed of 8 bits per characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: JNI does not forgive any mistakes. If, for example, you pass `NULL` as the first
    parameter in `GetStringUTFChars()`, VM will abort immediately. In addition, Android
    JNI does not respect JNI specification perfectly. Although the JNI Specification
    indicates that `GetStringUTFChars()` might return `NULL` if the memory could not
    be allocated, Android VMs will simply abort in such cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement `allocateEntry()`, which either creates a new entry (that is, increments
    the store length and returns the last element) or returns an existing one if the
    key already exists (after releasing its previous value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the entry is a new one, convert its key to a native string that can be kept
    in the memory. Indeed, raw JNI objects live for the duration of a native method
    call and must not be kept outside its scope:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the last method `releaseEntryValue()`, which frees the memory allocated
    for a value if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah` as seen
    in the previous chapter. You should see two new methods `Java_com_packtpub_store_Store_getString()`
    and `Java_com_packtpub_store_Store_setString()` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `jni/com_packtpub_Store.cpp`, insert the `cstdlib` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the help of the previously generated JNI header, implement the native method
    `getString()`. This method looks for the key passed to the store and returns its
    corresponding string value. If any problem occurs, a default `NULL` value is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java strings are not real primitives. Types `jstring` and `char*` cannot be
    used interchangeably as we already saw. To create a Java `String` object from
    a native string, use `NewStringUTF()` from the JNI API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, implement the `setString()` method, which allocates an entry (that is,
    creates a new entry in the store or reuses an existing one if it has the same
    key) and stores the converted Java string value in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The string value is translated from a Java string directly to our own string
    buffer using the `GetStringUTFLength()` and `GetStringUTFRegion()` methods from
    the JNI API. This is an alternative to `GetStringUTFChars()` used earlier. Finally,
    we must not forget to append the `null` character, which is the standard for a
    raw C string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the `Android.mk` file to compile `Store.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the application. Try to save a few entries with different keys and values.
    Then try to get them back from the native store. We managed to pass and retrieve
    strings from Java to C/C++. These values are saved in a native memory as native
    strings. Entries can then be retrieved as Java strings from the store according
    to their key.
  prefs: []
  type: TYPE_NORMAL
- en: Java and C strings are completely different beasts. Java strings need a concrete
    conversion to native strings to allow processing of their content using standard
    C string routines. Indeed, `jstring` is not a representation of a classic `char*`
    array but of a reference to a Java `String` object, accessible from the Java code
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discovered two ways to convert Java strings to native strings in this part:'
  prefs: []
  type: TYPE_NORMAL
- en: By pre-allocating a memory buffer in which the converted Java string is copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By retrieving a converted Java string in a memory buffer managed by JNI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing either solution depends on how memory is handled by the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Native character encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI provides two kinds of methods to deal with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: The ones with UTF in their name that work with Modified UTF-8 strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ones without UTF in their name that work with UTF-16 encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modified UTF-8 and UTF-16 strings are two different character encodings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified UTF-8** is a slightly different flavor of UTF-8 specific to Java.
    This encoding can represent standard ASCII characters (each on one byte) or can
    grow up to 4 bytes to represent extended characters (Ararbic, Cyrilic, Greek,
    Hebrew, and so on). The difference between standard UTF-8 and Modified UTF-8 resides
    in the different representation of the `null` character, which simply does not
    exist in the latter encoding. In this way, such strings can be processed with
    a standard C routine for which the `null` character is used as an ending sentinel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UTF-16** is the real encoding employed for Java strings. Each character is
    represented with two bytes, hence the Java `char` size. As a consequence, it is
    more efficient to work with UTF-16 in native code rather than Modified UTF-8 since
    they do not require conversion. The drawback is that classic C string routines
    will not work with them since they are not `null` terminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character encoding is a complex subject for which you can find more information
    at [http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html](http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html)
    and in the Android documentation at [http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings](http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings).
  prefs: []
  type: TYPE_NORMAL
- en: JNI String API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI provides several methods to handle a Java string on the native side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetStringUTFLength()` computes the Modified UTF-8 string length in *byte*
    (indeed UTF-8 strings have varying character sizes), whereas `GetStringLength()`
    computes UTF-16 string *number of characters* (not bytes, since UTF-16 characters
    are of a fixed size):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetStringUTFChars()` and `GetStringChars()` allocate a new memory buffer managed
    by JNI to store the result of Java to native (respectively Modified UTF-8 and
    UTF-16) string conversion. Use it when you want to convert an entire string without
    bothering with memory allocation. The last parameter `isCopy`, when not `null`,
    indicates whether the string has been internally copied by JNI or whether the
    returned buffer points to the real Java string memory. In Android, the returned
    `isCopy` value is generally `JNI_TRUE` for `GetStringUTFChars()` and `JNI_FALSE`
    for `GetStringChars()` (indeed the latter does not require encoding conversion):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although JNI specification indicates that `GetStringUTFChars()` can return NULL
    (which means that the operation has failed because, for example, memory could
    not be allocated), in practice, this check is useless because the Dalvik or ART
    VMs generally abort in this case. So simply avoid getting into that situation!
    You should still keep NULL-checks if your code aims at being portable to other
    Java Virtual Machines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ReleaseStringUTFChars()` and `ReleaseStringChars()` free the memory buffer
    allocated by `GetStringUTFChars()` and `GetStringChars()` when the client has
    finished processing it. These methods must always be called in pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetStringUTFRegion()` and `GetStringRegion()` retrieve all or only a region
    of the Java string. It works on a string buffer provided and managed by the client
    code. Use it when you want to manage memory allocation (for example, to reuse
    an existing memory buffer) or need to access small sections of a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetStringCritical()` and `ReleaseStringCritical()` are similar to `GetStringChars()`
    and `ReleaseStringChars()` but are only available for UTF-16 strings. According
    to the JNI specification, `GetStringCritical()` is more likely to return a direct
    pointer without making any copy. In exchange, the caller must not perform blocking
    or JNI calls and should not hold the string for a long time (like a critical section
    with threads). In practice, Android seems to behave similarly whether you use
    critical functions or not (but this may change):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the essential knowledge you need to know to deal with Java strings through
    JNI.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Java primitives to native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest kinds of elements we can handle with JNI are Java primitive types.
    Indeed, both the Java and native side use practically the same representation
    for this kind of data which, does not require any specific memory management.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will see how to pass integers to the native side and send them
    back to the Java side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part6`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling primitives in the native store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `StoreType.java`, add the newly managed integer type to the enumeration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Store.java` and define the new integer functionalities our native store
    provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `StoreActivity` class, update the `onGetValue()` method to retrieve
    integer entries from the store when they are selected in the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, insert or update integer entries in the store in the `onSetValue()` method.
    The entry data needs to be parsed before being passed to the native side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/Store.h`, append the integer type in the native `StoreType` enumeration
    and the `StoreValue` union:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. Two new
    methods `Java_com_packtpub_store_Store_getInteger()` and `Java_com_packtpub_store_Store_getInteger()`
    should appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `jni/com_packtpub_Store.cpp`, implement `getInteger()` with the help of
    the generated JNI header. This method simply returns the integer value of an entry
    without doing any specific conversion other than an implicit cast from `int32_t`
    to `jint`. If any problem occurs, during retrieval, a default value is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second method `setInteger()` stores the given integer value in the allocated
    entry. Note how here too that the passed JNI integer can be reversely cast to
    a C/C++ integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the application. Try to save a few entries with different keys, types, and
    values. Then try to get them back from the native store. We have this time managed
    to pass and retrieve integer primitives from Java to C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Integer primitives wear several dresses during native calls; first, `int` in
    Java code, then `jint` during transfer from/to Java code, and finally, `int` or
    `int32_t` in native code. Obviously, we could have kept the JNI representation
    `jint` in native code if we wanted to, since all of these types are simply equivalent.
    In other words, `jint` is simply an alias.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `int32_t` type is `typedef` introduced by the C99 standard library with
    the aim at more portability. The difference with the standard `int` type is that
    its size-in-bytes is fixed for all compilers and platforms. More numeric types
    are defined in `stdint.h` (in C) or `cstdint` (in C++).
  prefs: []
  type: TYPE_NORMAL
- en: 'All primitive types have their proper alias in JNI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Java type | JNI type | C type | Stdint C type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `Jboolean` | `unsigned char` | `uint8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `Jbyte` | `signed char` | `int8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `Jchar` | `unsigned short` | `uint16_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `Jdouble` | `double` | `N/A` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `jfloat` | `float` | `N/A` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `jint` | `Int` | `int32_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `jlong` | `long long` | `int64_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `jshort` | `Short` | `int16_t` |'
  prefs: []
  type: TYPE_TB
- en: You can use them exactly the same way we used integers in this part. More information
    about primitive types in JNI can be found at [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html)
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – passing and returning other primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current store deals only with integers and strings. Based on this model,
    try to implement store methods for other primitive types: `boolean`, `byte`, `char`,
    `double`, `float`, `long`, and `short`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part6_Full`.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Java objects from native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know from the previous section that a string is represented in JNI as `jstring`,
    which is in fact a Java object, which means that it is possible to exchange any
    Java object through JNI! However, because native code cannot understand or access
    Java directly, all Java objects have the same representation, `jobject`.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will focus on how to save an object on the native side and
    how to send it back to Java. As an example, we will work with a custom object
    `Color`, although any other type of object would work too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part7`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving references to Objects in native Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Java class `com.packtpub.store.Color` encapsulating an integer
    representation of a color. This integer is parsed from `String` containing HTML
    code (for example, `#FF0000`) thanks to the `android.graphics.Color` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `StoreType.java`, append the new Color data type to the enumeration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Store` class, append two new native methods to retrieve and save a
    `Color` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `StoreActivity.java` and update methods `onGetValue()` and `onSetValue()`
    to parse and display `Color` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/Store.h`, append the new color type to the `StoreType` enumeration
    and add a new member to the `StoreValue` union. But what type should you use,
    `Color` is an object known only from Java? In JNI, all java objects have the same
    type; `jobject`, an (indirect) object reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Regenerate the JNI header file `jni/com_packtpub_Store.h` with `javah`. You
    should see two new methods `Java_com_packtpub_store_Store_getColor()` and `Java_com_packtpub_store_Store_setColor()`
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `jni/com_packtpub_Store.cpp` and implement the two freshly generated methods
    `getColor()` and `setColor()`. The first one simply returns the Java Color object
    kept in the store entry as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The real subtleties are introduced in the second method `setColor()`. Indeed,
    at first sight, simply saving the `jobject` value in the store entry would seem
    sufficient. However, this assumption is wrong. Objects passed in parameters or
    created inside a JNI method are Local references. Local references cannot be kept
    in native code outside of the native method scope (such as for strings).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To be allowed to keep a Java object reference in native code after native method
    returns, they must be turned into Global references in order to inform the Dalvik
    VM that they must not be garbage collected. To do so, the JNI API provides the
    `NewGlobalRef()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Store.cpp`, modify `releaseEntryValue()` to delete the global reference
    when the entry is replaced by a new one. This is done with the `DeleteGlobalRef()`
    method, which is the counterpart of `NewGlobalRef()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the application. Enter and save a color value such as **#FF0000** or **red**,
    which is a predefined value allowed by the Android color parser. Get the entry
    back from the store. We managed to reference a Java object on the native side!
    Java objects are not and cannot be converted to C++ objects. Both are inherently
    different. Thus, to keep Java objects on the native side, we must keep references
    to them using the JNI API.
  prefs: []
  type: TYPE_NORMAL
- en: All objects coming from Java are represented by `jobject`, even `jstring` (which
    is in fact a `typedef` over `jobject` internally). A `jobject` is just a dumb
    "pointer" without any smart garbage collection mechanism (after all, we want to
    get rid of Java, at least partially). It does not give you a direct reference
    to the Java object memory but rather an indirect one. Indeed, Java objects do
    not have a fixed location in memory on the opposite to C++ objects. They may be
    moved during their lifetime. Regardless, it would be a bad idea to mess with a
    Java object representation in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Local references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Native calls have a scope limited to a method, which means that as soon as a
    native method ends, the VM becomes in charge again. The JNI specification uses
    this fact to its advantage in order to keep object references local to method
    boundaries. This means that `jobject` can only be used safely inside the method
    it was given to. Once native method returns, the Dalvik VM has no way to know
    if native code still holds object references and can decide to collect them at
    any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'These kinds of references are called **Local** references. They are automatically
    freed (the reference, not the object although the garbage collector might too)
    when native method returns to allow proper garbage collection later in the Java
    code. For example, the following piece of code should be strictly prohibited.
    Keeping such a reference outside the JNI method will eventually lead to an undefined
    behavior (a memory corruption, a crash, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects are passed to native methods as Local references. Every `jobject` returned
    by JNI functions (except `NewGlobalRef()`) is a Local reference. Just remember
    that everything is a Local reference by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'JNI provides several methods for managing Local references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewLocalRef()` to create one explicitly (from a Global references, for example),
    although this is rarely needed in practice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DeleteLocalRef()` to delete one when it is no longer needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Local references cannot be used outside the method scope and cannot be shared
    between threads, even during a single native call!
  prefs: []
  type: TYPE_NORMAL
- en: You are not required to delete Local references explicitly. However, according
    to the JNI specification, a JVM is only required to store 16 Local references
    at the same time and may refuse to create more (this is implementation-specific).
    It is thus good practice to release unused Local references as soon as possible,
    especially when working with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, JNI provides a few more methods to help working with Local references.
  prefs: []
  type: TYPE_NORMAL
- en: '`EnsureLocalCapacity()` informs the VM that it needs more Local references.
    This method return `-1` and throws a Java `OutOfMemoryError` when it cannot guarantee
    the requested capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PushLocalFrame()` and `PopLocalFrame()` offer a second way to allocate more
    Local references. It can be understood as a way to batch Local slot allocation
    and Local references deletion. This method also returns `-1` and throws a Java
    `OutOfMemoryError` when it cannot guarantee the requested capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Until Android 4.0 Ice Cream Sandwich, Local references were actually direct
    pointers, which means they could be kept beyond their natural scope and still
    be working. This is not the case anymore and such buggy code must be avoided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Global references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to use an object reference outside the method scope or keep it for
    a long period of time, references must be made **Global**. Global references also
    allow sharing objects between threads, which is not the case with Local references.
  prefs: []
  type: TYPE_NORMAL
- en: 'JNI provides two methods for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewGlobalRef()` to create Global references preventing garbage collection
    of the pointed object and allowing it to be shared between threads. It is possible
    for two references for the same object to be different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DeleteGlobalRef()` to delete Global references when they are no longer needed.
    Without it, the Dalvik VM would consider that objects are still referenced and
    would never collect them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IsSameObject()` to compare two object references, instead of using `==`, which
    is not a correct way to compare references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never forget to pair `New<Reference Type>Ref()` with `Delete<Reference Type>Ref()`.
    Failure to do so results in a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: Weak references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weak references are the last kind of reference available in JNI. They are similar
    to Global references in that they can be kept between JNI calls and shared between
    threads. However, unlike Global references, they do not prevent garbage collection.
    Thus, this kind of reference must be used with care as it can become invalid at
    any moment, unless you create a Global or Local reference from them before use
    each time you need it (and release it right after!).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When used appropriately, Weak references are useful to prevent memory leaks.
    If you have already done some Android development, you may already know one of
    the most common leaks: keeping a "hard" reference to an Activity from a background
    thread (typically, an `AsyncTask`) to notify the Activity later on when processing
    is over. Indeed, the Activity might be destroyed (because the user rotated the
    screen, for example) before a notification is sent. When using a Weak reference,
    the Activity can still be garbage collected and memory freed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewWeakGlobalRef()` and `DeleteWeakGlobalRef()` are the only methods necessary
    to create and delete a Weak reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: These methods return a `jweak` reference, which can be cast to the input object
    if needed (for example, if you create a reference to `jclass`, then the returned
    `jweak` can be cast into `jclass` or `jobject`).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should not use it directly but rather pass it to `NewGlobalRef()`
    or `NewLocalRef()` and use their result as usual. To ensure a local or Global
    reference issued from a Weak reference is valid, simply check whether the reference
    returned by `NewGlobalRef()` or `NewLocalRef()` is `NULL`. Once you are finished
    with the object, you can delete the Global or Local reference. Restart the process
    every time you work with that Weak object again. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a Weak reference itself points to an object, compare `jweak`
    to `NULL` using `IsSameObject()` (do not use `==`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Do not try to check the Weak reference state before creating a Global or Local
    reference because the pointed object might be collected concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to Android 2.2 Froyo, Weak references simply did not exist. Until Android
    4.0 Ice Cream Sandwich, they could not be used in JNI calls except `NewGlobalRef()`
    or `NewLocalRef()`. Although this is not an obligation anymore, using weak references
    directly in other JNI calls should be considered a bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the subject, have a look at the JNI specification at
    [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing Java arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one last type of data we have not talked about yet: **arrays**. Arrays
    have a specific place in Java as well as in JNI. They have their proper types
    and APIs, although Java arrays are also objects at their root.'
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will improve our store by letting users enter a set of values
    simultaneously in an entry. This set is going to be communicated to the native
    store as a Java array, which in turn is going to be stored as a classic C array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part8`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling Java arrays in native Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us handle operations on arrays, let's download a helper library, **Google
    Guava** (release 18.0 at the time of writing this book) available at [http://code.google.com/p/guava-libraries/](http://code.google.com/p/guava-libraries/).
    Guava offers many useful methods to deal with primitives and arrays, and perform
    "pseudo-functional" programming.
  prefs: []
  type: TYPE_NORMAL
- en: Copy `guava jar` in the project `libs` directory. Open the **Properties** project
    and go to **Java Build Path** | **Libraries**. Reference Guava jar by clicking
    on the **Add JARs...** button and validate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `StoreType.java` enumeration and add three new values: `IntegerArray`,
    `StringArray`, and `ColorArray`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Store.java` and add new methods to retrieve and save `int`, `String`,
    and `Color` arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Edit `StoreActivity.java` to connect native methods to the GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `onGetValue()` method so that it retrieves an array from the store
    depending on its type, concatenates its values with a semicolon separator (thanks
    to Guava joiners), and finally, displays them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Improve `onSetValue()` to convert a list of values into an array before transmitting
    it to `Store` (thanks to the Guava transformation feature):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a helper method `stringToList()` to help you convert a string into a
    list of the target type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/Store.h`, add the new array types to the `StoreType` enumeration. Also,
    declare the new fields `mIntegerArray`, `mStringArray`, and `mColorArray` in the
    `StoreValue` union. Store arrays are represented as raw C arrays (that is, a pointer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to remember the length of these arrays. Enter this information
    in a new field `mLength` in `StoreEntry`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/Store.cpp`, insert cases in `releaseEntryValue()` for the new arrays
    types. Indeed, allocated arrays have to be freed when the corresponding entry
    is released. As colors are Java objects, delete the Global references saved within
    each array item, else garbage collection will never happen (causing a memory leak):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Regenerate the JNI header `jni/com_packtpub_Store.h` with `Javah`. In `jni/com_packtpub_Store.cpp`,
    implement all these new methods. To do so, first add the `csdtint` include.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, cache the `String` and `Color` JNI Classes to be able to create, in the
    following steps, object arrays of these types. Classes are accessible by reflection
    from `JNIEnv` itself, and are retrievable from the `JavaVM` given to `JNI_OnLoad()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to check whether the found classes are null in case they cannot be
    loaded. If that happens, an exception is raised by the VM so that we can return
    immediately:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a `getIntegerArray()` implementation. A JNI array of integers is represented
    with the `jintArray` type. If an `int` is equivalent to `jint`, an `int*` array
    is absolutely not equivalent to `jintArray`. The first is a pointer to a memory
    buffer, whereas the second is a reference to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, to return `jintArray` here, instantiate a new Java integer array with
    the `NewIntArray()` JNI API method. Then, use `SetIntArrayRegion()` to copy the
    native `int` buffer content into `jintArray`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To save a Java array in native code, the inverse operation `GetIntArrayRegion()`
    exists. The only way to allocate a suitable memory buffer is to measure the array
    size with `GetArrayLength()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Java object arrays are different than Java primitive arrays. They are instantiated
    with a class type (here, the cached `String jclass`) because Java arrays are monotype.
    Object arrays themselves are represented with the `jobjectArray` type and can
    be created with the `NewObjectArray()` JNI API method.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike primitive arrays, it is not possible to work on all elements at the same
    time. Instead, objects are set one by one with `SetObjectArrayElement()`. Here,
    the native array is filled with `String` objects stored on the native side, which
    keeps Global references to them. So there is no need to delete or create any reference
    here except the reference to the newly allocated string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In `setStringArray()`, array elements are retrieved one by one with `GetObjectArrayElement()`.
    Returned references are local and should be made global to store them safely on
    the native side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Implement the same operations for colors, starting with `getColorArray()`. Since
    strings and colors are both objects on the Java side, the returned array can be
    created in the same way with `NewObjectArray()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place each `Color` reference saved inside the array using the JNI method `SetObjectArrayElement()`.
    Since colors have been stored on the native side as global Java references, no
    Local reference needs to be created or deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In `setColorArray()`, color elements are also retrieved one by one with `GetObjectArrayElement()`.
    Here, again, returned references are local and should be made global to store
    them safely on the native side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We transmitted Java arrays from the Java to the native side and vice versa.
    Java arrays are Java objects that can only be manipulated through a dedicated
    JNI API. They cannot be cast into native C/C++ arrays and are not usable the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to leverage the `JNI_OnLoad()` callback to cache JNI class descriptors.
    Class descriptors, of type `jclass` (which is also `jobject` behind the scenes),
    are equivalent to `Class<?>` in Java. They allow to define the type of array we
    want, a bit like the reflection API in Java. We will come back to this subject
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitives array types available are `jbooleanArray`, `jbyteArray`, `jcharArray`,
    `jdoubleArray`, `jfloatArray`, `jlongArray`, and `jshortArray`. These types represent
    references to real Java arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'These arrays can be manipulated with several methods provided by JNI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`New<Primitive>Array()` to create a new Java array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetArrayLength()` retrieves the length of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Get<Primitive>ArrayElements()` retrieves a whole array into a memory buffer
    allocated by JNI. The last parameter `isCopy`, when not null, indicates whether
    an array has been internally copied by JNI or it has returned buffer points to
    the real Java string memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Release<Primitive>ArrayElements()` releases the memory buffer allocated by
    `Get<Primitive>ArrayElements()`. Always use both in pairs. The last parameter
    mode is related to the `isCopy` parameter and indicates the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If 0, then JNI should copy the modified array back into the initial Java array
    and tell JNI to release its temporary memory buffer. This is the most common flag.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `JNI_COMMIT`, then JNI should copy the modified array back into the initial
    array but without releasing the memory. That way, the client code can transmit
    the result back to Java while still pursuing its work on the memory buffer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `JNI_ABORT`, then JNI must discard any change made in the memory buffer and
    leave the Java array unchanged. This will not work correctly if the temporary
    native memory buffer is not a copy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`Get<Primitive>ArrayRegion()` retrieves all or part of an array into a memory
    buffer allocated by the client code. For example for integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Set<Primitive>ArrayRegion()` initializes all or part of a Java array from
    a native buffer managed by the client code. For example for integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Get<Primitive>ArrayCritical()` and `Release<Primitive>ArrayCritical()` are
    similar to `Get<Primitive>ArrayElements()` and `Release<Primitive>ArrayElements()`
    but are only available to provide a direct access to the target array (instead
    of a copy). In exchange, the caller must not perform blocking or JNI calls and
    should not hold the array for a long time (like a critical section with threads).
    Not that the same two methods are featured for all primitives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Have a go hero – handling other array types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the knowledge freshly acquired, you can implement store methods for other
    array types: `jbooleanArray`, `jbyteArray`, `jcharArray`, `jdoubleArray`, `jfloatArray`,
    `jlongArray`, and `jshortArray`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you can write the `setBooleanArray()` method for the `jbooleanArray`
    type using `GetBooleanArrayElements()` and `ReleaseBooleanArrayElements()` instead
    of `GetBooleanArrayRegion()`. The result should look like the following, with
    both methods called in a pair with `memcpy()` in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part8_Full`.
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object arrays are named `jobjectArray` in JNI and represent a reference to a
    Java Object array. Objects arrays are specific because unlike primitive arrays,
    each array element is a reference to an object. As a consequence, a new Global
    reference is automatically registered each time an object is inserted in the array.
    That way, when native calls end, references do not get garbage collected. Note
    that object arrays cannot be converted to "native" arrays like primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object arrays can be manipulated with several methods provided by JNI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewObjectArray()` creates a new object array instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetArrayLength()` retrieves the length of an array (same method as primitives):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetObjectArrayElement()` retrieves one single object reference from a Java
    array. The returned reference is Local:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SetObjectArrayElement()` puts one single object reference into a Java array.
    A Global reference is created implicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html)
    for a more exhaustive list of JNI functions.
  prefs: []
  type: TYPE_NORMAL
- en: Raising and checking Java exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling in the Store project is not really satisfying. If the requested
    key cannot be found or if the retrieved value type does not match the requested
    type, a default value is returned. Do not even try with a Color entry. We definitely
    need a way to indicate that an error occurred! And what better way to indicate
    an error than an exception?
  prefs: []
  type: TYPE_NORMAL
- en: JNI provides the necessary API to raise an exception at the JVM level. These
    exceptions are the ones you can then catch in Java. They have nothing in common,
    neither the syntax nor the flow, with the usual C++ exceptions you can find in
    other programs (we will see more about them in [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*).
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will see how to raise JNI exceptions from the native to the
    Java side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part9`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – raising & catching exceptions in native Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the Java exception `com.packtpub.exception.InvalidTypeException` of
    type `Exception` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat the operation for two other exceptions: `NotExistingKeyException` of
    type `Exception` and `StoreFullException` of type `RuntimeException`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Store.java` and declare thrown exceptions on `getInteger()` in class
    `Store` (`StoreFullException` is `RuntimeException` and does not need declaration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat the operation for all other getter prototypes (strings, colors, and so
    on).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These exceptions need to be caught. Catch `NotExistingKeyException` and `InvalidTypeException`
    in `onGetValue()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Catch `StoreFullException` in `onSetValue()` in case the entry cannot be inserted
    because the store capacity is exhausted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `jni/Store.h` created in previous parts and define three new helper methods
    to throw exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `jni/Store.cpp` file to throw `NotExistingKeyException` and `InvalidTypeException`
    when getting an inappropriate entry from the store. A good place to raise them
    is when checking an entry with `isEntryValid()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`StoreFullException` is obviously raised when a new entry is inserted. Modify
    `allocateEntry()` in the same file to check entry insertions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `throwNotExistingException()`. To throw a Java exception, the first
    task is to find the corresponding class (like with the Java reflection API). Since
    we can assume these exceptions will not be raised frequently, we can keep from
    caching class reference. Then, raise the exception with `ThrowNew()`. Once we
    no longer need the exception class reference, we can get rid of it with `DeleteLocalRef`():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the operation for the two other exceptions. The code is identical (even
    to throw a runtime exception) and only the class name changes.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the application and try to get an entry with a non-existing key. Repeat
    the operation with an entry, which exists in the store but with a different type
    than the one selected in the GUI. In both cases, there is an error message. Try
    to save more than 16 references in the store and you will get an error again.
    In each case, an exception has been raised on the native side and caught on the
    Java side.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions in native code is not a complex task, but it is not trivial
    either. An exception is instantiated with a class descriptor of type `jclass`.
    This class descriptor is required by JNI to instantiate the proper kind of exception.
    JNI exceptions are not declared on JNI method prototypes since they are not related
    to C++ exceptions (exceptions which cannot be declared in C anyway). This explains
    why we have not regenerated the JNI header to accommodate the changes in the `Store.java
    file`.
  prefs: []
  type: TYPE_NORMAL
- en: Executing code in Exception state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once an exception is raised, be really careful with the JNI call you make.
    Indeed, any subsequent call fails until either of the following events occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The method is returned and an exception is propagated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The exception is cleared. Clearing an exception means that the exception is
    handled and thus not propagated to Java. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Only a few JNI methods are still safe to call after an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DeleteGlobalRef` | `PopLocalFrame` |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteLocalRef` | `PushLocalFrame` |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteWeakGlobalRef` | `Release<Primitive>ArrayElements` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionCheck` | `ReleasePrimitiveArrayCritical` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionClear` | `ReleaseStringChars` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionDescribe` | `ReleaseStringCritical` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionOccurred` | `ReleaseStringUTFChars` |'
  prefs: []
  type: TYPE_TB
- en: '| `MonitorExit` |   |'
  prefs: []
  type: TYPE_TB
- en: Do not try to call any other JNI method. Native code should clean its resources
    and give control back to Java as soon as possible (or handle the exception itself).
    Indeed, JNI exceptions have nothing in common with C++ exceptions. Their execution
    flow is completely different. When a Java exception is raised from native code,
    the latter can still pursue its processing. However, as soon as native call returns
    hand back to the Java VM, the latter propagates the exception as usual. In other
    words, JNI exceptions raised from native code affect Java code only (and JNI calls
    others then the one listed previously).
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI offers several methods to manage exceptions among which:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ThrowNew()` to raise the exception itself, allocating a new instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Throw()` to raise an exception that has already been allocated (for example,
    to rethrow):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ExceptionCheck()` to check whether an exception is pending, whoever raised
    it (native code or a Java callback). A simple `jboolean` is returned, which makes
    it appropriate for simple checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ExceptionOccurred()` to retrieve a `jthrowable` reference to the raised exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ExceptionDescribe()` is equivalent to `printStackTrace()` in Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An exception can be marked as caught on the native side with `ExceptionClear()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is essential to learn how to use these methods to write robust code, especially
    when calling back Java from native code. We will learn more about this subject
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to make Java communicate with C/C++. Android is
    now almost bilingual! Java can call C/C++ code with any type of data or object.
  prefs: []
  type: TYPE_NORMAL
- en: We first initialized a native JNI library using the `JNI_OnLoad` hook. Then,
    we converted Java Strings inside native code and saw the difference between Modified
    UTF-8 and UTF-16 character encoding. We also passed Java primitives to native
    code. Each of these primitives has their C/C++ equivalent type they can be cast
    to.
  prefs: []
  type: TYPE_NORMAL
- en: We also handled Java object references in native code using Global references
    and learned the difference between these and Local references. The first must
    be carefully deleted to ensure proper garbage collection, while the latter has
    native method scope and must be managed with care as their number is limited by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to manage Java arrays in native code so that we could
    access their content as native arrays. Arrays may or may not be copied by the
    VM when manipulated in native code. This performance penalty has to be taken into
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we raised and checked Java exceptions in native code. We saw that they
    have a different flows from the standard C++ exceptions. When an exception occurs,
    only a few cleaning JNI methods are safe to call. JNI exceptions are JVM-level
    exceptions, which means their flow is completely different from standard C++ exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is still more to come. Any Java object, method, or field can
    be called or retrieved by native code. Let's see how to call Java from C/C++ code
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
