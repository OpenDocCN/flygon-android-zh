- en: Chapter 5. Getting Around – Pathfinding and AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about camera and lighting effects. We added
    skybox, lights, and shadows to our Tank Battle game. We created lightmaps to make
    our scene dynamic. We took a look at cookies by giving our tank headlights. We
    also took a look at projectors by creating a blob shadow for the tank. A turbo
    boost was also created for the tank. By adjusting the viewing angle of the camera,
    we were able to make the tank look as if it was going much faster than it really
    was. When we finished the chapter, we had a dynamic and exciting-looking scene.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about the enemy. No longer will the player be able to just
    sit in one place to gather points. We will be adding an enemy tank to the game.
    By using Unity's NavMesh system, the tanks will be able to do pathfinding and
    chase the player. Once the player is found, the tanks will shoot and reduce the
    player's score.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NavMeshAgent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pathfinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chase and attack AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be adding modifications to the Tank Battle game from [Chapter 4](ch04.html
    "Chapter 4. Setting the Stage – Camera Effects and Lighting"), *Setting the Stage
    – Camera Effects and Lighting*, so load it up and we can begin.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AI and pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AI** is, as you might have guessed, **Artificial Intelligence**. In the broadest
    sense, this is anything an inanimate object might do to appear to be making decisions.
    You are probably most familiar with this concept from video games. When a character,
    not controlled by the player, selects a weapon to use and a target to use it on,
    this is AI.'
  prefs: []
  type: TYPE_NORMAL
- en: In its most complex form, AI attempts to mimic full human intelligence and learning.
    However, there is still far too much happening incredibly fast for this to truly
    succeed. Video games do not need to reach this far. We are primarily concerned
    with making our characters appear intelligent but still conquerable by our players.
    Usually, this means not allowing characters to act on more information than what
    a real player might have. Adjusting how much information characters have and can
    act on is a good way to adjust the level of difficulty in a game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pathfinding** is a subset of AI. We use it all the time, though you have
    probably never realized it. Pathfinding is, as the word suggests, the act of finding
    a path. Every time you need to find your way between any two points, you are doing
    pathfinding. As far as our characters are concerned, the simplest form of pathfinding
    is to follow a straight line to the goal point. Obviously, this method works best
    on an open plain, but tends to fail when there are any obstacles in the way. Another
    method is to overlay the game with a grid. Using the grid, we can find a path
    that goes around any obstacles and reaches our target.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method to pathfinding, and perhaps the one most often chosen,
    makes use of a special navigation mesh, or NavMesh. This is just a special model
    that is never seen by the player but covers all of the area that a computer character
    can move around in. The player is then navigated in a way that is similar to the
    grid; the difference is that the triangles of the mesh are used rather than the
    squares of the grid. This is the method that we will be using in Unity. Unity
    provides a nice set of tools for creating the NavMesh and utilizing it.
  prefs: []
  type: TYPE_NORMAL
- en: The NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the navigation mesh in Unity is very simple. The process is similar
    to the one that we used for making lightmaps. We just mark some meshes to be used,
    adjust some settings in a special window, and hit a button. So, load up the Tank
    Battle game in Unity if you haven't already done so, and we can get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity can automatically generate a NavMesh from any meshes that exist in a
    scene. To do so, the mesh must first be marked as static, just as we did for lightmaps.
    However, we do not want or need to be able to navigate the roofs of our city,
    so we make use of a special list of settings to dictate what type of static each
    object will be. Let''s start with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the city from the **Hierarchy** window and click on the down arrow to
    the right of **Static** in the **Inspector** window:![The NavMesh](img/4691OT_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can take a look at the options available for static objects as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Nothing**: This option is used to quickly deselect all the other options.
    If all the other options are unchecked, this one will be checked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everything**: Using this option, you can quickly select all the other options.
    When all of them are checked, this one will also be checked. The checkbox next
    to the **Static** label in the **Inspector** window performs the same function
    as checking and unchecking the **Everything** checkbox.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightmap Static**: This option needs to be checked when working with lightmaps
    in order for them to work. Any mesh that does not have this checked will not be
    lightmapped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occluder Static**: This is an option for working with occlusion. **Occlusion**
    is a method of runtime optimization that involves only rendering objects that
    can actually be seen, whether or not they are within the camera''s view space.
    An **occluder** is an object that will block other objects from being seen. It
    works in conjunction with the **Occludee Static** option. The best object choices
    for this option are large and solid.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching Static**: This is another option for runtime optimization. Batching
    is the act of grouping objects together before rendering them. It greatly increases
    the overall render speed of a game.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Static**: This is the option that we are primarily concerned with
    at this point. Any mesh that has this option checked will be used when calculating
    the NavMesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Occludee Static**: As mentioned a moment ago, this option works in conjunction
    with **Occluder Static** for the good of occlusion. An **occludee** is an object
    that will be obscured by other objects. When covered by an occluder, this object
    will not be drawn.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Off Mesh Link Generation**: This option also works with the NavMesh calculation.
    An off-mesh link is a connection between two parts of the NavMesh that aren''t
    physically connected, such as the roof and the street. Using a few settings in
    the **Navigation** window and this option, the links are automatically generated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection Probe Static**: The last option allows the object to be recorded
    by reflection probes. These record everything around them and generate a cubemap
    that can be used by reflective shaders.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to make the NavMesh work properly, we need to change the settings
    so that only the streets of the city can be navigated. When was the last time
    you saw a tank jump or fall from the roof of a building? So, we need to change
    the static options so that only the streets have **Navigation Static** checked.
    This can be done in one of the following two ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first way is to go through and uncheck the option for each object that we
    want changed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is to uncheck **Navigation Static** for the top-level object in the
    **Hierarchy** window, and when Unity asks whether we want to make the change for
    all children objects, reply with a yes. Then, go to just the objects that we want
    to navigate and recheck the option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, open the **Navigation** window by going to Unity's toolbar and click on
    **Window** and then click on **Navigation** at the bottom of the menu. The following
    screenshot displays the window where all the work of making the NavMesh happens:![The
    NavMesh](img/4691OT_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This window consists of three pages and a variety of settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an object is selected, the settings will appear on the **Object** page.
    The two checkboxes correspond directly with the **Static** options of the same
    name that we set a moment ago. The drop-down list in **Navigation Area** lets
    us group different parts of our NavMesh. These groups can be used to affect the
    pathfinding calculation. For example, a car can be set to only travel on the road
    area and the human can follow the sidewalk area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **Bake** page is the one that we are interested in; it is full of options
    to change how the NavMesh will be generated. It even includes a nice visual representation
    of the various settings at the top:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Agent Radius**: This should be set to the size of the thinnest character.
    It is used to keep characters from walking too close to walls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent Height**: This is the height of your characters. Using this, Unity
    can calculate and remove areas that are too low for them to pass. Anything lower
    than this value is deemed too small, so it should be set to the height of your
    shortest character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Slope**: Anything steeper than this value is ignored when calculating
    the NavMesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Height**: When making use of stairs, one must use this value. This is
    the maximum height of a stair that a character can step on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop Height**: This is the height from which characters can fall. With it,
    paths will include jumping off ledges, if it is faster to do so.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jump Distance**: Using this value, characters can jump across gaps in the
    NavMesh. This value represents the longest distance that can be jumped.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual Voxel Size / Voxel Size**: By checking the **Manual Voxel Size** box,
    you can adjust the value of **Voxel Size**. This is a level of detail for the
    NavMesh. Lower values will make it more accurate to the visible mesh, but it will
    take longer to calculate and require more memory to store.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Region Area**: If parts of the NavMesh are smaller than this value, they
    will not be used in the final NavMesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height Mesh**: With this option checked, the original height information
    is maintained in NavMesh. Unless you have a special need for it, this option should
    remain off. It takes the system longer to calculate and requires more memory to
    store.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third page, **Areas**, allows us to adjust the cost of movement for each
    of our defined areas. Essentially, how difficult is it to move though different
    parts of our game world? With cars, we could adjust the layers so that it is twice
    as costly for them to move through the field than to move along the road.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of the window, we have the following two buttons:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Clear**: This button removes the previously created NavMesh. After using
    this button, you will need to rebake the NavMesh before you can make use of pathfinding
    again.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bake**: This button starts the work and creates the NavMesh.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our city is very simple, so the default values will suit us well enough. Hit
    **Bake** and watch the progress bar in the bottom-right corner. Once it is done,
    a blue mesh will appear. This is the NavMesh and it represents all of the area
    that a character can move through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It may happen that your tanks will poke through the walls of the buildings a
    little as they move around. If they do, increase the **Agent Radius** in the **Navigation**
    window until they no longer do this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is one last thing we need to do. Our NavMesh is just right, but if you
    look closely, it goes through the fountain at the center of the city. It would
    be just wrong if enemy tanks start driving through the fountain. To fix this,
    start by selecting the mesh that forms the wall around the fountain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity's toolbar, click on **Component**, followed by **Navigation**, and
    finally **Nav Mesh Obstacle**. This simply adds a component that tells the navigation
    system to go around when searching for a path. Since we had already selected the
    wall, the new component will be sized to fit; we just need to select **Capsule**
    from the **Shape** drop-down list. You can see it represented as a wire cylinder
    in the **Scene** view.![The NavMesh](img/4691OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created the NavMesh. We made use of the **Navigation** window and the **Static**
    options to tell Unity which meshes to use when calculating the NavMesh. The Unity
    team put a lot of work into making this process quick and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, in [Chapter 3](ch03.html "Chapter 3. The Backbone of Any Game – Meshes,
    Materials, and Animations"), *The Backbone of Any Game – Meshes, Materials, and
    Animations*, when the challenge was to create obstacles for the player, you were
    encouraged to create additional meshes, such as tank traps and rubble. It would
    be a bad idea to let the enemy tanks drive through these as well. So, have a go
    at turning these into obstacles for the navigation system. This will be done just
    as with the fountain.
  prefs: []
  type: TYPE_NORMAL
- en: The NavMeshAgent component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be thinking that it is all well and good that we have a NavMesh,
    but there are no characters to navigate it. In this section, we will start the
    creation of our enemy tank. We will need to import and do a little setup for this
    second tank before we can do any AI type of programming. Using these steps, we
    can create it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Tanks_Type03.png` and `Tanks_Type03.blend` from the starting assets
    for the chapter and import them to the `Tanks` folder under the `Models` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity has finished importing, select the new tank in the **Project** window
    and take a look at it in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tank has no animations, so the **Animation Type** can be set to **None**
    and **Import Animation** can be unchecked from the **Rig** and **Animations**
    pages respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the tank from the **Project** window to the **Scene** window; any clear
    patch of street will work just fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For starters, rename the model in the **Scene** view to `EnemyTank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to change the parenting of the tank so that the turret can turn
    and the cannon will follow, just as we did for the player's tank. To do this,
    create an empty **GameObject** and rename it as `TurretPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position `TurretPivot` to be at the base of the turret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, drag and drop `TurretPivot` onto `EnemyTank` to
    make `EnemyTank` its parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, make another empty **GameObject** and rename it as `CannonPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `CannonPivot` GameObject must be made a child of `TurretPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, make the turret mesh a child of `TurretPivot` and
    the cannon mesh a child of `CannonPivot`. When Unity asks whether you are sure
    that you want to break the prefab connections, be sure to click on **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tank is a little large, so adjust the **Scale Factor** of the tank's **Import
    Settings** in the **Inspector** window to `0.6` to give us a tank that is similar
    to the size of the player's tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for the tank to navigate our new NavMesh, we need to add a **NavMeshAgent**
    component. First, select `EnemyTank` in the **Hierarchy** window, go to Unity's
    toolbar and navigate to **Component** | **Navigation** | **Nav Mesh Agent**. In
    the **Inspector** window, we can see the new component and the settings associated
    with it, as shown in the following screenshot:![The NavMeshAgent component](img/4691OT_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of these settings let us control how the NavMeshAgent interacts with our
    game world. Let''s take a look at what each of them does:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Radius**: This is simply how big the agent is. By working in conjunction
    with the value of **Radius** that we set in the **Navigation** window, this keeps
    the object from walking partly in the walls and into other agents.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: This setting affects the cylinder that appears in the editor, around
    the agent. It simply sets the height of the character and affects what overhangs
    they might be able to walk under.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base Offset**: This is the vertical offset of the colliders that is attached
    to the agent. It allows you to adjust what the **NavMeshAgent** component considers
    to be the bottom of your character.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: The **NavMeshAgent** component automatically moves the connected
    object when it has a path. This value dictates how fast to follow the path in
    units per second.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Speed**: This is the degrees per second that the agent can turn.
    A person would have a very high angular speed, while a car''s angular speed would
    be low.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceleration**: This is how many units per second in speed that the agent
    gains until it reaches its maximum capacity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopping Distance**: This is the distance from the target destination at
    which the agent will start to slow down and stop.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Braking**: With this box checked, the agent will stop as soon as it
    reaches the destination, rather than overshooting because of the irregular frame
    rate that tends to average to around 60 to 90 FPS for most games.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obstacle Avoidance Quality / Priority**: The quality is how much effort the
    agent will put in to find a smooth path around obstacles. A higher quality means
    more effort is made to find the path. The **Priority** option dictates who has
    the right of way. An agent with a high value will go around an agent with a low
    value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Traverse Off Mesh Link**: With this box checked, the agent will use
    the off-mesh links when pathfinding, such as jumping gaps and falling off ledges.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Repath**: If the path that was found is incomplete for any reason, this
    checkbox allows Unity to automatically try to find a new one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area Mask**: Remember the areas that were mentioned earlier when discussing
    the **Navigation** window? This is where we can set which areas the agent is able
    to traverse. Only the areas in this list that are checked will be used for pathfinding
    by the agent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the settings, let's use them. For the enemy tank, a value
    of `2.4` for the **Radius** and `4` for the **Height** will work well. You should
    be able to see another wire cylinder in the **Scene** window, which is our enemy
    tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is to turn `EnemyTank` into a prefab. Do this just as we
    did with the targets, by dragging it from the **Hierarchy** window and dropping
    it on the `Prefabs` folder in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created an enemy tank. We also learned about the settings for the **NavMeshAgent**
    component. However, if you try to play the game now, nothing will appear to happen.
    This is because the **NavMeshAgent** component is not being given a destination.
    We will resolve this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making the enemy chase the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next task is to make our enemy tank chase the player. We will need two scripts
    for this. The first will simply advertise the player's current position. The second
    will use that position and the **NavMeshAgent** component that we set up earlier
    to find a path to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing the player's location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a very short script, we can easily allow all our enemies to know the location
    of the player. A few short steps to create it are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new script in the `Scripts` folder of the **Project** window.
    Name it `PlayerPosition`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script will start with a single static variable. This variable will simply
    hold the current position of the player. As it is static, we will be able to easily
    access it from the rest of our scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We chose to use a static variable here for its simplicity and speed. Alternatively,
    we could have added a few extra steps to our enemy tank; it could have used the
    `FindWithTag` function when the game started to actually find the player tank
    and store it in a variable. Then, it could query that variable when it looks for
    the player's position. This is just one more way, among the multitude of ways,
    in which we could have gone about it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the next few lines of code, we make use of the `Start` function. This function
    is automatically called when a scene is first loaded. We use it so that the `position`
    variable can be filled and used as soon as the game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last segment of the code simply updates the `position` variable in every
    frame to the player's current position. We also do this in the `LateUpdate` function
    so that the update is done after the player has moved. The `LateUpdate` function
    is called at the end of every frame. With this, the player is able to move during
    the `Update` function and their position is updated later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing to do with this script is to add it to the player's tank. So,
    return to Unity and drag and drop the script from the **Project** window to the
    tank to add it as a component, just as we did it for all our other scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created the first script that is needed for our chase AI. This script
    simply updates a variable with the player's current position. We will make use
    of it in our next script where we will make the enemy tank move around.
  prefs: []
  type: TYPE_NORMAL
- en: Chasing the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next script will control our simple chase AI. Since we are making use of
    the **NavMesh** and **NavMeshAgent** components, we can leave nearly all the difficult
    portions of pathfinding to Unity. Let''s create the script by performing these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, create a new script. This time, name it `ChasePlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first line of this script holds a reference to the **NavMeshAgent** component
    that we set up earlier. We need access to this component in order to move the
    enemy tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last segment of the code first makes sure that we have our **NavMeshAgent**
    reference and then updates our goal destination. It uses the `PlayerPosition`
    script's variable that was set up earlier and the `SetDestination` function from
    the **NavMeshAgent**. Once we tell the function where to go, the **NavMeshAgent**
    component does all the hard work of getting us there. We update our goal destination
    in the `FixedUpdate` function because we do not need to update the destination
    in every frame. Updating this too often could cause a serious lag issue if there
    are a whole lot of enemies. The `FixedUpdate` function is called at regular intervals
    and is slower than the frame rate, so it is perfect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now need to add the script to our enemy tank. Select the prefab in the **Project**
    window and drag and drop the script in the **Inspector** panel, underneath the
    **NavMeshAgent** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to connect the reference, as we did previously. Drag the **NavMeshAgent**
    component to the **Agent** value in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the game now to try it out. Irrespective of the location where the enemy
    starts, it finds its way around all the buildings and makes it to the player's
    position. As you drive around, you can watch the enemy follow. However, the enemy
    tank could end up going through our tank and we could drive through it as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step to fix this is to add some colliders. Add a **Box Collider**
    component by using the **Physics** option in the **Component** menu for the turret,
    chassis, and each of the **TreadCase** objects. Neither the cannon nor the treads
    need colliders. The tread casings already cover the area of the treads, and the
    cannon is too small a target to be shot at properly.![Chasing the player](img/4691OT_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are making any of these changes in the **Scene** view, be sure to click
    on the **Apply** button in the **Inspector** window to update the root prefab
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last thing to change is the **Stopping Distance** property on the **NavMeshAgent**
    component. When the tanks engage, they move into range and start firing. They
    do not try to occupy the same space as the enemy, unless that enemy is small and
    squishy. By setting **Stopping Distance** to `10`, we will be able to replicate
    this behavior.![Chasing the player](img/4691OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we created a script that causes a **NavMeshAgent** component,
    in this case our enemy tank, to chase the player. We added colliders to stop us
    from driving through the enemy. In addition, we adjusted the value of **Stopping
    Distance** to give us a better tank behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Try adding a blob shadow to the enemy tank. This will give it a better visual
    sense of being grounded. You can just copy the one that was made for the player's
    tank.
  prefs: []
  type: TYPE_NORMAL
- en: Being attacked by the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What fun is a game without a little conflict; the nagging choice is whether
    to fight to the death or the doom of the cosmos? Every game needs some form of
    conflict to drive the player towards seeking a resolution. Our game will become
    a battle for points. Before, this just involved shooting some targets and getting
    some points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will make the enemy tank shoot at the player. Every time the enemy
    scores a hit, we will reduce the player''s score by a few points. The enemy will
    shoot in a similar manner to how the player fires, but we will use some basic
    AI to control the direction and firing speed and replace the player''s input controls.
    These steps will help us do it:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this off with a new script called `ShootAtPlayer`. Create it in
    the `Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with all our other scripts, we start this one out with two variables. The
    first variable will hold the last position of the enemy tank. The tank will not
    be shooting if it is in motion, so we need to store its last position to see whether
    it has moved. The second variable will be the maximum speed at which we can move
    and shoot. If the tank moves faster than this, it will not fire.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next two variables dictate how long it takes for the tank to ready a shot.
    It is unrealistic to be shooting at the player in every single frame. So, we use
    the first variable to adjust the length of time it takes to ready a shot and the
    second to store when the shot will be ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next variable contains the value of how fast the turret can rotate. While
    the tank is readying its shot, the turret will not be rotating to point at the
    player. That gives the player an opportunity to move out of the way. However,
    we need a speed variable to keep the turret from snapping to face the player after
    it has finished shooting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last three variables here hold references to other parts of the tank. The
    `turretPivot` variable is, of course, the pivot of the turret that we will rotate.
    The `muzzlePoint` variable will be used as the point from where our cannon will
    be fired. These will be used in the same manner as the ones for the player's tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the first function of the script, we will make use of the `Update` function.
    It starts by calling a function that will check to see whether it is possible
    to fire the cannon. If we can fire, we will perform some checks on our `readyTime`
    variable. If it is less than zero, we have not yet begun to ready our shot and
    call a function to do so. However, if it is less than the current time, we have
    finished the preparation and call the function to fire the cannon. If we are unable
    to fire, we first call a function to clear any preparations and then rotate the
    turret to face the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create our `CheckCanFire` function. The first part of the code
    checks to see whether we have moved too fast. First, we use `Vector3.Distance`
    to see how far we have moved since the last frame. By dividing the distance by
    the length of the frame, we are able to determine the speed with which we moved.
    Next, we update our `lastPosition` variable with our current position so that
    it is ready for the next frame. Finally, we compare the current speed with `maxSpeed`.
    If we moved too fast in this frame, we will be unable to fire and return a result
    as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the second half of the `CheckCanFire` function, we will check to see whether
    the turret is pointed at the player. First, we will find the direction to the
    player. By subtracting the second point''s location from that of any given point
    in space, we will get the vector value of the first point with respect to the
    second point. We will then flatten the direction by setting the `y` value to `0`.
    This is done because we do not want to be looking up or down at the player. Then,
    we will use `Vector3.Angle` to find the angle between the direction to the player
    and our turret''s forward direction. Finally, we will compare the angle to a low
    value to determine whether we are looking at the player and return the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `PrepareFire` function is quick and easy. It simply sets our `readyTime`
    variable to the time in the future when the tank would have prepared its shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Fire` function starts by making sure that we have a `muzzlePoint` reference
    to shoot from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function continues with the creation of a `RaycastHit` variable to store
    the result of our shot. We use `Physics.Raycast` and `SendMessage`, just as we
    did in the `FireControls` script, to shoot at anything and tell it that we hit
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Fire` function finishes by clearing the fire preparations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ClearFire` function is another quick function. It sets our `readyTime`
    variable to be less than zero, indicating that the tank is not preparing to fire:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function is `RotateTurret`. It begins by checking the `turretPivot`
    variable and cancels the function if the reference is missing. This is followed
    by the finding of a direction that points at the player, just as we did earlier.
    This direction is flattened by setting the `y` axis to `0`. Next, we will create
    the `step` variable to specify how much we can move this frame. We use `Vector3.RotateTowards`
    to find a vector that is closer to pointing at our target than the current forward
    direction. Finally, we use `Quaternion.LookRotation` to create a special rotation
    that points our turret in the new direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, by returning to Unity, create an empty **GameObject** and rename it as
    `MuzzlePoint`. Position `MuzzlePoint` like we did for the player, at the end of
    the cannon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make `MuzzlePoint` a child of the cannon and zero out any **Y** rotation that
    might be on it in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add our new `ShootAtPlayer` script to the enemy tank. Additionally, connect
    the references to the `TurretPivot` and `MuzzlePoint` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, for the enemy tank, hit the **Apply** button in the **Inspector** window
    to update the prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game now, you will see the enemy rotating to point at you, but
    our score will not decrease. This is because of two reasons. First, the tank is
    slightly floating. It doesn't matter where in the world you place it; when you
    play the game, the tank will slightly float. This is because of the way the `NavMeshAgent`
    component functions. The fix is simple; just set **BaseOffset** to `-0.3` in the
    **Inspector** window. This adjusts the system and puts the tank on the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second reason the score isn't changing is because the player is missing
    a function. To fix this, open the `ScoreCounter` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add the `RemovePoints` function. Given an amount, this function simply
    removes that many points from the player''s score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If your enemy tank is still unable to hit the player, it may be too big and
    is shooting over the player. Just tilt the tank's cannon down so that when it
    is shooting at the player, it also points towards the center of the player's tank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you take a look at the score counter in the top-right corner, the score will
    go down when the enemy gets close. Remember, it will not start dropping immediately
    because the enemy needs to stop moving, to ready the cannon, before they can shoot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Being attacked by the enemy](img/4691OT_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We gave the enemy the ability to attack the player. The new `ShootAtPlayer`
    script first checks to see whether the tank has slowed down and the cannon is
    trained on the player. If so, it will take regular shots at the player to reduce
    their score. The player is going to need to keep moving and aim at targets fast
    if they hope to be left with any points at the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are paying close attention to your score, it is difficult to tell
    when you are being shot at. We will be working with explosions in a future chapter,
    but even so, the player needs some feedback to tell what is going on. Most games
    will flash a red texture on the screen when the player is hit, whether or not
    there are any explosions. Try creating a simple texture and drawing it on the
    screen for half a second when the player is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Players tend to become frustrated quickly when faced with an enemy that they
    are unable to fight against. So, we are going to give our player the ability to
    damage and destroy the enemy tank. This will function in a similar manner to how
    the targets are shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to weaken our enemies is to give them some health that will
    reduce when they are shot. We can then destroy them when they run out of health.
    Let''s create a script with these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new script and naming it `Health`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script is rather short and starts with a single variable. This variable
    will keep track of the remaining health of the tank. By setting the default value
    to `3`, the tank will be able to survive three hits before being destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script also contains only one function, `Hit`. As in the case of the targets,
    this function is called by the `BroadcastMessage` function when the player shoots
    at it. The first line of the function reduces `health` by one point. The next
    line checks to see whether `health` is below zero. If it is, the tank is destroyed
    by calling the `Destroy` function and passing the `gameObject` variable to it.
    We also give the player a handful of points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It really is just that simple. Now, add the new script to the `EnemyTank` prefab
    in the **Project** window, and it will update all the enemy tanks that you currently
    have in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try this out: add a few extra enemy tanks to the scene and watch them follow
    you around and disappear when you shoot them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we gave the enemy tank a weakness, health. By creating a short script,
    the tank is able to track its health and detect when it has been shot. Once the
    tank runs out of health, it is removed from the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two targets to shoot at: the animated ones and the tank. However,
    they are both indicated with red slices. Try to make the ones that point at tanks
    to be of a different color. You will have to make a duplicate of the `IndicatorSlice`
    prefab and change the `IndicatorControl` script so that it can be told which type
    of slice to use when the `CreateSlice` and `NewSlice` functions are called.'
  prefs: []
  type: TYPE_NORMAL
- en: As a further challenge, the moment we give a creature some health, players want
    to be able to see how much damage they have done to it. There are two ways you
    could do this. First, you could put a cluster of cubes above the tank. Then, each
    time the tank loses health, you will have to delete one of the cubes. The second
    option is a little more difficult—drawing the bar in the GUI and changing its
    size based on the remaining health. To make the bar stay above the tank as the
    camera moves around, take a look at `Camera.WorldToScreenPoint` in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemy tanks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a limited number of enemies in the game at the beginning is not suitable
    for our game to have lasting fun. Therefore, we need to make some spawn points.
    As tanks are destroyed, these will make new tanks appear to keep the player on
    their toes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script that we will create in this section will keep our game world populated
    with all the enemies that our player might want to destroy. These steps will let
    us spawn the enemy tanks:'
  prefs: []
  type: TYPE_NORMAL
- en: We need another new script for this section. Once this is created, name it `SpawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script begins simply with a few variables. The first variable will hold
    a reference to our `EnemyTank` prefab. We need it so that we can spawn duplicates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second variable tracks the spawned tank. When it is destroyed, we will create
    a new one. Using this variable, we prevent the game from becoming overwhelmed
    with the enemy. There will only be as many tanks as spawn points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The third variable is for setting a distance between the spawning tanks and
    the player to prevent the spawning tanks from appearing on top of the player.
    If the player is outside this distance, a new tank can be spawned. If they are
    within, a new tank will not be spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first function that we will use is `FixedUpdate`. This will start by checking
    a function to see whether it needs to spawn a new tank. If it does, it will call
    the `SpawnTank` function to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the `CanSpawn` function. The first line of the function checks
    to see whether we already have a tank and returns `false` if we do. The second
    line uses `Vector3.Distance` to determine how far away the player currently is.
    The last line compares that distance with the minimum distance that the player
    needs to be before we can spawn anything, and it then returns the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function, `SpawnTank`, starts by checking to make sure that the `tankPrefab`
    reference has been connected. It can't continue if there is nothing to spawn.
    The second line uses the `Instantiate` function to create a duplicate of the prefab.
    In order to store it in our variable, we use `as GameObject` to make it the proper
    type. The last line moves the new tank to the spawn point's position as we don't
    want the tanks to appear at random locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We again chose to use the `Instantiate` and `Destroy` functions to handle the
    creation and deletion of our enemy tanks due to their simplicity and speed. Alternatively,
    we could have created a list of available enemies. Then, every time our player
    kills one, we could turn it off (instead of completely destroying it), just move
    an old one to where we need it (instead of creating a new one), reset the old
    one's stats, and turn it on. There will always be multiple ways to program everything,
    and this is just one alternative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return to Unity, create an empty **GameObject**, and rename it as `SpawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `SpawnPoint` script, which we just created, to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the spawn point selected, connect the prefab reference by dragging
    the `EnemyTank` prefab from the `Prefabs` folder and drop it on the appropriate
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, turn the `SpawnPoint` object into a prefab by dragging and dropping it
    from the **Hierarchy** window into the `Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, populate the city with the new points. Positioning one in each corner
    of the city will work well.![Spawning enemy tanks](img/4691OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created spawn points for the game. Each point will spawn a new tank.
    When a tank is destroyed, a new one will be created at the spawn point. Feel free
    to build the game and try it out on your device. This section and chapter are
    now complete and ready to be wrapped up.
  prefs: []
  type: TYPE_NORMAL
- en: Having one spawn point per tank is great, until we want many tanks or we wish
    them all to spawn from the same location. Your challenge here is to make a single
    spawn point to track multiple tanks. If any one of the tanks is destroyed, a new
    one should be created. You will definitely need an array to keep track of all
    the tanks. In addition, you could implement a delay for the spawn process as you
    won't want multiple tanks spawning on top of each other. This could cause them
    to suddenly jump as the **NavMeshAgent** component does its best to keep them
    from occupying the same space. In addition, the player might also think that they
    are only fighting one tank, when in fact there are several tanks in the same spot.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all the knowledge and tools that you need, as a further challenge,
    try to create other types of enemy tanks. You can experiment with size and speed.
    They can also have different strengths, or you could give more points when enemy
    tanks are destroyed. Perhaps, there is a tank that actually gives the player points
    when shooting at them. Play around with the game and have some fun with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about NavMeshes and pathfinding. We also did a little
    work with AI. This was perhaps one of the simplest types of AI, but chase behaviors
    are highly important to all types of games. To utilize all of this, we created
    an enemy tank. It chased the player and shot at them to reduce their score. To
    give the edge back to the player, we gave health to the enemy tanks. The player
    could then shoot the enemy tanks as well as the targets for points. We also created
    some spawn points so that every time a tank was destroyed, a new one would be
    created. In terms of general game play, our Tank Battle game is pretty much complete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a new game. In order to explore some of
    the special features of the mobile platform, we will create a Monkey Ball game.
    We will remove nearly all of the buttons from the screen in favor of new control
    methods. We will be turning the device's tilt sensors into our steering method.
    In addition, we will use the touchscreen to destroy enemies or collect bananas.
  prefs: []
  type: TYPE_NORMAL
