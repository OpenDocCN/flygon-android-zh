- en: Chapter 10. Writing Asteroids Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue putting together the material from previous chapters. We will
    implement an Asteroids game with 3D graphics, shadows, particles, and sounds using
    techniques and code fragments introduced in the previous chapters. First, we will
    extend the previous material with a few more ideas, and then, we will move on
    and code a complete gaming application. Let's start with an onscreen joystick.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an on-screen joystick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An on-screen joystick is based on multi-touch handling. Two structures contain
    descriptions of a single joystick button and an axis. The button is given an index
    and is specified by its color in the `FColour` field of the `sBitmapButton` structure.
    When a user taps the screen where the underlying pixel in the joystick mask has
    the color matching with one of the buttons, the `clScreenJoystick` class sets
    the pressed flag for the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `sBitmapAxis` structure represents a single stick of a joystick and contains
    two axes corresponding to vertical and horizontal directions. On the joystick
    mask bitmap, it is represented as a circular element centered at `FPosition` with
    the radius `FRadius`. The `FAxis1` and `FAxis2` indices specify which logical
    joystick axes are affected by this onscreen stick.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FColour` field is used to determine whether the user is touching this
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clScreenJoystick` class is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This bitmap contains a colored mask with buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Allocate button and axis state arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the state of the joystick buttons and axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether a button has been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current value of an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Button and axis setters are implemented in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to detect a button based on the color found in the joystick bitmap mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same logic applies to the axis detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently pushed buttons and active axes are stored inside these member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the value of an axis based on its center point and the touch point. The
    distance from the center point represents a value on a corresponding axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The multi-touch handler is implemented in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear all previous presses and axis states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Store the initial color of the button to track its movement later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the usage of the `clScreenJoystick` class, we modified the boids
    example from the previous chapter. The green box that denotes a target is controlled
    with the onscreen joystick.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our game look shinier, we add yet another component to our rendering
    engine: a particle system. Particles move similarly to boids from the previous
    chapter, but vastly outnumber them and are not supposed to participate in complex
    interactions. Since individual particles are transparent, we need to take care
    of the rendering order and render particles after all solid objects within the
    frame have been rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each particle is treated as a point-like object when speaking of dynamics and
    rendered as a screen-aligned quadrilateral. A single particle does not exist forever
    and its initial lifetime `FLifeTime` and current time-to-live `FTTL` are stored.
    The `sParticle` structure contains `FPosition`, `FVelocity`, and `FAcceleration`
    fields describing its kinematic and dynamic properties. In addition to the physical
    properties, the `FRGBA` field contains a color of the particle and the `FSize`
    field describes its visual size. Let''s put it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the simplicity of our implementation, we store particles as an **Array
    of Structures** (**AoS**) instead of **Structure of Arrays** (**SoA**). The SoA
    approach is much more cache friendly and faster. If you are interested in how
    to implement a CPU-based particle system more efficiently, refer to this series
    of blog posts: [http://www.bfilipek.com/2014/04/flexible-particle-system-start.html](http://www.bfilipek.com/2014/04/flexible-particle-system-start.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The private section of the `clParticleSystem` class contains a `clVertexAttribs`
    object with GPU-ready particle data, a container of `sParticle` instances, a material
    description for our rendering system, and the number of currently active particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor preallocates vertices for an initial number of particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A special material class name is specified. Our rendering system will be aware
    of this material and will use proper shaders to render the particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number of particles exceeds current capacity of the vertex array, grow
    it using the coefficient `1.2`. The optimal choice of growths coefficient here
    is subject to experiments and depends on emitters that are feeding the particle
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetMaxParticles()` method adjusts the size of the `FVertices` vertex array
    to accommodate at least `MaxParticles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a bunch of getter member functions to access private fields of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where everything happens. We will look into this method on the next
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetMaxParticles()` method may seem simple, but it actually contains some
    useful code besides the trivial resizing of a container. To render particles,
    we use the technique called billboarding. For each particle, we create a screen-aligned
    quad consisting of two triangles. Texture coordinates of the quad corners are
    fixed, and for each particle, we fill the `U` and `V` values in the `SetMaxParticles()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will resize the `FParticles` array and `FVertices` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop over the particles and assign six texture coordinate pairs to each vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We synchronize particle coordinates, lifetime, and colors between `FVertices`
    and `FParticles` fields every frame. The `UpdateParticles()` method calculates
    new positions and velocities for each particle, and then updates the individual
    components of the `FVertices` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the time-to-live of a particle is less than zero, we replace the particle
    with the last one in the array, so we can just efficiently pop the dead particle
    out of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Newtonian physics and explicit Euler integrator, just as we have done
    for boids in the previous chapter, we recalculate the new velocity and position
    for each particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The time-to-live, total lifetime, and size of a particle are packed together
    into a `vec3` variable so that they can be stored in a vertex array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep formulas simple, we normalize the lifetime of the particle and use
    it in our color calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the normalized time, we calculate the color of the current particle.
    The `GetParticleBrightness()` function is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since each particle is represented by two triangles, we assign the same values
    to six consequential elements in the vertex array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating each particle, we adjust the number of vertices to be rendered
    in the vertex array to match the number of the currently active particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetParticleBrightness()` function calculates a trapezoid-shaped function
    having a constant value of `1.0` for argument values from `0.1` to `0.9`. Visually,
    it means that at the beginning of the lifetime, particles fade in from zero to
    full visibility, then shine at a constant strength, and then linearly decay to
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have only defined the class holding the particle instances.
    To integrate these new objects into our rendering system, we have to define a
    new kind of scene graph node, the `clParticleSystemNode` node. Before we can do
    this, a few words should be told about how the particles are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce the `iParticleEmitter` interface, which declares a single pure
    virtual method, `EmitParticles()`, taking two parameters. The `DeltaTime` parameter
    is used to update the time counter and calculate new particle positions in the
    `PS` particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Fields of this class defines allowable ranges for each parameter of the particle.
    The limits for color, size, velocity, and lifetime are given by the variables
    with `Min` and `Max` postfixes. The `FEmissionRate` defines how many particles
    per second we are emitting and `FMaxParticles` gives the upper limit on the number
    of particles. The `FAccumulatedTime` field contains an approximate amount of time
    passed since the last particle system update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EmitParticles()` method is overridden in two subclasses. The first of
    these subclasses is `clParticleEmitter_Box`, which emits particles in an axis-aligned
    box region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop emits the required number of particles, one at a time. The
    position, velocity, color, time-to-live, and size are filled with uniform random
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the simplest emitters possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using particle systems in the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also need a decent-looking explosion effect for our game. Particles emission
    in a combustive manner is implemented in the `clParticleEmitter_Explosion` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the `FEmitted` fields to `false`. On the first invocation
    of `EmitParticles()`, this field is set to `true` and a fixed number of primary
    particles are emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The explosion effect adds a bunch of particles only once, but at each sequential
    `EmitParticles()` call secondary particles are created making trails, which follow
    the paths of primary particles. For each entity from the existing set of particles,
    an additional particle is created, so that the total number of particles is sustained
    within a budget set in the `FMaxParticles` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the explosion, this emitter will not work again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following loop creates a spray of particles with directions evenly distributed
    across a sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using two uniform random variables as angles, we calculate the uniform random
    direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each particle starts at the center of explosion and the velocity coincides
    with the random direction calculated in the preceding code multiplied by a random
    magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Time-to-live, color, and size fields are filled with uniform random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using particle systems inside a scene graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to declare and define the `clParticleSystemNode` class, which
    owns a `clParticleSystem` object, `clGeometryNode` with particle geometry, and
    a container of `iParticleEmitter` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following five methods provide access to the private particle emitters
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor instantiates a particle system and all the necessary scene
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a geometry node to store particles vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a material out of the particle system and apply it to the scene node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clParticleSystemNode::UpdateParticles()` method calls all the emitters,
    then invokes `clParticleSystem::UpdateParticles()` for `m_Particles`, and finally
    sends new particle vertex data to the rendering API using the `clGLVertexAray::CommitChanges()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendering of `clVertexAttribs` that contains particle attributes requires
    new shaders to be written. Since particles represent a new type of geometry, we
    extend our `clMaterialSystem` class so that it can handle the particle material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetShaderProgramForPass`() member function checks whether the material
    class is *Particle* and picks a shader program from a new set of particle shader
    programs. Otherwise, it falls back to the old `clMaterialSystem` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The only new field in this class is a map that holds the new compiled shader
    programs for each pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here goes the source code of all new shaders necessary to render particles.
    A vertex shader is shared between all rendering passes and does the billboarding;
    this orients particles to the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The same projected transform scale bias as for the default material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Particles should be oriented so that they always face the camera. Let''s construct
    a frame of reference where vectors `X` and `Y` are parallel to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the particle size stored inside the normal''s Z-component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use texture coordinates to calculate offsets from the center of the particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the vertex position using the model-view-projection matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass on all other varying variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Fragment shaders are more diverse and require a different one for ambient,
    shadow, and light passes to render particles properly. The following is the particle
    fragment shader for an ambient pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `v_Params` comes from the `clParticleSystem::UpdateParticles()`
    function where TTL, lifetime, and size are packed together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute transparency based on the distance to the particle center. This gives
    nice rounded particles without using any textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader for a light pass looks as follows. It just discards the
    fragment, particles do not react on light sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A shadow map generation pass can be handled with the following fragment shader.
    Create a rounded shadow for each particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The shadow grows for the first half of particle lifetime and shrinks to zero
    afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A demonstration of particles rendering can be found in the `1_Particles` example.
    Here is a screenshot showing the running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using particle systems inside a scene graph](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the beginning, we create an empty particle system node and pass it to the
    `GenerateExplosion()` function, which adds yet another explosion to the particle
    system. Here is how this is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The demo is intended to run on an Android device; do not spawn too many particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A palette for three different explosion types consists of blue, red, and green
    colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Just pick one tint randomly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and set up the emitter object. You are strongly encouraged to play with
    these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is invoked from the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Dice to decide whether we should add another explosion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Always add a new explosion if the particle system contains no active particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Try building this demo for Android and running it on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Asteroids game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have everything in place to deal with the actual game. Essentially,
    the game contains a lot of the previous examples stitched together to run in common
    and implement different aspects of the application. The glue that defines the
    game logic is in the class `clGameManager`, which is defined in `Game.cpp` and
    `Game.h`. The actual boid-like entities are implemented in `Actors.cpp` and `Actors.h`.
    Let''s start with the base class `iActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The major difference from all the previous examples is that there is no `Render()`
    method in this game framework. Instead, all entities should know how to attach
    to and detach from a scene graph. These methods are overridden in subclasses and
    vary between different types of actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Some code is shared between all subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'An asteroid game entity is an instance of the `clAsteroid` class, which is
    very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is almost trivial. Update the position and clamp it to the
    size of the game level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Asteroids always rotate around the `(1,1,1)` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Attachment to the scene burns down to loading of an `.obj` file with an appropriate
    3D model and setting up a material. A yellow one would be nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Detachment from the scene is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clRocket` class represents a rocket fired from the space ship. Everything
    is similar to the implementation of `clAsteroid` except the `Update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If a rocket leaves the level area, kill it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Explosions are implemented in the `clExplosion` class. The `clExplosion::AttachToScene()`
    method creates a particle system node with the emitter similar to the one in `GenerateExplosion()`.
    Nothing interesting there. However, the `Update()` method is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Particle system nodes require updating. Use a coefficient to make particles
    move slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Kill the explosion once all particles are gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, the `clSpaceShip` class represents a player-controllable
    entity. Again, the most interesting part is the `Update()` method, which handles
    the user controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Ask the game manager if any control keys were pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the ship warp between opposite sides of the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We do not want it to move very fast; here speed decay and clamping are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'A time counter is used to limit the rate of fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Scale and rotate the 3D model to match the desired size and orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the cumulative transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Fire` method does exactly what it appears to do. It launches a rocket
    and maintains the rate of fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Try changing the weapon cool down time. One second is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual rocket entity is added by the game manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Those are all the entities existing in the game. Let''s take a short glance
    at the `clGameManager` class, which rules them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the state of all objects and calculate collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the rendering technique to draw the game world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two functions to create new entities; they are used in `clSpaceShip`
    and `CheckCollisions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of high-level math functions to deal with positions of the entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Kill a game actor, which can be an asteroid, an explosion, or a rocket. The
    space ship lives forever in our game. The `Kill()` method does not remove the
    actor immediately. Instead, it adds the actor to a container, which is later handled
    in the `PerformExecution()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The name says it all. Play an audio file in a fire-and-forget fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The grand central dispatch of the gaming logic lays within the `GenerateTicks()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Update everything, check for collisions, and remove dead objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove stopped audio sources one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Collision checking is done with a naive `O(n^2)` algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If a rocket is close enough to an asteroid, destroy both and add a huge explosion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Executions are fast, but require a bit of C++ template magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the template code to handle heterogeneous entity containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: If you are a C++14 fan, you can definitely replace `const typename Container::value_type&`
    in the lambda parameter with `const auto&`, but our Visual Studio 2013 refused
    to compile the new code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever other functions are not mentioned here can be found in the `1_Asteroids`
    example. Build and run the code. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asteroids game](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we summed up many techniques shown in the book and implemented
    a portable game application using the Android NDK. The essence of our tinkering
    with all that C++ code is the possibility to run our game unchanged on a desktop
    machine. This approach gives great opportunities in debugging large C++ mobile
    applications and faster iteration times when integrating new content into these
    apps. Furthermore, professional mobile development is never focused on one platform.
    With development practices like these, you can write C++ code that runs on many
    mobile platforms, including Android and iOS.
  prefs: []
  type: TYPE_NORMAL
