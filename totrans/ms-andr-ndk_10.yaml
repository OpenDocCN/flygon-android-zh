- en: Chapter 10. Writing Asteroids Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 编写“小行星”游戏
- en: We will continue putting together the material from previous chapters. We will
    implement an Asteroids game with 3D graphics, shadows, particles, and sounds using
    techniques and code fragments introduced in the previous chapters. First, we will
    extend the previous material with a few more ideas, and then, we will move on
    and code a complete gaming application. Let's start with an onscreen joystick.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续整合之前章节的材料。我们将使用前几章介绍的技术和代码片段实现一个带有3D图形、阴影、粒子和声音的“小行星”游戏。首先，我们将在之前的内容中增加一些新的想法，然后继续编写一个完整的游戏应用程序。我们从屏幕操纵杆开始。
- en: Creating an on-screen joystick
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个屏幕上的操纵杆
- en: 'An on-screen joystick is based on multi-touch handling. Two structures contain
    descriptions of a single joystick button and an axis. The button is given an index
    and is specified by its color in the `FColour` field of the `sBitmapButton` structure.
    When a user taps the screen where the underlying pixel in the joystick mask has
    the color matching with one of the buttons, the `clScreenJoystick` class sets
    the pressed flag for the button:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的操纵杆基于多点触控处理。两个结构体包含了一个单一操纵杆按钮和轴的描述。按钮被赋予一个索引，并在`sBitmapButton`结构的`FColour`字段中通过其颜色指定。当用户在屏幕上点击，且操纵杆遮罩下方的像素颜色与其中一个按钮相匹配时，`clScreenJoystick`类将设置该按钮的按下标志：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sBitmapAxis` structure represents a single stick of a joystick and contains
    two axes corresponding to vertical and horizontal directions. On the joystick
    mask bitmap, it is represented as a circular element centered at `FPosition` with
    the radius `FRadius`. The `FAxis1` and `FAxis2` indices specify which logical
    joystick axes are affected by this onscreen stick.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`sBitmapAxis`结构体代表了一个游戏手柄的操纵杆，包含对应垂直和水平方向的两个轴。在游戏手柄的位图遮罩中，它以一个以`FPosition`为中心，半径为`FRadius`的圆形元素表示。`FAxis1`和`FAxis2`索引指定了哪些逻辑游戏手柄轴受到这个屏幕操纵杆的影响。'
- en: 'The `FColour` field is used to determine whether the user is touching this
    axis:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`FColour`字段用于确定用户是否触摸了这个轴：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `clScreenJoystick` class is declared as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`clScreenJoystick`类的声明如下：'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This bitmap contains a colored mask with buttons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位图包含了一个带有按钮的颜色遮罩：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Allocate button and axis state arrays:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分配按钮和轴状态数组：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Reset the state of the joystick buttons and axes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重置操纵杆按钮和轴的状态：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Check whether a button has been pressed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 检查按钮是否被按下：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get the current value of an axis:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 获取轴的当前值：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Button and axis setters are implemented in a similar way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮和轴的设置器以类似的方式实现：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Try to detect a button based on the color found in the joystick bitmap mask:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试根据游戏手柄位图遮罩中找到的颜色来检测一个按钮：
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same logic applies to the axis detection:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑也适用于轴的检测：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Currently pushed buttons and active axes are stored inside these member variables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当前按下的按钮和活动的轴存储在这些成员变量中：
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Read the value of an axis based on its center point and the touch point. The
    distance from the center point represents a value on a corresponding axis:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据轴的中心点和触摸点读取轴的值。从中心点出发的距离代表相应轴上的一个值：
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The multi-touch handler is implemented in the following way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多点触控处理程序以下列方式实现：
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Clear all previous presses and axis states:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 清除所有之前的按下和轴的状态：
- en: '[PRE14]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Store the initial color of the button to track its movement later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 存储按钮的初始颜色，以便稍后跟踪其移动：
- en: '[PRE15]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To demonstrate the usage of the `clScreenJoystick` class, we modified the boids
    example from the previous chapter. The green box that denotes a target is controlled
    with the onscreen joystick.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`clScreenJoystick`类的使用，我们修改了前一章中的boids示例。绿色的盒子表示的目标用屏幕操纵杆控制。
- en: Implementing the particle system
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现粒子系统
- en: 'To make our game look shinier, we add yet another component to our rendering
    engine: a particle system. Particles move similarly to boids from the previous
    chapter, but vastly outnumber them and are not supposed to participate in complex
    interactions. Since individual particles are transparent, we need to take care
    of the rendering order and render particles after all solid objects within the
    frame have been rendered.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的游戏看起来更加光彩照人，我们在渲染引擎中添加了另一个组件：粒子系统。粒子类似于前一章中的boids移动，但数量大大超过它们，并且不打算参与复杂的交互。由于单个粒子是透明的，我们需要注意渲染顺序，并在帧内所有固体对象渲染后渲染粒子。
- en: 'Each particle is treated as a point-like object when speaking of dynamics and
    rendered as a screen-aligned quadrilateral. A single particle does not exist forever
    and its initial lifetime `FLifeTime` and current time-to-live `FTTL` are stored.
    The `sParticle` structure contains `FPosition`, `FVelocity`, and `FAcceleration`
    fields describing its kinematic and dynamic properties. In addition to the physical
    properties, the `FRGBA` field contains a color of the particle and the `FSize`
    field describes its visual size. Let''s put it this way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论动力学时，每个粒子都被视为一个点状对象，并以屏幕对齐的四边形进行渲染。单个粒子并非永远存在，其初始生命周期`FLifeTime`和当前生存时间`FTTL`被存储。`sParticle`结构包含描述其运动和动力学属性的`FPosition`、`FVelocity`和`FAcceleration`字段。除了物理属性外，`FRGBA`字段包含粒子的颜色，而`FSize`字段描述了其视觉大小。我们可以这样说：
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the simplicity of our implementation, we store particles as an **Array
    of Structures** (**AoS**) instead of **Structure of Arrays** (**SoA**). The SoA
    approach is much more cache friendly and faster. If you are interested in how
    to implement a CPU-based particle system more efficiently, refer to this series
    of blog posts: [http://www.bfilipek.com/2014/04/flexible-particle-system-start.html](http://www.bfilipek.com/2014/04/flexible-particle-system-start.html).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的实现，我们以**结构数组**（**AoS**）而不是**数组结构**（**SoA**）的形式存储粒子。SoA方法对缓存更加友好且速度更快。如果你对如何更有效地实现基于CPU的粒子系统感兴趣，请参考以下系列博客文章：[http://www.bfilipek.com/2014/04/flexible-particle-system-start.html](http://www.bfilipek.com/2014/04/flexible-particle-system-start.html)。
- en: 'The private section of the `clParticleSystem` class contains a `clVertexAttribs`
    object with GPU-ready particle data, a container of `sParticle` instances, a material
    description for our rendering system, and the number of currently active particles:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`clParticleSystem`类的私有部分包含一个带有GPU就绪粒子数据的`clVertexAttribs`对象，一个`sParticle`实例的容器，一个用于我们渲染系统的材质描述，以及当前活动的粒子数量：'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The constructor preallocates vertices for an initial number of particles:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数为初始数量的粒子预分配顶点：
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A special material class name is specified. Our rendering system will be aware
    of this material and will use proper shaders to render the particle system:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了一个特殊的材质类名。我们的渲染系统将识别这种材质，并使用适当的着色器来渲染粒子系统：
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the number of particles exceeds current capacity of the vertex array, grow
    it using the coefficient `1.2`. The optimal choice of growths coefficient here
    is subject to experiments and depends on emitters that are feeding the particle
    system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子的数量超过了顶点数组的当前容量，使用系数`1.2`进行扩容。这里增长系数的最优选择取决于实验，并依赖于向粒子系统提供粒子的发射器：
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `SetMaxParticles()` method adjusts the size of the `FVertices` vertex array
    to accommodate at least `MaxParticles`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMaxParticles()`方法调整`FVertices`顶点数组的大小，以至少容纳`MaxParticles`：'
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need a bunch of getter member functions to access private fields of
    the class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一系列的获取成员函数来访问类的私有字段：
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is where everything happens. We will look into this method on the next
    page:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有操作发生的地方。我们将在下一页中探讨这个方法：
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `SetMaxParticles()` method may seem simple, but it actually contains some
    useful code besides the trivial resizing of a container. To render particles,
    we use the technique called billboarding. For each particle, we create a screen-aligned
    quad consisting of two triangles. Texture coordinates of the quad corners are
    fixed, and for each particle, we fill the `U` and `V` values in the `SetMaxParticles()`
    method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMaxParticles()`方法可能看起来很简单，但实际上除了容器大小的调整之外，还包含一些有用的代码。为了渲染粒子，我们使用了称为billboarding的技术。对于每个粒子，我们创建一个由两个三角形组成的屏幕对齐的四边形。四边形角的纹理坐标是固定的，对于每个粒子，我们在`SetMaxParticles()`方法中填充`U`和`V`值：'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we will resize the `FParticles` array and `FVertices` object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调整`FParticles`数组和`FVertices`对象的大小：
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Loop over the particles and assign six texture coordinate pairs to each vertex:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历粒子并给每个顶点分配六个纹理坐标对：
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We synchronize particle coordinates, lifetime, and colors between `FVertices`
    and `FParticles` fields every frame. The `UpdateParticles()` method calculates
    new positions and velocities for each particle, and then updates the individual
    components of the `FVertices` object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每帧都在`FVertices`和`FParticles`字段之间同步粒子坐标、生命周期和颜色。`UpdateParticles()`方法为每个粒子计算新的位置和速度，然后更新`FVertices`对象的各个组件：
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the time-to-live of a particle is less than zero, we replace the particle
    with the last one in the array, so we can just efficiently pop the dead particle
    out of the container:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子的生存时间小于零，我们用数组中的最后一个粒子替换它，这样我们可以有效地将死粒子从容器中弹出：
- en: '[PRE28]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using Newtonian physics and explicit Euler integrator, just as we have done
    for boids in the previous chapter, we recalculate the new velocity and position
    for each particle:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿物理学和显式欧拉积分器，正如我们在上一章对鸟群所做的那样，我们为每个粒子重新计算新的速度和位置：
- en: '[PRE29]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The time-to-live, total lifetime, and size of a particle are packed together
    into a `vec3` variable so that they can be stored in a vertex array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的生存时间、总生命时间和大小被打包到一个`vec3`变量中，这样它们就可以存储在顶点数组中：
- en: '[PRE30]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To keep formulas simple, we normalize the lifetime of the particle and use
    it in our color calculations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化公式，我们归一化粒子的生命周期，并在我们的颜色计算中使用它：
- en: '[PRE31]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Depending on the normalized time, we calculate the color of the current particle.
    The `GetParticleBrightness()` function is described as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据归一化时间，我们计算当前粒子的颜色。`GetParticleBrightness()`函数的描述如下：
- en: '[PRE32]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since each particle is represented by two triangles, we assign the same values
    to six consequential elements in the vertex array:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个粒子由两个三角形表示，我们在顶点数组中为连续的六个元素分配相同的值：
- en: '[PRE33]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After updating each particle, we adjust the number of vertices to be rendered
    in the vertex array to match the number of the currently active particles:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更新每个粒子后，我们调整顶点数组中要渲染的顶点数量，以匹配当前活动的粒子数：
- en: '[PRE34]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `GetParticleBrightness()` function calculates a trapezoid-shaped function
    having a constant value of `1.0` for argument values from `0.1` to `0.9`. Visually,
    it means that at the beginning of the lifetime, particles fade in from zero to
    full visibility, then shine at a constant strength, and then linearly decay to
    zero:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetParticleBrightness()`函数计算了一个梯形函数，对于从`0.1`到`0.9`的参数值，该函数的值为`1.0`。从视觉上讲，这意味着在粒子生命周期的开始，粒子从零渐变到完全可见，然后以恒定强度发光，然后线性衰减到零：'
- en: '[PRE35]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, we have only defined the class holding the particle instances.
    To integrate these new objects into our rendering system, we have to define a
    new kind of scene graph node, the `clParticleSystemNode` node. Before we can do
    this, a few words should be told about how the particles are emitted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只定义了持有粒子实例的类。为了将这些新对象集成到我们的渲染系统中，我们必须定义一种新的场景图节点，即`clParticleSystemNode`节点。在我们这样做之前，应该先讲述一下粒子的发射方式。
- en: 'We introduce the `iParticleEmitter` interface, which declares a single pure
    virtual method, `EmitParticles()`, taking two parameters. The `DeltaTime` parameter
    is used to update the time counter and calculate new particle positions in the
    `PS` particle system:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了`iParticleEmitter`接口，该接口声明了一个纯虚方法`EmitParticles()`，该方法有两个参数。`DeltaTime`参数用于更新时间计数器并在`PS`粒子系统中计算新粒子的位置：
- en: '[PRE36]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Fields of this class defines allowable ranges for each parameter of the particle.
    The limits for color, size, velocity, and lifetime are given by the variables
    with `Min` and `Max` postfixes. The `FEmissionRate` defines how many particles
    per second we are emitting and `FMaxParticles` gives the upper limit on the number
    of particles. The `FAccumulatedTime` field contains an approximate amount of time
    passed since the last particle system update:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的字段定义了粒子每个参数的允许范围。颜色、大小、速度和生命周期的限制由带有`Min`和`Max`后缀的变量给出。`FEmissionRate`定义了我们每秒发射的粒子数，而`FMaxParticles`给出了粒子数量的上限。`FAccumulatedTime`字段包含了自上次粒子系统更新以来大约经过的时间：
- en: '[PRE37]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `EmitParticles()` method is overridden in two subclasses. The first of
    these subclasses is `clParticleEmitter_Box`, which emits particles in an axis-aligned
    box region:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmitParticles()`方法在两个子类中被重写。第一个子类是`clParticleEmitter_Box`，它在一个轴向对齐的盒子区域发射粒子：'
- en: '[PRE38]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following loop emits the required number of particles, one at a time. The
    position, velocity, color, time-to-live, and size are filled with uniform random
    variables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的循环一次发射一个所需数量的粒子。位置、速度、颜色、生存时间和大小都用均匀随机变量填充：
- en: '[PRE39]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is one of the simplest emitters possible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能最简单的发射器之一。
- en: Using particle systems in the game
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏中使用粒子系统
- en: 'We also need a decent-looking explosion effect for our game. Particles emission
    in a combustive manner is implemented in the `clParticleEmitter_Explosion` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏还需要一个看起来不错爆炸效果。在`clParticleEmitter_Explosion`类中实现了以燃烧方式发射粒子的功能：
- en: '[PRE40]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The constructor sets the `FEmitted` fields to `false`. On the first invocation
    of `EmitParticles()`, this field is set to `true` and a fixed number of primary
    particles are emitted:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将`FEmitted`字段设置为`false`。在第一次调用`EmitParticles()`时，此字段被设置为`true`，并发射固定数量的主粒子：
- en: '[PRE42]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The explosion effect adds a bunch of particles only once, but at each sequential
    `EmitParticles()` call secondary particles are created making trails, which follow
    the paths of primary particles. For each entity from the existing set of particles,
    an additional particle is created, so that the total number of particles is sustained
    within a budget set in the `FMaxParticles` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸效果只添加一次大量粒子，但在每次顺序调用`EmitParticles()`时，会创建次级粒子，形成跟随主粒子路径的轨迹。对于现有粒子集合中的每个实体，都会创建一个附加粒子，以使粒子总数保持在`FMaxParticles`变量设定的预算内：
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we have created the explosion, this emitter will not work again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了爆炸效果，这个发射器将不再工作：
- en: '[PRE44]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following loop creates a spray of particles with directions evenly distributed
    across a sphere:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的循环创建了一个方向在球体上均匀分布的粒子喷雾：
- en: '[PRE45]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using two uniform random variables as angles, we calculate the uniform random
    direction:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个均匀分布的随机变量作为角度，我们计算了均匀的随机方向：
- en: '[PRE46]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each particle starts at the center of explosion and the velocity coincides
    with the random direction calculated in the preceding code multiplied by a random
    magnitude:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个粒子从爆炸中心开始，速度与前面代码中计算出的随机方向相乘的随机大小一致：
- en: '[PRE47]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Time-to-live, color, and size fields are filled with uniform random values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生存时间、颜色和大小字段填充了均匀的随机值：
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using particle systems inside a scene graph
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在场景图中使用粒子系统
- en: 'Now, we are ready to declare and define the `clParticleSystemNode` class, which
    owns a `clParticleSystem` object, `clGeometryNode` with particle geometry, and
    a container of `iParticleEmitter` objects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备声明并定义`clParticleSystemNode`类，它拥有一个`clParticleSystem`对象，带有粒子几何的`clGeometryNode`，以及`iParticleEmitter`对象的容器：
- en: '[PRE49]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following five methods provide access to the private particle emitters
    container:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五个方法提供了对私有粒子发射器容器的访问权限：
- en: '[PRE50]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The constructor instantiates a particle system and all the necessary scene
    nodes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数实例化了一个粒子系统以及所有必要的场景节点：
- en: '[PRE51]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a geometry node to store particles vertices:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个几何节点以存储粒子顶点：
- en: '[PRE52]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Get a material out of the particle system and apply it to the scene node:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从粒子系统中获取材质，并将其应用到场景节点上：
- en: '[PRE53]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `clParticleSystemNode::UpdateParticles()` method calls all the emitters,
    then invokes `clParticleSystem::UpdateParticles()` for `m_Particles`, and finally
    sends new particle vertex data to the rendering API using the `clGLVertexAray::CommitChanges()`
    call:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`clParticleSystemNode::UpdateParticles()`方法调用所有发射器，然后为`m_Particles`调用`clParticleSystem::UpdateParticles()`，并最终使用`clGLVertexAray::CommitChanges()`调用将新的粒子顶点数据发送到渲染API：'
- en: '[PRE54]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rendering of `clVertexAttribs` that contains particle attributes requires
    new shaders to be written. Since particles represent a new type of geometry, we
    extend our `clMaterialSystem` class so that it can handle the particle material:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 包含粒子属性的`clVertexAttribs`的渲染需要编写新的着色器。由于粒子代表了一种新的几何类型，我们扩展了我们的`clMaterialSystem`类，使其能够处理粒子材质：
- en: '[PRE55]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `GetShaderProgramForPass`() member function checks whether the material
    class is *Particle* and picks a shader program from a new set of particle shader
    programs. Otherwise, it falls back to the old `clMaterialSystem` implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetShaderProgramForPass()`成员函数检查材质类是否为*Particle*，并从一组新的粒子着色器程序中选择一个着色器程序。否则，它会回退到旧的`clMaterialSystem`实现：'
- en: '[PRE56]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The only new field in this class is a map that holds the new compiled shader
    programs for each pass:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此类中唯一的新字段是一个映射，用于保存每个通道的新编译着色器程序：
- en: '[PRE57]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here goes the source code of all new shaders necessary to render particles.
    A vertex shader is shared between all rendering passes and does the billboarding;
    this orients particles to the camera:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是渲染粒子所需的所有新着色器的源代码。顶点着色器在所有渲染通道之间共享，并执行公告板处理；这会将粒子对准到相机：
- en: '[PRE58]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The same projected transform scale bias as for the default material:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认材质相同的投影变换缩放偏置：
- en: '[PRE59]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Particles should be oriented so that they always face the camera. Let''s construct
    a frame of reference where vectors `X` and `Y` are parallel to the screen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子应该被定向，使它们始终面向相机。让我们构建一个参考框架，其中向量`X`和`Y`与屏幕平行：
- en: '[PRE60]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Fetch the particle size stored inside the normal''s Z-component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 获取存储在法线Z分量中的粒子大小：
- en: '[PRE61]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use texture coordinates to calculate offsets from the center of the particle:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理坐标来计算粒子中心偏移量：
- en: '[PRE62]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Transform the vertex position using the model-view-projection matrix:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型视图投影矩阵变换顶点位置：
- en: '[PRE63]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Pass on all other varying variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 传递所有其他变量：
- en: '[PRE64]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Fragment shaders are more diverse and require a different one for ambient,
    shadow, and light passes to render particles properly. The following is the particle
    fragment shader for an ambient pass:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器更为多样，需要不同的着色器来处理环境光、阴影和光照传递，以正确渲染粒子。以下是环境传递的粒子片段着色器：
- en: '[PRE65]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The value of `v_Params` comes from the `clParticleSystem::UpdateParticles()`
    function where TTL, lifetime, and size are packed together:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`v_Params`的值来自`clParticleSystem::UpdateParticles()`函数，其中TTL、生命周期和大小打包在一起：'
- en: '[PRE66]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Compute transparency based on the distance to the particle center. This gives
    nice rounded particles without using any textures:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据到粒子中心的距离计算透明度。这样可以得到没有使用任何纹理的圆润粒子：
- en: '[PRE67]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The fragment shader for a light pass looks as follows. It just discards the
    fragment, particles do not react on light sources:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 光照传递的片段着色器如下所示。它只是丢弃了片段，粒子不会对光源产生反应：
- en: '[PRE68]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A shadow map generation pass can be handled with the following fragment shader.
    Create a rounded shadow for each particle:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射生成传递可以用以下片段着色器处理。为每个粒子创建一个圆形阴影：
- en: '[PRE69]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The shadow grows for the first half of particle lifetime and shrinks to zero
    afterwards:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子生命周期的一半内，阴影会增大，之后缩小到零：
- en: '[PRE70]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A demonstration of particles rendering can be found in the `1_Particles` example.
    Here is a screenshot showing the running application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`1_Particles`示例中可以找到粒子渲染的演示。以下是运行应用程序的截图：
- en: '![Using particle systems inside a scene graph](img/image00232.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![在场景图中使用粒子系统](img/image00232.jpeg)'
- en: 'At the beginning, we create an empty particle system node and pass it to the
    `GenerateExplosion()` function, which adds yet another explosion to the particle
    system. Here is how this is implemented:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 初始阶段，我们创建一个空的粒子系统节点，并将其传递给`GenerateExplosion()`函数，该函数为粒子系统添加了另一个爆炸效果。以下是实现方式：
- en: '[PRE71]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The demo is intended to run on an Android device; do not spawn too many particles:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 演示旨在在Android设备上运行；不要生成太多粒子：
- en: '[PRE72]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A palette for three different explosion types consists of blue, red, and green
    colors:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 三种不同爆炸类型的调色板包括蓝色、红色和绿色：
- en: '[PRE73]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Just pick one tint randomly:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择一种染色：
- en: '[PRE74]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create and set up the emitter object. You are strongly encouraged to play with
    these parameters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并设置发射器对象。强烈建议您玩转这些参数：
- en: '[PRE75]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This function is invoked from the main loop:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从主循环中调用：
- en: '[PRE76]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Dice to decide whether we should add another explosion:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 投掷骰子以决定是否应添加另一个爆炸效果：
- en: '[PRE77]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Always add a new explosion if the particle system contains no active particles:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子系统不包含活跃的粒子，则始终添加新的爆炸效果：
- en: '[PRE78]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Try building this demo for Android and running it on your device.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为Android构建此演示并在您的设备上运行。
- en: Asteroids game
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小行星游戏
- en: 'Now, we have everything in place to deal with the actual game. Essentially,
    the game contains a lot of the previous examples stitched together to run in common
    and implement different aspects of the application. The glue that defines the
    game logic is in the class `clGameManager`, which is defined in `Game.cpp` and
    `Game.h`. The actual boid-like entities are implemented in `Actors.cpp` and `Actors.h`.
    Let''s start with the base class `iActor`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好处理实际的游戏。本质上，游戏包含了许多前例拼接在一起，以共同运行并实现应用程序的不同方面。定义游戏逻辑的“胶水”在`clGameManager`类中，该类在`Game.cpp`和`Game.h`中定义。实际的类似鸟类的实体在`Actors.cpp`和`Actors.h`中实现。让我们从基类`iActor`开始：
- en: '[PRE79]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The major difference from all the previous examples is that there is no `Render()`
    method in this game framework. Instead, all entities should know how to attach
    to and detach from a scene graph. These methods are overridden in subclasses and
    vary between different types of actors:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有前例的主要区别在于，这个游戏框架中没有`Render()`方法。相反，所有实体都应该知道如何附加到场景图以及从中分离。这些方法在子类中被重写，并且因不同类型的参与者而异：
- en: '[PRE80]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Some code is shared between all subclasses:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码在所有子类之间共享：
- en: '[PRE81]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'An asteroid game entity is an instance of the `clAsteroid` class, which is
    very simple:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星游戏实体是`clAsteroid`类的实例，非常简单：
- en: '[PRE82]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The implementation is almost trivial. Update the position and clamp it to the
    size of the game level:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实现几乎微不足道。更新位置并将其限制在游戏关卡的大小内：
- en: '[PRE83]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Asteroids always rotate around the `(1,1,1)` axis:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星总是围绕`(1,1,1)`轴旋转：
- en: '[PRE84]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Attachment to the scene burns down to loading of an `.obj` file with an appropriate
    3D model and setting up a material. A yellow one would be nice:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到场景主要是加载一个适当的3D模型的`.obj`文件并设置材质。黄色会很好看：
- en: '[PRE85]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Detachment from the scene is simple:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从场景中分离很简单：
- en: '[PRE86]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `clRocket` class represents a rocket fired from the space ship. Everything
    is similar to the implementation of `clAsteroid` except the `Update()` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`clRocket`类表示从太空船发射的火箭。除了`Update()`方法之外，一切都与`clAsteroid`的实现相似：'
- en: '[PRE87]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If a rocket leaves the level area, kill it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果火箭离开了关卡区域，就销毁它：
- en: '[PRE88]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Explosions are implemented in the `clExplosion` class. The `clExplosion::AttachToScene()`
    method creates a particle system node with the emitter similar to the one in `GenerateExplosion()`.
    Nothing interesting there. However, the `Update()` method is slightly different:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸在`clExplosion`类中实现。`clExplosion::AttachToScene()`方法创建了一个与`GenerateExplosion()`中相似的发射器的粒子系统节点。那里没有什么有趣的。然而，`Update()`方法略有不同：
- en: '[PRE89]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Particle system nodes require updating. Use a coefficient to make particles
    move slower:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统节点需要更新。使用系数让粒子移动得更慢：
- en: '[PRE90]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Kill the explosion once all particles are gone:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有粒子消失后，销毁爆炸：
- en: '[PRE91]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Last but not least, the `clSpaceShip` class represents a player-controllable
    entity. Again, the most interesting part is the `Update()` method, which handles
    the user controls:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`clSpaceShip`类表示一个可由玩家控制的实体。同样，最有趣的部分是处理用户控制的`Update()`方法：
- en: '[PRE92]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Ask the game manager if any control keys were pressed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 询问游戏管理器是否按下了任何控制键：
- en: '[PRE93]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Make the ship warp between opposite sides of the level:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让船在关卡的相对两侧之间进行跃迁：
- en: '[PRE94]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We do not want it to move very fast; here speed decay and clamping are implemented.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望它移动得太快；这里实现了速度衰减和限制。
- en: '[PRE95]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'A time counter is used to limit the rate of fire:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间计数器限制发射速率：
- en: '[PRE96]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Scale and rotate the 3D model to match the desired size and orientation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和旋转3D模型以匹配所需的大小和方向：
- en: '[PRE97]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Apply the cumulative transformation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用累积变换：
- en: '[PRE98]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `Fire` method does exactly what it appears to do. It launches a rocket
    and maintains the rate of fire:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fire`方法所做的正是它看起来要做的事。它发射火箭并维持发射速率：'
- en: '[PRE99]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Try changing the weapon cool down time. One second is the default value:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试改变武器冷却时间。一秒是默认值：
- en: '[PRE100]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The actual rocket entity is added by the game manager:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏管理器添加实际的火箭实体：
- en: '[PRE101]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Those are all the entities existing in the game. Let''s take a short glance
    at the `clGameManager` class, which rules them all:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是游戏中存在的实体。让我们快速浏览一下统治它们的`clGameManager`类：
- en: '[PRE102]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Update the state of all objects and calculate collisions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更新所有对象的状态并计算碰撞：
- en: '[PRE103]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Use the rendering technique to draw the game world:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渲染技术绘制游戏世界：
- en: '[PRE104]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'There are two functions to create new entities; they are used in `clSpaceShip`
    and `CheckCollisions()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数用于创建新实体；它们在`clSpaceShip`和`CheckCollisions()`中使用：
- en: '[PRE105]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'A couple of high-level math functions to deal with positions of the entities:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级数学函数用于处理实体位置：
- en: '[PRE106]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Kill a game actor, which can be an asteroid, an explosion, or a rocket. The
    space ship lives forever in our game. The `Kill()` method does not remove the
    actor immediately. Instead, it adds the actor to a container, which is later handled
    in the `PerformExecution()` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁游戏演员，可能是小行星、爆炸或火箭。在我们的游戏中，太空船永存。`Kill()`方法不会立即移除演员。相反，它会将演员添加到一个容器中，稍后在`PerformExecution()`方法中处理：
- en: '[PRE107]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The name says it all. Play an audio file in a fire-and-forget fashion:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 名字说明了一切。以“即发即忘”的方式播放音频文件：
- en: '[PRE108]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The grand central dispatch of the gaming logic lays within the `GenerateTicks()`
    method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑的大中央调度位于`GenerateTicks()`方法中：
- en: '[PRE109]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Update everything, check for collisions, and remove dead objects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更新一切，检查碰撞，并移除死亡对象：
- en: '[PRE110]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Remove stopped audio sources one by one:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 逐一移除已停止的音频源：
- en: '[PRE111]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Collision checking is done with a naive `O(n^2)` algorithm:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检查是用一个简单的`O(n^2)`算法完成的：
- en: '[PRE112]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If a rocket is close enough to an asteroid, destroy both and add a huge explosion:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果火箭足够接近小行星，就销毁两者并产生巨大的爆炸：
- en: '[PRE113]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Executions are fast, but require a bit of C++ template magic:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行很快，但需要一些C++模板魔法：
- en: '[PRE114]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here is the template code to handle heterogeneous entity containers:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理异构实体容器的模板代码：
- en: '[PRE115]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: If you are a C++14 fan, you can definitely replace `const typename Container::value_type&`
    in the lambda parameter with `const auto&`, but our Visual Studio 2013 refused
    to compile the new code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个C++14的粉丝，你绝对可以用`const auto&`替换lambda参数中的`const typename Container::value_type&`，但我们的Visual
    Studio 2013拒绝编译新代码。
- en: 'Whatever other functions are not mentioned here can be found in the `1_Asteroids`
    example. Build and run the code. It should look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里未提及的其他功能可以在`1_Asteroids`示例中找到。构建并运行代码，效果应如下所示：
- en: '![Asteroids game](img/image00233.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Asteroids游戏](img/image00233.jpeg)'
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we summed up many techniques shown in the book and implemented
    a portable game application using the Android NDK. The essence of our tinkering
    with all that C++ code is the possibility to run our game unchanged on a desktop
    machine. This approach gives great opportunities in debugging large C++ mobile
    applications and faster iteration times when integrating new content into these
    apps. Furthermore, professional mobile development is never focused on one platform.
    With development practices like these, you can write C++ code that runs on many
    mobile platforms, including Android and iOS.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们总结了书中展示的许多技巧，并使用Android NDK实现了一个可移植的游戏应用。我们所有C++代码调试的核心在于能够不变地在桌面计算机上运行我们的游戏。这种方法在调试大型C++移动应用以及在将这些应用整合到新内容时提供了极大的便利和更快的迭代速度。此外，专业的移动开发永远不会只关注一个平台。通过这些开发实践，你可以编写在许多移动平台（包括Android和iOS）上运行的C++代码。
