- en: Chapter 11. Things That Go Bump – Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collision detection in this game is much more complex than the previous
    two. For this reason, the code will be quite heavily commented. Sometimes the
    comments will explain things in a bit more detail or in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: However, that doesn't mean it needs to be hard work. What we need to do is take
    a moment to consider a strategy that will work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this approach will mean that by the end of the chapter, our collision
    detection solutions will appear straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we are trying to achieve can be put into the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want for the border:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asteroids, bullets, and the ship need to know when they have collided with the
    border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asteroids should reverse and head back into the game area when they touch the
    border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A bullet should reset itself at the border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ship should subtract a life and then respawn in the centre
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we want for the asteroids. We need to know and respond when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ship touches an asteroid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a bullet touches an asteroid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the original Asteroids game, we will not respond to asteroids bumping
    into each other
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we will not be detecting an asteroid on asteroid collisions, you will
    see that when our collision detection nears completion, achieving asteroid on
    asteroid collision detection will not present much of an extra challenge. However,
    it will put extra strain on the device's CPU.
  prefs: []
  type: TYPE_NORMAL
- en: We know that we have object on border collisions to detect and object on asteroid
    collisions to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with the border
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may sound obvious, but the border is simply four static straight lines. This
    makes a border collision a different problem to an asteroid collision.
  prefs: []
  type: TYPE_NORMAL
- en: All of the objects that we are interested in have vertices (or one vertex in
    the case of a bullet). This may at first suggest that we can simply compute the
    world location of each vertex from the model space and the centre of the object
    stored in `worldLocation`. We can, but this overlooks the fact that the asteroids
    and the ship rotate, which constantly causes a variation in the actual world locations
    of all the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to translate and rotate the model space vertices, and then test
    if any of them have touched the border. We can do this in the object's `update`
    method for each frame, but we only need the rotated coordinates occasionally,
    when the object is very close to the border.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase of border collision detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This suggests that a preliminary check, a first phase of collision detection,
    is more efficient. It implies that the translation and rotation of the vertices
    will need to take place outside of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do is use a simple rectangle intersect check based on the centre
    of the object and its width and height. If this cheap method returns a hit, we
    will then rotate and translate each vertex and check their real-world coordinates
    individually against the location of the border.
  prefs: []
  type: TYPE_NORMAL
- en: Once the rotated game world locations of the vertices are calculated, the collision
    detection is simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, a two-stage solution is appropriate for the asteroid detection
    as well. Also, rotation and translation is involved but it is far less important.
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with an asteroid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing for collision with an asteroid is similar in some respects. We need
    to find out if any single vertex from the ship or a bullet crosses into the space
    contained by the vertices of the asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that the asteroid is not only a moving target, but also
    a rotating one. We will not only have to rotate and translate all the vertices
    of the objects, but the asteroids as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to calculate the line made between each pair of vertices on the
    asteroid. Fortunately, at this point, we can fall back on a clever algorithm devised
    and refined by mathematicians far greater than myself. We will use the crossing
    number algorithm. This is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The crossing number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We compute the line made by a pair of vertices and use the crossing number algorithm
    to see if a particular vertex from the object being tested crossed that line.
    If it did, we increment a variable from 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: We test the same point against each and every line made by each vertex pair
    from an asteroid, incrementing our variable each time it does. If our variable
    is odd after testing the vertex against every line with the crossing number algorithm,
    we have a hit. If it is even, no collision has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Of course if no collision has occurred, we must proceed to test each and every
    vertex from the object being tested against each and every line formed out of
    the vertex pairs on the asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a visual representation of the crossing number algorithm in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![The crossing number](img/B043422_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course with all these complex calculations going on, we will definitely want
    to do a simple first phase test to see if it is likely there has been a collision
    before doing the complex tests.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase and overview of asteroid collision detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The radius overlap test is quite appropriate when testing a single vertex, such
    as a bullet, a spinning triangle like a ship, or a rotating asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an overview of the whole process we will use for testing the collisions
    against asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the radius of the object being tested overlapped with the radius of an asteroid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, has the first vertex of the object crossed the first line of the asteroid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, `crossingNumber ++`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 2 with each line on the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `crossingNumber` is odd, return true to calling code because a collision
    has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `crossingNumber` is even, no collision has occurred (yet) repeat steps 2,
    3, and 4 with the next vertex of the object being tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all vertices tested and we reached here then no collision has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will set up a collision detection class called `CD` with two static methods.
    The `detect` method will test for collisions with asteroids and be called for
    each bullet and ship against each and every asteroid in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `contain` method will check for collisions with every asteroid, bullet,
    and ship against the border.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the calculations outside the objects themselves means that we will need
    a whole bunch of data for the objects we will be testing, and the ones made accessible
    to the new `CD` class's methods.
  prefs: []
  type: TYPE_NORMAL
- en: The CollisionPackage class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that we need a certain set of data to carry out detections properly.
    This next class will hold all the data that our collision detection class's methods
    will need in order to do its job, and every object that we need to detect collisions
    for will have one.
  prefs: []
  type: TYPE_NORMAL
- en: When the time comes to rotate all the points to their real-world location, our
    collision package will need to know which way the object is facing. We have a
    float called `facingAngle`.
  prefs: []
  type: TYPE_NORMAL
- en: We will obviously need a copy of the model space vertices. As with the rotated
    location, we will not go through the trouble of updating every frame and will
    do so only after the first phase of collision detection shows that a collision
    is likely.
  prefs: []
  type: TYPE_NORMAL
- en: We will also hold the precomputed value for the length of the array that holds
    these vertices. It can potentially save time in the collision detection process.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will also need the world coordinates of the object. This, we will
    update every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Each object will have a precomputed `radius` variable, which is the size of
    the object from its centre to its furthest vertex. This will be used in our `detect`
    method for radius overlapping, phase one detection.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have a couple of `PointF` objects, `currentPoint`, and `currentPoint2,`
    which are just handy objects that will avoid us potentially summoning the garbage
    collector during an intensive part of the two collision detection methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `CollisionPackage`, and implement the members we
    have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a simple constructor that will receive all the necessary data
    from each object at the end of each object''s constructor. Implement the `CollisionPackage`
    constructor as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all the data we need for advanced collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding collision packages to the objects and making them accessible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we have our `CollisionPackage` class. We will see how to add one to each
    object we need to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the Bullet class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open up the `Bullet` class, and we will see how to make use of our `CollisionPackage`
    constructor on the simplest case (just a point). Add a new member for the collision
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new member of type `CollisionPackage` to the `Bullet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a structure to pass in to our `CollisionPackage` constructor
    and initialize the collision package. Note that we send in a single element array
    with the model space coordinates that will be 0,0,0\. Then, we send in the world
    location, 1, for the radius and the angle the bullet is facing. Enter the following
    code at the end of the `Bullet` class''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally for the `Bullet` class, we update the collision package in each frame
    by adding this code to the very end of the `Bullet` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, our bullets are all set for detection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the SpaceShip class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open up the `SpaceShip` class and add these members. We will then see how to
    use them in the `SpaceShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we do something extra compared to the `Bullet` class. We add three more
    model space coordinates. OpenGL will not know about these and doesn''t need them.
    They are positioned in the middle of each of the three lines, which make the ship.
    We do this to make it harder for a vertex of an asteroid to drift inside the ship
    without a vertex of the ship being inside the asteroid. This is a visual representation
    of the problem that we are solving. The ships vertices are heavily emphasized
    to highlight the problem. Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can completely solve this problem by testing all the asteroids vertices
    against all of the ship''s lines as well as what we are planning to do; test all
    the ship''s vertices against all the asteroids lines. However, just adding a few
    extra points to the ship does produce near-perfect detection as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, right after the call to `setVertices()` in the `SpaceShip` constructor
    implement the code we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next as we did for the `Bullet` class, we synchronize the collision package
    each frame in the `SpaceShip` class's `update` method. We do this at the very
    end of the method after the call to `move()` has updated the ship's coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will add a collision package to the asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the Asteroid class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open up the `Asteroid` class and add a `CollisionPackage` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `Asteroid` constructor, just after the call to `generatePoints()`,
    we initialize the `CollisionPackage` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a helper method that reverses the direction of travel and *bounces*
    the asteroid back by a few pixels when a collision has been detected. We will
    call this method when we detect a collision with the border. Add the `bounce`
    method to the `Asteroid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `SpaceShip` and `Bullet` classes, we will update the collision
    package in the `update` method just after the call to `move` at the very end of
    the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to do something that we didn't need to do for the other classes.
    Our crossing number algorithm uses lines not vertices, so we need to make a line
    out of the last vertex by joining it with the first. We didn't need to do this
    with the `SpaceShip` class because of the way our collision data code worked.
    The collision data code will test the points of the bullets and ship against the
    lines of the asteroids. Not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the extra code to add to the seventh point in the `generatePoints`
    method. In the following code, I have included the existing code on either side
    of the new highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can talk about building the collision detection class itself.
  prefs: []
  type: TYPE_NORMAL
- en: The CD class outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now implement the first phase of collision detection. As discussed,
    the algorithms we will use are computationally expensive, and we only want to
    use them when there is a realistic chance of a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will check each bullet and the ship against every asteroid using
    the radius overlapping method discussed in [Chapter 3](ch03.html "Chapter 3. Tappy
    Defender – Taking Flight"), *Tappy Defender – Taking Flight*. We will check the
    asteroids, ship, and bullets against the border using a simplified rectangle intersection
    method.
  prefs: []
  type: TYPE_NORMAL
- en: After the next two sections, you will actually be able to play the game, but
    you will see that the basic collision detection that we have used so far is not
    satisfying enough for this type of game.
  prefs: []
  type: TYPE_NORMAL
- en: These first checks will decide whether we then move on to do the more accurate
    and computationally expensive checks.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement these second phase checks in the sections *Precise collision
    detection with the border* and *Precise collision detection with an asteroid*,
    which will use the more advanced algorithms and put the data in our collision
    packages to full use.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new class and call it `CD`. Add a member `PointF` object
    and initialize it. We will use it to avoid creating new objects during the critical
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing radius overlapping for asteroids and ships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's add our first method to the `CD` class, to detect collisions between bullets
    and asteroids as well as the ship and asteroids. As we discussed, we are only
    implementing the first part of this method for now. Here is the implementation
    of the radius overlapping code.
  prefs: []
  type: TYPE_NORMAL
- en: The code works by making a hypothetical triangle with a missing side, and then
    using Pythagoras' theorem to calculate the missing side that is the distance between
    the centre points of the two objects. If the combined radii of the two objects
    is greater than the distance between the two object centers, we have an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `detect` method with the radius overlapping code. Note that we return
    `true` if the radii overlap. This one line of code will be replaced with the more
    accurate detection later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss the border.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rectangle intersection for the border
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will see if any asteroids, bullets, or the ship need containing within the
    border. As discussed, we will carry out a simple rectangle intersect test and
    return `true` if detected. Later, we will delete the return `true` and add the
    more sophisticated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `contain` method as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two methods that we just need to call them on all the appropriate
    object combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are really close to being able to play our game, albeit with simplified collision
    detection. First add some methods that handle what happens when certain collisions
    are detected and then see how we actually use our `CD` class.
  prefs: []
  type: TYPE_NORMAL
- en: Helper methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need a couple of helper methods to respond, when we detect
    various types of collisions.
  prefs: []
  type: TYPE_NORMAL
- en: We need a method for when the ship is destroyed and a method for when an asteroid
    is destroyed. The next two subsections cover this.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a ship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The death of a ship can be detected in two places, so it makes sense to add
    a method to handle the events that follow. In this next method, we reset the ship's
    location to the center of the map, play a sound, and decrement `numLives`.
  prefs: []
  type: TYPE_NORMAL
- en: If `numLives` is equal to zero, set `levelNumber` back to one, `numLives` to
    three, call `createObjects()` to redraw a level, pause the game, and then play
    a sound suitable to let the player know that he is starting again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `lifeLost` method to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will handle what happens when an asteroid dies.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying an asteroid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method will be called when the ship or a bullet hits an asteroid. First,
    we set the asteroid that triggered the collision to `setActive(false)`. It will
    not be drawn or updated any more.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we play a sound and decrement `numAsteroidsRemaining`. Finally if `numAsteroidsRemaining`
    is equal to zero, the player has cleared an entire level. In that case, we increment
    `levelNumber` and `numLives`, play a victorious sound, and start a harder level
    by calling `createObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `destroyAsteroid()` method to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now call our new `CD` class's static methods and respond when we get
    a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for collisions in update()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will check to see if the ship needs containing. We simply call `CD.contain()`
    with the `mapWidth`, `mapHeight`, and the ship's collision package. If there is
    a collision, the code calls `lifeLost()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the collision detection code after all the code that updates the objects
    in the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the code that detects if any of the asteroids are attempting to leave
    the asteroid simulator. It works exactly the same way as the previous block of
    code except that we loop through each asteroid, check if it is active, and call
    bounce on the asteroid if we detect a collision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code for the bullets looks a little more complicated, but it isn't really.
    The call to `CD.contain()` is identical, and we do so for each bullet. However,
    some last minute balancing of the game play is necessary for the bullet to be
    reset as it left the viewport (if that was before the border), because otherwise
    the ship can just spin round and destroy the asteroids from a great distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code to detect bullet collisions with the border and the edge of
    the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game now and see how the `CD.contain()` method does a fairly
    good job of keeping everything within the asteroid simulator.
  prefs: []
  type: TYPE_NORMAL
- en: We will call our `detect` method to see if anything is bumping into an asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: First, check the bullets. Note that we do a preliminary check to make sure the
    bullet is in flight, and the asteroid is active before we trouble our `CD.detect`
    method. Then, we just pass in the two collision packages and `CD.detect` does
    the rest. If a bullet collides with the border, we call `resetBullet()` on the
    appropriate bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we test for the ship. If a collision is detected, we call `destroyAsteroid()`
    followed by `lifeLost()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can play the game and our rudimentary collision detection
    will work. However, fly too close to an asteroid, and you will lose a life without
    touching it or merely shoot a bullet close and the asteroid is gone. We need to
    be able to skim the surface of the border or asteroid and only get a hit when
    a point actually crosses into the exact space of another object.
  prefs: []
  type: TYPE_NORMAL
- en: Precise collision detection with the border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To upgrade our `detect` method, we need to replace the return statement in the
    `if(possibleCollision)` block with the more precise detection code.
  prefs: []
  type: TYPE_NORMAL
- en: First, initialize `radianAngle` to be the radian equivalent of whichever direction
    (in degrees) our object is facing. The `Math` class uses radians as they are more
    mathematically useful in calculations than the easier to visualize degree measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The variables `cosAngle` and `sinAngle` are just what the name suggests, and
    are used in the block of code which follows this one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth mentioning that the `Math.cos()` and `Math.sin()` methods are relatively
    time consuming. We can speed up our collision detection class by precomputing
    360 values for both `sin` and `cos` and then using a simple lookup method instead
    of this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: However, we maintain our goal of over 60 frames per second, so don't do so here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the return statement and add this code in the `if(possibleCollision)`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the next block of code, enter a `for` loop that loops through each of the
    object's vertices, translates them from model-space to world-space coordinates,
    then uses our previously computed values for cosine and sine of the `facingAngle`
    object to rotate them to their precise locations in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now all we do is see if the rotated and translated vertex falls outside of either
    the left, right, top, or bottom of the border/map. If it does, we return `true`;
    if not, the loop continues to check each and every vertex the same way (translate,
    rotate, check, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game now and watch the bullets disappear with a satisfying thud
    into the border or fly your ship deadly close to the border.
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve our asteroid collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Precise collision detection with an asteroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did this last because there is a more complicated final step. As in the border
    detection, we will need to translate and rotate our object's vertices. However
    this time, we will need to do it for two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, once we rotated and translated the asteroid's vertices, we will
    need to handle them in pairs of vertices that form a line. These are lines that
    we will test against each and every vertex from the other object. This test is
    of course our crossing number method that we discussed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to do all of this within the body of the `if (distance < cp1.radius
    + cp2.radius) { ...}`, where we previously just set the `collided` Boolean to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a lot of code, so we will split it into chunks and see what is
    going on at each stage. Also, the code indentation will not always be consistent
    from block to block in order to format it in the most readable way possible.
  prefs: []
  type: TYPE_NORMAL
- en: The next few blocks of code are the entire contents of the aforementioned, `if`
    block that needs replacing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, we can use a sine and cosine lookup table here too.
  prefs: []
  type: TYPE_NORMAL
- en: We could make a method to rotate angles as we do this so often. But this is
    not as straightforward as it may seem. If we put the rotation code in a method,
    we will either have to put the following sine and cosine calculations in it, which
    will make it slow or precompute it before the method call and the `for` loops
    which is kind of untidy itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you consider that we need more than one value for both the sine and
    cosine of an angle, the method needs to *know* which value to use, and this isn't
    rocket science, but it starts to get even less compact than we might have initially
    imagined. So, I opted to avoid the method call altogether, even if the code is
    a little sprawling. Actually, if you place the whole lot in a method call, you
    still get nearly 60 FPS on an old Galaxy S2 phone. So if you want to tidy things
    up, go ahead; I just thought it was worth discussing why I did things this way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the `for` loops, as we did with the border detection, we
    will compute a few things that won't change for the duration of this method. The
    sine and cosine of the facing angle from each of the two collision packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we loop through all the vertices from `cp2`, then test each in turn with
    all the sides (vertex pairs) from `cp1`. Remember an asteroid has an extra vertex
    of padding that is the same as the first. Therefore, we can test the last side
    of the asteroid. We must always pass in the asteroid collision package as the
    *second* argument when calling `CD.detect()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, translate and then rotate the object being tested
    against an asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now using a pair of vertices at a time, from the asteroid, translate and rotate
    both to their final world-space coordinates ready for the next block of code,
    where we will use the vertex locations calculated in the previous block and this
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we detect if the current vertex from either the ship or a bullet crosses
    the line formed by the current vertex pair of the asteroid. If it does, we increment
    `numCrosses`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the modulus operator to determine if `numCrosses` is odd or
    even. As discussed, we return `true` (collision) for odd and `false` (no collision)
    for even.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now fly your ship right up to the asteroids and only get hit when it
    really looks like you should. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Precise collision detection with an asteroid](img/B043422_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, all of our collision detection and our Asteroids simulator game is done!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can continue to improve our game. For example, it wouldn't be too hard to
    spawn two or three smaller asteroids when the current asteroid is destroyed. We
    just need an array to hold the smaller asteroids. When we deactivate the regular
    asteroid, the array activates some previously instantiated smaller ones at the
    same location as the regular one. We can then make some minor modifications to
    the way we count asteroids, and we will have a neat new feature.
  prefs: []
  type: TYPE_NORMAL
- en: The arcade classic, Asteroids, had a mean UFO that would turn up occasionally.
    It would be simple to design a UFO shape from lines, and have it randomly proceed
    from left to right, or right to left, moving up and down a bit as well.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can add a hyperspace button. This is a kind of last resort for the
    player when they are sure that death is imminent. Tap the hyperspace button and
    the ship will respawn in a random location. We will just need to add a button
    to the array in the `InputController` class and a call to a new, simple `randomHyperspaceJUmp`
    method in the `Ship` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add Google Play achievements and leaderboards and then publish
    the game. If you publish a game that uses OpenGL, you need to add this declaration
    to the `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Try and add some of the improvements we talked about and perhaps some more of
    your own. If you publish your game or even if you don't, I would love to hear
    your ideas or see a link to your projects on [gamecodeschool.com](http://gamecodeschool.com).
  prefs: []
  type: TYPE_NORMAL
- en: I think we are done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you have enjoyed our whirl-wind tour, making games for Android, and I
    hope you keep making lots of new games!
  prefs: []
  type: TYPE_NORMAL
