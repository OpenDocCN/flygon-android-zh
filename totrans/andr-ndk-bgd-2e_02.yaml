- en: Chapter 2. Starting a Native Android Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 开始一个本地Android项目
- en: '*A man with the most powerful tools in hand is unarmed without the knowledge
    of their usage. Make, GCC, Ant, Bash, Eclipse…—any new Android programmer needs
    to deal with this technological ecosystem. Luckily, some of these names may already
    sound familiar. Indeed, Android is based on many open source components, laid
    together by the Android Development Kits and their specific tool-set: ADB, AAPT,
    AM, NDK-Build, NDK-GDB... Mastering them will give us the power to create, build,
    deploy and debug our own Android applications.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有最强大工具的人，若不知如何使用，实则手无寸铁。Make、GCC、Ant、Bash、Eclipse……—任何新的Android程序员都需要处理这个技术生态系统。幸运的是，其中一些名字可能已经听起来很熟悉。实际上，Android是基于许多开源组件构建的，由Android开发工具包及其特定的工具集：ADB、AAPT、AM、NDK-Build、NDK-GDB...掌握它们将赋予我们创建、构建、部署和调试我们自己的Android应用程序的能力。
- en: Before diving deeper into native code in the next chapter, let's discover these
    tools by starting a new concrete Android project that includes native C/C++ code.
    Despite Android Studio being the new official Android IDE, its lack of support
    for native code encourages us to focus mainly on Eclipse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章深入探讨本地代码之前，让我们通过启动一个新的具体Android项目来发现这些工具，该项目包含本地C/C++代码。尽管Android Studio是新的官方Android
    IDE，但它对本地代码的支持不足，促使我们主要关注Eclipse。
- en: 'Therefore, in this chapter, we are going to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将要：
- en: Build an official sample application and deploy it on an Android device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个官方示例应用程序并将其部署在Android设备上
- en: Create our first native Android project using Eclipse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse创建我们的第一个本地Android项目
- en: Interface Java with C/C++ using Java Native Interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java Native Interfaces接口将Java与C/C++连接起来
- en: Debug a native Android application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试一个本地Android应用程序
- en: Analyze a native crash dump
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析本地崩溃转储
- en: Set up a Gradle project with native code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle设置包含本地代码的项目
- en: By the end of this chapter, you should know how to start a new native Android
    project on your own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该知道如何独立开始一个新的本地Android项目。
- en: Building NDK sample applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建NDK示例应用程序
- en: The simplest way to get started with your new Android development environment
    is to compile and deploy some of the samples provided with the Android NDK. A
    possible (and *polygonful*!) choice is the **San Angeles** demo, created in 2004
    by Jetro Lauha and later ported to OpenGL ES (more information at [http://jet.ro/visuals/4k-intros/san-angeles-observation/](http://jet.ro/visuals/4k-intros/san-angeles-observation/)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用新的Android开发环境的简单方法之一是编译和部署Android NDK提供的示例之一。一个可能的（而且*polygonful*！）选择是2004年由Jetro
    Lauha创建的**San Angeles**演示，后来被移植到OpenGL ES（更多信息请访问[http://jet.ro/visuals/4k-intros/san-angeles-observation/](http://jet.ro/visuals/4k-intros/san-angeles-observation/)）。
- en: Time for action – compiling and deploying San Angeles sample
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 编译和部署San Angeles示例
- en: 'Let''s use Android SDK and NDK tools to build a working APK:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Android SDK和NDK工具来构建一个可工作的APK：
- en: Open a command-line prompt and go to the San Angeles sample directory inside
    the Android NDK. All further steps have to be performed from this directory.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行提示符，进入Android NDK中的San Angeles示例目录。所有后续步骤都必须从这个目录执行。
- en: 'Generate San Angeles project files with the `android` command:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`android`命令生成San Angeles项目文件：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_19.jpg)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 编译和部署San Angeles示例](img/1529_02_19.jpg)'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may get the following error upon executing this command:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令时，你可能会遇到以下错误：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that you have not installed all the Android SDK platforms as specified
    in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Environment"), *Setting Up
    Your Environment*. In which case, either install them using the `Android manager
    tool` or specify your own project target, for example, `android update project
    --target 18 -p ./`.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着你可能没有按照[第1章](ch01.html "第1章. 设置你的环境")，*设置你的环境*中指定的那样安装所有的Android SDK平台。在这种情况下，你可以使用`Android管理工具`安装它们，或者指定你自己的项目目标，例如，`android
    update project --target 18 -p ./`。
- en: Compile San Angeles native library with `ndk-build`:![Time for action – compiling
    and deploying San Angeles sample](img/1529_02_20.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ndk-build`编译San Angeles本地库：![行动时间 – 编译和部署San Angeles示例](img/1529_02_20.jpg)
- en: 'Build and package San Angeles application in **Debug** mode:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以**调试**模式构建和打包San Angeles应用程序：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_21.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 编译和部署San Angeles示例](img/1529_02_21.jpg)'
- en: 'Make sure your Android device is connected or the emulator is started. Then
    deploy the generated package:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的Android设备已连接或已启动模拟器。然后部署生成的包：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_22.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 编译和部署 San Angeles 示例](img/1529_02_22.jpg)'
- en: 'Launch `SanAngeles` application on your device or emulator:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备或模拟器上启动 `SanAngeles` 应用程序：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Time for action – compiling and deploying San Angeles sample](img/1529_02_23.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 编译和部署 San Angeles 示例](img/1529_02_23.jpg)'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    Publishing 书籍的示例代码文件。如果您在别处购买了这本书，可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，我们会直接将文件通过电子邮件发送给您。
- en: '*What just happened?*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The old-school San Angeles demo, full of flat-shaded polygons and nostalgia,
    is now running on your device. With only a few command lines, involving most of
    the tools needed for the Android development, a full application including native
    C/C++ code has been generated, compiled, built, packaged, deployed, and launched.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 充满平面阴影多边形和怀旧气息的旧式 San Angeles 演示现在正在您的设备上运行。仅通过几行命令，涉及大部分 Android 开发所需的工具，就生成了一个包含原生
    C/C++ 代码的完整应用程序，并编译、构建、打包、部署和启动。
- en: '![What just happened?](img/1529_02_24.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![刚才发生了什么？](img/1529_02_24.jpg)'
- en: Let's see this process in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个过程。
- en: Generating project files with Android manager
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Android 管理器生成项目文件
- en: 'We generated project files from an existing code base thanks to the Android
    manager. The following bullet points give more information regarding this process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 Android 管理器从现有代码库生成了项目文件。以下关于此过程的详细信息：
- en: '`build.xml`: This is the Ant file that describes how to compile and package
    the final application APK file (which stands for *Android PacKage*). This build
    file contains mainly links to properties and core Android Ant build files.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.xml`：这是 Ant 文件，描述了如何编译并打包最终的 APK 应用程序文件（即 *Android PacKage*）。此构建文件主要包含属性和核心
    Android Ant 构建文件的链接。'
- en: '`local.properties`: This file contains the Android SDK location. Every time
    your SDK location changes, this file should be regenerated.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local.properties`：这个文件包含了 Android SDK 的位置。每次 SDK 位置发生变化时，都应该重新生成这个文件。'
- en: '`proguard-project.txt`: This file contains a default configuration for **Proguard**,
    a code optimizer and obfuscator for Java code. More information about it can be
    found at [http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proguard-project.txt`：这个文件包含了 **Proguard** 的默认配置，Proguard 是用于 Java 代码的代码优化器和混淆器。关于它的更多信息可以在
    [http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html)
    找到。'
- en: '`project.properties`: This file contains the application target Android SDK
    version. This file is generated by default from a pre-existing `default.properties`
    file in the `project` directory. If no `default.properties` exists, then an additional
    `–target <API Target>` flag (for example, `--target 4` for Android 4 Donut) must
    be appended to the `android create` command.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.properties`：这个文件包含了应用程序的目标 Android SDK 版本。此文件默认从 `project` 目录中的预存在
    `default.properties` 文件生成。如果没有 `default.properties`，则必须在 `android create` 命令中添加额外的
    `–target <API Target>` 标志（例如，`--target 4` 表示 Android 4 Donut）。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Target SDK version is different from the minimum SDK version. The first version
    describes the latest Android version for which an application is built, whereas
    the latter indicates the minimum Android version on which the application is allowed
    to run. Both can be declared optionally in `AndroidManifest.xml` file (clause
    `<uses-sdk>`) but only the target SDK version is "duplicated" in `project.properties`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目标 SDK 版本与最低 SDK 版本不同。第一个版本描述了应用程序构建的最新 Android 版本，而后者表示应用程序允许运行的最低 Android
    版本。两者都可以在 `AndroidManifest.xml` 文件（条款 `<uses-sdk>`）中可选声明，但只有目标 SDK 版本在 `project.properties`
    中“重复”。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When creating an Android application, choose carefully the minimum and target
    Android API you want to support, as this can dramatically change your application
    capabilities as well as your audience wideness. Indeed, as a result of fragmentation,
    targets tend to move a lot and faster in Android!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 Android 应用程序时，请仔细选择您希望支持的最低和目标 Android API，因为这可能会极大地改变您应用程序的功能以及您的受众范围。实际上，由于碎片化，目标往往在
    Android 上移动得更快更多！
- en: An application that does not target the latest Android version does not mean
    it will not run on it. However, it will not have access to all the latest features
    nor all of the latest optimizations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不以最新 Android 版本为目标的应用并不意味着它不能在该版本上运行。然而，它将无法使用所有最新的功能以及最新的优化。
- en: 'The Android manager is the main entry point for an Android developer. Its responsibilities
    are bound to SDK version updates, virtual devices management, and projects management.
    They can be listed exhaustively from the command line by executing `android –help`.
    Since we have already looked at SDK and AVD management in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Environment"), *Setting Up Your Environment*, let''s
    focus on its project management capabilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Android 管理器是 Android 开发者的主要入口点。其职责与 SDK 版本更新、虚拟设备管理和项目管理相关。通过执行 `android –help`
    可以从命令行详尽列出。由于我们在[第1章](ch01.html "第1章. 设置你的环境")，*设置你的环境*中已经了解了 SDK 和 AVD 管理，现在让我们关注其项目管理能力：
- en: '`android create project` allows creating new Android projects ex-nihilo from
    the command line. Generated projects contain only Java files but no NDK-related
    files. A few additional options must be specified to allow for proper generation,
    such as:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create project` 允许从命令行空手起家创建新的 Android 项目。生成的项目只包含 Java 文件，不包含与 NDK
    相关的文件。为了正确生成，必须指定一些额外的选项，例如：'
- en: '| Option | Description |'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-a` | Main activity name |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-a` | 主活动名称 |'
- en: '| `-k` | Application package |'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-k` | 应用程序包 |'
- en: '| `-n` | Project name |'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-n` | 项目名称 |'
- en: '| `-p` | Project path |'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-p` | 项目路径 |'
- en: '| `-t` | Target SDK version |'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-t` | 目标 SDK 版本 |'
- en: '| `-g` and `-v` | To generate Gradle build file instead of Ant and specifying
    its plugin version |'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-g` 和 `-v` | 生成 Gradle 构建文件而不是 Ant，并指定其插件版本 |'
- en: 'An example of command line to create a new project is as follows:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建新项目的命令行示例如下：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`android update project` creates project files from existing sources, as shown
    in the previous tutorial. However, if they already exist it can also upgrade the
    project target to new SDK versions (that is, the `project.properties` file) and
    update the Android SDK location (that is, the `local.properties` file). The available
    flags are slightly different:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android update project` 从现有源代码创建项目文件，如前面的教程所示。然而，如果它们已经存在，它还可以将项目目标升级到新的 SDK
    版本（即 `project.properties` 文件）并更新 Android SDK 位置（即 `local.properties` 文件）。可用的标志略有不同：'
- en: '| Option | Description |'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-l` | Library projects to add |'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-l` | 要添加的库项目 |'
- en: '| `-n` | Project name |'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-n` | 项目名称 |'
- en: '| `-p` | Project path |'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-p` | 项目路径 |'
- en: '| `-t` | Target SDK version |'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-t` | 目标 SDK 版本 |'
- en: '| `-s` | To update projects in subfolders |'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `-s` | 更新子文件夹中的项目 |'
- en: 'We can also append a new library project with the `-l` flag, for example:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以使用 `-l` 标志附加新的库项目，例如：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`android create lib-project` and `android update lib-project` manage library
    projects. These kinds of projects are not well adapted for native C/C++ development,
    especially when it comes to debugging, since NDK has its own way of reusing native
    libraries.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create lib-project` 和 `android update lib-project` 管理库项目。这类项目并不适合原生
    C/C++ 开发，尤其是在调试时，因为 NDK 有自己复用原生库的方式。'
- en: '`android create test-project`, `android update test-project`, and `android
    create uitest-project` manage unit test and UI test projects.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`android create test-project`、`android update test-project` 和 `android create
    uitest-project` 管理单元测试和 UI 测试项目。'
- en: More details about all these options can be found on the Android developer website
    at [http://developer.android.com/tools/help/android.html](http://developer.android.com/tools/help/android.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有这些选项的更多详细信息可以在 Android 开发者网站找到，网址为 [http://developer.android.com/tools/help/android.html](http://developer.android.com/tools/help/android.html)。
- en: Compiling native code with NDK-Build
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NDK-Build 编译原生代码
- en: 'After generating project files, we then compile our first native C/C++ library
    (also called *module*) using `ndk-build`. This command, the most essential one
    to know for NDK development, is basically a Bash script, which:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生成项目文件后，我们使用 `ndk-build` 编译第一个原生 C/C++ 库（也称为*模块*）。这个命令是 NDK 开发中最需要了解的基本命令，它实际上是一个
    Bash 脚本，可以：
- en: Sets up the Android native compilation toolchain based on either GCC or CLang.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 GCC 或 CLang 设置 Android 原生编译工具链。
- en: 'Wraps `Make` to control native code construction with the help of user-defined
    `Makefiles`: `Android.mk` and optional `Application.mk`. By default, `NDK-`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装 `Make` 以控制原生代码构建，借助用户定义的 `Makefiles`：`Android.mk` 和可选的 `Application.mk`。默认情况下，`NDK-`
- en: '`Build` looks for in the `jni` project directory, where native C/C++ are often
    located by convention.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build`会在`jni`项目目录中查找，按照惯例本地C/C++代码通常位于此处。'
- en: 'NDK-Build generates intermediate object files from C/C++ source files (in the
    `obj` directory) and produces the final binary library (`.so`) in the `libs` directory.
    NDK-related build files can be erased with the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NDK-Build从C/C++源文件（在`obj`目录中）生成中间对象文件，并在`libs`目录中生成最终的二进制库（`.so`）。可以通过以下命令删除与NDK相关的构建文件：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For more information about NDK-Build and Makefiles, see [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NDK-Build和Makefiles的更多信息，请参阅[第9章](ch09.html "第9章. 将现有库迁移到Android")，*将现有库迁移到Android*。
- en: Building and packaging an application with Ant
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ant构建和打包应用程序
- en: 'An Android application is not composed of native C/C++ code only, but also
    of Java code. Thus, we have:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Android应用程序不仅仅由本地C/C++代码组成，还包括Java代码。因此，我们有：
- en: Built Java sources located in the `src` directory with `Javac`(Java Compiler).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Javac`(Java编译器)编译位于`src`目录中的Java源文件。
- en: Dexed generated Java bytecode, that is, transforming it into Android Dalvik
    or ART bytecode with DX. Indeed, both Dalvik and ART Virtual Machines (more about
    these later in this chapter) operate on a specific bytecode, which is stored in
    an optimized format called **Dex**.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dexed生成的Java字节码，即使用DX将其转换为Android Dalvik或ART字节码。实际上，Dalvik和ART虚拟机（关于这些内容将在本章后面介绍）都基于一种特定的字节码运行，这种字节码以优化的格式存储，称为**Dex**。
- en: Packaged Dex files, Android manifest, resources (images, and so on), and native
    libraries in the final APK file with AAPT, also known as the **Android Asset Packaging
    Tool**.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AAPT打包Dex文件、Android清单、资源（如图片等）以及最终的APK文件中的本地库，AAPT也称为**Android资源打包工具**。
- en: 'All these operations are summarized in one call to Ant: `ant debug`. The result
    is an APK packaged in debug mode and generated in the `bin` directory. Other build
    modes are available (for example, release mode) and can be listed with `ant help`.
    If you would like to erase temporary Java-related build files (for example, the
    `Java .class`), then simply run the following command line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都可以通过一个Ant命令汇总：`ant debug`。结果是在`bin`目录中生成一个调试模式的APK。其他构建模式也可用（例如，发布模式），可以通过`ant
    help`列出。如果你想删除与Java相关的临时构建文件（例如，`Java .class`文件），只需运行以下命令行：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Deploying an application package with Ant
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ant部署应用程序包
- en: 'A packaged application can be deployed as is with Ant through **ADB**. The
    available options for deployment are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ant通过**ADB**可以部署打包的应用程序。可用的部署选项如下：
- en: '`ant installd` for debug mode'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ant installd` 用于调试模式'
- en: '`ant installr` for release mode'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ant installr` 用于发布模式'
- en: 'Beware that an APK cannot overwrite an older APK of the same application if
    they come from a different source. In such a case, remove the previous application
    first by executing the following command line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果来自不同来源的同一应用程序的旧APK不能被新APK覆盖。在这种情况下，首先通过执行以下命令行删除先前的应用程序：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Installation and uninstallation can also be performed directly through ADB,
    for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和卸载也可以直接通过ADB执行，例如：
- en: '`adb install` <path to application APK>: For installing an application for
    the first time (for example, `bin/DemoActivity-debug.apk` for our sample).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb install` <应用程序APK的路径>：用于首次安装应用程序（例如，对于我们示例中的`bin/DemoActivity-debug.apk`）。'
- en: '`adb install -r` <path to application APK>: For reinstalling an application
    and to keep its data stored on the device.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb install -r` <应用程序APK的路径>：用于重新安装应用程序并保留设备上的数据。'
- en: '`adb uninstall` <application package name>: For uninstalling an application
    identified by its Application package name (for example, `com.example.SanAngeles`
    for our sample).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb uninstall` <应用程序包名>：用于卸载通过应用程序包名标识的应用程序（例如，对于我们示例中的`com.example.SanAngeles`）。'
- en: Launching an application with ADB Shell
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ADB Shell启动应用程序
- en: 'Finally, we launched the application thanks to the **Activity Manager** (**AM**).
    AM command parameters that are used to start San Angeles come from the `AndroidManifest.xml`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过**活动管理器**（**AM**）启动了应用程序。用于启动San Angeles的AM命令参数来自`AndroidManifest.xml`文件：
- en: '`com.example.SanAngeles` is the application package name (the same we use to
    uninstall an application as previously shown).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.example.SanAngeles` 是应用程序包名（与我们之前展示的卸载应用程序时使用的相同）。'
- en: '`com.example.SanAngeles.DemoActivity` is the launched Activity canonical class
    name (that is, a simple class name concatenated to its package). Here is a brief
    example of how these are used:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.example.SanAngeles.DemoActivity`是启动活动的规范类名（即简单类名与其包名相连）。以下是如何使用它们的一个简短示例：'
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because it is located on your device, AM needs to be run through ADB. To do
    so, the latter features a limited Unix-like shell, which features some classic
    commands such as `ls`, `cd`, `pwd`, `cat`, `chmod`, or `ps` as well as a few Android
    specific ones as shown in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为AM位于你的设备上，所以需要通过ADB来运行。为此，ADB提供了一个有限的类Unix shell，它包含一些经典命令，如`ls`、`cd`、`pwd`、`cat`、`chmod`或`ps`以及一些Android特有的命令，如下表所示：
- en: '| `am` | The Activity Manager which not only starts Activities but can also
    kill them, broadcast intent, start/stop profiler, and so on. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `am` | 活动管理器不仅可以启动活动，还可以杀死活动，广播意图，开始/停止分析器等。 |'
- en: '| `dmesg` | To dump kernel messages. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `dmesg` | 用于转储内核信息。 |'
- en: '| `dumpsys` | To dump the system state. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `dumpsys` | 用于转储系统状态。 |'
- en: '| `logcat` | To display device log messages. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `logcat` | 用于显示设备日志信息。 |'
- en: '| `run-as <user id> <command>` | To run a command with the `user id` privilege.
    `user id` can be an application package name, which gives access to application
    files (for example, `run-as com.example.SanAngeles ls`). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `run-as <用户id> <命令>` | 使用`用户id`权限运行命令。`用户id`可以是应用程序包名，这可以访问应用程序文件（例如，`run-as
    com.example.SanAngeles ls`）。 |'
- en: '| `sqlite3 <db file>` | To open an SQLite Database (it can be combined with
    `run-as`). |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite3 <db文件>` | 用于打开SQLite数据库（可以与`run-as`结合使用）。 |'
- en: 'ADB can be started in one of the following ways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ADB可以通过以下方式之一启动：
- en: With a command in parameter, as shown in step 5 with AM, in which case Shell
    runs a single command and immediately exits.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数中的命令，如步骤5中的AM所示，在这种情况下，Shell运行单个命令并立即退出。
- en: With the `adb shell` command without a parameter, in which case you can use
    it as a classic Shell (and, for example, call `am` and any other command).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不带参数的`adb shell`命令，你可以将其作为一个经典Shell使用（例如，调用`am`和其他任何命令）。
- en: ADB Shell is a real '*Swiss Army knife*', which allows advanced manipulations
    on your device, especially with the root access. For example, it becomes possible
    to observe applications deployed in their "sandbox" directory (that is, the `/data/data`
    directory) or to list and kill the currently running processes. Without root access
    to your phone, possible actions are more limited. For more information, have a
    look at [http://developer.android.com/tools/help/adb.html](http://developer.android.com/tools/help/adb.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ADB Shell是一个真正的'*瑞士军刀*'，它允许你在设备上进行高级操作，特别是有了root权限。例如，可以观察部署在“沙箱”目录中的应用程序（即`/data/data`目录）或者列出并杀死当前运行中的进程。如果没有手机的root权限，可能执行的操作会更有限。更多信息请查看[http://developer.android.com/tools/help/adb.html](http://developer.android.com/tools/help/adb.html)。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you know a bit about the Android ecosystem, you may have heard about rooted
    phones and non-rooted phones. **Rooting** a phone means getting administrative
    privilege, generally using hacks. Rooting a phone is useful to install a custom
    ROM version (optimized or modified, for example, **Cyanogen**) or to perform any
    sort of (especially dangerous) manipulations that a root user can do (for example,
    accessing and deleting any file). Rooting is not an illegal operation as such,
    as you are modifying YOUR device. However, not all manufacturers appreciate this
    practice, which usually voids the warranty.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解一些关于Android生态系统的知识，你可能听说过已root的手机和未root的手机。**Root**手机意味着获取管理员权限，通常使用破解方法。Root手机可以用来安装自定义的ROM版本（例如优化或修改过的**Cyanogen**）或者执行任何root用户能做的（尤其是危险的）操作（例如访问和删除任何文件）。Root本身并不是非法操作，因为你是在修改自己的设备。然而，并不是所有制造商都欣赏这种做法，这通常会使得保修失效。
- en: More about Android tooling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于Android工具的信息
- en: Building San Angeles sample application gives you a glimpse of what Android
    tools can do. However, behind their somewhat 'rustic' look, more is possible.
    Information can be found on the Android developer website at [http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构建San Angeles示例应用程序可以让你一窥Android工具的能力。然而，在它们略显'原始'的外观背后，还有更多可能性。你可以在Android开发者网站找到更多信息，网址是[http://developer.android.com/tools/help/index.html](http://developer.android.com/tools/help/index.html)。
- en: Creating your first native Android project
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个本地Android项目
- en: In the first part of the chapter, we saw how to use Android command-line tools.
    However, developing with Notepad or VI is not really attractive. Coding should
    be fun! And to make it so, we need our preferred IDE to perform boring or unpractical
    tasks. So now we will see how to create a native Android project using Eclipse.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们了解了如何使用Android命令行工具。然而，使用Notepad或VI进行开发并不吸引人。编程应该是乐趣！为了使之有趣，我们需要我们喜欢的IDE来执行无聊或不实用的任务。现在，我们将了解如何使用Eclipse创建一个本地Android项目。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目结果名为`Store_Part1`。
- en: Time for action – creating a native Android project
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作时间——创建一个本地Android项目
- en: 'Eclipse provides a wizard to help us set up our project:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse提供了一个向导来帮助我们设置项目：
- en: Launch Eclipse. In the main menu, go to **File** | **New** | **Project…**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse。在主菜单中，前往**File** | **New** | **Project…**。
- en: Then, in the opened **New project** wizard, **go to Android** | **Android Application
    Project** and click on **Next**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在打开的**New project**向导中，选择**Android** | **Android Application Project**并点击**Next**。
- en: In the next screen, enter project properties as follows and click on **Next**
    again:![Time for action – creating a native Android project](img/1529_02_01.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕中，按如下所示输入项目属性并再次点击**Next**：![Time for action – creating a native Android
    project](img/1529_02_01.jpg)
- en: Click on **Next** twice, leaving default options, to go to the **Create activity**
    wizard screen. Select **Blank activity with Fragment** and click on **Next**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Next**两次，保留默认选项，以进入**Create activity**向导屏幕。选择**Blank activity with Fragment**并点击**Next**。
- en: Finally, in the **Blank Activity** screen, enter activity properties as follows:![Time
    for action – creating a native Android project](img/1529_02_02.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**Blank Activity**屏幕中，按如下方式输入活动属性：![Time for action – creating a native
    Android project](img/1529_02_02.jpg)
- en: Click on **Finish** to validate. After a few seconds, the wizard disappears
    and the project **Store** is displayed in Eclipse.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Finish**以验证。几秒钟后，向导消失，Eclipse中会显示项目**Store**。
- en: Add native C/C++ support to the project. Select the project **Store** in the
    **Package Explorer** view and from its right-click context menu, go to **Android
    Tools** | **Add Native Support...**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为项目添加本地C/C++支持。在**Package Explorer**视图中选择项目**Store**，并从其右键菜单中选择**Android Tools**
    | **Add Native Support...**。
- en: In the opened **Add Android Native Support** popup, set the library name to
    `com_packtpub_store_Store` and click on **Finish**.![Time for action – creating
    a native Android project](img/1529_02_03.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的**Add Android Native Support**弹出窗口中，将库名称设置为`com_packtpub_store_Store`并点击**Finish**。![Time
    for action – creating a native Android project](img/1529_02_03.jpg)
- en: The `jni` and `obj` directories are created in the project directory. The first
    directory contains one makefile `Android.mk` and one C++ source file `com_packtpub_store_Store.cpp`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目目录中创建了`jni`和`obj`目录。第一个目录包含一个makefile `Android.mk`和一个C++源文件 `com_packtpub_store_Store.cpp`。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After adding native support, Eclipse may automatically switch your perspective
    to C/C++. Therefore, in case your development environment does not look as usual,
    simply check your perspective in the Eclipse's top-right corner. You can work
    on an NDK project from either a Java or C/C++ perspective without any trouble.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加本地支持后，Eclipse可能会自动将你的视角切换到C/C++。因此，如果你的开发环境看起来与平时不同，只需检查Eclipse右上角的角度即可。你可以从Java或C/C++的角度无障碍地处理NDK项目。
- en: 'Create a new Java class `Store` in `src/com/packtpub/store/Store.java`. From
    within a static block, load the `com_packtpub_store_Store` native library:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/com/packtpub/store/`目录下创建一个新的Java类`Store.java`。从静态代码块中加载`com_packtpub_store_Store`本地库：
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Edit `src/com/packtpub/store/StoreActivity.java`. Declare and initialize a
    new instance of `Store` in activity''s `onCreate()`. Since we do not need them,
    remove the `onCreateOptionsMenu()` and `onOptionsItemSelected()` methods that
    may have been created by the Eclipse project creation wizard:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/com/packtpub/store/StoreActivity.java`。在活动的`onCreate()`中声明并初始化`Store`的新实例。由于我们不需要它们，可以删除可能由Eclipse项目创建向导创建的`onCreateOptionsMenu()`和`onOptionsItemSelected()`方法：
- en: '[PRE12]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Connect your device or emulator and launch the application. Select `Store` in
    the **Package Explorer** view and then navigate to **Run** | **Run As** | **Android
    Application** from the Eclipse main menu. Alternatively, click on the **Run**
    button in the Eclipse toolbar.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接你的设备或模拟器并启动应用程序。在**Package Explorer**视图中选择`Store`，然后从Eclipse主菜单导航至**Run**
    | **Run As** | **Android Application**。或者，点击Eclipse工具栏中的**Run**按钮。
- en: Select the application type **Android Application** and click on **OK** to get
    the following screen:![Time for action – creating a native Android project](img/1529_02_04.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择应用程序类型 **Android Application** 并点击 **OK**，进入以下界面：![行动时间——创建原生 Android 项目](img/1529_02_04.jpg)
- en: '*What just happened?*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In only a few steps, our first native Android project has been created and launched
    thanks to Eclipse.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个步骤中，我们的第一个原生 Android 项目已经通过 Eclipse 创建并启动了。
- en: The Android project creation wizard helps get you started quickly. It generates
    the minimum code for a simple Android application. However, by default, new Android
    projects support Java and only Java.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android 项目创建向导可以帮助你快速入门。它生成了一个简单 Android 应用程序所需的最小代码。然而，默认情况下，新的 Android 项目只支持
    Java 语言。
- en: 'With the help of ADT, an Android Java project is easily turned into a hybrid
    project with native C/C++ support. It generates the minimum files necessary for
    an NDK-Build to compile a native library:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 借助 ADT，一个 Android Java 项目可以轻松地转变为支持原生 C/C++ 的混合项目。它生成了 NDK-Build 编译原生库所需的最小文件：
- en: '`Android.mk` is a Makefile describing which source files to compile and how
    to generate the final native library.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Android.mk` 是一个 Makefile，描述了要编译哪些源文件以及如何生成最终的原生库。'
- en: '`com_packtpub_store_Store.cpp` is an almost empty file containing a single
    include. We are going to explain this in the next part of this chapter.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`com_packtpub_store_Store.cpp` 是一个几乎为空的文件，包含了一个单一的包含指令。我们将在本章的下一部分解释这一点。'
- en: Once the project is set up, dynamically loading a native library is done in
    a single call to `System.loadLibrary()`. This is easily done in a static block,
    which ensures that the library is loaded once and for all, before a class is initialized.
    Beware that this works only if the container class is loaded from a single Java
    ClassLoader (which is usually the case).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目设置完成后，动态加载原生库只需调用一次 `System.loadLibrary()`。这很容易在一个静态块中完成，确保在类初始化之前一次性加载库。请注意，这只有在容器类是从单个
    Java 类加载器加载时才有效（通常情况下是这样的）。
- en: Working with an IDE like Eclipse really offers a huge productivity boost and
    makes programming much more comfortable! But if you are a command-line aficionado
    or would like to train your command-line skills, the first part, *Building NDK
    sample applications*, can easily be applied here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Eclipse 这样的 IDE 真的可以大幅提高生产效率，让编程变得更加舒适！但如果你是一个命令行爱好者，或者想要锻炼你的命令行技能，那么第一部分，*构建
    NDK 示例应用程序*，可以很容易地应用在这里。
- en: Introducing Dalvik and ART
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 Dalvik 和 ART。
- en: It is not possible to talk about Android without mentioning a few words about
    **Dalvik** and **ART**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 说到 Android，不得不提一下 **Dalvik** 和 **ART**。
- en: Dalvik is a **Virtual Machine** on which the Dex bytecode is interpreted (not
    native code!). It is at the core of any application running on Android. Dalvik
    has been conceived to fit the constrained requirements of mobile devices. It is
    specifically optimized to use less memory and CPU. It sits on top of the Android
    kernel, which provides the first layer of abstraction over the hardware (process
    management, memory management, and so on).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik 是一个 **虚拟机**，在其中解释 Dex 字节码（不是原生代码！）。它是任何在 Android 上运行的应用程序的核心。Dalvik 被设计为符合移动设备的限制性要求。它特别优化以使用更少的内存和
    CPU。它位于 Android 内核之上，内核为硬件提供了第一层抽象（进程管理、内存管理等）。
- en: ART is the new Android runtime environment, which has replaced Dalvik since
    the Android 5 Lollipop. It has improved performances a lot compared to Dalvik.
    Indeed, where Dalvik interprets bytecode `Just-In-Time` upon application startup,
    ART, on the other hand, precompiles bytecode `Ahead-Of-Time` into native code
    during application installation. ART is backward compatible with applications
    packaged for former Dalvik VMs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ART 是新的 Android 运行时环境，自 Android 5 Lollipop 起取代了 Dalvik。与 Dalvik 相比，它大大提高了性能。实际上，Dalvik
    在应用程序启动时 `即时` 解释字节码，而 ART 则是在应用程序安装期间 `提前` 将字节码预编译成原生代码。ART 与为早期 Dalvik 虚拟机打包的应用程序向后兼容。
- en: Android has been designed with speed in mind. Because most users do not want
    to wait for their application to be loaded while others are still running, the
    system is able to instantiate multiple Dalvik or ART VMs quickly, thanks to the
    **Zygote** process. Zygote, (whose name comes from the very first biologic cell
    of an organism from which daughter cells get reproduced), starts when the system
    boots up. It preloads (or "warms up") all core libraries shared among applications
    as well as the Virtual Machine instance. To launch a new application, Zygote is
    simply forked and the initial Dalvik instance gets copied as a consequence. Memory
    consumption is lowered by sharing as many libraries as possible between processes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Android在设计时考虑了速度。因为大多数用户不希望在等待应用程序加载的同时，其他应用程序仍在运行，因此系统能够快速实例化多个Dalvik或ART VM，这要归功于**Zygote**进程。Zygote（其名称来自生物体中第一个生物细胞，从中产生子细胞）在系统启动时开始运行。它预加载（或“预热”）所有应用程序共享的核心库以及虚拟机实例。要启动新应用程序，只需分叉Zygote，初始Dalvik实例因此被复制。通过尽可能多地共享进程之间的库，降低内存消耗。
- en: Dalvik and ART are themselves made of native C/C++ code compiled for the target
    Android platform (ARM, X86, and so on). This means that interfacing these VMs
    with native C/C++ libraries is easily possible provided that it is compiled with
    the same **Application Binary Interface** (**ABI**) (which basically describes
    the application or library binary format). This is the role devoted to the Android
    NDK. For more information, have a look at the **Android Open Source Project**
    (**AOSP**), that is, the Android source code at [https://source.android.com/](https://source.android.com/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik和ART本身是由为目标Android平台（ARM、X86等）编译的原生C/C++代码构成的。这意味着，只要使用相同的**应用程序二进制接口**（**ABI**）（它基本上描述了应用程序或库的二进制格式），就可以轻松地将这些虚拟机与原生C/C++库进行接口交互。这就是Android
    NDK的作用。更多信息，请查看**Android开源项目**（**AOSP**），即Android源代码，在[https://source.android.com/](https://source.android.com/)。
- en: Interfacing Java with C/C++
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java与C/C++接口
- en: Native C/C++ code has the ability to unleash the power of your application.
    To do so, Java code needs to invoke and run its native counterpart. In this part,
    we are going to interface Java and native C/C++ code together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原生C/C++代码能够释放应用程序的强大功能。为此，Java代码需要调用并运行其原生对应部分。在本部分，我们将把Java和原生C/C++代码接口在一起。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part2`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`Store_Part2`。
- en: Time for action – calling C code from Java
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 从Java调用C代码
- en: 'Let''s create our first native method and call it from the Java side:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个原生方法，并从Java端调用它：
- en: 'Open `src/com/packtpub/store/Store.java` and declare one native method to query
    the `Store`. This method returns `int` with the number of entries in it. There
    is no need to define a method body:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/com/packtpub/store/Store.java`文件，并为`Store`声明一个查询原生方法。此方法返回`int`类型的条目数量。无需定义方法体：
- en: '[PRE13]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open `src/com/packtpub/store/StoreActivity.java` and initialize the store.
    Use its `getCount()` method value to initialize the application title:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/com/packtpub/store/StoreActivity.java`文件，并初始化商店。使用其`getCount()`方法的值来初始化应用程序标题：
- en: '[PRE14]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generate a JNI header file from the `Store` class. Go to the Eclipse main menu
    and go to **Run** | **External Tools** | **External Tools Configurations…**. Create
    a new **Program** configuration with the following parameters described in the
    following screenshot:![Time for action – calling C code from Java](img/1529_02_05.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Store`类生成JNI头文件。转到Eclipse主菜单，选择**运行** | **外部工具** | **外部工具配置…**。使用以下参数创建一个新的**程序**配置，如下截图所示：![行动时间
    - 从Java调用C代码](img/1529_02_05.jpg)
- en: '**Location** refers to the `javah` absolute path, which is OS specific. On
    Windows, you can enter `${env_var:JAVA_HOME}\bin\javah.exe`. On Mac OS X and Linux,
    it is usually `/usr/bin/javah`.'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**位置**指的是`javah`的绝对路径，这是特定于操作系统的。在Windows上，你可以输入`${env_var:JAVA_HOME}\bin\javah.exe`。在Mac
    OS X和Linux上，通常是`/usr/bin/javah`。'
- en: 'In the **Refresh** tab, check **Refresh resources upon completion** and select
    **Specific resources**. Using the **Specify Resources…** button, select the `jni`
    folder. Finally, click on **Run** to execute `javah`. A new file `jni/com_packtpub_store_Store.h`
    will then be generated. This contains a prototype for the native method `getCount()`
    expected on the Java side:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**刷新**标签中，勾选**完成后刷新资源**，并选择**特定资源**。使用**指定资源…**按钮，选择`jni`文件夹。最后，点击**运行**以执行`javah`。然后会生成一个名为`jni/com_packtpub_store_Store.h`的新文件。这包含了Java端期望的原生方法`getCount()`的原型：
- en: '[PRE15]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now implement `jni/com_packtpub_store_Store.cpp` so that it returns
    `0` when invoked. The method signature originates from the generated header file
    (you can replace any previous code) except that the parameter names have been
    explicitly specified:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以实现在`jni/com_packtpub_store_Store.cpp`中的方法，使其在调用时返回`0`。方法签名来自生成的头文件（你可以替换之前的任何代码），不过这里明确指定了参数名称：
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and run the application.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Java now talks C/C++! In the previous part, we created a hybrid Android project.
    In this part, we interfaced Java with native code. This cooperation is established
    through **Java Native Interfaces** (**JNI**). JNI is the bridge, which binds Java
    to C/C++. This occurs in three main steps.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Java现在可以与C/C++对话了！在上一部分，我们创建了一个混合Android项目。在这一部分，我们通过Java本地接口（JNI）将Java与本地代码接口。这种合作是通过**Java
    Native Interfaces**（**JNI**）建立的。JNI是连接Java与C/C++的桥梁。这个过程主要分为三个步骤。
- en: 'Defining native method prototypes on the Java side, marked with the native
    keyword. Such methods have no body, like an abstract method, because they are
    implemented on the native side. Native methods can have parameters, a return value,
    visibility (private, protected, package protected, or public), and can be static:
    such as the usual Java methods.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java端定义本地方法原型，使用native关键字标记。这些方法没有方法体，就像抽象方法一样，因为它们是在本地端实现的。本地方法可以有参数、返回值、可见性（私有、保护、包保护或公共），并且可以是静态的：就像普通的Java方法一样。
- en: Native methods can be called from anywhere in Java code, provided that containing
    a native library has been loaded before they are called. Failure to do so results
    in an exception of type `java.lang.UnsatisfiedLinkError`, which is raised when
    the native method is invoked for the first time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法可以在Java代码的任何地方被调用，前提是在调用之前已经加载了包含本地库。如果未能做到这一点，将会抛出类型为`java.lang.UnsatisfiedLinkError`的异常，这个异常是在首次调用本地方法时产生的。
- en: Using `javah` to generate a header file with corresponding native C/C++ prototypes.
    Although it is not compulsory, the `javah` tool provided by the JDK is extremely
    useful to generate native prototypes. Indeed, the JNI convention is tedious and
    error-prone (more about this in [Chapter 3](ch03.html "Chapter 3. Interfacing
    Java and C/C++ with JNI"), *Interfacing Java and C/C++ with JNI*). The JNI code
    is generated from the `.class` file, which means your Java code must be compiled
    first.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`javah`生成一个带有相应本地C/C++原型的头文件。尽管这不是强制的，但JDK提供的`javah`工具对于生成本地原型非常有用。实际上，JNI约定既繁琐又容易出错（关于这一点在[第3章](ch03.html
    "第3章. 使用JNI接口Java和C/C++")，*使用JNI接口Java和C/C++*中有更多介绍）。JNI代码是从`.class`文件生成的，这意味着你的Java代码必须首先被编译。
- en: Writing native C/C++ code implementation to perform expected operations. Here,
    we simply return `0` when the `Store` library is queried. Our native library is
    compiled in the `libs/armeabi` directory (the one for ARM processors) and is named
    `libcom_packtpub_store_Store.so`. Temporary files generated during compilation
    are located in the `obj/local` directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 编写本地C/C++代码实现以执行预期操作。在这里，当查询`Store`库时，我们简单地返回`0`。我们的本地库在`libs/armeabi`目录（针对ARM处理器的目录）中编译，并命名为`libcom_packtpub_store_Store.so`。编译过程中生成的临时文件位于`obj/local`目录中。
- en: Despite its apparent simplicity, interfacing Java with C/C++ is much more involved
    than what it seems superficially. How to write JNI code on the native side is
    explored in more detail in [Chapter 3](ch03.html "Chapter 3. Interfacing Java
    and C/C++ with JNI"), *Interfacing Java and C/C++ with JNI*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表面看起来很简单，但将Java与C/C++接口比看上去要复杂得多。在[第3章](ch03.html "第3章. 使用JNI接口Java和C/C++")，*使用JNI接口Java和C/C++*中，将更详细地探讨如何在本地端编写JNI代码。
- en: Debugging native Android applications
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试本地Android应用程序
- en: 'Before diving deeper into JNI, there is one last important tool that any Android
    developer needs to know how to use: the **Debugger**. The official NDK one is
    the GNU Debugger also known as **GDB**.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨JNI之前，还有一个任何Android开发者都需要知道如何使用的最后一个重要工具：**调试器**。官方NDK提供的调试器是GNU调试器，也称为**GDB**。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part3`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`Store_Part3`。
- en: Time for action – debugging a native Android application
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——调试一个本地Android应用程序
- en: 'Create file `jni/Application.mk` with the following content:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`jni/Application.mk`，内容如下：
- en: '[PRE17]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These are not the only ABIs provided by the NDK; more processor architectures
    such as MIPS or variants such as 64 bits or hard floats exist. The ones used here
    are the main ones you should be concerned with. They can easily be tested on an
    emulator.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些并不是NDK提供的唯一ABI；还有更多的处理器架构，如MIPS或变体如64位或硬浮点。这里使用的这些是你应该关注的主要架构。它们可以轻松地在模拟器上进行测试。
- en: Open **Project Properties**, go to **C/C++ Build**, uncheck **Use default build
    command** and enter `ndk-build NDK_DEBUG=1`:![Time for action – debugging a native
    Android application](img/1529_02_06.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**项目属性**，进入**C/C++构建**，取消勾选**使用默认构建命令**并输入`ndk-build NDK_DEBUG=1`:![行动时间——调试本地Android应用程序](img/1529_02_06.jpg)
- en: In `jni/com_packtpub_store_Store.cpp`, place a breakpoint inside the `Java_com_packtpub_store_Store_getCount()`method
    by double-clicking on the Eclipse editor gutter.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_store_Store.cpp`中，通过在Eclipse编辑器边栏双击，在`Java_com_packtpub_store_Store_getCount()`方法内部设置一个断点。
- en: Select the `Store` project in the **Package Explorer** or **Project Explorer**
    view and go to **Debug As** | **Android Native Application**. The application
    starts, but you will probably find that nothing happens. Indeed, the breakpoint
    is likely to be reached before the GDB Debugger could attach to the application
    process.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**包浏览器**或**项目浏览器**视图中选择`Store`项目，并选择**调试为** | **Android本地应用程序**。应用程序开始运行，但可能会发现什么也没有发生。实际上，在GDB调试器能够附加到应用程序进程之前，很可能会达到断点。
- en: Leave the application and reopen it from your device application menu. This
    time, Eclipse stops at the native breakpoint. Look at your device screen. The
    UI should be frozen because the main application thread is paused in native code.![Time
    for action – debugging a native Android application](img/1529_02_08.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开应用程序，并从你的设备应用菜单重新打开它。这次，Eclipse会在本地断点处停止。查看你的设备屏幕，UI应该已经冻结，因为主应用程序线程在本地代码中暂停了。![行动时间——调试本地Android应用程序](img/1529_02_08.jpg)
- en: Inspect variables in the **Variables** view and check the call stack in the
    **Debug** view. In the **Expressions** view, enter `*pEnv.functions` and open
    result expression to see the various functions provided by the `JNIEnv` object.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**变量**视图中检查变量，并在**调试**视图中查看调用堆栈。在**表达式**视图中输入`*pEnv.functions`并打开结果表达式，以查看`JNIEnv`对象提供的各种函数。
- en: '**Step Over** current instruction from the Eclipse toolbar or with the shortcut,
    *F6* (you can also use **Step Into** with the shortcut, *F7*). The following instructions
    will be highlighted:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Eclipse工具栏或快捷键*F6*来**单步跳过**当前指令（也可以使用快捷键*F7*进行**单步进入**）。以下指令将被高亮：
- en: '**Resume** the execution from the Eclipse toolbar or with the shortcut, *F8*.
    The application screen is displayed on your device again.'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Eclipse工具栏或快捷键*F8*来**恢复**执行。应用程序界面将再次显示在你的设备上。
- en: '**Terminate** the application from the Eclipse toolbar or with the shortcut,
    *Ctrl*+*F2*. The application is killed and the **Debug** view is emptied.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Eclipse工具栏或快捷键*Ctrl*+*F2*来**终止**应用程序。应用程序被杀死，**调试**视图会被清空。
- en: '*What just happened?*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This useful productivity tool that is a debugger is now an asset in our toolbox.
    We can easily stop or resume program execution at any point, step into, over or
    out of native instructions, and inspect any variable. This ability is made available
    to developers thanks to NDK-GDB, which is a wrapper script around the command-line
    debugger GDB (which can be cumbersome to use by hand). Hopefully, GDB is supported
    by Eclipse CDT and by extension Eclipse ADT.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有用的生产力工具——调试器，现在是我们工具箱中的资产。我们可以轻松地在任何点停止或恢复程序执行，单步进入、跳过或离开本地指令，并检查任何变量。这种能力得益于NDK-GDB，它是命令行调试器GDB（手动使用可能比较麻烦）的包装脚本。幸运的是，GDB得到了Eclipse
    CDT的支持，进而也得到了Eclipse ADT的支持。
- en: On Android, and more generally on embedded devices, GDB is configured in client/server
    mode, while a program runs on a device as a server (`gdbserver`, which is generated
    by NDK-Build in the `libs` directory). A remote client, that is, a developer's
    workstation with Eclipse, connects and sends remote debugging commands to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统上，以及更普遍的嵌入式设备上，GDB被配置为客户端/服务器模式，而程序作为服务器在设备上运行（`gdbserver`，它是由NDK-Build在`libs`目录中生成的）。远程客户端，即开发者的工作站上的Eclipse，连接并发送远程调试命令。
- en: Defining NDK application-wide settings
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义NDK全应用设置
- en: 'To help NDK-Build and NDK-GDB do their work, we created a new `Application.mk`
    file. This file should be considered as a global Makefile defining application-wide
    compilation settings, such as the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助NDK-Build和NDK-GDB完成它们的工作，我们创建了一个新的`Application.mk`文件。这个文件应被视为一个全局Makefile，定义了应用程序范围的编译设置，例如以下内容：
- en: '`APP_PLATFORM`: Android API that the application targets. This information
    should be a duplication of `minSdkVersion` in the `AndroidManifest.xml` file.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_PLATFORM`：应用程序针对的Android API。这个信息应该是`AndroidManifest.xml`文件中`minSdkVersion`的重复。'
- en: '`APP_ABI`: CPU architectures that the application targets. An Application Binary
    Interface specifies the binary code format (instruction set, calling conventions,
    and so on) that makes executable and library binaries. ABIs are thus strongly
    related to processors. ABI can be tweaked with additional settings such as `LOCAL_ARM_CODE`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_ABI`：应用程序针对的CPU架构。应用程序二进制接口指定了可执行文件和库二进制文件的二进制代码格式（指令集、调用约定等）。ABIs因此与处理器密切相关。可以通过额外的设置，如`LOCAL_ARM_CODE`来调整ABI。'
- en: 'The main ABIs that are currently supported by the Android NDK are as shown
    in the following table:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Android NDK支持的主要ABI如下表所示：
- en: '| **armeabi** | This is the default option, which should be compatible with
    all ARM devices. Thumb is a special instruction set that encodes instructions
    on 16 bits instead of 32 to improve code size (useful for devices with constrained
    memory). The instruction set is severely restricted compared to ArmEABI. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi** | 这是默认选项，应该与所有ARM设备兼容。Thumb是一种特殊的指令集，它将指令编码为16位而不是32位，以提高代码大小（对于内存受限的设备很有用）。与ArmEABI相比，指令集受到严重限制。'
- en: '| **armeabi****with LOCAL_ARM_CODE = arm** | (Or Arm v5) Should run on all
    ARM devices. Instructions are encoded on 32 bits but may be more concise than
    Thumb code. Arm v5 does not support advanced extensions such as floating point
    acceleration and is thus slower than Arm v7. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi**（当`LOCAL_ARM_CODE = arm`时） | （或ARM v5）应该能在所有ARM设备上运行。指令编码为32位，但可能比Thumb代码更简洁。ARM
    v5不支持浮点加速等高级扩展，因此比ARM v7慢。'
- en: '| **armeabi-v7a** | Supports extensions such as Thumb-2 (similar to Thumb but
    with additional 32-bit instructions) and VFP, plus some optional extensions such
    as NEON. Code compiled for Arm V7 will not run on Arm V5 processors. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi-v7a** | 支持如Thumb-2（类似于Thumb，但增加了额外的32位指令）和VFP等扩展，以及一些可选扩展，如NEON。为ARM
    V7编译的代码不能在ARM V5处理器上运行。'
- en: '| **armeabi-v7a-hard** | This ABI is an extension of the armeabi-v7a that supports
    hardware floats instead of soft floats. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **armeabi-v7a-hard** | 这个ABI是armeabi-v7a的扩展，它支持硬件浮点而不是软浮点。'
- en: '| **arm64-v8a** | This is dedicated to the new 64-bit processor architecture.
    64-bit ARM processors are backward compatible with older ABIs. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **arm64-v8a** | 这是专为新的64位处理器架构设计的。64位ARM处理器向后兼容旧的ABI。'
- en: '| **x86 and x86_64** | For "PC-like" processor architectures (that is, Intel/AMD).
    These are the ABIs used on the emulator in order to get hardware acceleration
    on a PC. Although most Android devices are ARM, some of them are now X86-based.
    The x86 ABI is for 32-bit processors and x86_64 is for 64-bit processors. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **x86 和 x86_64** | 针对类似“PC”的处理器架构（即Intel/AMD）。这些是在模拟器上使用的ABI，以便在PC上获得硬件加速。尽管大多数Android设备是ARM，但其中一些现在基于X86。x86
    ABI用于32位处理器，而x86_64用于64位处理器。'
- en: '| **mips and mips 64** | For processors made by MIPS Technologies, now property
    of Imagination Technologies well-known for the PowerVR graphics processors. Almost
    no device uses these at the time of writing this book. The mips ABI is for 32-bit
    processors and mips64 is for 64-bit processors. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **mips 和 mips64** | 针对由MIPS Technologies制造的处理器设计，现在属于Imagination Technologies，后者以PowerVR图形处理器而闻名。在撰写本书时，几乎没有设备使用这些ABI。mips
    ABI用于32位处理器，而mips64用于64位处理器。'
- en: '| **all, all32 and all64** | This is a shortcut to build an ndk library for
    all 32-bit or 64-bit ABIs. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **all, all32 和 all64** | 这是一个快捷方式，用于为所有32位或64位ABI构建ndk库。'
- en: Each library and intermediate object file is recompiled for each ABI. They are
    stored in their own respective directory which can be found in the `obj` and `libs`
    folders.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库和中间对象文件都会针对每个ABI重新编译。它们存储在各自独立的目录中，可以在`obj`和`libs`文件夹中找到。
- en: A few more flags can be used inside `Application.mk`. We will discover more
    about this in detail in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries
    to Android"), *Porting Existing Libraries to Android*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.mk`内部还可以使用更多的标志。我们将在[第9章](ch09.html "第9章. 将现有库移植到Android")《*将现有库移植到Android*》中详细了解这一点。
- en: The `Application.mk` flags are not the only ones necessary to ensure the NDK
    debugger work; `NDK_DEBUG=1` must also be passed manually to NDK-Build so that
    it compiles Debug binaries and generates GDB setup files (`gdb.setup` and `gdbserver`)
    correctly. Note that this should probably be considered more as a defect in Android
    development tools rather than a real configuration step, since it should normally
    handle the debugging flag automatically.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`标志并不是确保NDK调试器工作的唯一设置；还需要手动传递`NDK_DEBUG=1`给NDK-Build，这样它才能编译调试二进制文件并正确生成GDB设置文件（`gdb.setup`和`gdbserver`）。请注意，这应该更多地被视为Android开发工具的缺陷，而不是一个真正的配置步骤，因为通常它应该能自动处理调试标志。'
- en: NDK-GDB day-to-day
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NDK-GDB的日常使用
- en: Debugger support in the NDK and Eclipse is quite recent and has improved a lot
    among NDK releases (for example, debugging purely native threads was not working
    before). However, although it is now quite usable, debugging on Android can sometimes
    be buggy, unstable, and rather slow (because it needs to communicate with the
    remote Android device).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: NDK和Eclipse中的调试器支持是近期才出现的，并且在NDK的不同版本之间有了很大的改进（例如，之前无法调试纯本地线程）。然而，尽管现在调试器已经相当可用，但在Android上进行调试有时可能会出现错误、不稳定，并且相对较慢（因为它需要与远程的Android设备进行通信）。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: NDK-GDB might sometimes appear crazy and stop at a breakpoint with a completely
    unusual stack trace. This could be related to GDB not being able to correctly
    determine current ABI while debugging. To fix this issue, put only your corresponding
    device ABI in the `APP_ABI` clause and remove or comment any other.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: NDK-GDB有时可能会出现疯狂的现象，在一个完全不正常的堆栈跟踪处停止在断点。这可能与GDB在调试时无法正确确定当前的ABI有关。要解决这个问题，只需在`APP_ABI`子句中放入对应设备的ABI，并移除或注释掉其他的。
- en: 'NDK Debugger can also be tricky to use, such as when debugging native startup
    code. Indeed, GDB does not start fast enough to activate breakpoints. A simple
    way to overcome this problem is to make native code sleep for a few seconds when
    an application starts. To leave GDB enough time to attach an application process,
    we can do, for example, the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: NDK调试器在使用上也可能有些棘手，例如在调试本地启动代码时。实际上，GDB启动不够快，无法激活断点。克服这个问题的简单方法是让本地代码在应用程序启动时暂停几秒钟。为了给GDB足够的时间来附加应用程序进程，我们可以例如这样做：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another solution is to launch a Debug session and then simply leave and re-launch
    the application from your device, as we have seen in the previous tutorial. This
    is possible because the Android application life cycle is such that an application
    survives when it is in the background, until the memory is needed. This trick
    only works if your application does not crash during startup though.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是启动一个调试会话，然后简单地离开并从设备上重新启动应用程序，正如我们在之前的教程中看到的那样。这是可行的，因为Android应用程序的生命周期是这样的：当应用程序在后台时，它会保持存活，直到需要内存。不过，这个技巧只适用于应用程序在启动过程中没有崩溃的情况。
- en: Analyzing native crash dumps
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析本地崩溃转储
- en: 'Every developer has one day experienced an unexpected crash in its application.
    Do not be ashamed, it has happened to all of us. And as a newcomer in Android
    native development, this situation will happen again, many times. Debuggers are
    a tremendous tool to look for problems in your code. Sadly, however they work
    in "real-time", when a program runs. They become sterile with fatal bugs that
    cannot be reproduced easily. Hopefully, there is a tool for that: **NDK-Stack**.
    NDK-Stack helps you read a crash dump to analyze an application''s stack-trace
    at the moment it crashed.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发人员都有过一天在他们的应用程序中遇到意外的崩溃。不要为此感到羞愧，我们所有人都经历过。作为Android本地开发的新手，这种情况还会发生很多次。调试器是查找代码问题的巨大工具。遗憾的是，它们在程序运行时的“实时”工作。面对难以复现的致命错误时，它们变得无效。幸运的是，有一个工具可以解决这个问题：**NDK-Stack**。NDK-Stack可以帮助你读取崩溃转储，以分析应用程序在崩溃那一刻的堆栈跟踪。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Crash`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的示例项目名为`Store_Crash`。
- en: Time for action – analyzing a native crash dump
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——分析一个本地崩溃转储
- en: 'Let''s make our application crash to see how to read a crash dump:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的应用程序崩溃，看看如何读取崩溃转储：
- en: 'Simulate a fatal bug in `jni/com_packtpub_store_Store.cpp`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_store_Store.cpp`中模拟一个致命错误：
- en: '[PRE19]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open the **LogCat** view in Eclipse, select the **All Messages (no filter)**
    option, and then run the application. A crash dump appears in the logs. This is
    not pretty! If you look carefully through it, you should find a `backtrace` section
    with a snapshot of the call-stack at the moment the application crashed. However,
    it does not give the line of code involved:![Time for action – analyzing a native
    crash dump](img/1529_02_07.jpg)
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Eclipse 中打开 **LogCat** 视图，选择 **所有消息（无筛选）** 选项，然后运行应用程序。日志中出现了崩溃转储。这看起来不美观！如果你仔细查看，应该能在其中找到带有应用程序崩溃时刻调用栈快照的
    `backtrace` 部分。然而，它没有给出涉及的代码行：![行动时间 – 分析原生崩溃转储](img/1529_02_07.jpg)
- en: 'From a command-line prompt, go to the project directory. Find the line of code
    implied in the crash by running NDK-Stack with `logcat` as the input. NDK-Stack
    needs the `obj` files corresponding to the device ABI on which the application
    crashed, for example:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行提示符进入项目目录。通过使用 `logcat` 作为输入运行 NDK-Stack，找到导致崩溃的代码行。NDK-Stack 需要对应于应用程序崩溃的设备
    ABI 的 `obj` 文件，例如：
- en: '[PRE20]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Time for action – analyzing a native crash dump](img/1529_02_09.jpg)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 分析原生崩溃转储](img/1529_02_09.jpg)'
- en: '*What just happened?*'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: NDK-Stack utility provided with the Android NDK can help you locate the source
    of an application crash. This tool is an inestimable help and should be considered
    as your first-aid kit when a bad crash happens. However, if it can point you toward
    the *where*, it is another kettle of fish to find out the *why*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 提供的 NDK-Stack 工具可以帮助你定位应用程序崩溃的源头。这个工具是不可或缺的帮助，当发生严重的崩溃时，应被视为你的急救包。然而，如果它能指出*在哪里*，那么找出*为什么*就是另一回事了。
- en: '**Stack-trace** is only a small part of a crash dump. Deciphering the rest
    of a dump is rarely necessary but understanding its meaning is good for general
    culture.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**只是崩溃转储的一小部分。解读转储的其余部分很少是必要的，但理解其含义对提高一般文化素养有帮助。'
- en: Deciphering crash dumps
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解读崩溃转储
- en: 'Crash dumps are not only dedicated to overly talented developers seeing a red-dressed
    girl in binary code, but also to those who have a minimum knowledge of assemblers
    and the way processors work. The goal of this trace is to give as much information
    as possible on the current state of the program at the time it crashed. It contains:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃转储不仅是为了那些在二进制代码中看到穿红衣服女孩的过于有才华的开发者，也是为了那些对汇编器和处理器工作方式有基本了解的人。这个跟踪的目标是尽可能多地提供程序在崩溃时的当前状态信息。它包含：
- en: '1st line: **Build Fingerprint** is a kind of identifier indicating the device/Android
    release currently running. This information is interesting when analyzing dumps
    from various origins.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行：**构建指纹**是一种标识符，表示当前运行的设备/Android 版本。在分析来自不同来源的转储时，这些信息很有趣。
- en: '3rd line: The **PID** or process identifier uniquely identifies an application
    on the Unix system, and the **TID**, which is the thread identifier. The thread
    identifier can be the same as the process identifier when a crash occurs on the
    main thread.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行：**PID** 或进程标识符在 Unix 系统上唯一标识一个应用程序，以及 **TID**，即线程标识符。当在主线程上发生崩溃时，线程标识符可能与进程标识符相同。
- en: '4th line: The crash origin represented as a **Signal** is a classic segmentation
    fault (**SIGSEGV**).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行：表示为 **信号** 的崩溃源头是一个经典的段错误（**SIGSEGV**）。
- en: '**Processor Register** values. A register holds values or pointers on which
    the processor can work immediately.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器寄存器**的值。寄存器保存处理器可以立即操作的值或指针。'
- en: '**Backtrace** (that is the stack-trace) with the method calls that lead to
    the crash.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回溯**（即堆栈跟踪）与方法调用，这些调用导致了崩溃。'
- en: '**Raw stack** is similar to the backtrace but with stack parameters and variables.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始堆栈**与回溯类似，但包含了堆栈参数和变量。'
- en: Some **Memory Words** around the main register (provided for ARM processors
    only). The first column indicates memory-line locations, while others columns
    indicate memory values represented in hexadecimal.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要寄存器的一些**内存字**（仅针对 ARM 处理器提供）。第一列指示内存行的位置，而其他列指示以十六进制表示的内存值。
- en: 'Processor registers are different between processor architectures and versions.
    ARM processors provide:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器寄存器在不同处理器架构和版本之间是不同的。ARM 处理器提供：
- en: '| **rX** | **Integer Registers** where a program puts values it works on. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **rX** | **整数寄存器**，程序在这里放置它要处理的值。 |'
- en: '| **dX** | **Floating Point Registers** where a program puts values it works
    on. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **dX** | **浮点寄存器**，程序在这里放置它要处理的值。 |'
- en: '| **fp (or r11)** | **Frame Pointer** holds the current stack frame location
    during a routine call (in conjunction with the Stack Pointer). |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **fp（或r11）** | **帧指针**在过程调用期间保存当前堆栈帧的位置（与堆栈指针配合使用）。 |'
- en: '| **ip (or r12)** | **Intra Procedure Call Scratch Register** may be used with
    some sub-routine calls; for example, when the linker needs a veneer (a small piece
    of code) to aim at a different memory area when branching. Indeed, a branch instruction
    to jump somewhere else in memory requires an offset argument relative to the current
    location, allowing a branching range of a few MB only, not the full memory. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **ip（或r12）** | **过程内调用暂存寄存器**可能用于某些子程序调用；例如，当链接器需要一个薄层（一小段代码）以在分支时指向不同的内存区域时。实际上，跳转到内存中其他位置的分支指令需要一个相对于当前位置的偏移量参数，这使得分支范围只有几MB，而不是整个内存。
    |'
- en: '| **sp (or r13)** | **Stack Pointer** holds the location of the top of the
    stack. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **sp（或r13）** | **堆栈指针**保存堆栈顶部的位置。 |'
- en: '| **lr (or r14)** | **Link Register** saves a program counter value temporarily
    so that it can restore it later. A typical example of its use is as a function
    call, which jumps somewhere in the code and then goes back to its previous location.
    Of course, several chained sub-routine calls require the Link Register to be stacked.
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **lr（或r14）** | **链接寄存器**临时保存程序计数器值，以便稍后恢复。其使用的一个典型例子是函数调用，它跳转到代码中的某个位置，然后返回到其先前的位置。当然，多个链式子程序调用需要将链接寄存器入栈。
    |'
- en: '| **pc (or r15)** | **Program Counter** holds the address of the next instruction
    to be executed. The program counter is just incremented when executing a sequential
    code to fetch the next instruction but it is altered by branching instructions
    (if/else, a C/C++ function calls, and so on). |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **pc（或r15）** | **程序计数器**保存着将要执行的下一个指令的地址。程序计数器在执行顺序代码时只是递增以获取下一个指令，但它会被分支指令（如if/else，C/C++函数调用等）改变。
    |'
- en: '| **cpsr** | **Current Program Status Register** contains a few flags about
    the current processor working mode and some additional bit flags for condition
    codes (such as N for an operation that resulted in a negative value, Z for a 0
    or equality result, and so on), interrupts, and instruction sets (Thumb or ARM).
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **cpsr** | **当前程序状态寄存器**包含有关当前处理器工作模式的一些标志和额外的位标志，用于条件码（如操作结果为负值的N，结果为0或相等的Z等），中断和指令集（拇指或ARM）。
    |'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that the use of registers is mainly a convention. For example, Apple
    iOS uses `r7` as a Frame Pointer instead of `r12` on ARMs. So always be very careful
    when writing or reusing assembly code!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，寄存器的主要使用是一种约定。例如，苹果iOS在ARMS上使用`r7`作为帧指针，而不是`r12`。因此，在编写或重用汇编代码时一定要非常小心！
- en: 'On the other hand, X86 processors provide:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，X86处理器提供：
- en: '| **eax** | **Accumulator Register** is used, for example, for arithmetic or
    I/O operations. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **eax** | **累加器寄存器**用于例如算术或I/O操作。 |'
- en: '| **ebx** | **Base Register** is a data pointer for memory access. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **ebx** | **基址寄存器**是用于内存访问的数据指针。 |'
- en: '| **ecx** | **Counter Register** is used for iterative operations such as loop
    counter. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **ecx** | **计数器寄存器**用于迭代操作，如循环计数器。 |'
- en: '| **edx** | **Data Register** is a secondary Accumulator Register used in conjunction
    with `eax`. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **edx** | **数据寄存器**是配合`eax`使用的次要累加寄存器。 |'
- en: '| **esi** | **Source Index Register** is used for memory array copying in conjunction
    with `edi`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **esi** | **源索引寄存器**与`edi`配合使用，用于内存数组的复制。 |'
- en: '| **edi** | **Destination Index Register** is used for memory array copying
    in conjunction with `esi`. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **edi** | **目的索引寄存器**与`esi`配合使用，用于内存数组的复制。 |'
- en: '| **eip** | **Instruction Pointer** holds offset of the next instruction. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **eip** | **指令指针**保存下一个指令的偏移量。 |'
- en: '| **ebp** | **Base Pointer** holds the current stack frame location during
    a routine call (in conjunction with the Stack Pointer). |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **ebp** | **基指针**在过程调用期间保存当前堆栈帧的位置（与堆栈指针配合使用）。 |'
- en: '| **esp** | **Stack Pointer** holds the location of the top of the stack. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **esp** | **堆栈指针**保存堆栈顶部的位置。 |'
- en: '| **xcs** | **Code Segment** helps in addressing the memory segment in which
    the program runs. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **xcs** | **代码段**帮助寻址程序运行的内存段。 |'
- en: '| **xds** | **Data Segment** helps addressing a data memory segment. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **xds** | **数据段**帮助寻址数据内存段。 |'
- en: '| **xes** | **Extra Segment** is an additional register to address a memory
    segment. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **xes** | **额外段**是用于寻址内存段的附加寄存器。 |'
- en: '| **xfs** | **Additional Segment** which is a general purpose data segment.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **xfs** | **附加段**，这是一个通用数据段。 |'
- en: '| **xss** | **Stack segment** holds the Stack memory segment. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **xss** | **堆栈段**保存堆栈内存段。 |'
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Many X86 registers are a **legacy**, which means that they lost the initial
    purpose they were created for. Take their descriptions with some caution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多X86寄存器是**遗留**的，这意味着它们失去了创建时的初衷。对它们的描述要持谨慎态度。
- en: Deciphering stack-traces is not an easy task and requires time and expertise.
    Don't bother too much if you do not understand every part of it yet. This is necessary
    as a last resort only.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 解读堆栈跟踪不是一件容易的事，它需要时间和专业知识。如果你还无法理解它的每一部分，不必过于烦恼。这只在万不得已的情况下才需要。
- en: Setting up a Gradle project to compile native code
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Gradle项目以编译原生代码
- en: Android Studio is now the new officially supported Android IDE, in place of
    Eclipse. It comes with **Gradle**, which is the new official Android build system.
    Gradle introduces a Groovy-based specific language to define the project configuration
    easily. Although its support of the NDK is still preliminary, it keeps improving
    and is becoming more and more useable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio现在是官方支持的Android IDE，取代了Eclipse。它带有**Gradle**，这是新的官方Android构建系统。Gradle引入了一种基于Groovy的特定语言，以便轻松定义项目配置。尽管其对NDK的支持还初步，但它不断改进，变得越来越可用。
- en: Let's now see how to create an Android Studio project with Gradle that compiles
    native code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Gradle创建一个编译原生代码的Android Studio项目。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Gradle_Auto`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`Store_Gradle_Auto`。
- en: Time for action – creating a native Android project
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建原生Android项目
- en: 'Gradle-based projects can be created easily through Android Studio:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Android Studio可以轻松创建基于Gradle的项目：
- en: Launch Android Studio. On the welcome screen, select **New Project…** (or go
    to **File** | **New Project…** if a project is already opened).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Android Studio。在欢迎屏幕上，选择**新建项目…**（如果已经打开了一个项目，则选择**文件** | **新建项目…**）。
- en: From the **New Project** wizard, enter the following configuration and click
    on **Next**:![Time for action – creating a native Android project](img/1529_02_51.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建项目**向导中，输入以下配置并点击**下一步**：![行动时间 – 创建原生Android项目](img/1529_02_51.jpg)
- en: 'Then, select the minimum SDK (for example, API 14: Ice Scream Sandwich) and
    click on **Next**.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择最小的SDK（例如，API 14：冰激凌三明治），并点击**下一步**。
- en: Select **Blank Activity with Fragment** and click on **Next**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**带片段的空白活动**并点击**下一步**。
- en: Finally, enter **Activity Name** and **Layout Name** names as follows and click
    on **Finish**:![Time for action – creating a native Android project](img/1529_02_52.jpg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式输入**活动名称**和**布局名称**，然后点击**完成**：![行动时间 – 创建原生Android项目](img/1529_02_52.jpg)
- en: Android Studio should then open the project:![Time for action – creating a native
    Android project](img/1529_02_55.jpg)
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Android Studio应该会打开项目：![行动时间 – 创建原生Android项目](img/1529_02_55.jpg)
- en: Modify `StoreActivity.java` and create `Store.java` in the same way as we did
    in the *Interfacing Java with C/C++* section in this chapter (Step 1 and 2).
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`StoreActivity.java`文件，并按照本章中*Java与C/C++接口*部分（步骤1和2）创建`Store.java`。
- en: Create the `app/src/main/jni` directory. Copy the C and Header files we created
    in the *Interfacing Java with C/C++* section in this chapter (Step 4 and 5).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`app/src/main/jni`目录。复制本章*Java与C/C++接口*部分（步骤4和5）中创建的C和头文件。
- en: 'Edit `app/build.gradle` that has been generated by Android Studio. In `defaultConfig`,
    insert a `ndk` section to configure the module (that is, a library) name:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑Android Studio生成的`app/build.gradle`文件。在`defaultConfig`中插入一个`ndk`部分来配置模块（即库）名称：
- en: '[PRE21]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and install the project on your device by clicking on **installDebug**
    in the **Gradle tasks** view of Android Studio.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击Android Studio中**Gradle任务**视图下的**installDebug**，编译并在你的设备上安装项目。
- en: Tip
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If Android Studio complains that it cannot find the NDK, make sure the `local.properties`
    file in the project's root directory contains both `sdk.dir` and `ndk.dir` properties
    that can point to your Android SDK and NDK location.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果Android Studio抱怨找不到NDK，请确保项目根目录中的`local.properties`文件包含可以指向你的Android SDK和NDK位置的`sdk.dir`和`ndk.dir`属性。
- en: '*What just happened?*'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created our first Android Studio project that compiles native code through
    Gradle. NDK properties are configured in a section specific to `ndk` in the `build.gradle`
    file (for example, the module name).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个通过Gradle编译本地代码的第一个Android Studio项目。NDK属性在 `build.gradle` 文件（例如，模块名称）的特定于
    `ndk` 的部分配置。
- en: 'Multiple settings are available as shown in the following table:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了多个可用的设置：
- en: '| Property | Description |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **abiFilter** | The list of ABIs to compile for; by default, all. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **abiFilter** | 要编译的目标ABI列表；默认情况下，编译所有ABI。 |'
- en: '| **cFlags** | Custom flags to pass to the compiler. More about this in [Chapter
    9](ch09.html "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing
    Libraries to Android*. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **cFlags** | 传递给编译器的自定义标志。关于这方面的更多信息，请参见[第9章](ch09.html "第9章. 将现有库移植到Android")，*将现有库移植到Android*。
    |'
- en: '| **ldLibs** | Custom flags to pass to the linker. More about this in [Chapter
    9](ch09.html "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing
    Libraries to Android*. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **ldLibs** | 传递给链接器的自定义标志。关于这方面的更多信息，请参见[第9章](ch09.html "第9章. 将现有库移植到Android")，*将现有库移植到Android*。
    |'
- en: '| **moduleName** | This is the name of the module to be built. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **moduleName** | 这是将要构建的模块名称。 |'
- en: '| **stl** | This is the STL library to use for compilation. More about this
    in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **stl** | 这是用于编译的STL库。关于这方面的更多信息，请参见[第9章](ch09.html "第9章. 将现有库移植到Android")，*将现有库移植到Android*。
    |'
- en: You might have noticed that we have not reused the `Android.mk` and `Application.mk`
    files. This is because Gradle generates the build files automatically if given
    an input to `ndk-build` at compilation time. In our example, you can see the generated
    `Android.mk` for the `Store` module in the `app/build/intermediates/ndk/debug`
    directory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有重用 `Android.mk` 和 `Application.mk` 文件。这是因为如果在编译时给 `ndk-build` 提供了输入，Gradle
    会自动生成构建文件。在我们的示例中，你可以在 `app/build/intermediates/ndk/debug` 目录下看到为 `Store` 模块生成的
    `Android.mk` 文件。
- en: NDK automatic Makefile generation makes it easy to compile native NDK code on
    simple projects. However, if you want more control on your native build, you can
    create your own Makefiles like the ones created in the Interfacing Java with C/C++
    section in this chapter. Let's see how to do this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: NDK自动Makefile生成使得在简单项目上编译本地NDK代码变得容易。但是，如果你想要在本地构建上获得更多控制，你可以创建自己的Makefiles，就像本章中在“Java与C/C++接口”部分创建的那样。让我们看看如何操作。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Gradle_Manual`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为 `Store_Gradle_Manual`。
- en: Time for action – using your own Makefiles with Gradle
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 使用你自己的Makefiles与Gradle
- en: 'Using your own handmade makefiles with Gradle is a bit tricky but not too complicated:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你手工制作的Makefiles与Gradle有点棘手，但并不复杂：
- en: Copy the `Android.mk` and `Application.mk` files we created in the *Interfacing
    Java with C/C++* section in this chapter into the `app/src/main/jni` directory.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章中在“Java与C/C++接口”部分创建的 `Android.mk` 和 `Application.mk` 文件复制到 `app/src/main/jni`
    目录。
- en: Edit `app/build.gradle`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `app/build.gradle` 文件。
- en: 'Add an import for the `OS` "Class" and remove the first `ndk` section we created
    in the previous section:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `OS` “类”的导入，并删除前一个部分中我们创建的第一个 `ndk` 部分：
- en: '[PRE22]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Still in the android section of `app/build.gradle`., insert a `sourceSets.main`
    section with the following:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '仍然在 `app/build.gradle` 文件的android部分，插入一个包含以下内容的 `sourceSets.main` 部分： '
- en: '`jniLibs.srcDir`, which defines where Gradle will find the generated libraries.'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jniLibs.srcDir`，定义了Gradle将找到生成的库的位置。'
- en: '`jni.srcDirs`, which is set to an empty array to disable native code compilation
    through Gradle.'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jni.srcDirs`，设置为空数组以通过Gradle禁用本地代码编译。'
- en: '[PRE23]'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, create a new Gradle task `ndkBuild` that will manually trigger the
    `ndk-build` command, specifying the custom directory `src/main` as the compilation
    directory.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的Gradle任务 `ndkBuild`，它将手动触发 `ndk-build` 命令，指定自定义目录 `src/main` 作为编译目录。
- en: 'Declare a dependency between the `ndkBuild` task and the Java compilation task
    to automatically trigger native code compilation:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明 `ndkBuild` 任务与Java编译任务之间的依赖关系，以自动触发本地代码编译：
- en: '[PRE24]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compile and install the project on your device by clicking on **installDebug**
    in the **Gradle tasks** view of Android Studio.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击Android Studio中的 **installDebug** 在 **Gradle任务** 视图下编译并安装项目到你的设备上。
- en: '*What just happened?*'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The Makefile generation and native source compilation performed by the Android
    Gradle plugin can easily be disabled. The trick is to simply indicate that no
    native source directory is available. We can then use the power of Gradle, which
    allows defining easily custom build tasks and dependencies between them, to execute
    the `ndk-build` command. This trick allows using our own NDK makefiles, giving
    us more flexibility in the way we build native code.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Android Gradle插件进行的Makefile生成和原生源代码编译可以轻松禁用。诀窍是简单地指出没有可用的原生源代码目录。然后我们可以利用Gradle的强大功能，它允许轻松定义自定义构建任务及其之间的依赖关系，以执行`ndk-build`命令。这个技巧允许我们使用自己的NDK
    makefiles，从而在构建原生代码时给我们提供更大的灵活性。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Creating, compiling, building, packaging, and deploying an application project
    are not the most exciting tasks, but they cannot be avoided. Mastering them will
    allow you to be productive and focused on the real objective: **producing code**.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、编译、构建、打包和部署应用程序项目可能不是最激动人心的任务，但它们是无法避免的。掌握它们将使您能够提高效率并专注于真正的目标：**编写代码**。
- en: In summary, we built our first sample application using command-line tools and
    deploying it on an Android device. We also created our first native Android project
    using Eclipse and interfaced Java with C/C++ using Java Native Interfaces. We
    debugged a native Android application with NDK-GDB and analyzed a native crash
    dump to find its origin in the source code. Finally, we created a similar project
    using Android Studio and built it with Gradle.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，我们使用命令行工具构建了第一个示例应用程序，并将其部署在Android设备上。我们还使用Eclipse创建了第一个原生Android项目，并通过Java本地接口（JNI）将Java与C/C++进行接口。我们使用NDK-GDB调试了原生Android应用程序，并分析了原生崩溃转储以在源代码中找到其根源。最后，我们使用Android
    Studio创建了类似的项目，并使用Gradle构建它。
- en: This first experiment with the Android NDK gives you a good overview of the
    way native development works. In the next chapter, we are going to focus on the
    code and dive more deeply into the JNI protocol.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这首次使用Android NDK的实验使您对原生开发的工作方式有了很好的了解。在下一章中，我们将专注于代码，并深入探讨JNI协议。
