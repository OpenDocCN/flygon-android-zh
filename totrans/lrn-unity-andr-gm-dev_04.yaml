- en: Chapter 4. Setting the Stage – Camera Effects and Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned about the basic building blocks of any
    game: meshes, materials, and animations. We created a *Tank Battle* game that
    utilized all of these blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will expand upon the Tank Battle game. We will start with
    the addition of a skybox and distance fog. The exploration of camera effects continues
    with a target indicator overlay that uses a second camera. The creation of a turbo
    boost effect for the tank will round out our look at camera effects. Continuing
    with a look at lighting, we will finish off our tank environment with the addition
    of lightmaps and shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Skyboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance fog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the field of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating lightmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be directly piggybacking off the project from [Chapter 3](ch03.html
    "Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations"), *The
    Backbone of Any Game – Meshes, Material, and Animations*. So, open the project
    in Unity and we will get started.
  prefs: []
  type: TYPE_NORMAL
- en: Camera effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many great camera effects that you should add in order to give your
    game the last great finishing touch. In this chapter, we will be covering a few
    options that are easy to add. These will also give our tank game a finished look.
  prefs: []
  type: TYPE_NORMAL
- en: Skyboxes and distance fog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a camera renders the frame of a game, it starts by clearing the screen.
    The default camera in Unity does this by coloring everything with a gradient,
    simulating the look of a skybox. All of the game's meshes are then drawn on top
    of this blank screen. While the gradient looks better than a solid color, it is
    still rather boring for an exciting battle of tanks. Luckily for us, Unity allows
    us to change the skybox. A skybox is just a fancy word for the series of images
    that form the background sky of any game. Distance fog works in conjunction with
    the skybox by easing the visual transition between models and the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thing we need is a new skybox. We can create our own, however,
    Unity provides us with several excellent ones that will fit our needs just fine.
    Let''s use the following steps to get a skybox now:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, select **Assets** and then click on **Import
    Package**. About halfway down this list, select **Skyboxes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a little bit of processing, a new window will pop up. A package in Unity
    is just a compressed group of assets that have already been set up in Unity. This
    window displays the contents and allows you to selectively import them. We want
    them all, so we just click on **Import** in the bottom-right corner of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new folder, `Standard Assets`, will be added to the **Project** window. This
    contains a folder, `Skyboxes`, which contains various skybox materials. Select
    any one of these. You can see in the **Inspector** window that they are normal
    materials that make use of the skybox shader. They each have six images, one for
    each direction of a box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will also notice that there are warning messages with a **Fix Now** button
    under each image. This is because all the images were compressed to save import
    time and space, but the skybox shader needs them in a different format. Just click
    on the **Fix Now** button each time and Unity will automatically fix it for you.
    It will also get rid of all of the odd blackness in the material preview.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a skybox of your choice to the game, first make sure that you have the
    correct scene loaded. If you do not, simply double-click on the scene in the **Project**
    window. This is necessary because the settings we are about to change are specific
    to each scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the top of the Unity Editor and select **Edit** and then click on **Scene
    Render Settings**. The new group of settings will appear in the **Inspector**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, we are concerned with the value at the top, **Skybox Material**.
    Just drag and drop the new skybox material into the **Skybox Material** slot and
    it will be automatically updated. The change can be viewed right away in the **Game**
    and **Scene** windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add distance fog, we also adjust this setting in **Scene Render Settings**.
    To turn it on, simply tick the **Use Fog** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next setting, **Fog Color**, allows you to pick a color for the fog. It
    is good to pick a color that is close to the general color of the skybox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Fog Mode** setting is a drop-down list of options that dictate the method
    that Unity will use to calculate the distance fog. For nearly all cases, the default
    setting of **Exponential Squared** is suitable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next three settings, **Density**, **Start**, and **End**, determine how
    much fog there is and how close it starts. They will only appear for the fog modes
    that use them. **Density** is used for the **Exponential** and **Exponential Squared**
    fog modes, while the others are used for the **Linear** fog mode. Settings that
    put the fog at the edge of sight will, in general, give the best-looking effect.
    Leave these settings on **Exponential Squared** and choose `0.03` for the **Density**
    in order to get a good look.![Skyboxes and distance fog](img/4691OT_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have imported several skyboxes and added them to the scene. The distance
    fog settings are also turned on and adjusted. Now, our scene has started to look
    like a real game.
  prefs: []
  type: TYPE_NORMAL
- en: Target indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another camera effect that is rather interesting is the use of multiple cameras.
    A second camera can be used to make a 3D GUI, a minimap, or perhaps a security
    camera popup. In the next section, we will be creating a system that will point
    at targets that are nearby. Using a second camera, we will make the indicators
    appear above the player's tank.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to start by creating an object that will point at targets. We
    will be making a prefab that can be used repeatedly. However, you will need to
    import the `IndicatorSliceMesh.blend` starting asset for this chapter, so we have
    something for the player to see. It is a pie-slice-shaped mesh. Let''s perform
    the following steps to create the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the mesh imported, add it to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty **GameObject** component and rename it to `IndicatorSlice`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the mesh a child of `IndicatorSlice` and position it so that it points
    along the *z* axis of `GameObject`, with the small end of the pie slice being
    at the position of `IndicatorSlice`. The `IndicatorSlice` GameObject will be centered
    in our indicator. Each slice that is created will have its *z* axis pointing in
    the direction of a target, as shown in the following figure:![Creating the pointer](img/4691OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to create a new script that will control our indicator. Create
    a new script called `TargetIndicator` in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start off this script with a pair of variables. The first variable will
    hold a reference to the target that this indicator piece will point at. The indicator
    is also going to grow and shrink, based on how far away the target is. The second
    variable will control the distance at which the indicator will start to grow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function will be used to set the `target` variable when the indicator
    piece is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last set of code goes in the `LateUpdate` function. The `LateUpdate` function
    is used so that the indicator pieces can point at a target after our tank moves
    in the `Update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start the function by checking whether the `target` variable has a value.
    If it is null, the indicator slice is destroyed. The `Destroy` function can be
    used to remove any object that exists from the game. The `gameObject` variable
    is automatically provided by the `MonoBehaviour` class and holds a reference to
    the **GameObject** component that the script component is attached to. Destroying
    this component will also destroy everything that is a child of (or attached to)
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we determine how far this indicator slice is from its target. By using
    `Vector3.Distance`, we can easily calculate the distance without doing the math
    ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line of code determines the vertical scale, *y* axis, of the slice. It
    does so by using a bit of carefully applied math and the `Mathf.Clamp01` function.
    This function limits the supplied value to be between zero and one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the calculated scale to set the indicator slice''s local scale. By adjusting
    the local scale, we can easily control how big the whole indicator is just by
    changing the scale of the parent object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `transform.LookAt` function is just a fancy, automatic way of rotating
    a GameObject so that its *z* axis points to a specific spot in the world. However,
    we want all the indicator slices to lie flat on the ground and not point into
    the air at any targets that might be above us. So, we first collect the target''s
    position. By setting the variable''s `y` value to the position of the slice, we
    ensure that the slice remains flat. That last line, of course, closes off the
    `LateUpdate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is the last code for this script. Return to Unity and add
    the `TargetIndicator` script to the `IndicatorSlice` object in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off the indicator, create a prefab of it. Do it just like we did for
    our target objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, delete the `IndicatorSlice` object from the scene. We will be creating
    slices dynamically when the game starts. This requires the prefab, but not the
    one in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a prefab of the object we will be using to indicate the direction
    of targets. The script that was created and attached will rotate each instance
    of the prefab to point at the targets in the scene. It will also adjust the scale
    to indicate how far away the targets are from the player.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the indicator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now need to create a script that will control the indicator slices. This
    will include creating new slices as they are needed. Also, the **GameObject**
    component it is attached to will act as a center point for the indicator slices,
    which we just created, to rotate around. Let''s perform these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script and name it `IndicatorControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start off this script with a pair of variables. The first variable will
    hold a reference to the prefab that was just created. This will allow us to spawn
    instances of the prefab whenever we desire. The second is a static variable, which
    means that it can be easily accessed without a reference to the component that
    exists in the scene. It will be filled when the game starts with a reference to
    the instance of this script that is in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function will be used by the targets. Soon, we will be updating the
    target''s script to call this function at the beginning of the game. The function
    is static, just like the preceding variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function starts by checking whether there is a reference to any object
    in the static variable. If it is empty, equal to `null`, `Object.FindObjectOfType`
    is used to fill the variable. By telling it what type of object we want to find,
    it will search in the game and try to find one. This is a relatively slow process
    and should not be used often, but we use this process and the variable so that
    we can always be sure that the system can find the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second part of the `CreateSlice` function checks to make sure that our
    static variable is not empty. If so, it tells the instance to create a new indicator
    slice and passes the target to the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one more function for this script: `NewSlice`. The `NewSlice` function
    does as its name implies; it will create new indicator slices when called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function first uses the `Instantiate` function to create a copy of `indicatorPrefab`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the function makes the new slice a child of the control''s transform,
    so it will stay with us as we move around. By zeroing out the local position of
    the new slice, we also insure that it will be at the same location as our control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last line of the function uses the slice''s `SendMessage` function to call
    the `SetTarget` function that we created previously and passes it the desired
    target object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the script is created, we need to use it. Create an empty **GameObject**
    component and name it `IndicatorControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new **GameObject** component needs to be made a child of the tank, followed
    by having its position set to zero on each axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the script we just created to the `IndicatorControl` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, with the GameObject selected, add the reference to the `IndicatorSlice`
    prefab. Do this by dragging the prefab from the **Project** window to the proper
    slot in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a script that will control the spawning of our target indicator slices.
    The **GameObject** component we created at the end will also allow us to control
    the size of the whole indicator with ease. We are almost done with the target
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a second camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you were to play the game now, it will still look no different. This is
    because the targets do not make the call yet to create the indicator slices. We
    will also be adding the second camera in this section as we finish off with the
    target indicator. These steps will help us do it well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening the `Target` script and adding the following line of code
    at the end of the `Awake` function. This line tells the `IndicatorControl` script
    to create a new indicator slice for this target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Working with a second camera](img/4691OT_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If you play the game now, you can see the indicator in action. However, it is
    probably too large and certainly appears inside the tank. A bad solution will
    be to move the `IndicatorControl` object until the whole thing appears above the
    tank. However, when explosions occur and things start flying through the air,
    they will obscure the target indicator all over again. A better solution is to
    add a second camera. You can do so now by selecting **GameObject** from the top
    of the Unity Editor and then clicking on **Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, make the camera a child of `Main Camera`. Be sure to set the new
    camera's position and rotation values to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, every camera in Unity is given a variety of components: **Camera**,
    **Flare Layer**, **GUI Layer**, and **Audio Listener**. Besides the **Camera**
    component, the others are generally unimportant to every other camera, and there
    should only be one **Audio Listener** component in the whole of the scene. Remove
    the excess components from the camera, leaving just the **Camera** component.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we do anything else with the camera, we need to change the layer that
    the `IndicatorSlice` prefab is on. Layers are used for selective interaction between
    objects. They are used primarily for physics and rendering. First select the prefab
    in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Inspector** window is the **Layer** label with a drop-down
    list that reads **Default**. Click on the drop-down list and select **Add Layer...**
    from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of layers will now appear in the **Inspector** window. These are all
    the layers that are used in the game. The first few are reserved for use by Unity;
    hence, they have been grayed out. The rest are for our use. Click on the input
    box at the right-hand side of **User Layer 8** and name it `Indicator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `IndicatorSlice` prefab again. This time, select the new **Indicator**
    layer from the **Layer** drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity will ask whether you want to change the layer of all the child objects
    as well. We want the whole object rendered on this layer, so we need to select
    **Yes, change children** and we will be able to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's get back to our second camera. Select the camera and take a look
    at the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first attribute of the **Camera** component is **Clear Flags**. This list
    of options dictate what the camera will fill the background with before drawing
    all the models in the game. The second camera should not block out everything
    drawn by the first camera. We select **Depth only** from the **Clear Flags** drop-down
    list. This means that instead of putting the skybox in the background, it will
    leave what was already rendered and just draw new things on top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next attribute, **Culling Mask**, controls which layers are rendered by
    the camera. The first two options, **Nothing** and **Everything**, are for the
    quick deselection and selection of all the layers. For this camera, deselect all
    other layers so that only the **Indicator** layer has a check next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is to adjust the scale of `IndicatorControl` so that the
    target indicator is not too large or small.![Working with a second camera](img/4691OT_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a system to indicate the direction of potential targets. To do this,
    we used a second camera. By adjusting the layers in the **Culling Mask** attribute,
    we can make a camera render only a part of the scene. Also, by changing the **Clear
    Flags** attribute to **Depth only**, the second camera can draw on top of what
    was drawn by the first camera.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to change where the indicator is drawn by moving the camera.
    If you were to move the `IndicatorControl` object instead, it will change how
    the distance from the targets and the directions to target are calculated. Move
    and angle the second camera so that there is a more pleasing view of the target
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: When you move the second camera or when you use the boost (from the next section),
    you will probably notice that the target indicator can still be seen in the tank.
    Adjust the main camera so that it does not render the target indicator. This is
    done similarly to how we made the second camera only render the target indicator
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Turbo boost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last camera effect that we will be looking at in this chapter is a turbo
    boost. It is going to be a button on the screen that will propel the player forward
    rapidly for a short amount of time. The camera effect comes in because a simple
    adjustment to the **Field of View** attribute can make it look as if we are going
    much faster. A similar method is used in movies to make car chases look even faster
    than they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only be making a single script in this section. The script will move
    the tank in a similar manner to the `ChassisControls` script we created in the
    last chapter. The difference is that we won''t have to hold down a button for
    the boost to work. Let''s get to it with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new script and calling it `TurboBoost`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start off the script, we need four variables. The first variable is a reference
    to the `CharacterController` component on the tank. We need this for movement.
    The second variable is how fast we will be moving while boosting. The third is
    for how long, in seconds, we will be boosting. The last is used internally for
    whether or not we can boost and when we should stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `StartBoost` function is pretty simple. It checks whether the `startTime`
    variable is less than zero. If it is, the variable is set to the current time
    as provided by `Time.time`. The value of the variable being less than zero means
    that we are not boosting currently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function we are going to use is the `Update` function. It begins with
    a check of `startTime` to see whether we are currently boosting. If we are not
    boosting, the function is exited early. The next line of code checks to make sure
    that we have our `CharacterController` reference. If the variable is empty, then
    we can''t make the tank move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next line of code should look familiar. This is the line that makes the
    tank move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, check whether we are in the first half-second of the boost. By comparing
    the current time with the time that was recorded when we started, we can easily
    figure out for how long we have been boosting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the time is right, we transition the camera by adjusting the `fieldOfView`
    value. The `Camera.main` value is just a reference provided by Unity to the main
    camera used in the scene. The `Mathf.Lerp` function takes a starting value and
    moves this value toward the goal value based on a third value between zero and
    one. Using this, the camera''s `fieldOfView` value is moved toward our goal over
    the half-second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next piece of code does the same thing as the previous two, except for
    the last half-second of our boost, and uses the same method to transition the
    `fieldOfView` value back to the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last bit of code checks whether we are done with boosting. If so, `startTime`
    is set to `-1` in order to indicate that we can start another boost. That last
    curly brace, of course, closes off the `Update` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the script to your tank and connect the `CharacterController` reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are almost done. We need to create a new button. We can do this just like
    we have done before. Anchor the button to the bottom-right corner of **Canvas**
    and position it just above the chassis' movement controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last, be sure to select `Tank` for the **OnClick** object and navigate to **Turbo
    Boost** | **StartBoost ()** for the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try this out.![Turbo boost](img/4691OT_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a turbo boost here. The same method of movement that we used in the
    previous chapter moves the tank here. By adjusting the **Field of View** attribute
    of the camera, we make it look like the tank is moving even faster.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice while playing the game that you can turn even when boosting.
    Try adding a check to the `ChassisControls` script in order to lock the controls,
    at the time of boosting. You need to add a reference to the `TurboBoost` script
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an additional, extra challenge, try adding a cooldown to the boost. Make
    it such that the player can''t constantly use the boost. Also, try canceling the
    boost if the tank runs into something. This is a hard one, so here''s a hint to
    start with: take a look at `OnControllerColliderHit` in the Unity documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity provides a variety of light types for brightening the game world. They
    are **Directional Light**, **Spotlight**, **Point Light**, and **Area Light**.
    Each of these projects light in a different way; they are explained in detail
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional Light**: This functions much like the sun. It projects all of
    its light in a single direction. The position of the light does not matter, only
    the rotation does. Light is projected over the entire scene in one direction.
    This makes it perfect for initially adding light to a scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spotlight**: This functions just like the lights on a stage. Light is projected
    in a cone-like shape in a specific direction. Because of this, it is also the
    most complex light type for the system to calculate. Unity has made significant
    improvements on how it calculates lights, but an overuse of these lights should
    be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point Light**: This is the primary light type that will be used in your games.
    It emits light in every direction. This functions just like a light bulb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area Light**: This is a special-use light. It emits light in a single direction
    from a plane. Think of it as a big neon sign used to advertise a hotel or restaurant.
    Because of their complexity, these lights can only be used when baking shadows.
    There are too many calculations for them to be used when the game is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next obvious question when talking about lights concerns shadows, especially
    real-time shadows. While real-time shadows add a lot to a scene and are technically
    possible on any platform, they are very expensive. On top of that, they are a
    Unity Pro feature for all light types, except **Directional Lights**. All in all,
    this makes them a bit too much for your average mobile game.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are perfectly viable alternatives that do not cost
    nearly as much and often look more realistic than real-time shadows. The first
    alternative is for your environment. In general, the environment in a game never
    moves and never changes within a specific scene. For this, we have lightmaps.
    They are extra textures that contain shadow data. Using Unity, you can create
    these textures while making your game. Then, when the game is running, they are
    automatically applied and your shadows appear. This, however, does not work for
    dynamic objects (anything that moves).
  prefs: []
  type: TYPE_NORMAL
- en: For dynamic objects, we have cookies. These are not your grandmother's cookies.
    In lighting, a cookie is a black and white image that is projected onto meshes
    in the game. This is similar to shadow puppets. Shadow puppets use a cutout to
    block a part of the light, whereas cookies use black and white images to tell
    the light where it can cast its light.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies can also be used to create other good effects, both static and dynamic,
    such as a cloud cover that pans across the scene or, perhaps, light projecting
    out from a cage. Or, you can use them to make the uneven focus point of a flashlight.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more lights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is rather simple to add additional lights to the scene. Also, as long as
    one sticks to point lights, the cost to render them stays low. Let''s use these
    steps to light up our game:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, navigate to **GameObject** | **Light** | **Point
    Light**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the new light selected, these are a few attributes that we should be concerned
    about in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Range**: This is how far light will be emitted from the object. The light
    emitted from this point is brightest at the center and fades to nothing as it
    reaches the extent of the range. The range is additionally represented as a yellow-colored
    wire sphere in the **Scene** view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: This is simply the color of the light. By default, it is white;
    however, any color can be used here. This setting is shared between all the light
    types.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intensity**: This denotes the brightness of the light. The greater the intensity
    of the light, the brighter will be the light at its center. This setting is also
    shared between all the light types.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and position several more lights, arranging them along the streets to
    add some more interesting elements to the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *D* to duplicate the selected object. This can greatly speed
    up the creation process (like the one shown in the following screenshot):![Adding
    more lights](img/4691OT_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While adding these lights, you probably noticed one of their major drawbacks.
    There is a limit to the number of lights that will affect a surface in real time.
    It is possible to somewhat work around this by using more complex meshes. A better
    option is to use lightmaps, which we'll be seeing in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the Unity Editor again, navigate to **GameObject** | **Light**
    | **Spotlight**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a new light and take a look at it in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spot Angle**: This is unique to this type of light. It dictates how wide
    the cone of the emitted light will be. Together with **Range**, it is represented
    by a yellow-colored wire cone in the **Scene** view.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a few spotlights around the fountain in the center of our Tank Battle city,
    as shown in the following screenshot:![Adding more lights](img/4691OT_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having so many objects in a scene clutters the **Hierarchy** window, making
    it hard to find anything. To organize it, you can use empty GameObjects. Create
    a **GameObject** and name it `PointLights`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By making all of your point lights children of this empty **GameObject**, the
    **Hierarchy** window becomes significantly less cluttered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added several lights to the game. By changing the colors of the lights, we
    make the scene much more interesting to look at and play in. However, a drawback
    of the lighting system is revealed. The city we are using is very simple and there
    is a limit to the number of lights that can affect a plane at one time. While
    the look of our scene is nevertheless improved, much of the impressiveness is
    stolen by this drawback.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lightmaps are great for complex lighting setups that will be too expensive or
    simply won't work at runtime. They also allow you to add detailed shadows to your
    game world without the expense of real-time shadows. However, it will only work
    for objects that do not move over the course of a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lightmaps are a great effect for any game environment, but we need to explicitly
    tell Unity which objects will not move and then create the lightmaps. The following
    steps will help us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to make your environment meshes static. To do this,
    start by selecting a piece of your city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner of the **Inspector** window, to the right-hand side
    of the object name field, are a checkbox and a **Static** label. Checking this
    box will make the object static.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make all of the city''s meshes static, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of selecting each checkbox one by one, if you have any sort of grouping
    (as we just did for the lights), this step can be completed much faster. Select
    the root object of your city, the one that is the parent to all the pieces of
    your city, buildings, and streets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, go and select the **Static** checkbox.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the new popup, select **Yes, change children** to cause all the subobjects
    to become static as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any mesh that is either not unwrapped or has UV positions outside the normalized
    UV space will be skipped when Unity generates a lightmap. In the **Model Import
    Settings** window, there is an option to have Unity automatically generate lightmap
    coordinates, **Generate Lightmap UVs**. If you are using `TankBattleCity` for
    your environment, this option should be turned on now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the top of the Unity Editor and select **Window** and then click on **Lighting**,
    near the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of your time will be spent on the **Scene** page when looking at this window.
    Select **Scene** at the top of the window to switch to that window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing you will notice about this page is that it has the same **Sky
    Light** section that we saw in **Scene Render Settings**, where we changed the
    skybox. We also have all the **Fog** settings toward the bottom of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The section we are interested in is **General GI Settings**, as shown in the
    following screenshot:![Lightmaps](img/4691OT_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding screenshot has the following settings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Workflow**: This setting determines which method you are going to use in
    order to work with your lightmaps. By default, **Legacy** is selected, which is
    the old method. We want to change it to **On Demand**. (**Iterative** is the same
    as **On Demand**, but it attempts to update the lightmaps while you are adjusting
    settings. This is only recommended if you have a computer that is powerful enough
    to handle it.)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Parameters**: This setting lets you create settings that you might
    want to be able to quickly select. This will be especially useful if you have
    many scenes that need to be changed. However, we only have one scene, so we can
    ignore it for now.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sky Light**: This setting affects how much ambient light is in the scene.
    A lower value will make the overall scene darker, perhaps giving you a night scene.
    A higher value will make everything brighter, perhaps a daytime scene. The **Realtime
    Sky** checkbox below this setting dictates whether this calculation is made while
    the game is running or only when you are baking the lightmaps. Unchecking the
    box will save on processing, but leaving it checked will allow you to change the
    brightness of your scene while the game is running. So, you can see your lights
    in the game, set **Sky Light** to `0.2`, and uncheck **Realtime Sky**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Albedo Scale**: This setting affects how much light bounces off of surfaces.
    The **Indirect Scale** option affects how much light is in the overall scene from
    the light sources that do not point directly at an object. For our purposes, both
    of these can be left at their default values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Realtime GI Settings**: This section is only available with Unity''s new
    lightmaping system. It holds the controls for lightmaps that are calculated while
    the game is running. The **Realtime Resolution** and **Realtime Atlas Size** options
    adjust how much detail is present in these lightmaps. The **CPU Usage** option
    controls the amount of effort that the system will put into calculating the values
    you see while the game is running. Since we are working on a mobile platform,
    we need to keep our processing costs down, so leaving all of these at their low
    defaults works fine for us.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baked GI Settings**: These settings hold the controls for adjusting the precalculated
    lightmaps. This is where most of your adjustments will take place. Right off the
    bat, we have a **Directional Mode** checkbox that dictates whether we are going
    to use a single set of lightmaps when unchecked. Or, if we are going to use two
    sets, where one set is for color and direct light and the second set is for indirect
    light. Using two sets of lightmaps can give you greater detail, especially in
    dark areas, but is more costly to calculate and use. So, we are going to leave
    it unchecked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baked Resolution**: This setting controls how much detail is put into an
    object based on its size. After the number field, you can see the **texels per
    unit** setting. A texel is just a fancy lightmap pixel. So, it is really just
    the amount of pixel details in the lightmap for each unit in the scene. For our
    purposes, a value of `30` will give us a good amount of detail without overloading
    our computers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Baked Resolution** setting will most quickly affect how long it takes
    to actually bake your lightmaps. It is always better to start working with low
    values and only increase the values once your lighting setup comes close to what
    you want the final product to look like.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Baked Atlas Size**: This setting controls the ultimate resolution of the
    final lightmap images. Smaller resolution sizes will be easier to process, but
    you need to limit the overall details of the largest objects in your scene. No
    matter what resolution you have chosen, a single plane of your models cannot have
    more detail than a single lightmap atlas. The default of **1024** is an excellent
    compromise between detail and processing cost.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Padding**: The value of this setting adjusts the space in the lightmap between
    objects. A value that is too low will cause the shading to bleed onto the edges
    of other objects that share the lightmap. A value that is too high will lead to
    a great amount of wasted space in your lightmaps. Again, the default here will
    work just fine for us.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct Scale**: This setting will scale the intensity of lights when baked
    into your lightmap. It will let you change the overall brightness of your scene.
    The default will work just fine here as well.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AO Exponent**: This setting adjusts the contrast of the ambient lighting.
    This will make the dark areas in your scene look darker and the light areas look
    brighter. Leaving it at the default of `1` will be fine for us.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom of the page is a **Bake** button. Clicking on this button will
    start the render process. A loading bar will appear in the bottom-right corner
    of Unity, so you can monitor the progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be warned as this process is likely to take a while. Especially as the complexity
    of the environment and the number of lights increases and the detail settings
    are ramped up, this will take longer and longer to run. Also, unless you have
    a superior computer, there isn't much you can do in Unity while it is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you clicked on the button and realized that you have made a mistake, don't
    fret. After **Bake** is selected, the button changes to **Cancel**. At this time,
    it is possible to select it and stop the process from continuing. However, once
    the textures have been created and Unity starts to import them, there is no stopping
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the left-hand side of the **Bake** button is **Clear**. This button is the
    quickest and easiest way to delete and remove all of the lightmaps that are currently
    being used in the scene. This cannot be undone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to add shadows to your buildings, select **Directional Light** in your
    scene, from **Hierarchy**, and take a look at the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Shadow Type** drop-down list, select **Soft Shadows**. This simply
    turns on the shadows for this light. It turns them on for both lightmaps and real-time
    lighting. The greater the number of lights with shadows turned on, the more expensive
    they become to render. It is a good idea to turn on the shadows for your lightmap,
    but be sure to turn them off afterwards. This will conserve processing in your
    final game, while still giving your static scene a good look.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all your lights and settings match your expectations, select **Bake** and
    once it has finished processing, gaze in wonder at the now beautiful scene before
    you, as shown here:![Lightmaps](img/4691OT_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added lightmaps to our game world. The length of time it takes to just process
    this step makes it difficult to make minor tweaks. However, our lighting has vastly
    improved with a few clicks. While earlier the lights were broken by the meshes,
    we now have smooth patches of color and light.
  prefs: []
  type: TYPE_NORMAL
- en: 'When playing a game, there is only one type of light that people will not question
    the source of: sunlight. Every other light looks weird if a source is not seen.
    Create a mesh and add it to the game in order to give a reason for the lights
    you are using. This can be something along the lines of torches, lamp posts, or
    even glowing alien goo balls. Whatever they end up being, having them adds that
    touch of completeness that makes the difference between an OK-looking game and
    a great-looking game.'
  prefs: []
  type: TYPE_NORMAL
- en: As a second challenge, take a look at your lightmap's quality. Play with the
    various quality settings we discussed to see what the differences are. Also, find
    out how low the resolution can be before you notice any pixelation. Can the settings
    go even lower when running on smaller mobile device screens? Go find out.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies are a great way to add interest to the lights in your game. They use
    a texture to adjust how the light is emitted. This effect can cover a wide range
    of uses, from sparkling crystals to caged industrial lights and, in our case,
    headlights.
  prefs: []
  type: TYPE_NORMAL
- en: 'By giving our tank headlights, we give the player the ability to control the
    light in their world. Using cookies, we can make them look more interesting than
    just circles of light. Let''s add those lights with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a spotlight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the light in front of the tank and pointing away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, increase the value of the **Intensity** attribute
    to `3`. This will make our headlights bright, like real headlights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need some cookie textures. At the top of the Unity Editor, navigate
    to **Assets** | **Import Package** | **Light Cookies**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new window, click on **Import** and wait for the loading bar to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a few options to choose from. Inside the `Standard Assets` folder,
    a new folder was created, `Light Cookies`, that contains the new textures. Drag
    **Flashlight** from the **Project** window and drop it onto the **Cookie** field
    on **Spotlight** in the **Inspector** window. It is as simple as that to add a
    cookie to a light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may still not be able to see your cookie in action. It is the result of
    the same issue we were having before; too many lights can't shade the same object.
    Unfortunately, a light that is meant to move around cannot be baked into the lightmaps.
    To fix this, change the light's **Render Mode** attribute to **Important** in
    the **Inspector** panel. This will give the light priority and make it light an
    object before the other objects in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you were to bake your lights again now, you would end up with the cookie
    shape stuck on the wall of a building. We need to change **GI Mode** to **Realtime**
    so that the light is ignored by the lightmaping process but is still able to affect
    the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off, duplicate the light for the second headlight and make them both
    children of the tank. What good is it to have headlights if they don't come with
    us?![Cookies](img/4691OT_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We performed a few short steps and created a pair of headlights for our tank
    using cookies. This is exactly how many other games, especially horror games,
    create flashlight effects.
  prefs: []
  type: TYPE_NORMAL
- en: Try making a script that will allow the player to turn the headlights on and
    off. It should be a simple button that toggles the lights. Take a look at the
    `enabled` variable that is supplied as part of the light.
  prefs: []
  type: TYPE_NORMAL
- en: As a simple challenge, create a lamp that sits on the turret of the tank. Give
    it a light as well. With this, the player can point a light to where they are
    shooting and not just in the direction in which their tank is pointing.
  prefs: []
  type: TYPE_NORMAL
- en: Blob shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blob shadows are a simple and cheap method by which you can add a shadow to
    a character. They have been around since the dawn of video games. A normal shadow
    is a solid, dark projection of an object onto another surface. The contours of
    the shadow exactly match the shape of the object. This becomes expensive to calculate
    when characters start to move around randomly.
  prefs: []
  type: TYPE_NORMAL
- en: A blob shadow is a blot of black texture underneath a character or an object.
    It usually does not have a clearly definable shape and never matches the exact
    shape of the object it is meant to be the shadow of. The blob shadow also, generally,
    does not change sizes. This makes it significantly easier to calculate, making
    it the shadow of choice for many generations of video games. This also means that
    it is a better option for our mobile devices where processing speed can quickly
    become an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a blob shadow to our tank. Unity has already done the bulk
    of the work for us; we just need to add it to the tank. With these steps, we can
    add a blob shadow:'
  prefs: []
  type: TYPE_NORMAL
- en: We start this one off by importing Unity's blob shadow. Go to the top of the
    Unity Editor and navigate to **Assets** | **Import Package** | **Projectors**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Import** in the new window and look in the **Project** window for
    a new folder called `Projectors` created under `Standard Assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Blob Shadow Projector` prefab from the **Project** window to the scene
    and position it above the tank, as shown in the following screenshot:![Blob shadows](img/4691OT_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, the shadow appears on top of our tank. To fix this, we again
    need to make use of layers. So, select the tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Layer** drop-down list, select **Add Layer…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the text field at the right-hand side of **User Layer 9** and give
    it the name `PlayerTank`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your tank once more, but select **PlayerTank** from the **Layer** drop-down
    list this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the new window pops up, be sure to select **Yes, change children** to change
    the layer of the whole tank. If you don't select this, the blob shadow may appear
    on some parts of the tank, while it may not appear on other parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select `Blob Shadow Projector` from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The blob shadow is created by the **Projector** component. This component functions
    in a similar manner to the **Camera** component. However, it puts an image on
    the world rather than turning the world into an image and putting it on your screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a look at the **Inspector** window. The value we are concerned with right
    now is that of **Ignore Layers**. Right now, it is set to **Nothing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Nothing** and select `PlayerTank` from the **Layers** drop-down list.
    This will make the projector ignore the tank and only make the blob shadow appear
    underneath it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to change the size of the shadow to roughly match the size
    of the tank. Adjust the value of the **Field of View** attribute until the size
    is just about right. A value of `70` seems to be a good size to start with.![Blob
    shadows](img/4691OT_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to make `Blob Shadow Projector` a child of the tank. We need
    to be able to bring our shadow with us; we don't want to lose it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We gave our tank a shadow. Shadows are great for making objects, and especially
    characters, look like they are actually touching the ground. The blob shadow that
    we used is better than a real-time shadow because it is processed faster.
  prefs: []
  type: TYPE_NORMAL
- en: The texture that the blob shadow comes with is round, but our tank is mostly
    square. Try creating your own texture for the blob shadow and use it. Some sort
    of a rectangle should work well. If you end up with long black streaks on your
    scene, make sure that your texture has a completely white border around the edge
    of the image.
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to add your own texture to the blob shadow, then how about taking
    a look at that cannon? The cannon sticks out of our tank and ruins its otherwise
    square profile. Use a second blob shadow, attached to the turret, to project a
    shadow for the cannon. The texture for this will also have to be rectangle shaped.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be well and truly familiar with camera effects and
    lights.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started by taking a look at using multiple cameras. We then
    played around with a turbo boost camera effect. The chapter continued with the
    lighting of our city. The lights improved greatly when we made use of lightmaps.
    We finished it off with a look at cookies and blob shadows for use with some special
    lighting effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see the creation of enemies for our game. We will
    use Unity's pathfinding system to make them move around and chase the player.
    After this, the player will need to be much more active if they hope to keep their
    points.
  prefs: []
  type: TYPE_NORMAL
