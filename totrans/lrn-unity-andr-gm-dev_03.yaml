- en: Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the GUI. We started by creating a
    simple Tic-tac-toe game to learn about the basic pieces of the game. We followed
    this by changing the look of the game and making the board handle multiple screen
    orientations. We completed with a few menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is about the core of any game: meshes, materials, and animations.
    Without these blocks, there is generally nothing to show to players. You could,
    of course, just use flat images in the GUI. But, where is the fun in that? If
    you are going to choose a 3D game engine, you might as well make full use of its
    capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand meshes, materials, and animations, we will be creating a tank
    battle game. This project will be used in a few other chapters. By the end of
    the book, it will be one of the two robust games that we will have created. For
    this chapter, the player will get to drive a tank around a small city, they will
    be able to shoot at animated targets, and we will also add a counter to track
    the scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ray tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be starting a new project in this chapter, so follow the first section
    to get it started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though this project will eventually grow to become much larger than the previous
    ones, the actual setup is similar to the previous projects and is not overly complex.
    You will need a number of starting assets for this project; they will be described
    during the setup process. Due to the complexity and specific nature of these assets,
    it is recommended to use the ones provided with the code bundle of this book for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in the previous two chapters, we will need to create a new project
    so that we can create our next game. Obviously, the first thing to do is to start
    a new Unity project. For organizational purposes, name it `Ch3_TankBattle`. The
    following points are the prerequisites that are required for this project to kick-start:'
  prefs: []
  type: TYPE_NORMAL
- en: This project will also grow to become much larger than our previous projects,
    so we should create some folders to keep things organized. For starters, create
    six folders. The top-level folders will be the `Models`, `Scripts`, and `Prefabs`
    folders. Inside `Models`, create `Environment`, `Tanks`, and `Targets`. Having
    these folders makes the project significantly more manageable. Any complete model
    can consist of a mesh file, one or more textures, a material for every texture,
    and potentially dozens of animation files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we continue, it is a good idea to change your target platform to Android,
    if you haven't already done so. Every time the target platform is changed, all
    of the assets in the project need to be reimported. This is an automatic step
    carried out by Unity, but it will take an increasing amount of time as our project
    grows. By setting our target platform before there is anything in the project,
    we save lots of time later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will also make use of a very powerful part of Unity: prefabs. These are
    special objects that make the process of creating a game significantly easier.
    The name means prefabricated—created beforehand and replicated. What this means
    for us is that we can completely set up a target for our tank to shoot at and
    turn it into a prefab. Then, we can place instances of the prefab throughout the
    game world. If we ever need to make a change to the targets, all we need to do
    is modify the original prefab. Any change made to a prefab is also made on any
    instance of that prefab. Don''t worry; it makes more sense when it is used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to create some meshes and textures for this project. To start with,
    we will need a tank (it is kind of hard to have a battle of tanks without any
    tanks). The tank that is provided with this code bundle has a turret and cannon,
    which are separate pieces. We will also use a trick to make the tank's treads
    look like they are moving, so each of them are a separate piece and uses a separate
    texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will need an animated target. The one that is provided with the
    code bundle of this book is rigged up like the human arm with a bull's eye for
    the hand. It has four animations. The first starts in a curled position and goes
    to an extended position. The second is the reverse of the first one, going from
    the extended position to the curled position. The third starts in the extended
    position and is flung back, as if it is hit in the front, and returns to the curled
    position. The last is just like the third one, but it goes forward as if it is
    hit from behind. These are fairly simple animations, but they will serve us well
    in learning about Unity's animation system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Very little happened here; we simply created the project and added some folders.
    There was also a little discussion about the assets that we would be using for
    this chapter's project.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to import assets to Unity. We will be going through
    perhaps the simplest (and certainly the best) ways to import groups of assets.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Unity Editor, start by right-clicking on your `Tanks` folder and
    select **Show in Explorer** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens the folder that contains the asset that was selected. In this case,
    the `Models` folder opens in the Windows' folder browser. We just need to put
    our tank and its textures into the `Tanks` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The files provided for this chapter are `Tank.blend`, `Tanks_Type01.png`, and
    `TankTread.png`. In addition, utilizing the `.blend` files in Unity requires Blender
    to be installed in your system. Blender is a free modeling program that is available
    at [http://www.blender.org](http://www.blender.org). Unity makes use of it in
    order to convert the previously mentioned files into ones that it can fully utilize.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we return to Unity, the fact that we added files will be detected, and
    they will automatically be imported. This is one of the best things about Unity.
    There is no need to explicitly tell Unity to import. If there are changes within
    the project's assets, it just updates the assets automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may also notice that an extra folder and some files were created when Unity
    imported our tank. Whenever a new mesh is imported, by default Unity will try
    to pair it with the materials. We will go into more detail about what a material
    is in Unity in the next section. For now, it is an object that keeps track of
    how to display a texture on a mesh. Based on the information in the mesh, Unity
    looks in the project for a material with the correct name. If one cannot be found,
    a `Materials` folder is created next to the mesh and the missing materials are
    created inside it. When creating these materials, Unity also searches for the
    right textures. This is why it is important to add textures to the folder at the
    same time as the mesh, so that they can all be imported together. If you did not
    add the textures at the same time as the tank, the section about creating materials
    will describe how to add textures to materials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have imported our tank into Unity. It is really quite simple. Changes made
    to any of the assets or folders of the project are automatically detected by Unity,
    and anything that is needed is accordingly imported.
  prefs: []
  type: TYPE_NORMAL
- en: Tank import settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Importing any asset into Unity is done by using a default group of settings.
    Any of these settings can be changed from the **Inspector** window. With your
    new tank selected, we will go over the import settings for a model here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tank import settings](img/4691OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see in the preceding screenshot that the top of the **Inspector** window
    has three tabs: **Model**, **Rig**, and **Animations**. The **Model** page handles
    the mesh itself, while **Rig** and **Animations** are for importing animations.
    For now, we only care about the **Model** page, so select it if it is not already
    selected. Each section of the **Model** page is broken down here.'
  prefs: []
  type: TYPE_NORMAL
- en: Meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Meshes** section of the previous screenshot has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Meshes** section of the **Import Settings** window starts with the **Scale
    Factor** attribute. This is a value that tells Unity how big the mesh is by default.
    One generic unit or one meter from your modeling program translates to one unit
    in Unity. This tank was made in generic units, so the tank's scale factor is one.
    If you were working in centimeters when making the tank, the scale factor would
    be 0.01 because a centimeter is a hundredth of a meter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **File Scale** option is the scale used in the modeling program when the
    model was originally created. It is primarily informational. If you need to adjust
    the size of the imported model, adjust the **Scale Factor**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next option, **Mesh Compression**, will become important in the final chapter
    when we go over the optimization of our games. The higher the compression is set
    to, the smaller will be the size of the file in the game. However, this will start
    to introduce weirdness in your mesh as Unity works to make it smaller. For now,
    leave it as **Off**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Read/Write Enabled** option is useful if you want to make changes to the
    mesh while the game is playing. This allows you to do some really cool things,
    such as destructible environments, where your scripts break the meshes into pieces
    based on where they are being shot. However, it also means that Unity has to keep
    a copy of the mesh in memory, which could really start to lag a system if it is
    complex. This is outside the scope of this book, so unchecking this option is
    a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optimize Mesh** option is a good one to leave on, unless you are doing
    something specific and fancy with the mesh. With this on, Unity does some special
    'behind the scenes' magic. In computer graphics and especially Unity, every mesh
    is ultimately a series of triangles that are drawn on a screen. This option allows
    Unity to reorder the triangles in the file so that the whole mesh can be drawn
    faster and more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Import BlendShapes** option allows Unity to make sense of any BlendShapes
    that might be part of the model. These are animated positions of the vertexes
    of the model. Usually, they are used for facial animations. The next option, **Generate
    Colliders**, is a useful one if you're doing complex things with physics. Unity
    has a set of simple collider shapes that should be used whenever possible because
    they are easier to process. However, there are situations where they won't quite
    get the job done; for example, a rubble or a half-pipe where the collision shape
    is too complex to be made with a series of simple shapes. That is why Unity has
    a **Mesh Collider** component. With this option checked, a **Mesh Collider** component
    is added to every mesh in our model. We will be sticking with simple colliders
    in this chapter, so leave the **Generate Colliders** option off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Swap UVs** and **Generate Lightmap UVs** options are primarily used when
    working with lighting, especially lightmaps. Unity can handle two sets of UV coordinates
    on a model. Normally, the first is used for the texture and the second for the
    lightmap or shadow texture. If they are in the wrong order, **Swap UVs** will
    change them so that the second set comes first. If you need an unwrap for a lightmap
    but did not create one, **Generate Lightmap UVs** will create one for you. We
    are not working with lightmaps in this project, so both of these can remain off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normals & Tangents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Normals & Tangents** section of the earlier screenshot has the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: The next section of options, **Normals & Tangents**, begins with the **Normals**
    option. This defines how Unity will hold the normals of your mesh. By default,
    they are imported from the file; however, there is also the option to make Unity
    calculate them based on the way the mesh is defined. Otherwise, if we set this
    option to **None**, Unity will not import the normals. Normals are needed if we
    want our mesh to be affected by real-time lighting or make use of normal maps.
    We will be making use of real-time lighting in this project, so leave it set to
    **Import**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Tangents**, **Smoothing Angle**, and **Split Tangents** options are used
    if your mesh has a normal map. Tangents are needed to determine how lighting interacts
    with a normal mapped surface. By default, Unity will calculate these for you.
    Importing tangents is only possible from a few file types. The smoothing angle,
    based on the angle between the two faces, dictates whether shading across an edge
    would be smooth or sharp. The **Split Tangents** option is there to handle a few
    specific lighting quirks. If lighting is broken by seams, enabling this option
    will fix it. Normal maps are great for making a low-resolution game look like
    a high-resolution one. However, because of all the extra files and information
    needed to use them, they are not ideal for a mobile game. Therefore, we will not
    be using them in this book and so all of these options can be turned off to save
    memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Keep Quads** option will allow your models to take advantage of DirectX
    11's new tessellation techniques for creating high-detail models from low-detail
    models and a special displacement map. Unfortunately, it will be a while before
    mobile devices can support such detail, and even longer before they become commonplace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Materials** section of the previous screenshot has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: The last section, **Materials**, defines how Unity should look for materials.
    The first option, **Import Materials**, allows you to decide whether or not a
    material should be imported. If it is turned off, a default white material will
    be applied. This material will not show up anywhere in your project; it is a hidden
    default. For models that will not have any textures, such as collision meshes,
    this can be turned off. For our tank and nearly every other case, this should
    be left on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two options, **Material Naming** and **Material Search**, work together
    to name and find the materials for the mesh. Directly below them, there is a text
    box that describes how Unity will go about searching for the material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the material being searched for can be the name of the texture used
    in the modeling program, the name of the material created in the modeling program,
    or the name of the model and the material. If a texture name cannot be found,
    the material name will be used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Unity does a recursive-up search. This means that we start the search
    by looking in the `Materials` folder, followed by a search for any materials that
    are in the same folder. We then check the parent folder for matching materials,
    followed by the folder above that. This continues until we find either the material
    that has the correct name or we reach the root assets folder.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we have the options of checking the entire project or only looking
    in the `Materials` folder that is next to our model. The defaults for these options
    are just fine. In general, they do not need to be changed. They can be easily
    dealt with, especially for a large project, using the Unity Editor scripting,
    which will not be covered in this book.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Revert and Apply buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, the screenshot has the **Revert** and **Apply** buttons, which are explained
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever changes are made to the import settings, one of the two buttons, **Revert**
    or **Apply**, must be chosen. The **Revert** button cancels the changes and switches
    the import settings back to what they were before changes were made. The **Apply**
    button confirms the changes and reimports the model with the new settings if these
    buttons are not selected; Unity will complain with a pop up and force you to make
    a choice before letting you mess with anything else.![The Revert and Apply buttons](img/4691OT_03_02.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have two types of previews as we can see in the previous screenshot.
    The **Imported Object** section is a preview of what the object will look like
    in the **Inspector** window, if we added the object to the **Scene** view and
    selected it. The **Preview** window, the section where we can see the tank model,
    is what the model will look like in the **Scene** view. You can click and drag
    the object in this window to rotate it and look at it from different angles. In
    addition, there is a little blue button in this window. By clicking on this button,
    you will be able to add labels to the object. Then, these labels will also be
    searchable in the **Project** window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the tank
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have imported the tank, we need to set it up. We will be adjusting
    the arrangement of the tank as well as creating a few scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The tank
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the creation of our tank will primarily consist of the creation
    and arrangement of the tank''s components. Using the following steps, we can set
    up our tank:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by dragging the tank from the **Project** window to the **Hierarchy**
    window. You will notice that the name of the tank appears in blue color in the
    **Hierarchy** window. This is because it is a prefab instance. Any model in your
    project largely acts like a prefab. However, we want our tank to do more than
    just sit there; so, being a prefab of a static mesh is not helpful. Therefore,
    select your tank in the **Hierarchy** window and we will start to make it useful
    be removing the **Animator** component. To do this, select the gear to the right
    of the Animator component in the **Inspector** window. From the new drop-down
    list, select **Remove Component**, as seen in the following screenshot, and it
    will be removed:![The tank](img/4691OT_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using the tank that is provided by default, selecting the different
    parts of it will reveal that all the pivot points are at the base. This will not
    be useful for making our turret and cannon pivot properly. The easiest way to
    solve this is by adding new empty **GameObjects** to act as pivot points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Any object in the scene is a `GameObject`. Any empty `GameObject` is one that
    only has a **Transform** component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the Unity Editor, **Create Empty** is the first option under the
    **GameObject** button. It creates the objects that we need. Create two empty GameObjects
    and position one at the base of the turret and the other at the base of the cannon.
    In addition, rename them as `TurretPivot` and `CannonPivot` respectively. This
    can be done with the textbox at the very top of the **Inspector** window if the
    object is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, drag `TurretPivot` onto `Tank`. This changes the
    parent of `TurretPivot` to `Tank`. Then, drag the object, that is, the turret
    mesh, onto `TurretPivot`. In the code, we will be rotating the pivot point and
    not the mesh directly. When a parent object moves or rotates, all of the children
    objects move with it. When you make this change, Unity will complain about the
    change to the original hierarchy of the object; it does this just to make sure
    that it is a change that you want to make and not an accident:![The tank](img/4691OT_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As losing the connection to the prefab can potentially break a game, Unity just
    wants to be sure that we actually want it to happen. So, click on **Continue**
    and we can finish working with the tank without other complaints from Unity. We
    also need to make `CannonPivot` a child of `TurretPivot` and the cannon a child
    of `CannonPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish our hierarchy changes, we need to place the camera. Since we want
    the player to appear as if they are is actually in the tank, the camera should
    be placed behind and above the tank with a tilt slightly downward to focus on
    a spot a few tank lengths ahead. Once it is positioned, make it a child of `TurretPivot`
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have set up the basic structure that our tank will use. By making use of
    multiple objects in this way, we can control their movements and actions independently
    from each other. At this point, instead of having a rigid tank that only points
    forward, we can tilt, rotate, and aim each piece independently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also, the tank should be centered above the point at which you want the whole
    thing to pivot around. If yours is not, you can select everything that is under
    the base tank object in the **Hierarchy** window and move it around.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A short script for keeping track of a player''s score and the addition of a
    text element will constitute the focus of this short section. The following are
    the steps for the creation of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: The first script that is needed to make our tank work is fairly simple. Create
    a new script and name it `ScoreCounter`. It will, as the name implies, track the
    score. Create it in the `Scripts` folder and clear out the default functions,
    just like every other script that we have made so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like we did in the previous chapter, since any script that needs access
    to any of our GUI elements needs an extra line at the very top of the script,
    add the following line of code right after the line that says `using UnityEngine;`.
    This allows us to use and change the text element we need to display the score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following line of code should look familiar from the previous chapter.
    First, we define an integer counter. As it is static, other scripts (such as the
    ones we will create for the targets) will be able to modify this number and give
    us the score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then add a variable to store the text element for our interface. It
    will work like the turn indicator from the previous chapter, giving us a location
    to update and display the player''s score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last bit of code for this script is an `Update` function. This function
    is called automatically by Unity for every single frame. This is the perfect spot
    for us to put any code and logic that needs to change regularly without the player''s
    direct input. For our purpose, we will update the text element and make certain
    that it always has the most up-to-date score to display. By adding the score to
    double quotes, we are changing the number into a word so that it can be used properly
    by the text element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it for this very simple script. It will track our score throughout the
    game. In addition, instead of doing any of the score increments itself, other
    scripts will update the counter to give points to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The buttons that we have used so far only perform an action when they are pressed
    and released. Our players will need to hold down the buttons to control their
    tank. So, we need to create a repeat button; a button that performs an action
    as long as it is held down. Follow these steps to create a repeat button:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script that should be named as `RepeatButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To give this script access to the parts of Unity that it needs in order to
    work, just like the previous script, we need to add the following two lines right
    after the one that says `using UnityEngine;`. The first will give us access to
    the `Selectable` class: the one from which all interactive interface elements
    are derived. The second will let us handle the events that occur when our players
    interact with our new button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to update the `public class` line of our code. Any normal script
    that will provide functionality to the objects in our game expands upon the `MonoBehaviour`
    class. We need to change the line to the following, so that our script can instead
    exist in and expand the functionality of the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our script will have a total of four variables. The first allows it to keep
    track of whether or not it is being pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next three variables will provide the same functionality as the button
    did in the previous chapter. For the button, we had to select an object, followed
    by a function from a specific script, and finally some value to send. Here, we
    are going to do the same thing. The first variable here keeps track of which object
    in the scene we are going to interact with. The second will be the name of a function
    that is on some of the script attached to the object. The last will be a number
    to send along for the function, and it will provide more specific input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first function for this script will override a function provided by the
    `Selectable` class. It is called the moment the player clicks on the button. It
    is given some information about how and where it was clicked, which is stored
    in `eventData`. The second line just calls the function of the same name on the
    parent class. The last thing the function does is set our Boolean flag to mark
    that the button is currently being pressed by the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function does the exact same thing as the previous function. The main
    difference is that it is called when the mouse or touch from the player is no
    longer over the button in the interface. The second difference is that it sets
    the Boolean to `false` because when our player drags their finger off the button,
    they are no longer pressing it, and we want to stop performing our action in that
    case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following function is like the first two. However, it is called when the
    button is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final function of this script is again our `Update` function. It first
    checks whether the player is currently pressing this button. It then calls the
    `SendMessage` function on our target object, telling it what function to perform
    and what number to use. The `SendMessage` function is only available for **GameObject**
    and **MonoBehviour** components. It takes the name of a function and tries to
    find it on the GameObject to which the message was sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another script done! This one allows us to hold buttons rather than be forced
    to press them repeatedly to move through our game.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the chassis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A normal tank rotates in place, and it can easily move forward and back. We
    will make our tank do this with the creation of a single script. Perform these
    steps to create our second script for the tank:'
  prefs: []
  type: TYPE_NORMAL
- en: The second script is called `ChassisControls`. It will make our tank move around.
    We will create it in the `Scripts` folder as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first three lines of the script define the variables that the tank will
    need to move around. We will also be able to change them in the **Inspector**
    window, in case our tank is too fast or too slow. The first line defines a variable
    that holds a connection to a `CharacterController` component. This component will
    not only move the tank around easily but it will also allow it to stop by walls
    and other colliders. The next two lines of code define how fast we move and rotate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start the following line of code by defining our `MoveTank` function; it
    needs to be passed a `speed` value to dictate how far and in which direction the
    tank should go. A positive value will make the tank go forward and a negative
    value will make it go backwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to move in a three-dimensional space, we need a vector—a value with
    both direction and magnitude. Therefore, we define a movement vector and set it
    to the tank's forward direction, multiplied by the tank's speed, and again multiplied
    by the amount of time that has elapsed since the last frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you remember from geometry class, 3D space has three axes: x, y, and z.
    In Unity, the following convention applies: x is to the right, y is up, and z
    is forward. The transform component holds these values for an object''s position,
    rotation, and scale. We can access the transform component of any object in Unity
    by calling upon the `transform` variable that Unity provides. The `transform`
    component also provides a `forward` variable that will give us a vector that points
    in the direction in which the object is facing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we want to move at a regular pace, for example, a certain number
    of meters per second; therefore, we make use of `Time.deltaTime`. This is a value
    provided by Unity that holds how many seconds it has been since the last frame
    of the game was drawn on screen. Think of it like a flip book. In order to make
    it look like a guy is walking across the page, he needs to move slightly on each
    page. In the case of a game, the pages are not flipped regularly. So, we have
    to modify our movement by how long it has taken to flip to the new page. This
    helps us to maintain an even pace.x2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to stay on the ground. In general, any character you want to
    control in a game does not automatically receive all of the physics, such as gravity,
    that a boulder would. For example, when jumping, you temporarily remove gravity
    so that the character can go up. That is why the next line of code does a simple
    implementation of gravity by subtracting the normal speed of gravity and then
    keeping it in pace with our frame rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, for the `MoveTank` function, we actually do the moving. The `CharacterController`
    component has a special `Move` function that will move the character but constrain
    it by collisions. We just need to tell it how far and in which direction we want
    to move this frame by passing the `move` vector to it. This final curly brace,
    of course, closes off the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RotateTank` function also needs a speed value to dictate how fast and in
    which direction to rotate. We start by defining another vector; however, instead
    of defining in which direction to move, this one will dictate in which direction
    to rotate around. In this case, we will be rotating around our up direction. We
    will then multiply that by our `speed` and `Time.deltaTime` parameters to move
    fast enough and keep pace with our frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last bit of the function actually does the rotation. The **Transform**
    component provides a `Rotate` function. Rotation, especially in 3D space, can
    become weird and difficult very quickly. The `Rotate` function handles all of
    that for us; we just need to supply it with the values to apply for rotation.
    In addition, don''t forget the curly brace to close off the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a script to control the movement of our tank. It will use a special
    `Move` function from the `CharacterController` component so that our tank can
    move forwards and backwards. We also used a special `Rotate` function provided
    by the **Transform** component to rotate our tank.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the turret
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This next script will allow the player to rotate their turret and aim the cannon:'
  prefs: []
  type: TYPE_NORMAL
- en: The last script that we need to create for our tank is `TurretControls`. This
    script will allow players to rotate the turret left and right and tilt the cannon
    up and down. As with all of the others, create it in the `Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first two variables that we define will hold pointers to the turret and
    cannon pivots- the empty `GameObjects` that we created for our tank. The second
    set is the speed at which our turret and cannon will rotate. Finally, we have
    some limit values. If we didn''t limit how much our cannon could rotate, it would
    just spin around and around, passing through our tank. This isn''t the most realistic
    behavior for a tank, so we must put some limits on it. The limits are in the range
    of 300 because straight ahead is zero degrees and down is 90 degrees. We want
    it to be in the upward angle, so it is in the range of 300\. We can also use 359.9
    because Unity will change 360 to zero so that it can continue to rotate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the `RotateTurret` function. It works in exactly the same way as the
    `RotateTank` function. However, instead of looking at a `CharacterController`
    component''s `transform` variable, we act upon the `turretPivot` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second and last function, `RotateCannon`, gets a little more down-and-dirty
    with rotations. The fault completely lies with the need to put limits on the rotation
    of the cannon. After opening the function, the first step is to figure out how
    much we are going to be rotating this frame. We use a float value instead of a
    vector because we have to set the rotation ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we define a variable that holds our current rotation. We do this because
    Unity will not let us act on the rotation directly. Unity actually keeps track
    of rotation as a quaternion. This is a complex method of defining rotations that
    is beyond the scope of this book. Luckily, Unity gives us access to an x, y, and
    z method of defining rotations called `EulerAngles`. It is a rotation around each
    of the three axes in 3D space. The `localEulerAngles` value of a **Transform**
    component is the rotation relative to the parent **GameObject**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is called `EulerAngles` because of Leonhard Euler, a Swiss mathematician,
    who came up with this method of defining rotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we adjust the rotation and apply the limits in one go through the use
    of the `Mathf.Clamp` function. `Mathf` is a group of useful mathematical functions.
    The `clamp` function takes a value and makes it no lower and no higher than the
    other two values passed to the function. So, we first send it our *x* axis rotation,
    which is the result of subtracting rotate from the current x rotation of `euler`.
    As the positive rotation is clockwise around an axis, we have to subtract our
    rotation to go up instead of down with a positive value. Next, we pass our lower
    limit to the `Clamp` function, followed by our higher limit: these are the `lowCannonLimit`
    and `highCannonLimit` variables that we defined at the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have to actually apply the new rotation to our cannon''s pivot
    point. This involves simply setting the `localEulerAngles` value of the **Transform**
    component to the new value. Again, be sure to use the curly brace to close off
    the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now created a script that will control the turret of the tank. The player
    will be able to control the tilt of the cannon and rotation of the turret. This
    script functioned in a very similar manner to the `ChassisControls` script that
    we created earlier—the difference was in limiting the amount the cannon can tilt.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the pieces together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That was the last of the scripts for the moment. We have our tank and our scripts;
    the next step is to put them together:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to add the scripts to our tank. Remember how we added our `Tic-tac-toe`
    script to the camera in the last chapter? Start by selecting your tank in the
    **Hierarchy** window. Before these scripts work, we will first need to add the
    `CharacterController` component to our tank. So, go to the top of the Unity Editor
    and select **Component**, then select **Physics**, and finally click on the **Character
    Controller** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that a green capsule appears on the tank in the **Scene** view
    as soon as you add the new component. This capsule represents the space that will
    collide and interact with other colliders. The values on the **Character Controller**
    component let us control how it interacts with other colliders. For most cases,
    the defaults for the first four parameters are just fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Putting the pieces together](img/4691OT_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The parameters in **Character Controller** are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Slope Limit**: This attribute shows us how steep an incline the controller
    can move up.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Offset**: This attribute shows us how high a step can be before it starts
    to block movement.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skin Width**: This defines how far another collider can penetrate this controller''s
    collider before it is completely stopped. This is mostly used for squeezing between
    objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Move Distance**: This attribute is for limiting jitter. It is the minimum
    amount of movement that has to be applied in a frame before it will actually move.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Center**/**Radius**/**Height**: These attributes define the size of the capsule
    that you see in the **Scene** view. They are used for the collision.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last three values are the most important right now. We need to adjust these
    values as closely as possible to match our tank's size. Admittedly, the capsule
    is round and our tank is square, but a `CharacterController` component is the
    easiest way to move a character with collision, and it will be used the most often.
    Use values of `2.3` for the **Radius** attribute and the **Y** portion of the
    **Center** attribute; everything else can be left as the default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is now time to add the scripts to our tank. Do this by selecting the tank
    in the **Hierarchy** window and dragging the `ChassisControls`, `TurretControls`,
    and `ScoreCounter` scripts onto the **Inspector** window. This is just as we did
    in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to finish creating the connections that we started in our scripts.
    Start by clicking the `CharacterController` component's name and dragging it to
    the **Character Control** slot that is on our new `ChassisControls` script component.
    Unity lets us connect object variables in the Unity Editor so that they do not
    have to be hardcoded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to connect our turret and cannon pivot points. So, click and drag
    the points from the **Hierarchy** window to the corresponding variable on the
    `TurretControls` script component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can test our game, we need to create a bunch of GUI buttons to actually
    control our tank. Start by creating a canvas, just like we did in the previous
    chapter, and one empty GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty GameObject needs a **Rect Transform** component, and it needs to be
    made a child of `Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to `LeftControls` and set its anchor to **bottom left**. In addition,
    set **Pos X** to `75`, **Pos Y** to `75`, **Pos Z** to `0`, **Width** to `150`,
    and **Height** to `150` as shown in the following screenshot:![Putting the pieces
    together](img/4691OT_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need four buttons to be the children of `LeftControls`. As in the last
    chapter, they can be found at the top of the editor by navigating to **GameObject**
    | **UI** | **Button**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the four buttons to `Forward`, `Back`, `Left`, and `Right`. While you're
    at it, you can also change their text child to have the relevant text, such as
    `F`, `B`, `L`, and `R`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button only activates when the player clicks and releases it. Clicking repeatedly
    just to make the tank move will not work very well. So, click on the gear to the
    right of each of their **Button** components and select **Remove Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add our `RepeatButton` script to each. As we extended that `Selectable`
    class, you can see that we have all the same controls over our button that we
    did on the other buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the values of **Width** and **Height** of all the four buttons to `50`.
    Their positions become as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Button | Pos X | Pos Y |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Forward | 0 | 50 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Left | -50 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Back | 0 | -50 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Right | 50 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '![Putting the pieces together](img/4691OT_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now that we have our four movement buttons, we need to connect them to our tank.
    For each of the buttons, drag `Tank` from the **Hierarchy** panel and drop it
    in the **Target** slot in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we next set the **Function** and **Value** slots, spelling is very important.
    If something is a little bit off, your function will not be found, lots of errors
    will appear, and the tank will not work. For the `Forward` button, set the **Function**
    slot to `MoveTank` and the **Value** slot to `1`. The `Back` button also needs
    the value of `MoveTank` in the **Function** slot, but it needs a value of `-1`
    in the **Value** slot. The `Left` button needs a value of `RotateTank` in the
    **Function** slot and a value of `-1` in the **Value** slot. The `Right` button
    needs a value of `RotateTank` in the **Function** slot and `1` in the **Value**
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set up our turret controls. Right-click on `LeftControls` in
    the **Hierarchy** window and select **Duplicate** from the new menu. Rename the
    new copy to `RightControls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This new control set needs an anchor set of **bottom right**, a **Pos X** of
    `-75`, and **Pos Y** of `75` (as shown in the following screenshot):![Putting
    the pieces together](img/4691OT_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The buttons under this set will need to be renamed as `Up`, `Down`, `Left`,
    and `Right`. Their text can be changed to `U`, `D`, `L`, and `R` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Function** slot of the `Up` button should be set to `RotateCannon` with
    the value of the **Value** slot as `1`. The `Down` button has a **Function** slot
    value of `RotateCannon` and a **Value** slot value of `-1`. The `Left` button
    needs `RotateTurret` as the value of the **Function** slot with a value of `-1`
    for the **Value** slot. Finally, the `Right` button needs a **Function** slot
    value of `RotateTurret` with a **Value** slot value of `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do is to create a new Text element that can be found by navigating
    to **GameObject** | **UI** | **Text** and rename it as `Score`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select your `Tank` and drag `Score` from the **Hierarchy** window to
    the **Display** slot of the **Score Counter (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene as `TankBattle` and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just finished putting our tank together. Unless you look at the **Scene**
    view while using the movement controls, it is hard to tell that the tank is moving.
    The turret controls can be seen in the **Game** view though. Other than not having
    a point of reference for whether or not our tank is moving, it runs pretty well.
    The next step and the next section will give us that reference point as we add
    our city.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice a quick jump when you first try to tilt the cannon. Such behavior
    is annoying and makes the game look broken. Try adjusting the cannon to fix it.
    If you are having trouble with it, take a look at the cannon's starting rotation.
    It has to do with the way the rotation is clamped every time we try to move it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, the materials are the defining factor for how models are drawn on
    the screen. They can be as simple as coloring it all blue or as complex as reflecting
    water with waves. In this section, we will cover the details of the controls for
    a material. We will also create our city and some simple materials to texture
    it with.
  prefs: []
  type: TYPE_NORMAL
- en: The city
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a city gives our tanks and our players a good place to play. Follow
    these steps to create our city:'
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this section, no part of the city provided with the code
    bundle of this book was given a specific texture. It was just unwrapped and some
    tile-able textures were created. So, we need to start by importing the city and
    the textures to the `Environment` folder. Do this in the same the way in which
    we imported the tank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The files are `TankBattleCity.blend`, `brick_001.png`, `brick_002.png`, `brick_003.png`,
    `dirt_001.png`, `dirt_003.png`, `pebbles_001.png`, `rocks_001.png`, `rubble_001.png`,
    and `water_002.png`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As the city is unwrapped, Unity will still create a single material for it.
    However, textures were never applied in any modeling program. So, the material
    is plain white. We have several extra textures, so we are going to need more than
    just that one material for the whole city. Creating a new material is simple;
    it is done just like creating a new script. Right-click on the `Materials` folder
    inside the `Environment` folder, select **Create**, and then click on **Material**,
    which is about halfway down the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a new material in the folder and immediately allow us to name
    it. Name the material as `Pebbles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your new material selected, take a look at the **Inspector** window. When
    we have selected a material, we get the options that are needed to change its
    look:![The city](img/4691OT_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the following things from the preceding screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the very top of the **Inspector** window, we have the material's name followed
    by a **Shader** drop-down list. A shader is essentially a short script that tells
    the graphics card how to draw something on the screen. You will use the **Standard**
    shader most often; it is essentially an all-inclusive shader, so it is always
    selected by default. This is where you would select any special effect or custom
    shaders.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Rendering Mode** drop-down menu lets you pick whether or not this material
    will use any amount of transparency. **Opaque** means it will be solid. The **Cutout**
    option will render with a sharp edge around transparent areas of your texture,
    based on the value of **Alpha Cutoff**. The **Transparent** option will give you
    a smooth edge that is based on the alpha channel of your texture.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Main Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Main Maps** section has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Main Maps** section starts with **Diffuse,** where you put your main color
    texture. It can be tinted with the color picker to the right of the slot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Specular** option defines the shininess of your material; think of it
    like the glare from the light on your device's screen. You can either use an image
    to control it, or you can use the color picker to determine what color is reflected
    and the smoothness to control how sharp the glare is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Normal Map** option lets you add a texture that controls shading across
    the surface of your material. These textures need to be specially imported. If
    the texture you pick hasn't been set properly, a warning box will appear where
    you can select **Fix Now** to change it. A slider will also appear, giving you
    control over how much effect the texture has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Height Map** option works in a manner similar to **Normal Map**. It adjusts
    the bumpiness of your material and gives a slider to adjust it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Occlusion** option lets you add an ambient occlusion texture to the material,
    controlling the darkness or lightness of the material based on the proximity of
    objects to each other in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Emission** option gives you control over the projected light and color
    that a material gives off. This only affects lightmaps and the appearance of this
    material. To actually give off light dynamically, it has to be faked with the
    addition of a real-time light.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Detail Mask** option lets you control where the textures in **Secondary
    Maps** appear on your material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values of **Tiling** and **Offset** control the size and position of the
    textures. The values of **Tiling** dictate how many times the texture will repeat
    across the normalized UV space in the x and y directions. The **Offset** parameter
    is how far from zero the texture starts in the normalized UV space. You can select
    the number fields and input values to modify them. By doing so, and paying attention
    to the **Preview** window at the bottom, you will see how they change the texture.
    Tiling textures are most commonly used for large surfaces where the texture is
    similar across the surface and a particular texture just repeats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Secondary Maps** section has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secondary Maps** starts with **Detail Diffuse x2**, which is an extra diffuse
    texture to be blended on top of your main diffuse texture. It could be used to
    add a bumpy variation across the surface of your boulder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normal Map** works like the main **Normal Map** slot and controls the shading
    of the detail textures.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second set of **Tiling** and **Offset** values work like the first and just
    control the detail textures. Usually these are set higher than the first to add
    extra interest across the surface of the material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**UV Set** just lets you select the model unwrap set that the detail textures
    are going to use on the model to which the material is applied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `pebbles_001` texture to this material by dragging it from the **Project**
    window and dropping it on the square to the right of the **Diffuse** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the color of the texture better, use the color picker to the right of
    the **Diffuse** slot and pick a light tan color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A value of `30` for both the **X** and **Y** values of the main **Tiling** will
    make it easier to see when **Tiling** is applied to our city streets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see our new material in action, first drag your city to the **Hierarchy**
    window so that it is added to the **Scene** view. By right-clicking and dragging,
    you can look around in your **Scene** view, and by using *W*, *A*, *S*, and *D*,
    you can move around. Look over at the streets of the city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag your new material from the **Project** window into your **Scene**
    view. While dragging the material around, you should see that the meshes change
    to appear as if they are using the material. Once you are over the streets, let
    go of your left mouse button. The material is now applied to the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we currently have a whole quarter of a city to texture. So, create
    more materials and use the remaining textures on the rest of the city. Create
    a new material for each extra texture, and four extra textures of `brick_002`,
    so that we can have different colors for each building's height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply your new materials to the city, either by looking at the following screenshot
    or through your own artistic sensibility:![Secondary Maps](img/4691OT_03_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are trying to get to the center fountain, if your tank is in the way,
    select your tank in the **Hierarchy** window and use the **Gizmo** in the **Scene**
    view to drag it out of the way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you were to try to play the game now, you might notice that we have a couple
    of problems. For starters, we only have a quarter of a city; perhaps you have
    more if you made your own city. In addition, there is still no collision on the
    city, so we will fall right through it when we move.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Changing the size of our tank is pretty simple. Select it in the **Hierarchy**
    window and look for the **Scale** label in our **Transform** component. Changing
    the **X**, **Y**, and **Z** values under **Scale** will change the size of our
    tank. Be sure to change them evenly or some weirdness will occur when we start
    rotating the tank. Values of `0.5` make the tank small enough to fit through the
    small streets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is collision for the city. For the most part, we will be able to get
    away with simple collision shapes that are faster to process. However, the circular
    center of the city will require something special. Start by double-clicking on
    the walls of one of the square buildings in the **Scene** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with prefabs, which the city still is, clicking on any object that
    makes up the prefab will select the root prefab object. Once a prefab is selected,
    clicking on any part of it will select that individual piece. Because this behavior
    is different from non-prefab objects; you need to be mindful of this when you
    select objects in the **Scene** view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With a set of walls selected, go to the top of the Unity Editor and select **Component**,
    followed by **Physics**, and finally select **Box Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are adding the collider to a specific mesh, Unity does its best to automatically
    fit the collider to the shape. For us, this means that the new `BoxCollider` component
    is already sized to fit the building. Continue by adding `BoxCollider` components
    to the rest of the square buildings and the outer wall. Our streets are essentially
    just a plane, so a `BoxCollider` component will work just fine for them as well.
    Though it is pointed at the top, the obelisk at the center of the fountain is
    essentially just a box; so another `BoxCollider` will suit it fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have one last building and the fountain ring to deal with. These are not
    boxes, spheres, or capsules. So, our simple colliders will not work. Select the
    walls of the last building, the one next to the center fountain. A few options
    down from where you selected **Box Collider**, there is a **Mesh Collider** option.
    This will add a `MeshCollider` component to our object. This component does what
    its name suggests; it takes a mesh and turns it into a collider. By adding it
    to a specific mesh, the `MeshCollider` component automatically selects that mesh
    to be "collideable". You should also add `MeshCollider` components to the short
    ledge around the center building and the ring wall around the fountain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last problem to solve is the duplication of our city quarter. Start by selecting
    the root city object in your **Hierarchy** window, select `TankBattleCity`, and
    remove the `Animator` component from it. The city is not going to animate, so
    it does not need this component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the city in the **Hierarchy** window and click on **Duplicate**.
    This creates a copy of the object that was selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the city quarter two more times and we will have the four parts of
    our city. The only problem is that they will all be in the exact same position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to rotate three of the pieces to make a full city. Select one and set
    the value of **Y Rotation** in the **Transform** component to `90`. This will
    rotate it 90 degrees around the vertical axis and give us half of a city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will complete the city by setting one of the remaining pieces to `180` and
    the other to `270`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That leaves one last thing to do. We have four center fountains. In three of
    the four city pieces, select the three meshes that make up the center fountain
    (the `Obelisk`, `Wall`, and `Water`) and hit the *Delete* key on your keyboard.
    Confirm that you want to break the prefab connection each time, and our city will
    be complete, as shown in the following figure:![Secondary Maps](img/4691OT_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out the game now. We can drive the tank around the city and rotate its turret.
    This is so much fun. We created materials and textured the city, and after making
    it possible for the player to collide with the buildings and road, we duplicated
    the section so that we could have a whole city.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all the skills needed to import meshes and create materials,
    the challenge is to decorate the city. Create some rubble and tank traps and practice
    importing them to Unity and setting them up in the scene. If you really want to
    go above and beyond, try your hand at creating your own city; choose something
    from the world, or do something using your imagination. Once it is created, we
    can release the tanks in it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving treads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is just one thing left to do, and then we will be done with materials
    and can go on to make the game even more fun. Remember the **Offset** value of
    the materials? It turns out that we can actually control it with a script. Perform
    these steps to make the treads move with our tank:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the `ChassisControls` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add a few variables at the beginning of the script. The first
    two will hold references to our tank tread renderers, the part of the mesh object
    that keeps track of the material that is applied to the mesh and actually does
    the drawing. This is similar to how the `characterControl` variable holds a reference
    to our `CharacterController` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next two variables will keep track of the amount of offset applied to each
    tread. We store it here because this is a faster reference than trying to look
    it up from the tread's material for each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make use of the new values, the following lines of code need to be added
    at the end of the `MoveTank` function. The first line here adjusts the offset
    for the right tread as per our speed, and keeps in time with our frame rate. The
    second line utilizes the material value of a `Renderer` component to find our
    tank''s tread material. The `mainTextureOffset` value of the material is the offset
    of the primary texture in the material. In the case of our diffuse materials,
    this is the only texture. Then, we have to set the offset to a new `Vector2` value
    that will contain our new offset value. `Vector2` is just like `Vector3`, which
    we used for moving around, but it works in 2D space instead of 3D space. A texture
    is flat; therefore, it is a 2D space. The last two lines of the code do the same
    thing as the other two, but for the tank''s left tread instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the connections to the `Renderer` components of our treads, do the
    same thing that we did for the pivot points: drag the tread meshes from the **Hierarchy**
    window to the corresponding value in the **Inspector** window. Once this is done,
    be sure to save it and try it out.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We updated our `ChassisControls` script to make the tank's treads move. As the
    tank is driven around, the textures pan in the appropriate direction. This is
    the same type of functionality that is used to make waves in water and other textures
    that move.
  prefs: []
  type: TYPE_NORMAL
- en: The movement of the material doesn't quite match the speed of the tank. Figure
    out how to add an extra speed value for the tank's treads. In addition, it would
    be cool if they moved in opposite directions when the tank is rotating. Real tanks
    turn by making one tread go forward and the other back.
  prefs: []
  type: TYPE_NORMAL
- en: Animations in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic that we will be covering is animation. As we explore animations
    in Unity, we will create some targets for our tank to shoot at. Much of the power
    of Unity's animation system, **Mecanim**, lies in working with humanoid characters.
    But, setting up and animating human type characters could fill an entire book
    in itself, so it will not be covered here. However, there is still much that we
    can learn and do with Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bullet points will explain all of the settings that are available
    for importing animations:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue with the explanation of the animation import settings, we
    need an animated model to work with. We have one last set of assets to import
    to our project. Import the `Target.blend` and `Target.png` files into the `Targets`
    folder of our project. Once they are imported, adjust the **Import Settings**
    window on the **Model** page for the target, just as we did for the tank. Now,
    switch to the **Rig** tab (as shown in the following screenshot):![Animations
    in Unity](img/4691OT_03_11.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Animation Type** attribute tells Unity what type of skeleton the current
    model is going to use when animation is going to be done. Models with different
    types are unable to share animations. The different options under **Animation
    Type** are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Humanoid** option adds many more buttons and switches to the page for
    working with human type characters. But again, this is too complex to cover here.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Generic** rig still uses Mecanim and many of its features. In reality, this
    is just any animation skeleton that does not resemble a human in structure.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option, **Legacy**, utilizes Unity's old animation system. However,
    this system will be phased out over the next few versions of Unity, so this will
    not be covered here either.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **None**, indicates that the object will not animate. You could
    select this option for both the tank and the city because it also keeps Unity
    from adding the Animator component, and saves space in the final project's size.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Root Node** value is a list of every object that is in the model file.
    Its purpose is to select the base object of your animation rig. For this target,
    select **Bone_Arm_Upper**, which is underneath the second **Armature** option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optimize Game Object** option will hide the whole skeleton of your model
    when it is checked. Hitting the plus sign on the new box that appears will allow
    you to select specific bones, which you still want access to when you view the
    model in the **Hierarchy** window. This is an especially useful option when dealing
    with any complex rig that has a great many bones.![Animations in Unity](img/4691OT_03_12.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last tab of the import settings, **Animations**, contains everything that
    we need to get the animations from our files into Unity. At the top of the **Target
    Import Settings** window, we have the **Import Animation** checkbox. If an object
    is not going to animate, it is a good idea to turn this option off. Doing so will
    also save space in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option below that, **Bake Animations**, is only used when your animations
    contain kinematics and are from 3ds Max or Maya. This target is from Blender,
    so the option is grayed out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next four options, **Anim. Compression**, **Rotation Error**, **Position
    Error**, and **Scale Error**, are primarily used for smoothing jittery animations.
    Nearly all the time, the defaults will be just fine for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Clips** section is what we are really concerned about here. This will
    be a list of every animation clip that is currently being imported from the model.
    On the left-hand side of the list, we have the name of the clip. On the right-hand
    side, we can see the start and end frames of the clip. The various parameters
    under the **Clips** section are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity will add a default animation to every new model. This is a clip generated
    from the default preview range of your modeling program when the file was saved.
    In the case of our target, this is **Default Take**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Blender, it is also possible to create a series of actions for each rig.
    By default, they are imported by Unity as animation clips. In this case, the **ArmatureAction**
    clip is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below and to the right-hand side of the clips, there is a little tab with the
    **+** and **–** buttons. These two buttons add a clip to the end and remove the
    selected clip respectively.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Animations in Unity](img/4691OT_03_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When a clip is selected, the next section appears. It starts with a text field
    for changing the name of the clip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the text field, when working with Blender, there is a **Source Take**
    drop-down list. This list is the same as the default animations. Most of the time,
    you will just use **Default Take**; but, if your animation is for ever appearing
    wrong or is missing, try changing the **Source Take** drop-down list first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a small timeline, followed by input fields for the **Start** and
    **End** frames of the animation clip. Clicking on the two blue flags and dragging
    them in the timeline will change the numbers in the input fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have **Loop Time**, **Loop Pose**, and **Cycle Offset**. If we want
    our animation to repeat, check the box next to **Loop Time**. **Loop Pose** will
    cause the positions of the bones in the first and last frames of the animation
    to match. When an animation is looping, **Cycle Offset** will become available.
    This value lets us adjust the frame on which the looping animation starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next three small sections, **Root Transform Rotation**, **Root Transform
    Position (Y)**, and **Root Transform Position (XZ)**, allow us to control the
    movement of a character through the animation. The controls under these sections
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these sections have a **Bake into Pose** option. If these are
    left unchecked, the movement of the root node (we selected it under the **Rig**
    page) within the animation is translated into movement of the whole object. Think
    of it like this: say you were to animate a character running to the right inside
    the animation program, you will actually move them rather than animating in place
    as normal.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With Unity's old animation system, for the physical part of a character to move
    the collider, the GameObject had to be moved with the code. So, if you were to
    use the animation, the character would appear as if it had moved, but it would
    have no collision. With this new system, the whole character will move when the
    animation is played. However, this requires a different and more complex setup
    to work completely. So, we did not use this on the tank, though we could have
    used it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the three sections also has a **Based Upon** drop-down option. The choice
    of this option dictates the object's center for each of the sections. There are
    more choices if you are working with humanoid characters, but for now we only
    have two. A choice of **Root Node** means the pivot point of the root node object
    is the center. A choice of **Original** means that the origin, as defined by the
    animation program, is the center of the object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an **Offset** option for the first two of these sections that
    works to correct errors in the motion. When animating a walk cycle for a character,
    if the character is pulling to the side slightly, adjusting the **Offset** option
    under **Root Transform Rotation** will correct it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next option for our animation clip is a **Mask**. By clicking on the arrow
    to the left, you can expand a list of all objects in the model. Each object has
    a checkbox next to it. The objects that are not checked will not be animated when
    this clip is played. This is useful in the case of a hand-waving animation. Such
    an animation would only need to move the arm and hand, so we would uncheck all
    of the objects that might make up the body of the character. We could then layer
    animations, making our character capable of waving while standing, walking, or
    running without the need to create three extra animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Curves** option will give you the ability to add a float value to the
    animation, which will change over the course of the animation. This value can
    then be checked by your code while the animation plays. This could be used to
    adjust the gravity affecting your character while they jump, change the size of
    their collider as they crouch into a ball, or do a great many other things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events work similar to how we used the `SendMessage` function in our `RepeatButton`
    script. At a specific point in your animation, a function can be called to perform
    some action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Motion** option lets you define which bone in your animation controls
    the model motion. This can override the one chosen on the **Rig** tab. Our target
    does not move, so it is not particularly relevant to our situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have our **Revert** button, **Apply** button, and the **Preview**
    window at the bottom. Just as with all of our other import settings, we have to
    hit one of these buttons when changes are made. This **Preview** window is made
    special by the speed slider in the top-right corner and the big play button in
    the top-left corner. By clicking on this button, we can preview the selected animation.
    This lets us detect the errors in motion that we discussed earlier, and it generally
    makes sure that the animation is what we want it to be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of settings that are available to us when we are working with
    animations in Unity. They let us control the frames from the original animation
    program that we want to import. In addition, they can be used to control how the
    animation interacts with your scripts. No matter what settings you choose, the
    most important thing is the animation clip's name. If this is not set, it can
    be extremely difficult to work with several animations that have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The target's animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, now that the description is all out of the way, let''s actually make something
    with it. We will start by setting up the animations for the target. Using the
    knowledge that we just gained, we can now set up our target''s animations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For starters, if you missed or skipped it earlier, be sure to import the `Target.blend`
    and `Target.png` files to the `Targets` folder. In addition, on the **Rig** page
    of the import settings, ensure that the **Animation Type** attribute is set to
    **Generic** and the **Root Node** attribute is set to **Bone_Arm_Upper**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a total of six animations. By clicking on the **+** button in the **Clips**
    section, you can add four more animations. If you have added too many, click on
    the **-** button to remove the extra clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these clips should have a **Source Take** drop-down list of **Default
    Take** and all of the **Bake into Pose** options should be checked because the
    target will not move from its starting location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's create our idle animations. Select the first clip and rename it
    as `Idle_Retract`. As this is a mechanical object, we can get away with a really
    short animation; it is so short that we are just going to use the first frame.
    Set the starting frame to `0.9` and the ending frame to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to turn on **Loop Pose** because idle animations are, of course,
    looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The extended idle animation is created in almost exactly the same manner. Select
    the second clip and rename it as `Idle_Extend`. The starting frame here is `14`
    and the ending frame is `14.1`. In addition, this animation needs to loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next two animations are for a situation when the target extends and retracts.
    They will be called `Extend` and `Retract`, so rename the next two clips. The
    `Extend` animation will start at frame `1` and end at frame `13`. The `Retract`
    animation will start at frame `28` and ends at frame `40`. Neither of these will
    loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last two animations also will not loop. They are for when we shoot the targets.
    There is one for being shot in the front and one for being shot from behind. The
    `Hit_Front` animation will be from frame `57` to frame `87`. The `Hit_Back` animation
    will be from frame `98` to frame `128`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all of the changes are made, make sure to click on **Apply** or they will
    not be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set up the animations that will be used by our targets. There are
    six in total. They may not seem like much now, but the next section would not
    be possible without them.
  prefs: []
  type: TYPE_NORMAL
- en: State machines to control animations in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to control these new animations in Unity, we need to set up
    a state machine. A state machine is just a fancy object that keeps track of what
    an object can do, and how to transition between things. You can think of it in
    terms of a builder from a real-time strategy game. The builder has a walk state
    that is used when moving to the next construction site. When the builder gets
    there, it switches to a build state. If an enemy shows up, the builder will enter
    a runaway state until the enemy is gone. Finally, there is an idle state for when
    the builder does nothing. In Unity, these are called Animator controllers when
    you work with animations and Mecanim.
  prefs: []
  type: TYPE_NORMAL
- en: Target state machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of a state machine allows us to focus more on what the target is doing,
    while letting Unity handle the *how it is going to do it* part. Perform these
    steps to create the state machine and control the target:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an **Animator** controller is simple and this is done just as we have
    been doing for our scripts and materials. The option is approximately in the middle
    of the **Create** menu. Create an Animator controller in the `Targets` folder
    and name it `TargetController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `TargetController` to open a new window (as shown in the following
    screenshot):![Target state machine](img/4691OT_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Animator** window is where we edit our state machines. The various parts
    of the **Animator** window are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the top-left side is a **Layers** button. Clicking on it will display a list
    of all of the blendable layers that make up your animation system. Every state
    machine will have at least the **Base Layer**. Adding more layers would allow
    us to blend state machines. Let's say we have a character that walks around normally
    when he is at full health. When his health drops below half, he starts to limp.
    If the character has only ten percent of his health left, he starts to crawl.
    This would be achieved through the use of layers to prevent the need of creating
    extra animations for each type of movement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To the right of that is a **Parameters** button that will display the list of
    parameters. Clicking on the **+** button will add a new parameter to the list.
    These parameters can be **Float**, **Int**, **Bool**, and **Trigger**. The transitions
    between the states are most often triggered by changes in these parameters. Any
    scripts working with the state machine can modify these values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next bit is a breadcrumb trail, like one that you might find on a website.
    It lets us see where we are in the state machine at a glance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Auto Live Link** button at the top-right corner controls our ability to
    see the state machine's update in real time within the game. This is useful for
    debugging transitions and controls for the character.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the center of the **Animator** window, there are three boxes: **Any State**,
    **Entry**, and **Exit**. (If you can''t see them, click on the middle mouse button
    and drag on the grid to pan the view around.) These boxes are the base controls
    for your animation state machine. The **Any State** box will allow your object
    to transition into specific animations, no matter where in the state machine they
    may be, such as moving to a death animation irrespective of the action the player
    was performing. The **Entry** box is used when you first start your state machine.
    All of the transitions are analyzed and the first suitable and subsequent animation
    becomes the starting location. The **Exit** box is used primarily for substate
    machines and allows you to transition out of the group without a lot of extra
    convoluted connections.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a new state, right-click on the grid that is inside our **Animator**
    window. Hover your mouse over **Create State** and select **Empty**. This creates
    a new empty state for our state machine. Normally, new states are gray, but since
    this is the first state in our machine, it is orange, which is the color of the
    default state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every state machine will start in its default state. Click on the state to select
    it, and we can take a look at it in the **Inspector** window (as shown in the
    following screenshot).![Target state machine](img/4691OT_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the following fields in the preceding screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top, there is a text field for changing the name of the state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, you can add a **Tag** for organizational purposes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, there is a **Speed** field. This field controls the playback speed of
    the animation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Motion** field is where we will add connections to the animation clips
    that we created earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Foot IK** option lets us decide whether we want to let a part of the animation
    to be calculated with **Inverse Kinematics** (**IK**), which is the process of
    calculating how a chain of bones will be laid out based on the position of the
    target bone at the end. We did not set up any IK for these animations, so we do
    not need to worry about this option.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With the **Write Defaults** option, we can control whether animated properties
    remain changed after the animation ends.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **Mirror**, is used to flip the left and right axis (or *x*
    axis) of the animation. If you created a right-hand-waving animation, this option
    would let you change it to a left-hand-waving animation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, there is the list of transitions that go from the current state
    to another state. These are transitions that are out of the state and not into
    it. As you will soon see, a transition in this list appears as the name of the
    current state with an arrow to the right, followed by the name of the state it
    is connected to.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkboxes also appear under the **Solo** and **Mute** labels on the right.
    These are for debugging transitions between the states. Any number of transitions
    can be muted at one time, but only one can be soloed at a time. When a transition
    has been muted, it means that the state machine will ignore it when deciding which
    transition to make. Checking the **Solo** box is the same as muting all but one
    of the transitions; this is just a quick way to make it the only active transition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to need one state for each of our target's animations. So, create
    five more states and rename all six to match the names of the animation clips
    that we created earlier. The default state, the first one you created that will
    appear orange on your screen, should be named `Idle_Retract`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** window, click on the little triangle on the right side of
    the **Target** model (as highlighted in the following screenshot):![Target state
    machine](img/4691OT_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This expands the model so that we can see all of the objects that make up that
    model in Unity. The first group consists of the actual objects that make up the
    model. Next are the raw meshes that are used in the model. These are followed
    by the animation clips (they will appear on your screen as a blue box with a big
    play button at the center); these are what we are interested in right now. Last
    is an avatar object; this is what keeps track of the **Rig** setup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select each state in your **Animator** window and pair it with the correct clip
    by dragging an animation clip from the **Project** window, and dropping it onto
    the **Motion** field in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can create our transitions, we need a few parameters. Open the parameters
    list by clicking on the **Parameters** button in the top-left corner. Then, click
    on the **+** button and select **Float** from the menu that appears. A new parameter
    should now appear in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new field on the left-hand side is the name of the parameter; it can be
    renamed at any time by double-clicking on it. Rename this one to `time`. The field
    on the right is the current value of this parameter. When debugging our state
    machine, we can modify these values here to trigger changes in the state machine.
    Any changes made by the scripts while the game is running will also appear here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need two more parameters. Create two **Bool** parameters and rename them
    as `wasHit` and `inTheFront`. These will trigger the machine to change to the
    getting hit states, while the time parameter will trigger the machine to utilize
    the `extend` and `retract` states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a new transition, right-click on a state and select **Make Transition**
    from the menu that pops up. A transition line is now connected from the state
    to your mouse. To complete the transition creation, click on the state that you
    wish to connect to. There will be an arrow on the line, indicating the direction
    of the transition. We need the following transitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a transition from `Idle_Retract` to `Extend`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need a transition from `Extend` to `Idle_Extend`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Idle_Extend` needs three transitions, one going to `Retract`, the other to
    `Hit_Front`, and the last to `Hit_Back`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Retract`, `Hit_Front`, and `Hit_Back` animations need a transition that
    goes to `Idle_Retract`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the following screenshot as a reference. If you create a transition or state
    that you do not want, select it and hit the *Delete* key on your keyboard to remove
    it.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Target state machine](img/4691OT_03_17.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: If you click on one of the transition lines, then we can take a look at its
    settings (as shown in the following screenshot):![Target state machine](img/4691OT_03_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the following things in the screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the **Inspector** window, we have the same indicators of which
    states we are transitioning between that we had in the state—the name of the state
    the transition starts in, followed by an arrow, and finally the name of the state
    the transition ends in.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the familiar **Transitions** list, there is a text field where we
    can give our transitions specific names. This is useful if we have several different
    types of transitions between the same two states.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Has Exit Time** checkbox dictates whether the transition will wait until
    the animation is close to its end before changing to the next animation. This
    is good for things like smoothly transitioning between walk and idle animations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first value in **Exit Time** under **Settings** sets when the transition
    would start. This is only relevant when the checkbox above it is checked. It should
    have a value from zero to start the animation, and to one to end the animation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition Duration** setting defines how long the transition will take.
    It again takes a value between zero and one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition Offset** setting defines where in the target animation the
    transition will begin.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Interruption Source** and **Ordered Interruption** options determine whether
    another transition can occur while it is in the process of going through this
    one. They also set which set of transitions will have precedence and in which
    order they will be processed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a timeline block that lets us preview the transition between animations.
    By dragging the little flag left and right, we can watch the transition in the
    **Preview** window. The top half of this block holds waveforms that indicate the
    movement contained in an animation. The bottom half shows the states as boxes
    that overlap where the transition actually occurs. Either one of these boxes can
    be dragged to change the length of the transition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Since our two idle animations are of negligible length, this normally can't
    easily be seen in our setup. If you create a temporary transition between the
    `extend` and `retract` states, it would be visible.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, we have a **Conditions** list. Using the parameters that we set up,
    we can create any number of conditions here that must be met before this transition
    can take place.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another **Preview** window at the bottom of the **Inspector** panel.
    It functions just like the one for the **Animation Import Settings** page, but
    this one plays the transition between the two relevant animations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the transition between the `Idle_Retract` state and the `Extend` state.
    We want the targets to randomly pop up. This will be controlled by a script that
    will change the time parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** under the **Conditions** list to add a new condition. Then,
    click on the arrow in the middle of the condition to select **time** from the
    list of parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to turn a **Float** value into a conditional statement, we need to
    compare it with another value. That is why we got a new drop-down button with
    comparison options when we selected the parameter. A **Float** value will be either
    greater than or less than the value on the right. Our time will be counting down,
    so select **Less** from the list and leave the value as zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a condition so that the transition between the `Idle_Extend` and `Retract`
    states will be the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the transition between the `Idle_Extend` state and the `Hit_Front` state,
    we will use both the **Bool** parameters that were created. Select the transition
    and click on the **+** button under **Conditions** until you have two conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first condition, select **wasHit**, and select **inTheFront** for the
    second condition. A **Bool** parameter is either `true` or `false`. In the case
    of transitions, it needs to know which of the values it is waiting for. For this
    transition, both should be left as **true**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set up the conditions for the transition between `Idle_Extend` and `Hit_Back`,
    just as you did for the previous transition. The only difference is that `false`
    needs to be selected from the drop-down list next to the **inTheFront** conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created a state machine that will be used by our targets. By linking
    each state to an animation and connecting all of them with transitions, the target
    will be able to switch between animations. This transitioning is controlled by
    adding conditionals and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We only need one more piece before we can finish putting the target together—a
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in our `Scripts` folder and name it `Target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, in order to interact with our state machine, we need a reference to
    the `Animator` component. It is the component that you removed from the tank and
    the city. The `Animator` component is what ties all of the pieces of the animation
    together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is followed by two float values that will dictate the range of time, in
    seconds, during which our targets will sit in their idle states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we have three values that will hold the ID numbers of the parameters
    that we need to change. It is technically possible to just use the names of the
    parameters to set them, but using the ID number is much faster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last two variables will hold the ID numbers of the two idle states. We
    need these for checking which state we are in. All of the IDs are initially set
    to `-1` as a dummy value; we set them to their actual values with the function
    in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Awake` function is a special function in Unity that is called on every
    script at the beginning of the game. Its purpose is initialization before the
    game gets underway, and it is perfect for initially setting our ID values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For each ID, we make a call to the `Animator.StringToHash` function. This function
    calculates the ID number of the parameter or state whose name we give it. The
    state names also needs to be prefixed with `Base Layer`. This is because Unity
    wants us to be specific when it is possible to have several different layers with
    states that are named the same. It is also very important that the name here exactly
    matches the name in the **Animator** window. If it does not, IDs will not match,
    errors will occur, and the script will not function correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make use of all of these IDs, we turn to our very good friend—the `Update`
    function. At the beginning of the function, we use the `GetCurrentAnimatorStateInfo`
    function to figure out which state is the current one. We send a zero to this
    function because it wants to know the index of the layer we are inquiring about,
    of which we only have one. The function returns an object with the information
    about the current state, and we grab the `nameHash` value (also known as the ID
    value) of this state right away and set our variable to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next line of code is a comparison with our idle state IDs to figure out
    whether we are in one of those states. If we are, we call upon the `SubtractTime`
    function (which we will write in a moment) to reduce the time parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the target is not currently in one of its idle states, we start by checking
    to see whether we were hit. If so, the hit is cleared using the `ClearHit` function
    and the time parameter is reset using the `ResetTime` function. We will write
    both these functions in a moment. Finally, we check to see whether our timer has
    dropped below zero. If it has, we again reset the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `SubtractTime` function, we use the `GetFloat` function of our `Animator`
    component to retrieve the value of a float parameter. By sending our `timeId`
    variable to it, we can receive the current value of the time parameter. Like we
    did with the tank, we then use `Time.deltaTime` to keep pace with our frame rate
    and subtract time from the timer. Once this is done, we need to give the state
    machine the new value, which is done with the `SetFloat` function. We tell it
    which parameter to change by giving it an ID value, and we tell it what to change
    by giving it our new time value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next function to create is `ClearHit`. This function uses `SetBool` from
    the `Animator` component to set Boolean parameters. It functions just like the
    `SetFloat` function. We just give it an ID and a value. In this case, we set both
    of our Boolean parameters to `false` so that the state machine no longer thinks
    that it has been hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last function for the script is `ResetTime`. This is another quick function.
    First, we use the `Random.Range` function to get a random value. By passing it
    a minimum and maximum value, our new random number will be between them. Finally,
    we use the `SetFloat` function to give the state machine the new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created a script to control the state machine of our target. For comparing
    states and setting parameters, we gathered and used IDs. For now, do not worry
    about when the hit states are activated. It will be made clear in the following
    section when we finally make the tank shoot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the model, animations, state machine, and script, it is time
    to create the target and turn it into a prefab. We have all the pieces, so let''s
    put them all together:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by dragging the **Target** model from the **Project** window to the **Hierarchy**
    window. This creates a new instance of the target object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By selecting the new target object, we can see that it already has an **Animator**
    component attached to it; we just need to add a reference to the `AnimatorController`
    that we created. Do this by dragging `TargetController` from the **Project** window
    and dropping it onto the Animator component's **Controller** field, just like
    all the other object references that we have set up so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, we need to add the `Target` script to the object and connect a reference
    to the **Animator** component in its relevant field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do to the target object is to add a collider to actually receive
    our cannon shots. Unfortunately, since the `Target` object uses bones and a rig
    to animate, it is not as simple as adding a collider directly to the mesh at which
    we will be shooting. Instead, we need to create a new empty `GameObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this to `TargetCollider` and make it a child of the target's `Bone_Target`
    bone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `MeshCollider` component to the new GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to provide this component with some mesh data. Find the **Target**
    mesh data in the **Project** window, underneath the **Target** model. Drag it
    to the **Mesh** value of the `MeshCollider` component. This causes a green cylinder
    to appear in the **Scene** view. This is our collision, but it is not yet aligned
    to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Transform** component to set the **GameObject** position to `4` for
    the **X** value and `0` for both **Y** and **Z**. The rotation needs to be changed
    to `0` for **X**, `-90` for **Y**, and `90` for **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we made the changes, you probably noticed that the font of everything that
    was new or changed became bold. This is to indicate that something is different
    with this prefab instance as compared to the original. Remember, models are essentially
    prefabs; the problem with them is that we cannot directly make changes, such as
    adding scripts. To make this target into a new prefab, simply drag it from the
    **Hierarchy** window and drop it onto the `Prefabs` folder in the **Project**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this spiffy new prefab is created, populate the city with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you placed all of these targets, you probably noticed that they are a little
    large. Instead of editing each target individually or even all of them as a group,
    we only have to make a change to the original prefab. Select the `Target` prefab
    in the **Project** window. The **Inspector** window displays the same information
    for a root prefab object as it does for any other object in the scene. With our
    prefab selected, half the scale and all of the instances already in the scene
    will automatically be updated to match. We can also make changes to the min and
    max idle times and make it affect the whole scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just finished creating the targets for our tank. By making use of Unity's
    prefab system, we can also duplicate the target throughout our game and easily
    make changes that affect them all.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted one of the targets to be larger than all of the others, you could
    change it in the scene. Any changes made to a prefab instance are saved, and they
    take precedence over changes made to the root prefab object. In addition, when
    you look at an instance in the **Inspector** window, there will be three new buttons
    at the top of the window. The **Select** button selects the root prefab object
    in the **Project** window. The **Revert** button will remove any unique changes
    made to this instance, whereas the **Apply** button updates the root object with
    all the changes that were made in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using all that you have learned about animations and state machines, your challenge
    here is to create a second type of target. Play around with different movements
    and behaviors. You can perhaps create one that transitions from waving around
    to standing still.
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing to shooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play the game now; it is pretty cool. We have our drivable tank and textured
    city. We even have fancy animated targets. We are just missing one thing: how
    do we shoot? We need to make one more script and we can shoot targets to our heart''s
    content. Follow these steps to create the script and set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add an empty `GameObject` to our tank. Rename it to `MuzzlePoint`
    and make it a child of the cannon's pivot point object. Once this is done, position
    it at the end of the cannon so that the blue arrow points away from the tank,
    along the same direction as the cannon. This will be the point where our bullets
    will come from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need something to indicate where we are shooting. The explosions are
    covered in future chapters, so choose **Sphere** from the **3D Object** menu underneath
    **GameObject** and rename it to `TargetPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the sphere's scale to `0.2` for each axis and give it a red material. This
    way, it can be more easily seen without being completely obtrusive. It does not
    matter where it starts in our scene, our next script will move it around when
    we shoot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `SphereCollider` component from `TargetPoint`. The `SphereCollider`
    has to be removed because we don't want to shoot our own target indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a new script and call it `FireControls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should start to look familiar to you. We start with variables to hold references
    to our muzzle and targeting objects that we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Fire` function starts by defining a variable that will hold the detailed
    information about what was shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is followed by an `if` statement that checks the `Physics.Raycast` function.
    The `Raycast` function works just like shooting a gun. We start with a position
    (the muzzle point's position) pointing to a specific direction (forward relative
    to the muzzle point along that blue axis) and get out what was hit. If we hit
    something, the `if` statement evaluates to `true`; otherwise, it is `false` and
    we would skip ahead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we do hit something, we first move our target point to the point that was
    hit. We then use the `SendMessage` function to tell what we hit that it has been
    hit, the same way we used it in our `RepeatButton` script earlier. We use `hit.transform.root.gameObject`
    to get at the GameObject that was hit. We also provide it with a value, `hit.point`,
    to tell the object where it was hit. The `SendMessageOptions.DontRequireReceiver`
    part of the line keeps the function from throwing an error if it is unable to
    find the desired function. Our targets have the function, but the city walls do
    not and they would throw an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last part of our `Fire` function occurs if we didn''t hit anything. We
    send our target point back to the world origin so that the player knows that they
    missed everything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing to add is the `Hit` function at the end of our `Target` script.
    We start the function by getting the current state ID, just as we did earlier
    in the script. However, this time we only check against our extended idle ID.
    If they do not match, we use `return` to exit the function early. We do this because
    we don''t want to let the player shoot any targets that are down or in mid-transition.
    If our state is correct, we continue by telling the animation that we were hit
    by using the `SetBool` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the `Hit` function figures out on which side the target was hit.
    To do this, we first have to convert the point that we received from world space
    into local space. The `InverseTransformPoint` function from our **Transform**
    component does this nicely. We then do a check to see where the shot came from.
    Due to the way that the target is constructed, if the shot was positive on the
    *x* axis, it came from behind. Otherwise, it came from the front. Either way,
    we set the `inTheFront` parameter from our state machine to the proper value.
    Then, we give the player some points by incrementing the static variable that
    we created in our `ScoreCounter` script, way back at the beginning of the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add the new `FireControls` script to the tank. You also need
    to connect the references to the `MuzzlePoint` and `TargetPoint` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to create a new button to control and trigger this script.
    So, navigate to **GameObject** | **UI** | **Button** and rename the button to
    `Fire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to hit the little plus sign in the bottom right of the button's
    **Inspector** window and select `Tank` for the **Object** slot, exactly like we
    did for our Tic-tac-toe game. Then, navigate to **FireControls** | **Fire ()**
    from the function drop down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created a script that allows us to fire the cannon of our tank. The
    method of using ray tracing is the simplest and most widely used. In general,
    bullets fly too fast for us to see them. Ray tracing is like this, that is, it
    is instantaneous. However, this method does not take gravity, or anything else
    that might change the direction of a bullet, into account.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all of the buttons and components are in place, make them look better.
    Use the skills you gained from the previous chapter to style the GUI and make
    it look great. Perhaps you could even manage to create a directional pad for the
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And, that is it! The chapter was long and we learned a lot. We imported meshes
    and set up a tank. We created materials so that color could be added to a city.
    We also animated some targets and learned how to shoot them down. It was a lot
    and it is time for a break. Play the game, shoot some targets, and gather those
    points. The project is all done and ready to be built in your device of choice.
    The build process is the same as both the previous projects, so have fun!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about special camera effects and lighting. We will learn
    about lights and their types. Our Tank Battle game will expand through the addition
    of a skybox and several lights. We will also take a look at distance fog. With
    the addition of shadows and lightmaps, the city in which we battle really starts
    to become interesting and dynamic.
  prefs: []
  type: TYPE_NORMAL
