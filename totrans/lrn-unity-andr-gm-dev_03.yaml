- en: Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 任何游戏的核心——网格、材质和动画
- en: In the previous chapter, we learned about the GUI. We started by creating a
    simple Tic-tac-toe game to learn about the basic pieces of the game. We followed
    this by changing the look of the game and making the board handle multiple screen
    orientations. We completed with a few menus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了GUI。我们从创建一个简单的井字游戏开始，学习游戏的基本组成部分。然后通过改变游戏的外观并使游戏板支持多种屏幕方向来继续。最后，我们完成了一些菜单的制作。
- en: 'This chapter is about the core of any game: meshes, materials, and animations.
    Without these blocks, there is generally nothing to show to players. You could,
    of course, just use flat images in the GUI. But, where is the fun in that? If
    you are going to choose a 3D game engine, you might as well make full use of its
    capabilities.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍任何游戏的核心：网格、材质和动画。没有这些基础，通常没有东西可以展示给玩家。当然，你也可以只使用GUI中的平面图像。但这样有什么乐趣呢？既然你选择了3D游戏引擎，不妨充分利用它的功能。
- en: To understand meshes, materials, and animations, we will be creating a tank
    battle game. This project will be used in a few other chapters. By the end of
    the book, it will be one of the two robust games that we will have created. For
    this chapter, the player will get to drive a tank around a small city, they will
    be able to shoot at animated targets, and we will also add a counter to track
    the scores.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解网格、材质和动画，我们将创建一个坦克大战游戏。这个项目将在其他章节中使用。到本书结束时，这将是我们创建的两个完整游戏之一。在本章中，玩家将驾驶坦克在一个小城市中四处移动，他们能够射击动画目标，我们还将添加一个计数器来跟踪分数。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Importing meshes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入网格
- en: Creating the materials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建材质
- en: Animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Creating the prefabs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制体
- en: Ray tracing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线追踪
- en: We will be starting a new project in this chapter, so follow the first section
    to get it started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一个新项目，请按照第一部分来启动。
- en: Setting up
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置准备
- en: Though this project will eventually grow to become much larger than the previous
    ones, the actual setup is similar to the previous projects and is not overly complex.
    You will need a number of starting assets for this project; they will be described
    during the setup process. Due to the complexity and specific nature of these assets,
    it is recommended to use the ones provided with the code bundle of this book for
    now.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个项目最终会比之前的更大，但实际设置与前一个项目类似，并不复杂。这个项目你需要一些起始资源，这些将在设置过程中进行描述。由于这些资源的复杂性和特定性，建议现在使用本书代码包中提供的资源。
- en: 'As we did in the previous two chapters, we will need to create a new project
    so that we can create our next game. Obviously, the first thing to do is to start
    a new Unity project. For organizational purposes, name it `Ch3_TankBattle`. The
    following points are the prerequisites that are required for this project to kick-start:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两章一样，我们需要创建一个新项目，以便开发下一款游戏。显然，首先要做的就是启动一个新的Unity项目。为了便于组织，将其命名为`Ch3_TankBattle`。以下是启动本项目所需的前提条件：
- en: This project will also grow to become much larger than our previous projects,
    so we should create some folders to keep things organized. For starters, create
    six folders. The top-level folders will be the `Models`, `Scripts`, and `Prefabs`
    folders. Inside `Models`, create `Environment`, `Tanks`, and `Targets`. Having
    these folders makes the project significantly more manageable. Any complete model
    can consist of a mesh file, one or more textures, a material for every texture,
    and potentially dozens of animation files.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目也会比我们之前的项目变得更大，因此我们应该创建一些文件夹来保持组织性。首先，创建六个文件夹。顶级文件夹将是`Models`、`Scripts`和`Prefabs`文件夹。在`Models`内创建`Environment`、`Tanks`和`Targets`。拥有这些文件夹使得项目管理起来更加容易。任何完整的模型可以包含一个网格文件，一个或多个纹理，每个纹理对应一个材质，以及可能包含数十个动画文件。
- en: Before we continue, it is a good idea to change your target platform to Android,
    if you haven't already done so. Every time the target platform is changed, all
    of the assets in the project need to be reimported. This is an automatic step
    carried out by Unity, but it will take an increasing amount of time as our project
    grows. By setting our target platform before there is anything in the project,
    we save lots of time later.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，如果你还没有这样做，最好是将你的目标平台改为Android。每次更改目标平台，项目中的所有资源都需要重新导入。这是Unity自动执行的一步，但随着项目的增长，这将花费越来越多的时间。在项目中有任何内容之前设置目标平台，我们可以节省很多时间。
- en: 'We will also make use of a very powerful part of Unity: prefabs. These are
    special objects that make the process of creating a game significantly easier.
    The name means prefabricated—created beforehand and replicated. What this means
    for us is that we can completely set up a target for our tank to shoot at and
    turn it into a prefab. Then, we can place instances of the prefab throughout the
    game world. If we ever need to make a change to the targets, all we need to do
    is modify the original prefab. Any change made to a prefab is also made on any
    instance of that prefab. Don''t worry; it makes more sense when it is used.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将利用Unity一个非常强大的部分：预制体。这些特殊对象使创建游戏的过程大大简化。这个名字意味着预先制造的——事先创建并复制的。对我们来说，这意味着我们可以完全设置一个坦克射击的目标，并将其转换成预制体。然后，我们可以在游戏世界中放置预制体的实例。如果我们需要更改目标，只需修改原始预制体即可。对预制体所做的任何更改也会应用于该预制体的任何实例。别担心，使用时它会更有意义。
- en: We will need to create some meshes and textures for this project. To start with,
    we will need a tank (it is kind of hard to have a battle of tanks without any
    tanks). The tank that is provided with this code bundle has a turret and cannon,
    which are separate pieces. We will also use a trick to make the tank's treads
    look like they are moving, so each of them are a separate piece and uses a separate
    texture.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这个项目创建一些网格和纹理。首先，我们需要一辆坦克（如果没有坦克，进行坦克大战是有点困难的）。这个代码包中提供的坦克有一个炮塔和一门大炮，这些都是独立的部件。我们还将使用一个技巧，让坦克的履带看起来像是在移动，所以它们每个都是独立的部件，并使用单独的纹理。
- en: Finally, we will need an animated target. The one that is provided with the
    code bundle of this book is rigged up like the human arm with a bull's eye for
    the hand. It has four animations. The first starts in a curled position and goes
    to an extended position. The second is the reverse of the first one, going from
    the extended position to the curled position. The third starts in the extended
    position and is flung back, as if it is hit in the front, and returns to the curled
    position. The last is just like the third one, but it goes forward as if it is
    hit from behind. These are fairly simple animations, but they will serve us well
    in learning about Unity's animation system.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个动画目标。本书代码包中提供的那个像人的手臂一样装有牛眼的手。它有四个动画。第一个从卷曲的位置开始，移动到伸展的位置。第二个与第一个相反，从伸展的位置回到卷曲的位置。第三个从伸展的位置开始，向后弹起，就像从前面被打到，然后回到卷曲的位置。最后一个与第三个类似，但是它是向前移动，就像是从后面被打到一样。这些动画相当简单，但它们将帮助我们很好地了解Unity的动画系统。
- en: Very little happened here; we simply created the project and added some folders.
    There was also a little discussion about the assets that we would be using for
    this chapter's project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情很少；我们只是创建了一个项目并添加了一些文件夹。我们还简要讨论了将为本章项目使用哪些资源。
- en: Importing the meshes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入网格
- en: 'There are several ways to import assets to Unity. We will be going through
    perhaps the simplest (and certainly the best) ways to import groups of assets.
    Let''s get started:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将资源导入Unity。我们将介绍最简单（也可能是最好）的方法来导入资源组。让我们开始吧：
- en: Inside the Unity Editor, start by right-clicking on your `Tanks` folder and
    select **Show in Explorer** from the menu.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，首先在你的`Tanks`文件夹上右键点击，然后从菜单中选择**在资源管理器中显示**。
- en: This opens the folder that contains the asset that was selected. In this case,
    the `Models` folder opens in the Windows' folder browser. We just need to put
    our tank and its textures into the `Tanks` folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会打开包含所选择资源的文件夹。在本例中，`Models`文件夹在Windows文件夹浏览器中打开。我们只需将坦克及其纹理放入`Tanks`文件夹中。
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The files provided for this chapter are `Tank.blend`, `Tanks_Type01.png`, and
    `TankTread.png`. In addition, utilizing the `.blend` files in Unity requires Blender
    to be installed in your system. Blender is a free modeling program that is available
    at [http://www.blender.org](http://www.blender.org). Unity makes use of it in
    order to convert the previously mentioned files into ones that it can fully utilize.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章提供的文件有 `Tank.blend`、`Tanks_Type01.png` 和 `TankTread.png`。此外，在 Unity 中使用 `.blend`
    文件需要在你的系统中安装 Blender。Blender 是一个免费的建模程序，可在 [http://www.blender.org](http://www.blender.org)
    获取。Unity 利用它将前述文件转换成可以完全利用的文件。
- en: When we return to Unity, the fact that we added files will be detected, and
    they will automatically be imported. This is one of the best things about Unity.
    There is no need to explicitly tell Unity to import. If there are changes within
    the project's assets, it just updates the assets automatically.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们回到 Unity，它会检测到我们添加的文件，并自动导入。这是 Unity 最好的特点之一。无需明确告诉 Unity 导入。如果项目资产内部发生变化，它会自动更新资产。
- en: You may also notice that an extra folder and some files were created when Unity
    imported our tank. Whenever a new mesh is imported, by default Unity will try
    to pair it with the materials. We will go into more detail about what a material
    is in Unity in the next section. For now, it is an object that keeps track of
    how to display a texture on a mesh. Based on the information in the mesh, Unity
    looks in the project for a material with the correct name. If one cannot be found,
    a `Materials` folder is created next to the mesh and the missing materials are
    created inside it. When creating these materials, Unity also searches for the
    right textures. This is why it is important to add textures to the folder at the
    same time as the mesh, so that they can all be imported together. If you did not
    add the textures at the same time as the tank, the section about creating materials
    will describe how to add textures to materials.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还会注意到，当 Unity 导入我们的坦克时，会创建一个额外的文件夹和一些文件。每当导入新网格时，默认情况下 Unity 会尝试将其与材质配对。下一节将详细介绍
    Unity 中的材质是什么。现在，它是一个跟踪如何在网格上显示纹理的对象。根据网格中的信息，Unity 在项目中查找具有正确名称的材质。如果找不到，将在网格旁边创建一个
    `Materials` 文件夹，并在其中创建缺失的材质。创建这些材质时，Unity 也会查找正确的纹理。这就是为什么将纹理与网格同时添加到文件夹中很重要，以便它们可以一起导入。如果你没有在导入坦克的同时添加纹理，关于创建材质的部分将介绍如何将纹理添加到材质中。
- en: We have imported our tank into Unity. It is really quite simple. Changes made
    to any of the assets or folders of the project are automatically detected by Unity,
    and anything that is needed is accordingly imported.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将坦克导入 Unity。这真的很简单。对项目中的任何资产或文件夹所做的更改都会被 Unity 自动检测到，并根据需要相应地导入。
- en: Tank import settings
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坦克导入设置
- en: 'Importing any asset into Unity is done by using a default group of settings.
    Any of these settings can be changed from the **Inspector** window. With your
    new tank selected, we will go over the import settings for a model here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何资源导入 Unity 是通过使用一组默认设置完成的。这些设置都可以从**检查器**窗口进行更改。选中你的新坦克后，我们将在这里介绍模型导入设置：
- en: '![Tank import settings](img/4691OT_03_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![坦克导入设置](img/4691OT_03_01.jpg)'
- en: 'We can see in the preceding screenshot that the top of the **Inspector** window
    has three tabs: **Model**, **Rig**, and **Animations**. The **Model** page handles
    the mesh itself, while **Rig** and **Animations** are for importing animations.
    For now, we only care about the **Model** page, so select it if it is not already
    selected. Each section of the **Model** page is broken down here.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，在**检查器**窗口顶部有三个标签页：**模型**、**绑定**和**动画**。**模型**页面处理网格本身，而**绑定**和**动画**用于导入动画。目前我们只关心**模型**页面，如果尚未选择，请选择它。下面将详细介绍**模型**页面的每个部分。
- en: Meshes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: 'The **Meshes** section of the previous screenshot has the following options:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张截图中的**网格**部分有以下选项：
- en: The **Meshes** section of the **Import Settings** window starts with the **Scale
    Factor** attribute. This is a value that tells Unity how big the mesh is by default.
    One generic unit or one meter from your modeling program translates to one unit
    in Unity. This tank was made in generic units, so the tank's scale factor is one.
    If you were working in centimeters when making the tank, the scale factor would
    be 0.01 because a centimeter is a hundredth of a meter.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入设置**窗口中的**网格**部分以**缩放因子**属性开始。这是一个告诉Unity网格默认大小的值。你的建模程序中的一个通用单位或一米转换为Unity中的一个单位。这个坦克是以通用单位制作的，所以坦克的缩放因子是1。如果你在制作坦克时使用的是厘米，那么缩放因子将是0.01，因为厘米是米的一百分之一。'
- en: The **File Scale** option is the scale used in the modeling program when the
    model was originally created. It is primarily informational. If you need to adjust
    the size of the imported model, adjust the **Scale Factor**.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件缩放**选项是原始创建模型时建模程序中使用的缩放。它主要是信息性的。如果你需要调整导入模型的大小，请调整**缩放因子**。'
- en: The next option, **Mesh Compression**, will become important in the final chapter
    when we go over the optimization of our games. The higher the compression is set
    to, the smaller will be the size of the file in the game. However, this will start
    to introduce weirdness in your mesh as Unity works to make it smaller. For now,
    leave it as **Off**.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个选项，**网格压缩**，在我们讨论游戏优化时将在最后一章变得非常重要。压缩设置得越高，游戏中文件的大小就会越小。然而，这也会开始让你的网格出现一些奇怪的现象，因为Unity会尝试使其更小。现在，将其设置为**关闭**。
- en: The **Read/Write Enabled** option is useful if you want to make changes to the
    mesh while the game is playing. This allows you to do some really cool things,
    such as destructible environments, where your scripts break the meshes into pieces
    based on where they are being shot. However, it also means that Unity has to keep
    a copy of the mesh in memory, which could really start to lag a system if it is
    complex. This is outside the scope of this book, so unchecking this option is
    a good idea.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在游戏运行时对网格进行修改，**读/写启用**选项将非常有用。这使得你可以实现一些非常酷的功能，比如可破坏的环境，你的脚本可以根据被射击的位置将网格分割成碎片。然而，这也意味着Unity需要在内存中保留网格的一个副本，如果它很复杂，这可能会让系统开始变得卡顿。这超出了本书的范围，因此取消选中此选项是个好主意。
- en: The **Optimize Mesh** option is a good one to leave on, unless you are doing
    something specific and fancy with the mesh. With this on, Unity does some special
    'behind the scenes' magic. In computer graphics and especially Unity, every mesh
    is ultimately a series of triangles that are drawn on a screen. This option allows
    Unity to reorder the triangles in the file so that the whole mesh can be drawn
    faster and more easily.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格**选项是一个好的选择，除非你对网格有特定的高级操作。开启这个选项，Unity会进行一些特殊的“幕后”处理。在计算机图形学中，尤其是在Unity中，每个网格最终都是由一系列在屏幕上绘制的三角形组成。此选项允许Unity重新排列文件中的三角形，以便更快、更容易地绘制整个网格。'
- en: The **Import BlendShapes** option allows Unity to make sense of any BlendShapes
    that might be part of the model. These are animated positions of the vertexes
    of the model. Usually, they are used for facial animations. The next option, **Generate
    Colliders**, is a useful one if you're doing complex things with physics. Unity
    has a set of simple collider shapes that should be used whenever possible because
    they are easier to process. However, there are situations where they won't quite
    get the job done; for example, a rubble or a half-pipe where the collision shape
    is too complex to be made with a series of simple shapes. That is why Unity has
    a **Mesh Collider** component. With this option checked, a **Mesh Collider** component
    is added to every mesh in our model. We will be sticking with simple colliders
    in this chapter, so leave the **Generate Colliders** option off.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入混合形状**选项允许Unity理解模型中可能包含的任何混合形状。这些是模型顶点的动画位置。通常，它们用于面部动画。下一个选项，**生成碰撞器**，在进行物理方面的复杂操作时非常有用。Unity有一组简单的碰撞器形状，应该尽可能使用，因为它们更容易处理。然而，在某些情况下，它们可能无法完全完成任务；例如，瓦砾或半管，其中碰撞形状太复杂，无法用一系列简单的形状制作。这就是为什么Unity有一个**网格碰撞器**组件。选中此选项后，将为模型中的每个网格添加一个**网格碰撞器**组件。本章我们将坚持使用简单的碰撞器，所以将**生成碰撞器**选项关闭。'
- en: The **Swap UVs** and **Generate Lightmap UVs** options are primarily used when
    working with lighting, especially lightmaps. Unity can handle two sets of UV coordinates
    on a model. Normally, the first is used for the texture and the second for the
    lightmap or shadow texture. If they are in the wrong order, **Swap UVs** will
    change them so that the second set comes first. If you need an unwrap for a lightmap
    but did not create one, **Generate Lightmap UVs** will create one for you. We
    are not working with lightmaps in this project, so both of these can remain off.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换 UV**和**生成光照贴图 UV**选项主要用于处理光照，尤其是光照贴图时。Unity 可以处理模型上的两套 UV 坐标。通常，第一套用于纹理，第二套用于光照贴图或阴影纹理。如果它们的顺序错误，**交换
    UV**会将它们更改，使得第二套先出现。如果你需要一个光照贴图的展开，但并未创建一个，**生成光照贴图 UV**将为你创建一个。在这个项目中我们不使用光照贴图，所以这两个选项可以保持关闭。'
- en: Normals & Tangents
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法线与切线
- en: 'The **Normals & Tangents** section of the earlier screenshot has the following
    options:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 早期截图中的**法线与切线**部分有以下选项：
- en: The next section of options, **Normals & Tangents**, begins with the **Normals**
    option. This defines how Unity will hold the normals of your mesh. By default,
    they are imported from the file; however, there is also the option to make Unity
    calculate them based on the way the mesh is defined. Otherwise, if we set this
    option to **None**, Unity will not import the normals. Normals are needed if we
    want our mesh to be affected by real-time lighting or make use of normal maps.
    We will be making use of real-time lighting in this project, so leave it set to
    **Import**.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个选项部分，**法线与切线**，从**法线**选项开始。这定义了 Unity 如何保存你的网格的法线。默认情况下，它们是从文件中导入的；然而，也有一个选项让
    Unity 根据网格的定义方式计算它们。否则，如果我们将此选项设置为**无**，Unity 将不会导入法线。如果我们希望网格受到实时光照的影响或使用法线贴图，就需要法线。在这个项目中我们将使用实时光照，所以将其设置为**导入**。
- en: The **Tangents**, **Smoothing Angle**, and **Split Tangents** options are used
    if your mesh has a normal map. Tangents are needed to determine how lighting interacts
    with a normal mapped surface. By default, Unity will calculate these for you.
    Importing tangents is only possible from a few file types. The smoothing angle,
    based on the angle between the two faces, dictates whether shading across an edge
    would be smooth or sharp. The **Split Tangents** option is there to handle a few
    specific lighting quirks. If lighting is broken by seams, enabling this option
    will fix it. Normal maps are great for making a low-resolution game look like
    a high-resolution one. However, because of all the extra files and information
    needed to use them, they are not ideal for a mobile game. Therefore, we will not
    be using them in this book and so all of these options can be turned off to save
    memory.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的网格具有法线贴图，那么**切线**、**平滑角度**和**分割切线**选项将派上用场。切线用于确定光照如何与法线贴图表面交互。默认情况下，Unity
    会为你计算这些。导入切线仅限于几种文件类型。基于两个面之间角度的平滑角度，决定了边缘的着色是平滑还是锐利。**分割切线**选项用于处理一些特定的光照问题。如果光照被接缝破坏，启用此选项将修复它。法线贴图非常适合让低分辨率游戏看起来像高分辨率游戏。然而，由于使用它们需要额外的文件和信息，它们并不适合移动游戏。因此，在本书中我们不使用它们，这些选项都可以关闭以节省内存。
- en: The **Keep Quads** option will allow your models to take advantage of DirectX
    11's new tessellation techniques for creating high-detail models from low-detail
    models and a special displacement map. Unfortunately, it will be a while before
    mobile devices can support such detail, and even longer before they become commonplace.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持四边形**选项将允许你的模型利用 DirectX 11 的新镶嵌技术，从低细节模型和特殊的位移贴图创建高细节模型。不幸的是，移动设备支持这种细节还需要一段时间，而要成为普遍现象则需要更长时间。'
- en: Materials
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材质
- en: 'The **Materials** section of the previous screenshot has the following options:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图中的**材质**部分有以下选项：
- en: The last section, **Materials**, defines how Unity should look for materials.
    The first option, **Import Materials**, allows you to decide whether or not a
    material should be imported. If it is turned off, a default white material will
    be applied. This material will not show up anywhere in your project; it is a hidden
    default. For models that will not have any textures, such as collision meshes,
    this can be turned off. For our tank and nearly every other case, this should
    be left on.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个部分，**材质**，定义了 Unity 应该如何查找材质。第一个选项，**导入材质**，允许你决定是否导入材质。如果关闭，将应用默认的白色材质。这种材质在项目中任何地方都不会显示；它是一个隐藏的默认值。对于不会有任何纹理的模型，比如碰撞网格，可以关闭这个选项。对于我们坦克模型以及几乎其他所有情况，应该保持开启状态。
- en: The last two options, **Material Naming** and **Material Search**, work together
    to name and find the materials for the mesh. Directly below them, there is a text
    box that describes how Unity will go about searching for the material.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后两个选项，**材质命名**和**材质搜索**，共同作用于为网格命名和查找材质。在它们下面直接是一个文本框，描述了 Unity 将如何搜索材质。
- en: The name of the material being searched for can be the name of the texture used
    in the modeling program, the name of the material created in the modeling program,
    or the name of the model and the material. If a texture name cannot be found,
    the material name will be used.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索的材质名称可以是建模程序中使用的纹理名称、建模程序中创建的材质名称，或者是模型和材质的名称。如果找不到纹理名称，将使用材质名称。
- en: By default, Unity does a recursive-up search. This means that we start the search
    by looking in the `Materials` folder, followed by a search for any materials that
    are in the same folder. We then check the parent folder for matching materials,
    followed by the folder above that. This continues until we find either the material
    that has the correct name or we reach the root assets folder.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Unity 会进行递归向上搜索。这意味着我们从`Materials`文件夹开始搜索，然后查找同一文件夹中的任何材质。接着检查父文件夹是否有匹配的材质，然后是上一级文件夹。如此继续，直到找到具有正确名称的材质，或者到达根资产文件夹。
- en: Alternatively, we have the options of checking the entire project or only looking
    in the `Materials` folder that is next to our model. The defaults for these options
    are just fine. In general, they do not need to be changed. They can be easily
    dealt with, especially for a large project, using the Unity Editor scripting,
    which will not be covered in this book.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，我们还可以选择检查整个项目，或者只在我们模型旁边的`Materials`文件夹中查找。这些选项的默认设置已经很好了。通常，它们不需要更改。特别是对于大型项目，可以使用
    Unity 编辑器脚本轻松处理，本书将不涉及这部分内容。
- en: The Revert and Apply buttons
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复和应用按钮
- en: 'Next, the screenshot has the **Revert** and **Apply** buttons, which are explained
    here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，截图中有**恢复**和**应用**按钮，下面将对此进行解释：
- en: Whenever changes are made to the import settings, one of the two buttons, **Revert**
    or **Apply**, must be chosen. The **Revert** button cancels the changes and switches
    the import settings back to what they were before changes were made. The **Apply**
    button confirms the changes and reimports the model with the new settings if these
    buttons are not selected; Unity will complain with a pop up and force you to make
    a choice before letting you mess with anything else.![The Revert and Apply buttons](img/4691OT_03_02.jpg)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当对导入设置进行更改时，必须选择两个按钮中的一个，**恢复**或**应用**。**恢复**按钮取消更改，并将导入设置恢复到更改之前的状态。**应用**按钮确认更改，并使用新设置重新导入模型。如果没有选择这些按钮，Unity
    会弹出一个对话框并强制你做出选择，然后才能进行其他操作。![恢复和应用按钮](img/4691OT_03_02.jpg)
- en: Finally, we have two types of previews as we can see in the previous screenshot.
    The **Imported Object** section is a preview of what the object will look like
    in the **Inspector** window, if we added the object to the **Scene** view and
    selected it. The **Preview** window, the section where we can see the tank model,
    is what the model will look like in the **Scene** view. You can click and drag
    the object in this window to rotate it and look at it from different angles. In
    addition, there is a little blue button in this window. By clicking on this button,
    you will be able to add labels to the object. Then, these labels will also be
    searchable in the **Project** window.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以看到如前截图所示有两种预览类型。**Imported Object**部分是如果我们将对象添加到**Scene**视图并选择它，在**Inspector**窗口中对象外观的预览。**Preview**窗口，我们可以在其中看到坦克模型的区域，是模型在**Scene**视图中的样子。你可以在该窗口中点击并拖动对象来旋转它，并从不同的角度观察它。此外，在这个窗口中有一个小蓝按钮。点击这个按钮，你将能够给对象添加标签。然后，这些标签也可以在**Project**窗口中进行搜索。
- en: Setting up the tank
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置坦克
- en: Now that we have imported the tank, we need to set it up. We will be adjusting
    the arrangement of the tank as well as creating a few scripts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经导入了坦克，我们需要对其进行设置。我们将调整坦克的布局，并创建一些脚本。
- en: The tank
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坦克
- en: 'At this point, the creation of our tank will primarily consist of the creation
    and arrangement of the tank''s components. Using the following steps, we can set
    up our tank:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们创建坦克的主要工作将包括创建和排列坦克的组件。使用以下步骤，我们可以设置我们的坦克：
- en: Start by dragging the tank from the **Project** window to the **Hierarchy**
    window. You will notice that the name of the tank appears in blue color in the
    **Hierarchy** window. This is because it is a prefab instance. Any model in your
    project largely acts like a prefab. However, we want our tank to do more than
    just sit there; so, being a prefab of a static mesh is not helpful. Therefore,
    select your tank in the **Hierarchy** window and we will start to make it useful
    be removing the **Animator** component. To do this, select the gear to the right
    of the Animator component in the **Inspector** window. From the new drop-down
    list, select **Remove Component**, as seen in the following screenshot, and it
    will be removed:![The tank](img/4691OT_03_19.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从**Project**窗口将坦克拖到**Hierarchy**窗口。你会注意到坦克的名字在**Hierarchy**窗口中以蓝色显示。这是因为它是一个预制体实例。你的项目中的任何模型在很大程度上都像预制体。然而，我们希望我们的坦克不仅仅是放在那里；所以，作为一个静态网格的预制体是没有帮助的。因此，在**Hierarchy**窗口中选择你的坦克，我们将开始通过移除**Animator**组件使其变得有用。为此，在**Inspector**窗口中选择Animator组件右侧的齿轮。从新的下拉列表中选择**Remove
    Component**，如下截图所示，它将被移除：![The tank](img/4691OT_03_19.jpg)
- en: If you are using the tank that is provided by default, selecting the different
    parts of it will reveal that all the pivot points are at the base. This will not
    be useful for making our turret and cannon pivot properly. The easiest way to
    solve this is by adding new empty **GameObjects** to act as pivot points.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用默认提供的坦克，选择它的不同部分，你会发现所有的轴心点都在底部。这对于使我们的炮塔和炮管正确旋转并不有用。解决这个问题的最简单方法就是添加新的空**GameObject**作为轴心点。
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Any object in the scene is a `GameObject`. Any empty `GameObject` is one that
    only has a **Transform** component.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 场景中的任何物体都是一个`GameObject`。任何空的`GameObject`只包含一个**Transform**组件。
- en: At the top of the Unity Editor, **Create Empty** is the first option under the
    **GameObject** button. It creates the objects that we need. Create two empty GameObjects
    and position one at the base of the turret and the other at the base of the cannon.
    In addition, rename them as `TurretPivot` and `CannonPivot` respectively. This
    can be done with the textbox at the very top of the **Inspector** window if the
    object is selected.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，**Create Empty**是**GameObject**按钮下的第一个选项。它创建了我们所需要的物体。创建两个空的GameObject，并将一个定位在炮塔底部，另一个定位在炮管底部。此外，分别将它们重命名为`TurretPivot`和`CannonPivot`。如果选择了物体，这可以通过**Inspector**窗口顶部的文本框来完成。
- en: In the **Hierarchy** window, drag `TurretPivot` onto `Tank`. This changes the
    parent of `TurretPivot` to `Tank`. Then, drag the object, that is, the turret
    mesh, onto `TurretPivot`. In the code, we will be rotating the pivot point and
    not the mesh directly. When a parent object moves or rotates, all of the children
    objects move with it. When you make this change, Unity will complain about the
    change to the original hierarchy of the object; it does this just to make sure
    that it is a change that you want to make and not an accident:![The tank](img/4691OT_03_06.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，将 `TurretPivot` 拖到 `Tank` 上。这将改变 `TurretPivot` 的父对象为 `Tank`。然后，将对象（即炮塔网格）拖到
    `TurretPivot` 上。在代码中，我们将旋转枢轴点而不是直接旋转网格。当一个父对象移动或旋转时，所有子对象都会随之移动。当你进行这个更改时，Unity
    会抱怨关于对象原始层次结构的更改；它这样做只是为了确保这是一个你想要做的更改，而不是一个意外：![坦克](img/4691OT_03_06.jpg)
- en: As losing the connection to the prefab can potentially break a game, Unity just
    wants to be sure that we actually want it to happen. So, click on **Continue**
    and we can finish working with the tank without other complaints from Unity. We
    also need to make `CannonPivot` a child of `TurretPivot` and the cannon a child
    of `CannonPivot`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于失去与预制件的连接可能会破坏游戏，Unity 想要确保我们确实希望这样做。因此，点击**继续**按钮，我们就可以在没有Unity其他抱怨的情况下完成坦克的工作。我们还需要将
    `CannonPivot` 设置为 `TurretPivot` 的子对象，并将炮管设置为 `CannonPivot` 的子对象。
- en: To finish our hierarchy changes, we need to place the camera. Since we want
    the player to appear as if they are is actually in the tank, the camera should
    be placed behind and above the tank with a tilt slightly downward to focus on
    a spot a few tank lengths ahead. Once it is positioned, make it a child of `TurretPivot`
    as well.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的层次结构更改，我们需要放置摄像机。由于我们希望玩家看起来就像是在坦克里一样，摄像机应该放在坦克后面和上方，稍微向下倾斜，以聚焦在几辆坦克长度前的一个点。一旦定位好，也将其设置为
    `TurretPivot` 的子对象。
- en: We have set up the basic structure that our tank will use. By making use of
    multiple objects in this way, we can control their movements and actions independently
    from each other. At this point, instead of having a rigid tank that only points
    forward, we can tilt, rotate, and aim each piece independently.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个基础结构，我们的坦克将会使用这个结构。通过这种方式使用多个对象，我们可以独立地控制它们的移动和动作。在这一点上，我们不再拥有一个只能向前指的僵硬坦克，我们可以独立地倾斜、旋转和瞄准每个部分。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Also, the tank should be centered above the point at which you want the whole
    thing to pivot around. If yours is not, you can select everything that is under
    the base tank object in the **Hierarchy** window and move it around.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，坦克应该位于你希望整个物体围绕其旋转的中心点上方。如果它不是，你可以在**层次结构**窗口中选择基础坦克对象下的所有内容，并移动它们。
- en: Keeping score
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持计分
- en: 'A short script for keeping track of a player''s score and the addition of a
    text element will constitute the focus of this short section. The following are
    the steps for the creation of our script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点关注一个简短的脚本，用于跟踪玩家的分数和文本元素的添加。以下是创建我们脚本的步骤：
- en: The first script that is needed to make our tank work is fairly simple. Create
    a new script and name it `ScoreCounter`. It will, as the name implies, track the
    score. Create it in the `Scripts` folder and clear out the default functions,
    just like every other script that we have made so far.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们的坦克工作的第一个脚本非常简单。创建一个新的脚本，并将其命名为 `ScoreCounter`。顾名思义，它将跟踪分数。在 `Scripts` 文件夹中创建它，并清除到目前为止我们制作的其他脚本中的默认函数。
- en: 'Just like we did in the previous chapter, since any script that needs access
    to any of our GUI elements needs an extra line at the very top of the script,
    add the following line of code right after the line that says `using UnityEngine;`.
    This allows us to use and change the text element we need to display the score:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如上一章所做的那样，由于任何需要访问我们的GUI元素的脚本都需要在脚本最顶部添加一行代码，在 `using UnityEngine;` 这行代码之后添加以下代码行。这允许我们使用并更改需要显示分数的文本元素：
- en: '[PRE0]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following line of code should look familiar from the previous chapter.
    First, we define an integer counter. As it is static, other scripts (such as the
    ones we will create for the targets) will be able to modify this number and give
    us the score:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码应该从上一章看起来很熟悉。首先，我们定义了一个整数计数器。由于它是静态的，其他脚本（例如我们为靶子创建的脚本）将能够修改这个数字，并给我们得分：
- en: '[PRE1]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will then add a variable to store the text element for our interface. It
    will work like the turn indicator from the previous chapter, giving us a location
    to update and display the player''s score:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个变量来存储界面的文本元素。它将像上一章中的转向指示器一样工作，为我们提供一个位置来更新和显示玩家的分数：
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last bit of code for this script is an `Update` function. This function
    is called automatically by Unity for every single frame. This is the perfect spot
    for us to put any code and logic that needs to change regularly without the player''s
    direct input. For our purpose, we will update the text element and make certain
    that it always has the most up-to-date score to display. By adding the score to
    double quotes, we are changing the number into a word so that it can be used properly
    by the text element:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的最后一段代码是一个`Update`函数。这个函数由 Unity 自动为每一帧调用。这是放置任何需要定期更改而无需玩家直接输入的代码和逻辑的完美位置。对于我们的目的，我们将更新文本元素，并确保它总是显示最新的分数。通过将分数添加到双引号中，我们将数字转换为单词，以便文本元素可以正确使用它：
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's it for this very simple script. It will track our score throughout the
    game. In addition, instead of doing any of the score increments itself, other
    scripts will update the counter to give points to the player.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个非常简单的脚本的全部内容。它将跟踪整个游戏过程中的分数。此外，它本身不会执行任何分数增加的操作，而是由其他脚本更新计数器来给玩家加分。
- en: Repeat buttons
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复按钮
- en: 'The buttons that we have used so far only perform an action when they are pressed
    and released. Our players will need to hold down the buttons to control their
    tank. So, we need to create a repeat button; a button that performs an action
    as long as it is held down. Follow these steps to create a repeat button:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们使用的按钮只在按下并释放时执行操作。我们的玩家需要按住按钮来控制他们的坦克。因此，我们需要创建一个重复按钮；一个只要按住就会执行操作的按钮。按照以下步骤来创建一个重复按钮：
- en: Create a new script that should be named as `RepeatButton`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RepeatButton`的新脚本。
- en: 'To give this script access to the parts of Unity that it needs in order to
    work, just like the previous script, we need to add the following two lines right
    after the one that says `using UnityEngine;`. The first will give us access to
    the `Selectable` class: the one from which all interactive interface elements
    are derived. The second will let us handle the events that occur when our players
    interact with our new button:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让这个脚本能够访问到它需要工作的 Unity 部分，和之前的脚本一样，我们需要在写着`using UnityEngine;`的那一行下面添加以下两行。第一行将让我们访问到`Selectable`类：所有交互式界面元素都从中派生的那个类。第二行将使我们能够处理玩家与我们新按钮交互时发生的事件：
- en: '[PRE4]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to update the `public class` line of our code. Any normal script
    that will provide functionality to the objects in our game expands upon the `MonoBehaviour`
    class. We need to change the line to the following, so that our script can instead
    exist in and expand the functionality of the interface:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新代码中的`public class`行。任何为游戏中的对象提供功能的普通脚本都是对`MonoBehaviour`类的扩展。我们需要将行更改为以下内容，以便我们的脚本可以存在于界面中并扩展其功能：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our script will have a total of four variables. The first allows it to keep
    track of whether or not it is being pressed:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的脚本总共有四个变量。第一个允许它跟踪是否被按下：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next three variables will provide the same functionality as the button
    did in the previous chapter. For the button, we had to select an object, followed
    by a function from a specific script, and finally some value to send. Here, we
    are going to do the same thing. The first variable here keeps track of which object
    in the scene we are going to interact with. The second will be the name of a function
    that is on some of the script attached to the object. The last will be a number
    to send along for the function, and it will provide more specific input:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的三个变量将提供与上一章中按钮相同的功能。对于按钮，我们必须选择一个对象，然后选择特定脚本中的一个函数，最后发送一些值。这里，我们将做同样的事情。这里的第一变量跟踪我们要在场景中与之交互的对象。第二个将是附加到对象上某个脚本中的函数名称。最后一个将是一起发送给函数的数字，它将提供更具体的输入：
- en: '[PRE7]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first function for this script will override a function provided by the
    `Selectable` class. It is called the moment the player clicks on the button. It
    is given some information about how and where it was clicked, which is stored
    in `eventData`. The second line just calls the function of the same name on the
    parent class. The last thing the function does is set our Boolean flag to mark
    that the button is currently being pressed by the player:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本脚本的第一函数将覆盖`Selectable`类提供的函数。当玩家点击按钮时立即调用它。它接收到一些关于点击方式和位置的信息，这些信息存储在`eventData`中。第二行只是调用了父类中同名的函数。该函数最后做的是设置我们的布尔标志，以标记按钮当前正被玩家按下：
- en: '[PRE8]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next function does the exact same thing as the previous function. The main
    difference is that it is called when the mouse or touch from the player is no
    longer over the button in the interface. The second difference is that it sets
    the Boolean to `false` because when our player drags their finger off the button,
    they are no longer pressing it, and we want to stop performing our action in that
    case:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数与上一个函数完全相同。主要区别在于，当玩家的鼠标或触摸不再位于界面中的按钮上时调用它。第二个区别是它将布尔值设置为`false`，因为当玩家将手指从按钮上移开时，他们不再按下按钮，在这种情况下我们希望停止执行我们的动作：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following function is like the first two. However, it is called when the
    button is released:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数与前两个类似。但是，当按钮释放时调用它：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final function of this script is again our `Update` function. It first
    checks whether the player is currently pressing this button. It then calls the
    `SendMessage` function on our target object, telling it what function to perform
    and what number to use. The `SendMessage` function is only available for **GameObject**
    and **MonoBehviour** components. It takes the name of a function and tries to
    find it on the GameObject to which the message was sent:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本的最后一个函数是我们的`Update`函数。它首先检查玩家当前是否按下了按钮。然后它在我们目标对象上调用`SendMessage`函数，告诉它要执行哪个函数以及使用哪个数字。`SendMessage`函数仅对**GameObject**和**MonoBehviour**组件可用。它接收一个函数名，并尝试在接收消息的GameObject上找到它：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another script done! This one allows us to hold buttons rather than be forced
    to press them repeatedly to move through our game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个脚本完成了！这个脚本允许我们按住按钮，而不是被迫反复按下按钮来在游戏中移动。
- en: Controlling the chassis
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制底盘
- en: 'A normal tank rotates in place, and it can easily move forward and back. We
    will make our tank do this with the creation of a single script. Perform these
    steps to create our second script for the tank:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 常规坦克可以进行原地旋转，并且可以轻松地前进和后退。我们将通过创建一个脚本来使我们的坦克实现这一点。按照以下步骤为坦克创建我们的第二个脚本：
- en: The second script is called `ChassisControls`. It will make our tank move around.
    We will create it in the `Scripts` folder as well.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个脚本称为`ChassisControls`。它将使我们的坦克四处移动。我们将在`Scripts`文件夹中创建它。
- en: 'The first three lines of the script define the variables that the tank will
    need to move around. We will also be able to change them in the **Inspector**
    window, in case our tank is too fast or too slow. The first line defines a variable
    that holds a connection to a `CharacterController` component. This component will
    not only move the tank around easily but it will also allow it to stop by walls
    and other colliders. The next two lines of code define how fast we move and rotate:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的前三行定义了坦克移动所需的变量。我们还可以在**检查器**窗口中更改它们，以防我们的坦克太快或太慢。第一行定义了一个变量，该变量保存了对`CharacterController`组件的连接。这个组件不仅容易移动坦克，而且还能让它碰到墙壁和其他碰撞体时停止。接下来的两行代码定义了我们移动和旋转的速度：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We start the following line of code by defining our `MoveTank` function; it
    needs to be passed a `speed` value to dictate how far and in which direction the
    tank should go. A positive value will make the tank go forward and a negative
    value will make it go backwards:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义`MoveTank`函数，它需要传递一个`speed`值来决定坦克应该向哪个方向以及多远前进。正值将使坦克向前移动，负值将使其向后移动：
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to move in a three-dimensional space, we need a vector—a value with
    both direction and magnitude. Therefore, we define a movement vector and set it
    to the tank's forward direction, multiplied by the tank's speed, and again multiplied
    by the amount of time that has elapsed since the last frame.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在三维空间中移动，我们需要一个向量——一个既有方向又有大小的值。因此，我们定义了一个移动向量，并将其设置为坦克的前进方向，乘以坦克的速度，再乘以自上一帧以来经过的时间量。
- en: 'If you remember from geometry class, 3D space has three axes: x, y, and z.
    In Unity, the following convention applies: x is to the right, y is up, and z
    is forward. The transform component holds these values for an object''s position,
    rotation, and scale. We can access the transform component of any object in Unity
    by calling upon the `transform` variable that Unity provides. The `transform`
    component also provides a `forward` variable that will give us a vector that points
    in the direction in which the object is facing.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你记得几何课上的内容，3D空间有三条轴：x、y 和 z。在Unity中，以下约定适用：x是向右，y是向上，z是向前。transform组件保存了一个对象的位置、旋转和缩放的这些值。我们可以通过调用Unity提供的`transform`变量来访问Unity中任何对象的transform组件。`transform`组件还提供了一个`forward`变量，它会给出一个指向对象面向方向的向量。
- en: In addition, we want to move at a regular pace, for example, a certain number
    of meters per second; therefore, we make use of `Time.deltaTime`. This is a value
    provided by Unity that holds how many seconds it has been since the last frame
    of the game was drawn on screen. Think of it like a flip book. In order to make
    it look like a guy is walking across the page, he needs to move slightly on each
    page. In the case of a game, the pages are not flipped regularly. So, we have
    to modify our movement by how long it has taken to flip to the new page. This
    helps us to maintain an even pace.x2
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们希望以恒定的速度移动，例如，每秒移动一定的距离；因此，我们使用了`Time.deltaTime`。这是Unity提供的一个值，它表示自上次在屏幕上绘制游戏的帧以来已经过去了多少秒。你可以把它想象成翻书。为了使一个人看起来像是在页面上走动，他在每一页上都需要稍微移动一点。在游戏的情况下，页面不是定期翻动的。因此，我们必须根据翻到新页面所花费的时间来调整我们的移动。这有助于我们保持恒定的速度。
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we want to stay on the ground. In general, any character you want to
    control in a game does not automatically receive all of the physics, such as gravity,
    that a boulder would. For example, when jumping, you temporarily remove gravity
    so that the character can go up. That is why the next line of code does a simple
    implementation of gravity by subtracting the normal speed of gravity and then
    keeping it in pace with our frame rate:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望角色保持在地面上。通常，在游戏中，任何你想控制的字符不会自动获得像石头那样的所有物理特性，比如重力。例如，当跳跃时，你暂时移除了重力，使角色能够向上移动。这就是为什么下一行代码简单地实现了重力，通过减去正常的重力速度，然后使其与我们的帧率保持同步：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, for the `MoveTank` function, we actually do the moving. The `CharacterController`
    component has a special `Move` function that will move the character but constrain
    it by collisions. We just need to tell it how far and in which direction we want
    to move this frame by passing the `move` vector to it. This final curly brace,
    of course, closes off the function:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于`MoveTank`函数，我们实际上执行了移动操作。`CharacterController`组件有一个特殊的`Move`函数，它能够移动角色并受到碰撞的限制。我们只需通过传递`move`向量来告诉它本帧我们想要移动多远以及移动的方向。当然，最后的这个花括号结束了这个函数的定义：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `RotateTank` function also needs a speed value to dictate how fast and in
    which direction to rotate. We start by defining another vector; however, instead
    of defining in which direction to move, this one will dictate in which direction
    to rotate around. In this case, we will be rotating around our up direction. We
    will then multiply that by our `speed` and `Time.deltaTime` parameters to move
    fast enough and keep pace with our frame rate.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RotateTank`函数也需要一个速度值来指定旋转的速度和方向。我们从定义另一个向量开始；然而，这个向量不是定义移动的方向，而是定义旋转的方向。在这种情况下，我们将围绕向上的方向旋转。然后我们将这个向量乘以我们的`speed`和`Time.deltaTime`参数，以足够快的速度移动并保持与我们的帧率同步。'
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last bit of the function actually does the rotation. The **Transform**
    component provides a `Rotate` function. Rotation, especially in 3D space, can
    become weird and difficult very quickly. The `Rotate` function handles all of
    that for us; we just need to supply it with the values to apply for rotation.
    In addition, don''t forget the curly brace to close off the function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最后部分实际上执行了旋转操作。**Transform**组件提供了一个`Rotate`函数。在3D空间中，尤其是进行旋转操作时，可能会变得复杂和困难。`Rotate`函数为我们处理了所有这些操作；我们只需要为它提供要应用的旋转值。此外，别忘了用花括号结束这个函数的定义：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a script to control the movement of our tank. It will use a special
    `Move` function from the `CharacterController` component so that our tank can
    move forwards and backwards. We also used a special `Rotate` function provided
    by the **Transform** component to rotate our tank.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个控制坦克移动的脚本。它将使用`CharacterController`组件的专用`Move`函数，使我们的坦克能够前进和后退。我们还使用了**Transform**组件提供的专用`Rotate`函数来旋转坦克。
- en: Controlling the turret
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制炮塔
- en: 'This next script will allow the player to rotate their turret and aim the cannon:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本将允许玩家旋转他们的炮塔并瞄准炮管：
- en: The last script that we need to create for our tank is `TurretControls`. This
    script will allow players to rotate the turret left and right and tilt the cannon
    up and down. As with all of the others, create it in the `Scripts` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为坦克创建的最后一个脚本为`TurretControls`。这个脚本将允许玩家左右旋转炮塔，以及上下倾斜炮管。与所有其他脚本一样，在`Scripts`文件夹中创建它。
- en: 'The first two variables that we define will hold pointers to the turret and
    cannon pivots- the empty `GameObjects` that we created for our tank. The second
    set is the speed at which our turret and cannon will rotate. Finally, we have
    some limit values. If we didn''t limit how much our cannon could rotate, it would
    just spin around and around, passing through our tank. This isn''t the most realistic
    behavior for a tank, so we must put some limits on it. The limits are in the range
    of 300 because straight ahead is zero degrees and down is 90 degrees. We want
    it to be in the upward angle, so it is in the range of 300\. We can also use 359.9
    because Unity will change 360 to zero so that it can continue to rotate:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义的前两个变量将保存指向炮塔和炮管旋转点的指针——我们为坦克创建的空`GameObjects`。第二组是炮塔和炮管的旋转速度。最后，我们设置了一些限制值。如果我们不对炮管的旋转角度进行限制，它只会不停地旋转，穿过坦克。这对于坦克来说并不是最真实的行为，因此我们必须设置一些限制。限制范围是300度，因为正前方是0度，向下是90度。我们希望它是向上的角度，所以范围是300度。我们也可以使用359.9度，因为Unity会将360度变为零度，以便它能够继续旋转：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next is the `RotateTurret` function. It works in exactly the same way as the
    `RotateTank` function. However, instead of looking at a `CharacterController`
    component''s `transform` variable, we act upon the `turretPivot` variable:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`RotateTurret`函数。它的工作原理与`RotateTank`函数完全相同。但是，我们不是查看`CharacterController`组件的`transform`变量，而是对`turretPivot`变量进行操作：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second and last function, `RotateCannon`, gets a little more down-and-dirty
    with rotations. The fault completely lies with the need to put limits on the rotation
    of the cannon. After opening the function, the first step is to figure out how
    much we are going to be rotating this frame. We use a float value instead of a
    vector because we have to set the rotation ourselves:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个也是最后一个函数`RotateCannon`，在处理旋转时会更深入一些。这完全是因为我们需要对炮管的旋转设置限制。打开函数后，第一步是确定我们这一帧将旋转多少。我们使用浮点值而不是向量，因为我们必须自己设置旋转：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we define a variable that holds our current rotation. We do this because
    Unity will not let us act on the rotation directly. Unity actually keeps track
    of rotation as a quaternion. This is a complex method of defining rotations that
    is beyond the scope of this book. Luckily, Unity gives us access to an x, y, and
    z method of defining rotations called `EulerAngles`. It is a rotation around each
    of the three axes in 3D space. The `localEulerAngles` value of a **Transform**
    component is the rotation relative to the parent **GameObject**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个变量来保存当前的旋转值。这样做是因为Unity不允许我们直接对旋转值进行操作。实际上，Unity以四元数的形式跟踪旋转，这种方法超出了本书的讨论范围。幸运的是，Unity为我们提供了名为`EulerAngles`的方法，通过x、y和z定义旋转。这是围绕三维空间中的三个轴的旋转。**Transform**组件的`localEulerAngles`值是相对于父**GameObject**的旋转。
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is called `EulerAngles` because of Leonhard Euler, a Swiss mathematician,
    who came up with this method of defining rotations.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它被称为`EulerAngles`，因为这是由瑞士数学家莱昂哈德·欧拉提出的一种定义旋转的方法。
- en: 'Next, we adjust the rotation and apply the limits in one go through the use
    of the `Mathf.Clamp` function. `Mathf` is a group of useful mathematical functions.
    The `clamp` function takes a value and makes it no lower and no higher than the
    other two values passed to the function. So, we first send it our *x* axis rotation,
    which is the result of subtracting rotate from the current x rotation of `euler`.
    As the positive rotation is clockwise around an axis, we have to subtract our
    rotation to go up instead of down with a positive value. Next, we pass our lower
    limit to the `Clamp` function, followed by our higher limit: these are the `lowCannonLimit`
    and `highCannonLimit` variables that we defined at the top of the script:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`Mathf.Clamp`函数一次性调整旋转并应用限制。`Mathf`是一组有用的数学函数。`clamp`函数接收一个值，并使其不低于也不高于传递给函数的其他两个值。因此，我们首先发送我们的*x*轴旋转，这是从`euler`的当前x旋转中减去rotate的结果。由于沿轴正向旋转是顺时针的，因此我们需要减去我们的旋转，以便向上而不是向下使用正值。接下来，我们将下限传递给`Clamp`函数，然后是我们的上限：这是我们顶部脚本中定义的`lowCannonLimit`和`highCannonLimit`变量：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we have to actually apply the new rotation to our cannon''s pivot
    point. This involves simply setting the `localEulerAngles` value of the **Transform**
    component to the new value. Again, be sure to use the curly brace to close off
    the function:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将新的旋转实际应用到炮塔的支点。这只需将**变换**组件的`localEulerAngles`值设置为新的值。同样，请确保使用花括号关闭函数：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have now created a script that will control the turret of the tank. The player
    will be able to control the tilt of the cannon and rotation of the turret. This
    script functioned in a very similar manner to the `ChassisControls` script that
    we created earlier—the difference was in limiting the amount the cannon can tilt.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个可以控制坦克炮塔的脚本。玩家将能够控制炮管的倾斜和炮塔的旋转。这个脚本与我们之前创建的`ChassisControls`脚本功能非常相似——区别在于限制炮管可以倾斜的程度。
- en: Putting the pieces together
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装部件
- en: 'That was the last of the scripts for the moment. We have our tank and our scripts;
    the next step is to put them together:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这暂时是最后一个脚本了。我们有我们的坦克和脚本；下一步是将它们组合起来：
- en: Now, we need to add the scripts to our tank. Remember how we added our `Tic-tac-toe`
    script to the camera in the last chapter? Start by selecting your tank in the
    **Hierarchy** window. Before these scripts work, we will first need to add the
    `CharacterController` component to our tank. So, go to the top of the Unity Editor
    and select **Component**, then select **Physics**, and finally click on the **Character
    Controller** option.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要向坦克中添加脚本。还记得我们在上一章如何将`井字游戏`脚本添加到摄像机上的吗？首先在**层次结构**窗口中选择你的坦克。在这些脚本工作之前，我们首先需要在坦克上添加`CharacterController`组件。因此，在
    Unity 编辑器顶部选择**组件**，然后选择**物理**，最后点击**角色控制器**选项。
- en: You will notice that a green capsule appears on the tank in the **Scene** view
    as soon as you add the new component. This capsule represents the space that will
    collide and interact with other colliders. The values on the **Character Controller**
    component let us control how it interacts with other colliders. For most cases,
    the defaults for the first four parameters are just fine.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，当你添加新组件后，在**场景**视图中坦克上会出现一个绿色的胶囊。这个胶囊表示将与其他碰撞体发生碰撞和交互的空间。**角色控制器**组件上的值允许我们控制它与其他碰撞体的交互方式。在大多数情况下，前四个参数的默认值都是可以的。
- en: '![Putting the pieces together](img/4691OT_03_07.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![组装部件](img/4691OT_03_07.jpg)'
- en: 'The parameters in **Character Controller** are as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**角色控制器**中的参数如下：'
- en: '**Slope Limit**: This attribute shows us how steep an incline the controller
    can move up.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**斜率限制**：这个属性显示控制器可以爬升的斜坡的最大倾斜度。'
- en: '**Step Offset**: This attribute shows us how high a step can be before it starts
    to block movement.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步进偏移**：这个属性显示了一个台阶在开始阻挡移动之前可以有多高。'
- en: '**Skin Width**: This defines how far another collider can penetrate this controller''s
    collider before it is completely stopped. This is mostly used for squeezing between
    objects.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**皮肤宽度**：这定义了另一个碰撞体在完全停止之前可以穿透此控制器碰撞体的距离。这主要用于在物体间挤压。'
- en: '**Min Move Distance**: This attribute is for limiting jitter. It is the minimum
    amount of movement that has to be applied in a frame before it will actually move.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小移动距离**：这个属性用于限制抖动。这是在一帧中实际移动之前必须应用的最小移动量。'
- en: '**Center**/**Radius**/**Height**: These attributes define the size of the capsule
    that you see in the **Scene** view. They are used for the collision.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Center**/**Radius**/**Height**：这些属性定义了你在 **Scene** 视图中看到的胶囊的大小。它们用于碰撞。'
- en: The last three values are the most important right now. We need to adjust these
    values as closely as possible to match our tank's size. Admittedly, the capsule
    is round and our tank is square, but a `CharacterController` component is the
    easiest way to move a character with collision, and it will be used the most often.
    Use values of `2.3` for the **Radius** attribute and the **Y** portion of the
    **Center** attribute; everything else can be left as the default values.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前最后三个值最为重要。我们需要尽可能调整这些值以匹配我们坦克的大小。诚然，胶囊是圆形的，我们的坦克是方形的，但 `CharacterController`
    组件是移动带碰撞的角色最简单的方式，它将最常被使用。将 **Radius** 属性和 **Center** 属性的 **Y** 部分设置为 `2.3`；其他部分可以保持默认值。
- en: It is now time to add the scripts to our tank. Do this by selecting the tank
    in the **Hierarchy** window and dragging the `ChassisControls`, `TurretControls`,
    and `ScoreCounter` scripts onto the **Inspector** window. This is just as we did
    in the previous chapters.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是向坦克添加脚本的时候了。通过在 **Hierarchy** 窗口中选择坦克，并将 `ChassisControls`、`TurretControls`
    和 `ScoreCounter` 脚本拖到 **Inspector** 窗口。这与我们在前几章中所做的一样。
- en: Next, we need to finish creating the connections that we started in our scripts.
    Start by clicking the `CharacterController` component's name and dragging it to
    the **Character Control** slot that is on our new `ChassisControls` script component.
    Unity lets us connect object variables in the Unity Editor so that they do not
    have to be hardcoded.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要完成在脚本中开始的连接。首先点击 `CharacterController` 组件的名称，并将其拖到我们新的 `ChassisControls`
    脚本组件上的 **Character Control** 插槽。Unity 允许我们在 Unity 编辑器中连接对象变量，这样它们就不必硬编码。
- en: We also need to connect our turret and cannon pivot points. So, click and drag
    the points from the **Hierarchy** window to the corresponding variable on the
    `TurretControls` script component.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要连接我们的炮塔和炮管旋转点。因此，从 **Hierarchy** 窗口点击并拖动点，到 `TurretControls` 脚本组件上的相应变量。
- en: Before we can test our game, we need to create a bunch of GUI buttons to actually
    control our tank. Start by creating a canvas, just like we did in the previous
    chapter, and one empty GameObject.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试我们的游戏之前，我们需要创建一堆 GUI 按钮来实际控制我们的坦克。首先创建一个画布，就像我们在上一章中所做的那样，并创建一个空的 GameObject。
- en: The empty GameObject needs a **Rect Transform** component, and it needs to be
    made a child of `Canvas`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空的 GameObject 需要一个 **Rect Transform** 组件，并且需要将其设置为 `Canvas` 的子对象。
- en: Rename it to `LeftControls` and set its anchor to **bottom left**. In addition,
    set **Pos X** to `75`, **Pos Y** to `75`, **Pos Z** to `0`, **Width** to `150`,
    and **Height** to `150` as shown in the following screenshot:![Putting the pieces
    together](img/4691OT_03_03.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `LeftControls` 并将其锚点设置为**左下角**。此外，将 **Pos X** 设置为 `75`，**Pos Y** 设置为
    `75`，**Pos Z** 设置为 `0`，**Width** 设置为 `150`，**Height** 设置为 `150`，如下截图所示：![拼凑在一起](img/4691OT_03_03.jpg)
- en: Next, we need four buttons to be the children of `LeftControls`. As in the last
    chapter, they can be found at the top of the editor by navigating to **GameObject**
    | **UI** | **Button**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要四个按钮作为 `LeftControls` 的子对象。与上一章一样，通过导航到 **GameObject** | **UI** | **Button**，可以在编辑器顶部找到它们。
- en: Rename the four buttons to `Forward`, `Back`, `Left`, and `Right`. While you're
    at it, you can also change their text child to have the relevant text, such as
    `F`, `B`, `L`, and `R`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个按钮重命名为 `Forward`、`Back`、`Left` 和 `Right`。同时，你也可以将它们的文本子对象更改为相关的文本，比如 `F`、`B`、`L`
    和 `R`。
- en: The button only activates when the player clicks and releases it. Clicking repeatedly
    just to make the tank move will not work very well. So, click on the gear to the
    right of each of their **Button** components and select **Remove Component**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮仅在玩家点击并释放时激活。仅仅为了使坦克移动而重复点击效果不太好。因此，点击它们每个 **Button** 组件右侧的齿轮，并选择 **Remove
    Component**。
- en: Now, add our `RepeatButton` script to each. As we extended that `Selectable`
    class, you can see that we have all the same controls over our button that we
    did on the other buttons.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将我们的 `RepeatButton` 脚本添加到每一个按钮上。由于我们扩展了 `Selectable` 类，你可以看到我们对按钮拥有与其他按钮相同的控制权。
- en: 'Set the values of **Width** and **Height** of all the four buttons to `50`.
    Their positions become as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个按钮的 **Width** 和 **Height** 值设置为 `50`。它们的位置如下所示：
- en: '| Button | Pos X | Pos Y |'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 按钮 | Pos X | Pos Y |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Forward | 0 | 50 |'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Forward | 0 | 50 |'
- en: '| Left | -50 | 0 |'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 左 | -50 | 0 |'
- en: '| Back | 0 | -50 |'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Back | 0 | -50 |'
- en: '| Right | 50 | 0 |'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Right | 50 | 0 |'
- en: '![Putting the pieces together](img/4691OT_03_04.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![拼凑碎片](img/4691OT_03_04.jpg)'
- en: Now that we have our four movement buttons, we need to connect them to our tank.
    For each of the buttons, drag `Tank` from the **Hierarchy** panel and drop it
    in the **Target** slot in the **Inspector** panel.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了四个移动按钮，需要将它们连接到我们的坦克上。对于每个按钮，将**层次结构**面板中的`Tank`拖动到**检查器**面板中的**目标**槽里。
- en: When we next set the **Function** and **Value** slots, spelling is very important.
    If something is a little bit off, your function will not be found, lots of errors
    will appear, and the tank will not work. For the `Forward` button, set the **Function**
    slot to `MoveTank` and the **Value** slot to `1`. The `Back` button also needs
    the value of `MoveTank` in the **Function** slot, but it needs a value of `-1`
    in the **Value** slot. The `Left` button needs a value of `RotateTank` in the
    **Function** slot and a value of `-1` in the **Value** slot. The `Right` button
    needs a value of `RotateTank` in the **Function** slot and `1` in the **Value**
    slot.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们下次设置**函数**和**值**槽时，拼写非常重要。如果有一点偏差，你的函数将找不到，会出现很多错误，坦克也将无法工作。对于`Forward`按钮，将**函数**槽设置为`MoveTank`，**值**槽设置为`1`。`Back`按钮在**函数**槽中也需要`MoveTank`的值，但在**值**槽中需要`-1`。`Left`按钮在**函数**槽中需要`RotateTank`的值，**值**槽中需要`-1`。`Right`按钮在**函数**槽中需要`RotateTank`的值，**值**槽中需要`1`。
- en: Next, we need to set up our turret controls. Right-click on `LeftControls` in
    the **Hierarchy** window and select **Duplicate** from the new menu. Rename the
    new copy to `RightControls`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的炮塔控制。在**层次结构**窗口中右键点击`LeftControls`，并从新菜单中选择**复制**。将新副本重命名为`RightControls`。
- en: This new control set needs an anchor set of **bottom right**, a **Pos X** of
    `-75`, and **Pos Y** of `75` (as shown in the following screenshot):![Putting
    the pieces together](img/4691OT_03_05.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新的控制集需要一个**右下角**的锚点，**PosX**为`-75`，**PosY**为`75`（如下面的截图所示）:![拼凑碎片](img/4691OT_03_05.jpg)
- en: The buttons under this set will need to be renamed as `Up`, `Down`, `Left`,
    and `Right`. Their text can be changed to `U`, `D`, `L`, and `R` respectively.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这组下面的按钮需要被重命名为`Up`、`Down`、`Left`和`Right`。它们的文本可以分别更改为`U`、`D`、`L`和`R`。
- en: The **Function** slot of the `Up` button should be set to `RotateCannon` with
    the value of the **Value** slot as `1`. The `Down` button has a **Function** slot
    value of `RotateCannon` and a **Value** slot value of `-1`. The `Left` button
    needs `RotateTurret` as the value of the **Function** slot with a value of `-1`
    for the **Value** slot. Finally, the `Right` button needs a **Function** slot
    value of `RotateTurret` with a **Value** slot value of `1`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Up`按钮的**函数**槽应该设置为`RotateCannon`，其**值**槽的值为`1`。`Down`按钮的**函数**槽值为`RotateCannon`，**值**槽的值为`-1`。`Left`按钮需要`RotateTurret`作为**函数**槽的值，**值**槽的值为`-1`。最后，`Right`按钮需要**函数**槽的值为`RotateTurret`，**值**槽的值为`1`。'
- en: The last thing to do is to create a new Text element that can be found by navigating
    to **GameObject** | **UI** | **Text** and rename it as `Score`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件事是创建一个新的文本元素，可以通过导航到**游戏对象** | **UI** | **文本**来找到，并将其重命名为`Score`。
- en: Finally, select your `Tank` and drag `Score` from the **Hierarchy** window to
    the **Display** slot of the **Score Counter (Script)** component.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择你的`Tank`，并将**层次结构**窗口中的`Score`拖动到**分数计数器(脚本)**组件的**显示**槽中。
- en: Save the scene as `TankBattle` and try it out.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景保存为`TankBattle`并试玩一下。
- en: We just finished putting our tank together. Unless you look at the **Scene**
    view while using the movement controls, it is hard to tell that the tank is moving.
    The turret controls can be seen in the **Game** view though. Other than not having
    a point of reference for whether or not our tank is moving, it runs pretty well.
    The next step and the next section will give us that reference point as we add
    our city.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了坦克的组装。除非在使用移动控制时查看**场景**视图，否则很难判断坦克是否在移动。炮塔控制可以在**游戏**视图中看到。除了没有判断坦克是否在移动的参照点外，它运行得相当好。下一步和下一节将为我们添加城市，提供那个参照点。
- en: You might notice a quick jump when you first try to tilt the cannon. Such behavior
    is annoying and makes the game look broken. Try adjusting the cannon to fix it.
    If you are having trouble with it, take a look at the cannon's starting rotation.
    It has to do with the way the rotation is clamped every time we try to move it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，当你第一次尝试倾斜炮管时，会有一个快速的跳跃。这种行为很烦人，会让游戏看起来不完整。尝试调整炮管以修复它。如果你在这方面遇到麻烦，请查看炮管的起始旋转角度。这与我们每次尝试移动它时旋转被限制的方式有关。
- en: Creating materials
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建材质
- en: In Unity, the materials are the defining factor for how models are drawn on
    the screen. They can be as simple as coloring it all blue or as complex as reflecting
    water with waves. In this section, we will cover the details of the controls for
    a material. We will also create our city and some simple materials to texture
    it with.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，材质是决定模型在屏幕上如何绘制的关键因素。它们可以是简单的全蓝色，也可以是复杂的有波浪反射的水面。在本节中，我们将介绍控制材质的详细内容。我们还将创建我们的城市以及一些简单的材质来为其贴图。
- en: The city
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 城市
- en: 'Creating a city gives our tanks and our players a good place to play. Follow
    these steps to create our city:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个城市可以为我们的坦克和玩家提供一个良好的游戏场所。按照以下步骤来创建我们的城市：
- en: For the purpose of this section, no part of the city provided with the code
    bundle of this book was given a specific texture. It was just unwrapped and some
    tile-able textures were created. So, we need to start by importing the city and
    the textures to the `Environment` folder. Do this in the same the way in which
    we imported the tank.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了本节的目的，本书代码包中提供的城市部分没有被赋予特定的纹理。它只是被展开，并创建了一些可平铺的纹理。因此，我们需要从导入城市和纹理到`Environment`文件夹开始。以我们导入坦克的相同方式来完成这个操作。
- en: Note
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The files are `TankBattleCity.blend`, `brick_001.png`, `brick_002.png`, `brick_003.png`,
    `dirt_001.png`, `dirt_003.png`, `pebbles_001.png`, `rocks_001.png`, `rubble_001.png`,
    and `water_002.png`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相关文件包括`TankBattleCity.blend`、`brick_001.png`、`brick_002.png`、`brick_003.png`、`dirt_001.png`、`dirt_003.png`、`pebbles_001.png`、`rocks_001.png`、`rubble_001.png`以及`water_002.png`。
- en: As the city is unwrapped, Unity will still create a single material for it.
    However, textures were never applied in any modeling program. So, the material
    is plain white. We have several extra textures, so we are going to need more than
    just that one material for the whole city. Creating a new material is simple;
    it is done just like creating a new script. Right-click on the `Materials` folder
    inside the `Environment` folder, select **Create**, and then click on **Material**,
    which is about halfway down the menu.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当城市被展开时，Unity 仍然会为其创建一个单一材质。然而，在任何建模程序中都没有应用纹理。因此，材质是纯白色的。我们有多个额外的纹理，所以我们需要的不只是一个材质来覆盖整个城市。创建新材质很简单；就像创建新脚本一样。在`Environment`文件夹内的`Materials`文件夹上右键点击，选择**创建**，然后点击菜单中间的**材质**。
- en: This will create a new material in the folder and immediately allow us to name
    it. Name the material as `Pebbles`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在文件夹中创建一个新的材质，并立即允许我们为其命名。将材质命名为`Pebbles`。
- en: With your new material selected, take a look at the **Inspector** window. When
    we have selected a material, we get the options that are needed to change its
    look:![The city](img/4691OT_03_08.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的材质后，查看一下**检查器**窗口。当我们选择了一个材质，我们就可以获得改变其外观所需的选项：![The city](img/4691OT_03_08.jpg)
- en: 'You can see the following things from the preceding screenshot:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的截图我们可以看到以下内容：
- en: At the very top of the **Inspector** window, we have the material's name followed
    by a **Shader** drop-down list. A shader is essentially a short script that tells
    the graphics card how to draw something on the screen. You will use the **Standard**
    shader most often; it is essentially an all-inclusive shader, so it is always
    selected by default. This is where you would select any special effect or custom
    shaders.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的最顶部，我们有材质的名称，其后是一个**着色器**下拉列表。着色器本质上是一个简短的脚本，它告诉显卡如何在屏幕上绘制某物。你通常会使用**标准**着色器；它本质上是一个全能型着色器，因此默认情况下总是被选中。在这里，你可以选择任何特殊效果或自定义着色器。
- en: The **Rendering Mode** drop-down menu lets you pick whether or not this material
    will use any amount of transparency. **Opaque** means it will be solid. The **Cutout**
    option will render with a sharp edge around transparent areas of your texture,
    based on the value of **Alpha Cutoff**. The **Transparent** option will give you
    a smooth edge that is based on the alpha channel of your texture.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染模式**下拉菜单让你选择此材料是否使用任何程度的透明度。**不透明**表示它将是实心的。**剪切**选项将基于你的纹理透明区域的**Alpha截止值**以锐利的边缘渲染。**透明**选项将基于你的纹理的alpha通道提供平滑的边缘。'
- en: Main Maps
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主贴图
- en: 'The **Main Maps** section has the following options:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**主贴图**部分包含以下选项：'
- en: The **Main Maps** section starts with **Diffuse,** where you put your main color
    texture. It can be tinted with the color picker to the right of the slot.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主贴图**部分从**漫反射**开始，这里放置你的主颜色纹理。可以通过纹理槽右侧的颜色选择器进行着色。'
- en: The **Specular** option defines the shininess of your material; think of it
    like the glare from the light on your device's screen. You can either use an image
    to control it, or you can use the color picker to determine what color is reflected
    and the smoothness to control how sharp the glare is.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高光**选项定义了材料的光泽度；你可以想象成设备屏幕上的反光。你可以使用图像来控制它，或者使用颜色选择器来确定反射的颜色以及通过平滑度来控制反光的锐利程度。'
- en: The **Normal Map** option lets you add a texture that controls shading across
    the surface of your material. These textures need to be specially imported. If
    the texture you pick hasn't been set properly, a warning box will appear where
    you can select **Fix Now** to change it. A slider will also appear, giving you
    control over how much effect the texture has.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线贴图**选项允许你添加一个控制材料表面阴影的纹理。这些纹理需要特别导入。如果你选择的纹理没有正确设置，会出现一个警告框，你可以选择**立即修复**来更改它。还会出现一个滑块，让你控制纹理的效果程度。'
- en: The **Height Map** option works in a manner similar to **Normal Map**. It adjusts
    the bumpiness of your material and gives a slider to adjust it.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度贴图**选项的工作方式与**法线贴图**类似。它调整材料的凹凸程度，并提供一个滑块来调整它。'
- en: The **Occlusion** option lets you add an ambient occlusion texture to the material,
    controlling the darkness or lightness of the material based on the proximity of
    objects to each other in the model.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡**选项允许你向材料添加环境遮挡纹理，根据模型中物体之间的接近程度来控制材料的暗度或亮度。'
- en: The **Emission** option gives you control over the projected light and color
    that a material gives off. This only affects lightmaps and the appearance of this
    material. To actually give off light dynamically, it has to be faked with the
    addition of a real-time light.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射**选项让你控制材料发出的投影光和颜色。这只会影响光照图和此材料的外观。要实际动态地发出光，必须通过添加实时光源来模拟。'
- en: The **Detail Mask** option lets you control where the textures in **Secondary
    Maps** appear on your material.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细节遮罩**选项允许你控制**次要贴图**中的纹理在材料上的出现位置。'
- en: The values of **Tiling** and **Offset** control the size and position of the
    textures. The values of **Tiling** dictate how many times the texture will repeat
    across the normalized UV space in the x and y directions. The **Offset** parameter
    is how far from zero the texture starts in the normalized UV space. You can select
    the number fields and input values to modify them. By doing so, and paying attention
    to the **Preview** window at the bottom, you will see how they change the texture.
    Tiling textures are most commonly used for large surfaces where the texture is
    similar across the surface and a particular texture just repeats.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平铺**和**偏移**的值控制纹理的大小和位置。**平铺**的值决定了纹理在规范化的UV空间内沿x和y方向重复的次数。**偏移**参数是纹理在规范化的UV空间中从零点开始的距离。你可以选择数字字段并输入值来修改它们。这样做，并注意底部的**预览**窗口，你将看到它们如何改变纹理。平铺纹理通常用于大面积表面，这些表面的纹理相似且特定纹理只是重复出现。'
- en: Secondary Maps
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 次要贴图
- en: 'The **Secondary Maps** section has the following options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**次要贴图**部分包含以下选项：'
- en: '**Secondary Maps** starts with **Detail Diffuse x2**, which is an extra diffuse
    texture to be blended on top of your main diffuse texture. It could be used to
    add a bumpy variation across the surface of your boulder.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**次要贴图**从**细节漫反射x2**开始，这是一个额外的漫反射纹理，用于与你的主漫反射纹理混合。它可能用于在巨石表面添加凹凸不平的变化。'
- en: '**Normal Map** works like the main **Normal Map** slot and controls the shading
    of the detail textures.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second set of **Tiling** and **Offset** values work like the first and just
    control the detail textures. Usually these are set higher than the first to add
    extra interest across the surface of the material.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**UV Set** just lets you select the model unwrap set that the detail textures
    are going to use on the model to which the material is applied.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `pebbles_001` texture to this material by dragging it from the **Project**
    window and dropping it on the square to the right of the **Diffuse** slot.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the color of the texture better, use the color picker to the right of
    the **Diffuse** slot and pick a light tan color.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A value of `30` for both the **X** and **Y** values of the main **Tiling** will
    make it easier to see when **Tiling** is applied to our city streets.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see our new material in action, first drag your city to the **Hierarchy**
    window so that it is added to the **Scene** view. By right-clicking and dragging,
    you can look around in your **Scene** view, and by using *W*, *A*, *S*, and *D*,
    you can move around. Look over at the streets of the city.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag your new material from the **Project** window into your **Scene**
    view. While dragging the material around, you should see that the meshes change
    to appear as if they are using the material. Once you are over the streets, let
    go of your left mouse button. The material is now applied to the mesh.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we currently have a whole quarter of a city to texture. So, create
    more materials and use the remaining textures on the rest of the city. Create
    a new material for each extra texture, and four extra textures of `brick_002`,
    so that we can have different colors for each building's height.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply your new materials to the city, either by looking at the following screenshot
    or through your own artistic sensibility:![Secondary Maps](img/4691OT_03_09.jpg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are trying to get to the center fountain, if your tank is in the way,
    select your tank in the **Hierarchy** window and use the **Gizmo** in the **Scene**
    view to drag it out of the way.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you were to try to play the game now, you might notice that we have a couple
    of problems. For starters, we only have a quarter of a city; perhaps you have
    more if you made your own city. In addition, there is still no collision on the
    city, so we will fall right through it when we move.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Changing the size of our tank is pretty simple. Select it in the **Hierarchy**
    window and look for the **Scale** label in our **Transform** component. Changing
    the **X**, **Y**, and **Z** values under **Scale** will change the size of our
    tank. Be sure to change them evenly or some weirdness will occur when we start
    rotating the tank. Values of `0.5` make the tank small enough to fit through the
    small streets.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is collision for the city. For the most part, we will be able to get
    away with simple collision shapes that are faster to process. However, the circular
    center of the city will require something special. Start by double-clicking on
    the walls of one of the square buildings in the **Scene** view.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with prefabs, which the city still is, clicking on any object that
    makes up the prefab will select the root prefab object. Once a prefab is selected,
    clicking on any part of it will select that individual piece. Because this behavior
    is different from non-prefab objects; you need to be mindful of this when you
    select objects in the **Scene** view.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With a set of walls selected, go to the top of the Unity Editor and select **Component**,
    followed by **Physics**, and finally select **Box Collider**.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are adding the collider to a specific mesh, Unity does its best to automatically
    fit the collider to the shape. For us, this means that the new `BoxCollider` component
    is already sized to fit the building. Continue by adding `BoxCollider` components
    to the rest of the square buildings and the outer wall. Our streets are essentially
    just a plane, so a `BoxCollider` component will work just fine for them as well.
    Though it is pointed at the top, the obelisk at the center of the fountain is
    essentially just a box; so another `BoxCollider` will suit it fine.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have one last building and the fountain ring to deal with. These are not
    boxes, spheres, or capsules. So, our simple colliders will not work. Select the
    walls of the last building, the one next to the center fountain. A few options
    down from where you selected **Box Collider**, there is a **Mesh Collider** option.
    This will add a `MeshCollider` component to our object. This component does what
    its name suggests; it takes a mesh and turns it into a collider. By adding it
    to a specific mesh, the `MeshCollider` component automatically selects that mesh
    to be "collideable". You should also add `MeshCollider` components to the short
    ledge around the center building and the ring wall around the fountain.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last problem to solve is the duplication of our city quarter. Start by selecting
    the root city object in your **Hierarchy** window, select `TankBattleCity`, and
    remove the `Animator` component from it. The city is not going to animate, so
    it does not need this component.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the city in the **Hierarchy** window and click on **Duplicate**.
    This creates a copy of the object that was selected.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the city quarter two more times and we will have the four parts of
    our city. The only problem is that they will all be in the exact same position.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to rotate three of the pieces to make a full city. Select one and set
    the value of **Y Rotation** in the **Transform** component to `90`. This will
    rotate it 90 degrees around the vertical axis and give us half of a city.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will complete the city by setting one of the remaining pieces to `180` and
    the other to `270`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That leaves one last thing to do. We have four center fountains. In three of
    the four city pieces, select the three meshes that make up the center fountain
    (the `Obelisk`, `Wall`, and `Water`) and hit the *Delete* key on your keyboard.
    Confirm that you want to break the prefab connection each time, and our city will
    be complete, as shown in the following figure:![Secondary Maps](img/4691OT_03_10.jpg)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out the game now. We can drive the tank around the city and rotate its turret.
    This is so much fun. We created materials and textured the city, and after making
    it possible for the player to collide with the buildings and road, we duplicated
    the section so that we could have a whole city.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all the skills needed to import meshes and create materials,
    the challenge is to decorate the city. Create some rubble and tank traps and practice
    importing them to Unity and setting them up in the scene. If you really want to
    go above and beyond, try your hand at creating your own city; choose something
    from the world, or do something using your imagination. Once it is created, we
    can release the tanks in it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Moving treads
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is just one thing left to do, and then we will be done with materials
    and can go on to make the game even more fun. Remember the **Offset** value of
    the materials? It turns out that we can actually control it with a script. Perform
    these steps to make the treads move with our tank:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the `ChassisControls` script.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add a few variables at the beginning of the script. The first
    two will hold references to our tank tread renderers, the part of the mesh object
    that keeps track of the material that is applied to the mesh and actually does
    the drawing. This is similar to how the `characterControl` variable holds a reference
    to our `CharacterController` component:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The next two variables will keep track of the amount of offset applied to each
    tread. We store it here because this is a faster reference than trying to look
    it up from the tread's material for each frame.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To make use of the new values, the following lines of code need to be added
    at the end of the `MoveTank` function. The first line here adjusts the offset
    for the right tread as per our speed, and keeps in time with our frame rate. The
    second line utilizes the material value of a `Renderer` component to find our
    tank''s tread material. The `mainTextureOffset` value of the material is the offset
    of the primary texture in the material. In the case of our diffuse materials,
    this is the only texture. Then, we have to set the offset to a new `Vector2` value
    that will contain our new offset value. `Vector2` is just like `Vector3`, which
    we used for moving around, but it works in 2D space instead of 3D space. A texture
    is flat; therefore, it is a 2D space. The last two lines of the code do the same
    thing as the other two, but for the tank''s left tread instead:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To make the connections to the `Renderer` components of our treads, do the
    same thing that we did for the pivot points: drag the tread meshes from the **Hierarchy**
    window to the corresponding value in the **Inspector** window. Once this is done,
    be sure to save it and try it out.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We updated our `ChassisControls` script to make the tank's treads move. As the
    tank is driven around, the textures pan in the appropriate direction. This is
    the same type of functionality that is used to make waves in water and other textures
    that move.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The movement of the material doesn't quite match the speed of the tank. Figure
    out how to add an extra speed value for the tank's treads. In addition, it would
    be cool if they moved in opposite directions when the tank is rotating. Real tanks
    turn by making one tread go forward and the other back.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Animations in Unity
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next topic that we will be covering is animation. As we explore animations
    in Unity, we will create some targets for our tank to shoot at. Much of the power
    of Unity's animation system, **Mecanim**, lies in working with humanoid characters.
    But, setting up and animating human type characters could fill an entire book
    in itself, so it will not be covered here. However, there is still much that we
    can learn and do with Mecanim.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bullet points will explain all of the settings that are available
    for importing animations:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue with the explanation of the animation import settings, we
    need an animated model to work with. We have one last set of assets to import
    to our project. Import the `Target.blend` and `Target.png` files into the `Targets`
    folder of our project. Once they are imported, adjust the **Import Settings**
    window on the **Model** page for the target, just as we did for the tank. Now,
    switch to the **Rig** tab (as shown in the following screenshot):![Animations
    in Unity](img/4691OT_03_11.jpg)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Animation Type** attribute tells Unity what type of skeleton the current
    model is going to use when animation is going to be done. Models with different
    types are unable to share animations. The different options under **Animation
    Type** are as follows:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Humanoid** option adds many more buttons and switches to the page for
    working with human type characters. But again, this is too complex to cover here.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Generic** rig still uses Mecanim and many of its features. In reality, this
    is just any animation skeleton that does not resemble a human in structure.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option, **Legacy**, utilizes Unity's old animation system. However,
    this system will be phased out over the next few versions of Unity, so this will
    not be covered here either.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **None**, indicates that the object will not animate. You could
    select this option for both the tank and the city because it also keeps Unity
    from adding the Animator component, and saves space in the final project's size.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Root Node** value is a list of every object that is in the model file.
    Its purpose is to select the base object of your animation rig. For this target,
    select **Bone_Arm_Upper**, which is underneath the second **Armature** option.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Optimize Game Object** option will hide the whole skeleton of your model
    when it is checked. Hitting the plus sign on the new box that appears will allow
    you to select specific bones, which you still want access to when you view the
    model in the **Hierarchy** window. This is an especially useful option when dealing
    with any complex rig that has a great many bones.![Animations in Unity](img/4691OT_03_12.jpg)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last tab of the import settings, **Animations**, contains everything that
    we need to get the animations from our files into Unity. At the top of the **Target
    Import Settings** window, we have the **Import Animation** checkbox. If an object
    is not going to animate, it is a good idea to turn this option off. Doing so will
    also save space in your project.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option below that, **Bake Animations**, is only used when your animations
    contain kinematics and are from 3ds Max or Maya. This target is from Blender,
    so the option is grayed out.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next four options, **Anim. Compression**, **Rotation Error**, **Position
    Error**, and **Scale Error**, are primarily used for smoothing jittery animations.
    Nearly all the time, the defaults will be just fine for use.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Clips** section is what we are really concerned about here. This will
    be a list of every animation clip that is currently being imported from the model.
    On the left-hand side of the list, we have the name of the clip. On the right-hand
    side, we can see the start and end frames of the clip. The various parameters
    under the **Clips** section are as follows:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity will add a default animation to every new model. This is a clip generated
    from the default preview range of your modeling program when the file was saved.
    In the case of our target, this is **Default Take**.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Blender, it is also possible to create a series of actions for each rig.
    By default, they are imported by Unity as animation clips. In this case, the **ArmatureAction**
    clip is created.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below and to the right-hand side of the clips, there is a little tab with the
    **+** and **–** buttons. These two buttons add a clip to the end and remove the
    selected clip respectively.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Animations in Unity](img/4691OT_03_13.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When a clip is selected, the next section appears. It starts with a text field
    for changing the name of the clip.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the text field, when working with Blender, there is a **Source Take**
    drop-down list. This list is the same as the default animations. Most of the time,
    you will just use **Default Take**; but, if your animation is for ever appearing
    wrong or is missing, try changing the **Source Take** drop-down list first.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a small timeline, followed by input fields for the **Start** and
    **End** frames of the animation clip. Clicking on the two blue flags and dragging
    them in the timeline will change the numbers in the input fields.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个小的时间线，以及动画剪辑的**开始**和**结束**帧的输入字段。点击两个蓝色旗帜并在时间线上拖动它们将改变输入字段中的数字。
- en: Next, we have **Loop Time**, **Loop Pose**, and **Cycle Offset**. If we want
    our animation to repeat, check the box next to **Loop Time**. **Loop Pose** will
    cause the positions of the bones in the first and last frames of the animation
    to match. When an animation is looping, **Cycle Offset** will become available.
    This value lets us adjust the frame on which the looping animation starts.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有**循环时间**、**循环姿势**和**循环偏移**。如果我们希望动画重复，请勾选**循环时间**旁边的框。**循环姿势**将使得动画的第一帧和最后一帧中的骨骼位置相匹配。当动画循环时，**循环偏移**将变得可用。这个值让我们调整循环动画开始的帧。
- en: 'The next three small sections, **Root Transform Rotation**, **Root Transform
    Position (Y)**, and **Root Transform Position (XZ)**, allow us to control the
    movement of a character through the animation. The controls under these sections
    are as follows:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个小节，**根变换旋转**、**根变换位置（Y）**和**根变换位置（XZ）**，允许我们通过动画控制角色的移动。这些部分下的控制如下：
- en: 'All three of these sections have a **Bake into Pose** option. If these are
    left unchecked, the movement of the root node (we selected it under the **Rig**
    page) within the animation is translated into movement of the whole object. Think
    of it like this: say you were to animate a character running to the right inside
    the animation program, you will actually move them rather than animating in place
    as normal.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个部分都有一个**烘焙到姿势**的选项。如果这些选项未被选中，根节点（我们在**绑定**页面选择了它）在动画中的移动将被转换为整个对象的移动。这样想：假设你要在动画程序中动画一个向右跑的角色，实际上你会移动他们，而不是像平常一样在原地动画。
- en: With Unity's old animation system, for the physical part of a character to move
    the collider, the GameObject had to be moved with the code. So, if you were to
    use the animation, the character would appear as if it had moved, but it would
    have no collision. With this new system, the whole character will move when the
    animation is played. However, this requires a different and more complex setup
    to work completely. So, we did not use this on the tank, though we could have
    used it.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Unity 的旧动画系统，要让角色的物理部分移动碰撞器，必须用代码移动 GameObject。因此，如果你使用这个动画，角色看起来像是移动了，但实际上没有碰撞。使用这个新系统，当播放动画时整个角色都会移动。然而，这需要不同的更复杂的设置才能完全工作。所以我们没有在坦克上使用这个，尽管我们可以使用。
- en: Each of the three sections also has a **Based Upon** drop-down option. The choice
    of this option dictates the object's center for each of the sections. There are
    more choices if you are working with humanoid characters, but for now we only
    have two. A choice of **Root Node** means the pivot point of the root node object
    is the center. A choice of **Original** means that the origin, as defined by the
    animation program, is the center of the object.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个部分中的每一个都包含一个**基于**的下拉选项。这个选项的选择决定了每个部分的物体的中心。如果你在使用人形角色，会有更多的选择，但目前我们只有两个选项。如果选择**根节点**，意味着根节点对象的轴心点是中心。如果选择**原始**，则由动画程序定义的原点是物体的中心。
- en: There is also an **Offset** option for the first two of these sections that
    works to correct errors in the motion. When animating a walk cycle for a character,
    if the character is pulling to the side slightly, adjusting the **Offset** option
    under **Root Transform Rotation** will correct it.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个部分还有一个**偏移**选项，用于纠正动作中的错误。当为角色动画行走周期时，如果角色稍微向侧面拉，调整**根变换旋转**下的**偏移**选项将纠正它。
- en: The next option for our animation clip is a **Mask**. By clicking on the arrow
    to the left, you can expand a list of all objects in the model. Each object has
    a checkbox next to it. The objects that are not checked will not be animated when
    this clip is played. This is useful in the case of a hand-waving animation. Such
    an animation would only need to move the arm and hand, so we would uncheck all
    of the objects that might make up the body of the character. We could then layer
    animations, making our character capable of waving while standing, walking, or
    running without the need to create three extra animations.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的动画剪辑下一个选项是**遮罩**。通过点击左侧的箭头，你可以展开模型中所有对象的列表。每个对象旁边都有一个复选框。当播放这个剪辑时，未被勾选的对象将不会动画化。这对于挥手动画非常有用。这种动画只需要移动手臂和手，因此我们会取消勾选构成角色身体的所有对象。然后我们可以叠加动画，让角色在站立、行走或奔跑时挥手，而无需创建三个额外的动画。
- en: The **Curves** option will give you the ability to add a float value to the
    animation, which will change over the course of the animation. This value can
    then be checked by your code while the animation plays. This could be used to
    adjust the gravity affecting your character while they jump, change the size of
    their collider as they crouch into a ball, or do a great many other things.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**曲线**选项将允许你向动画中添加一个浮点值，这个值将在动画过程中改变。当动画播放时，你的代码可以检查这个值。这可以用来调整角色跳跃时受重力的影响，当他们蹲下成球体时改变碰撞器的大小，或者做许多其他的事情。'
- en: Events work similar to how we used the `SendMessage` function in our `RepeatButton`
    script. At a specific point in your animation, a function can be called to perform
    some action.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的工作原理类似于我们在`RepeatButton`脚本中使用`SendMessage`函数的方式。在你的动画中的特定时刻，可以调用一个函数来执行某些操作。
- en: The **Motion** option lets you define which bone in your animation controls
    the model motion. This can override the one chosen on the **Rig** tab. Our target
    does not move, so it is not particularly relevant to our situation.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动**选项允许你定义动画中的哪个骨骼控制模型的运动。这可以覆盖在**绑定**标签上选择的骨骼。我们的目标物不会移动，所以这对于我们的情况来说并不是特别相关。'
- en: Finally, we have our **Revert** button, **Apply** button, and the **Preview**
    window at the bottom. Just as with all of our other import settings, we have to
    hit one of these buttons when changes are made. This **Preview** window is made
    special by the speed slider in the top-right corner and the big play button in
    the top-left corner. By clicking on this button, we can preview the selected animation.
    This lets us detect the errors in motion that we discussed earlier, and it generally
    makes sure that the animation is what we want it to be.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在底部有**恢复**按钮、**应用**按钮和**预览**窗口。就像我们所有其他导入设置一样，当我们进行更改时，必须点击这些按钮之一。这个**预览**窗口的特殊之处在于右上角的速度滑块和左上角的大播放按钮。点击这个按钮，我们可以预览选定的动画。这让我们可以检测到我们之前讨论的动作中的错误，并确保动画就是我们想要的效果。
- en: There are a lot of settings that are available to us when we are working with
    animations in Unity. They let us control the frames from the original animation
    program that we want to import. In addition, they can be used to control how the
    animation interacts with your scripts. No matter what settings you choose, the
    most important thing is the animation clip's name. If this is not set, it can
    be extremely difficult to work with several animations that have the same name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Unity中处理动画时，有许多设置可供我们使用。它们允许我们控制想要导入的原始动画程序中的帧数。此外，它们还可以用来控制动画如何与你的脚本交互。无论你选择什么设置，最重要的是动画剪辑的名称。如果没有设置这个，当你需要处理几个名称相同的动画时，可能会变得极其困难。
- en: The target's animations
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标物的动画
- en: 'So, now that the description is all out of the way, let''s actually make something
    with it. We will start by setting up the animations for the target. Using the
    knowledge that we just gained, we can now set up our target''s animations as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在我们已经了解了所有的描述，让我们实际用它来制作一些东西。我们将从为目标物设置动画开始。利用我们刚刚获得的知识，我们现在可以如下设置我们的目标物的动画：
- en: For starters, if you missed or skipped it earlier, be sure to import the `Target.blend`
    and `Target.png` files to the `Targets` folder. In addition, on the **Rig** page
    of the import settings, ensure that the **Animation Type** attribute is set to
    **Generic** and the **Root Node** attribute is set to **Bone_Arm_Upper**.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a total of six animations. By clicking on the **+** button in the **Clips**
    section, you can add four more animations. If you have added too many, click on
    the **-** button to remove the extra clips.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these clips should have a **Source Take** drop-down list of **Default
    Take** and all of the **Bake into Pose** options should be checked because the
    target will not move from its starting location.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's create our idle animations. Select the first clip and rename it
    as `Idle_Retract`. As this is a mechanical object, we can get away with a really
    short animation; it is so short that we are just going to use the first frame.
    Set the starting frame to `0.9` and the ending frame to `1`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to turn on **Loop Pose** because idle animations are, of course,
    looping.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The extended idle animation is created in almost exactly the same manner. Select
    the second clip and rename it as `Idle_Extend`. The starting frame here is `14`
    and the ending frame is `14.1`. In addition, this animation needs to loop.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next two animations are for a situation when the target extends and retracts.
    They will be called `Extend` and `Retract`, so rename the next two clips. The
    `Extend` animation will start at frame `1` and end at frame `13`. The `Retract`
    animation will start at frame `28` and ends at frame `40`. Neither of these will
    loop.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last two animations also will not loop. They are for when we shoot the targets.
    There is one for being shot in the front and one for being shot from behind. The
    `Hit_Front` animation will be from frame `57` to frame `87`. The `Hit_Back` animation
    will be from frame `98` to frame `128`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all of the changes are made, make sure to click on **Apply** or they will
    not be saved.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set up the animations that will be used by our targets. There are
    six in total. They may not seem like much now, but the next section would not
    be possible without them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: State machines to control animations in Unity
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to control these new animations in Unity, we need to set up
    a state machine. A state machine is just a fancy object that keeps track of what
    an object can do, and how to transition between things. You can think of it in
    terms of a builder from a real-time strategy game. The builder has a walk state
    that is used when moving to the next construction site. When the builder gets
    there, it switches to a build state. If an enemy shows up, the builder will enter
    a runaway state until the enemy is gone. Finally, there is an idle state for when
    the builder does nothing. In Unity, these are called Animator controllers when
    you work with animations and Mecanim.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Target state machine
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of a state machine allows us to focus more on what the target is doing,
    while letting Unity handle the *how it is going to do it* part. Perform these
    steps to create the state machine and control the target:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Creating an **Animator** controller is simple and this is done just as we have
    been doing for our scripts and materials. The option is approximately in the middle
    of the **Create** menu. Create an Animator controller in the `Targets` folder
    and name it `TargetController`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `TargetController` to open a new window (as shown in the following
    screenshot):![Target state machine](img/4691OT_03_14.jpg)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Animator** window is where we edit our state machines. The various parts
    of the **Animator** window are as follows:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the top-left side is a **Layers** button. Clicking on it will display a list
    of all of the blendable layers that make up your animation system. Every state
    machine will have at least the **Base Layer**. Adding more layers would allow
    us to blend state machines. Let's say we have a character that walks around normally
    when he is at full health. When his health drops below half, he starts to limp.
    If the character has only ten percent of his health left, he starts to crawl.
    This would be achieved through the use of layers to prevent the need of creating
    extra animations for each type of movement.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To the right of that is a **Parameters** button that will display the list of
    parameters. Clicking on the **+** button will add a new parameter to the list.
    These parameters can be **Float**, **Int**, **Bool**, and **Trigger**. The transitions
    between the states are most often triggered by changes in these parameters. Any
    scripts working with the state machine can modify these values.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next bit is a breadcrumb trail, like one that you might find on a website.
    It lets us see where we are in the state machine at a glance.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Auto Live Link** button at the top-right corner controls our ability to
    see the state machine's update in real time within the game. This is useful for
    debugging transitions and controls for the character.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the center of the **Animator** window, there are three boxes: **Any State**,
    **Entry**, and **Exit**. (If you can''t see them, click on the middle mouse button
    and drag on the grid to pan the view around.) These boxes are the base controls
    for your animation state machine. The **Any State** box will allow your object
    to transition into specific animations, no matter where in the state machine they
    may be, such as moving to a death animation irrespective of the action the player
    was performing. The **Entry** box is used when you first start your state machine.
    All of the transitions are analyzed and the first suitable and subsequent animation
    becomes the starting location. The **Exit** box is used primarily for substate
    machines and allows you to transition out of the group without a lot of extra
    convoluted connections.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a new state, right-click on the grid that is inside our **Animator**
    window. Hover your mouse over **Create State** and select **Empty**. This creates
    a new empty state for our state machine. Normally, new states are gray, but since
    this is the first state in our machine, it is orange, which is the color of the
    default state.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every state machine will start in its default state. Click on the state to select
    it, and we can take a look at it in the **Inspector** window (as shown in the
    following screenshot).![Target state machine](img/4691OT_03_15.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the following fields in the preceding screenshot:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top, there is a text field for changing the name of the state.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, you can add a **Tag** for organizational purposes.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, there is a **Speed** field. This field controls the playback speed of
    the animation.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Motion** field is where we will add connections to the animation clips
    that we created earlier.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Foot IK** option lets us decide whether we want to let a part of the animation
    to be calculated with **Inverse Kinematics** (**IK**), which is the process of
    calculating how a chain of bones will be laid out based on the position of the
    target bone at the end. We did not set up any IK for these animations, so we do
    not need to worry about this option.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With the **Write Defaults** option, we can control whether animated properties
    remain changed after the animation ends.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option, **Mirror**, is used to flip the left and right axis (or *x*
    axis) of the animation. If you created a right-hand-waving animation, this option
    would let you change it to a left-hand-waving animation.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below that, there is the list of transitions that go from the current state
    to another state. These are transitions that are out of the state and not into
    it. As you will soon see, a transition in this list appears as the name of the
    current state with an arrow to the right, followed by the name of the state it
    is connected to.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkboxes also appear under the **Solo** and **Mute** labels on the right.
    These are for debugging transitions between the states. Any number of transitions
    can be muted at one time, but only one can be soloed at a time. When a transition
    has been muted, it means that the state machine will ignore it when deciding which
    transition to make. Checking the **Solo** box is the same as muting all but one
    of the transitions; this is just a quick way to make it the only active transition.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to need one state for each of our target's animations. So, create
    five more states and rename all six to match the names of the animation clips
    that we created earlier. The default state, the first one you created that will
    appear orange on your screen, should be named `Idle_Retract`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** window, click on the little triangle on the right side of
    the **Target** model (as highlighted in the following screenshot):![Target state
    machine](img/4691OT_03_16.jpg)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This expands the model so that we can see all of the objects that make up that
    model in Unity. The first group consists of the actual objects that make up the
    model. Next are the raw meshes that are used in the model. These are followed
    by the animation clips (they will appear on your screen as a blue box with a big
    play button at the center); these are what we are interested in right now. Last
    is an avatar object; this is what keeps track of the **Rig** setup.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select each state in your **Animator** window and pair it with the correct clip
    by dragging an animation clip from the **Project** window, and dropping it onto
    the **Motion** field in the **Inspector** window.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can create our transitions, we need a few parameters. Open the parameters
    list by clicking on the **Parameters** button in the top-left corner. Then, click
    on the **+** button and select **Float** from the menu that appears. A new parameter
    should now appear in the list.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new field on the left-hand side is the name of the parameter; it can be
    renamed at any time by double-clicking on it. Rename this one to `time`. The field
    on the right is the current value of this parameter. When debugging our state
    machine, we can modify these values here to trigger changes in the state machine.
    Any changes made by the scripts while the game is running will also appear here.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need two more parameters. Create two **Bool** parameters and rename them
    as `wasHit` and `inTheFront`. These will trigger the machine to change to the
    getting hit states, while the time parameter will trigger the machine to utilize
    the `extend` and `retract` states.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a new transition, right-click on a state and select **Make Transition**
    from the menu that pops up. A transition line is now connected from the state
    to your mouse. To complete the transition creation, click on the state that you
    wish to connect to. There will be an arrow on the line, indicating the direction
    of the transition. We need the following transitions:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a transition from `Idle_Retract` to `Extend`.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need a transition from `Extend` to `Idle_Extend`.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Idle_Extend` needs three transitions, one going to `Retract`, the other to
    `Hit_Front`, and the last to `Hit_Back`.'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Retract`, `Hit_Front`, and `Hit_Back` animations need a transition that
    goes to `Idle_Retract`.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the following screenshot as a reference. If you create a transition or state
    that you do not want, select it and hit the *Delete* key on your keyboard to remove
    it.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Target state machine](img/4691OT_03_17.jpg)'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: If you click on one of the transition lines, then we can take a look at its
    settings (as shown in the following screenshot):![Target state machine](img/4691OT_03_18.jpg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the following things in the screenshot:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the **Inspector** window, we have the same indicators of which
    states we are transitioning between that we had in the state—the name of the state
    the transition starts in, followed by an arrow, and finally the name of the state
    the transition ends in.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the familiar **Transitions** list, there is a text field where we
    can give our transitions specific names. This is useful if we have several different
    types of transitions between the same two states.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Has Exit Time** checkbox dictates whether the transition will wait until
    the animation is close to its end before changing to the next animation. This
    is good for things like smoothly transitioning between walk and idle animations.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first value in **Exit Time** under **Settings** sets when the transition
    would start. This is only relevant when the checkbox above it is checked. It should
    have a value from zero to start the animation, and to one to end the animation.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition Duration** setting defines how long the transition will take.
    It again takes a value between zero and one.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transition Offset** setting defines where in the target animation the
    transition will begin.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Interruption Source** and **Ordered Interruption** options determine whether
    another transition can occur while it is in the process of going through this
    one. They also set which set of transitions will have precedence and in which
    order they will be processed.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a timeline block that lets us preview the transition between animations.
    By dragging the little flag left and right, we can watch the transition in the
    **Preview** window. The top half of this block holds waveforms that indicate the
    movement contained in an animation. The bottom half shows the states as boxes
    that overlap where the transition actually occurs. Either one of these boxes can
    be dragged to change the length of the transition.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Since our two idle animations are of negligible length, this normally can't
    easily be seen in our setup. If you create a temporary transition between the
    `extend` and `retract` states, it would be visible.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, we have a **Conditions** list. Using the parameters that we set up,
    we can create any number of conditions here that must be met before this transition
    can take place.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another **Preview** window at the bottom of the **Inspector** panel.
    It functions just like the one for the **Animation Import Settings** page, but
    this one plays the transition between the two relevant animations.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the transition between the `Idle_Retract` state and the `Extend` state.
    We want the targets to randomly pop up. This will be controlled by a script that
    will change the time parameter.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** under the **Conditions** list to add a new condition. Then,
    click on the arrow in the middle of the condition to select **time** from the
    list of parameters.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to turn a **Float** value into a conditional statement, we need to
    compare it with another value. That is why we got a new drop-down button with
    comparison options when we selected the parameter. A **Float** value will be either
    greater than or less than the value on the right. Our time will be counting down,
    so select **Less** from the list and leave the value as zero.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a condition so that the transition between the `Idle_Extend` and `Retract`
    states will be the same.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the transition between the `Idle_Extend` state and the `Hit_Front` state,
    we will use both the **Bool** parameters that were created. Select the transition
    and click on the **+** button under **Conditions** until you have two conditions.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first condition, select **wasHit**, and select **inTheFront** for the
    second condition. A **Bool** parameter is either `true` or `false`. In the case
    of transitions, it needs to know which of the values it is waiting for. For this
    transition, both should be left as **true**.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, set up the conditions for the transition between `Idle_Extend` and `Hit_Back`,
    just as you did for the previous transition. The only difference is that `false`
    needs to be selected from the drop-down list next to the **inTheFront** conditional.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we created a state machine that will be used by our targets. By linking
    each state to an animation and connecting all of them with transitions, the target
    will be able to switch between animations. This transitioning is controlled by
    adding conditionals and parameters.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the target
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We only need one more piece before we can finish putting the target together—a
    script:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Create a new script in our `Scripts` folder and name it `Target`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, in order to interact with our state machine, we need a reference to
    the `Animator` component. It is the component that you removed from the tank and
    the city. The `Animator` component is what ties all of the pieces of the animation
    together:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is followed by two float values that will dictate the range of time, in
    seconds, during which our targets will sit in their idle states:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have three values that will hold the ID numbers of the parameters
    that we need to change. It is technically possible to just use the names of the
    parameters to set them, but using the ID number is much faster:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last two variables will hold the ID numbers of the two idle states. We
    need these for checking which state we are in. All of the IDs are initially set
    to `-1` as a dummy value; we set them to their actual values with the function
    in the next step:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Awake` function is a special function in Unity that is called on every
    script at the beginning of the game. Its purpose is initialization before the
    game gets underway, and it is perfect for initially setting our ID values.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For each ID, we make a call to the `Animator.StringToHash` function. This function
    calculates the ID number of the parameter or state whose name we give it. The
    state names also needs to be prefixed with `Base Layer`. This is because Unity
    wants us to be specific when it is possible to have several different layers with
    states that are named the same. It is also very important that the name here exactly
    matches the name in the **Animator** window. If it does not, IDs will not match,
    errors will occur, and the script will not function correctly.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To make use of all of these IDs, we turn to our very good friend—the `Update`
    function. At the beginning of the function, we use the `GetCurrentAnimatorStateInfo`
    function to figure out which state is the current one. We send a zero to this
    function because it wants to know the index of the layer we are inquiring about,
    of which we only have one. The function returns an object with the information
    about the current state, and we grab the `nameHash` value (also known as the ID
    value) of this state right away and set our variable to it.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The next line of code is a comparison with our idle state IDs to figure out
    whether we are in one of those states. If we are, we call upon the `SubtractTime`
    function (which we will write in a moment) to reduce the time parameter.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the target is not currently in one of its idle states, we start by checking
    to see whether we were hit. If so, the hit is cleared using the `ClearHit` function
    and the time parameter is reset using the `ResetTime` function. We will write
    both these functions in a moment. Finally, we check to see whether our timer has
    dropped below zero. If it has, we again reset the timer.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `SubtractTime` function, we use the `GetFloat` function of our `Animator`
    component to retrieve the value of a float parameter. By sending our `timeId`
    variable to it, we can receive the current value of the time parameter. Like we
    did with the tank, we then use `Time.deltaTime` to keep pace with our frame rate
    and subtract time from the timer. Once this is done, we need to give the state
    machine the new value, which is done with the `SetFloat` function. We tell it
    which parameter to change by giving it an ID value, and we tell it what to change
    by giving it our new time value.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The next function to create is `ClearHit`. This function uses `SetBool` from
    the `Animator` component to set Boolean parameters. It functions just like the
    `SetFloat` function. We just give it an ID and a value. In this case, we set both
    of our Boolean parameters to `false` so that the state machine no longer thinks
    that it has been hit.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last function for the script is `ResetTime`. This is another quick function.
    First, we use the `Random.Range` function to get a random value. By passing it
    a minimum and maximum value, our new random number will be between them. Finally,
    we use the `SetFloat` function to give the state machine the new value.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have created a script to control the state machine of our target. For comparing
    states and setting parameters, we gathered and used IDs. For now, do not worry
    about when the hit states are activated. It will be made clear in the following
    section when we finally make the tank shoot.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Creating the prefab
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the model, animations, state machine, and script, it is time
    to create the target and turn it into a prefab. We have all the pieces, so let''s
    put them all together:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Start by dragging the **Target** model from the **Project** window to the **Hierarchy**
    window. This creates a new instance of the target object.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By selecting the new target object, we can see that it already has an **Animator**
    component attached to it; we just need to add a reference to the `AnimatorController`
    that we created. Do this by dragging `TargetController` from the **Project** window
    and dropping it onto the Animator component's **Controller** field, just like
    all the other object references that we have set up so far.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, we need to add the `Target` script to the object and connect a reference
    to the **Animator** component in its relevant field.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do to the target object is to add a collider to actually receive
    our cannon shots. Unfortunately, since the `Target` object uses bones and a rig
    to animate, it is not as simple as adding a collider directly to the mesh at which
    we will be shooting. Instead, we need to create a new empty `GameObject`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename this to `TargetCollider` and make it a child of the target's `Bone_Target`
    bone.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `MeshCollider` component to the new GameObject.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to provide this component with some mesh data. Find the **Target**
    mesh data in the **Project** window, underneath the **Target** model. Drag it
    to the **Mesh** value of the `MeshCollider` component. This causes a green cylinder
    to appear in the **Scene** view. This is our collision, but it is not yet aligned
    to the target.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Transform** component to set the **GameObject** position to `4` for
    the **X** value and `0` for both **Y** and **Z**. The rotation needs to be changed
    to `0` for **X**, `-90` for **Y**, and `90` for **Z**.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we made the changes, you probably noticed that the font of everything that
    was new or changed became bold. This is to indicate that something is different
    with this prefab instance as compared to the original. Remember, models are essentially
    prefabs; the problem with them is that we cannot directly make changes, such as
    adding scripts. To make this target into a new prefab, simply drag it from the
    **Hierarchy** window and drop it onto the `Prefabs` folder in the **Project**
    window.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this spiffy new prefab is created, populate the city with it.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you placed all of these targets, you probably noticed that they are a little
    large. Instead of editing each target individually or even all of them as a group,
    we only have to make a change to the original prefab. Select the `Target` prefab
    in the **Project** window. The **Inspector** window displays the same information
    for a root prefab object as it does for any other object in the scene. With our
    prefab selected, half the scale and all of the instances already in the scene
    will automatically be updated to match. We can also make changes to the min and
    max idle times and make it affect the whole scene.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just finished creating the targets for our tank. By making use of Unity's
    prefab system, we can also duplicate the target throughout our game and easily
    make changes that affect them all.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted one of the targets to be larger than all of the others, you could
    change it in the scene. Any changes made to a prefab instance are saved, and they
    take precedence over changes made to the root prefab object. In addition, when
    you look at an instance in the **Inspector** window, there will be three new buttons
    at the top of the window. The **Select** button selects the root prefab object
    in the **Project** window. The **Revert** button will remove any unique changes
    made to this instance, whereas the **Apply** button updates the root object with
    all the changes that were made in this instance.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Using all that you have learned about animations and state machines, your challenge
    here is to create a second type of target. Play around with different movements
    and behaviors. You can perhaps create one that transitions from waving around
    to standing still.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing to shooting
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play the game now; it is pretty cool. We have our drivable tank and textured
    city. We even have fancy animated targets. We are just missing one thing: how
    do we shoot? We need to make one more script and we can shoot targets to our heart''s
    content. Follow these steps to create the script and set it up:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add an empty `GameObject` to our tank. Rename it to `MuzzlePoint`
    and make it a child of the cannon's pivot point object. Once this is done, position
    it at the end of the cannon so that the blue arrow points away from the tank,
    along the same direction as the cannon. This will be the point where our bullets
    will come from.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need something to indicate where we are shooting. The explosions are
    covered in future chapters, so choose **Sphere** from the **3D Object** menu underneath
    **GameObject** and rename it to `TargetPoint`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the sphere's scale to `0.2` for each axis and give it a red material. This
    way, it can be more easily seen without being completely obtrusive. It does not
    matter where it starts in our scene, our next script will move it around when
    we shoot.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `SphereCollider` component from `TargetPoint`. The `SphereCollider`
    has to be removed because we don't want to shoot our own target indicator.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a new script and call it `FireControls`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should start to look familiar to you. We start with variables to hold references
    to our muzzle and targeting objects that we just created.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Fire` function starts by defining a variable that will hold the detailed
    information about what was shot:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is followed by an `if` statement that checks the `Physics.Raycast` function.
    The `Raycast` function works just like shooting a gun. We start with a position
    (the muzzle point's position) pointing to a specific direction (forward relative
    to the muzzle point along that blue axis) and get out what was hit. If we hit
    something, the `if` statement evaluates to `true`; otherwise, it is `false` and
    we would skip ahead.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we do hit something, we first move our target point to the point that was
    hit. We then use the `SendMessage` function to tell what we hit that it has been
    hit, the same way we used it in our `RepeatButton` script earlier. We use `hit.transform.root.gameObject`
    to get at the GameObject that was hit. We also provide it with a value, `hit.point`,
    to tell the object where it was hit. The `SendMessageOptions.DontRequireReceiver`
    part of the line keeps the function from throwing an error if it is unable to
    find the desired function. Our targets have the function, but the city walls do
    not and they would throw an error.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last part of our `Fire` function occurs if we didn''t hit anything. We
    send our target point back to the world origin so that the player knows that they
    missed everything:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last thing to add is the `Hit` function at the end of our `Target` script.
    We start the function by getting the current state ID, just as we did earlier
    in the script. However, this time we only check against our extended idle ID.
    If they do not match, we use `return` to exit the function early. We do this because
    we don''t want to let the player shoot any targets that are down or in mid-transition.
    If our state is correct, we continue by telling the animation that we were hit
    by using the `SetBool` function:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The rest of the `Hit` function figures out on which side the target was hit.
    To do this, we first have to convert the point that we received from world space
    into local space. The `InverseTransformPoint` function from our **Transform**
    component does this nicely. We then do a check to see where the shot came from.
    Due to the way that the target is constructed, if the shot was positive on the
    *x* axis, it came from behind. Otherwise, it came from the front. Either way,
    we set the `inTheFront` parameter from our state machine to the proper value.
    Then, we give the player some points by incrementing the static variable that
    we created in our `ScoreCounter` script, way back at the beginning of the chapter:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, we need to add the new `FireControls` script to the tank. You also need
    to connect the references to the `MuzzlePoint` and `TargetPoint` objects.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to create a new button to control and trigger this script.
    So, navigate to **GameObject** | **UI** | **Button** and rename the button to
    `Fire`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to hit the little plus sign in the bottom right of the button's
    **Inspector** window and select `Tank` for the **Object** slot, exactly like we
    did for our Tic-tac-toe game. Then, navigate to **FireControls** | **Fire ()**
    from the function drop down.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created a script that allows us to fire the cannon of our tank. The
    method of using ray tracing is the simplest and most widely used. In general,
    bullets fly too fast for us to see them. Ray tracing is like this, that is, it
    is instantaneous. However, this method does not take gravity, or anything else
    that might change the direction of a bullet, into account.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Now that all of the buttons and components are in place, make them look better.
    Use the skills you gained from the previous chapter to style the GUI and make
    it look great. Perhaps you could even manage to create a directional pad for the
    movement.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And, that is it! The chapter was long and we learned a lot. We imported meshes
    and set up a tank. We created materials so that color could be added to a city.
    We also animated some targets and learned how to shoot them down. It was a lot
    and it is time for a break. Play the game, shoot some targets, and gather those
    points. The project is all done and ready to be built in your device of choice.
    The build process is the same as both the previous projects, so have fun!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about special camera effects and lighting. We will learn
    about lights and their types. Our Tank Battle game will expand through the addition
    of a skybox and several lights. We will also take a look at distance fog. With
    the addition of shadows and lightmaps, the city in which we battle really starts
    to become interesting and dynamic.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
