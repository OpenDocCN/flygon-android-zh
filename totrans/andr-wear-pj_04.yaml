- en: Measure Your Wellness - Sensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量你的健康 - 传感器
- en: We are living in the realm of technology! It is definitely not the highlight
    here. We are also living in the realm of intricate lifestyles that are driving
    everyone's health into some sort of illness. Our existence leads us back to the
    roots of the ocean; we all know that we are beings who have evolved from water.
    If we trace back, we clearly understand that our body composition is made of 60
    percent water and the rest is muscled water. When we talk about taking care of
    our health, we miss simple things, such as drinking sufficient water. Adequate,
    regular water consumption will ensure a great metabolism and healthy, functional
    organs. Then new millennium's advancements in technologies are an expression of
    how one can make use of technology for doing the right things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在科技领域！这绝对不是这里的重点。我们也生活在复杂生活方式的领域，这些生活方式正在将每个人的健康推向某种疾病。我们的存在让我们回到海洋的根源；我们都知道，我们是从水中进化而来的生物。如果我们追溯，我们会清楚地了解我们身体组成60%是水，其余的是肌肉水分。当我们谈论照顾我们的健康时，我们会忽略简单的事情，比如喝足够的水。适量、定期饮水将确保新陈代谢良好和健康、功能正常的器官。然后，新千年的技术进步表达了如何利用技术来做正确的事情。
- en: Android Wear integrates numerous sensors, which can be used to help Android
    Wear users measure their heart rate, step counts, and much more. Having said that,
    how about writing an application that reminds us to drink water every 30 minutes,
    measures our heart rate and step count, and offers a few health tips?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 集成了众多传感器，可用于帮助 Android Wear 用户测量他们的心率、步数等。说到这里，编写一个应用程序如何？该程序可以每30分钟提醒我们喝水，测量我们的心率和步数，并提供一些健康小贴士。
- en: This chapter will enable you to understand how to enlist all the available sensors
    in the Wear device and use them for measuring step counts, heart rate, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你了解如何列出 Wear 设备中所有可用的传感器，并使用它们来测量步数、心率等。
- en: 'In this chapter, we will explore the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Enlisting the available sensors in Wear
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出 Wear 中的可用传感器
- en: The accuracy of the sensors and battery consumption
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器的准确性和电池消耗
- en: Wear 2.0 doze mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wear 2.0 省电模式
- en: Writing the app with initial logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有初始逻辑的应用程序
- en: Getting started on the material design for Wear
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始为 Wear 设计材料设计
- en: Creating a user interface for the app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建用户界面
- en: Conceptualizing the application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念化应用程序
- en: The Wear app, which we will build, will have three main interfaces for starting
    the water reminder, heart rate analysis, and step counter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 Wear 应用程序将有三个主要界面，用于启动饮水提醒、心率分析和步数计数器。
- en: 'The following is the water reminder screen for starting the reminder service.
    Using the navigation facility in the navigation drawer, we can swap between other
    screens:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是启动提醒服务的饮水提醒屏幕。使用导航抽屉中的导航功能，我们可以切换到其他屏幕：
- en: '![](img/00059.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: Enlisting the available sensors in Wear
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出 Wear 中的可用传感器
- en: 'Knowing the list of sensors available in the Wear device you are working on
    is actually good ensuring you do for not have false results and unnecessary waiting.
    Few android Wear devices don''t have the heart rate sensor. Writing an app for
    the heart rate sensor, in such cases, proves nothing. Here''s how we can get the
    list of available sensors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 了解您正在工作的 Wear 设备中可用的传感器列表实际上是有好处的，可以确保您不会得到错误的结果和不必要的等待。一些 Android Wear 设备没有心率传感器。在这种情况下，编写针对心率传感器的应用程序是没有意义的。以下是我们获取可用传感器列表的方法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will see all the available sensors in the Wear device in the console, as
    follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制台中看到 Wear 设备中所有可用的传感器，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Accuracy of sensors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传感器的准确性
- en: All the sensors packed into the Wear devices exhibit the best possible precision
    and accuracy. When we are writing an application for the health field, considering
    the accuracy of the sensor is very important. The sensors used in Wear devices
    are also dependent on manufacturers since Android Wear has produced nearly 40
    and more different brands as per the Google IO 2017\. When we are writing the
    application from the groundup without knowledge of what Wear offers, we surely
    will experience many challenges. Most of the Wear devices have step detector and
    step counter sensors. Perhaps, we need not worry about writing an accelerometer
    program that takes the three-dimensional motion of the device and predicts the
    step, which will be inaccurate. Linear acceleration predicted steps can lead to
    false results most of the time. For saving the battery and making a meaningful
    decision in certain use cases, sensors play a vital role. Motion sensors help
    in saving the Wear device's battery by turning the ambient mode on when the wrist
    is not being looked at. Light sensors will allow devices to increase or decrease
    the screen's brightness according to the external light influence. Heart rate
    sensors are common in Wearable devices. Essentially, a heart rate sensor is an
    optical sensor. It will not be as accurate as an electrocardiogram or electrocardiograph
    (EKG), but these sensors will be close to accurate when you are using them during
    periods of rest. Using the same sensors, sleep monitoring and activity tracking,
    such as calorie burning, can be predicted. These sensors are getting better and
    will be extremely accurate in the future, but, for the quality of the hardware,
    what is packed in Wear will receive software fixes for hardware issues and software
    level controls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集成在可穿戴设备中的传感器都展现出尽可能高的精确度和准确度。在为健康领域编写应用程序时，考虑传感器的准确性非常重要。由于Android Wear根据Google
    IO 2017的数据已经生产了近40个及以上的不同品牌，所以可穿戴设备中使用的传感器也取决于制造商。如果我们从零开始编写应用程序，却不知道可穿戴设备能提供什么功能，我们肯定会遇到很多挑战。大多数可穿戴设备都配备了步数检测器和步数计数传感器。或许，我们不必担心编写一个能预测设备三维动作并据此预测步数的加速度计程序，这种做法通常不准确。线性加速度预测的步数大多数时候会导致错误的结果。为了在某些使用场景中节省电池并做出有意义的决策，传感器发挥着至关重要的作用。运动传感器通过在手腕未被查看时开启环境模式来帮助节省可穿戴设备的电池。光线传感器允许设备根据外部光线影响增加或减少屏幕亮度。心率传感器在可穿戴设备中很常见。本质上，心率传感器是一种光学传感器。它不会像心电图（EKG）那样准确，但当你休息时使用它们，这些传感器的准确度会接近。使用相同的传感器，可以预测睡眠监测和活动跟踪，比如卡路里消耗。这些传感器正在变得更好，未来将极为准确，但为了硬件质量，可穿戴设备中配备的硬件问题将通过软件修复和软件级别的控制来解决。
- en: 'The common Wear integrated sensors are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的可穿戴集成传感器如下：
- en: Accelerometer
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计
- en: Magnetometer
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁力计
- en: Ambient sensor
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境传感器
- en: GPS
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS
- en: Heart rate sensor
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心率传感器
- en: Oxygen saturation sensor
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 氧饱和度传感器
- en: In the future, Wear devices will pack in more sensors with more accuracy and
    they will target the health area through these sensors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，可穿戴设备将配备更多更精确的传感器，并通过这些传感器瞄准健康领域。
- en: Battery consumption
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电池消耗
- en: The battery is vital. The programs we write should target saving the battery.
    The Wear 1.x design guidelines and standards didn't have material design and it
    had a huge impact on battery consumption. After the material design was introduced
    to Wear 2.0, it became clear that a dark theme saves more battery. The Android
    Wear team is continuously working on improving the battery life. Google has introduced
    a set of best practices to improve the battery life of Wear devices. The display
    in Wear devices consumes a lot of battery. There are different types of display
    and they draw different quantities of power when the display is in the on mode,
    in the always on mode, and in the interactive mode. The interactive mode draws
    the maximum power, so we need to be concerned about when to write the interactive
    mode. Of course, battery consumption is necessary for most use cases. When we
    really look into a particular use case, there will be numerous places where we
    can stop the max power being drawn from the Wear battery. We should always double-check
    in the production app that we are releasing all the sensors and other hardware
    that will consumed battery. Android offers the `WAKE_LOCK` mechanism, which enables
    developers to identify which app is using which hardware, and helps to release
    them when the application goes into the background. Writing services are necessary
    for running a long process, but if we utilize background services for hardware
    acquisition, they will always be consuming the battery, and writing a kill service
    in such cases is very important.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 电池至关重要。我们编写的程序应当旨在节省电池。Wear 1.x的设计指南和标准没有采用材质设计，这对电池消耗造成了巨大影响。在Wear 2.0引入材质设计后，深色主题能节省更多电池变得显而易见。Android
    Wear团队一直在努力改善电池续航。谷歌推出了一系列最佳实践来提升Wear设备的电池寿命。Wear设备中的显示屏幕消耗大量电池。不同类型的显示屏在开启模式、常显模式和交互模式下消耗的电量各不相同。交互模式消耗的电量最大，因此我们需要关注何时编写交互模式。当然，对于大多数用例来说，电池消耗是必要的。当我们深入查看某个特定用例时，会发现有许多地方可以避免Wear电池消耗最大电量。我们应该始终在生产应用中仔细检查，确保释放所有会消耗电池的传感器和其他硬件。Android提供了`WAKE_LOCK`机制，使开发者能够识别哪个应用正在使用哪些硬件，并在应用进入后台时帮助释放它们。编写服务对于运行长时间进程是必要的，但如果我们利用后台服务来获取硬件，它们将始终消耗电池，在这种情况下编写终止服务非常重要。
- en: Android Studio offers an open source tool called Battery Historian [https://developer.android.com/studio/profile/battery-historian.html](https://developer.android.com/studio/profile/battery-historian.html)
    for analyzing the battery stats for apps. Battery historian converts battery data
    into HTML visual representations that can be viewed on a browser. Before trying
    to save the battery, we need to know which process draws how much current from
    the battery. Later, using the battery historian data, we will determine which
    process is consuming more data and we will be able to work on battery optimization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio提供了一个名为Battery Historian [https://developer.android.com/studio/profile/battery-historian.html](https://developer.android.com/studio/profile/battery-historian.html)的开源工具，用于分析应用的电池统计信息。Battery
    Historian将电池数据转换为HTML可视化表示，可以在浏览器中查看。在尝试节省电池之前，我们需要知道哪个进程从电池中消耗了多少电流。之后，使用Battery
    Historian的数据，我们将确定哪个进程消耗了更多数据，并能够进行电池优化工作。
- en: Doze mode
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休眠模式
- en: Battery optimization is always a challenging task for developers. Google has
    initiated many in-house projects, such as Project Volta, which insists on an animation
    rate of 60 frames per second. Manufacturers have started a trend of releasing
    phones and tablets packed with the highest battery capacity. The challenge here
    was that there were too many new hardware components introduced and the devices
    were long lasting with a few more hours. Instead of packing an enormous battery,
    Google optimized the battery consumption process from API level 23 to accommodate
    few more hours of usage when the applications are adapted to use the doze mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，电池优化始终是一项挑战。谷歌启动了许多内部项目，例如Project Volta，它坚持每秒60帧的动画速率。制造商开始流行发布配备最高电池容量的手机和平板电脑。这里的挑战在于引入了太多的新硬件组件，设备的使用时间仅延长了几个小时。谷歌没有简单地增大电池容量，而是从API级别23开始优化电池消耗过程，以适应应用适应休眠模式后的额外几小时使用时间。
- en: 'When the device is not being used for a long time or when the device is in
    an idle state for a long time, the device enters into doze mode. When the system
    tries to access network and CPU-intensive services, the doze mode prevents this
    from happening. Doze mode exits automatically after a periodic time, accesses
    the network, and syncs all the jobs and alarms. The following restrictions apply
    to your app when it is in the mode:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备长时间未使用或设备长时间处于空闲状态时，设备将进入休眠模式。当系统尝试访问网络和 CPU 密集型服务时，休眠模式会阻止这种情况发生。休眠模式在周期时间后自动退出，访问网络，并同步所有任务和闹钟。以下限制适用于应用在休眠模式时：
- en: Network operations are killed
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络操作被终止
- en: The system ignores wake locks
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统忽略唤醒锁
- en: Standard alarm managers need to wait for the doze mode to be exited
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的闹钟管理器需要等待退出休眠模式
- en: To fire an alarm when it is in doze mode, it should use `setAndAllowWhileIdle()`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在休眠模式下触发闹钟，应使用 `setAndAllowWhileIdle()`
- en: The device will not perform Wi-Fi scans
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备将不会执行 Wi-Fi 扫描
- en: The sync adapters are restricted
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步适配器受到限制
- en: The job schedulers are restricted
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务调度器受到限制
- en: 'Adapting the doze mode to your applications can affect them differently depending
    on the capabilities they offer. Almost all the apps work normally when they are
    in doze mode. In some use cases, we have to modify the network request jobs, alarm,
    and syncs, and the app should manage all the activities efficiently during the
    doze mode exit. Doze mode is likely to influence the activities that the `AlarmManager`
    alerts for and timers manage, considering that alarms in Android 5.1 (API level
    22) or lower do not fire when the system is in doze mode. To help schedule alarms,
    Android 6.0 (API level 23) introduces two new `AlarmManager` methods: `setAndAllowWhileIdle()`
    and `setExactAndAllowWhileIdle()`. With these methods, we can fire an alarm in
    doze mode.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用提供的能力，调整休眠模式可能会对它们产生不同的影响。几乎所有的应用在休眠模式下都能正常工作。在某些用例中，我们必须修改网络请求任务、闹钟和同步，并且应用应该在退出休眠模式时有效地管理所有活动。考虑到在
    Android 5.1（API 级别 22）或更低版本中，当系统处于休眠模式时，闹钟不会触发，休眠模式可能会影响 `AlarmManager` 提醒的活动和定时器管理。为了帮助安排闹钟，Android
    6.0（API 级别 23）引入了两个新的 `AlarmManager` 方法：`setAndAllowWhileIdle()` 和 `setExactAndAllowWhileIdle()`。使用这些方法，我们可以在休眠模式下触发闹钟。
- en: Creating a project
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个项目
- en: Now, let's fire up the Android Studio and build a Wear app that helps us to
    do all this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动 Android Studio 并构建一个帮助我们完成所有这些操作的 Wear 应用。
- en: 'Create an Android project and call it `Upbeat`. Since it is a health-related
    application, the name upbeat makes a lot of sense:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Upbeat` 的 Android 项目。由于这是一个与健康管理相关的应用，这个名字非常合适：
- en: '![](img/00060.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: 'Choose a Phone and Wear module in the Target Android Devices screen:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“目标 Android 设备”屏幕中选择 Phone 和 Wear 模块：
- en: '![](img/00061.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00061.jpeg)'
- en: Now choose the Empty Activity for the mobile template and the Always On Wear
    Activity for Wear. After your project is successfully created, go to the Wear
    module and add the color scheme file to start driving the development of the material
    design standard.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为手机模板选择 Empty Activity，为 Wear 选择 Always On Wear Activity。在项目成功创建后，进入 Wear
    模块并添加配色方案文件，开始按照材料设计标准推动开发。
- en: 'Create a `colors.xml` file in the `res/values` directory and add the following
    color codes:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/values` 目录中创建一个 `colors.xml` 文件，并添加以下颜色代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For better readability of code for the project, let's create packages called
    `fragments`, `services`, and `utils`. In these three packages, we will create
    all our working code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目代码的可读性更好，让我们创建名为 `fragments`、`services` 和 `utils` 的包。在这三个包中，我们将编写所有的工作代码。
- en: 'In this project, we will use `WearableDrawerLayout` and `WearableNavigationDrawer`
    for navigating between fragments. Let''s set up `MainActivity` in the wear module
    for working with `WearableNavigationDrawer`. In the `activity_main.xml` file,
    we need to change the root element to `WearableDrawerLayout`, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用 `WearableDrawerLayout` 和 `WearableNavigationDrawer` 在片段之间导航。让我们在
    wear 模块中设置 `MainActivity` 以使用 `WearableNavigationDrawer`。在 `activity_main.xml`
    文件中，我们需要将根元素更改为 `WearableDrawerLayout`，如下所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside `nestedScrollview` from the support library, we shall add `framelayout`
    as a container for the fragments to be attached and detached. After that, we can
    attach another child of the `WearableNavigationDrawer` element. In case we are
    looking for the Wear app to have an action menu, which we are, we shall add another
    element called `WearableActionDrawer`. Add the following code within in the `WearableDrawerLayout`
    scope:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持库中的 `nestedScrollview` 内，我们将添加 `framelayout` 作为要附加和分离的片段的容器。之后，我们可以附加 `WearableNavigationDrawer`
    元素的另一个子元素。如果我们希望 Wear 应用拥有一个动作菜单，我们确实需要，那么我们应该添加另一个名为 `WearableActionDrawer` 的元素。在
    `WearableDrawerLayout` 范围内添加以下代码：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding a drawer menu
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个抽屉菜单
- en: 'We are going to add the `drawer_menu` menu XML resource in a moment. All visual
    elements are in place for `MainActivity`. Let''s work on the Java side of the
    story to make the dynamic swipe and fragments switch for the selected navigation
    drawer item. Before we get started on `MainActivity`, we need to create a POJO
    class for the drawer item with a constructor:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即添加 `drawer_menu` 菜单 XML 资源。所有视觉元素都已为 `MainActivity` 做好准备。让我们在 Java 代码方面进行操作，为选定的导航抽屉项实现动态滑动和片段切换。在开始
    `MainActivity` 之前，我们需要创建一个带有构造函数的抽屉项的 POJO 类：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These getters and setters will help in setting the drawer icon and drawer title,
    as we have discussed what a POJO is in a note-taking app earlier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些获取器和设置器将帮助设置抽屉图标和抽屉标题，正如我们之前在笔记应用中讨论 POJO 一样。
- en: 'In `MainActivity.java`, let''s implement `WearableActionDrawer.OnMenuItemClickListener`
    and override `onMenuItemClick`, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainActivity.java` 中，让我们实现 `WearableActionDrawer.OnMenuItemClickListener`
    并重写 `onMenuItemClick`，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s initialize all the instances for `WearableDrawerLayout`, `WearableNavigationDrawer`,
    and `WearableActionDrawer` with the necessary setup inside the scope of `MainActivity`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `MainActivity` 的范围内初始化所有 `WearableDrawerLayout`、`WearableNavigationDrawer`
    和 `WearableActionDrawer` 的实例，并进行必要的设置：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `onCreate` method, let''s map all the visual components through the
    `findViewById()` method. Thereafter, we will use a new class called `ViewTreeObserver`
    for quick peeks and hiding:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中，让我们通过 `findViewById()` 方法映射所有视觉组件。之后，我们将使用一个名为 `ViewTreeObserver`
    的新类来进行快速预览和隐藏：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have seen the array initialization code after the `setAmbientEnabled()`
    method. We need to write the associated method to it. Inside the method, initialize
    a list of `DrawerItem`, loop through the items, and get the title and icon, as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `setAmbientEnabled()` 方法后看到了数组初始化代码。我们需要为它编写关联的方法。在方法内部，初始化 `DrawerItem`
    的列表，遍历这些项，并获取标题和图标，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `FragmentArrayNames` instance, we are searching for a string array,
    which needs to be created. In the `res/values` folder, create the `arrays.xml`
    file and the following set of arrays:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FragmentArrayNames` 实例中，我们需要找到一个字符串数组，这是需要创建的。在 `res/values` 文件夹中，创建 `arrays.xml`
    文件以及以下一系列数组：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For understanding, let's take the water item in the `screens` string array.
    We add a title and exact icon name to the items for the water fragment screen,
    and it is the same for the other array items.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解，我们以 `screens` 字符串数组中的水项为例。我们为水片段屏幕的项添加标题和确切的图标名称，其他数组项也同理。
- en: 'For the `WearableActionDrawer` item, we need to have the actions configured
    before we continue writing the Java logic. We need to add the `menu` XML file
    into the `res/menu` directory. Let''s call the file `drawer_menu.xml`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `WearableActionDrawer` 项，我们需要在继续编写 Java 逻辑之前配置动作。我们需要将 `menu` XML 文件添加到 `res/menu`
    目录中。让我们将文件命名为 `drawer_menu.xml`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have to override `onMenuItemclicklistener` and fireup an action when the
    user clicks on any of the menu items:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写 `onMenuItemclicklistener` 并在用户点击任何菜单项时触发一个动作：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the point when `actionDrawer` popsup from the bottom of the Wear device,
    we will close the navigation `drawerlayout` to have the activity drawer perceivably.
    When a user clicks on the item, we will show the fragment screen name, which we
    made in array XML.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `actionDrawer` 从 Wear 设备底部弹出时，我们将关闭导航 `drawerlayout` 以便活动抽屉可以明显地被感知。当用户点击项时，我们将显示我们之前在数组
    XML 中创建的片段屏幕名称。
- en: Now for the last piece of `MainActivity`. Let's compose the `NavigationDrawer`
    adapter to attach the frame when it is switched.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来处理 `MainActivity` 的最后一步。让我们编写 `NavigationDrawer` 适配器，以便在切换时附加框架。
- en: Creating a navigation drawer adapter
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个导航抽屉适配器
- en: 'Make a class that extends to `WearableNavigationDrawerAdapter` and override
    the following methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个扩展自 `WearableNavigationDrawerAdapter` 的类并重写以下方法：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After this, make a constructor that gets the context as a parameter, and, inside
    the `getCount` method, return the `drawer_item` `ArrayList` with its size.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个以上下文为参数的构造函数，并在`getCount`方法中返回`drawer_item` `ArrayList`及其大小。
- en: 'In the `onItemSelected` method, based on the position parameter, we can switch
    the fragments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onItemSelected`方法中，根据位置参数，我们可以切换碎片：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Regardless, we have to write the fragments. Hang on for some time. In `getItemText`,
    we can restore the name from `draweritem` `ArrayList` as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们必须编写这些碎片。稍等一会儿。在`getItemText`中，我们可以从`draweritem` `ArrayList`恢复名称，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To fetch the drawable icon and set the icon, we are going to use the following
    custom method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取可绘制的图标并设置图标，我们将使用以下自定义方法：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Yes, we have completed the `MainActivity` code. Let''s put all the methods
    together and see the complete `MainActivity` code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们已经完成了`MainActivity`的代码。让我们把所有方法放在一起，看看完整的`MainActivity`代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating fragments
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建碎片（Fragments）
- en: We need to create a fragment called `DrinkWaterFragment`. In this fragment,
    we will handle starting and ending the `WaterDrink` reminder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`DrinkWaterFragment`的碎片。在这个碎片中，我们将处理启动和结束`WaterDrink`提醒。
- en: 'Create a new layout file in the `res/layout` directory, create the `drink_water_fragment.xml`
    file, and add two buttons inside `boxinsetlayout`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res/layout`目录中创建一个新的布局文件，创建`drink_water_fragment.xml`文件，并在`boxinsetlayout`内添加两个按钮，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can use the normal `Button` class as well, but, in this project, we are
    going to use `AppCompatButton` for material design illustrations such as elevation
    and other features. We have to customize the button background selector. Create
    a file inside the `drawable` directory and call it `button_background.xml`. Add
    the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用正常的`Button`类，但在这个项目中，我们将使用`AppCompatButton`来实现材料设计图示，如高度和其他功能。我们必须自定义按钮背景选择器。在`drawable`目录中创建一个文件，并将其命名为`button_background.xml`。添加以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside `DrinkWaterFragment`, instantiate the buttons, and attach a listener
    to both the buttons for starting and stopping the service of, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DrinkWaterFragment`内部，实例化按钮，并为开始和停止服务的按钮附加监听器，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is now time to write a `BroadcastReceiver` class inside the services package
    with the notification configured inside. Let''s call the class `WaterReminderReceiver`
    and extend it to `BroadcastReciever`. Override the `onReceive` method and, whenever
    `AlarmManager` triggers this receiver will receive the data, we will see a notification:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在服务包内编写一个`BroadcastReceiver`类，并在其中配置通知。让我们将这个类命名为`WaterReminderReceiver`并继承自`BroadcastReceiver`。重写`onReceive`方法，每当`AlarmManager`触发这个接收器时，它将接收到数据，我们会看到一个通知：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Register this receiver in the manifest inside the application tag scope:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的清单文件中注册这个接收器，放在application标签的作用域内：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in the `DrinkWaterFragment` in the Start button''s `onClickListener` start
    the `AlarmManager` service and register the broadcast receiver as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`DrinkWaterFragment`中，在开始按钮的`onClickListener`中启动`AlarmManager`服务，并注册广播接收器：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, for debugging purposes, we will be giving a delay of 15 seconds, though
    you can change the delay based on your needs and application use case. We also
    make sure that when a Wear device goes to the doze mode the water reminder still
    firesup the doze-supported method to start the alarm manager.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了调试目的，我们将设置15秒的延迟，尽管你可以根据你的需要和应用场景改变延迟时间。我们还确保当Wear设备进入休眠模式时，饮水提醒仍然可以启动支持休眠模式的方法来启动闹钟管理器。
- en: 'To stop the water reminder service when we click the Stop button, `onClickListener`
    will stop the alarm manager that is running in background and shows a quick toast
    for the `unsubscription` of water reminder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击停止按钮以停止饮水提醒服务时，`onClickListener`将停止在后台运行的闹钟管理器，并为取消饮水提醒显示一个快速吐司提示：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The complete fragment class code is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的碎片类代码如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This fragment is attached to the `MainActivity` `NavigationDrawerAdapter`.
    Ensure you attach this fragment as the default fragment by attaching the fragment
    in the `onCreate` method as the `MainActivity`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个碎片附加在`MainActivity`的`NavigationDrawerAdapter`上。确保你通过在`onCreate`方法中附加碎片，将此碎片作为默认碎片附加到`MainActivity`：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have successfully completed the drink water reminder feature for the app.
    Now, let's build the heartrate detection through the optical heart rate sensors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为应用完成了饮水提醒功能。现在，让我们通过光学心率传感器来构建心率检测功能。
- en: 'Create a fragment inside the fragments package and call that `HeartRateFragment.java`.
    In the `res/layout` directory refactor, create XML, or create a new layout file
    and call that `heart_rate_fragment.xml`, and add the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在fragments包内创建一个片段，并命名为`HeartRateFragment.java`。在`res/layout`目录中重构，创建XML，或者创建一个新的布局文件，并命名为`heart_rate_fragment.xml`，并添加以下代码：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Instead of a static `ImageView`, as shown in the previous code, how about adding
    a dynamic heartbeat for the pulse rate returned by a sensor? We will create a
    custom scale animation based on the open source project at [https://github.com/scottyab/HeartBeatView](https://github.com/scottyab/HeartBeatView).
    Let''s create a class inside the utils package and call that `HeartBeatView.java`,
    which extends to `AppCompatImageView`. Before we get started on working on the
    `CustomView`, we have to set its styleables, as follows, which helps to manage
    the custom values we pass. Create a file in `res/values` and call it `heartbeat_attrs.xml`.
    `Styleable` defines the attributes and properties for the custom view; for instance,
    when the custom view needs a scale factor, we can define it as shown in the following
    code example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面代码中显示的静态`ImageView`相比，如何添加一个由传感器返回的心率动态心跳？我们将基于开源项目[https://github.com/scottyab/HeartBeatView](https://github.com/scottyab/HeartBeatView)创建一个自定义缩放动画。在utils包内创建一个类，命名为`HeartBeatView.java`，它继承自`AppCompatImageView`。在开始处理`CustomView`之前，我们必须设置其styleables，如下所示，这有助于管理我们传递的自定义值。在`res/values`中创建一个文件，命名为`heartbeat_attrs.xml`。`Styleable`为自定义视图定义属性和属性；例如，当自定义视图需要一个缩放因子时，我们可以按以下代码示例进行定义：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the `HeartBeatView` class by extending the `AppCompatImageView` class.
    We need to create constructors that belong to the `AppCompatImageView` class,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承`AppCompatImageView`类来创建`HeartBeatView`类。我们需要创建属于`AppCompatImageView`类的构造函数，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create instances for configuring the scale factor and animation duration.
    Add the following instances to the global scope of the class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在全局范围内为类添加以下实例，以配置缩放因子和动画时长：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need a vector graphic in a heart shape, and that needs to be created in
    the `drawable` folder. Create a file, call it `heart_red_24dp.xml`, and add the
    following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个心形的矢量图形，并且需要在`drawable`文件夹中创建它。创建一个文件，命名为`heart_red_24dp.xml`，并添加以下代码：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To initialize the vector graphic, we will utilize the `drawable` instance and
    access the vector graphic:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化矢量图形，我们将使用`drawable`实例并访问矢量图形：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the `styleable` that we created in the `res/values` directory, we can
    populate the scale factor and animation duration. Using the `TypedArray` class
    instance, we can obtain the attributes, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res/values`目录中创建的`styleable`，我们可以填充缩放因子和动画时长。通过`TypedArray`类的实例，我们可以获取以下属性：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will require three methods, namely `toggle()`, `start()`, and `stop()` to
    initialize the animation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要三个方法，即`toggle()`、`start()`和`stop()`来初始化动画：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, to set the duration based on BPM, we will simply assign bpm to the duration
    using the `Math.round` operation for a 3-digit floating point:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了根据BPM设置时长，我们将简单地使用`Math.round`操作将bpm分配给时长，使其成为一个3位小数：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To check whether the `heartBeat` animation has started and for the duration
    of the animation, we have to write the following two methods:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查`heartBeat`动画是否已开始以及动画的持续时间，我们必须编写以下两个方法：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using this pointer, we will assign the duration and the scale factor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个指针，我们将分配时长和缩放因子：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we will write two animation listener methods for `ScaleUpAnimation`
    and `ScaleDownAnimation`. We will write a method of the type `Animator.AnimatorListener`
    and we will increase the scale in `ScaleUpListener` and decrease it in `ScaleDownListener`
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为`ScaleUpAnimation`和`ScaleDownAnimation`编写两个动画监听器方法。我们将编写一个`Animator.AnimatorListener`类型的方法，并在`ScaleUpListener`中增加缩放，在`ScaleDownListener`中减少缩放，如下所示：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The completed custom view class is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的自定义视图类如下所示：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `heart_rate_fragment.xml`, replace the `imageview` code with the new custom
    view created. Give it a unique ID:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`heart_rate_fragment.xml`中，用新创建的自定义视图替换`imageview`代码。给它一个唯一的ID：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the `HeartRateFragment` class, extend it to the `Fragment` class, and
    implement it to `SensorEventListener`. `SensorEventListener` will monitor all
    the sensor updates and return the changed result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`HeartRateFragment`类，扩展自`Fragment`类，并实现`SensorEventListener`。`SensorEventListener`将监控所有传感器更新并返回更改后的结果：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within in the global scope of the program, instantiate the following necessary
    components:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的全球范围内，实例化以下必要的组件：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `onCreateView` method, map all the visual components added into the
    XML file. It is good practice to initialize the sensors in `onCreateView` for
    facing less number of NPEs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateView`方法中，映射XML文件中添加的所有视觉组件。在`onCreateView`中初始化传感器是很好的做法，这样可以减少NPE的数量：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Accessing the `HeartRate` sensor needs permission in the manifest. In Wear
    2.0, we need to set the runtime permission as well. So, register the body sensor
    permission in the manifest file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`HeartRate`传感器需要在清单中设置权限。在Wear 2.0中，我们还需要设置运行时权限。因此，在清单文件中注册身体传感器权限：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For runtime permission, we need to request the access for `BODY_SENSORS` and
    then override the `onRequestPermissionresul()` method. The following code illustrates
    the runtime permission model:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行时权限，我们需要请求`BODY_SENSORS`的访问权限，然后重写`onRequestPermissionResult()`方法。以下代码说明了运行时权限模型：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, call `requestSensorPermission()` in the `onCreateView()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreateView()`方法中调用`requestSensorPermission()`：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `onSensorChanged()` method, using the `sensorevent` object from the
    argument, we will now get the `HeartRate`. The following code fetches the type
    of sensor and its return values. Later, inside the for loop, we can set the `HeartBeat`
    animation duration and its toggle method to start the animation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onSensorChanged()`方法中，使用参数中的`sensorevent`对象，我们现在将获取`HeartRate`。以下代码获取传感器的类型及其返回值。稍后，在for循环内部，我们可以设置`HeartBeat`动画的持续时间及其切换方法以启动动画：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `onStart` and `onDestroy` methods, register the `HeartRate` sensor and
    unregister the sensor:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onStart`和`onDestroy`方法中，注册`HeartRate`传感器和解注册传感器：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The complete `HeartRateFragment` class code is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`HeartRateFragment`类代码如下：
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, in the `MainActivity` navigation adapter, we can attach `HeartRateFragment`
    for the second index value. In the `onItemSelected` method, add the following
    code change:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`导航适配器中，我们可以为第二个索引值附加`HeartRateFragment`。在`onItemSelected`方法中，添加以下代码更改：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have to build one more screen for the Step counter. Create a new fragment
    in the fragments package. Create another layout xml file and call it `step_counter_fragment.xml`.
    The user interface for this chapter's scope is just two text fields,.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为步数计数器构建一个屏幕。在fragments包中创建一个新的片段。创建另一个布局xml文件，并将其命名为`step_counter_fragment.xml`。本章范围的用户界面仅包含两个文本字段。
- en: 'as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the fragment class created, we have one simple text view to display the `StepCounter`
    data. To keep the step counter sensor running in the background, we need to create
    a service class and attach the sensor data to the service class. Before constructing
    the Fragments, let's take care of the services that the step counter will require.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的片段类中，我们有一个简单的文本视图来显示`StepCounter`数据。为了使步数计数器传感器在后台运行，我们需要创建一个服务类并将传感器数据附加到服务类。在构建片段之前，让我们先处理步数计数器将需要的服务。
- en: 'We will write an observer to receive a specific datatype and, in the UI, we
    will use a Handler thread to receive the data. Let''s create a class called `EventReceiver`,
    which listens to the sensor changes. We are going to use the `BlockingQueue` class
    for java, which waits for the queue to get empty. Using a separate thread, with
    the help of `ThreadPoolExecutor`, we can detect the events. Find the complete
    class, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个观察器来接收特定的数据类型，在UI中，我们将使用Handler线程来接收数据。让我们创建一个名为`EventReceiver`的类，它监听传感器的变化。我们将使用Java的`BlockingQueue`类，该类等待队列清空。借助`ThreadPoolExecutor`，我们可以使用一个单独的线程检测事件。以下是完整的类：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will register the notification from the `Reporter` interface and remove
    it whenever it is not necessary. The reporter interface is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册来自`Reporter`接口的通知，并在不需要时移除它。报告接口如下所示：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We need a `BroadcastReceiver` class to receive the notification from the service:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`BroadcastReceiver`类来接收来自服务的通知：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s get started on writing the service class. Create a class that extends
    to the Service class and implement it to `SensorEventListener` with the following
    instances:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写服务类。创建一个扩展自Service类的类，并实现它以`SensorEventListener`以下实例：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a method for getting the sensor manager:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建获取传感器管理器的方法：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following method gets the Step counter sensor from the Wear device:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法从Wear设备获取步数计数器传感器：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To register the step count sensor, we will use the sensor manager class and,
    using the `registerListener` method, we will register the sensor:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册步数计数传感器，我们将使用传感器管理器类，并使用`registerListener`方法注册传感器：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To set up the `BroadcastReceiver` alarm, we created an `AlarmNotification`
    `BroadcastReceiver` earlier. Using the following method, we can register the class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`BroadcastReceiver`闹钟，我们之前创建了一个`AlarmNotification` `BroadcastReceiver`。使用以下方法，我们可以注册该类：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Whenever a sensor gives a variation in the sensor event data, using the `onSensorChanged`
    method, we can fireup the notification in the background:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当传感器在传感器事件数据中给出变化时，我们可以使用`onSensorChanged`方法在后台触发通知：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For the `UpdateNotification` method, we will use the `NotificationCompat.Builder`
    class to construct the notification:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UpdateNotification`方法，我们将使用`NotificationCompat.Builder`类来构建通知：
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Override the `onStartCommand` method, and initialize the sensor manager and
    step counter sensor, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`onStartCommand`方法，并初始化传感器管理器和步数计数传感器，如下所示：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Whenever there is an accuracy change in the sensor readings, we can fireup
    the notification as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当传感器读数的准确性发生变化时，我们可以按如下方式触发通知：
- en: '[PRE63]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We need to register the service and broadcast receiver in the manifest within
    the application tag:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在应用程序标签中的清单中注册服务和广播接收器：
- en: '[PRE64]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We have to create a simple `StepsTaken` Logic for the service to start fresh
    every day. We will create a serializable class, and, using the Calendar instance
    if the day is over, we will initialise the steps from zero:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为服务创建一个简单的`StepsTaken`逻辑，以便每天重新开始。我们将创建一个可序列化的类，并使用日历实例，如果一天结束，我们将从零开始初始化步数：
- en: '[PRE65]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The complete code for `WearStepService` class is given below.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`WearStepService`类的完整代码。
- en: '[PRE66]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, finally, we shall update the step counter code in the fragment. In the
    `StepCounterFragment`, we need to implement the Reporter interface and create
    the handler instance and the `textview` instance, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们将在片段中更新步数计数器代码。在`StepCounterFragment`中，我们需要实现Reporter接口并创建处理程序实例和`textview`实例，如下所示：
- en: '[PRE67]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, in the `oncreateView` method, register `WearStepService` and connect the
    step counter `textview` to the `xml` tag we created, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`oncreateView`方法中，注册`WearStepService`并将步数计数器`textview`连接到我们创建的`xml`标签，如下所示：
- en: '[PRE68]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we implement the Reporter interface, we need to override a `NotifyEvent`
    method, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现Reporter接口时，需要重写`NotifyEvent`方法，如下所示：
- en: '[PRE69]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the `onResume` and `onPause` methods of the Fragment lifecycle, register
    and remove the event receiver observer for the `StepsTaken` class we wrote earlier:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段生命周期的`onResume`和`onPause`方法中，注册和移除我们之前编写的`StepsTaken`类的事件接收观察者：
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The complete fragment class looks as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的片段类如下所示：
- en: '[PRE71]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We have successfully completed the `Stepcounter` feature. Do not forget to
    attach this fragment in the `MainActivity` navigation adapter with the next index
    value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功完成了`Stepcounter`功能。不要忘记在`MainActivity`导航适配器中用下一个索引值附加此片段：
- en: '[PRE72]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The app will look as follows once you complete all the fragments.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有片段后，应用将如下所示。
- en: 'The following screenshot illustrates the drink water fragment that helps the
    user start the reminder service:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了帮助用户启动提醒服务的饮水片段：
- en: '![](img/00062.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: 'The following screenshot illustrates how the water reminder can be started
    and stop through these buttons:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了如何通过这些按钮启动和停止饮水提醒：
- en: '![](img/00063.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: 'This image illustrates how to read the `HeartRate` sensor as well as the `HeartBeat`
    Animation we created:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像展示了如何读取`HeartRate`传感器以及我们创建的`HeartBeat`动画：
- en: '![](img/00064.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: 'This image illustrates the step counter screen, which shows the step counts:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像展示了显示步数的步数计数器屏幕：
- en: '![](img/00065.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have studied the sensors, battery utilizations, and the
    best practices. We have additionally looked at how the doze mode helps to spare
    the battery and spare the CPU cycles. You have learned how to construct a material
    design Wear application using ideas such as making fragments for Wear devices,
    working with `WearableNavigationLayout`, working with `WearableActionDrawer`,
    working with services and `BroadcastReceivers`, and working with sensors, such
    as the optical `HeartRate` sensor and step counter, the notifications for the
    step counter and drink water services, and runtime permissions for the body sensors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了传感器、电池使用以及最佳实践。此外，我们还了解了休眠模式如何帮助节省电池和CPU周期。你已经学会了如何使用诸如为Wear设备制作片段、使用`WearableNavigationLayout`、使用`WearableActionDrawer`、使用服务和`BroadcastReceivers`以及使用传感器（例如光学`HeartRate`传感器和步数计数器）等想法来构建一个材料设计风格的Wear应用程序，还有步数计数器和饮水服务的通知，以及身体传感器的运行时权限。
- en: In the next chapter, we anticipate making this application more solid by using
    more elements and functionalities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们预计将通过使用更多元素和功能，使这个应用程序更加稳定。
