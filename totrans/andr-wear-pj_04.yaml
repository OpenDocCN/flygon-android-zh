- en: Measure Your Wellness - Sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are living in the realm of technology! It is definitely not the highlight
    here. We are also living in the realm of intricate lifestyles that are driving
    everyone's health into some sort of illness. Our existence leads us back to the
    roots of the ocean; we all know that we are beings who have evolved from water.
    If we trace back, we clearly understand that our body composition is made of 60
    percent water and the rest is muscled water. When we talk about taking care of
    our health, we miss simple things, such as drinking sufficient water. Adequate,
    regular water consumption will ensure a great metabolism and healthy, functional
    organs. Then new millennium's advancements in technologies are an expression of
    how one can make use of technology for doing the right things.
  prefs: []
  type: TYPE_NORMAL
- en: Android Wear integrates numerous sensors, which can be used to help Android
    Wear users measure their heart rate, step counts, and much more. Having said that,
    how about writing an application that reminds us to drink water every 30 minutes,
    measures our heart rate and step count, and offers a few health tips?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will enable you to understand how to enlist all the available sensors
    in the Wear device and use them for measuring step counts, heart rate, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enlisting the available sensors in Wear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accuracy of the sensors and battery consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wear 2.0 doze mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the app with initial logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started on the material design for Wear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user interface for the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conceptualizing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Wear app, which we will build, will have three main interfaces for starting
    the water reminder, heart rate analysis, and step counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the water reminder screen for starting the reminder service.
    Using the navigation facility in the navigation drawer, we can swap between other
    screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enlisting the available sensors in Wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowing the list of sensors available in the Wear device you are working on
    is actually good ensuring you do for not have false results and unnecessary waiting.
    Few android Wear devices don''t have the heart rate sensor. Writing an app for
    the heart rate sensor, in such cases, proves nothing. Here''s how we can get the
    list of available sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see all the available sensors in the Wear device in the console, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Accuracy of sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the sensors packed into the Wear devices exhibit the best possible precision
    and accuracy. When we are writing an application for the health field, considering
    the accuracy of the sensor is very important. The sensors used in Wear devices
    are also dependent on manufacturers since Android Wear has produced nearly 40
    and more different brands as per the Google IO 2017\. When we are writing the
    application from the groundup without knowledge of what Wear offers, we surely
    will experience many challenges. Most of the Wear devices have step detector and
    step counter sensors. Perhaps, we need not worry about writing an accelerometer
    program that takes the three-dimensional motion of the device and predicts the
    step, which will be inaccurate. Linear acceleration predicted steps can lead to
    false results most of the time. For saving the battery and making a meaningful
    decision in certain use cases, sensors play a vital role. Motion sensors help
    in saving the Wear device's battery by turning the ambient mode on when the wrist
    is not being looked at. Light sensors will allow devices to increase or decrease
    the screen's brightness according to the external light influence. Heart rate
    sensors are common in Wearable devices. Essentially, a heart rate sensor is an
    optical sensor. It will not be as accurate as an electrocardiogram or electrocardiograph
    (EKG), but these sensors will be close to accurate when you are using them during
    periods of rest. Using the same sensors, sleep monitoring and activity tracking,
    such as calorie burning, can be predicted. These sensors are getting better and
    will be extremely accurate in the future, but, for the quality of the hardware,
    what is packed in Wear will receive software fixes for hardware issues and software
    level controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common Wear integrated sensors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnetometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heart rate sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oxygen saturation sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the future, Wear devices will pack in more sensors with more accuracy and
    they will target the health area through these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Battery consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The battery is vital. The programs we write should target saving the battery.
    The Wear 1.x design guidelines and standards didn't have material design and it
    had a huge impact on battery consumption. After the material design was introduced
    to Wear 2.0, it became clear that a dark theme saves more battery. The Android
    Wear team is continuously working on improving the battery life. Google has introduced
    a set of best practices to improve the battery life of Wear devices. The display
    in Wear devices consumes a lot of battery. There are different types of display
    and they draw different quantities of power when the display is in the on mode,
    in the always on mode, and in the interactive mode. The interactive mode draws
    the maximum power, so we need to be concerned about when to write the interactive
    mode. Of course, battery consumption is necessary for most use cases. When we
    really look into a particular use case, there will be numerous places where we
    can stop the max power being drawn from the Wear battery. We should always double-check
    in the production app that we are releasing all the sensors and other hardware
    that will consumed battery. Android offers the `WAKE_LOCK` mechanism, which enables
    developers to identify which app is using which hardware, and helps to release
    them when the application goes into the background. Writing services are necessary
    for running a long process, but if we utilize background services for hardware
    acquisition, they will always be consuming the battery, and writing a kill service
    in such cases is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio offers an open source tool called Battery Historian [https://developer.android.com/studio/profile/battery-historian.html](https://developer.android.com/studio/profile/battery-historian.html)
    for analyzing the battery stats for apps. Battery historian converts battery data
    into HTML visual representations that can be viewed on a browser. Before trying
    to save the battery, we need to know which process draws how much current from
    the battery. Later, using the battery historian data, we will determine which
    process is consuming more data and we will be able to work on battery optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Doze mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Battery optimization is always a challenging task for developers. Google has
    initiated many in-house projects, such as Project Volta, which insists on an animation
    rate of 60 frames per second. Manufacturers have started a trend of releasing
    phones and tablets packed with the highest battery capacity. The challenge here
    was that there were too many new hardware components introduced and the devices
    were long lasting with a few more hours. Instead of packing an enormous battery,
    Google optimized the battery consumption process from API level 23 to accommodate
    few more hours of usage when the applications are adapted to use the doze mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the device is not being used for a long time or when the device is in
    an idle state for a long time, the device enters into doze mode. When the system
    tries to access network and CPU-intensive services, the doze mode prevents this
    from happening. Doze mode exits automatically after a periodic time, accesses
    the network, and syncs all the jobs and alarms. The following restrictions apply
    to your app when it is in the mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Network operations are killed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system ignores wake locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard alarm managers need to wait for the doze mode to be exited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fire an alarm when it is in doze mode, it should use `setAndAllowWhileIdle()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The device will not perform Wi-Fi scans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sync adapters are restricted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The job schedulers are restricted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adapting the doze mode to your applications can affect them differently depending
    on the capabilities they offer. Almost all the apps work normally when they are
    in doze mode. In some use cases, we have to modify the network request jobs, alarm,
    and syncs, and the app should manage all the activities efficiently during the
    doze mode exit. Doze mode is likely to influence the activities that the `AlarmManager`
    alerts for and timers manage, considering that alarms in Android 5.1 (API level
    22) or lower do not fire when the system is in doze mode. To help schedule alarms,
    Android 6.0 (API level 23) introduces two new `AlarmManager` methods: `setAndAllowWhileIdle()`
    and `setExactAndAllowWhileIdle()`. With these methods, we can fire an alarm in
    doze mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's fire up the Android Studio and build a Wear app that helps us to
    do all this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an Android project and call it `Upbeat`. Since it is a health-related
    application, the name upbeat makes a lot of sense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose a Phone and Wear module in the Target Android Devices screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now choose the Empty Activity for the mobile template and the Always On Wear
    Activity for Wear. After your project is successfully created, go to the Wear
    module and add the color scheme file to start driving the development of the material
    design standard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `colors.xml` file in the `res/values` directory and add the following
    color codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For better readability of code for the project, let's create packages called
    `fragments`, `services`, and `utils`. In these three packages, we will create
    all our working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will use `WearableDrawerLayout` and `WearableNavigationDrawer`
    for navigating between fragments. Let''s set up `MainActivity` in the wear module
    for working with `WearableNavigationDrawer`. In the `activity_main.xml` file,
    we need to change the root element to `WearableDrawerLayout`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `nestedScrollview` from the support library, we shall add `framelayout`
    as a container for the fragments to be attached and detached. After that, we can
    attach another child of the `WearableNavigationDrawer` element. In case we are
    looking for the Wear app to have an action menu, which we are, we shall add another
    element called `WearableActionDrawer`. Add the following code within in the `WearableDrawerLayout`
    scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding a drawer menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to add the `drawer_menu` menu XML resource in a moment. All visual
    elements are in place for `MainActivity`. Let''s work on the Java side of the
    story to make the dynamic swipe and fragments switch for the selected navigation
    drawer item. Before we get started on `MainActivity`, we need to create a POJO
    class for the drawer item with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These getters and setters will help in setting the drawer icon and drawer title,
    as we have discussed what a POJO is in a note-taking app earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.java`, let''s implement `WearableActionDrawer.OnMenuItemClickListener`
    and override `onMenuItemClick`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize all the instances for `WearableDrawerLayout`, `WearableNavigationDrawer`,
    and `WearableActionDrawer` with the necessary setup inside the scope of `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreate` method, let''s map all the visual components through the
    `findViewById()` method. Thereafter, we will use a new class called `ViewTreeObserver`
    for quick peeks and hiding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen the array initialization code after the `setAmbientEnabled()`
    method. We need to write the associated method to it. Inside the method, initialize
    a list of `DrawerItem`, loop through the items, and get the title and icon, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `FragmentArrayNames` instance, we are searching for a string array,
    which needs to be created. In the `res/values` folder, create the `arrays.xml`
    file and the following set of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For understanding, let's take the water item in the `screens` string array.
    We add a title and exact icon name to the items for the water fragment screen,
    and it is the same for the other array items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `WearableActionDrawer` item, we need to have the actions configured
    before we continue writing the Java logic. We need to add the `menu` XML file
    into the `res/menu` directory. Let''s call the file `drawer_menu.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to override `onMenuItemclicklistener` and fireup an action when the
    user clicks on any of the menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At the point when `actionDrawer` popsup from the bottom of the Wear device,
    we will close the navigation `drawerlayout` to have the activity drawer perceivably.
    When a user clicks on the item, we will show the fragment screen name, which we
    made in array XML.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the last piece of `MainActivity`. Let's compose the `NavigationDrawer`
    adapter to attach the frame when it is switched.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a navigation drawer adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make a class that extends to `WearableNavigationDrawerAdapter` and override
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After this, make a constructor that gets the context as a parameter, and, inside
    the `getCount` method, return the `drawer_item` `ArrayList` with its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onItemSelected` method, based on the position parameter, we can switch
    the fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless, we have to write the fragments. Hang on for some time. In `getItemText`,
    we can restore the name from `draweritem` `ArrayList` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch the drawable icon and set the icon, we are going to use the following
    custom method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, we have completed the `MainActivity` code. Let''s put all the methods
    together and see the complete `MainActivity` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create a fragment called `DrinkWaterFragment`. In this fragment,
    we will handle starting and ending the `WaterDrink` reminder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new layout file in the `res/layout` directory, create the `drink_water_fragment.xml`
    file, and add two buttons inside `boxinsetlayout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the normal `Button` class as well, but, in this project, we are
    going to use `AppCompatButton` for material design illustrations such as elevation
    and other features. We have to customize the button background selector. Create
    a file inside the `drawable` directory and call it `button_background.xml`. Add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `DrinkWaterFragment`, instantiate the buttons, and attach a listener
    to both the buttons for starting and stopping the service of, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now time to write a `BroadcastReceiver` class inside the services package
    with the notification configured inside. Let''s call the class `WaterReminderReceiver`
    and extend it to `BroadcastReciever`. Override the `onReceive` method and, whenever
    `AlarmManager` triggers this receiver will receive the data, we will see a notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Register this receiver in the manifest inside the application tag scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `DrinkWaterFragment` in the Start button''s `onClickListener` start
    the `AlarmManager` service and register the broadcast receiver as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, for debugging purposes, we will be giving a delay of 15 seconds, though
    you can change the delay based on your needs and application use case. We also
    make sure that when a Wear device goes to the doze mode the water reminder still
    firesup the doze-supported method to start the alarm manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the water reminder service when we click the Stop button, `onClickListener`
    will stop the alarm manager that is running in background and shows a quick toast
    for the `unsubscription` of water reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete fragment class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This fragment is attached to the `MainActivity` `NavigationDrawerAdapter`.
    Ensure you attach this fragment as the default fragment by attaching the fragment
    in the `onCreate` method as the `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully completed the drink water reminder feature for the app.
    Now, let's build the heartrate detection through the optical heart rate sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a fragment inside the fragments package and call that `HeartRateFragment.java`.
    In the `res/layout` directory refactor, create XML, or create a new layout file
    and call that `heart_rate_fragment.xml`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of a static `ImageView`, as shown in the previous code, how about adding
    a dynamic heartbeat for the pulse rate returned by a sensor? We will create a
    custom scale animation based on the open source project at [https://github.com/scottyab/HeartBeatView](https://github.com/scottyab/HeartBeatView).
    Let''s create a class inside the utils package and call that `HeartBeatView.java`,
    which extends to `AppCompatImageView`. Before we get started on working on the
    `CustomView`, we have to set its styleables, as follows, which helps to manage
    the custom values we pass. Create a file in `res/values` and call it `heartbeat_attrs.xml`.
    `Styleable` defines the attributes and properties for the custom view; for instance,
    when the custom view needs a scale factor, we can define it as shown in the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `HeartBeatView` class by extending the `AppCompatImageView` class.
    We need to create constructors that belong to the `AppCompatImageView` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create instances for configuring the scale factor and animation duration.
    Add the following instances to the global scope of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a vector graphic in a heart shape, and that needs to be created in
    the `drawable` folder. Create a file, call it `heart_red_24dp.xml`, and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the vector graphic, we will utilize the `drawable` instance and
    access the vector graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `styleable` that we created in the `res/values` directory, we can
    populate the scale factor and animation duration. Using the `TypedArray` class
    instance, we can obtain the attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will require three methods, namely `toggle()`, `start()`, and `stop()` to
    initialize the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to set the duration based on BPM, we will simply assign bpm to the duration
    using the `Math.round` operation for a 3-digit floating point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the `heartBeat` animation has started and for the duration
    of the animation, we have to write the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this pointer, we will assign the duration and the scale factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will write two animation listener methods for `ScaleUpAnimation`
    and `ScaleDownAnimation`. We will write a method of the type `Animator.AnimatorListener`
    and we will increase the scale in `ScaleUpListener` and decrease it in `ScaleDownListener`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The completed custom view class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In `heart_rate_fragment.xml`, replace the `imageview` code with the new custom
    view created. Give it a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `HeartRateFragment` class, extend it to the `Fragment` class, and
    implement it to `SensorEventListener`. `SensorEventListener` will monitor all
    the sensor updates and return the changed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Within in the global scope of the program, instantiate the following necessary
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreateView` method, map all the visual components added into the
    XML file. It is good practice to initialize the sensors in `onCreateView` for
    facing less number of NPEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the `HeartRate` sensor needs permission in the manifest. In Wear
    2.0, we need to set the runtime permission as well. So, register the body sensor
    permission in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For runtime permission, we need to request the access for `BODY_SENSORS` and
    then override the `onRequestPermissionresul()` method. The following code illustrates
    the runtime permission model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call `requestSensorPermission()` in the `onCreateView()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onSensorChanged()` method, using the `sensorevent` object from the
    argument, we will now get the `HeartRate`. The following code fetches the type
    of sensor and its return values. Later, inside the for loop, we can set the `HeartBeat`
    animation duration and its toggle method to start the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onStart` and `onDestroy` methods, register the `HeartRate` sensor and
    unregister the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `HeartRateFragment` class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `MainActivity` navigation adapter, we can attach `HeartRateFragment`
    for the second index value. In the `onItemSelected` method, add the following
    code change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have to build one more screen for the Step counter. Create a new fragment
    in the fragments package. Create another layout xml file and call it `step_counter_fragment.xml`.
    The user interface for this chapter's scope is just two text fields,.
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the fragment class created, we have one simple text view to display the `StepCounter`
    data. To keep the step counter sensor running in the background, we need to create
    a service class and attach the sensor data to the service class. Before constructing
    the Fragments, let's take care of the services that the step counter will require.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write an observer to receive a specific datatype and, in the UI, we
    will use a Handler thread to receive the data. Let''s create a class called `EventReceiver`,
    which listens to the sensor changes. We are going to use the `BlockingQueue` class
    for java, which waits for the queue to get empty. Using a separate thread, with
    the help of `ThreadPoolExecutor`, we can detect the events. Find the complete
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will register the notification from the `Reporter` interface and remove
    it whenever it is not necessary. The reporter interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a `BroadcastReceiver` class to receive the notification from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started on writing the service class. Create a class that extends
    to the Service class and implement it to `SensorEventListener` with the following
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a method for getting the sensor manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method gets the Step counter sensor from the Wear device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the step count sensor, we will use the sensor manager class and,
    using the `registerListener` method, we will register the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up the `BroadcastReceiver` alarm, we created an `AlarmNotification`
    `BroadcastReceiver` earlier. Using the following method, we can register the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a sensor gives a variation in the sensor event data, using the `onSensorChanged`
    method, we can fireup the notification in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `UpdateNotification` method, we will use the `NotificationCompat.Builder`
    class to construct the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onStartCommand` method, and initialize the sensor manager and
    step counter sensor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever there is an accuracy change in the sensor readings, we can fireup
    the notification as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to register the service and broadcast receiver in the manifest within
    the application tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to create a simple `StepsTaken` Logic for the service to start fresh
    every day. We will create a serializable class, and, using the Calendar instance
    if the day is over, we will initialise the steps from zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for `WearStepService` class is given below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, finally, we shall update the step counter code in the fragment. In the
    `StepCounterFragment`, we need to implement the Reporter interface and create
    the handler instance and the `textview` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `oncreateView` method, register `WearStepService` and connect the
    step counter `textview` to the `xml` tag we created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we implement the Reporter interface, we need to override a `NotifyEvent`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onResume` and `onPause` methods of the Fragment lifecycle, register
    and remove the event receiver observer for the `StepsTaken` class we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete fragment class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully completed the `Stepcounter` feature. Do not forget to
    attach this fragment in the `MainActivity` navigation adapter with the next index
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The app will look as follows once you complete all the fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the drink water fragment that helps the
    user start the reminder service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot illustrates how the water reminder can be started
    and stop through these buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This image illustrates how to read the `HeartRate` sensor as well as the `HeartBeat`
    Animation we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This image illustrates the step counter screen, which shows the step counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have studied the sensors, battery utilizations, and the
    best practices. We have additionally looked at how the doze mode helps to spare
    the battery and spare the CPU cycles. You have learned how to construct a material
    design Wear application using ideas such as making fragments for Wear devices,
    working with `WearableNavigationLayout`, working with `WearableActionDrawer`,
    working with services and `BroadcastReceivers`, and working with sensors, such
    as the optical `HeartRate` sensor and step counter, the notifications for the
    step counter and drink water services, and runtime permissions for the body sensors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we anticipate making this application more solid by using
    more elements and functionalities.
  prefs: []
  type: TYPE_NORMAL
