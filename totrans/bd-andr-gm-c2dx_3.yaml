- en: Chapter 3. Understanding Game Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover how to add physics to our games by using the
    built-in engine provided by Cocos2d-x based on the popular Chipmunk framework.
    We are going to explain the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling gravity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling physics properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the Chipmunk physics engine, you may visit [https://chipmunk-physics.net](https://chipmunk-physics.net).
  prefs: []
  type: TYPE_NORMAL
- en: Physics engines encapsulate all the complexity related to giving our scene realistic
    motions, such as adding gravity to an object so it is attracted to the bottom
    of the screen, or detecting collision between bodies and so on.
  prefs: []
  type: TYPE_NORMAL
- en: While working with physics, we should keep in mind that we are dealing with
    a physics world in our scene, and that all the physics elements participating
    in the world are known as physics bodies. These bodies have properties such as
    mass, position, and rotation. These may be changed to customize the bodies. One
    physics body may be attached to another by a joint definition.
  prefs: []
  type: TYPE_NORMAL
- en: Take in to consideration that, from a physics perspective, the physics body
    is not aware of the sprites and other objects outside of the physics world, but
    we will see in this chapter how to link the sprites to the physics bodies.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common characteristics of video games is collision detection;
    we often need to know when the objects collide with each other. This can be easily
    done by defining the shapes that would represent the collision area on each body,
    and then specifying a collision listener, as we will show later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will be covering the Box2D physics engine, which is a completely
    separate physics engine and has nothing to do with Chipmunk. Box2D is written
    in C++, and Chipmunk is written in C.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enable physics in our game, we need to add the following lines
    to our `HelloWorldScene.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we have created an instance variable for the `_sprBomb` variable, so that
    it can be accessed from within all the instance methods. In this particular case,
    we would like to have access to the bomb instance in the `onCollision` method
    that will be called each time the collisions between the physics bodies are detected,
    so that we can make the bomb disappear by simply setting its visible attribute
    to false.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us move to our `HelloWorld.cpp` implementation file, and make a few
    changes in order to set up our physics world.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us modify our `createScene` method, so that it will now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous versions of the Cocos2d-x branch 3, you needed to specify the
    physics world that the current scene layer would use. But, it is not necessary
    in version 3.4 and the `setPhysicsWorld` method has been removed from the `Layer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Here we can see that we are now creating the scene instance using the `createWithPhysics`
    static method contained in the `Scene` class, rather than using the simple create
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The second step that we are going to perform here is to set the gravity to (0,0),
    so that the physics world's gravity will not attract our sprites to the bottom
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will enable the physic''s engine debug draw, which will allow us to
    see all the physics bodies. This option will help us during the development phase,
    we will use the COCOS2D_DEBUG macro so that it only displays the debug draw when
    running in the debug mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the red circles that surround the bomb
    and the player sprite. This represents the physics body attached to each player
    sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the physics world](img/B04193_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let us implement our `setPhysicsBody` method, which receives, as a parameter,
    a sprite object pointer referring to the sprite to which I will add a physics
    body. This method will create a circle that will represent the physics body, and
    therefore, the collision area. The circle will be created with a radius that is
    half of the width of the sprite, so that it covers as much of the sprite's area
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Circles are commonly used for detecting the collisions since they require less
    CPU effort for detecting the collisions in each frame; nevertheless, their precision
    can be unacceptable in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us add the physics bodies to our player and to our bomb sprite, within
    our `init` method. In order to do this, we will call our instance method setPhysicsBody
    after the initialization of each of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let us implement our `onCollision` instance method. This is going to
    be called each time a collision between two physics bodies is detected. As we
    can see in the following code, when the bomb physics body collides with our player,
    it makes the bomb invisible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a good place for putting some logs during the development process in
    order to find out when the collisions are being detected. In Cocos2d-x 3.4 you
    can print the log messages using the `CCLOG` macro. This could be turned on by
    defining the macro `COCOS2D_DEBUG` as follows: `#define COCOS2D_DEBUG 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this method returns a Boolean value. It indicates whether these
    two bodies can collide again. In this particular case, we will return false, indicating
    that as soon as these two physics bodies collide they should not continue to collide.
    If we return the true indication, then these two objects will continue to collide,
    and this will cause our player sprite to move, thus giving our game an undesired
    visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us enable our game to detect when our bomb collides with our player.
    In order to do this we will create an `EventListenerPhysicsContact` instance,
    we are going to set it so that when two physics bodies start colliding, it should
    call our `onCollision` instance method. Then, we will add our event listener to
    the event dispatcher. We are going to create these three simple steps inside our
    `initPhysics` instance method. So, our code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `init` method code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Handling gravity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have successfully used the built-in physics engine to detect the
    collision, let us play a little bit with gravity. Go to the `createScene` method
    and modify the parameters that we have sent to the constructor. In our game, we
    have used the `(0,0)` value, since we did not want our world to have any gravity
    force that moves our bodies on either the *x* or the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Now, give it a try, change the values to positive or negative. When we use a
    negative value on the *x* axis, it will attract the body toward the left, and
    when we use the negative value on the *y* axis, it will attract the body toward
    the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing these values and understanding the physics added to our game might
    give you some ideas for your next games.
  prefs: []
  type: TYPE_NORMAL
- en: Handling physics properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created our scene, which corresponds to the physics world,
    we now have the ability to change the physics properties, such as the velocity,
    linear damping, force, impulse, and torque for each body.
  prefs: []
  type: TYPE_NORMAL
- en: Applying velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we managed to move our bomb from the top of the screen
    to the bottom using a `MoveTo` action. Now that we are using the built-in physics
    engine, we can achieve the same effect just by setting a velocity to the bomb.
    This can be done by simply calling the `setVelocity` method of the bomb sprite's
    physics body. Velocity is a vector quantity; therefore, the method mentioned receives
    a `Vect` instance as the parameter. The value of *x* will represent its horizontal
    component; on this axis a positive value means that the body will move to the
    right and a negative value means that the body will move to the left. The *y*
    value affects the vertical movement. Positive values move the body toward the
    top of the screen and negative values move the body to the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added the following line to the `init` method of the `HelloWorld.cpp`
    implementation file just before the return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember to remove the line of code that requests the bomb sprite to execute
    the `MoveTo` action so that you can confirm that the bomb is now moving because
    of its velocity parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us go to the `onCollision` method, there we are going to set the bomb's
    velocity to zero when it collides with our player sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the `Vec2` class, the null constructor will initialize all the vector
    values to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Linear damping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can decrease the velocity of our physics body to create a friction effect.
    One way to achieve this is by calling the `linearDamping` method and specifying
    the rate of change of the body's velocity. The value should be a float between
    `0.0` and `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the linear damping by setting the value of the bomb's physics body
    to `0.1f`, and observe how the velocity of the bomb is decreased.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember to document or remove this line after testing the linear damping so
    that the game does not behave in an unexpected way.
  prefs: []
  type: TYPE_NORMAL
- en: Applying force
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can apply an immediate force to a body by simply calling the `applyForce`
    method of the physics body to which we want to apply it. Analogous to the methods
    explained in the previous sections, it receives a vector as a parameter, which
    means that the force has vertical and horizontal components.
  prefs: []
  type: TYPE_NORMAL
- en: We can test this method by applying a force to the bomb that will make it move
    to the right as soon as it collides with our player sprite in our `onCollision`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Applying impulse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section we have added an immediate force to our physics body,
    now we can add a continuous force by applying an impulse to it by calling the
    `applyImpulse` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code, after applying the immediate force to the physics
    body in the `onCollision` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the game now, and you will see how the bomb moves to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying impulse](img/B04193_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remove the lines of code that add force and impulse to our bomb within the `onCollision`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Applying torque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let us make our bomb rotate after it collides with our player sprite.
    We can do that by applying a torque force to the bomb's physics body by using
    the `applyTorque` method, which receives a float number; if positive, it will
    make the physics body rotate counter-clockwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add an arbitrary positive torque to the `onCollision` method just before
    the return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now add a negative value to the `applyTorque` method, and you will see how the
    physics body rotates clockwise.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all of the modifications, our `onCollision` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `init` method now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how our game looks after the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting everything together](img/B04193_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Box2D physics engine**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used the built-in physics engine provided by the framework,
    which is based on the chipmunk C physics library; nevertheless, Cocos2d-x also
    provides the integration in its API with the Box2D physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a Box2D world, we instantiate the `b2World` class and then
    we pass to its constructor a `b2Vec` object that represents the world's gravity.
    The world instance has an instance method for creating `b2Bodies`. The sprite
    class has a method named `setB2Body`, which allows us to associate a Box2D physics
    body to any given sprite. This is smoother than how it was in the branch 2 of
    the framework; more code was required to tie a `b2Body` with a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Box2D integration is easy to use, I strongly recommend using the
    built-in physics engine as the Box2D integration is no longer under active development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have added physics to our game by creating a physics world and physics bodies
    that represent the bomb and our player sprite, and we have used the collision
    detection mechanism provided by the built-in physics engine in a very few steps.
    We have also showed how to change the gravity parameters so that the physic bodies
    move according to the force of gravity. We have easily changed the physics properties
    of the bodies, such as velocity, friction, force, impulse, and torque with a single
    line of code for each of those. So far, our player ignores our user events. In
    the next chapter, we will cover how to add user interaction to our game.
  prefs: []
  type: TYPE_NORMAL
