["```java\nclass clSceneNode: public iIntrusiveCounter\n{\nprotected:\n  mat4 m_LocalTransform;\n  mat4 m_GlobalTransform;\n  std::vector< clPtr<clSceneNode> > m_ChildNodes;\n```", "```java\npublic:\n  clSceneNode():\n  m_LocalTransform( mat4::Identity() ),\n  m_GlobalTransform( mat4::Identity() ) {}\n```", "```java\n  void SetLocalTransform( const mat4& Mtx )\n  { m_LocalTransform = Mtx; }\n  const mat4& GetLocalTransformConst() const\n  { return m_LocalTransform; }\n  mat4& GetLocalTransform()\n  { return m_LocalTransform; };\n```", "```java\n  virtual void Add( const clPtr<clSceneNode>& Node )\n  {\n    m_ChildNodes.push_back( Node );\n  }\n```", "```java\n  void RecalculateLocalFromGlobal()\n  {\n    mat4 ParentInv = m_GlobalTransform.GetInversed();\n    for ( auto& i : m_ChildNodes )\n    {\n```", "```java\n    i->SetLocalTransform( ParentInv * i->GetGlobalTransform() );\n```", "```java\n    i->RecalculateLocalFromGlobal();\n  }\n}\n```", "```java\nvirtual void AcceptTraverser(iSceneTraverser* Traverser) = 0;\n```", "```java\nclass iSceneTraverser: public iIntrusiveCounter\n{\npublic:\n  virtual void Traverse( clPtr<clSceneNode> Node );\n  virtual void Reset() = 0;\n```", "```java\n  friend class clSceneNode;\n  friend class clMaterialNode;\n  friend class clGeometryNode;\nprotected:\n  virtual void PreAcceptSceneNode( clSceneNode* Node ) {};\n  virtual void PostAcceptSceneNode( clSceneNode* Node ) {};\n  virtual void PreAcceptMaterialNode( clMaterialNode* Node ) {};\n  virtual void PostAcceptMaterialNode( clMaterialNode* Node ){};\n  virtual void PreAcceptGeometryNode( clGeometryNode* Node ) {};\n  virtual void PostAcceptGeometryNode( clGeometryNode* Node ){};\n};\n```", "```java\nvoid iSceneTraverser::Traverse( clPtr<clSceneNode> Node )\n{\n  if ( !Node ) return;\n  Reset();\n  Node->AcceptTraverser( this );\n}\n```", "```java\nstruct sMaterial\n{\npublic:\n  sMaterial()\n  : m_Ambient( 0.2f )\n  , m_Diffuse( 0.8f )\n  , m_MaterialClass()\n  {}\n  vec4 m_Ambient;\n  vec4 m_Diffuse;\n```", "```java\n  std::string m_MaterialClass;\n};\n```", "```java\nclass clMaterialNode: public clSceneNode\n{\npublic:\n  clMaterialNode() {};\n  sMaterial& GetMaterial() { return m_Material; }\n  const sMaterial& GetMaterial() const { return m_Material; }\n  void SetMaterial( const sMaterial& Mtl ) { m_Material = Mtl; }\n  virtual void AcceptTraverser(iSceneTraverser* Traverser) override;\nprivate:\n  sMaterial m_Material;\n};\n```", "```java\nvoid clMaterialNode::AcceptTraverser( iSceneTraverser* Traverser )\n{\n  Traverser->PreAcceptSceneNode( this );\n  Traverser->PreAcceptMaterialNode( this );\n  AcceptChildren( Traverser );\n  Traverser->PostAcceptMaterialNode( this );\n  Traverser->PostAcceptSceneNode( this );\n}\n```", "```java\nclass clGeometryNode: public clSceneNode\n{\npublic:\n  clGeometryNode() {};\n  clPtr<clVertexAttribs> GetVertexAttribs() const\n  { return m_VertexAttribs; }\n  void SetVertexAttribs( const clPtr<clVertexAttribs>& VA )\n  { m_VertexAttribs = VA; }\n```", "```java\n  clPtr<clGLVertexArray> GetVA() const\n  {\n    if ( !m_VA )\n    {\n      m_VA = make_intrusive<clGLVertexArray>();\n      m_VA->SetVertexAttribs( m_VertexAttribs );\n    }\n    return m_VA;\n  }\n  virtual void AcceptTraverser(iSceneTraverser* Traverser) override;\nprivate:\n  clPtr<clVertexAttribs> m_VertexAttribs;\n  mutable clPtr<clGLVertexArray> m_VA;\n};\n```", "```java\nclass clTransformUpdateTraverser: public iSceneTraverser\n{\nprivate:\n  std::vector<mat4> m_ModelView;\n```", "```java\npublic:\n  clTransformUpdateTraverser(): m_ModelView() {}\n  virtual void Reset() override\n  {\n    m_ModelView.clear();\n    m_ModelView.push_back( mat4::Identity() );\n  }\n```", "```java\nprotected:\n  virtual void PreAcceptSceneNode( clSceneNode* Node ) override\n  {\n    m_ModelView.push_back( Node->GetLocalTransform() * m_ModelView.back() );\n    Node->SetGlobalTransform( m_ModelView.back() );\n  }\n```", "```java\n  virtual void PostAcceptSceneNode( clSceneNode* Node ) override\n  {\n    m_ModelView.pop_back();\n  }\n};\n```", "```java\nclTransformUpdateTraverser g_TransformUpdateTraverser;\nclPtr<clSceneNode> g_Scene;\ng_TransformUpdateTraverser.Traverse( g_Scene );\n```", "```java\nstruct sMatrices\n{\n```", "```java\n  mat4 m_ProjectionMatrix;\n  mat4 m_ViewMatrix;\n  mat4 m_ModelMatrix;\n```", "```java\n  mat4 m_ModelViewMatrix;\n  mat4 m_ModelViewMatrixInverse;\n  mat4 m_ModelViewProjectionMatrix;\n  mat4 m_NormalMatrix;\n  void UpdateMatrices()\n  {\n    m_ModelViewMatrix = m_ModelMatrix * m_ViewMatrix;\n    m_ModelViewMatrixInverse = m_ModelViewMatrix.GetInversed();\n    m_ModelViewProjectionMatrix = m_ModelViewMatrix * m_ProjectionMatrix;\n    m_NormalMatrix = mat4( m_ModelViewMatrixInverse.ToMatrix3().GetTransposed() );\n  }\n};\n```", "```java\nclass clRenderOp\n{\npublic:\n  clRenderOp( const clPtr<clGeometryNode>& G, const clPtr<clMaterialNode>& M):\n    m_Geometry(G), m_Material(M) {}\n  void Render( sMatrices& Matrices ) const;\n  clPtr<clGeometryNode> m_Geometry;\n  clPtr<clMaterialNode> m_Material;\n};\n```", "```java\nstatic const char g_vShaderStr[] = R\"(\n  uniform mat4 in_ModelViewProjectionMatrix;\n  uniform mat4 in_NormalMatrix;\n  uniform mat4 in_ModelMatrix;\n  in vec4 in_Vertex;\n  in vec2 in_TexCoord;\n  in vec3 in_Normal;\n  out vec2 v_Coords;\n  out vec3 v_Normal;\n  out vec3 v_WorldNormal;\n  void main()\n  {\n    v_Coords = in_TexCoord.xy;\n    v_Normal = mat3(in_NormalMatrix) * in_Normal;\n    v_WorldNormal = ( in_ModelMatrix * vec4( in_Normal, 0.0 ) ).xyz;\n    gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Normal;\n  in vec3 v_WorldNormal;\n  out vec4 out_FragColor;\n  uniform vec4 u_AmbientColor;\n  uniform vec4 u_DiffuseColor;\n  void main()\n  {\n    vec4 Ka = u_AmbientColor;\n    vec4 Kd = u_DiffuseColor;\n```", "```java\n    vec3 L = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    float d = clamp( dot( L, normalize(v_WorldNormal) ), 0.0, 1.0 );\n    vec4 Color = Ka + Kd * d;\n    out_FragColor = Color;\n  }\n)\";\n```", "```java\nclPtr<clGLSLShaderProgram> g_ShaderProgram;\n```", "```java\nvoid clRenderOp::Render( sMatrices& Matrices ) const\n{\n  if ( !g_ShaderProgram )\n  {\n    g_ShaderProgram = make_intrusive<clGLSLShaderProgram>( g_vShaderStr, g_fShaderStr );\n  }\n  Matrices.m_ModelMatrix = this->m_Geometry->GetGlobalTransformConst();\n  Matrices.UpdateMatrices();\n```", "```java\n  g_ShaderProgram->Bind();\n  g_ShaderProgram->SetUniformNameVec4Array( \"u_AmbientColor\", 1, this->m_Material->GetMaterial().m_Ambient );\n  g_ShaderProgram->SetUniformNameVec4Array( \"u_DiffuseColor\", 1, this->m_Material->GetMaterial().m_Diffuse );\n  g_ShaderProgram->SetUniformNameMat4Array( in_ProjectionMatrix\", 1, Matrices.m_ProjectionMatrix );\n  g_ShaderProgram->SetUniformNameMat4Array( \"in_ViewMatrix\", 1, Matrices.m_ViewMatrix );\n  g_ShaderProgram->SetUniformNameMat4Array( \"in_ModelMatrix\", 1, Matrices.m_ModelMatrix );\n  g_ShaderProgram->SetUniformNameMat4Array( \"in_NormalMatrix\", 1, Matrices.m_NormalMatrix );\n  g_ShaderProgram->SetUniformNameMat4Array( \"in_ModelViewMatrix\", 1, Matrices.m_ModelViewMatrix );\n  g_ShaderProgram->SetUniformNameMat4Array( \"in_ModelViewProjectionMatrix\", 1, Matrices.m_ModelViewProjectionMatrix );\n  this->m_Geometry->GetVA()->Draw( false );\n}\n```", "```java\nclass clROPsTraverser: public iSceneTraverser\n{\nprivate:\n  std::vector<clRenderOp> m_RenderQueue;\n  std::vector<clMaterialNode*> m_Materials;\npublic:\n  clROPsTraverser()\n  : m_RenderQueue()\n  , m_Materials() {}\n```", "```java\n  virtual void Reset() override\n  {\n    m_RenderQueue.clear();\n    m_Materials.clear();\n  }\n```", "```java\n  virtual const std::vector<clRenderOp>& GetRenderQueue() const\n  {\n    return m_RenderQueue;\n  }\n```", "```java\nprotected:\n  virtual void PreAcceptSceneNode( clSceneNode* Node ) override\n  {\n  }\n  virtual void PostAcceptSceneNode( clSceneNode* Node ) override\n  {\n  }\n```", "```java\n  virtual void PreAcceptGeometryNode( clGeometryNode* Node ) override\n  {\n    if ( !m_Materials.size() ) return;\n    m_RenderQueue.emplace_back( Node, m_Materials.front() );\n  }\n  virtual void PostAcceptGeometryNode( clGeometryNode* Node ) override\n  {\n  }\n```", "```java\n  virtual void PreAcceptMaterialNode( clMaterialNode* Node ) override\n  {\n    m_Materials.push_back( Node );\n  }\n  virtual void PostAcceptMaterialNode( clMaterialNode* Node ) override\n  {\n    m_Materials.pop_back();\n  }\n};\n```", "```java\ng_Scene = make_intrusive<clSceneNode>();\n```", "```java\nauto MaterialNode = make_intrusive<clMaterialNode>();\nsMaterial Material;\nMaterial.m_Ambient = vec4( 0.1f, 0.0f, 0.0f, 1.0f );\nMaterial.m_Diffuse = vec4( 0.9f, 0.0f, 0.0f, 1.0f );\nMaterialNode->SetMaterial( Material );\n```", "```java\nauto VA = clGeomServ::CreateAxisAlignedBox( vec3(-1), vec3(+1) );\ng_Box= make_intrusive<clGeometryNode>();\ng_Box->SetVertexAttribs( VA );\nMaterialNode->Add( g_Box );\n```", "```java\ng_Scene->Add( MaterialNode );\n```", "```java\nvoid OnDrawFrame()\n{\n  static float Angle = 0.0f;\n```", "```java\n  g_Box->SetLocalTransform( mat4::GetRotateMatrixAxis( Angle, vec3( 1, 1, 1 ) ) );\n  Angle += 0.01f;\n```", "```java\n  g_TransformUpdateTraverser.Traverse( g_Scene );\n  g_ROPsTraverser.Traverse( g_Scene );\n  const auto& RenderQueue = g_ROPsTraverser.GetRenderQueue();\n```", "```java\n  sMatrices Matrices;\n  Matrices.m_ProjectionMatrix = Math::Perspective( 45.0f, g_Window->GetAspect(), 0.4f, 2000.0f );\n  Matrices.m_ViewMatrix = g_Camera.GetViewMatrix();\n```", "```java\n  LGL3->glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n  LGL3->glEnable( GL_DEPTH_TEST );\n```", "```java\n  for ( const auto& ROP : RenderQueue )\n  {\n    ROP.Render( Matrices );\n  }\n}\n```", "```java\nclass clGLFrameBuffer: public iIntrusiveCounter\n{\npublic:\n  clGLFrameBuffer():\n  FFrameBuffer(0),\n  FColorBuffer(),\n  FDepthBuffer(),\n  FColorBuffersParams(),\n  FHasDepthBuffer( false )\n  {}\n  virtual ~clGLFrameBuffer();\n```", "```java\n  virtual void InitRenderTargetV( const ivec4& WidthHeightBitsPerChannel, const bool HasDepthBuffer );\n```", "```java\n  virtual ivec4 GetParameters() const\n  {\n    return FColorBuffersParams;\n  }\n```", "```java\n  virtual clPtr<clGLTexture> GetColorTexture() const\n  {\n    return FColorBuffer;\n  }\n  virtual clPtr<clGLTexture> GetDepthTexture() const\n  {\n    return FDepthBuffer;\n  }\n```", "```java\n  virtual void Bind( int TargetIndex ) const;\n  virtual void UnBind() const;\n```", "```java\nprotected:\n  void CheckFrameBuffer() const;\n```", "```java\nprivate:\n  GLuint FFrameBuffer;\n  clPtr<clGLTexture> FColorBuffer;\n  clPtr<clGLTexture> FDepthBuffer;\n  ivec4 FColorBuffersParams;\n  bool FHasDepthBuffer;\n};\n```", "```java\nvoid clGLFrameBuffer::InitRenderTargetV( const ivec4& WidthHeightBitsPerChannel, const bool HasDepthBuffer )\n{\n```", "```java\n  FColorBuffersParams = WidthHeightBitsPerChannel;\n  FHasDepthBuffer = HasDepthBuffer;\n```", "```java\n  LGL3->glGenFramebuffers( 1, &FFrameBuffer );\n```", "```java\n  Bind( 0 );\n```", "```java\n  FColorBuffer = make_intrusive<clGLTexture>();\n  int Width = FColorBuffersParams[0];\n  int Height = FColorBuffersParams[1];\n```", "```java\n  #if defined( OS_ANDROID )\n    const Lenum InternalFormat = GL_RGBA;\n    auto DepthFormat = GL_DEPTH_COMPONENT;\n  #else\n    const Lenum InternalFormat = GL_RGBA8;\n    auto DepthFormat = GL_DEPTH_COMPONENT24;\n  #endif\n```", "```java\n  FColorBuffer->SetFormat( GL_TEXTURE_2D, InternalFormat, GL_RGBA, Width, Height );\n```", "```java\n  FColorBuffer->AttachToCurrentFB( GL_COLOR_ATTACHMENT0 );\n```", "```java\n  if ( HasDepthBuffer )\n  {\n    FDepthBuffer = make_intrusive<clGLTexture>();\n```", "```java\n    int Width = FColorBuffersParams[0];\n    int Height = FColorBuffersParams[1];\n```", "```java\n    FDepthBuffer->SetFormat( GL_TEXTURE_2D, DepthFormat, GL_DEPTH_COMPONENT, Width, Height );\n    FDepthBuffer->AttachToCurrentFB( GL_DEPTH_ATTACHMENT );\n  }\n```", "```java\n  CheckFrameBuffer();\n  UnBind();\n}\n```", "```java\nvoid clGLFrameBuffer::CheckFrameBuffer() const\n{\n  Bind( 0 );\n  GLenum FBStatus = LGL3->glCheckFramebufferStatus( GL_FRAMEBUFFER );\n```", "```java\n  switch ( FBStatus )\n  {\n    case GL_FRAMEBUFFER_COMPLETE: // Everything's OK\n      break;\n    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      LOGI( \"GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT\" );\n      break;\n    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      LOGI(\"GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\" );\n      break;\n```", "```java\n    #if !defined(OS_ANDROID)\n      case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:\n        LOGI( \"GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER\" );\n        break;\n      case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:\n        LOGI( \"GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER\" );\n        break;\n    #endif\n      case GL_FRAMEBUFFER_UNSUPPORTED:\n        LOGI( \"GL_FRAMEBUFFER_UNSUPPORTED\" );\n        break;\n      default:\n        LOGI( \"Unknown framebuffer error: %x\", FBStatus );\n  }\n```", "```java\n  UnBind();\n}\n```", "```java\nclass clLightNode: public clSceneNode\n{\npublic:\n  clLightNode() {}\n  clPtr<iLight> GetLight() const\n  {\n    return m_Light;\n  }\n  void SetLight( const clPtr<iLight>& L )\n  {\n    m_Light = L;\n  }\n  virtual void AcceptTraverser( iSceneTraverser* Traverser )\n    override;\n  clPtr<iLight> m_Light;\n};\n```", "```java\nvoid clLightNode::AcceptTraverser( iSceneTraverser* Traverser )\n{\n  Traverser->PreAcceptSceneNode( this );\n  Traverser->PreAcceptLightNode( this );\n  AcceptChildren( Traverser );\n  Traverser->PostAcceptLightNode( this );\n  Traverser->PostAcceptSceneNode( this );\n}\n```", "```java\nprotected:\nfriend class clLightNode;\nvirtual void PreAcceptLightNode( clLightNode* Node ) {}\nvirtual void PostAcceptLightNode( clLightNode* Node ) {}\n```", "```java\nclass iLight: public iIntrusiveCounter\n{\npublic:\n  iLight():\n  m_Ambient(0.2f),\n  m_Diffuse(0.8f),\n  m_Position(0),\n  m_Direction(0.0f, 0.0f, 1.0f),\n```", "```java\n  m_SpotOuterAngle(45.0f)\n  {}\n```", "```java\n  void UpdateROPUniforms( const std::vector<clRenderOp>& ROPs, const clPtr<clMaterialSystem>& MatSys, const clPtr<clLightNode>& LightNode ) const;\n```", "```java\n  mat4 GetViewForShadowMap() const\n  {\n    return Math::LookAt( m_Position, m_Position + m_Direction, vec3( 0, 0, 1 ) );\n  }\n  mat4 GetProjectionForShadowMap() const\n  {\n    float NearCP = 0.1f;\n    float FarCP = 1000.0f;\n    return Math::Perspective( 2.0f * this->m_SpotOuterAngle, 1.0f, NearCP, FarCP );\n  }\n```", "```java\n  clPtr<clGLFrameBuffer> iLight::GetShadowMap() const\n  {\n    if ( !m_ShadowMap )\n    {\n      m_ShadowMap = make_intrusive<clGLFrameBuffer>();\n      m_ShadowMap->InitRenderTargetV(\n        { ivec4(1024, 1024, 8, 0) },\n        true\n      );\n    }\n    return m_ShadowMap;\n  }\n```", "```java\npublic:\n  vec4 m_Ambient;\n  vec4 m_Diffuse;\n  vec3 m_Position;\n  vec3 m_Direction;\n  float m_SpotOuterAngle;\n```", "```java\n  mutable clPtr<clGLFrameBuffer> m_ShadowMap;\n};\n```", "```java\nvoid iLight::UpdateROPUniforms( const std::vector<clRenderOp>& ROPs, const clPtr<clMaterialSystem>& MatSys, const clPtr<clLightNode>& LightNode ) const\n{\n  mat4 LightMV = this->GetViewForShadowMap();\n  mat4 LightProj = GetProjectionForShadowMap();\n  mat4 Mtx = LightNode->GetGlobalTransformConst();\n  vec3 Pos = ( Mtx * vec4( this->m_Position, 1.0f ) ).XYZ();\n  vec3 Dir = ( Mtx * vec4( this->m_Direction, 0.0f ) ).XYZ();\n  auto AmbientSP = MatSys->GetShaderProgramForPass( ePass_Ambient );\n  AmbientSP->Bind();\n  AmbientSP->SetUniformNameVec3Array( \"u_LightPos\", 1, Pos );\n  AmbientSP->SetUniformNameVec3Array( \"u_LightDir\", 1, Dir );\n  auto LightSP = MatSys->GetShaderProgramForPass( ePass_Light );\n  LightSP->Bind();\n  LightSP->SetUniformNameVec3Array( \"u_LightPos\", 1, Pos );\n  LightSP->SetUniformNameVec3Array( \"u_LightDir\", 1, Dir );\n  LightSP->SetUniformNameVec4Array( \"u_LightDiffuse\", 1, this->m_Diffuse );\n  mat4 ScaleBias = GetProjScaleBiasMat();\n  mat4 ShadowMatrix = ( Mtx * LightMV * LightProj ) * ScaleBias;\n  LightSP->SetUniformNameMat4Array( \"in_ShadowMatrix\", 1, ShadowMatrix );\n  this->GetShadowMap()->GetDepthTexture()->Bind( 0 );\n}\n```", "```java\nmat4 GetProjScaleBiasMat()\n{\n  return mat4( 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0 );\n}\n```", "```java\nenum ePass\n{\n  ePass_Ambient,\n  ePass_Light,\n  ePass_Shadow\n};\n```", "```java\nclass clMaterialSystem: public iIntrusiveCounter\n{\npublic:\n  clMaterialSystem();\n```", "```java\n  clPtr<clGLSLShaderProgram> GetShaderProgramForPass(ePass P)\n  {\n    return m_ShaderPrograms[ P ];\n  }\nprivate:\n  std::map<ePass, clPtr<clGLSLShaderProgram>> m_ShaderPrograms;\n};\n```", "```java\nclMaterialSystem::clMaterialSystem()\n{\n  m_ShaderPrograms[ ePass_Ambient ] = make_intrusive<clGLSLShaderProgram>( g_vShaderStr, g_fShaderAmbientStr );\n  m_ShaderPrograms[ ePass_Light   ] = make_intrusive<clGLSLShaderProgram>( g_vShaderStr, g_fShaderLightStr );\n  m_ShaderPrograms[ ePass_Shadow  ] = make_intrusive<clGLSLShaderProgram>( g_vShaderShadowStr, g_fShaderShadowStr );\n}\n```", "```java\nstatic const char g_vShaderStr[] = R\"(\n  uniform mat4 in_ModelViewProjectionMatrix;\n  uniform mat4 in_NormalMatrix;\n  uniform mat4 in_ModelMatrix;\n  uniform mat4 in_ShadowMatrix;\n  in vec4 in_Vertex;\n  in vec2 in_TexCoord;\n  in vec3 in_Normal;\n  out vec2 v_Coords;\n  out vec3 v_Normal;\n  out vec3 v_WorldNormal;\n  out vec4 v_ProjectedVertex;\n  out vec4 v_ShadowMapCoord;\n```", "```java\n  mat4 GetProjScaleBiasMat()\n  {\n    return mat4( \n      0.5, 0.0, 0.0, 0.0, \n      0.0, 0.5, 0.0, 0.0, \n      0.0, 0.0, 0.5, 0.0, \n      0.5, 0.5, 0.5, 1.0 );\n  }\n```", "```java\n  void main()\n  {\n    v_Coords = in_TexCoord.xy;\n    v_Normal = mat3(in_NormalMatrix) * in_Normal;\n    v_WorldNormal = ( in_ModelMatrix * vec4( in_Normal, 0.0 ) ).xyz;\n    v_ProjectedVertex = GetProjScaleBiasMat() * in_ModelViewProjectionMatrix * in_Vertex;\n    v_ShadowMapCoord = in_ShadowMatrix * in_ModelMatrix * in_Vertex;\n    gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderAmbientStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Normal;\n  in vec3 v_WorldNormal;\n  out vec4 out_FragColor;\n  uniform vec4 u_AmbientColor;\n  uniform vec4 u_DiffuseColor;\n  void main()\n  {\n    out_FragColor = u_AmbientColor;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderLightStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Normal;\n  in vec3 v_WorldNormal;\n  in vec4 v_ProjectedVertex;\n  in vec4 v_ShadowMapCoord;\n  out vec4 out_FragColor;\n  uniform vec4 u_AmbientColor;\n  uniform vec4 u_DiffuseColor;\n  uniform vec3 u_LightPos;\n  uniform vec3 u_LightDir;\n  uniform vec4 u_LightDiffuse;\n  uniform sampler2D Texture0;\n```", "```java\n  float PCF5x5( const vec2 ShadowCoord, float Depth )\n  {\n    float Size = 1.0 / float( textureSize( Texture0, 0 ).x );\n    float Shadow =( Depth >= texture( Texture0, ShadowCoord ).r ) ? 1.0 : 0.0;\n    for ( int v=-2; v<=2; v++ ) for ( int u=-2; u<=2; u++ )\n    {\n       Shadow += ( Depth >= texture( Texture0, ShadowCoord + Size * vec2(u, v) ).r ) ? 1.0 : 0.0;\n    }\n    return Shadow / 26.0;\n  }\n```", "```java\n  float ComputeSpotLightShadow()\n  {\n```", "```java\n    vec4 ShadowCoords4 = v_ShadowMapCoord / v_ShadowMapCoord.w;\n    if ( ShadowCoords4.w > 0.0 )\n    {\n      vec2 ShadowCoord = vec2( ShadowCoords4 );\n      float DepthBias = -0.0002;\n      float ShadowSample = 1.0 - PCF5x5( ShadowCoord, ShadowCoords4.z + DepthBias );\n```", "```java\n      float ShadowCoef = 0.3;\n      return ShadowSample * ShadowCoef;\n    }\n    return 1.0;\n  }\n```", "```java\n  void main()\n  {\n    vec4 Kd = u_DiffuseColor * u_LightDiffuse;\n    vec3 L = normalize( u_LightDir );\n    vec3 N = normalize( v_WorldNormal );\n    float d = clamp( dot( -L, N ), 0.0, 1.0 );\n    vec4 Color = Kd * d * ComputeSpotLightShadow();\n    Color.w = 1.0;\n    out_FragColor = Color;\n  }\n)\";\n```", "```java\nstatic const char g_vShaderShadowStr[] = R\"(\n  uniform mat4 in_ModelViewProjectionMatrix;\n  in vec4 in_Vertex;\n  void main()\n  {\n    gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n  }\n)\";\nstatic const char g_fShaderShadowStr[] = R\"(\n  out vec4 out_FragColor;\n  void main()\n  {\n    out_FragColor = vec4( 1, 1, 1, 1 );\n  }\n)\";\n```", "```java\nvoid RenderROPs( sMatrices& Matrices, const std::vector<clRenderOp>& RenderQueue, ePass Pass )\n{\n  for ( const auto& ROP : RenderQueue )\n  {\n    ROP.Render( Matrices, g_MatSys, Pass );\n  }\n}\n```", "```java\nm_TransformUpdateTraverser.Traverse( Root );\nm_ROPsTraverser.Traverse( Root );\nconst auto& RenderQueue = m_ROPsTraverser.GetRenderQueue();\nauto RenderQueue_Opaque = Select( RenderQueue, []( const clRenderOp& ROP )\n    {\n      return ROP.m_Material->GetMaterial().m_MaterialClass != \"Particle\";\n    } );\n    auto RenderQueue_Transparent = Select( RenderQueue, []( const clRenderOp& ROP )\n    {\n      return ROP.m_Material->GetMaterial().m_MaterialClass == \"Particle\";\n    } \n  );\n```", "```java\n  sMatrices Matrices;\n  Matrices.m_ProjectionMatrix = Proj;\n  Matrices.m_ViewMatrix = View;\n  Matrices.UpdateMatrices();\n  LGL3->glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );\n  LGL3->glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n  LGL3->glEnable( GL_DEPTH_TEST );\n```", "```java\n  LGL3->glDepthFunc( GL_LEQUAL );\n  LGL3->glDisablei( GL_BLEND, 0 );\n  RenderROPs( Matrices, RenderQueue_Opaque, ePass_Ambient, MatSys );\n```", "```java\n  auto Lights = g_ROPsTraverser.GetLights();\n  UpdateShadowMaps( Lights, RenderQueue );\n```", "```java\n  void UpdateShadowMaps( const std::vector<clLightNode*>& Lights, const std::vector<clRenderOp>& ROPs )\n  {\n    LGL3->glDisable( GL_BLEND );\n    for ( size_t i = 0; i != Lights.size(); i++ )\n    {\n      sMatrices ShadowMatrices;\n      clPtr<iLight> L = Lights[ i ]->GetLight();\n      clPtr<clGLFrameBuffer> ShadowBuffer = L->GetShadowMap();\n```", "```java\n      ShadowBuffer->Bind( 0 );\n      LGL3->glClearColor( 0, 0, 0, 1 );\n      LGL3->glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n```", "```java\n      LMatrix4 Proj = L->GetProjectionForShadowMap();\n      LMatrix4 MV = L->GetViewForShadowMap();\n```", "```java\n      ShadowMatrices.m_ViewMatrix = MV;\n      ShadowMatrices.m_ProjectionMatrix = Proj;\n      ShadowMatrices.UpdateMatrices();\n      L->UpdateROPUniforms( ROPs, g_MatSys, Lights[i] );\n```", "```java\n      RenderROPs( ShadowMatrices, ROPs, ePass_Shadow );\n      ShadowBuffer->UnBind();\n    }\n  }\n```", "```java\n  LGL3->glDepthFunc( GL_EQUAL );\n  LGL3->glBlendFunc( GL_ONE, GL_ONE );\n  LGL3->glEnablei( GL_BLEND, 0 );\n  for ( const auto& L : Lights )\n  {\n    L->GetLight()->UpdateROPUniforms( RenderQueue, MatSys, L );\n    RenderROPs( Matrices, RenderQueue, ePass_Light, MatSys );\n  }\n```", "```java\n  LGL3->glBlendFunc(GL_SRC_ALPHA, GL_ONE);\n  LGL3->glDepthFunc(GL_LESS);\n  LGL3->glEnablei(GL_BLEND, 0);\n  LGL3->glDepthMask( GL_FALSE );\n  RenderROPs( Matrices, RenderQueue_Transparent, ePass_Ambient, MatSys );\n```", "```java\n  LGL3->glDepthMask( GL_TRUE );\n```", "```java\n  g_MatSys = make_intrusive<clMaterialSystem>();\n  g_Scene = make_intrusive<clSceneNode>();\n  g_Canvas = make_intrusive<clGLCanvas>( g_Window );\n```", "```java\n  auto CubeMaterialNode = make_intrusive<clMaterialNode>();\n  {\n    sMaterial Material;\n    Material.m_Ambient = vec4( 0.2f, 0.0f, 0.0f, 1.0f );\n    Material.m_Diffuse = vec4( 0.8f, 0.0f, 0.0f, 1.0f );\n    CubeMaterialNode->SetMaterial( Material );\n  }\n  auto PlaneMaterialNode = make_intrusive<clMaterialNode>();\n  {\n    sMaterial Material;\n    Material.m_Ambient = vec4( 0.0f, 0.2f, 0.0f, 1.0f );\n    Material.m_Diffuse = vec4( 0.0f, 0.8f, 0.0f, 1.0f );\n    PlaneMaterialNode->SetMaterial( Material );\n  }\n  auto DeimosMaterialNode = make_intrusive<clMaterialNode>();\n  {\n    sMaterial Material;\n    Material.m_Ambient = vec4( 0.0f, 0.0f, 0.2f, 1.0f );\n    Material.m_Diffuse = vec4( 0.0f, 0.0f, 0.8f, 1.0f );\n    DeimosMaterialNode->SetMaterial( Material );\n  }\n```", "```java\n  {\n    auto VA = clGeomServ::CreateAxisAlignedBox( vec3(-0.5), vec3(+0.5) );\n    g_Box= make_intrusive<clGeometryNode>();\n    g_Box->SetVertexAttribs( VA );\n    CubeMaterialNode->Add( g_Box );\n```", "```java\n    auto DeimosNode = LoadOBJSceneNode( g_FS->CreateReader( \"deimos.obj\" ) );\n    DeimosNode->SetLocalTransform( mat4::GetScaleMatrix(vec3(0.01f, 0.01f, 0.01f)) * mat4::GetTranslateMatrix(vec3(1.1f, 1.1f, 0.0f)) );\n    DeimosMaterialNode->Add( DeimosNode );\n  }\n  {\n    auto VA = clGeomServ::CreateAxisAlignedBox( vec3(-2.0f, -2.0f, -1.0f), vec3(2.0f, 2.0f, -0.95f) );\n    auto Geometry = make_intrusive<clGeometryNode>();\n    Geometry->SetVertexAttribs( VA );\n    PlaneMaterialNode->Add( Geometry );\n  }\n```", "```java\n  {\n    auto Light = make_intrusive<iLight>( );\n    Light->m_Diffuse = vec4( 0.5f, 0.5f, 0.5f, 1.0f );\n    Light->m_Position = vec3( 5, 5, 5 );\n    Light->m_Direction = vec3( -1, -1, -1 ).GetNormalized();\n    Light->m_SpotOuterAngle = 21;\n    g_LightNode = make_intrusive<clLightNode>( );\n    g_LightNode->SetLight( Light );\n    g_Scene->Add( g_LightNode );\n  }\n  {\n    auto Light = make_intrusive<iLight>();\n    Light->m_Diffuse = vec4( 0.5f, 0.5f, 0.5f, 1.0f );\n    Light->m_Position = vec3( 5, -5, 5 );\n    Light->m_Direction = vec3( -1, 1, -1 ).GetNormalized();\n    Light->m_SpotOuterAngle = 20;\n    auto LightNode = make_intrusive<clLightNode>();\n    LightNode->SetLight( Light );\n    g_Scene->Add( LightNode );\n  }\n```", "```java\n  g_Scene->Add( CubeMaterialNode );\n  g_Scene->Add( PlaneMaterialNode );\n  g_Scene->Add( DeimosMaterialNode );\n  while( g_Window && g_Window->HandleInput() )\n  {\n    OnDrawFrame();\n    g_Window->Swap();\n  }\n```", "```java\nclass clVirtualTrackball\n{\npublic:\n  clVirtualTrackball():\n  FCurrentPoint( 0.0f ),\n  FPrevPoint( 0.0f ),\n  FStarted( false )\n  {\n    FRotation.IdentityMatrix();\n    FRotationDelta.IdentityMatrix();\n  };\n```", "```java\n  virtual LMatrix4 DragTo( LVector2 ScreenPoint, float Speed, bool KeyPressed )\n  {\n    if ( KeyPressed && !FStarted )\n    {\n      StartDragging( ScreenPoint );\n      FStarted = KeyPressed;\n      return mat4::Identity();\n    }\n    FStarted = KeyPressed;\n```", "```java\n    if ( !KeyPressed ) return mat4::Identity();\n```", "```java\n    FCurrentPoint = ProjectOnSphere( ScreenPoint );\n    LVector3 Direction = FCurrentPoint - FPrevPoint;\n    LMatrix4 RotMatrix;\n    RotMatrix.IdentityMatrix();\n    float Shift = Direction.Length();\n```", "```java\n    if ( Shift > Math::EPSILON )\n    {\n      LVector3 Axis = FPrevPoint.Cross( FCurrentPoint );\n      RotMatrix.RotateMatrixAxis( Shift * Speed, Axis );\n    }\n    FRotationDelta = RotMatrix;\n    return RotMatrix;\n  }\n  LMatrix4& GetRotationDelta()\n  {\n    return FRotationDelta;\n  };\n```", "```java\n  virtual LMatrix4 GetRotationMatrix() const\n  {\n    return FRotation * FRotationDelta;\n  }\n  static clVirtualTrackball* Create()\n  {\n    return new clVirtualTrackball();\n  }\n```", "```java\nprivate:\n  virtual void StartDragging( LVector2 ScreenPoint )\n  {\n    FRotation = FRotation * FRotationDelta;\n    FCurrentPoint = ProjectOnSphere( ScreenPoint );\n    FPrevPoint = FCurrentPoint;\n    FRotationDelta.IdentityMatrix();\n  }\n```", "```java\n  LVector3 ProjectOnSphere( LVector2 ScreenPoint )\n  {\n    LVector3 Proj;\n```", "```java\n    Proj.x = 2.0f * ScreenPoint.x - 1.0f;\n    Proj.y = -( 2.0f * ScreenPoint.y - 1.0f );\n    Proj.z = 0.0f;\n    float Length = Proj.Length();\n    Length = ( Length < 1.0f ) ? Length : 1.0f;\n    Proj.z = sqrtf( 1.001f - Length * Length );\n    Proj.Normalize();\n    return Proj;\n  }\n  LVector3 FCurrentPoint;\n  LVector3 FPrevPoint;\n  LMatrix4 FRotation;\n  LMatrix4 FRotationDelta;\n  bool FStarted;\n};\n```", "```java\nvoid UpdateTrackball( float Speed )\n{\n  g_Trackball.DragTo( g_MouseState.FPos, Speed, g_MouseState.FPressed );\n}\nvoid OnDrawFrame()\n{\n  UpdateTrackball( 10.0f );\n  mat4 TrackballMtx = g_Trackball.GetRotationMatrix();\n  Matrices.m_ViewMatrix = TrackballMtx * g_Camera.GetViewMatrix();\n}\n```"]