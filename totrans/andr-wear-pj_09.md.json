["```java\n//Install Firebase CLI \n$ npm install -g firebase-tools\n\n```", "```java\nsudo su\nnpm install -g firebase-tools\n\n```", "```java\n//CLI authentication\n$ firebase login\n\n```", "```java\n//Initialise Firebase functions\n$ firebase init functions\n\n```", "```java\n//import firebase functions modules\nconst functions = require('firebase-functions');\n//import admin module\n        const admin = require('firebase-admin');\n        admin.initializeApp(functions.config().firebase);\n\n// Listens for new messages added to messages/:pushId\n        exports.pushNotification = functions.database\n        .ref('/messages/ashok_geetha/{pushId}').onWrite( event => {\n\n        console.log('Push notification event triggered');\n\n        //  Grab the current value of what was written to the Realtime \n        Database.\n        var valueObject = event.data.val();\n\n        if(valueObject.photoUrl != null) {\n        valueObject.photoUrl= \"Sent you a lot of love!\";\n        }\n\n        // Create a notification\n        const payload = {\n        notification: {\n        title:valueObject.message,\n        body: valueObject.user || valueObject.photoUrl,\n        sound: \"default\"\n        },\n        };\n\n        //Create an options object that contains the time to live for \n        the notification and the priority\n        const options = {\n        priority: \"high\",\n        timeToLive: 60 * 60 * 24\n        };\n\n        return admin.messaging().sendToTopic(\"pushNotifications\", \n        payload, options);\n        });\n\n```", "```java\n//Add the dependency\ndependencies {\n     compile 'com.google.firebase:firebase-messaging:10.2.4'\n}\n\n```", "```java\npublic class MessagingService extends FirebaseMessagingService {\n\n    //Override methods\n}\n\n```", "```java\n@Override\npublic void onMessageReceived(RemoteMessage remoteMessage) {\n    super.onMessageReceived(remoteMessage);\n}\n\n```", "```java\nString notificationTitle = null, notificationBody = null;\n// Check if message contains a notification payload.\nif (remoteMessage.getNotification() != null) {\n    Log.d(TAG, \"Message Notification Body: \" + remoteMessage.getNotification().getBody());\n    notificationTitle = remoteMessage.getNotification().getTitle();\n    notificationBody = remoteMessage.getNotification().getBody();\n}\n\n```", "```java\nprivate void sendNotification(String notificationTitle, String notificationBody) {\n    Intent intent = new Intent(this, MainActivity.class);\n    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, \n    intent,\n            PendingIntent.FLAG_ONE_SHOT);\n\n    Uri defaultSoundUri= RingtoneManager.getDefaultUri\n    (RingtoneManager.TYPE_NOTIFICATION);\n    NotificationCompat.Builder notificationBuilder = \n    (NotificationCompat.Builder) new NotificationCompat.Builder(this)\n            .setAutoCancel(true)   //Automatically delete the \n                                   notification\n            .setSmallIcon(R.mipmap.ic_launcher) //Notification icon\n            .setContentIntent(pendingIntent)\n            .setContentTitle(notificationTitle)\n            .setContentText(notificationBody)\n            .setSound(defaultSoundUri);\n\n    NotificationManager notificationManager = (NotificationManager) \n    getSystemService(Context.NOTIFICATION_SERVICE);\n\n    notificationManager.notify(0, notificationBuilder.build());\n}\n\n```", "```java\nsendNotification(notificationTitle, notificationBody);\n\n```", "```java\npublic class MessagingService extends FirebaseMessagingService {\n\n    private static final String TAG = \"MessagingService\";\n\n    @Override\n    public void onMessageReceived(RemoteMessage remoteMessage) {\n        String notificationTitle = null, notificationBody = null;\n        // Check if message contains a notification payload.\n        if (remoteMessage.getNotification() != null) {\n            Log.d(TAG, \"Message Notification Body: \" + \n            remoteMessage.getNotification().getBody());\n            notificationTitle = \n            remoteMessage.getNotification().getTitle();\n            notificationBody = \n            remoteMessage.getNotification().getBody();\n\n            sendNotification(notificationTitle, notificationBody);\n\n        }\n    }\n\n    private void sendNotification(String notificationTitle, String \n    notificationBody) {\n        Intent intent = new Intent(this, MainActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        PendingIntent pendingIntent = PendingIntent.getActivity(this, \n       0, intent,\n                PendingIntent.FLAG_ONE_SHOT);\n\n        Uri defaultSoundUri= RingtoneManager.getDefaultUri\n        (RingtoneManager.TYPE_NOTIFICATION);\n        NotificationCompat.Builder notificationBuilder =     \n        (NotificationCompat.Builder) \n        new NotificationCompat.Builder(this)\n                .setAutoCancel(true)   //Automatically delete the \n                                  notification\n                .setSmallIcon(R.mipmap.ic_launcher) //Notification icon\n                .setContentIntent(pendingIntent)\n                .setContentTitle(notificationTitle)\n                .setContentText(notificationBody)\n                .setSound(defaultSoundUri);\n\n        NotificationManager notificationManager = (NotificationManager) \n       getSystemService(Context.NOTIFICATION_SERVICE);\n\n        notificationManager.notify(0, notificationBuilder.build());\n    }\n}\n\n```", "```java\n<service\n    android:name=\".MessagingService\">\n    <intent-filter>\n        <action android:name=\"com.google.firebase.MESSAGING_EVENT\"/>\n    </intent-filter>\n</service>\n\n```", "```java\nFirebaseMessaging.getInstance().subscribeToTopic(\"pushNotifications\");\n\n```", "```java\npublic class PacktApp extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Firebase.setAndroidContext(this);\n        FirebaseMessaging.getInstance()\n        .subscribeToTopic(\"pushNotifications\");\n    }\n}\n\n```", "```java\n<application\n    android:name=\".PacktApp\"\n    ...>\n\n</application>\n\n```", "```java\n Notification notification = new NotificationCompat.Builder(mContext)\n         .setContentTitle(\"New mail from \" + sender.toString())\n         .setContentText(subject)\n         .setSmallIcon(R.drawable.new_mail)\n         .extend(new NotificationCompat.WearableExtender()\n                 .setContentIcon(R.drawable.new_mail))\n         .build();\n NotificationManagerCompat.from(mContext).notify(0, notification);\n\n```", "```java\n/Android Wear requires a hint to display the reply action inline.\nAction.WearableExtender actionExtender =\n    new Action.WearableExtender()\n        .setHintLaunchesActivity(true)\n        .setHintDisplayActionInline(true);\nwearableExtender.addAction(actionBuilder.extend(actionExtender).build());\n\n```", "```java\nprivate static final String TAG = \"MessagingService\";\npublic static final String EXTRA_VOICE_REPLY = \"extra_voice_reply\";\npublic static final String REPLY_ACTION =\n        \"com.packt.smartcha.ACTION_MESSAGE_REPLY\";\n\n```", "```java\n// Creates an Intent that will be triggered when a reply is received.\nprivate Intent getMessageReplyIntent(int conversationId) {\n    return new Intent().setAction(REPLY_ACTION).putExtra(\"1223\", \n    conversationId);\n}\n\n```", "```java\nprivate void sendNotification(String notificationTitle, String notificationBody) {\n    // Wear 2.0 allows for in-line actions, which will be used for \n    \"reply\".\n    NotificationCompat.Action.WearableExtender inlineActionForWear2 =\n            new NotificationCompat.Action.WearableExtender()\n                    .setHintDisplayActionInline(true)\n                    .setHintLaunchesActivity(false);\n\n    RemoteInput remoteInput = new \n    RemoteInput.Builder(\"extra_voice_reply\").build();\n\n    // Building a Pending Intent for the reply action to trigger.\n    PendingIntent replyIntent = PendingIntent.getBroadcast(\n            getApplicationContext(),\n            0,\n            getMessageReplyIntent(1),\n            PendingIntent.FLAG_UPDATE_CURRENT);\n\n    // Add an action to allow replies.\n    NotificationCompat.Action replyAction =\n            new NotificationCompat.Action.Builder(\n                    R.drawable.googleg_standard_color_18,\n                    \"Notification\",\n                    replyIntent)\n\n                    /// TODO: Add better wear support.\n                    .addRemoteInput(remoteInput)\n                    .extend(inlineActionForWear2)\n                    .build();\n\n    Intent intent = new Intent(this, ChatActivity.class);\n    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, \n    intent,\n            PendingIntent.FLAG_ONE_SHOT);\n\n    Uri defaultSoundUri = RingtoneManager.getDefaultUri\n    (RingtoneManager.TYPE_NOTIFICATION);\n    NotificationCompat.Builder notificationBuilder =      \n    (NotificationCompat.Builder) \n    new NotificationCompat.Builder(this)\n            .setAutoCancel(true)   //Automatically delete the     \n            notification\n            .setSmallIcon(R.mipmap.ic_launcher) //Notification icon\n            .setContentIntent(pendingIntent)\n            .addAction(replyAction)\n            .setContentTitle(notificationTitle)\n            .setContentText(notificationBody)\n            .setSound(defaultSoundUri);\n\n    NotificationManagerCompat notificationManager = \n    NotificationManagerCompat.from(this);\n    notificationManager.notify(0, notificationBuilder.build());\n}\n\n```", "```java\npackage com.packt.smartchat;\n\n/**\n * Created by ashok.kumar on 02/06/17.\n */\n\npublic class MessagingService extends FirebaseMessagingService {\n\n    private static final String TAG = \"MessagingService\";\n    public static final String EXTRA_VOICE_REPLY = \"extra_voice_reply\";\n    public static final String REPLY_ACTION =\n            \"com.packt.smartcha.ACTION_MESSAGE_REPLY\";\n            public static final String SEND_MESSAGE_ACTION =\n            \"com.packt.smartchat.ACTION_SEND_MESSAGE\";\n\n    @Override\n    public void onMessageReceived(RemoteMessage remoteMessage) {\n        String notificationTitle = null, notificationBody = null;\n        // Check if message contains a notification payload.\n        if (remoteMessage.getNotification() != null) {\n            Log.d(TAG, \"Message Notification Body: \" + \n            remoteMessage.getNotification().getBody());\n            notificationTitle = \n            remoteMessage.getNotification().getTitle();\n            notificationBody = \n            remoteMessage.getNotification().getBody();\n\n            sendNotification(notificationTitle, notificationBody);\n\n        }\n    }\n\n    // Creates an intent that will be triggered when a message is read.\n    private Intent getMessageReadIntent(int id) {\n        return new Intent().setAction(\"1\").putExtra(\"1482\", id);\n    }\n\n    // Creates an Intent that will be triggered when a reply is \n    received.\n    private Intent getMessageReplyIntent(int conversationId) {\n        return new Intent().setAction(REPLY_ACTION).putExtra(\"1223\", \n        conversationId);\n    }\n\n    private void sendNotification(String notificationTitle, String \n    notificationBody) {\n        // Wear 2.0 allows for in-line actions, which will be used for \n        \"reply\".\n        NotificationCompat.Action.WearableExtender \n        inlineActionForWear2 =\n                new NotificationCompat.Action.WearableExtender()\n                        .setHintDisplayActionInline(true)\n                        .setHintLaunchesActivity(false);\n\n        RemoteInput remoteInput = new \n        RemoteInput.Builder(\"extra_voice_reply\").build();\n\n        // Building a Pending Intent for the reply action to trigger.\n        PendingIntent replyIntent = PendingIntent.getBroadcast(\n                getApplicationContext(),\n                0,\n                getMessageReplyIntent(1),\n                PendingIntent.FLAG_UPDATE_CURRENT);\n\n        // Add an action to allow replies.\n        NotificationCompat.Action replyAction =\n                new NotificationCompat.Action.Builder(\n                        R.drawable.googleg_standard_color_18,\n                        \"Notification\",\n                        replyIntent)\n\n                        /// TODO: Add better wear support.\n                        .addRemoteInput(remoteInput)\n                        .extend(inlineActionForWear2)\n                        .build();\n\n        Intent intent = new Intent(this, ChatActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        PendingIntent pendingIntent = PendingIntent.getActivity(this, \n        0, intent,\n                PendingIntent.FLAG_ONE_SHOT);\n\n        Uri defaultSoundUri = RingtoneManager.getDefaultUri\n         (RingtoneManager.TYPE_NOTIFICATION);\n        NotificationCompat.Builder notificationBuilder = \n        (NotificationCompat.Builder) new \n         NotificationCompat.Builder(this)\n                .setAutoCancel(true)   //Automatically delete the \n                notification\n                .setSmallIcon(R.mipmap.ic_launcher) //Notification icon\n                .setContentIntent(pendingIntent)\n                .addAction(replyAction)\n                .setContentTitle(notificationTitle)\n                .setContentText(notificationBody)\n                .setSound(defaultSoundUri);\n\n        NotificationManagerCompat notificationManager = \n        NotificationManagerCompat.from(this);\n        notificationManager.notify(0, notificationBuilder.build());\n    }\n}\n\n```", "```java\n@Override\npublic void onReceive(Context context, Intent intent) {\n    if (MessagingService.REPLY_ACTION.equals(intent.getAction())) {\n        int conversationId = intent.getIntExtra(\"reply\", -1);\n        CharSequence reply = getMessageText(intent);\n        if (conversationId != -1) {\n            Log.d(TAG, \"Got reply (\" + reply + \") for ConversationId \" \n            + conversationId);\n        }\n        // Tell the Service to send another message.\n        Intent serviceIntent = new Intent(context, \n        MessagingService.class);\n        serviceIntent.setAction(MessagingService.SEND_MESSAGE_ACTION);\n        context.startService(serviceIntent);\n    }\n}\n\n```", "```java\nprivate CharSequence getMessageText(Intent intent) {\n    Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);\n    if (remoteInput != null) {\n        return \n        remoteInput.getCharSequence\n        (MessagingService.EXTRA_VOICE_REPLY);\n    }\n    return null;\n}\n\n```", "```java\npublic class MessageReplyReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \n    MessageReplyReceiver.class.getSimpleName();\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (MessagingService.REPLY_ACTION.equals(intent.getAction())) {\n            int conversationId = intent.getIntExtra(\"reply\", -1);\n            CharSequence reply = getMessageText(intent);\n            if (conversationId != -1) {\n                Log.d(TAG, \"Got reply (\" + reply + \") for \n                ConversationId \" + conversationId);\n            }\n            // Tell the Service to send another message.\n            Intent serviceIntent = new Intent(context,    \n            MessagingService.class);\n            serviceIntent.setAction\n           (MessagingService.SEND_MESSAGE_ACTION);\n            context.startService(serviceIntent);\n        }\n    }\n\n    private CharSequence getMessageText(Intent intent) {\n        Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);\n        if (remoteInput != null) {\n            return remoteInput.getCharSequence\n            (MessagingService.EXTRA_VOICE_REPLY);\n        }\n        return null;\n    }\n}\n\n```", "```java\n<receiver android:name=\".MessageReplyReceiver\">\n    <intent-filter>\n        <action \n        android:name=\"com.packt.smartchat.ACTION_MESSAGE_REPLY\"/>\n    </intent-filter>\n</receiver>\n\n```"]