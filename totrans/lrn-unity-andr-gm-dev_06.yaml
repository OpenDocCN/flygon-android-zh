- en: Chapter 6. Specialities of the Mobile Device – Touch and Tilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about pathfinding and AI. We expanded our
    Tank Battle game to include enemy tanks. We created points for them to spawn at
    and made them shoot at the player. In addition, the player was given the ability
    to destroy the tanks. Once they were destroyed, the player received some points
    and a new enemy tank was spawned.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work on a new game as we explore some of the specialties
    of mobile devices. We will create a **Monkey Ball** game. The player will take
    control of a monkey in an oversized hamster ball and try to reach the end of the
    maze before time runs out, while collecting bananas. To move around, they will
    have to tilt the mobile device. To collect bananas, the player will have to touch
    the screen where the banana is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Touch controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Monkey Ball game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a new project for this chapter, so start Unity and we will
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every project, we need a little bit of preparation work in order to
    prepare our development environment. Don''t worry; the setup for this chapter
    is simple and straightforward. Let''s follow these steps to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is, of course, to start Unity and create a new project. It will
    need to be a 3D project and naming it `Ch6_MonkeyBall` will work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Unity has finished initializing, this is the perfect opportunity to set
    our build settings. Open the **Build Settings** window, select **Android** from
    the list of platforms and hit **Switch Platform** to change the target platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While you are in the **Build Settings** window, select **Player Settings** to
    open the player settings in the **Inspector**. Adjust the **Company Name**, **Product
    Name**, and, most importantly, the **Bundle Identifier**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a user tilts their device, the whole screen will adjust its orientation
    when a new side becomes the bottom. Since the whole game is based around tilting
    the device, the screen orientation might change at any moment when a player is
    playing and thus spoil their game. Therefore, in **Player Settings**, find the
    **Resolution** **and Presentation** section and ensure that the **Default Orientation**
    is not set to **Auto Rotation**, which would cause Unity to change a game's orientation
    when we are playing. Any of the other options will work for us here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a few folders to keep the project organized. The `Scripts`,
    `Models`, and `Prefabs` folders should be created in the **Project** window. Since
    we may end up with dozens of levels and maps in the future, it would be a good
    idea to make a `Scenes` folder as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we must import the assets for this project. We are going to need a monkey
    for the player, a banana to collect, a sample map, and some fences. Luckily, all
    of these have already been prepared and are available with the starting assets
    for this chapter. Import `Monkey.blend`, `Monkey.psd`, `Ball.psd`, `Banana.blend`,
    `Banana.psd`, `MonkeyBallMap.blend`, `Grass.psd`, `Fence.blend`, and `Wood.psd`
    to the `Models` folder that you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just finished the setup for this chapter's project. Once again, a little
    bit of effort at the beginning of the project will save time and avoid frustration
    later; as the project grows in size, the organization done at the beginning becomes
    very important.
  prefs: []
  type: TYPE_NORMAL
- en: A basic environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into all the fun of tilt and touch controls, we need a basic
    testing environment. When working with new control schemes, it is always best
    to work in a simple and well-controlled environment before introducing the complexities
    of a real level. Let''s make ours with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the top of Unity and select **Cube** by navigating to **GameObject** |
    **3D Object** to create a new cube, which will be the base of our basic environment.
    Rename it as `Ground` so that we can keep track of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the cube's **Position** in the **Inspector** panel to `0` on each axis,
    allowing us to work around the world origin. Also, set its **X** and **Z** **Scale**
    in the **Inspector** to `10`, giving us enough space to move around and test our
    monkey.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a second cube, named `Fence`. This cube should have a **Position**
    value of `-5` for **X**, `1` for **Y**, and `0` for **Z**, along with a scale
    of `0.2` for **X** and **Y** and `10` for **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `Fence` selected in the **Hierarchy** window, you can hit *Ctrl* + *D*
    on your keyboard to make a duplicate. We are going to need a total of four, positioned
    along each side of our `Ground` cube:![A basic environment](img/4691OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a basic testing environment that will allow us to work with our
    controls and not worry about all the complexities of a whole level. Once our controls
    work in this environment the way we want them to, we will introduce our monkey
    to a new environment.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling with tilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern mobile devices provide a broad variety of internal sensors to detect
    and provide information about the surrounding world. Though you may not have thought
    of them in such a way, you must be certainly very familiar with the microphone
    and speaker that are required for making calls. There is also a Wi-Fi receiver
    for connecting to the Internet and a camera for taking pictures. In addition,
    your device almost certainly has a magnetometer, to work with your GPS and provide
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensor that we are interested in right now is the **gyroscope**. This sensor
    detects local rotation of the device. In general, it is one of the many sensors
    in your phone that is used to determine the orientation and movement of the device
    in the world. We are going to use it to steer our monkey. When the user tilts
    their device left and right, the monkey will move left and right. When the device
    is tilted up and down, the monkey will go forward and backward. With these steps,
    we can create the script that will let us control our monkey in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: To start this off, create a new script and name it `MonkeyBall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first variable will hold a reference to the **Rigidbody** component that
    will be attached to the ball. This is what will allow us to actually make it roll
    around and collide with the things in the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next two variables will let us control how the tilting of the device affects
    the movement in the game. The first will allow us to get rid of any movements
    that are too small. This lets us avoid random movements from the environment or
    a sensor that perhaps isn''t entirely accurate. The second will let us scale the
    tilt input up or down in case the control feels either sluggish and slow or uncontrollably
    fast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last variable for now will keep track of how much the device has been tilted.
    It forces the user to tilt their device back and forth, countering movement if
    they want to go in the opposite direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our very first function for this script is nice and short. In order to get
    input from the gyroscope, we must first turn it on. We will do this in the `Awake`
    function so that we can start tracking it at the very beginning of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next function for our script will be `Update`. It starts by grabbing the
    value of `rotationRate` from the gyroscope. This is a value in radians per second,
    indicating how fast the user has tilted their device along each axis. To make
    it a little more understandable, we multiply the value of `rotationRate` by `Mathf.Rad2Deg`
    to convert it into degrees per second before we store it in a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When holding your device with the screen facing you, the *x* axis of your device
    points to the right. The *y* axis is straight up, at the top of the device and
    the *z* axis points directly towards you from the center of the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we make sure that there is enough movement along each axis to actually
    make our monkey move. By using `Mathf.Abs` on each value, we find the absolute
    value of the axis movement. We then compare it to the minimum amount of tilt that
    we are looking for. If the movement is too little, we zero it out in our `rotation`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, for our `Update` function, we track the new movement by adding it
    to our `totalRotate` variable. To do this properly, we need to rearrange the values.
    The player expects to be able to tilt the top of their device towards them to
    go backwards and away to go forwards. This is the *x* axis movement, but it comes
    in backwards from our device compared to what we need to move the monkey, hence
    the negative sign before the value. Next, we swap the *y* and *z* axes'' rotation
    because the player is going to expect to tilt their device left and right to go
    left and right, which is a *y* axis movement. If we applied that to the *y* axis
    of our monkey, he would just spin in place. So, the movement is treated to be
    speed per second rather than speed per frame; we have to multiply by `Time.deltaTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function for now is the `FixedUpdate` function. When making changes
    to and dealing with rigidbodies, it is best to do it in `FixedUpdate`. The rigidbody
    is what actually connects us into Unity''s physics engine, and it only updates
    during this function. All we are doing here is adding some torque, or rotational
    force, to the rigidbody. We use the total that we have been collecting and multiply
    it by our `sensitivity` to give our players the speed of control that they will
    expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to make use of our new script, we need to make some changes to the
    ball. Start by creating a sphere for us to work with; this can be found by navigating
    to **GameObject** | **3D Object** | **Sphere**. Rename it as `MonkeyBall` and
    position it a little above our **Ground** cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, give it the `Ball.psd` texture in a material so that we can see it rotate
    and not just move. The two-tone nature of the texture will let us easily see it
    roll around the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Rigidbody** component can be found by navigating to **Component** | **Physics**
    | **Rigidbody** at the top of Unity. Add a new **Rigidbody** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, add our `MonkeyBall` script to the sphere and drag the new **Rigidbody**
    component to the **Body** slot in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the point where it is especially important to have **Unity Remote**.
    With your device attached and *Unity Remote* running, you can hold it up and steer
    the ball. Feel free to adjust the sensitivity and minimum tilt until you find
    settings that feel natural to control. Due to the great variety of devices, their
    hardware, and the architecture used, the rate of tilt can easily differ from one
    device to the next. However, especially at this stage, you must find settings
    that work for your device now and worry about what will work for other devices
    once the game is more complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are having trouble seeing the ball roll around, move the camera so that
    you have a better view. However, make sure that it continues to point forward
    along the world's *z* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all your settings are in place, ensure that you save the scene. Name it
    `MonkeyBall`.![Controlling with tilt](img/4691OT_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We made use of the gyroscope to provide you with the steering control of a ball.
    By measuring how the player is tilting his or her device, we are able to add motion
    to the ball accordingly. By rolling around a simple map, we can fine-tune our
    controls and make sure everything is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Following with the camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To really make the player feel like they are controlling the ball, the camera
    needs to follow it around. This is particularly necessary when the maps and levels
    become larger and more complex than what can be shown in a single camera shot.
    The simplest solution would be to just make the camera a child of the ball, but
    that will make it spin with the ball and our controls will become confusing as
    well. So, let''s use these steps to set up our camera to follow the ball around:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to first create a new script and name it `CameraFollow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script is really simple. It has a single variable to keep track of what
    is being followed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only function in the script is the `LateUpdate` function. We use this function
    because it executes after everything else has had a chance to do their normal
    update. The only thing the script is going to do is move to the new position of
    the ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make use of this script, we need a new empty **GameObject** component. Name
    it `CameraPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at (approximately) the center of the ball. This is the point that
    will actually move to follow the ball around. At this point, the created **GameObject**
    doesn't have to be perfectly positioned; it just needs to be close enough so that
    it's easier to line up the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, find the `Main Camera` in the **Hierarchy** window and make it a child
    of `CameraPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Main Camera` component's **X** position to `0`. As long as **X** stays
    at zero and the camera continues to point relatively forward along the *z* axis,
    you can freely move it to find a good position from which to observe the ball.
    Values of `2` for the **Y** position, `-2.5` for the **Z** position, and `35`
    for the **X** rotation also work well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `CameraFollow` script to the `CameraPivot` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, drag `MonkeyBall` from the scene and drop it on the **Ball** slot of
    the new **CameraFollow** script component. Then, go try it out!![Following with
    the camera](img/4691OT_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a ball that rolls around and a camera that follows it. The camera
    is simply updating its position to keep pace with the ball, but it works well
    as an effect. As a player, we will definitely feel that we are taking control
    of the ball and its motion.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the monkey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are close to the ball and following it around, we need something
    a little more interesting to look at. In this section, we are going to add the
    monkey to the ball. In addition, to ensure that he isn''t being spun around wildly,
    we will make a new script to keep him upright. Let''s do all of that by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty **GameObject** and rename it `MonkeyPivot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make it a child of the `MonkeyBall` script and zero out its position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the monkey to the scene and make it a child of the `MonkeyPivot` GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it easier to see the monkey inside the ball, we need to make it slightly
    transparent. Select `MonkeyBall` and find the **Rendering Mode** setting on the
    material at the bottom. By changing it to **Transparent**, we will be able to
    adjust it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **Color Picker** box to the right of **Albedo** and change
    the **A** slider, alpha, to `128`; this will allow us to now see through the ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale and move the monkey until he fills the center of the ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also take this opportunity to pose the monkey. If you expand the monkey
    in the **Hierarchy** window, you will be able to see all of the bones that make
    up his skeleton rig. Giving him a cool pose now will make the game much better
    for our players later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Adding the monkey](img/4691OT_06_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Our monkey and the ball are looking really cool right now, until we actually
    hit play and the monkey spins around dizzily in the ball. We need to open our
    `MonkeyBall` script and fix his spinning antics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need two new variables at the top of the script. The first will keep
    track of the empty **GameObject** that we created a moment ago. The second will
    give us the speed for updating the rotation of the monkey. We want it to look
    like the monkey is moving the ball, so he needs to face the direction in which
    the ball is moving. The speed here is how fast he will turn to face the right
    direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a new `LateUpdate` function. This double-checks whether the `monkeyPivot`
    variable has actually been filled for the script. If it isn''t there, we can''t
    do anything else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We first need to figure out which direction the ball is moving in. The easiest
    way to do this is to grab `velocity` of the **Rigidbody** component, our body
    variable. It is a `Vector3` that indicates how fast and in which direction we
    are currently moving. Since we do not want our monkey to point up or down, we
    zero out the *y* axis movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to figure out which direction the monkey is currently facing.
    We have used the forward value before, with our tanks. It is simply the direction
    in 3D space in which we are facing. Again, to avoid looking up or down, we zero
    out the *y* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To prevent suddenly changing direction as we move and to keep pace with the
    frame rate, we must calculate a `step` variable. This is how much we can rotate
    this frame, based on our speed and the time that has elapsed since the last frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to find a new direction to face by using `Vector3.RotateTowards`.
    It takes the direction we were facing, followed by the direction we want to face
    and two speeds. The first speed specifies how much the angle can change in this
    frame and the second specifies how much the magnitude, or length, of the vector
    can change. We are not concerned with a change in magnitude, so it is given a
    zero value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the new rotation is calculated using `Quaternion.LookRotation` by
    passing the `newFacing` vector to it and applying the result to the monkey''s
    rotation. This will turn the monkey to face in the direction of the movement and
    keep him from spinning with the ball:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make it work, drop the `MonkeyPivot` object on the **Monkey Pivot** slot
    on the **MonkeyBall** script component. The monkey will rotate to face the direction
    of the ball's movement while staying upright:![Adding the monkey](img/4691OT_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've just finished adding the monkey to the ball. By giving him a cool pose,
    the player will be more engaged with it as a character. However, it looks a little
    weird when the monkey spins wildly within the ball, so we updated our script to
    keep him upright and facing the direction in which the ball is moving. Now, it
    almost looks as though the monkey is in control of the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the monkey on the board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What fun is a game if there is no risk of failure? In order to test our monkey
    and tilt controls, we put a safety fence around our basic environment to keep
    them from falling over. However, every game needs a little risk to make it exciting.
    By removing the safety fence, we introduce a risk of falling over and losing the
    game. However, usually there is an option to retry the game if you fall. To this
    end, we will now create what is traditionally called a **kill** **volume**. This
    is simply an area that resets the player when they fall into it. Let''s use these
    steps to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new script and name it `KillVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script has a single variable. It will keep track of where to put the monkey
    ball after it has fallen in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This script also has a single function, `OnTriggerEnter`. This function is
    called every time an object with a **Rigidbody** component enters a trigger volume.
    It receives the object that enters as a collider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function simply changes the position of the thing that entered the volume
    to that of the point where we want to respawn it. The only thing that will be
    moving around our game will be the monkey ball, so we don''t have to worry about
    any double-checking what has entered. We also set `velocity` to `zero` so that
    it doesn''t move suddenly when the player regains control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need a new empty **GameObject**, named `RespawnPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position this object at approximately the same location of where our ball starts.
    This is the point where the ball will be put after it has fallen off the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create another empty **GameObject** and name it `KillVolume`. This object
    will catch and reset the game when the player falls in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its position to `-10` for **Y** and `0` for both **X** and **Z**. This will
    put it well below where the player is going to be. The important thing for future
    levels is that this volume is below where the player is normally going to be.
    If it isn't, they might miss it and fall forever, or suddenly jump back to the
    beginning, passing through it on their way to an that area they are supposed to
    be in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to give the object a **Box Collider** component and attach our `KillVolume`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to get `OnTriggerEnter` function called by Unity, we need the **Is
    Trigger** box checked. Otherwise, it will just collide with the volume and appear
    to the player that they are just floating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to make the volume large enough to actually catch our player when
    they fall in. To do this, set **Size** on the **Box Collider** component to `100`
    for both the **X** and **Z** axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `RespawnPoint` object from the **Hierarchy** window to the **Respawn
    Point** slot on our `KillVolume` script component in the **Inspector**. Without
    it, our player will never be able to get back after falling off the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, delete the `Fence` cubes from our basic environment so that we can
    test it out. You can move the ball around and when it falls off the ground block,
    it will hit `KillVolume` and return to `RespawnPoint`.![Keeping the monkey on
    the board](img/4691OT_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the ability to reset our players when they fall off the map. The
    important part is detecting when they are no longer on the map and not interrupting
    them when they should be. This is why we have made it so large and put it well
    underneath the main area of our level. However, it would be a bad idea to put
    the volume too far below the play area, or the player is going to be falling for
    a long time before the game is reset.
  prefs: []
  type: TYPE_NORMAL
- en: Winning and losing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the ability to move around and reset if we fall off the map,
    we just need some way to win or lose the game. This particular type of game is
    traditionally tracked by how fast you are able to get from one end of the map
    to the other. If you fail to reach the end before the timer runs out, it is game
    over. Let''s use these steps to create a finish line and a timer for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a new script named `VictoryVolume`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It starts with a pair of variables for tracking the messages for our player.
    The first will be turned on and shown to the player if they reach the end within
    the time limit. The second will only display if they run out of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next variable will track the `Text` object in the GUI to display the current
    amount of time left to complete the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This variable is for setting how much time, in seconds, is available for a
    player to complete the level. When adjusting this in the **Inspector** panel for
    a larger version of the game, it is a good idea to have several people test the
    level in order to get a feel of how long it takes to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our last variable for the script will simply track whether or not our timer
    can actually count down. By making it `private` and defaulting it to `true`, the
    timer will always start counting from the moment the level loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first function for this script is `Awake`, which is the best location for
    initialization. The only thing it does is turn off both of the messages. We will
    turn on the appropriate one later, based on how our player performs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To detect when the player has crossed the finish line, we will be using the
    same `OnTriggerEnter` function that we used for the `KillVolume` script. Here,
    however, we will first check to make sure that we are still timing the player.
    If we are no longer timing them, they must have run out of time and lost. Therefore,
    we should not let them cross the finish line and win:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we turn on the text that tells the player that they have won. We have
    to let them know at some point, so it might as well be now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing the function does is essentially turn the physics off for the
    monkey ball to stop it from rolling around. By using `attachedRigidbody`, we gain
    access to the **Rigidbody** component, which is the part hooking it into Unity''s
    physics engine that is attached to the object. Then, we set its `isKinematic`
    property to `true`, essentially telling it that it will be controlled by the script
    and not by the physics engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the function stops counting the player''s time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function for this script is the `Update` function, which first checks
    to make sure that the timer is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It then removes the time since the last frame, from the time remaining to complete
    the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we update the time on screen with the amount of time that remains. The
    text on the screen must be in the form of a string, or words. A number, such as
    our remaining time, is not a word, so we use the `ToString` function on it to
    convert it into the right datatype for it to be displayed. Leaving it at that
    would have been fine, but it would have displayed a bunch of extra decimal places
    that the player wouldn''t have even cared about. Therefore, `0.00` is passed to
    the function. We are telling it what format and how many decimal places we want
    the number to have when it becomes a word. This makes it more meaningful to our
    players and much easier to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After checking to see whether the player is out of time, we turn on the text
    that tells them that they have lost and turn off the time display. We also stop
    counting the time. If they are already out of time, what is the point in counting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to return to Unity and make this script work. Do this by first
    creating a new empty **GameObject** and naming it `VictoryPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is going to need three cubes as children. Remember, you can find them by
    navigating to **GameObject** | **3D Object** | **Cube**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first cube should be positioned at `1` for **X**, `1` for **Y**, and `0`
    for **Z**. In addition, give it a scale of `0.25` for **X**, `2` for **Y**, and
    `0.25` for **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second cube should have all of the same settings as the first one, except
    for having a position of `-1` for **X**, which moves it to the opposite side of
    the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last cube needs a position of `0` for **X**, `2.5` for **Y**, and `0` for
    **Z**. Its scale needs to be set as `2.25` for **X**, `1` for **Y**, and `0.25`
    for **Z**. Together, these three cubes give us a basic-looking finish line, which
    will stand out from the rest of the game board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we are going to need some text objects for the GUI. Create three of them,
    by navigating to **GameObject** | **UI** | **Text**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first should be named `Timer`; this will handle the display, showing how
    much time remains for the player to reach the finish line. It needs to be anchored
    to the **top-left** with a position of `80` for **Pos X** and `-20` for **Pos
    Y**. It also needs a value of `130` for **Width** and a value of `30` for **Height**.
    We can also change the default text to `0.00` so that we have a better idea of
    how it will look in the game. A **Font Size** value of `20` and **Alignment**
    of **left-center** will position it well for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second text object should be named `Victory`; it will display the message
    shown when the player reaches the finish line. It needs to be anchored in **middle-center**
    with a position of `0` for **Pos X** and **Pos Y**. It needs a value of `200`
    for **Width** and a value of `60` for **Height** so that we will have enough space
    to draw the message. Change the default text to `You Win!`, increase **Font Size**
    to `50,` and select **middle-center** for **Alignment** so that we get a nice,
    big message in the center of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last text object should be named `OutOfTime`; it will display the message
    when the player fails to reach the end, before the timer runs down. It shares
    all the same settings as the previous one, except it needs a value of `500` for
    **Width** to fit its larger default text of `You Ran Out Of Time!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to select `VictoryPoint` and give it a **BoxCollider** component,
    as well as our `VictoryVolume` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **BoxCollider** component is going to need the **Is Trigger** box to be
    checked. It needs a value of `0` for **X**, `1` for **Y**, and `0` for **Z** for
    **Center**. In addition, **Size** should be `1.75` for **X**, `2` for **Y**, and
    `0.25` for **Z**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, drag each of the text objects that we just created to the appropriate
    slot on the **VictoryVolume** script component.![Winning and losing the game](img/4691OT_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've just finished putting together a means by which the player can either
    win or lose the game. If you were to try it out now, you should be able to see
    the timer tick down in the top-left corner of the screen. When you manage to reach
    the finish line in time, a nice message is displayed indicating this. If you are
    not quite as successful in reaching it, a different message is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: This is the entire interface that we will be creating for this game, but it
    is still awfully bland. Use your skills from what you learned in [Chapter 2](ch02.html
    "Chapter 2. Looking Good – The Graphical Interface"), *Looking Good – The Graphical
    Interface* to style the interface. It should look pleasing and exciting, perhaps
    even monkey-themed. To get extra fancy, you could try to set it up to change colors
    and size as the remaining time approaches zero, giving the player an indication
    at a glance of where they stand in terms of the time remaining to complete that
    level.
  prefs: []
  type: TYPE_NORMAL
- en: The finish line also looks boring, as it is made only out of cubes. Try your
    hand at creating a new one. It could have some sort of finish line banner across
    it, like they have in races. Maybe it could be a little more round-looking. If
    you wanted to get really fancy, you could look at creating a second timer that
    would exist at the front of the finish line. It would allow the player to look
    at the world, where most of their focus will be, and know what their remaining
    time is.
  prefs: []
  type: TYPE_NORMAL
- en: Putting together the complex environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a one block map does not make for a very interesting game experience.
    It works excellently for us to set up the controls, but the players will not find
    it much fun. So, we need something a little better. Here, we will be setting up
    a more complex environment with ramps, bridges, and turns. We will also use some
    fences to help and guide the player. Let''s do this all with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding the `MonkeyBallMap` model to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Scale** attribute to `100` on each axis and its **Position** attribute
    to `0` on each axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the map appears to be white, then apply the `Grass` texture to it. This map
    gives us a good starting platform, a half-pipe ramp, a few turns, and a short
    bridge. Altogether, there are plenty of basic challenges for the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable our ball to actually to use the map, it is going to need some colliders
    to make it physical. Expand `MonkeyBallMap` in the **Hierarchy** window and select
    both `FlatBits` and `HalfPipe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On to each of these objects add a **MeshCollider** component, just like we did
    for some of the parts of our tank city. Remember, it can be found by navigating
    to **Component** | **Physics** | **Mesh Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have the `Fence` model. With this, we can both help and hinder the
    player by placing guardrails along the edges or blockages in their path. Start
    by dragging the `Fence` model into the scene and setting its **Scale** to `100`
    to keep it sized in proportion to our map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable the fences to physically block the player, they need a collider. To
    both of the children fence objects, add a **BoxCollider** component that can be
    found by navigating to **Component** | **Physics** | **Box Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, ensure that you apply the `Wood` texture to both of the fence pieces
    if they appear white in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty **GameObject** and name it `Fences`. Then, set its **Position**
    attribute to `0` on each axis. This object will help us to stay organized because
    we could end up with a great many pieces of fence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, expand the `Fence` model in the **Hierarchy** window and make both `Post`
    and `PostWithSpokes` children of the `Fences` empty **GameObject**. Then, delete
    the `Fence` object. By doing this, we break the prefab connection and remove the
    risk of recreating it. If we had just used the `Fence` object for our organization,
    there was a risk that we could've ended up deleting all of our work that we put
    in setting them up in the scene if we made changes to the original model file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to position the fences in strategic locations to affect how our player
    is able to play the game. The first place we might want to put them is around
    the starting area, giving our player a nice safe beginning to the game. Remember,
    you can use *Ctrl* + *D* to duplicate the fence pieces so that you will always
    have enough fences.![Putting together the complex environment](img/4691OT_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second place to put fences would be after the half pipe, just before the
    bridge. Here, they would help the player to reorient themselves before they try
    to go across the small bridge:![Putting together the complex environment](img/4691OT_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last place we could put them would be a hindrance to the player. If we place
    them in the middle of the final platform, we would force the player to go around
    and risk falling off before reaching the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Speaking of the finish line, now that everything else is placed, we need to
    move it into position. Place it at the end of the lower platform. Here, the player
    will have to face all of the challenges of the map and risk falling many times
    before they finally achieve victory by reaching the end.![Putting together the
    complex environment](img/4691OT_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is it for setting up our complex environment. We gave the player a chance
    to orient themselves before forcing them to navigate a handful of challenges and
    reach the end. Give it a try. Our game is starting to look really nice.
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge here might be quite obvious. Try your hand at making your
    own map with ramps, bridges, chutes, and blockages. You could perhaps make a big
    maze out of the fences. Otherwise, you could alter the level so that it actually
    requires the player to go up some straight paths and ramps, meaning the player
    would need enough speed to make it. There might even be the need for a few jumps.
    Make the player go down a ramp to gain speed before jumping across to another
    platform. Whatever your new level becomes, make sure that `KillVolume` is below
    it and covers plenty of area underneath. You never quite know how the players
    will play and where they will manage to get themselves stuck.
  prefs: []
  type: TYPE_NORMAL
- en: The map itself looks pretty good, but the area around it could use some work.
    Use your skills from the previous chapters—add a skybox to the world, something
    that looks better than the defaults. While you're at it, work with the lighting.
    A single **Directional Light** is nice but not very interesting. Create some light
    source models to place round the map. Then, bake the lightmaps to create some
    good quality shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Adding bananas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to a game with monkeys, the most obvious thing for our player
    to collect is bananas. However, it is never enough to have items in the world
    for players to collect; we have to show the player that the items are collectible.
    Usually, this means that the thing is spinning, bouncing, shining, generating
    sparks, or demonstrating some other special effect. For our game, we are going
    to make the bananas bounce up and down while spinning in place. Let''s do it with
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right off the bat, we are going to need a new script. Create one and name it
    `BananaBounce`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script begins with three variables. The first is how fast, in meters per
    second, the banana will move up and down. The second is how high the banana will
    go from its starting position. The third is at how many degrees per second the
    banana will spin in place. Altogether, these variables will let us easily control
    and tweak the movement of the banana:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This next variable will keep track of the actual object that will be moving.
    By using two objects for the setup and control of the banana, we are able to separate
    position and rotation and make everything easier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function for this script is `Update`. It first checks to make sure that
    our `bobber` variable has been filled. Without it, we can''t do anything to make
    our banana move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we use the `PingPong` function to calculate a new position for our banana.
    This function bounces a value between zero and the second value you to it. In
    this case, we are using the current time multiplied by our speed to determine
    how far the banana might have moved in this game. By giving a height to it, we
    end up with a value that moves back and forth from zero to our maximum height.
    We then multiply it by an up vector and apply it to our `localPosition` so that
    the banana will move up and down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we use the same `Rotate` function that we used for rotating turrets
    to make the banana spin in its place. It will just do this constantly at whatever
    speed we tell it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to return to Unity and set these bananas up. To do this, we first
    need to add the `Banana` model to the scene. If it is white, be sure to add the
    `Banana` texture to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our `BananaBounce` script to the new banana, or else it is just not going
    to set there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The child object of `Banana` needs to be put in the **Bobber** slot on our script
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, turn it into a prefab and scatter them about the map: a few at the
    beginning area, a few near the finish line, and some along the way.![Adding bananas](img/4691OT_06_11.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you try out the game now, you should have several happily bouncing bananas.
    By using the `Mathf.PingPong` function, our jobs are made very easy for the creation
    of this effect. Without it, we would have needed to do a bunch of extra calculations
    to figure out whether we were moving up or down and how far along we were.
  prefs: []
  type: TYPE_NORMAL
- en: Having bananas as collectibles is great, but which game these days has a single
    type of pickup? Try your hand at making some other pickup models. The most obvious
    one would be some banana bundles, such as the bunches that you can buy at the
    grocery store or the huge bunch that actually grows on banana trees. However,
    you could also go down the route of coins, energy crystals, ancient monkey totems,
    checkpoints, score multipliers, or anything else that might catch your attention.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting bananas with touch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most obvious features of the modern mobile device is the touch screen.
    Devices use the electrical conductivity of the user''s finger and many tiny contact
    points to determine the location that is being touched. In order to explore the
    possibilities of the touch interface for our game, we will be making our players
    poke the bananas on the screen rather than running into them to collect them.
    Unity provides us with easy access to the touch inputs. By combining the input
    with ray casts, as we did for making the tanks fire, we can determine which object
    in the 3D space was touched by the user. For us, this means we can give the player
    the ability to touch and collect those bananas. To do it, let''s use these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First up, we need a new script. Create one and name it `BananaTouch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Update` function is the only function in this script. It starts by checking
    to see whether the player is touching the screen in any way. The `Input` class
    provides us with the `touchCount` value, which is simply a counter for how many
    fingers are currently touching the device''s screen. If there are no fingers touching,
    we don''t want to waste our time doing any work, so we exit early with `return`:
    and are ready to check the next frame again to see whether the player is touching
    the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We next create a `foreach` loop. This is a loop that will check each item in
    the list of touches, but it will not track the index of that touch. We then check
    the phase of each touch to see whether it has just started touching the screen.
    Every touch has five potential phases: **Began**, **Moved**, **Stationary**, **Ended**,
    and **Canceled**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the description for each state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Began**: This phase of touch occurs when the user first touches the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moved**: This phase of touch occurs when the user moves his or her finger
    across the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stationary**: This phase of touch is the opposite of the previous phase;
    this happens when the user''s finger is not moving across the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ended**: This phase of touch occurs when the user''s finger is lifted off
    the screen. This is the normal way for a touch to complete.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canceled**: This phase of touch occurs when an error occurs while tracking
    the touch. This phase tends to occur most often when a finger is touching the
    screen but not moving for a lot of time. The touch system is not perfect, so it
    assumes that it missed the finger being lifted off the screen and just cancels
    that touch.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we create a pair of variables. As with our tanks, the first is a holder
    for what was hit by our raycast. The second is a `Ray`, which is just a container
    for storing a point in space and a directional vector. The `ScreenPointToRay`
    function is specially provided by the camera for converting touch positions from
    the 2D space of the screen to the 3D space of the game world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step for the function is to call the `Raycast` function. We pass the
    ray and the tracking variable to the function. If an object is hit, we send it
    a message to tell it that it has been touched, just like shooting things with
    our tank. In addition, there are several curly braces that are required to close
    off the `if` statements, loop, and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we can try it out, we need to update our `BananaBounce` script to give
    it some health and allow it to be destroyed when its health runs out. So, open
    it now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need a pair of variables. The first is `health`. Actually, this is
    just the number of touches that are required to destroy the banana. If we had
    multiple types of bananas, they could each have a different amount of health.
    The second variable is a modifier for the banana''s speed of movement. Every time
    the banana loses health, it will slow down, indicating how much health it has
    left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a new function. This `Touched` function will receive the
    message from our `BananaTouch` script. It works similar to how we shot with our
    tank. The very first thing it does is reduce the remaining health:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After some damage has been done, we can slow the movement of the banana by
    doing a little division. This way it is easy for the player to know whether their
    touch was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the function checks to see whether the banana has run out of health.
    If it has, we use the `Destroy` function to get rid of it, just like the enemy
    tanks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you return to Unity, you need to attach our new `BananaTouch` script to
    the `MonkeyBall` object. Due to the way it works, it could technically go on any
    object, but it is always a good practice to keep player control scripts together
    and on what they are controlling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a **Sphere Collider** component to one of your bananas; this can be
    found by navigating to **Component** | **Physics** | **Sphere Collider**. If we
    make the changes to one and update the prefab, all the bananas in the scene will
    be updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Is Trigger** box so that the bananas do not block the movement of
    our monkey,. They will still be touchable while allowing our monkey to pass through
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The collider also needs to be positioned in a place where the player will mostly
    touch when they hit it. So, set the **Center** to `0` for **X**, `0.375` for **Y**,
    and `0` for **Z**. In addition, make sure the **Radius** is set to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, be sure to hit the **Apply** button at the top right of the **Inspector**
    panel to update all the bananas in the scene.![Collecting bananas with touch](img/4691OT_06_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you try out the game now, you should be able to touch any of the bananas.
    Initially, all of the bananas will move up and down evenly, like they did earlier.
    As you touch them, the ones that you touched will move slower, thanks to the bit
    of division that we made, before they are finally deleted. This lets our player
    easily see which bananas have been touched and which haven't.
  prefs: []
  type: TYPE_NORMAL
- en: The next step from having collectible objects in a game is to give meaning to
    the player. This is mostly done by giving them some point value. Try to do that
    here. It could be done in a very similar manner to the point system we had when
    we were destroying enemy tanks. If you created some other pickups earlier, you
    could set each of them up to have different amounts of health. They could also
    give you different amounts of points as a result. Play around with the numbers
    and settings until you find something that will be fun for the player to interact
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the specialties of the modern mobile device.
    We created a Monkey Ball game to try this out. We gained access to the device's
    gyroscope to detect when it is rotated. This gave our monkey the ability to be
    directed. After creating a more complex and interesting environment for the player
    to move around, we created a bunch of bananas that bob up and down while spinning
    in place. We also made use of the touch screen to give the player the ability
    to collect the bananas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a short break from our Monkey Ball game.
    One of the most popular mobile games on the market, Angry Birds, is a distinct
    and not uncommon type of game. In order to learn about physics in Unity and the
    possibility of a 2D-style game, we will be making an Angry Birds clone. We will
    also take a look at Parallax scrolling to help us create a pleasing background.
    Before you know it, we will be creating all of the Angry Birds levels that you
    always wished you could play.
  prefs: []
  type: TYPE_NORMAL
