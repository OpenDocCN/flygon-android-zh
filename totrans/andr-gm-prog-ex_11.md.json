["```java\nif (any point falls outside the border){collision has occurred}\n```", "```java\n// All objects which can collide have a collision package.\n// Asteroids, ship, bullets. The structure seems like slight\n// overkill for bullets but it keeps the code generic,\n// and the use of vertexListLength means there isn't any\n// actual speed overhead. Also if we wanted line, triangle or\n// even spinning bullets the code wouldn't need to change.\n\npublic class CollisionPackage {\n\n    // All the members are public to avoid multiple calls\n    // to getters and setters.\n\n    // The facing angle allows us to calculate the\n    // current world coordinates of each vertex using\n    // the model-space coordinates in vertexList.\n    public float facingAngle;\n\n    // The model-space coordinates\n    public PointF[] vertexList;\n\n    /* \n    The number of vertices in vertexList\n    is kept in this next int because it is pre-calculated\n    and we can use it in our loops instead of\n    continually calling vertexList.length.\n   */\n    public int vertexListLength;\n\n    // Where is the centre of the object?\n    public PointF worldLocation;\n\n    /* \n    This next float will be used to detect if the circle shaped\n    hitboxes collide. It represents the furthest point\n    from the centre of any given object.\n    Each object will set this slightly differently.\n    The ship will use height/2 an asteroid will use 25\n    To allow for a max length rotated coordinate.\n   */\n    public float radius;\n\n    // A couple of points to store results and avoid creating new\n    // objects during intensive collision detection\n    public PointF currentPoint = new PointF();\n    public PointF currentPoint2 = new PointF();\n```", "```java\npublic CollisionPackage(PointF[] vertexList, PointF worldLocation, \n  float radius, float facingAngle){ \n\n        vertexListLength = vertexList.length;\n        this.vertexList = new PointF[vertexListLength];\n        // Make a copy of the array\n\n        for (int i = 0; i < vertexListLength; i++) {\n            this.vertexList[i] = new PointF();\n            this.vertexList[i].x = vertexList[i].x;\n            this.vertexList[i].y = vertexList[i].y;\n        }\n\n        this.worldLocation = new PointF();\n        this.worldLocation = worldLocation;\n\n        this.radius = radius;\n\n        this.facingAngle = facingAngle;\n\n    }\n\n}\n```", "```java\nCollisionPackage cp;\n```", "```java\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\n\n// First, build a one element array\nPointF point = new PointF(0,0);\nPointF[] points = new PointF[1];\npoints[0] = point;\n\n// 1.0f is an approximate representation \n//of the size of a bullet\ncp = new CollisionPackage(points, getWorldLocation(),\n1.0f, getFacingAngle());\n```", "```java\n        move(fps);\n\n // Update the collision package\n cp.facingAngle = getFacingAngle();\n cp.worldLocation = getWorldLocation();\n\n```", "```java\nCollisionPackage cp;\n\n// Next, a 2d representation using PointF of\n// the vertices. Used to build shipVertices\n// and to pass to the CollisionPackage constructor\nPointF[] points;\n```", "```java\nsetVertices(shipVertices);\n\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\n\npoints = new PointF[6];\npoints[0] = new PointF(- halfW, - halfL);\n\npoints[2] = new PointF(halfW, - halfL);\npoints[4] = new PointF(0, 0 + halfL);\n\n// To make collision detection more accurate we will define some\n// more points on the midpoints of all our sides.\n// It is possible that the point of an asteroid will pass through\n// the side of the ship and we do not test for this!\n// We only test for the point of a ship \n// passing through the side of an asteroid!!\n// This is computationally cheaper than running both tests.\n// Although not as accurate we will see it is very close.\n// We can think of this visually as \n// adding extra sensors on the sides of our ship\n// Here we use an equation to find the midpoint \n// of a line which you can find an explanation of\n// on most good high school math web sites.\n\npoints[1] = new PointF(points[0].x + \n points[2].x/2,(points[0].y + points[2].y)/2);\n\npoints[3] = new PointF((points[2].x + points[4].x)/2,\n (points[2].y + points[4].y)/2);\n\npoints[5] = new PointF((points[4].x + points[0].x)/2,\n (points[4].y + points[0].y)/2);\n\ncp = new CollisionPackage(points, getWorldLocation(), \n length/2, getFacingAngle());\n\n}// End SpaceShip constructor\n```", "```java\nmove(fps);\n\n // Update the collision package\n cp.facingAngle = getFacingAngle();\n cp.worldLocation = getWorldLocation();\n\n}// End SpaceShip update()\n```", "```java\nCollisionPackage cp;\n```", "```java\n// Define a random asteroid shape\n// Then call the parent setVertices()\ngeneratePoints();\n\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\ncp = new CollisionPackage\n (points, getWorldLocation(), 25, getFacingAngle());\n\n```", "```java\npublic void bounce(){\n\n  // Reverse the travelling angle\n    if(getTravellingAngle() >= 180){\n      setTravellingAngle(getTravellingAngle()-180);\n     }else{\n      setTravellingAngle(getTravellingAngle() + 180);\n    }\n\n    // Reverse velocity because occasionally they get stuck\n    setWorldLocation((getWorldLocation().x + -getxVelocity()/3), (getWorldLocation().y + -getyVelocity()/3));\n\n    // Speed up by 10%\n    setSpeed(getSpeed() * 1.1f);\n\n    // Not too fast though\n    if(getSpeed() > getMaxSpeed()){\n      setSpeed(getMaxSpeed());\n\n}\n```", "```java\nmove(fps);\n\n// Update the collision package\ncp.facingAngle = getFacingAngle();\ncp.worldLocation = getWorldLocation();\n\n}\n```", "```java\n// left below 0\npoints[5] = new PointF();\ni = -(r.nextInt(14)+11);\npoints[5].x =  i;\ni = -(r.nextInt(12)+1);\n\npoints[5].y = i;\n\n// We add on an extra point that we won't use in asteroidVertices[].\n// The point is the same as the first. \n// This is because the last vertex\n// links back to the first to create a line. \n// This line will need to be\n// used in calculations when we do our collision detection.\n\n// Here is the extra vertex- same as the first.\npoints[6] = new PointF();\npoints[6].x = points[0].x;\npoints[6].x = points[0].x;\n\n// Now use these points to draw our asteroid\nfloat[] asteroidVertices = new float[]{\n// First point to second point\npoints[0].x, points[0].y, 0,\npoints[1].x, points[1].y, 0,\n```", "```java\nprivate static PointF rotatedPoint = new PointF();\n```", "```java\npublic static boolean detect(CollisionPackage cp1, \n    CollisionPackage cp2) {\n\n    boolean collided = false;\n\n   // Check circle collision between the two objects\n\n   // Get the distance of the two objects from\n   // the centre of the circles on the x axis\n   float distanceX = (cp1.worldLocation.x)\n        - (cp2.worldLocation.x);\n\n   // Get the distance of the two objects from\n   // the centre of the circles on the y axis\n   float distanceY = (cp1.worldLocation.y)\n        - (cp2.worldLocation.y);\n\n        // Calculate the distance between the center of each circle\n        double distance = Math.sqrt\n            (distanceX * distanceX + distanceY * distanceY);\n\n        // Finally see if the two circles overlap\n        // If they do it is worth doing the more intensive\n        // and accurate check.\n        if (distance < cp1.radius + cp2.radius) {\n\n         // Log.e(\"Circle collision:\",\"true\");\n         // todo  Eventually we will add the \n         // more accurate code here\n         // todo and delete the line below.\n\n            collided = true;\n        }\n\n        return collided;\n    }\n```", "```java\n// Check if anything hits the border\npublic static boolean contain(float mapWidth, float mapHeight,                                              \n  CollisionPackage cp) {\n\n   boolean possibleCollision = false;\n\n    // Check if any corner of a virtual rectangle\n    // around the centre of the object is out of bounds.\n    // Rectangle is best because we are testing \n    // against straight sides (the border)\n    // If it is we have a possible collision.\n\n    if (cp.worldLocation.x - cp.radius < 0) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.x + cp.radius > mapWidth) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.y - cp.radius < 0) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.y + cp.radius > mapHeight) {\n            possibleCollision = true;\n        }\n\n        if (possibleCollision) {\n            // todo For now we return true\n            return true;\n        }\n\n        return false; // No collision\n}\n```", "```java\npublic void lifeLost(){\n        // Reset the ship to the center\n        gm.ship.setWorldLocation(gm.mapWidth/2, gm.mapHeight/2);\n        // Play a sound\n        sm.playSound(\"shipexplode\");\n\n        // Deduct a life\n        gm.numLives = gm.numLives -1;\n\n        if(gm.numLives == 0){\n            gm.levelNumber = 1;\n            gm.numLives = 3;\n            createObjects();\n            gm.switchPlayingStatus();\n            sm.playSound(\"gameover\");\n        }\n    }\n```", "```java\npublic void destroyAsteroid(int asteroidIndex){\n\n  gm.asteroids[asteroidIndex].setActive(false);\n     // Play a sound\n     sm.playSound(\"explode\");\n     // Reduce the number of active asteroids\n     gm.numAsteroidsRemaining --;\n\n     // Has the player cleared them all?\n     if(gm.numAsteroidsRemaining == 0){\n     // Play a victory sound\n\n     // Increment the level number\n     gm.levelNumber ++;\n\n     // Extra life\n     gm.numLives ++;\n\n     sm.playSound(\"nextlevel\");\n     // Respawn everything\n     // With more asteroids\n     createObjects();\n\n}\n}\n}// End class\n```", "```java\n// End of all updates!!\n\n// All objects are in their new locations\n// Start collision detection\n\n// Check if the ship needs containing\nif (CD.contain(gm.mapWidth, gm.mapHeight, gm.ship.cp)) {\n\n  lifeLost();\n\n}\n```", "```java\n// Check if an asteroid needs containing\nfor (int i = 0; i < gm.numAsteroids; i++) {\n  if (gm.asteroids[i].isActive()) {\n       if (CD.contain(gm.mapWidth, gm.mapHeight, \n       gm.asteroids[i].cp)) {\n\n          // Bounce the asteroid back into the game\n          gm.asteroids[i].bounce();\n\n          // Play a sound\n          sm.playSound(\"blip\");\n\n       }\n    }\n\n}\n```", "```java\n// Check if bullet needs containing\n// But first see if the bullet is out of sight\n// If it is reset it to make game harder\nfor (int i = 0; i < gm.numBullets; i++) {\n\n    // Is the bullet in flight?\n    if (gm.bullets[i].isInFlight()) {\n\n   // Comment the next block to make the game easier!!!\n   // It will allow the bullets to go all the way from\n   // ship to border without being reset. \n   // These lines reset the bullet when\n   // shortly after they leave the players view.\n   // This forces the player to go 'hunting' for the\n   // asteroids instead of spinning round spamming the\n   // fire button...\n   // This code would be better with a viewport.clip() method\n   // like in project 2 but seems a bit excessive just for these\n   // few 15ish lines of code.\n\n   // Start comment out to make easier\n   handyPointF = gm.bullets[i].getWorldLocation();\n   handyPointF2 = gm.ship.getWorldLocation();\n\n   if(handyPointF.x > handyPointF2.x + gm.metresToShowX / 2){\n        // Reset the bullet\n        gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n\n    }else\n        if(handyPointF.x < handyPointF2.x - gm.metresToShowX / 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n\n        }else\n        if(handyPointF.y > handyPointF2.y + gm.metresToShowY/ 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n       }else\n        if(handyPointF.y < handyPointF2.y - gm.metresToShowY / 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n                }\n            // End comment out to make easier\n\n            // Does bullet need containing?\n            if (CD.contain(gm.mapWidth, gm.mapHeight,      \n                gm.bullets[i].cp)) {\n\n                 // Reset the bullet\n                 gm.bullets[i].resetBullet\n                    (gm.ship.getWorldLocation());\n                 // Play a sound\n                 sm.playSound(\"ricochet\");\n          }\n\n     }\n\n}\n```", "```java\n// Now we see if anything has hit an asteroid\n\n// Check collisions between asteroids and bullets\n// Loop through each bullet and asteroid in turn\n\nfor (int bulletNum = 0; bulletNum < gm.numBullets; bulletNum++) {\n    for (int asteroidNum = 0; asteroidNum < gm.numAsteroids;                            \n        asteroidNum++) {\n\n        // Check that the current bullet is in flight\n        // and the current asteroid is \n        // active before proceeding\n        if (gm.bullets[bulletNum].isInFlight() &&                                           \n            gm.asteroids[asteroidNum].isActive())\n\n            // Perform the collision checks by \n            // passing in the collision packages\n\n            // A Bullet only has one vertex. \n            // Our collision detection works on vertex pairs\n\n          if (CD.detect(gm.bullets[bulletNum].cp,                                           \n              gm.asteroids[asteroidNum].cp)) {\n\n                // If we get a hit...\n                destroyAsteroid(asteroidNum);\n\n                // Reset the bullet\n                gm.bullets[bulletNum].resetBullet\n                    (gm.ship.getWorldLocation());\n           }\n\n    }\n}\n```", "```java\n// Check collisions between asteroids and ship\n// Loop through each asteroid in turn\n\nfor (int asteroidNum = 0; asteroidNum < gm.numAsteroids;                            \n     asteroidNum++) {\n\n    // Is the current asteroid active before proceeding\n    if (gm.asteroids[asteroidNum].isActive()) {\n\n        // Perform the collision checks by\n        // passing in the collision packages\n        if (CD.detect(gm.ship.cp, gm.asteroids[asteroidNum].cp)) {\n\n        // hit!\n        destroyAsteroid(asteroidNum);\n        lifeLost();\n       }\n    }\n}\n```", "```java\nif (possibleCollision) {\n\n double radianAngle = ((cp.facingAngle/180)*Math.PI);\n double cosAngle = Math.cos(radianAngle);\n double sinAngle = Math.sin(radianAngle);\n\n```", "```java\n    //Rotate each and every vertex then check for a collision\n    // If just one is then we have a collision.\n    // Once we have a collision no need to check further\n    for (int i = 0 ; i < cp.vertexListLength; i++){\n        // First update the regular un-rotated model space coordinates\n        // relative to the current world location (centre of object)\n        float worldUnrotatedX = \n                cp.worldLocation.x + cp.vertexList[i].x;\n\n        float worldUnrotatedY =  \n                cp.worldLocation.y + cp.vertexList[i].y;\n\n        // Now rotate the newly updated point, stored in currentPoint\n        // around the centre point of the object (worldLocation)\n        cp.currentPoint.x = cp.worldLocation.x + (int)                                   \n            ((worldUnrotatedX - cp.worldLocation.x)\n            * cosAngle - (worldUnrotatedY - cp.worldLocation.y)\n            * sinAngle);\n\n        cp.currentPoint.y = cp.worldLocation.y + (int)                                   \n            ((worldUnrotatedX - cp.worldLocation.x)\n            * sinAngle+(worldUnrotatedY - cp.worldLocation.y)\n            * cosAngle);\n```", "```java\n     // Check the rotated vertex for a collision\n     if (cp.currentPoint.x < 0) {\n\n       return true;\n     } else if (cp.currentPoint.x > mapWidth) {\n\n       return true;\n     } else if (cp.currentPoint.y < 0) {\n\n       return true;\n     } else if (cp.currentPoint.y > mapHeight) {\n\n       return true;\n   }\n\n}\n```", "```java\n     if (distance < cp1.radius + cp2.radius) {\n\n            double radianAngle1 = ((cp1.facingAngle / 180) * Math.PI);\n            double cosAngle1 = Math.cos(radianAngle1);\n            double sinAngle1 = Math.sin(radianAngle1);\n\n            double radianAngle2 = ((cp2.facingAngle / 180) * Math.PI);\n            double cosAngle2 = Math.cos(radianAngle2);\n            double sinAngle2 = Math.sin(radianAngle2);\n\n            int numCrosses = 0;    // The number of times we cross a side\n\n            float worldUnrotatedX;\n            float worldUnrotatedY;\n```", "```java\nfor (int i = 0; i < cp1.vertexListLength; i++) {\n\n    worldUnrotatedX = cp1.worldLocation.x + cp1.vertexList[i].x;\n    worldUnrotatedY = cp1.worldLocation.y + cp1.vertexList[i].y;\n\n    // Now rotate the newly updated point, stored in currentPoint\n    // around the centre point of the object (worldLocation)\n    cp1.currentPoint.x = cp1.worldLocation.x +\n        (int) ((worldUnrotatedX - cp1.worldLocation.x)\n        * cosAngle1 - (worldUnrotatedY - cp1.worldLocation.y) *\n        sinAngle1);\n\n    cp1.currentPoint.y = cp1.worldLocation.y + \n        (int) ((worldUnrotatedX - cp1.worldLocation.x)\n        * sinAngle1 + (worldUnrotatedY - cp1.worldLocation.y) *                   \n         cosAngle1);\n\n    // cp1.currentPoint now hold the x/y \n    // world coordinates of the first point to test\n```", "```java\n// Use two vertices at a time to represent the line we are testing\n// We don't test the last vertex because we are testing pairs\n// and the last vertex of cp2 is the padded extra vertex.\n// It will form part of the last side when we test vertexList[5]\n\nfor (int j = 0; j < cp2.vertexListLength - 1; j++) {\n\n    // Now we get the rotated coordinates of \n    // BOTH the current 2 points being\n    // used to form a side from cp2 (the asteroid)\n    // First we need to rotate the model-space \n    // coordinate we are testing\n    // to its current world position\n    // First update the regular un-rotated model space coordinates\n    // relative to the current world location (centre of object)\n\n    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[j].x;\n    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[j].y;\n\n    // Now rotate the newly updated point, stored in worldUnrotatedX/y\n    // around the centre point of the object (worldLocation)\n\n    cp2.currentPoint.x = cp2.worldLocation.x + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   \n          sinAngle2);\n\n    cp2.currentPoint.y = cp2.worldLocation.y + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   \n          cosAngle2);\n\n    // cp2.currentPoint now hold the x/y world coordinates\n    // of the first point that\n    // will represent a line from the asteroid\n\n    // Now we can do exactly the same for the \n    // second vertex and store it in\n    // currentPoint2\\. We will then have a point and a line (two \n    // vertices)we can use the\n    // crossing number algorithm on.\n\n    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[i + 1].x;\n    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[i + 1].y;\n\n    // Now rotate the newly updated point, stored in worldUnrotatedX/Y\n    // around the centre point of the object (worldLocation)\n    cp2.currentPoint2.x = cp2.worldLocation.x + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   \n          sinAngle2);\n\n    cp2.currentPoint2.y = cp2.worldLocation.y + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   \n           cosAngle2);\n```", "```java\n// And now we can test the rotated point from cp1 against the\n// rotated points which form a side from cp2\n\nif (((cp2.currentPoint.y > cp1.currentPoint.y) !=                               \n       (cp2.currentPoint2.y > cp1.currentPoint.y)) &&\n       (cp1.currentPoint.x < (cp2.currentPoint2.x -                                \n     cp2.currentPoint2.x)    *(cp1.currentPoint.y - \n        cp2.currentPoint.y) / (cp2.currentPoint2.y  -                               \n  cp2.currentPoint.y) + cp2.currentPoint.x)){\n\n        numCrosses++;\n\n}\n```", "```java\n            }\n            }\n            // So do we have a collision?\n            if (numCrosses % 2 == 0) {\n                // even number of crosses(outside asteroid)\n                collided = false;\n            } else {\n                // odd number of crosses(inside asteroid)\n                collided = true;\n            }\n\n        }// end if\n```", "```java\n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />\n```"]