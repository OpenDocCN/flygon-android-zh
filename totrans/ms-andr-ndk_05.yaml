- en: Chapter 5. Cross-platform Audio Streaming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 跨平台音频流
- en: In this chapter, we consider the last non-visual component needed to build interactive
    mobile applications. We are looking for a truly portable implementation of audio
    playback for Android and desktop PCs. We propose using the OpenAL library, since
    it is a well-established library on desktop platforms. Audio playback is inherently
    an asynchronous process, so the decoding and submitting of data to the sound API
    should be done on a separate thread. We will create an audio streaming library
    based on the multi-threading code from [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Networking"),
    *Networking*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑构建交互式移动应用程序所需的最后一个非视觉组件。我们寻找的是一个真正可移植的音频播放实现，适用于Android和桌面PC。我们建议使用OpenAL库，因为它在桌面平台上已经非常成熟。音频播放本质上是一个异步过程，因此解码并将数据提交给声音API应该在单独的线程上完成。我们将基于[第三章](part0035.xhtml#aid-11C3M2
    "第三章. 网络编程")的*网络编程*中的多线程代码创建一个音频流库。
- en: Raw uncompressed audio can take up a lot of memory, so compressed formats of
    different flavors are used quite often. We consider some of them in this chapter
    and will show you how to play them in Android using native C++ code and popular
    third-party libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 原始未压缩音频可能占用大量内存，因此经常使用不同种类的压缩格式。我们将在本章考虑其中一些格式，并展示如何使用原生C++代码和流行的第三方库在Android中播放它们。
- en: Initialization and playback
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化和播放
- en: We use the OpenAL cross-platform audio library throughout this chapter. In order
    to make all the examples simple and self-contained, we start with the minimalistic
    example which can play a sound from an uncompressed `.wav` file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节我们将使用跨平台的OpenAL音频库。为了使所有示例保持简洁且自包含，我们从可以播放未压缩`.wav`文件的最小化示例开始。
- en: Let's briefly describe what we need to do in order to produce sound. The routines
    of OpenAL manipulate objects encountered in the playback and recording processes.
    The `ALCdevice` object represents a unit of audio hardware. Since multiple threads
    may produce sound at the same time, another object called `ALCcontext` is introduced.
    First, an application opens a device and then a context is created and attached
    to the opened device. Each context maintains a number of `Audio Source` objects,
    because even a single application might need to play multiple sounds simultaneously.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述一下产生声音需要做些什么。OpenAL的例程处理播放和录音过程中遇到的对象。`ALCdevice`对象代表音频硬件的一个单元。由于多个线程可能同时产生声音，因此引入了另一个名为`ALCcontext`的对象。首先，应用程序打开一个设备，然后创建一个上下文并将其附加到打开的设备上。每个上下文都维护着多个`Audio
    Source`对象，因为即使单个应用程序也可能需要同时播放多个声音。
- en: We are getting close to actual sound production. One more object is required
    as a waveform container, which is called a buffer. An audio recording can be quite
    lengthy, so we don't submit the entire sound as a single buffer. We read samples
    in small chunks and submit these chunks using several buffers, usually a couple,
    into the audio source's queue.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近实际的声音产生。还需要一个对象作为波形容器，这称为缓冲区。音频录音可能相当长，所以我们不会将整个声音作为一个缓冲区提交。我们以小块读取样本，并使用几个缓冲区（通常是一对）将这些块提交到音频源的队列中。
- en: 'The following pseudo-code depicts how to play a sound which fits entirely into
    memory:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码描述了如何播放完全适合内存的声音：
- en: First open a device, create a context, and attach the context to the device.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开一个设备，创建一个上下文，并将上下文附加到设备上。
- en: Create an audio source, allocate a single sound buffer.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个音频源，分配一个声音缓冲区。
- en: Load waveform data into the buffer.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将波形数据加载到缓冲区中。
- en: Enqueue the buffer to the audio source.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓冲区入队到音频源。
- en: Wait until playback is complete.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待播放完成。
- en: Destroy the buffer, the source, and the context and close the device.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁缓冲区、源和上下文，并关闭设备。
- en: There is an apparent problem at step 5\. We cannot block the UI thread of the
    application for a couple of seconds, thus the sound playback must be asynchronous.
    Fortunately, the OpenAL calls are thread-safe and we can perform playback in a
    separate thread without doing any OpenAL synchronization ourselves.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步有一个明显的问题。我们无法将应用程序的UI线程阻塞几秒钟，因此声音播放必须是异步的。幸运的是，OpenAL调用是线程安全的，我们可以在没有自己进行任何OpenAL同步的情况下在单独的线程中执行播放。
- en: Let's check the example `1_InitOpenAL`. To perform waveform loading in step
    3 and keep the code as simple as possible, we take a `.wav` file and load it into
    a `clBlob` object. In step 2, we create an audio source and a buffer with parameters
    corresponding to those inside the `WAV` header. Steps 1, 4, and 6 consist only
    of some OpenAL API calls. Step 5 is done via a busy-wait loop on an atomic conditional
    variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查示例`1_InitOpenAL`。为了在步骤3中执行波形加载并尽可能保持代码简单，我们取一个`.wav`文件并将其加载到`clBlob`对象中。在步骤2中，我们创建一个音频源和缓冲区，其参数与`WAV`头中的参数相对应。步骤1、4和6仅包含一些OpenAL
    API调用。步骤5通过在原子条件变量上进行忙等待循环来完成。
- en: 'The native C++ entry point for this example starts by creating a separate audio
    thread declared as a global object `g_Sound`. The `g_FS` object contains an instance
    of the `clFileSystem` class used to load audio data from files:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的本地C++入口点从创建一个单独的音频线程开始，该线程声明为全局对象`g_Sound`。`g_FS`对象包含`clFileSystem`类的实例，用于从文件加载音频数据：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `clSoundThread` class contains an OpenAL device and a context. The audio
    source and buffer handles are also declared for this one-source-one-buffer example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSoundThread`类包含一个OpenAL设备和上下文。音频源和缓冲区句柄也为此单一源单一缓冲区的示例而声明：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The method `Run()` does all the initialization, loading, and finalization:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()`方法负责所有初始化、加载和结束工作：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To use OpenAL routines, we should load the library. For Android, Linux, and
    OS X, the implementation is easy, we just use a statically linked library and
    that is it. However, for Windows, we load the `OpenAL32.dll` file and retrieve
    all the necessary function pointers from the dynamic link library:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用OpenAL例程，我们应该加载库。对于Android、Linux和OS X，实现很简单，我们只需使用静态链接库即可。然而，对于Windows，我们加载`OpenAL32.dll`文件，并从动态链接库中获取所有必要的函数指针：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we open a device and create a context. The `nullptr` argument for `alcOpenDevice()`
    means that we are using the default sound device:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开一个设备并创建一个上下文。`alcOpenDevice()`的`nullptr`参数意味着我们正在使用默认的音频设备：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we create an audio source and set its volume to the maximum level:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个音频源并将其音量设置为最大级别：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Loading of the waveform, which corresponds to the step 3 in our pseudo-code,
    is done by reading the entire `.wav` file into the `clBlob` object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 波形的加载，对应于我们伪代码中的第3步，通过将整个`.wav`文件读取到`clBlob`对象中完成：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The header can be accessed the following way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式访问头文件：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We copy bytes from `clBlob` into the sound buffer, skipping the number of bytes
    corresponding to the size of the header:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`clBlob`中复制字节到声音缓冲区，跳过头文件对应大小的字节数：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let us just busy-wait for the sound to finish:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们忙等待声音播放完毕：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At the end, we stop the source, delete all the objects and unload the OpenAL
    library:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们停止源，删除所有对象并卸载OpenAL库：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `clSoundThread` class also contains two helper methods. The `IsPlaying()`
    method checks if the sound is still playing by requesting its state:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`clSoundThread`类还包含两个辅助方法。`IsPlaying()`方法通过请求其状态来检查声音是否仍在播放：'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `PlayBuffer()` method creates a buffer object, fills it with the waveform
    from the `Data` parameter and starts playback:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayBuffer()`方法创建一个缓冲区对象，用`Data`参数中的波形填充它并开始播放：'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code relies on two global functions. `Env_Sleep()` sleeps for
    a given amount of milliseconds. The Windows version of the code differs slightly
    from Android and OS X:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码依赖于两个全局函数。`Env_Sleep()`函数以给定的毫秒数休眠。Windows版本的代码与Android和OS X略有不同：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use `Sleep()` with Windows in order to be compatible with some MinGW distros
    that lack support for `std::chrono`. If you want to use Visual Studio, just stick
    to `std::this_thread::sleep_for()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Windows上使用`Sleep()`以与一些缺乏对`std::chrono`支持的MinGW发行版兼容。如果你想要使用Visual Studio，只需坚持使用`std::this_thread::sleep_for()`。
- en: The `LoadFileAsBlob()` function uses the provided `clFileSystem` object to load
    the contents of a file into the memory block. We reuse this routine in most of
    our subsequent code samples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadFileAsBlob()`函数使用提供的`clFileSystem`对象将文件内容加载到内存块中。我们在后续的大部分代码示例中重复使用这个例程。'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you compile and run this example on a desktop machine by typing `make all`,
    you should hear a short ding sound. Let us proceed further and learn how to do
    sound streaming before we end up with an Android application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在桌面机器上通过输入`make all`编译并运行此示例，你应该能听到一个短暂的叮当声。在我们结束Android应用程序之前，让我们进一步了解如何进行声音流处理。
- en: Streaming sounds
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式声音
- en: 'Now that we can play short audio samples, it is time to organize our audio
    system into classes and take a closer look at the `2_Streaming` example. Long
    audio samples, such as background music, require a lot of memory in a decompressed
    form. Streaming is a technique to decompress them in small chunks, piece by piece.
    The `clAudioThread` class manages the initialization and does everything from
    the previous sample except playing the sound:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够播放短音频样本，是时候将音频系统组织成类，并仔细查看`2_Streaming`示例了。长音频样本（如背景音乐）在解压缩形式下需要大量内存。流式传输是一种小块小块地、逐片解压缩它们的技术。`clAudioThread`类负责初始化并处理除播放声音之外的所有工作：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This method is used to synchronize the start of the audio thread with its users:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将音频线程的开始与其用户同步：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `clAudioSource` class represents a single sound producing entity. The wave
    data is not stored in the source itself and we postpone the description of the
    `clAudioSource` class. Right now, we introduce the `iWaveDataProvider` interface
    class which provides the data for the next audio buffer. The reference to an `iWaveDataProvider`
    instance is stored in the `clAudioSource` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`clAudioSource`类代表单一声音产生实体。波形数据不是存储在源本身中，我们推迟对`clAudioSource`类的描述。现在，我们介绍提供下一个音频缓冲区数据的`iWaveDataProvider`接口类。对`iWaveDataProvider`实例的引用存储在`clAudioSource`类中：'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The audio signal properties are stored in these three fields:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 音频信号属性存储在这三个字段中：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Two pure virtual methods give access to the current wave data played by the
    audio source. They are to be implemented in the actual decoder subclasses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 两个纯虚方法提供了对音频源当前播放的波形数据的访问。它们应在实际的解码器子类中实现：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `IsStreaming()` method tells us if this provider represents a continuous
    stream or a single chunk of audio data, like the one in the previous example.
    The `StreamWaveData()` method loads, decodes, or generates values in the buffer
    accessed by the `GetWaveData()` function; it is usually implemented in subclasses
    as well. When `clAudioSource` needs more audio data to enqueue into a buffer,
    it invokes the `StreamWaveData()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsStreaming()`方法告诉我们此提供程序是否代表连续流或如前一个示例中的单个音频数据块。`StreamWaveData()`方法加载、解码或生成`GetWaveData()`函数访问的缓冲区中的值；它通常也在子类中实现。当`clAudioSource`需要更多音频数据以排队进入缓冲区时，它会调用`StreamWaveData()`方法：'
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last auxiliary function returns the internal data format used by OpenAL.
    Here we support only stereo and mono signals with 8 or 16 bits per sample:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助函数返回OpenAL使用的内部数据格式。这里我们只支持每样本8位或16位的立体声和单声道信号：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our basic sound decoding is done in the `clStreamingWaveDataProvider` class.
    It contains the `FBuffer` data vector and the number of useful bytes in it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本声音解码是在`clStreamingWaveDataProvider`类中完成的。它包含`FBuffer`数据向量和其中的有用字节数：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are ready to describe the class `clAudioSource` which does the actual heavy
    lifting. The constructor creates an OpenAL audio source object, sets the volume
    level and disables looping:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备描述实际执行繁重任务的`clAudioSource`类。构造函数创建一个OpenAL音频源对象，设置音量级别并禁用循环：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have two different use cases. If the attached `iWaveDataProvider` supports
    streaming, we need to create and maintain at least two sound buffers. Both buffers
    are enqueued to the OpenAL playback queue and swapped as soon as one of them finishes
    playing. At each swapping event, we call the `StreamWaveData()` method of `iWaveDataProvider`
    to stream the data into the next audio buffer. If the `iWaveDataProvider` is not
    streamed, we only need a single buffer which is initialized at the beginning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的使用场景。如果附加的`iWaveDataProvider`支持流式传输，我们需要创建并维护至少两个声音缓冲区。这两个缓冲区都被加入到OpenAL播放队列中，并在其中一个缓冲区播放完成后进行交换。在每次交换事件中，我们调用`iWaveDataProvider`的`StreamWaveData()`方法将数据流式传输到下一个音频缓冲区。如果`iWaveDataProvider`不支持流式传输，我们只需要一个在开始时初始化的单个缓冲区。
- en: 'The `Play()` method fills both buffers with decoded data and calls `alSourcePlay()`
    to start playback:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play()`方法用解码后的数据填充两个缓冲区，并调用`alSourcePlay()`开始播放：'
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Stop()` and `Pause()` methods call appropriate OpenAL routines to stop
    and pause playback respectively:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop()`和`Pause()`方法分别调用适当的OpenAL例程来停止和暂停播放：'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `LoopSound()` and `SetVolume()` methods control playback parameters:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopSound()`和`SetVolume()`方法控制播放参数：'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `IsPlaying()` method is copied from the previous example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPlaying()`方法是从上一个示例中复制而来的：'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `StreamBuffer()` method writes the newly generated audio data into one
    of the buffers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamBuffer()`方法将新产生的音频数据写入其中一个缓冲区：'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Update()` method should be called often enough to prevent audio buffers
    from underflow. However, this method only matters if the attached `iWaveDataProvider`
    represents an audio stream:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法应该足够频繁地被调用，以防止音频缓冲区出现下溢。然而，只有当附加的 `iWaveDataProvider` 表示音频流时，此方法才重要：'
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We ask OpenAL how many buffers have been processed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们询问 OpenAL 已经处理了多少个缓冲区：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We remove each processed buffer from the queue and call `StreamBuffer()` to
    decode more data. Finally, we readd the buffer to the playback queue:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从队列中移除每个已处理的缓冲区，并调用 `StreamBuffer()` 来解码更多数据。最后，我们将缓冲区重新加入播放队列：
- en: '[PRE31]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The destructor stops playback and destroys the OpenAL audio source and buffers:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数会停止播放并销毁 OpenAL 音频源和缓冲区：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `BindWaveform()` method attaches a new `iWaveDataProvider` to this audio
    source instance:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindWaveform()` 方法将一个新的 `iWaveDataProvider` 附加到这个音频源实例：'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For a streaming `iWaveDataProvider`, we need two buffers. One is being played
    while the other is being updated:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于流式的 `iWaveDataProvider`，我们需要两个缓冲区。一个正在播放，另一个正在更新：
- en: '[PRE34]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the attached waveform is not a stream or, more specifically, it is not compressed,
    we create a single buffer and copy all the data into it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果附加的波形不是流式，或者更具体地说，它不是压缩的，我们会创建一个单一缓冲区并将所有数据复制到其中：
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The private `UnqueueAll()` method uses `alSourceUnqueueBuffers()` to clear
    the OpenAL playback queue:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法 `UnqueueAll()` 使用 `alSourceUnqueueBuffers()` 来清除 OpenAL 播放队列：
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The tail part of this class defines the reference to the attached `iWaveDataProvider`,
    internal handles of OpenAL objects, and the number of allocated buffers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类的尾部部分定义了附加的 `iWaveDataProvider` 的引用，OpenAL 对象的内部句柄以及已分配缓冲区的数量：
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To demonstrate some basic streaming capabilities, we change the sample code
    from `1_InitOpenAL` and create an audio source with the attached tone generator,
    described in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一些基本的流式处理能力，我们更改了 `1_InitOpenAL` 的示例代码，并创建了一个带有附加音调发生器的音频源，如下代码所示：
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we deliberately avoid the problem of decompressing the sound
    to focus on the streaming logic. So we start with a procedurally generated sound.
    The `clToneGenerator` class overrides the `StreamWaveData()` method and generates
    a sine wave, or a pure tone. To avoid audible glitches, we have to sample the
    sine function carefully and remember the integer index of the last generated sample.
    This index is stored in the `FLastOffset` field and used in calculations in each
    iteration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们故意避免了解压缩声音的问题，以便专注于流式处理逻辑。因此，我们从程序生成的声音开始。`clToneGenerator` 类重写了 `StreamWaveData()`
    方法并生成正弦波，即纯音调。为了避免可听见的故障，我们必须仔细采样正弦函数并记住最后一个生成样本的整数索引。这个索引存储在 `FLastOffset` 字段中，并在每次迭代中的计算中使用。
- en: 'The constructor of the class sets audio parameters to 16-bit 44.1kHz and allocates
    some space in the `FBuffer` container. The base frequency of this tone is set
    to 440 Hz:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数将音频参数设置为16位 44.1kHz，并在 `FBuffer` 容器中分配一些空间。这个音调的基本频率设置为440 Hz：
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `StreamWaveData()`, we check for available space in the `FBuffer` vector
    and reallocate it if necessary:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StreamWaveData()` 中，我们检查 `FBuffer` 向量中是否有可用空间，并在必要时重新分配它：
- en: '[PRE40]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we calculate the audio sample. The frequency is recalculated based
    on the sample count:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算音频样本。频率会根据样本数量重新计算：
- en: '[PRE41]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since we need `Size` bytes and our signal contains two channels with 16-bit
    samples, we need a total of `Size/4` samples:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要 `Size` 字节，并且我们的信号包含两个声道，每个声道16位样本，因此我们需要总共 `Size/4` 个样本：
- en: '[PRE42]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We convert the floating point value into the 16-bit signed integer and put
    low and high bytes of this integer into `FBuffer`. For each channel, we store
    two bytes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将浮点数值转换为16位有符号整数，并将此整数的低字节和高字节放入 `FBuffer` 中。对于每个声道，我们存储两个字节：
- en: '[PRE43]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the calculation, we increment the sample count and take the remainder
    to avoid integer overflow in the counter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 计算后，我们增加样本计数并取余数，以避免计数器中的整数溢出：
- en: '[PRE44]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The compiled example will produce a pure tone of 440 Hz. We encourage you to
    change the value of `clToneGenerator::FFrequency` and see how it works. You can
    even create a simple tuning fork application for your musical instruments using
    this example. As for musical instruments, let's generate some audio data to mimic
    a stringed musical instrument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的示例将产生一个440 Hz的纯音调。我们鼓励您更改 `clToneGenerator::FFrequency` 的值，看看它是如何工作的。您甚至可以使用此示例为您的乐器创建一个简单的音叉应用程序。至于乐器，让我们生成一些模仿弦乐器的音频数据。
- en: Stringed musical instrument model
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弦乐器的音乐模型
- en: Let's implement a simple physical model of a stringed musical instrument using
    the code from the previous example. Later you can use these routines to create
    a small interactive synthesizer for Android.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前一个示例的代码来实现一个简单的弦乐器物理模型。稍后你可以使用这些例程为Android创建一个小型的交互式合成器。
- en: The string is modelled as a sequence of point masses oscillating vertically.
    Strictly speaking, we solve the linear one-dimensional wave equation with certain
    initial and boundary conditions. The sound is produced by taking values of the
    solution at the position of sound pickup.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 弦被建模为一系列垂直振动的点质量。严格来说，我们求解具有特定初始和边界条件的线性一维波动方程。声音是通过在声音接收位置取得解的值来产生的。
- en: 'We need the `clGString` class to store all the model values and the final result.
    The method `GenerateSound()` precalculates string parameters and resizes the data
    containers accordingly:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`clGString`类来存储所有的模型值和最终结果。`GenerateSound()`方法会预先计算字符串参数，并相应地调整数据容器的大小：
- en: '[PRE45]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Frc` value is the normalized fundamental frequency of the sound. Overtones
    are implicitly created by the physical model:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frc`值是声音的规范化基频。泛音是由物理模型隐式创建的：'
- en: '[PRE46]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After the initialization stage, we perform integration of the wave equation
    by calling the `Step()` method in a loop. The `Step()` member function returns
    the displacement of the string at the pickup position:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化阶段之后，我们通过在循环中调用`Step()`方法来执行波动方程的积分。`Step()`成员函数返回弦在接收位置处的位移：
- en: '[PRE47]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At each step, we clamp the value to the maximum:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步，我们将值限制在最大值：
- en: '[PRE48]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we convert floating point values to signed short integers. To avoid
    overflows, each sample is divided by the `MaxS` value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将浮点数值转换为有符号短整型。为了避免溢出，每个样本都要除以`MaxS`的值：
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We place the sound pickup closer to the end:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声音接收器放置在靠近末尾的位置：
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For better results, we produce a slight variation in the mass of a string element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的结果，我们在弦元素的质地上产生轻微的变化：
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At the beginning, we set non-zero velocities for the second part of the string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们为弦的第二部分设置非零速度：
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `frand()` member function returns a pseudo-random floating point value
    in the 0..1 range:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`frand()`成员函数返回0..1范围内的伪随机浮点值：'
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The usage of `std::random` is the preferred way of getting a pseudo-random number
    if your compiler supports it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器支持，使用`std::random`是获取伪随机数的首选方式。
- en: 'Here is the the way to generate a pseudo-random floating point number uniformly
    distributed in the range 0…1 using the new C++11 Standard Library:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用新的C++11标准库生成0…1范围内均匀分布的伪随机浮点数的方法：
- en: '[PRE54]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Though this short code snippet is not used in our source code bundle, it may
    be of use to you. Let us return to the code of our example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段简短的代码片段在我们的源代码包中未使用，但它可能对你有用。让我们回到我们示例的代码。
- en: 'The `Step()` method makes a single step and integrates the equations of the
    string motion. At the end of the step, a value from the `FPos` vector at the `FPickPos`
    position is taken as the next sample of the sound. For readers familiar with numerical
    methods, it might seem strange that there is no time step specification, implicitly
    it is 1/44100th of a second:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Step()`方法进行单步操作并整合弦运动的方程。在步骤结束时，从`FPos`向量在`FPickPos`位置的值作为声音的下一个样本。对于熟悉数值方法的读者来说，可能看起来很奇怪，因为没有指定时间步长，它是隐式为1/44100秒的：'
- en: '[PRE55]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At first, we enforce boundary conditions, those are fixed endpoints at both
    ends of the string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们强制施加边界条件，即弦两端的固定端点：
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'According to Hooke''s law ([http://en.wikipedia.org/wiki/Hooke''s_law](http://en.wikipedia.org/wiki/Hooke''s_law)),
    the force is proportional to the extension:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据胡克定律（[http://en.wikipedia.org/wiki/Hooke's_law](http://en.wikipedia.org/wiki/Hooke's_law)），力与伸长量成正比：
- en: '[PRE57]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To ensure numerical stability, we apply some artificial damping and take the
    average of the neighboring velocities. Failing to do so produces some unwanted
    tinkling sound:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数值稳定性，我们应用一些人工阻尼，并取相邻速度的平均值。如果不这样做，会产生一些不想要的声音：
- en: '[PRE58]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we update positions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新位置：
- en: '[PRE59]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To record our sound, we take only one position of the string:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录我们的声音，我们只取弦的一个位置：
- en: '[PRE60]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `1_InitOpenAL` example is easily modified to generate a string sound instead
    of loading a `.wav` file. We create the `clGString` instance and call the `GenerateSound()`
    method. After that, we get the `FSound` vector and submit it to the `PlayBuffer()`
    method of an audio source:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`1_InitOpenAL`示例可以轻松修改，以生成字符串声音，而不是加载`.wav`文件。我们创建`clGString`实例并调用`GenerateSound()`方法。之后，我们获取`FSound`向量并将其提交给音频源的`PlayBuffer()`方法：'
- en: '[PRE61]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, the sampling rate is hardcoded at 44100 Hz. Try the `3_GuitarStringSound`
    example for the complete code and hear it for yourself. Note that the startup
    time may be a bit high due to heavy pre-calculations before the sound can be played.
    However, the code is very simple and we leave it as an exercise to the reader
    to compile it for Android, taking all the necessary makefiles and wrappers from
    the subsequent examples. And in the meantime, we will do the stuff that can be
    run on Android out-of-the-box.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，采样率被硬编码为44100 Hz。尝试`3_GuitarStringSound`示例以获取完整代码并亲自聆听。请注意，由于在播放声音之前需要进行大量预计算，启动时间可能会稍长。然而，代码非常简单，我们将其作为一个练习留给读者，让他们为Android编译，并从后续示例中获取所有必要的makefile和包装器。同时，我们将处理那些可以立即在Android上运行的内容。
- en: Decoding compressed audio
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码压缩音频
- en: 'Now that we have implemented the basic audio streaming system, it is time to
    use a couple of third-party libraries to read compressed audio files. Basically,
    what we need to do is to override the `StreamWaveData()` function inside the `clStreamingWaveDataProvider`
    class. This function, in turn, calls the `ReadFromFile()` method where the actual
    decoding is done. The initialization of the decoder is done in the constructor
    and, for the abstract `iDecodingProvider` class, we only store the reference to
    a data blob. All the compressed data for the file is stored in a `clBlob` object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了基本的音频流系统，是时候使用几个第三方库来读取压缩的音频文件了。基本上，我们需要做的是覆盖`clStreamingWaveDataProvider`类中的`StreamWaveData()`函数。这个函数反过来调用`ReadFromFile()`方法，实际解码就在这里完成。解码器的初始化在构造函数中进行，对于抽象的`iDecodingProvider`类，我们只存储对数据块引用。文件的所有压缩数据都存储在`clBlob`对象中：
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `StreamWaveData()` method does the job of decoding. The first few lines
    ensure there is enough space in `FBuffer` to contain the decoded data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWaveData()`方法负责解码工作。前几行确保`FBuffer`有足够的空间来包含解码后的数据：'
- en: '[PRE63]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After the buffer is reallocated, we fill new bytes with zeroes, because non-zero
    values can produce unexpected noise:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配缓冲区后，我们用零填充新字节，因为非零值可能会产生意外的噪音：
- en: '[PRE64]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since `ReadFromFile()` may return insufficient data, we call it in a loop incrementing
    the number of bytes read:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ReadFromFile()`可能会返回不充分的数据，我们以循环的方式调用它，并增加读取的字节数：
- en: '[PRE65]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The return value of zero from `ReadFromFile()` means we have reached the end
    of the stream:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromFile()`返回零意味着我们已达到流末尾：'
- en: '[PRE66]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Looping is done by calling `Seek()` and setting the `FEof` flag:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Seek()`并设置`FEof`标志来实现循环：
- en: '[PRE67]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A negative value in `Ret` indicates a reading error has occurred. We stop decoding
    in this case:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ret`中的负值表示发生了读取错误。在这种情况下，我们停止解码：'
- en: '[PRE68]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The next two sections show how to decode different formats of audio files using
    popular third-party libraries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两节将展示如何使用流行的第三方库解码不同格式的音频文件。
- en: Decoding tracker music using the ModPlug library
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ModPlug库解码跟踪器音乐
- en: 'The first library we will tackle to decode audio files is the ModPlug library
    by Olivier Lapicque. Most popular tracker music file formats [http://en.wikipedia.org/wiki/Module_file](http://en.wikipedia.org/wiki/Module_file)
    can be decoded and converted into the waveform suitable for OpenAL using ModPlug.
    We will introduce the `clModPlugProvider` class which implements the `ReadFromFile()`
    routine. The constructor of the class loads the memory blob into the `ModPlugFile`
    object and assigns default audio parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个用于解码音频文件的库是Olivier Lapicque的ModPlug库。大多数流行的跟踪器音乐文件格式[http://en.wikipedia.org/wiki/Module_file](http://en.wikipedia.org/wiki/Module_file)可以使用ModPlug解码并转换为适合OpenAL的波形。我们将介绍实现`ReadFromFile()`例程的`clModPlugProvider`类。该类的构造函数将内存块加载到`ModPlugFile`对象中，并分配默认的音频参数：
- en: '[PRE69]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The destructor cleans up ModPlug:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数清理ModPlug：
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `ReadFromFile()` method calls `ModPlug_Read()` to fill `FBuffer`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromFile()`方法调用`ModPlug_Read()`来填充`FBuffer`：'
- en: '[PRE71]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Stream positioning is done using the `ModPlug_Seek()` routine. Inside the ModPlug
    API, all the timing is done in milliseconds:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 流定位是通过使用`ModPlug_Seek()`例程完成的。在ModPlug API内部，所有的时间计算都是以毫秒为单位的：
- en: '[PRE72]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To use this wave data provider, we attach its instance to a `clAudioSource`
    object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个波形数据提供者，我们将其实例附加到`clAudioSource`对象：
- en: '[PRE73]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Other details are reused from our previous examples. The `4_ModPlug` folder
    can be built and run on Android as well as on Windows. Use `ndk-build` and `ant`
    `debug` to create `.apk` for Android, and `make all` to create a Windows executable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其他细节是从我们之前的示例中复用的。`4_ModPlug`文件夹可以在Android和Windows上构建和运行。使用`ndk-build`和`ant
    debug`为Android创建`.apk`，使用`make all`创建Windows可执行文件。
- en: Decoding MP3 files
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码MP3文件
- en: 'Most of the patents for the MPEG-1 Layer 3 format expire by the end of the
    year 2015, so it is worth mentioning the MiniMP3 library by Fabrice Bellard. Using
    this library is not harder than ModPlug, because we have already done all the
    grunt work in `iDecodingProvider`. Let''s take a look at the `5_MiniMP3` example.
    The `clMP3Provider` class creates the decoder instance and reads stream parameters
    by reading some frames from the beginning:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MPEG-1 Layer 3格式的多数专利在2015年底到期，因此值得提及Fabrice Bellard的MiniMP3库。使用这个库不会比ModPlug更难，因为我们已经在`iDecodingProvider`中完成了所有繁重的工作。让我们看看`5_MiniMP3`示例。`clMP3Provider`类创建了解码器实例，并通过读取开头的几帧来读取流参数：
- en: '[PRE74]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At the beginning, we set the stream position to the beginning of the `clBlob`
    object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们将流位置设置为`clBlob`对象的开始处：
- en: '[PRE75]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We need the information about the audio data, so we fetch it from the `info`
    structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关于音频数据的信息，因此我们从`info`结构中获取它：
- en: '[PRE76]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'There is nothing special in the destructor, here it is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数中没有特别之处，以下是它的样子：
- en: '[PRE77]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `ReadFromFile()` method keeps track of the bytes left in the source stream
    and fills the `FBuffer` container. Both the constructor and this method use the
    `bytes_left` and `stream_pos` fields to keep the current stream position and the
    remaining number of bytes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromFile()`方法跟踪源流中剩余的字节数，并填充`FBuffer`容器。构造函数和这个方法都使用`bytes_left`和`stream_pos`字段来保持当前的流位置和剩余的字节数：'
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Seeking is not so obvious with variable bitrate streams, so we leave this implementation
    as an exercise for the interested reader. The simplest case with a fixed bitrate
    should just recalculate `Time` from seconds to sample rate units and then set
    the `stream_pos` variable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变比特率的流，寻道并不是那么明显，因此我们将这个实现留给感兴趣的读者作为一个练习。在固定比特率的最简单情况下，只需从秒重新计算`Time`到采样率单位，然后设置`stream_pos`变量：
- en: '[PRE79]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To use it, we attach the provider to a `clAudioSource` object, just like with
    ModPlug:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们将提供者附加到`clAudioSource`对象，就像使用ModPlug一样：
- en: '[PRE80]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Again, this example is runnable on Android, just go and try it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个示例可以在Android上运行，去试试吧。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This code does not deal properly with some ID3 tags. If you want to write a
    generic music player based on our code, refer to this open source project written
    by the authors: [https://github.com/corporateshark/PortAMP](https://github.com/corporateshark/PortAMP).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有正确处理一些ID3标签。如果你想基于我们的代码编写一个通用的音乐播放器，可以参考作者编写的这个开源项目：[https://github.com/corporateshark/PortAMP](https://github.com/corporateshark/PortAMP)。
- en: Decoding OGG files
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码OGG文件
- en: 'There is yet another popular audio format worth mentioning. Ogg Vorbis is a
    completely open, patent-free, professional audio encoding and streaming technology
    with all the benefits of Open Source [http://www.vorbis.com](http://www.vorbis.com).
    The big picture of the OGG decoding and playback process is similar to that of
    MP3\. Let''s take a look at the example `6_OGG`. The `Decoders.cpp` file is extended
    with definitions of the OGG Vorbis functions `OGG_clear_func()`, `OGG_open_callbacks_func()`,
    `OGG_time_seek_func()`, `OGG_read_func()`, `OGG_info_func()`, and `OGG_comment_func()`.
    The functions are linked against a static library on Android or loaded from a
    `.dll` file on Windows. The main difference compared to MiniMP3 API is in providing
    a set of data reading callbacks to the OGG decoder. These callbacks are implemented
    in the `OGG_Callbacks.inc` file. The `OGG_ReadFunc()` callback reads data into
    the decoder:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个值得提及的流行音频格式。Ogg Vorbis是一种完全开放、无专利、专业的音频编码和流媒体技术，具有开源的所有好处[http://www.vorbis.com](http://www.vorbis.com)。OGG解码和播放过程的大致流程与MP3类似。让我们看看示例`6_OGG`。`Decoders.cpp`文件用OGG
    Vorbis函数的定义进行了扩展，包括`OGG_clear_func()`、`OGG_open_callbacks_func()`、`OGG_time_seek_func()`、`OGG_read_func()`、`OGG_info_func()`和`OGG_comment_func()`。这些函数在Android上链接到一个静态库，或者在Windows上从`.dll`文件加载。与MiniMP3
    API的主要区别在于向OGG解码器提供一组数据读取回调。这些回调在`OGG_Callbacks.inc`文件中实现。`OGG_ReadFunc()`回调将数据读取到解码器中：
- en: '[PRE81]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It is based on our filesystem abstraction and memory mapped files:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于我们的文件系统抽象和内存映射文件：
- en: '[PRE82]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `OGG_SeekFunc()` callback seeks the input stream using different relative
    positioning modes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`OGG_SeekFunc()` 回调使用不同的相对定位模式来查找输入流：'
- en: '[PRE83]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `OGG_CloseFunc()` and `OGG_TellFunc()` functions are trivial:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`OGG_CloseFunc()` 和 `OGG_TellFunc()` 函数非常简单：'
- en: '[PRE84]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'These callbacks are used in the constructor of `clOggProvider` to set up the
    decoder:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调在 `clOggProvider` 的构造函数中使用，以设置解码器：
- en: '[PRE85]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The stream parameters, like the number of channels, sampling rate and bits
    per sample, are retrieved here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 流参数（如通道数、采样率和每样本位数）在这里获取：
- en: '[PRE86]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The destructor is trivial:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数非常简单：
- en: '[PRE87]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `ReadFromFile()` and `Seek()` methods are pretty much similar in spirit
    to what we have done when dealing with MiniMP3:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFromFile()` 和 `Seek()` 方法在精神上与我们处理 MiniMP3 时所做的非常相似：'
- en: '[PRE88]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is the place where the callbacks mentioned in the preceding section are
    defined. Of course, they can be defined in-place instead of moving them into a
    separate file. However, we find this kind of separation more logical for this
    example; separating logically, the data provider concept and `OGG Vorbis` related
    APIs:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在前面章节提到的回调函数定义的地方。当然，它们可以在原地定义，而不必将它们移到单独的文件中。然而，我们认为这种分离对于本例来说在逻辑上更为清晰；将数据提供者概念和
    `OGG Vorbis` 相关 API 逻辑上分开：
- en: '[PRE89]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This example is also Android-capable out-of-the-box. Run the following command
    to get the `.apk` on your device:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也开箱即用，支持 Android。运行以下命令以在您的设备上获取 `.apk`：
- en: '[PRE90]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now start the activity and enjoy the music! In subsequent chapters we will add
    more interesting audio stuff on top of the material from this chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动活动，享受音乐吧！在后续章节中，我们将在本章内容的基础上添加更多有趣的音频内容。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to play audio on Android using portable C++
    code and open source third-party libraries. The provided examples are capable
    of playing `.mp3`, and `.ogg` audio files along with `.it`, `.xm`, `.mod`, and
    `.s3m` modules. We also learnt how to generate your own waveforms to simulate
    musical instruments. The code is portable across many systems and can be run and
    debugged on Android and Windows. Now, once we are done with audio, it is time
    to proceed to the next chapter and render some graphics with OpenGL.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用可移植的 C++ 代码和开源第三方库在 Android 上播放音频。提供的示例能够播放 `.mp3` 和 `.ogg` 音频文件以及
    `.it`、`.xm`、`.mod` 和 `.s3m` 模块。我们还学习了如何生成自己的波形来模拟乐器。代码可以在许多系统间移植，并且可以在 Android
    和 Windows 上运行和调试。现在，我们已经完成了音频部分，是时候进入下一章，使用 OpenGL 渲染一些图形了。
