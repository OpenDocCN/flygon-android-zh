- en: Chapter 5. Cross-platform Audio Streaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we consider the last non-visual component needed to build interactive
    mobile applications. We are looking for a truly portable implementation of audio
    playback for Android and desktop PCs. We propose using the OpenAL library, since
    it is a well-established library on desktop platforms. Audio playback is inherently
    an asynchronous process, so the decoding and submitting of data to the sound API
    should be done on a separate thread. We will create an audio streaming library
    based on the multi-threading code from [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Networking"),
    *Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: Raw uncompressed audio can take up a lot of memory, so compressed formats of
    different flavors are used quite often. We consider some of them in this chapter
    and will show you how to play them in Android using native C++ code and popular
    third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the OpenAL cross-platform audio library throughout this chapter. In order
    to make all the examples simple and self-contained, we start with the minimalistic
    example which can play a sound from an uncompressed `.wav` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly describe what we need to do in order to produce sound. The routines
    of OpenAL manipulate objects encountered in the playback and recording processes.
    The `ALCdevice` object represents a unit of audio hardware. Since multiple threads
    may produce sound at the same time, another object called `ALCcontext` is introduced.
    First, an application opens a device and then a context is created and attached
    to the opened device. Each context maintains a number of `Audio Source` objects,
    because even a single application might need to play multiple sounds simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting close to actual sound production. One more object is required
    as a waveform container, which is called a buffer. An audio recording can be quite
    lengthy, so we don't submit the entire sound as a single buffer. We read samples
    in small chunks and submit these chunks using several buffers, usually a couple,
    into the audio source's queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudo-code depicts how to play a sound which fits entirely into
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: First open a device, create a context, and attach the context to the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an audio source, allocate a single sound buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load waveform data into the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enqueue the buffer to the audio source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until playback is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destroy the buffer, the source, and the context and close the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is an apparent problem at step 5\. We cannot block the UI thread of the
    application for a couple of seconds, thus the sound playback must be asynchronous.
    Fortunately, the OpenAL calls are thread-safe and we can perform playback in a
    separate thread without doing any OpenAL synchronization ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the example `1_InitOpenAL`. To perform waveform loading in step
    3 and keep the code as simple as possible, we take a `.wav` file and load it into
    a `clBlob` object. In step 2, we create an audio source and a buffer with parameters
    corresponding to those inside the `WAV` header. Steps 1, 4, and 6 consist only
    of some OpenAL API calls. Step 5 is done via a busy-wait loop on an atomic conditional
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The native C++ entry point for this example starts by creating a separate audio
    thread declared as a global object `g_Sound`. The `g_FS` object contains an instance
    of the `clFileSystem` class used to load audio data from files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clSoundThread` class contains an OpenAL device and a context. The audio
    source and buffer handles are also declared for this one-source-one-buffer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `Run()` does all the initialization, loading, and finalization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To use OpenAL routines, we should load the library. For Android, Linux, and
    OS X, the implementation is easy, we just use a statically linked library and
    that is it. However, for Windows, we load the `OpenAL32.dll` file and retrieve
    all the necessary function pointers from the dynamic link library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we open a device and create a context. The `nullptr` argument for `alcOpenDevice()`
    means that we are using the default sound device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create an audio source and set its volume to the maximum level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading of the waveform, which corresponds to the step 3 in our pseudo-code,
    is done by reading the entire `.wav` file into the `clBlob` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The header can be accessed the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We copy bytes from `clBlob` into the sound buffer, skipping the number of bytes
    corresponding to the size of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us just busy-wait for the sound to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we stop the source, delete all the objects and unload the OpenAL
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clSoundThread` class also contains two helper methods. The `IsPlaying()`
    method checks if the sound is still playing by requesting its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PlayBuffer()` method creates a buffer object, fills it with the waveform
    from the `Data` parameter and starts playback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code relies on two global functions. `Env_Sleep()` sleeps for
    a given amount of milliseconds. The Windows version of the code differs slightly
    from Android and OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use `Sleep()` with Windows in order to be compatible with some MinGW distros
    that lack support for `std::chrono`. If you want to use Visual Studio, just stick
    to `std::this_thread::sleep_for()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoadFileAsBlob()` function uses the provided `clFileSystem` object to load
    the contents of a file into the memory block. We reuse this routine in most of
    our subsequent code samples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run this example on a desktop machine by typing `make all`,
    you should hear a short ding sound. Let us proceed further and learn how to do
    sound streaming before we end up with an Android application.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can play short audio samples, it is time to organize our audio
    system into classes and take a closer look at the `2_Streaming` example. Long
    audio samples, such as background music, require a lot of memory in a decompressed
    form. Streaming is a technique to decompress them in small chunks, piece by piece.
    The `clAudioThread` class manages the initialization and does everything from
    the previous sample except playing the sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is used to synchronize the start of the audio thread with its users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clAudioSource` class represents a single sound producing entity. The wave
    data is not stored in the source itself and we postpone the description of the
    `clAudioSource` class. Right now, we introduce the `iWaveDataProvider` interface
    class which provides the data for the next audio buffer. The reference to an `iWaveDataProvider`
    instance is stored in the `clAudioSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The audio signal properties are stored in these three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Two pure virtual methods give access to the current wave data played by the
    audio source. They are to be implemented in the actual decoder subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsStreaming()` method tells us if this provider represents a continuous
    stream or a single chunk of audio data, like the one in the previous example.
    The `StreamWaveData()` method loads, decodes, or generates values in the buffer
    accessed by the `GetWaveData()` function; it is usually implemented in subclasses
    as well. When `clAudioSource` needs more audio data to enqueue into a buffer,
    it invokes the `StreamWaveData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last auxiliary function returns the internal data format used by OpenAL.
    Here we support only stereo and mono signals with 8 or 16 bits per sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our basic sound decoding is done in the `clStreamingWaveDataProvider` class.
    It contains the `FBuffer` data vector and the number of useful bytes in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to describe the class `clAudioSource` which does the actual heavy
    lifting. The constructor creates an OpenAL audio source object, sets the volume
    level and disables looping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have two different use cases. If the attached `iWaveDataProvider` supports
    streaming, we need to create and maintain at least two sound buffers. Both buffers
    are enqueued to the OpenAL playback queue and swapped as soon as one of them finishes
    playing. At each swapping event, we call the `StreamWaveData()` method of `iWaveDataProvider`
    to stream the data into the next audio buffer. If the `iWaveDataProvider` is not
    streamed, we only need a single buffer which is initialized at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Play()` method fills both buffers with decoded data and calls `alSourcePlay()`
    to start playback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Stop()` and `Pause()` methods call appropriate OpenAL routines to stop
    and pause playback respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoopSound()` and `SetVolume()` methods control playback parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsPlaying()` method is copied from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StreamBuffer()` method writes the newly generated audio data into one
    of the buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Update()` method should be called often enough to prevent audio buffers
    from underflow. However, this method only matters if the attached `iWaveDataProvider`
    represents an audio stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We ask OpenAL how many buffers have been processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We remove each processed buffer from the queue and call `StreamBuffer()` to
    decode more data. Finally, we readd the buffer to the playback queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor stops playback and destroys the OpenAL audio source and buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BindWaveform()` method attaches a new `iWaveDataProvider` to this audio
    source instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For a streaming `iWaveDataProvider`, we need two buffers. One is being played
    while the other is being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the attached waveform is not a stream or, more specifically, it is not compressed,
    we create a single buffer and copy all the data into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The private `UnqueueAll()` method uses `alSourceUnqueueBuffers()` to clear
    the OpenAL playback queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail part of this class defines the reference to the attached `iWaveDataProvider`,
    internal handles of OpenAL objects, and the number of allocated buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate some basic streaming capabilities, we change the sample code
    from `1_InitOpenAL` and create an audio source with the attached tone generator,
    described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we deliberately avoid the problem of decompressing the sound
    to focus on the streaming logic. So we start with a procedurally generated sound.
    The `clToneGenerator` class overrides the `StreamWaveData()` method and generates
    a sine wave, or a pure tone. To avoid audible glitches, we have to sample the
    sine function carefully and remember the integer index of the last generated sample.
    This index is stored in the `FLastOffset` field and used in calculations in each
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the class sets audio parameters to 16-bit 44.1kHz and allocates
    some space in the `FBuffer` container. The base frequency of this tone is set
    to 440 Hz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In `StreamWaveData()`, we check for available space in the `FBuffer` vector
    and reallocate it if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the audio sample. The frequency is recalculated based
    on the sample count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need `Size` bytes and our signal contains two channels with 16-bit
    samples, we need a total of `Size/4` samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We convert the floating point value into the 16-bit signed integer and put
    low and high bytes of this integer into `FBuffer`. For each channel, we store
    two bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After the calculation, we increment the sample count and take the remainder
    to avoid integer overflow in the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The compiled example will produce a pure tone of 440 Hz. We encourage you to
    change the value of `clToneGenerator::FFrequency` and see how it works. You can
    even create a simple tuning fork application for your musical instruments using
    this example. As for musical instruments, let's generate some audio data to mimic
    a stringed musical instrument.
  prefs: []
  type: TYPE_NORMAL
- en: Stringed musical instrument model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement a simple physical model of a stringed musical instrument using
    the code from the previous example. Later you can use these routines to create
    a small interactive synthesizer for Android.
  prefs: []
  type: TYPE_NORMAL
- en: The string is modelled as a sequence of point masses oscillating vertically.
    Strictly speaking, we solve the linear one-dimensional wave equation with certain
    initial and boundary conditions. The sound is produced by taking values of the
    solution at the position of sound pickup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the `clGString` class to store all the model values and the final result.
    The method `GenerateSound()` precalculates string parameters and resizes the data
    containers accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Frc` value is the normalized fundamental frequency of the sound. Overtones
    are implicitly created by the physical model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After the initialization stage, we perform integration of the wave equation
    by calling the `Step()` method in a loop. The `Step()` member function returns
    the displacement of the string at the pickup position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At each step, we clamp the value to the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we convert floating point values to signed short integers. To avoid
    overflows, each sample is divided by the `MaxS` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We place the sound pickup closer to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For better results, we produce a slight variation in the mass of a string element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, we set non-zero velocities for the second part of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frand()` member function returns a pseudo-random floating point value
    in the 0..1 range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usage of `std::random` is the preferred way of getting a pseudo-random number
    if your compiler supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the the way to generate a pseudo-random floating point number uniformly
    distributed in the range 0…1 using the new C++11 Standard Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Though this short code snippet is not used in our source code bundle, it may
    be of use to you. Let us return to the code of our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Step()` method makes a single step and integrates the equations of the
    string motion. At the end of the step, a value from the `FPos` vector at the `FPickPos`
    position is taken as the next sample of the sound. For readers familiar with numerical
    methods, it might seem strange that there is no time step specification, implicitly
    it is 1/44100th of a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, we enforce boundary conditions, those are fixed endpoints at both
    ends of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'According to Hooke''s law ([http://en.wikipedia.org/wiki/Hooke''s_law](http://en.wikipedia.org/wiki/Hooke''s_law)),
    the force is proportional to the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure numerical stability, we apply some artificial damping and take the
    average of the neighboring velocities. Failing to do so produces some unwanted
    tinkling sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To record our sound, we take only one position of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `1_InitOpenAL` example is easily modified to generate a string sound instead
    of loading a `.wav` file. We create the `clGString` instance and call the `GenerateSound()`
    method. After that, we get the `FSound` vector and submit it to the `PlayBuffer()`
    method of an audio source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, the sampling rate is hardcoded at 44100 Hz. Try the `3_GuitarStringSound`
    example for the complete code and hear it for yourself. Note that the startup
    time may be a bit high due to heavy pre-calculations before the sound can be played.
    However, the code is very simple and we leave it as an exercise to the reader
    to compile it for Android, taking all the necessary makefiles and wrappers from
    the subsequent examples. And in the meantime, we will do the stuff that can be
    run on Android out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding compressed audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have implemented the basic audio streaming system, it is time to
    use a couple of third-party libraries to read compressed audio files. Basically,
    what we need to do is to override the `StreamWaveData()` function inside the `clStreamingWaveDataProvider`
    class. This function, in turn, calls the `ReadFromFile()` method where the actual
    decoding is done. The initialization of the decoder is done in the constructor
    and, for the abstract `iDecodingProvider` class, we only store the reference to
    a data blob. All the compressed data for the file is stored in a `clBlob` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StreamWaveData()` method does the job of decoding. The first few lines
    ensure there is enough space in `FBuffer` to contain the decoded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After the buffer is reallocated, we fill new bytes with zeroes, because non-zero
    values can produce unexpected noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `ReadFromFile()` may return insufficient data, we call it in a loop incrementing
    the number of bytes read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value of zero from `ReadFromFile()` means we have reached the end
    of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Looping is done by calling `Seek()` and setting the `FEof` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A negative value in `Ret` indicates a reading error has occurred. We stop decoding
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The next two sections show how to decode different formats of audio files using
    popular third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding tracker music using the ModPlug library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first library we will tackle to decode audio files is the ModPlug library
    by Olivier Lapicque. Most popular tracker music file formats [http://en.wikipedia.org/wiki/Module_file](http://en.wikipedia.org/wiki/Module_file)
    can be decoded and converted into the waveform suitable for OpenAL using ModPlug.
    We will introduce the `clModPlugProvider` class which implements the `ReadFromFile()`
    routine. The constructor of the class loads the memory blob into the `ModPlugFile`
    object and assigns default audio parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor cleans up ModPlug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFromFile()` method calls `ModPlug_Read()` to fill `FBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Stream positioning is done using the `ModPlug_Seek()` routine. Inside the ModPlug
    API, all the timing is done in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this wave data provider, we attach its instance to a `clAudioSource`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Other details are reused from our previous examples. The `4_ModPlug` folder
    can be built and run on Android as well as on Windows. Use `ndk-build` and `ant`
    `debug` to create `.apk` for Android, and `make all` to create a Windows executable.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding MP3 files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the patents for the MPEG-1 Layer 3 format expire by the end of the
    year 2015, so it is worth mentioning the MiniMP3 library by Fabrice Bellard. Using
    this library is not harder than ModPlug, because we have already done all the
    grunt work in `iDecodingProvider`. Let''s take a look at the `5_MiniMP3` example.
    The `clMP3Provider` class creates the decoder instance and reads stream parameters
    by reading some frames from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, we set the stream position to the beginning of the `clBlob`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the information about the audio data, so we fetch it from the `info`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special in the destructor, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFromFile()` method keeps track of the bytes left in the source stream
    and fills the `FBuffer` container. Both the constructor and this method use the
    `bytes_left` and `stream_pos` fields to keep the current stream position and the
    remaining number of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeking is not so obvious with variable bitrate streams, so we leave this implementation
    as an exercise for the interested reader. The simplest case with a fixed bitrate
    should just recalculate `Time` from seconds to sample rate units and then set
    the `stream_pos` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To use it, we attach the provider to a `clAudioSource` object, just like with
    ModPlug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Again, this example is runnable on Android, just go and try it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code does not deal properly with some ID3 tags. If you want to write a
    generic music player based on our code, refer to this open source project written
    by the authors: [https://github.com/corporateshark/PortAMP](https://github.com/corporateshark/PortAMP).'
  prefs: []
  type: TYPE_NORMAL
- en: Decoding OGG files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is yet another popular audio format worth mentioning. Ogg Vorbis is a
    completely open, patent-free, professional audio encoding and streaming technology
    with all the benefits of Open Source [http://www.vorbis.com](http://www.vorbis.com).
    The big picture of the OGG decoding and playback process is similar to that of
    MP3\. Let''s take a look at the example `6_OGG`. The `Decoders.cpp` file is extended
    with definitions of the OGG Vorbis functions `OGG_clear_func()`, `OGG_open_callbacks_func()`,
    `OGG_time_seek_func()`, `OGG_read_func()`, `OGG_info_func()`, and `OGG_comment_func()`.
    The functions are linked against a static library on Android or loaded from a
    `.dll` file on Windows. The main difference compared to MiniMP3 API is in providing
    a set of data reading callbacks to the OGG decoder. These callbacks are implemented
    in the `OGG_Callbacks.inc` file. The `OGG_ReadFunc()` callback reads data into
    the decoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'It is based on our filesystem abstraction and memory mapped files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OGG_SeekFunc()` callback seeks the input stream using different relative
    positioning modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OGG_CloseFunc()` and `OGG_TellFunc()` functions are trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'These callbacks are used in the constructor of `clOggProvider` to set up the
    decoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The stream parameters, like the number of channels, sampling rate and bits
    per sample, are retrieved here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFromFile()` and `Seek()` methods are pretty much similar in spirit
    to what we have done when dealing with MiniMP3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the place where the callbacks mentioned in the preceding section are
    defined. Of course, they can be defined in-place instead of moving them into a
    separate file. However, we find this kind of separation more logical for this
    example; separating logically, the data provider concept and `OGG Vorbis` related
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is also Android-capable out-of-the-box. Run the following command
    to get the `.apk` on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now start the activity and enjoy the music! In subsequent chapters we will add
    more interesting audio stuff on top of the material from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to play audio on Android using portable C++
    code and open source third-party libraries. The provided examples are capable
    of playing `.mp3`, and `.ogg` audio files along with `.it`, `.xm`, `.mod`, and
    `.s3m` modules. We also learnt how to generate your own waveforms to simulate
    musical instruments. The code is portable across many systems and can be run and
    debugged on Android and Windows. Now, once we are done with audio, it is time
    to proceed to the next chapter and render some graphics with OpenGL.
  prefs: []
  type: TYPE_NORMAL
