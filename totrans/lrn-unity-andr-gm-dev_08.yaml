- en: Chapter 8. Special Effects – Sound and Particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took a short break from our Monkey Ball game to
    learn about physics and 2D games in Unity. We created a clone of *Angry Birds*.
    The birds utilized physics to fly through the air and destroy the pigs and their
    structures. We utilized parallax scrolling to make a pleasing background effect.
    We also created a level selection screen, from which you can load the game's various
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we return to the Monkey Ball game. We are going to add many
    special effects that will round out the game experience. We will start by learning
    about the controls that Unity provides when working with audio. We will then move
    on to add some background music to the game and movement sounds for our monkey.
    Next, we will learn about particle systems, creating a dust trail for the monkey.
    Finally, we combine the effects explained in the chapter to create explosions
    for when the user collects bananas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following important topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio clips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing SFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding 2D and 3D SFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open up your Monkey Ball project and let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other assets, the Unity team has worked hard to make working with audio
    easy and hassle-free. Unity is capable of importing and utilizing a broad range
    of audio formats, allowing you to keep your files in a format that you can edit
    in another program.
  prefs: []
  type: TYPE_NORMAL
- en: Import settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Audio clips have a small assortment of important settings. They let you easily
    control the type and compression of files. The following screenshot shows the
    settings that we have to work with while importing audio clips:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Import settings](img/4691OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The options in the preceding screenshot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Force To Mono**: This checkbox will cause Unity to change a multichannel
    file to have a single channel of audio data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load In Background**: This will cause the initial loading of an audio file
    to not pause the whole game while it is loading the game into memory. It is best
    to use this for large files that do not need to be used right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preload Audio Data**: This will cause the audio information to be loaded
    as soon as possible. This is best for small files that need to be used almost
    immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load Type**: This controls how the file is loaded when the game is being
    played; you can choose from the following three available options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decompress On Load**: This removes compression from the file when it is first
    needed. The overhead for this option makes it a very poor choice for large files.
    This option is best for short sounds that you often hear, such as gunfire in a
    shooting game.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed In Memory**: This only decompresses the file as it is being played.
    When it is just being held in memory, the file remains compressed. This is a good
    option for short- and medium-length sounds that are not heard often.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming**: This loads in the audio as it is playing, such as streaming
    music or video from the Web. This option is best for things such as background
    music.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compression Format**: This allows you to select the kind of compression format
    to be used for reducing the size of your audio files. The **PCM** format will
    give you the largest file size and the best audio quality. The **Vorbis** format
    can give you the smallest file size, but the quality is reduced the smaller you
    go. The **ADPCM** format adapts to how the audio file is laid out, in order to
    give you a file size somewhere in the middle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality**: This is only used when **Vorbis** is selected as the compression
    format. A lower value will reduce the final size of the file in your project,
    but it will also introduce increasing amounts of artifacts to your audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sample Rate Setting**: This lets you determine how much detail from your
    audio files is maintained in Unity. The **Preserve Sample Rate** option will maintain
    the setting that was used in your original file. The **Optimize Sample Rate**
    option will allow Unity to choose a setting that works well for your file. The
    **Override Sample Rate** option will let you access the value of **Sample Rate**
    and select a specific setting for your audio. A smaller value will reduce the
    overall file size, at the cost of lowering the quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio Listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to actually hear anything in the game, every scene needs an **Audio
    Listener** component in it. By default, the `Main Camera` object (included first
    in any new scene) and any new camera you might create has an **Audio Listener**
    component attached. There can only be one **Audio Listener** component in your
    scene at a time. If there is more than one component or you try to play a sound
    when there isn't one, Unity will fill your console log with complaints and warnings.
    The **Audio Listener** component also gives the precise position for any 3D sound
    effects to key off.
  prefs: []
  type: TYPE_NORMAL
- en: Audio Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Audio Source** component is like a speaker, and it controls the settings
    used to play any sound effect. If the clip is 3D, the position of this object
    to the **Audio Listener** component and the mode chosen determine the volume of
    the clip. The following screenshot shows the various settings for an **Audio Source**
    component, followed by their explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Audio Source](img/4691OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**AudioClip**: This is the sound file that this **Audio Source** component
    will play, by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: For complex audio effects, one of Unity''s new **Audio Mixer**
    objects can be put here. These allow you to take specific control over the audio
    and over any effects or blending that might be applied to it, before it is finally
    played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mute**: This is a quick way to toggle the volume of the sound that is playing
    on and off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypass Effects**: This allows you to toggle any special filters applied to
    the **Audio Source** component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypass Listener Effect**: This allows the audio to ignore any special effects
    that might be applied to **Audio Listener**. This is a good setting for background
    music that should not be warped by the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypass Reverb Zones**: This allows you to control whether **Reverb Zones**,
    which control the transition areas in ambient audio, affect the sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play On Awake**: This will cause the audio clip to immediately start playing
    when the scene loads or the object is spawned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: This will cause the playing clip to repeat as it is played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: This dictates the relative importance of the files being played.
    The value `0` denotes the most important and best for music, while `256` denotes
    the least important file. Depending on the system, only so many sounds can be
    played at once. The list of files to be played starts with the most important
    and ends when this limit is reached, excluding those with the lowest values if
    there are more sounds than the limit will allow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: This decides how loud the clip will be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitch**: This scales the playback speed of the clip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stereo Pan**: This adjusts how evenly the sound comes out of each speaker,
    weighting it towards the left or right speaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spatial Blend**: This is the percentage of the 3D effects to be applied to
    the Audio Source component. This affects things such as the falloff and Doppler
    effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverb Zone Mix**: (Reverb zones are used to create transitions in ambient
    audio effects.) This setting lets you adjust how much effect these zones will
    have on the audio from this audio source.![Audio Source](img/4691OT_08_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The settings in the preceding screenshot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**3D Sound Settings**: This contains the group of settings that are specific
    to the playing of 3D audio clips. The **Volume**, **Spatial**, **Spread**, and
    **Reverb** options can be adjusted by using the graph at the end of the group.
    This allows you to create more dynamic transitions as the player approaches an
    **Audio Source** component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doppler Level**: This decides how much Doppler effect needs to be applied
    to moving sounds. Doppler effect is the change in pitch experienced as a source
    of sound moves closer or further away from you. A classic example is a car blaring
    its horn as it rushes by.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume Rolloff**: This controls how the volume fades with distance. There
    are three types of rolloffs:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logarithmic Rolloff**: This is a sudden and rapid falloff of the sound at
    a short distance from the source''s center.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Rolloff**: This is an even falloff with distance, the loudest being
    at the **Min Distance** value and the quietest at the **Max Distance** value.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom Rolloff**: This allows you to create a custom falloff by adjusting
    the graph at the end of the group. It is also automatically chosen when the graph
    is altered.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the **Audio Listener** component is closer than the **Min Distance** value,
    the audio will be played at the current volume level. Outside this distance, the
    sound will fall off, according to the **Rolloff** mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spread**: This adjusts the amount of area in speaker space that the sound
    covers. It becomes more important when working with more than one or two speakers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond the **Max Distance** value, the sound will stop transitioning, based
    on the graph at the bottom of the group.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know about the available audio settings, it is time to put that
    knowledge into action. We will start by adding some background music. This will
    have to be a 2D sound effect so that we can hear it comfortably, no matter where
    the **Audio Source** component is. We will also create a short script to fade-in
    the music, in order to reduce the suddenness with which sound effects bombard
    the player. We will use the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new script and name it `FadeIn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script begins with four variables. The first variable is the goal volume
    that the script has to reach. The second is the number of seconds that the transition
    will take. The third variable is the time when the transition began. The last
    variable keeps track of the **Audio Source** component attached to the same object
    as our script, allowing us to update it regularly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we make use of the `Awake` function. It begins by checking for an attached
    **Audio Source** component and filling our `source` variable with it. If one cannot
    be found, the **GameObject** is destroyed and the function is exited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Awake` function ends by setting the audio''s volume to `0` and starts
    playing it if it isn''t already playing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To cause the transition over time, we use the `Update` function. It will check
    whether the value of the `fadeStartTime` variable is below zero and set it to
    the current time if it is. This allows you to avoid the hiccup that can be caused
    by the initialization of a scene starting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the function checks whether the transition time has ended. If it has,
    the **Audio Source** component''s volume is set to `maxVolume` and the script
    is destroyed in order to free resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the current progress is calculated by finding the amount of time that
    has passed since the fade started and dividing it by the length of the transition.
    The resulting percentage of progress is multiplied by the value of `maxVolume`
    and applied to the **Audio Source** component''s volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in Unity, we need to create a new empty **GameObject** and name it `Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our `FadeIn` script and an **Audio Source** component to our object; these
    can be found by navigating to **Component** | **Audio** | **Audio Source**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not done so already, create an `Audio` folder in your **Project**
    panel and import the sound files included in the `Starting Assets` folder for
    the chapter. Because of the small size of these files and our current game, the
    default import settings for them will work just fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your `Background` object in the **Hierarchy** window and drag the `Background`
    sound to the **AudioClip** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the **Play On Awake** and **Loop** checkboxes are checked in
    the **Audio Source** component. Both the **Volume** and **Spatial Blend** options
    also need to be set to `0` to make the file play throughout the game, but make
    no noise when starting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added background music to our game. For the sound to be constant and not
    directional, we utilized the music as a 2D sound. We also created a script to
    fade in the music when the game starts. This eases the transition into the game
    for the player, preventing a sudden onslaught of sound. If your background music
    ends up being too loud to hear anything else in the game, reduce the **Max Volume**
    value in the **Inspector** panel of your `Background` object something more pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: Background music adds a lot to a game's experience. A horror scene is not nearly
    as scary without some scary music. Bosses are much less intimidating without their
    daunting music. Look for some good background music for your other games. Something
    light and cheery will work well for *Angry Birds*, while a piece that is more
    industrial and fast-paced will keep hearts racing through the Tank Battle game.
  prefs: []
  type: TYPE_NORMAL
- en: Poking bananas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand 3D audio effects, we are going to add a sound to the bananas,
    which will be triggered every time the player touches them. This will give the
    players extra feedback when they have successfully touched one of the bananas,
    while also giving some indication of the distance and direction of the banana
    that was touched. Let''s use these steps to create this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a new script named `BananaPoke`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script has one variable, `source`, to keep track of the **Audio Source**
    component attached to the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like in our previous script, we use the `Awake` function to find a reference
    to our **Audio Source** component, saving us a little bit of work in the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the player touches a banana on the screen, a message is sent to the banana
    that calls the `Touched` function. We used this function in our `BananaBounce`
    script to adjust its health, which we created in [Chapter 6](ch06.html "Chapter 6. Specialities
    of the Mobile Device – Touch and Tilt"), *Specialities of the Mobile Device*.
    We can again use it here to play our sound effect, if we have an **Audio Source**
    component. The `PlayOneShot` function uses an **Audio Source** component''s position
    and settings to play a quick sound effect. Without this, we will be unable to
    play many sound effects from the same **Audio Source** component in rapid succession.
    All we need to pass it is for the audio clip to be played. In this case, the audio
    clip is attached to the **Audio Source** component itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add our new script and an **Audio Source** component to the
    `Banana` prefab in our **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `BananaPoke` sound file needs to be dragged from the `Audio` folder to the
    new **Audio Source** component's **AudioClip** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you don't hear an annoying pop at the very beginning of the game, uncheck
    the **Play On Awake** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we want to hear the difference in the distance of the bananas we touch.
    Set the **Spatial Blend** setting to `1`, in order to turn it from a 2D sound
    effect to a 3D sound effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to change the value of **Volume Rolloff** to **Linear Rolloff**
    and set **Max Distance** to `50`. This gives us a comfortable and easily heard
    change in the volume of our sound effect based on distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Living in a 3D world, we expect most sounds to come from a specific direction
    and to fall off with distance. By creating a similar effect in our 3D games, the
    player is able to easily judge where things are in the game world and how far
    away they might be. This is especially important for games where the player needs
    to be able to hear potential enemies, obstacles, or rewards so that they will
    be able to find or avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Our Tank Battle game has many enemies that can easily sneak up on us, because
    they make no noise as they approach. Tanks are not generally recognized as quiet
    machines. Go find an engine's rumble sound or make it and add it to the enemy
    tanks. This will give the player some indication of where the enemies might be
    and how far away they are. Also, different types of tanks have different types
    of engines. Every engine sounds a little bit different. So, while you're at it,
    find different engine noises for each type of tank you have, giving the player
    even more indication of what dangers may lie just around the corner.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Particle systems add a lot to the final look of a game. They can take the form
    of fire, magic waves, rain, or a great many other effects that you can dream up.
    They are often hard to create well, but are well worth the effort if you do. Keep
    in mind, especially when working with the mobile platform, that less is more.
    Larger particles are more effective than a great amount of particles. If your
    particle system ever contains thousands of particles in a small space or is duplicated
    on itself to increase the effect, you need to rethink the design and find a more
    efficient solution.
  prefs: []
  type: TYPE_NORMAL
- en: Particle system settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every particle system contains a large variety of components, each with its
    own settings. Most of the available settings have the option to be **Constant**,
    **Curve**, **Random Between Two Constants**, and **Random Between Two Curves**.
    The **Constant** option will be a specific value. The **Curve** option will be
    a set value that changes along the curve over time. The two random settings select
    a random value between the respective value types. This may seem confusing at
    first, but as you work through them, they will become more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in the following screenshots and descriptions that follow,
    we will work through and gain an understanding of each piece of a particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first portion, the **Initial** module, of the particle system holds all
    the settings used by every emitter in Unity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**: This denotes the time for which an emitter lasts. A looping system
    will repeat itself after this amount of time. A nonlooping system will stop emitting
    new particles after this length of time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Looping**: This checkbox dictates whether or not the system loops.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prewarm**: This checkbox, if checked, will start a looping system if it has
    already had a chance to loop for a while. This is useful in the case of torches
    that should already be lit, not start when the player enters the room.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Delay**: This will stop the particle system from emitting for the given
    number of seconds, when it is initially triggered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Lifetime**: This is the number of seconds for which an individual particle
    will last.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Speed**: This is how fast a particle will initially move when spawned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Size**: This dictates how large a particle is when it is spawned. It
    is always better to use large particles rather than small and, hence, a greater
    number of particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Rotation**: This will rotate the emitted particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Color**: This is the color tint of the particles when they are spawned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity Modifier**: This gives the particles a greater or lesser amount of
    gravity effect.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inherit Velocity**: This will cause particles to gain a portion of their
    transform''s momentum if it is moving.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulation Space**: This determines whether the particles will stay with
    the game object as it is moved (that is, local) or remain where they are in the
    world.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play On Awake**: This checkbox, if checked, will cause the emitter to start
    emitting as soon as it is spawned or the scene starts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Particles**: This limits the total number of particles that this system
    supports at a single time. This value only comes into play if the rate at which
    particles are emitted (or their lifespan) is great enough to overbalance their
    rate of destruction.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Emission** module controls how fast the particles are emitted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate**: If this is set to **Time**, it denotes the number of particles that
    are created per second. If this is set to **Distance**, it denotes the number
    of particles per unit of the distance that the system travels as it moves.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bursts**: This is only used when the **Rate** option is set to **Time**.
    It allows you to set points in the system''s timeline when a specific number of
    particles will be emitted.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Shape** module, as shown in the preceding screenshot, controls how the
    system emits particles. It has the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shape**: This dictates what form the emission point will take. Each option
    comes with a few more value fields that determine its size.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere**: This is the point from which particles are emitted in all the directions.
    The **Radius** parameter determines the size of the sphere. The **Emit from Shell**
    option dictates whether the particles are emitted from the surface of the sphere
    or from within the volume.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HemiSphere**: This is, as the name suggests, the half of a sphere. The **Radius**
    parameter and the **Emit from Shell** option work the same here as they do for
    **Sphere**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cone**: This emits particles in one direction. The **Angle** parameter determines
    whether the shape is closer to a cone or cylinder. The **Radius** parameter dictates
    the size of the emission point of the shape. The **Length** parameter is used
    when the **Emit from** option is set to **Volume** or **Volume Shell**, to dictate
    how much space is available for spawning particles. The **Emit from** option will
    determine where the particles are emitted from. **Base** emits from the base disc
    of the shape. The **Base Shell** option emits from the base of the cone but around
    the surface of the shape. **Volume** will emit from anywhere inside the shape,
    and **Volume Shell** emits from the surface of the shape.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Box**: This emits particles from a cube-type shape. The **Box X**, **Box
    Y**, and **Box Z** options determine the size of the box.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh**: This allows you to select a model to use as an emission point. You
    then have the option of emitting particles from each **Vertex**, **Edge**, or
    **Triangle** that makes up the **Mesh**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circle**: This emits particles from a single point along a 2D plane. **Radius**
    determines the size of the emission, and **Arc** dictates how much of the circle
    is used. **Emit from Edge** decides whether the particles are emitted from the
    inner or outer edge of the circle.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: This emits particles in a single direction, out from a line. The
    **Radius** parameter determines how long the emission area is.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random Direction**: This determines whether a particle''s direction is determined
    by the surface normal of the shape chosen or whether it is chosen at random.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Velocity over Lifetime** module allows you to control the momentum of
    the particles after they have been spawned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X**, **Y**, and **Z**: These define the number of units per second along
    each axis of the particle''s momentum.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space**: This dictates whether the velocity is applied locally to the system''s
    transformation or relative to the world.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Limit Velocity over Lifetime** module dampens a particle''s movement
    if it exceeds the specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate Axis**: This allows you to define a value unique to each axis and
    whether that value is local or relative to the world.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: This is how fast the particle has to be moving before the damp is
    applied.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dampen**: This is a percentage of the speed by which the particle is cut.
    It can be any value between zero and one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Force over Lifetime** module adds a constant amount of movement to each
    particle over the course of its life:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X**, **Y**, and **Z**: These define how much force needs to be applied along
    each axis.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Space**: This dictates whether the force is applied local to the system''s
    transformation or in the world space.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Randomize**: If **X**, **Y**, and **Z** are random values, this will cause
    the amount of force to apply to be randomly picked in each frame, resulting in
    a statistical averaging of the random values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Color over Lifetime** module allows you to define a series of colors for
    the particle to transition through after it has been spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Color by Speed** module causes the particle to transition through the
    defined range of colors as its speed changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: This is the set of colors to transition through.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This defines how fast the particle must go, in order to be
    at the minimum and maximum ends of the **Color** range.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Size over Lifetime** module changes the size of the particle over the
    course of its life.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Size by Speed** module adjusts the size of each particle, based on how
    fast it is going, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: This is the adjustment that the particles transition through.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This defines the minimum and maximum values for each of the
    **Size** values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **Rotation over Lifetime** module rotates particles over time after they
    have been spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Rotation by Speed** module rotates particles more as they go faster:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Velocity**: This is the degrees per second speed of the particle''s
    rotation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Range**: This is the minimum and maximum range for the **Angular Velocity**
    value if it is not set to **Constant**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The **External Forces** module multiplies the effect of wind zone objects. Wind
    zones simulate the effects of wind on particle systems and on Unity's trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Collision** module allows particles to collide and interact with the
    physical game world:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If this is set to **Planes**, you can define a number of flat surfaces for
    the particles to collide with. This is faster to process than **World** collisions:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Planes**: This is a list of transformations that define the surfaces to collide
    with. Particles will only collide with the local, positive y side of the transform.
    Any particles on the other side of the point will be destroyed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization**: This gives you the option to view the planes as a **Solid**
    surface or as a **Grid** surface.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale Plane**: This adjusts the size of the **Visualization** option. It
    does not affect the actual size of the surface to collide with.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle Radius**: This is used to define the size of the sphere that is
    used to calculate the particle''s collision with the planes.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If set to **World**, the particles will collide with every collider in your
    scene. This can be a lot for the processor to handle.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collides With**: This defines a list of layers that the particles can collide
    with. Only the colliders on the layers that are checked in this list will be used
    for the collision calculation.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collision Quality**: This defines how precise the collision calculations
    are for this particle system. The **High** option will calculate precisely for
    every single particle. The **Medium** option will use an approximation and a limited
    number of new calculations in each frame. The **Low** option just calculates less
    often than **Medium** does. If **Collision Quality** is set to **Medium** or **Low**,
    the **Voxel Size** parameter dictates how precisely the system estimates the points
    of collision.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dampen**: This removes the defined fraction amount of speed from the particle
    when it collides with a surface.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounce**: This allows the particle to maintain the defined fraction of its
    speed, specifically along the normal of the surface that was hit.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifetime Loss**: This is the percentage of life. When the particle collides,
    this percentage of life is removed from the particle. When the particle''s life
    drops to zero over time, or through collision, it is removed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Kill Speed**: If, after collision, the particle''s speed is below this
    value, the particle is destroyed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Send Collision Messages**: If this checkbox is checked, scripts attached
    to the particle system and the object that was collided with will be alerted every
    frame that the collision took place. Only one message is sent per frame, not per
    particle.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Sub Emitters** module allows additional particle systems to be spawned
    at points in the life of each particle of this system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any particle systems in the **Birth** list will be spawned and will follow the
    particle when it is first created. This can be used to create a fireball or smoke
    trail.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Collision** list spawns particle systems when the particle hits something.
    This can be used for rain drop splashes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Death** list spawns particles when the particles are destroyed. It can
    be used to spawn a firework explosion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Texture Sheet Animation** module causes the particle to flip through
    a number of particles over the course of its life. The texture used is defined
    in the **Renderer** module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tiles**: This defines the number of rows and columns in the sheet. This will
    determine the total number of frames available.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation**: This gives you the options of **Whole Sheet** and **Single Row**.
    If this option is set to **Single Row**, the row used can either be chosen at
    random or specified by using the **Random Row** checkbox and the value of **Row**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame over Time**: This defines how the particle transitions between frames.
    If set to **Constant**, the system will only use a single frame.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycles**: This is the number of times the particle will loop through the
    animation over the course of its life.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Particle system settings](img/4691OT_08_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The **Renderer** module dictates how each particle is drawn on the screen,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Render Mode**: This defines which method a particle should use in order to
    orient itself in the game world:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Billboard**: This will always face the camera directly.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stretched Billboard**: This will face particles at the camera, but it will
    stretch them based on the speed of the camera, the particle''s speed, or by a
    specific value.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal Billboard**: This is flat on the XZ plane of the game world.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertical Billboard**: This will always face the player but will always stay
    straight along the Y axis.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If set to **Mesh**, you can define a model to be used as a particle, rather
    than a flat plane.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal Direction**: This is used for the lighting and shading of the particles
    by adjusting the normal of each plane. A value of **1** aims the normals directly
    at the camera, while a value of **0** aims them toward the center of the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material**: This defines the material that was used to render the particles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sort Mode**: This dictates the order in which the particles should be drawn,
    by distance or age.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting Fudge**: This causes particle systems to be drawn earlier than normal.
    The higher the value, the earlier it will be drawn on the screen. This affects
    whether the system appears in front of or behind other particle systems or partially
    transparent objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cast Shadows**: This determines whether or not the particles will block light.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Shadows**: This determines whether or not the particles are affected
    by the shadows cast by other objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Particle Size**: This is the total amount of screen space that a single
    particle is allowed to fill. No matter what the real size of the particle is,
    it will never fill more than this space of the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting Layer** and **Order in Layer**: These are used when working with
    a 2D game. These dictate what level it is on and where in that level it should
    be drawn, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection Probes**: These can also be used to reflect the world rather than
    just a particle. When the world is reflecting rather than a particle, **Anchor
    Override** can be used to define a custom position to sample reflections from.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That was a whole lot of information. You will use the **Initial**, **Emission**,
    and **Shape** modules most often. They control the main features of any particle
    system. To a slightly lesser degree, you will use the **Renderer** module to change
    the texture used for the particle system and the **Color over Lifetime** module
    to adjust the fade. All of these pieces, when used together effectively, will
    give you some really great effects that round out the look of any game. The absolute
    best way to learn what all they can do is to just play around with the settings
    and see what happens. Experimentation and a few tutorials, such as the next few
    sections, are the best ways to become an expert particle system creator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dust trails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To give our players a better sense that characters are actually in the world
    and touching it, they are often given the ability to kick up little dust clouds
    as they move around the environment. It is a small effect but adds a good bit
    of polish to any game. We are going to give our monkey ball the ability to kick
    up little dust clouds. Let''s use these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a new particle system, by navigating to **GameObject**
    | **Particle System**. Name it `DustTrail`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, particle systems shoot out little white balls in a cone shape. For
    the dust, we need something a little more interesting. Import the textures from
    the `Starting Assets` folder for the chapter to a `Particles` folder in your project.
    These are particle textures, provided by Unity, which were in the older versions
    of the engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create a new material in our `Particles` folder. Name it `DustPoof`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the new material's **Shader** property by going to **Particles** | **Alpha
    Blended** and put the `DustPoof` texture into the **Particle Texture** image slot.
    This changes the material to be partially transparent and to blend well with both
    the world and the other particles that are being emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the look of our `DustPoof` particle system, put the material in the
    **Material** slot of the **Renderer** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The particles in the system last too long and go too far, so set **Start Lifetime**
    to `0.5` and **Start Speed** to `0.2`. This will make the particles just rise
    up a little from the ground before disappearing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to make the particles more appropriate for the size of our monkey.
    Set **Start Size** to `0.3` in order to make them appropriately small.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a little weird to see all the particles in the exact same orientation.
    To make the orientations different, change **Start Rotation** to be **Random Between
    Two Constants** by clicking on the small down arrow to the right-hand side of
    the input field. Then, set the two new input fields to `-180` and `180`, so that
    all the particles have a random rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The brownish color of the particle is alright, but it doesn't always make sense
    with the color and nature of what our level terrain is made of. Click on the color
    field next to **Start Color** and use the **Color Picker** window that pops up
    to pick a new color based on the environment. This will allow the particles to
    make more sense when being kicked up from the surface of our game field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, for the **Initial** module, we need to set **Simulation Space** to **World**
    so that the particles are left behind as our monkey moves, rather than following
    him.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Emission**, we need to make sure that there are enough particles to give
    us a good amount of dust being kicked up. Set **Rate** to `20` for a light dusting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we are going to adjust the **Shape** module so that the particles are
    emitted under the whole area of the ball. Ensure that the **Shape** is set to
    **Cone**, the **Angle** to `25`, and the **Radius** to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **Color over Lifetime** module, we can ease the sudden appearance and
    disappearance of the particles. Hit the checkbox at the left-hand side of the
    module's name to activate it. Click on the white bar at the right-hand side of
    **Color** to open the **Gradient Editor** window. In **Gradient Editor**, clicking
    just above the colored bar will add a new flag that will control the transparency
    of the particles over their lifetime. The left-hand side of this bar corresponds
    to the very beginning of a particle's life, and the right-hand side corresponds
    to the end of its life. We need a total of four flags. One at the very beginning,
    with the value of **Alpha** set to `0`, a second flag with a **Location** value
    of `20` and **Alpha** value of `255`, the third flag at a **Location** of `50`
    and **Alpha** of `255`, and the last flag at the very end with an **Alpha** value
    of `0`. This will cause the dust particles to fade in quickly at the beginning
    and fade out slowly after that, easing their transition into and out of existence.![Creating
    dust trails](img/4691OT_08_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can further ease the transition by using the **Size over Lifetime** module
    to make the particles grow and shrink as they come into and out of existence.
    Be sure to activate it with the checkbox by its name. By clicking on the curve
    bar at the right-hand side of **Size**, the **Particle System Curves** editor
    opens in the preview area at the bottom of the **Inspector** panel. Here, we can
    adjust any of the little diamond-shaped keys to control the size of the particles
    over the course of its life. Just as in the case of **Gradient Editor**, the left-hand
    side is the beginning of the particle's life and the right is the end. By right-clicking
    on it, we can add new keys to control the curve. To create a pop-in effect, put
    the first key at the bottom in the far left side. The second key should go at
    the top and correspond with the `0.2` value at the bottom. The third will work
    well at the top and `0.4` with the bottom values. The fourth should be at the
    far right and set at about `0.6` with the numbers on the left, which indicate
    the percentage of its **Start Size** that we set in the **Initial** module, as
    shown in the following screenshot:![Creating dust trails](img/4691OT_08_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, to complete the look of our particle system, we are going to use the
    **Rotation over Lifetime** module to add a little bit of spin to the particles.
    Change the value to **Random Between Two Constants** and set the two value fields
    to `-45` and `45` to make the particles spin a little over the course of their
    lives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that our monkey can use the particle system, make it a child of the `MonkeyPivot`
    object, and set its position to `0` for **X**, `-0.5` for **Y**, and `0` for **Z**.
    Also, make sure that the rotation is set to `270` for **X**, `0` for **Y**, and
    `0` for **Z**. This will keep it at the base of our monkey ball and throw particles
    into the air. Because it is a child of `MonkeyPivot`, it will not spin around
    with the ball, because we already made the object compensate for the spinning
    of the ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it out. As our monkey moves around, he leaves a nice little trail of dust
    in his wake. This effect can be a great bit of polish, especially if we tailor
    it to the material that the level is made out of, whether it be grass, sand, wood,
    metal, or anything else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might notice that the effect continues to play, even as our monkey flies
    off the edge of our map. We are going to create a new script to toggle the particles
    based on whether or not our monkey ball is actually touching the ground. Create
    a new script named `DustTrail` now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first variable for this script will hold a reference to the particle system
    we are trying to control. The second will be a flag that indicates whether or
    not the ball is actually touching the ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `OnCollisionStay` function to determine whether the ball is touching
    anything. This function is similar to the `OnCollisionEnter` function we used
    in the last chapter. While that function was called by Unity the moment one of
    our birds hit something, this one is called every frame our ball continues to
    touch another collider. When it is called, we just set our flag to mark that we
    are touching something:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the physics system only changes during the `FixedUpdate` loop, this
    is the function that we use to update our particle system. Here, we first check
    whether we are touching something and the particle system is not currently emitting
    anything, as indicated by its `isPlaying` variable. If the conditions are met,
    we use the `Play` function to turn the particle system on. However, if the ball
    is not touching anything and the particle system is currently playing, we use
    the `Stop` function to turn it off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the very end of the `FixedUpdate` function, we set our flag to `false` so
    that it can be re-updated in the next frame as to whether or not we need to turn
    the particle system on or off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, add the new script to the `MonkeyBall` object. As we learned in the previous
    chapter, if we don't attach it to the same object as the ball's **Rigidbody**
    component, we will not receive the collision messages we need to make the script
    work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, drop your `DustTrail` particle system into the **Dust** slot so that
    your script can actually take control over it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it again. Now our monkey can easily move around and create a little dust
    trail until it falls off the edge of the level, goes off a jump, or otherwise
    ends up in the air.![Creating dust trails](img/4691OT_08_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We gave our monkey ball the ability to kick up dust. We also made the dust turn
    on and off, based on whether the ball is actually touching the ground or not.
    This little effect makes the character feel nice and grounded in the world. It
    can also give you a sense of the speed of the character, based on the time for
    which the trail is behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Another good effect for grounding characters that we have previously discussed
    is shadows. If you haven't done so already, be sure to give your environment some
    shadow detail. You might notice, though, that due to the partially transparent
    nature of the ball, real-time shadows do not work on it. That's where the blob
    shadow we used on the tank will come in.
  prefs: []
  type: TYPE_NORMAL
- en: Our effect also runs constantly, even if the ball is not moving. Try to adjust
    whether or not the particle system plays based on the velocity of its **Rigidbody**
    component. We messed around with the velocity of **Rigidbody** components a little
    bit in the last chapter, if you need a refresher. For an added challenge, take
    a look at the particle system's `emissionRate` variable. Try to make the effect
    have more particles as the ball starts going faster.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we learned about audio effects and particle systems on their own. They
    each can add a lot to the scene, setting the mood and giving that touch of polish
    that sets a game apart. However, there are many effects that cannot stand on their
    own. Explosions, for example, are simply not that impressive, unless you have
    both the visual and auditory effects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploding bananas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is so much more satisfying to destroy things when they explode. It takes
    both a particle effect and a sound effect to make a proper explosion. We will
    start by creating an explosion prefab. Then, we will update the bananas to spawn
    the explosion once they are destroyed. Let''s use these steps to create the banana
    explosions:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a new particle system and name it `Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want our explosion to actually look something like an explosion. This is
    where our second particle texture comes in. Create a new material for it, named
    `Smoke`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, set the **Shader** property by going to **Particles** | **Additive**.
    This will use an additive-blending method that makes the overall particle look
    brighter, while still blending the alpha of the particle with the things behind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to set the new material's **Particle Texture** property to `Smoke`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, drop your `Smoke` material into the **Material** slot in the particle
    system's **Renderer** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do not want this explosion to last too long. So, in the **Initial** module,
    set **Duration** to `0.5` and **Start Lifetime** to `1`, making it all much shorter
    than what it was.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with things such as explosions that occur in short bursts, it can
    become hard to see how our changes are affecting the look of the particle system.
    When we are done with this particle system, we will have to uncheck the **Looping**
    checkbox, but leaving it on for now makes it much easier to view and work with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, so that the particles do not fly excessively far, set **Start Speed**
    to `0.5`, making the explosion contained and centralized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to have enough particles for a proper explosion, set **Rate** to `120`
    in the **Emission** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To actually make the explosion seem legitimate, change **Shape** to **Sphere**
    in the **Shape** module. Also, set **Radius** to `0.5`. If you are interested
    in changing the size of the explosion, adjust **Radius** and the **Emission Rate**.
    Increasing both will give you a larger explosion, while decreasing both will give
    you a smaller one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This basic explosion effect is just a visual explosion, as most are. Making
    an explosion that changes the environment or alters its appearance based on the
    environment will require extra scripting and model consideration that is beyond
    the scope of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The explosion in our game still isn't colored like an explosion and all of the
    particles pop out of the existence around the edges. That's where the **Color
    over Lifetime** module comes in. First, we need to get rid of the particle pop
    by adding some new flags for the alpha channel. Add two new flags at about `20`
    percent of the way in from the edges and adjust all the four flags, so that the
    particles fade in at the beginning and out at the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The flags along the bottom of the gradient bar of **Gradient Editor** control
    the colors that the particle will transition through over the course of its life.
    For a decent explosion, we are going to need two more flags, one that is placed
    one-third of the way in and one flag at two-thirds, spacing all four of them evenly.
    Explosions tend to start with a moderately bright color, followed by a bright
    color at the peak of the explosion's energy, then another medium bright color
    as the energy starts to dissipate, and finally black when all of the energy is
    gone. Each color you pick will affect the color of the explosion. For a normal
    explosion, select yellows and oranges. For a sci-fi space explosion, you can select
    blues or greens. Or, maybe it is an alien spore cloud with the use of purples.
    Use your imagination and pick something appropriate for what you want to explode.![Exploding
    bananas](img/4691OT_08_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have all our settings in place, ensure that **Play On Awake** is
    checked, so the explosion will start the moment it is created, and uncheck **Looping**,
    so that it does not play forever. If you want to test your particle system at
    this point, take a look at the **Stop**, **Simulate**, and **Pause** buttons that
    appear in the bottom-right of your **Scene** window when any particle system is
    selected. These buttons work just like the buttons of your music player, controlling
    the playback of your particle system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we were to start creating explosions now, they will just sit there in the
    scene after spawning their initial group of particles, though the player will
    never see them. That's why we need a new script to get rid of them once they are
    done. Create a new script and name it `Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script has a single variable, that is, to keep track of the particle system
    that indicates its existence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It also has a single function. The `Update` function checks every frame to
    see whether the particle system even exists or if it has stopped playing. In either
    case, the overall object is destroyed so that we can save resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to add our new script to the `Explosion` object. Also, drag the
    **Particle System** component to the **Particles** slot in the **Script** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the explosion heard, we need to add an **Audio Source** component to
    the `Explosion` object as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that its **Play On Awake** box is checked. So that the sound makes sense
    in 3D space, set the **Spatial Blend** property to `1`. Also, set it for **Linear
    Rolloff** and `50` for the **Max Distance**, so that we can hear it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't make much sense for our bananas to have the same explosion sound
    that a car has. Instead, we have a nice little popping sound that will differentiate
    the final touch from those that just reduce the health of the banana. To that
    end, set the `BananaPop` audio file in the **AudioClip** slot on the **Audio Source**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With all of our explosive settings in place, create a new prefab out of the
    `Explosion` object and delete it from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to update the `BananaBounce` script to actually spawn the explosion
    when it has run out of health. Open it up now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we add a new variable at the beginning of the script. This will simply
    keep track of the prefab that we want to spawn after the banana runs out of health:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a line to the `Touched` function right after we use the
    `Destroy` function. This line just creates a new instance of the explosion at
    the position of the banana:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, find your `Banana` prefab in the **Project** panel and drop the `Explosion`
    prefab into the new **Explosion** slot. If you don't, the explosion will never
    be created and Unity will give you an error every time a banana runs out of health.![Exploding
    bananas](img/4691OT_08_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, we have created an explosion. With
    the help of a few textures from Unity's old particle systems, we made it actually
    look like an explosion, rather than just the puff of colored balls that it would
    otherwise be. We also gave the explosion a sound effect. Combining both particle
    systems and audio sources, we can create many effects, such as our explosion,
    which would be weak if you just use one or the other. We also updated our bananas
    so that they spawn the explosions when they are destroyed by the player. Try playing
    around with the balance of the banana's audio, the volume differences between
    each touch on the banana, and the explosion itself. The more information we can
    give the player visually with particle systems and in an auditory manner with
    audio sources, the better will be the effect.
  prefs: []
  type: TYPE_NORMAL
- en: Bananas aren't the only thing in this world that can explode. In our second
    game, we were destroying tanks that just disappear. Try adding some new explosions
    to the Tank Battle game. Every time a tank is destroyed, it should explode in
    a glorious fashion. Also, shots from a tank tend to explode no matter what they
    hit. Try spawning an explosion at the point it was shot rather than moving the
    red sphere around. It will give the player a much better sense and feel of what
    they are shooting at.
  prefs: []
  type: TYPE_NORMAL
- en: The Angry Birds game can also use some explosions, especially the black bird.
    Every time something is destroyed, it should throw out some sort of particles
    and make a little bit of noise. Otherwise, it will continue to look a little weird
    when things just disappear suddenly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the special effects in Unity, specifically
    audio and particle systems. We started by understanding how Unity handles audio
    files. By adding background music and some squeak to the ball, we put into practice
    what we learned. We moved on to understand particle systems and created a dust
    trail for the ball. Finally, we put the two skill sets together and created explosions
    for the bananas when collected. Particle systems and audio effects add a lot to
    the final polish and look of a game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will complete our gaming experience together by taking
    a look at optimization in Unity. We will take a look at the tools provided for
    tracking performance. We will also create our own tool to track specific parts
    of a script's performance. We will explore asset compression and the other points
    that we can change to minimize the application footprint. Finally, key points
    for minimizing the lag while working with games and Unity will be discussed.
  prefs: []
  type: TYPE_NORMAL
