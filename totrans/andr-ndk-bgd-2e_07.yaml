- en: Chapter 7. Playing Sound with OpenSL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 使用OpenSL ES播放声音
- en: '*Multimedia is not only about graphics, it is also about sound and music. Applications
    in this domain are among the most popular in the Android market. Indeed, music
    has always been a strong engine for mobile device sales and music lovers are a
    target of choice. This is why an OS like Android could probably not go far without
    some musical talent! Open Sound Library for Embedded Systems, more frequently
    called OpenSL ES, is the pendant of OpenGL for sound. Although rather low-levewl,
    it is a first-class API for all sound-related tasks, either input or output.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*多媒体不仅仅是关于图形，还关乎声音和音乐。这一领域的应用程序在Android市场中是最受欢迎的。事实上，音乐一直是推动移动设备销售的重要动力，音乐爱好者始终是首选目标群体。这就是为什么像Android这样的操作系统可能没有一定的音乐才能就无法走得更远！嵌入式系统的开放声音库，通常称为OpenSL
    ES，是声音领域的OpenGL。尽管它相对底层，但它是所有与声音相关的任务，无论是输入还是输出，都是一流的API。*'
- en: 'When talking about sound on Android, we should distinguish Java from the native
    world. Indeed, both sides feature completely different APIs: **MediaPlayer**,
    **SoundPool**, **AudioTrack**, and **JetPlayer** on one hand, and **OpenSL ES**
    on the other hand:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论Android上的声音时，我们应该区分Java和本地世界。实际上，两边拥有完全不同的API：一方面是**MediaPlayer**、**SoundPool**、**AudioTrack**和**JetPlayer**，另一方面是**OpenSL
    ES**。
- en: MediaPlayer is more high level and easy to use. It handles not only music but
    also video. It is the way to go when a simple file playback is sufficient.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MediaPlayer是更高级且易于使用的。它不仅处理音乐，还处理视频。当只需要简单的文件播放时，它是首选的方法。
- en: SoundPool and AudioTrack are more low level and closer to low latency when playing
    sound. AudioTrack is the most flexible but also complex to use. It allows sound
    buffer modifications on the fly (by hand!).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoundPool和AudioTrack更底层，播放声音时更接近低延迟。AudioTrack虽然最灵活，但也最复杂。它允许在运行中手动修改声音缓冲区。
- en: JetPlayer is more dedicated to the playback of MIDI files. This API can be interesting
    for dynamic musing synthesis in a multimedia application or game (see the JetBoy
    example provided with Android SDK).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetPlayer更专注于MIDI文件的播放。这个API对于多媒体应用程序或游戏中的动态音乐合成可能很有趣（请参阅Android SDK提供的JetBoy示例）。
- en: OpenSL ES aims at offering a cross-platform API to manage audio on embedded
    systems; in other words, the OpenGL ES for audio. Like GLES, its specification
    is led by the Khronos group. On Android, OpenSL ES is in fact implemented on top
    of the AudioTrack API.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSL ES旨在为嵌入式系统提供跨平台的音频管理API；换句话说，就是音频领域的OpenGL ES。与GLES一样，其规范由Khronos组织领导。在Android上，OpenSL
    ES实际上是在AudioTrack API之上实现的。
- en: OpenSL ES was first released on Android 2.3 Gingerbread and was not available
    in previous releases (Android 2.2 and lower). While there is a profusion of APIs
    in Java, OpenSL ES is the only one provided on the native side and is exclusively
    available on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES首次在Android 2.3 Gingerbread版本中发布，之前的版本（Android 2.2及以下）并未提供。尽管Java中有大量的API，但OpenSL
    ES是唯一在本地端提供的，且仅限于此。
- en: However, OpenSL ES is still immature. The OpenSL specification is still incompletely
    supported and several limitations shall be expected. In addition, the OpenSL specification
    is implemented in its version 1.0.1 on Android, although version 1.1 is already
    out. Thus, some breaking changes can be expected in the future since the OpenSL
    ES implementation is still evolving.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenSL ES仍不够成熟。OpenSL规范仍然没有得到完全支持，预计会有一些限制。此外，尽管OpenSL 1.1版本已经发布，但Android上实现的OpenSL规范仍然是1.0.1版本。因此，由于OpenSL
    ES的实现仍在不断发展，未来可能会出现一些重大变化。
- en: 3D Audio features are available through OpenSL ES only for devices whose system
    is compiled with the appropriate profile. Indeed, the current OpenSL ES specification
    provides three different profiles, Game, Music, and Phone for different types
    of devices. At the time this book is written, none of these profiles are supported.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 只有系统编译时包含适当配置文件的设备才能通过OpenSL ES使用3D音频功能。实际上，当前的OpenSL ES规范提供了三种不同的配置文件，分别是针对不同类型设备的游戏、音乐和电话配置文件。在本书撰写之时，这些配置文件都不被支持。
- en: However, OpenSL ES has qualities. First, it may be easier to integrate in the
    architecture of a native application, since it is itself written in C/C++. It
    does not have to carry a garbage collector on its back. Native code is not interpreted
    and can be optimized in-depth through assembly code. These are some of the many
    reasons to consider it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenSL ES有其优点。首先，它可能更容易集成到本地应用程序的架构中，因为它本身是用C/C++编写的。它不需要背负垃圾收集器。本地代码不是解释执行的，可以通过汇编代码进行深度优化。这些都是考虑使用它的众多原因之一。
- en: 'This chapter is an introduction to the musical capabilities of OpenSL ES on
    the Android NDK. We are about to discover how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是介绍在 Android NDK 上 OpenSL ES 的音乐功能。我们将发现如何进行以下操作：
- en: Initialize OpenSL ES on Android
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 上初始化 OpenSL ES
- en: Play background music
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放背景音乐
- en: Play sounds with a sound buffer queue
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声音缓冲队列播放声音
- en: Record sounds and play them
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制声音并播放
- en: Audio and, more specifically, real-time audio is a highly technical subject.
    This chapter covers the basics to embed sound and music in your own applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 音频，特别是实时音频是一个高度技术化的课题。本章涵盖了将声音和音乐嵌入到您自己的应用程序中的基础知识。
- en: Initializing OpenSL ES
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 OpenSL ES
- en: OpenSL will not be very useful if we do not initialize it first. As usual, this
    step requires some boilerplate code. The verbosity of OpenSL does not improve
    the situation. Let's start this chapter by creating a new `SoundManager` to wrap
    OpenSL ES-related logic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不先初始化 OpenSL，它将不会非常有用。像往常一样，这一步需要一些样板代码。OpenSL 的繁琐并不会改善这种情况。让我们通过创建一个新的`SoundManager`类来包装与
    OpenSL ES 相关的逻辑，以此开始本章内容。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part10`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的最终项目名为`DroidBlaster_Part10`。
- en: Time for action – creating OpenSL ES engine and output
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——创建 OpenSL ES 引擎和输出
- en: 'Let''s create a new manager dedicated to sounds:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门用于声音的新管理器：
- en: Create a new file `jni/SoundManager.hpp`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/SoundManager.hpp`。
- en: 'First, include the OpenSL ES standard header `SLES/OpenSLES.h`. The two latter
    define objects and methods and are specifically created for Android. Then, create
    the `SoundManager` class to do the following:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，包含 OpenSL ES 标准头文件`SLES/OpenSLES.h`。后两个定义了对象和方法，专门为 Android 创建。然后，创建`SoundManager`类以执行以下操作：
- en: Initialize OpenSL ES with the `start()` method
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`start()`方法初始化 OpenSL ES
- en: Stop the sound and release OpenSL ES with the `stop()` method
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stop()`方法停止声音并释放 OpenSL ES
- en: 'There are two main kinds of pseudo-object structures (that is, containing function
    pointers applied on the structure itself, such as a C++ object with this) in OpenSL
    ES:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenSL ES 中有两种主要的伪对象结构（即包含应用于结构本身的函数指针的结构，例如具有此的 C++ 对象）：
- en: '**Objects**: These are represented by `SLObjectItf`, which provides a few common
    methods to get allocated resources and object interfaces. This could be roughly
    compared to an object in Java.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：这些由`SLObjectItf`表示，提供了一些常见方法来获取分配的资源和对对象接口的访问。这可以大致与 Java 中的对象相比较。'
- en: '**Interfaces**: These give access to object features. There can be several
    interfaces for an object. Depending on the host device, some interfaces may or
    may not be available. These are very roughly comparable to interfaces in Java.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：这些提供了访问对象特性的途径。一个对象可以有多个接口。根据主机设备的不同，某些接口可能可用或不可用。这些大致可以与 Java 中的接口相比较。'
- en: 'In `SoundManager`, declare two `SLObjectItf` instances, one for the OpenSL
    ES engine and an other for the speakers. Engines are available through a `SLEngineItf`
    interface:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SoundManager`中，声明两个`SLObjectItf`实例，一个用于 OpenSL ES 引擎，另一个用于扬声器。引擎可以通过`SLEngineItf`接口获得：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement `SoundManager` in `jni/SoundManager.cpp` with its constructor:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/SoundManager.cpp`中实现`SoundManager`及其构造函数：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Write the method `start()`, which is going to create an OpenSL Engine object
    and an `Output Mix` object. We need three variables per object to initialize:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`start()`方法，该方法将创建一个 OpenSL 引擎对象和一个`Output Mix`对象。我们需要每个对象三个变量来进行初始化：
- en: The number of interfaces to support for each object (`engineMixIIDCount` and
    `outputMixIIDCount`).
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象需要支持接口的数量（`engineMixIIDCount`和`outputMixIIDCount`）。
- en: An array of all the interfaces objects should support (`engineMixIIDs` and `outputMixIIDs`),
    for example `SL_IID_ENGINE` for the engine.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有接口对象应支持的接口数组（`engineMixIIDs`和`outputMixIIDs`），例如引擎的`SL_IID_ENGINE`。
- en: An array of Boolean values to indicate whether the interface is required or
    optional for the program (`engineMixReqs` and `outputMixReqs`).
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值数组，用于指示接口对程序是必需的还是可选的（`engineMixReqs`和`outputMixReqs`）。
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Continue the method `start()`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编写`start()`方法：
- en: Initialize the OpenSL ES engine object (that is, the basic type `SLObjectItf`)
    with the `slCreateEngine()` method. When we create an OpenSL ES object, the specific
    interfaces we are going to use have to be indicated. Here, we request the `SL_IID_ENGINE`
    interface, which allows creating other OpenSL ES objects. The engine is the central
    object of the OpenSL ES API.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`slCreateEngine()`方法初始化OpenSL ES引擎对象（即基本类型`SLObjectItf`）。当我们创建一个OpenSL ES对象时，我们必须指出将要使用的特定接口。在这里，我们请求`SL_IID_ENGINE`接口，它允许创建其他OpenSL
    ES对象。引擎是OpenSL ES API的核心对象。
- en: Then, invoke `Realize()` on the engine object. Any OpenSL ES object needs to
    be *realized* to allocate the required internal resources before use.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在引擎对象上调用`Realize()`。任何OpenSL ES对象在使用前都需要*实现*以分配所需的内部资源。
- en: Finally, retrieve `SLEngineItf`-specific interface.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，获取`SLEngineItf`特定的接口。
- en: The engine interface gives us the possibility to instantiate an audio output
    mix with the `CreateOutputMix()` method. The audio output mix defined here delivers
    sound to the default speakers. It is autonomous (the played sound is sent automatically
    to the speaker), so there is no need to request any specific interface here.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎接口使我们能够使用`CreateOutputMix()`方法实例化一个音频输出混合。在这里定义的音频输出混合将声音传送到默认扬声器。它是自主的（播放的声音会自动发送到扬声器），因此在这里无需请求任何特定接口。
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Write the `stop()` method to destroy what has been created in `start()`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`stop()`方法以销毁在`start()`中创建的内容：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit `jni/DroidBlaster.hpp` and embed our new `SoundManager`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/DroidBlaster.hpp`并将我们的新`SoundManager`嵌入其中：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create, start, and stop the sound service in `jni/DroidBlaster.cpp`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`中创建、启动和停止声音服务：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, link to `libOpenSLES.so` in the `jni/Android.mk` file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/Android.mk`文件中链接到`libOpenSLES.so`：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Run the application and check that no error is logged. We initialized the OpenSL
    ES library, which gives us access to efficient sound handling primitives directly
    from the native code. The current code does not perform anything apart from initialization.
    No sound comes out of the speakers yet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查是否有错误记录。我们初始化了OpenSL ES库，这使我们可以直接从本地代码访问高效的声音处理原语。当前的代码除了初始化之外，不执行任何操作。扬声器还不会发出声音。
- en: The entry point to OpenSL ES here is `SLEngineItf`, which is mainly an OpenSL
    ES object factory. It can create a channel to an output device (a speaker or anything
    else), as well as sound players or recorders (and even more!), as we will see
    later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES的入口点是`SLEngineItf`，它主要是一个OpenSL ES对象工厂。它可以创建到输出设备（扬声器或其他设备）的通道，以及声音播放器或记录器（甚至更多！），我们将在本章后面看到。
- en: The `SLOutputMixItf` is the object representing the audio output. Generally,
    this will be the device speaker or headset. Although the OpenSL ES specification
    allows enumerating the available output (and also input) devices, NDK implementation
    is not mature enough to obtain or select a proper one (`SLAudioIODeviceCapabilitiesItf`,
    the official interface to obtain such information). So, when dealing with output
    and input device selection (only input device for recorders needs to be specified
    currently), it is preferable to stick to default values, `SL_DEFAULTDEVICEID_AUDIOINPUT`
    and `SL_DEFAULTDEVICEID_AUDIOOUTPUT` defined in `SLES/OpenSLES.h`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SLOutputMixItf`是表示音频输出的对象。通常，这将是设备扬声器或耳机。尽管OpenSL ES规范允许枚举可用的输出（以及输入）设备，但NDK实现还不足以获取或选择适当的设备（`SLAudioIODeviceCapabilitiesItf`，获取此类信息的官方接口）。因此，在处理输出和输入设备选择时（目前只需指定记录器的输入设备），最好坚持使用默认值，即在`SLES/OpenSLES.h`中定义的`SL_DEFAULTDEVICEID_AUDIOINPUT`和`SL_DEFAULTDEVICEID_AUDIOOUTPUT`。'
- en: The current Android NDK implementation allows only one engine per application
    (this should not be an issue) and, at most, 32 created objects. Beware, however,
    that the creation of any object can fail, as this is dependent on the available
    system resources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Android NDK实现只允许每个应用程序有一个引擎（这不应成为问题），最多可以创建32个对象。但是请注意，任何对象的创建都可能失败，因为这取决于可用的系统资源。
- en: More on OpenSL ES philosophy
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于OpenSL ES理念的更多内容
- en: 'OpenSL ES is different from its graphics compatriot GLES, partly because it
    does not have a long history to carry. It is constructed on (more or less) an
    object-oriented principle based on objects and interfaces. The following definitions
    come from the official specification:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES与其图形同伴GLES不同，部分原因是因为它没有悠久的历史负担。它是基于对象和接口的（或多或少）面向对象原则构建的。以下定义来自官方规范：
- en: An **object** is an abstraction of a set of resources, assigned for a well-defined
    set of tasks, and the state of these resources. An object has a type determined
    on its creation. The object type determines the set of tasks that an object can
    perform. This can be considered similar to a class in C++.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**对象**是对一组资源的抽象，这些资源被分配用于一组明确定义的任务，以及这些资源的状态。对象在创建时确定了其类型。对象类型决定了对象可以执行的任务集。这可以看作类似于
    C++ 中的类。
- en: An **interface** is an abstraction of a set of related features that a certain
    object provides. An interface includes a set of methods, which are functions of
    the interface. An interface also has a type, which determines the exact set of
    methods of the interface. We can define the interface itself as a combination
    of its type and the object to which it is related.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**接口**是对一组相关功能的抽象，特定对象提供这些功能。接口包括一组方法，即接口的函数。接口也有一个类型，它决定了接口的确切方法集。我们可以将接口本身定义为其类型与相关对象的组合。
- en: An **interface ID** identifies an interface type. This identifier is used within
    the source code to refer to the interface type.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**接口 ID**用于识别接口类型。此标识符在源代码中使用，以引用接口类型。
- en: 'An OpenSL ES object is set up in a few steps as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES 对象的设置需要以下几个步骤：
- en: Instantiating it through a build method (which usually belongs to the engine).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构建方法（通常属于引擎）实例化它。
- en: Realizing it to allocate the necessary resources.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现它以分配必要的资源。
- en: Retrieving object interfaces. A basic object only has a very limited set of
    operations (`Realize()`, `Resume()`, `Destroy()`, and so on). Interfaces give
    access to real object features and describes what operations can be performed
    on an object, for example, a `Play` interface to play or pause a sound.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取对象接口。一个基本对象只具有非常有限的操作集（`Realize()`、`Resume()`、`Destroy()`等）。接口提供了对真实对象功能的访问，并描述了可以在对象上执行的操作，例如，一个
    `Play` 接口用于播放或暂停声音。
- en: 'Any interfaces can be requested but only the one supported by the object is
    going to be successfully retrieved. You cannot retrieve the record interface for
    an audio player because it returns (sometimes annoyingly!) `SL_RESULT_FEATURE_UNSUPPORTED`
    (error code 12). In technical terms, an OpenSL ES interface is a structure containing
    function pointers (initialized by the OpenSL ES implementation) with a self-parameter
    to simulate C++ objects and `this`, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求任何接口，但只有对象支持的接口才能成功获取。你不能为一个音频播放器获取录音接口，因为它会返回（有时很烦人！）`SL_RESULT_FEATURE_UNSUPPORTED`（错误代码
    12）。从技术角度来说，OpenSL ES 接口是一个包含函数指针（由 OpenSL ES 实现初始化）的结构，带有一个自参数来模拟 C++ 中的对象和 `this`。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `Realize()`, `Resume()`, and so on are object methods that can be applied
    on an `SLObjectItf` object. The approach is identical for interfaces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Realize()`、`Resume()` 等是可以应用于 `SLObjectItf` 对象的对象方法。接口的处理方式与此相同。
- en: For more detailed information on what OpenSL ES can provide, refer to the specification
    on the Khronos website [http://www.khronos.org/opensles](http://www.khronos.org/opensles),
    as well as the OpenSL ES documentation in the Android NDK docs directory. Android
    implementation does not fully respect the specification, at least for now. So,
    do not be disappointed when discovering that only a limited subset of the specification
    (especially sample codes) works on Android.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 OpenSL ES 可以提供哪些更详细信息，请参考 Khronos 网站上的规范[http://www.khronos.org/opensles](http://www.khronos.org/opensles)，以及
    Android NDK 文档目录中的 OpenSL ES 文档。目前，Android 的实现并没有完全遵守该规范。因此，在发现只有规范中有限的一部分（特别是示例代码）在
    Android 上有效时，请不要感到失望。
- en: Playing music files
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐文件
- en: OpenSL ES is initialized, but the only thing coming out of speakers is silence!
    So what about finding a nice piece of **Background Music** (**BGM**) and playing
    it natively with Android NDK? OpenSL ES provides the necessary stuff to read music
    files such as MP3 files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES 已初始化，但扬声器中传出的唯一声音却是沉默！那么，是否可以找到一段不错的**背景音乐**（**BGM**）并使用 Android NDK
    原生播放呢？OpenSL ES 提供了读取如 MP3 文件等音乐文件的必要功能。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part11`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为 `DroidBlaster_Part11`。
- en: Time for action – playing background music
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——播放背景音乐
- en: 'Let''s open and play an MP3 music file with OpenSL ES:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 OpenSL ES 打开并播放一个 MP3 音乐文件：
- en: 'MP3 files are opened by OpenSL using a POSIX file descriptor pointing to the
    chosen file. Improve `jni/ResourceManager.cpp` created in the previous chapters
    by defining a new structure `ResourceDescriptor` and appending a new method `descriptor()`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP3 文件通过 OpenSL 使用指向所选文件的 POSIX 文件描述符打开。通过定义新的结构 `ResourceDescriptor` 并添加新的方法
    `descriptor()` 来改进本章前面创建的 `jni/ResourceManager.cpp`：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement `jni/ResourceManager.cpp`. Of course, makes use of the asset manager
    API to open the descriptor and fill a `ResourceDescriptor` structure:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `jni/ResourceManager.cpp`。当然，使用资产管理器 API 打开描述符并填充 `ResourceDescriptor` 结构：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Go back to `jni/SoundManager.hpp` and define two methods `playBGM()` and `stopBGM()`
    to play/stop a background MP3 file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `jni/SoundManager.hpp` 并定义两个方法 `playBGM()` 和 `stopBGM()` 来播放/停止背景 MP3 文件。
- en: 'Declare an OpenSL ES object for the music player, along with the following
    interfaces:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明一个 OpenSL ES 对象用于音乐播放，以及以下接口：
- en: '`SLPlayItf` plays and stops music files'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLPlayItf` 播放和停止音乐文件'
- en: '`SLSeekItf` controls position and looping'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLSeekItf` 控制位置和循环'
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Start implementing `jni/SoundManager.cpp`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实施 `jni/SoundManager.cpp`。
- en: Include `Resource.hpp` to get access to asset file descriptors.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含 `Resource.hpp` 以获取资产文件描述符的访问权限。
- en: 'Initialize new members in the constructor and update `stop()` to stop the background
    music automatically (or some users are not going to be happy!):'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构造函数中初始化新成员，并更新 `stop()` 以自动停止背景音乐（否则一些用户可能会不高兴！）：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implement `playBGM()` to enrich the manager with playback features.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `playBGM()` 以增强管理器的播放功能。
- en: First, describe our audio setup through two main structures, `SLDataSource`
    and `SLDataSink`. The first describes the audio input channel and the second,
    the audio output channel.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，通过两个主要结构 `SLDataSource` 和 `SLDataSink` 描述我们的音频设置。第一个描述音频输入通道，第二个描述音频输出通道。
- en: Here, we configure the data source as a MIME source so that the file type gets
    detected automatically from the file descriptor. The file descriptor is, of course,
    opened with a call to `ResourceManager::descriptor()`.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将数据源配置为 MIME 源，以便从文件描述符自动检测文件类型。文件描述符当然是通过调用 `ResourceManager::descriptor()`
    打开的。
- en: 'The data sink (that is, the destination channel) is configured with the `OutputMix`
    object created in the first part of this chapter while initializing the OpenSL
    ES engine (and refers to the default audio output, that is, speakers or headset):'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据接收端（即目标通道）配置为本章第一部分初始化 OpenSL ES 引擎时创建的 `OutputMix` 对象（并指向默认音频输出，即扬声器或耳机）：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, create the OpenSL ES audio player. As always, with OpenSL ES objects,
    instantiate it through the engine first and then realize it. Two interfaces, `SL_IID_PLAY`
    and `SL_IID_SEEK`, are imperatively required:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 OpenSL ES 音频播放器。与往常一样，首先通过引擎实例化 OpenSL ES 对象，然后实现它。两个接口 `SL_IID_PLAY`
    和 `SL_IID_SEEK` 是必须的：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, using the `play` and `seek` interfaces, switch the playback in loop
    mode (that is, the music keeps playing) from the track's beginning (that is, `0`
    milliseconds) until its end (`SL_TIME_UNKNOWN`), and then start playing (`SetPlayState()`
    with `SL_PLAYSTATE_PLAYING`).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `play` 和 `seek` 接口，将播放模式切换为循环模式（即音乐持续播放），从曲目开始（即 `0` 毫秒）直到其结束（`SL_TIME_UNKNOWN`），然后开始播放（使用
    `SL_PLAYSTATE_PLAYING` 的 `SetPlayState()`）。
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Terminate with the last method `stopBGM()` to stop and destroy the player:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最后一个方法 `stopBGM()` 来停止并销毁播放器：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a resource pointing to the music file in `jni/DroidBlaster.hpp`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/DroidBlaster.hpp` 中添加一个指向音乐文件的资源：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, in `jni/DroidBlaster.cpp`, start playing the music right after `SoundManager`
    is started:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `jni/DroidBlaster.cpp` 中，在启动 `SoundManager` 后立即开始播放音乐：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Copy an MP3 file into the `droidblaster`'s `assets` directory and name it `bgm.mp3`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 MP3 文件复制到 `droidblaster` 的 `assets` 目录中，并将其命名为 `bgm.mp3`。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The BGM file is provided with this book in the `DroidBlaster_Part11/assets`
    directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: BGM 文件随本书在 `DroidBlaster_Part11/assets` 目录中提供。
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We discovered how to play a music clip from an MP3 file. Playback loops until
    the game is terminated. When using a MIME data source, the file type is auto-detected.
    Several formats are currently supported in Gingerbread, including Wave PCM, Wave
    alaw, Wave ulaw, MP3, Ogg Vorbis, and so on. The MIDI playback is currently not
    supported. Have a look at `$ANDROID_NDK/docs/opensles/index.html` for more information.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到如何从 MP3 文件播放音乐片段。播放会一直循环，直到游戏终止。当使用 MIME 数据源时，文件类型会自动检测。目前在 Gingerbread
    中支持多种格式，包括 Wave PCM、Wave alaw、Wave ulaw、MP3、Ogg Vorbis 等。目前不支持 MIDI 播放。更多信息请查看
    `$ANDROID_NDK/docs/opensles/index.html`。
- en: The way the sample code is presented here is typical of how OpenSL ES works.
    The OpenSL ES engine object, which is basically an object factory, creates an
    `AudioPlayer`. In its raw state, this object cannot do much. First, it needs to
    be realized to allocate the necessary resources. However, that is not enough.
    It needs to retrieve the right interfaces, like the `SL_IID_PLAY` interface to
    change the audio player state to playing/stopped. Then, the OpenSL API can be
    effectively used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的示例代码是OpenSL ES工作方式的典型例子。OpenSL ES引擎对象，基本上是一个对象工厂，创建一个`AudioPlayer`。在其原始状态下，这个对象做不了太多事情。首先，它需要实现以分配必要的资源。然而，这还不够。它需要检索正确的接口，如`SL_IID_PLAY`接口，以改变音频播放器的状态为播放/停止。然后，OpenSL
    API才能有效使用。
- en: That is quite some work, taking into account result verification (as any call
    is susceptible to fail), which kind of clutters the code. Getting inside this
    API can take a little bit more time than usual, but once understood, these concepts
    become rather easy to deal with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项相当大的工作，考虑到结果验证（因为任何调用都可能失败），这会使代码变得混乱。深入了解这个API可能需要比平时更多的时间，但一旦理解，这些概念就变得相当容易处理。
- en: You may be surprised to see that `startBGM()` and `stopBGM()` recreates and
    destroys the audio player respectively. The reason is that there is currently
    no way to change an MIME data source without completely recreating the OpenSL
    ES `AudioPlayer` object. So, although this technique is fine to play a long clip,
    it is not suitable to play a short sound dynamically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，`startBGM()`和`stopBGM()`分别会重新创建和销毁音频播放器。原因是目前没有办法在不完全重新创建OpenSL ES
    `AudioPlayer`对象的情况下更改MIME数据源。因此，尽管这种技术在播放长片段时是可行的，但不适合动态播放短声音。
- en: Playing sounds
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音
- en: The technique presented to play BGM from a MIME source is very practical but,
    sadly, not flexible enough. Recreating an `AudioPlayer` object is not necessary
    and accessing asset files each time is not good in terms of efficiency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从MIME源播放BGM的技术非常实用，但遗憾的是，不够灵活。重新创建`AudioPlayer`对象是不必要的，每次访问资源文件在效率上也不好。
- en: So, when it comes to playing sounds quickly in response to an event and generating
    them dynamically, we need to use a sound buffer queue. Each sound is preloaded
    or generated in a memory buffer, and placed into a queue when the playback is
    requested. No need to access a file at runtime!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在响应事件快速播放声音并动态生成它们时，我们需要使用声音缓冲队列。每个声音在内存缓冲区预加载或生成，并在请求播放时放入队列中。无需在运行时访问文件！
- en: A sound buffer, in the current OpenSL ES Android implementation, can contain
    PCM data. **Pulse Code Modulation** (**PCM**) is a data format dedicated to the
    representation of digital sounds. It is the format used in CD and in some Wave
    files. A PCM can be Mono (the same sound on all speakers) or Stereo (different
    sounds for left and right speakers if available).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前OpenSL ES Android实现中，声音缓冲区可以包含PCM数据。**脉冲编码调制**（**PCM**）是一种专门用于表示数字声音的数据格式。这是CD和一些Wave文件中使用的格式。PCM可以是单声道（所有扬声器上相同的声音）或立体声（如果可用，左右扬声器有不同的声音）。
- en: 'PCM is not compressed and is not efficient in terms of storage (just compare
    a musical CD with a data CD full of MP3). However, this format is lossless and
    offers the best quality. Quality depends on the sampling rate: analog sounds are
    represented digitally as a series of measure (that is, `sample`) of the sound
    signal.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: PCM没有压缩，在存储效率上不高（只需比较一张音乐CD和一个装满MP3的数据CD）。然而，这种格式是无损的，提供最佳质量。质量取决于采样率：模拟声音以一系列的测量（即`sample`）数字形式表示声音信号。
- en: 'A sound sample at 44100 Hz (that is 44100 measures per second) has better quality
    but also takes place more than a sound sampled at 16000 Hz. Also, each measure
    can be represented with a more or less fine degree of precision (the encoding).
    On current Android implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以44100 Hz（即每秒44100次测量）采样的声音样本质量更好，但也比以16000 Hz采样的声音占用更多空间。此外，每个测量可以表示得更精细或较不精细（即编码）。在当前Android实现中：
- en: Sounds can use 8000 Hz, 11025 Hz, 12000 Hz, 16000 Hz, 22050 Hz, 24000 Hz, 32000
    Hz, 44100 Hz, or 48000 Hz sampling,
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音可以使用8000 Hz、11025 Hz、12000 Hz、16000 Hz、22050 Hz、24000 Hz、32000 Hz、44100 Hz或48000
    Hz的采样率。
- en: Samples can be encoded on 8-bit unsigned or 16-bit signed (finer precision)
    in **little-endian** or **big-endian**.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本可以以8位无符号或16位有符号（更精细的精度）在小端（**little-endian**）或大端（**big-endian**）编码。
- en: In the following step-by-step tutorial, we will use a raw PCM file encoded over
    16-bit in little-endian.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下分步教程中，我们将使用一个以16位小端编码的原始PCM文件。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part12`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果项目随本书提供，名为 `DroidBlaster_Part12`。
- en: Time for action – creating and playing a sound buffer queue
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——创建并播放声音缓冲区队列
- en: 'Let''s use OpenSL ES to play an explosion sound stored in a memory buffer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用OpenSL ES来播放存储在内存缓冲区中的爆炸声：
- en: 'Update `jni/Resource.hpp` again to add a new method `getLength()`, which provides
    the size in bytes of an `asset` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次更新 `jni/Resource.hpp`，以添加一个新方法 `getLength()`，它提供 `asset` 文件的字节大小：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement this method in `jni/Resource.cpp`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Resource.cpp` 中实现这个方法：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create `jni/Sound.hpp` to manage a sound buffer.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `jni/Sound.hpp` 来管理声音缓冲区。
- en: Define a method `load()` to load a PCM file and `unload()` to release it.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个方法 `load()` 来加载一个PCM文件，以及 `unload()` 来释放它。
- en: 'Also, define the appropriate getters. Hold the raw sound data in a buffer along
    with its size. The sound is loaded from a `Resource`:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，定义适当的获取器。将原始声音数据及其大小保存在缓冲区中。声音是从 `Resource` 加载的：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sound loading implementation done in `jni/Sound.cpp` is quite simple; it creates
    a buffer with the same size as the PCM file and loads all the raw file content
    in it:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Sound.cpp` 中完成的声音加载实现非常简单；它创建一个与PCM文件大小相同的缓冲区，并将所有原始文件内容加载到其中：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create `jni/SoundQueue.hpp` to encapsulate the creation of a player object
    and its queue. Create three methods to:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `jni/SoundQueue.hpp` 来封装播放器对象及其队列的创建。创建三个方法来：
- en: Initialize the `queue` when the application starts to allocate OpenSL resources
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序启动时初始化 `queue` 以分配OpenSL资源
- en: Finalize the `queue` to release OpenSL resources
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成队列以释放OpenSL资源
- en: Play a sound buffer of a predefined length
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放预定义长度的声音缓冲区
- en: 'A sound queue can be manipulated through the `SLPlayItf` and `SLBufferQueueItf`
    interfaces:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过 `SLPlayItf` 和 `SLBufferQueueItf` 接口操作声音队列：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement `jni/SoundQueue.cpp`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `jni/SoundQueue.cpp`：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write `initialize()`, beginning with `SLDataSource` and `SLDataSink` to describe
    the input and output channel. Use a `SLDataFormat_PCM` data format (instead of
    `SLDataFormat_MIME`), which includes sampling, encoding, and endianness information.
    Sounds need to be mono (that is, only one sound channel for both left and right
    speakers when available). The queue is created with the Android-specific extension
    `SLDataLocator_AndroidSimpleBufferQueue()`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `initialize()`，从 `SLDataSource` 和 `SLDataSink` 开始描述输入和输出通道。使用 `SLDataFormat_PCM`
    数据格式（而不是 `SLDataFormat_MIME`），其中包含采样、编码和字节序信息。声音需要是单声道的（即，如果有左右扬声器，只有一个声音通道）。队列是使用特定于Android的扩展
    `SLDataLocator_AndroidSimpleBufferQueue()` 创建的：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, create and realize the sound player. We are going to need its `SL_IID_PLAY`
    and `SL_IID_BUFFERQUEUE` interface, available thanks to the data locator configured
    in the previous step:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建并实现声音播放器。我们将需要它的 `SL_IID_PLAY` 和 `SL_IID_BUFFERQUEUE` 接口，这得益于前一步配置的数据定位器：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, start the queue by setting it in the playing state. This does not
    actually mean that a sound is played. The queue is empty so that would not be
    possible. However, if a sound gets enqueued, it is automatically played:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将队列设置为播放状态来启动队列。这实际上并不意味着会播放声音。队列是空的，所以不可能。但是，如果声音被入队，它将自动播放：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OpenSL ES objects need to be released when we no longer need them:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们不再需要它们时，需要释放OpenSL ES对象：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, write `playSound()`, which first stops any sound being played and
    then enqueue the new sound buffer to be played. This is the simplest strategy
    to play a sound immediately:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写 `playSound()`，它首先停止任何正在播放的声音，然后将新的声音缓冲区入队以播放。这是立即播放声音的最简单策略：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open `jni/SoundManager.hpp` and include the newly created headers.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `jni/SoundManager.hpp` 并包含新创建的头文件。
- en: 'Create two new methods:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建两个新的方法：
- en: '`registerSound()` to load and manage a new sound buffer'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerSound()` 以加载和管理一个新的声音缓冲区'
- en: '`playSound()` to send a sound buffer to the sound play queue'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playSound()` 将声音缓冲区发送到声音播放队列'
- en: Define a `SoundQueue` array so that up to four sounds may be played simultaneously.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个 `SoundQueue` 数组，以便最多可以同时播放四个声音。
- en: 'Sound buffers are stored in a fixed-size C++ array:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声音缓冲区存储在一个固定大小的C++数组中：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the constructor in `jni/SoundManager.cpp` and create a new destructor
    to release resources:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `jni/SoundManager.cpp` 中的构造函数，并创建一个新的析构函数来释放资源：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update `start()` to initialize the `SoundQueue` instances. Then, load sound
    resources registered with `registerSound()`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `start()` 以初始化 `SoundQueue` 实例。然后，加载通过 `registerSound()` 注册的声音资源：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finalize the `SoundQueue` instances when the application stops to release OpenSL
    ES resources. Also, release the sound buffers:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序停止时，完成`SoundQueue`实例的最终化，以释放OpenSL ES资源。同时，释放声音缓冲区：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save and cache the sounds in `registerSound()`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`registerSound()`中保存并缓存声音：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, write `playSound()`, which sends the buffer to play to a `SoundQueue`.
    Use a simple round-robin strategy to play several sounds simultaneously. Send
    each new sound to play next in the queue (which is more likely to be available).
    Obviously, this playing strategy is suboptimal for sounds of various lengths:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写`playSound()`，它将缓冲区发送到`SoundQueue`进行播放。使用简单的轮询策略来同时播放多个声音。将每个新的声音发送到队列中下一个可用的位置进行播放。显然，这种播放策略对于不同长度的声音来说并不是最优的：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will play a sound when the DroidBlaster ship collides with an asteroid. Since
    the collision is not yet managed (see [Chapter 10](ch10.html "Chapter 10. Intensive
    Computing with RenderScript"), *Intensive Computing with RenderScript* for collision
    handling with **Box2D**), we will simply play a sound when the ship is initialized.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当DroidBlaster飞船与行星碰撞时，我们将播放一个声音。由于碰撞尚未处理（有关使用**Box2D**处理碰撞的内容，请参见[第10章](ch10.html
    "第10章. 使用RenderScript进行密集计算")），我们将在飞船初始化时简单地播放一个声音。
- en: 'To do so, in `jni/Ship.hpp`, retrieve a reference to `SoundManager` in the
    constructor and a collision sound buffer to play in `registerShip()`:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，在`jni/Ship.hpp`中，在构造函数中获取对`SoundManager`的引用，并在`registerShip()`中播放一个碰撞声音缓冲区：
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in `jni/Ship.cpp`, after having stored all the necessary references,
    play the sound when the ship is initialized:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`jni/Ship.cpp`中，在存储了所有必要的引用之后，在初始化飞船时播放声音：
- en: '[PRE37]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `jni/DroidBlaster.hpp`, define a reference to a file, which contains a collision
    sound:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中，定义一个对包含碰撞声音的文件的引用：
- en: '[PRE38]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, in `jni/DroidBlaster.cpp`, register the new sound and pass it to the
    `Ship` class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/DroidBlaster.cpp`中，注册新的声音并将其传递给`Ship`类：
- en: '[PRE39]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We discovered how to preload sounds in a buffer and play them as needed. What
    differentiates the sound playing technique from the BGM one seen earlier is the
    use of a buffer queue. A buffer queue is exactly what its name reveals: a **First
    In, First Out** (**FIFO**) collection of sound buffers played one after the other.
    Buffers are enqueued for playback when all the previous buffers are played.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何在缓冲区中预加载声音，并在需要时播放它们。这种声音播放技术与之前看到的背景音乐（BGM）技术的不同之处在于使用了缓冲队列。缓冲队列正是其名称所揭示的：一个**先进先出**（**FIFO**）的声音缓冲集合，一个接一个地播放。当前一个缓冲区播放完毕后，缓冲区会被加入队列以便播放。
- en: 'Buffers can be recycled. This technique is essential in combination with streaming
    files: two or more buffers are filled and sent to the queue. When the first buffer
    has finished playing, the second one starts while the first buffer is filled with
    new data. As soon as possible, the first buffer is enqueued before the queue gets
    empty. This process repeats forever until the playback is over. In addition, buffers
    are raw data and can thus be processed or filtered on the fly.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可以被回收利用。这种技术与流式文件结合使用时至关重要：两个或多个缓冲区被填充并发送到队列中。当第一个缓冲区播放完毕后，第二个缓冲区开始播放，同时第一个缓冲区被填充新数据。尽可能快地，在队列空之前将第一个缓冲区加入队列。这个过程会一直重复，直到播放结束。此外，缓冲区是原始数据，因此可以在飞行中进行处理或过滤。
- en: In the present tutorial, because `DroidBlaster` does not need to play more than
    one sound at once and no form of streaming is necessary, the buffer queue size
    is simply set to one buffer (step 7, `dataLocatorIn.numBuffers = 1;`). In addition,
    we want new sounds to pre-empt older ones, which explains why the queue is systematically
    cleared. Your OpenSL ES architecture should, of course, be adapted to your needs.
    If it becomes necessary to play several sounds simultaneously, several audio players
    (and therefore buffer queues) should be created.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，因为`DroidBlaster`不需要同时播放多个声音，也没有流式播放的需求，所以缓冲队列的大小被简单地设置为一个缓冲区（第7步，`dataLocatorIn.numBuffers
    = 1;`）。此外，我们希望新的声音能够抢占旧的声音，这就解释了为什么队列会被系统地清空。当然，你的OpenSL ES架构应根据你的需求来调整。如果需要同时播放多个声音，应该创建多个音频播放器（以及相应的缓冲队列）。
- en: Sound buffers are stored in the PCM format, which does not self-describe its
    internal format. Sampling, encoding, and other format information needs to be
    selected in the application code. Although this is fine for most of them, a solution,
    if that is not flexible enough, can be to load a Wave file, which contains all
    the necessary header information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 声音缓冲区以 PCM 格式存储，这种格式不能自描述其内部格式。采样率、编码和其他格式信息需要在应用程序代码中选定。尽管这对于大多数情况是合适的，但如果不够灵活，解决方案可以是加载一个
    Wave 文件，其中包含所有必要的头信息。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A great open source tool to filter and sequence sounds is **Audacity**. It allows
    altering the sampling rate and modifying channels (Mono/Stereo). Audacity is able
    to export as well as import sound as raw PCM data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开源工具，用于过滤和序列化声音是**Audacity**。它允许改变采样率以及修改声道（单声道/立体声）。Audacity 能够以原始 PCM
    数据的形式导入和导出声音。
- en: Using callbacks to detect sound queue events
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调来检测声音队列事件
- en: 'It is possible to detect when a sound has finished playing using callbacks.
    A callback can be set up by calling the `RegisterCallback()` method on a queue
    (but other types of objects can also register callbacks). For example, the callback
    can receive this, that is, a `SoundManager` self-reference, to allow processing
    with any contextual information if needed. Although this is facultative, an event
    mask is set up to ensure that the callback is called only when the `SL_PLAYEVENT_HEADATEND`
    (player has finished playing the buffer) event is triggered. A few others play
    events are available in `OpenSLES.h`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用回调来检测声音是否播放完毕。通过在队列上调用`RegisterCallback()`方法可以设置一个回调（但其他类型的对象也可以注册回调）。例如，回调可以接收这个，也就是一个`SoundManager`自身的引用，以便在需要时允许使用任何上下文信息进行处理。尽管这是可选的，但设置一个事件掩码可以确保仅在触发`SL_PLAYEVENT_HEADATEND`（播放器已播放完缓冲区）事件时调用回调。`OpenSLES.h`中还有其他一些播放事件可用：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, when a buffer finishes playing, a message is logged. Operations such as,
    enqueuing a new buffer (to handle streaming for example) can be performed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个缓冲区播放完毕时，会记录一条消息。可以执行诸如入队新缓冲区（例如处理流式传输）的操作。
- en: Low latency on Android
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓上的低延迟
- en: Callbacks are like system interruptions or application events, their processing
    must be short and fast. If advanced processing is necessary, it should not be
    performed inside the callback but on another thread- native threads being perfect
    candidates.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回调类似于系统中断或应用事件，它们的处理必须是短而快的。如果需要进行高级处理，不应该在回调内部执行，而应该在另一个线程上执行——原生线程是完美的候选者。
- en: Indeed, callbacks are emitted on a system thread, different than the one requesting
    OpenSL ES services (that is, the `NativeActivity` native thread in our case).
    Of course, with threads, arises the problem of thread-safety when accessing your
    own variables from the callback. Although protecting code with mutexes is tempting,
    they are not the best way to deal with real-time audio. Their effect on scheduling
    (**inversion of priority** issues for example) can cause glitches during playback.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，回调是在一个系统线程上触发的，这个线程与请求 OpenSL ES 服务的线程不同（在我们的案例中，就是`NativeActivity`原生线程）。当然，涉及到线程时，就会遇到从回调中访问你自己的变量时的线程安全问题。虽然使用互斥锁保护代码很诱人，但这并不是处理实时音频的最佳方式。它们对调度的效果（例如**优先级反转**问题）可能会导致播放过程中的故障。
- en: So, prefer using thread-safe techniques, like a lock-free queue to communicate
    with callbacks. Lock-free techniques can be implemented using GCC built-in atomic
    functions such as `__sync_fetch_and_add()` (which does not require any include
    file). For more information about atomic operations with the Android NDK, have
    a look at, `${ANDROID_NDK}/docs/ANDROID-ATOMICS.html`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议使用线程安全的技术，比如使用无锁队列与回调进行通信。无锁技术可以通过使用 GCC 内置的原子函数来实现，例如`__sync_fetch_and_add()`（它不需要包含任何头文件）。关于使用
    Android NDK 进行原子操作的信息，可以查看`${ANDROID_NDK}/docs/ANDROID-ATOMICS.html`。
- en: 'Although proper lock-free code is essential to achieve low-latency on Android,
    another important point to consider is that not all Android platforms and devices
    are suited for it! Indeed, low latency support came quite late in Android, starting
    from OS Version 4.1/4.2\. If you are in the need for low latency, you can check
    its support with the following piece of Java code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写正确的无锁代码对于在安卓上实现低延迟至关重要，但另一个需要考虑的重要点是，并非所有的安卓平台和设备都适合这样做！实际上，低延迟支持在安卓系统中出现得相当晚，从操作系统版本
    4.1/4.2 开始提供。如果你需要低延迟，可以使用以下 Java 代码片段来检查它的支持情况：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, beware! Many devices, even with the latest system versions, cannot
    achieve low latencies because of driver issues.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意！许多设备即使安装了最新的系统版本，由于驱动问题也无法实现低延迟。
- en: 'Once you know that the target platform supports low-latency, take care of using
    the proper sampling rate and buffer size. Indeed, the Android audio system provides
    a "fast path", which does not apply any resampling, when using the optimal configuration.
    To do so, from API level 17 or higher, use `android.media.AudioManager.getProperty()`
    from the Java side:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定目标平台支持低延迟后，要注意使用适当的采样率和缓冲区大小。实际上，当使用最佳配置时，Android音频系统提供了一个“快速路径”，不进行任何重采样。为此，从API级别17或更高版本开始，在Java端使用`android.media.AudioManager.getProperty()`：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information on this subject, have a look at the *High Performance*
    *Audio* talk at [https://developers.google.com/events/io/sessions/325993827](https://developers.google.com/events/io/sessions/325993827).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于这个主题的信息，请查看[高性能音频](https://developers.google.com/events/io/sessions/325993827)的演讲。
- en: Recording sounds
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制声音
- en: Android devices are all about interactions. Interactions can come not only from
    touches and sensors, but also from audio input. Most Android devices provide a
    microphone to record sound and allow an application such as the Android desktop
    search to offer vocal features to record queries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备都是关于交互的。交互不仅来自触摸和传感器，还来自音频输入。大多数Android设备提供了麦克风来录制声音，并允许应用程序如Android桌面搜索提供语音功能来记录查询。
- en: If the sound input is available, OpenSL ES gives native access to the sound
    recorder. It collaborates with a buffer queue to take data from the input device
    and fill an output sound buffer from it. The setup is pretty similar to what has
    been done with `AudioPlayer`, except that data source and data sink are permuted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音输入可用，OpenSL ES提供了对录音机的本地访问。它与缓冲队列协作，从输入设备获取数据并填充输出声音缓冲区。这个设置与`AudioPlayer`的处理非常相似，除了数据源和数据接收器位置互换。
- en: Have a go hero – recording and playing a sound
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战英雄——录音与播放声音
- en: 'To discover how recording works, record a sound when an application starts
    and play it when it has finished recording. Turning `SoundManager` into a recorder
    can be done in four steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解录音是如何工作的，可以在应用程序启动时录音，并在录音完成后播放。将`SoundManager`转变为录音器可以通过四个步骤完成：
- en: Using status `startSoundRecorder()` to initialize the sound recorder. Invoke
    it right after `startSoundPlayer()`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`startSoundRecorder()`状态来初始化声音录音机。在`startSoundPlayer()`之后立即调用它。
- en: With void `recordSound()`, start recording a sound buffer with device micro.
    Invoke this method at instances such as when the application is activated in `onActivate()`
    after the background music playback starts.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`void recordSound()`，开始使用设备麦克风录制声音缓冲区。在应用程序在`onActivate()`激活时调用此方法，例如背景音乐播放开始后。
- en: A new callback static `void callback_recorder(SLAndroidSimpleBufferQueueItf,
    void*)` to be notified of the record queue events. You have to register this callback
    so that it is triggered when a recorder event happens. Here, we are interested
    in buffer full events, that is, when the sound recording is finished.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的回调静态`void callback_recorder(SLAndroidSimpleBufferQueueItf, void*)`用来通知录音队列事件。你需要注册这个回调，以便在录音事件发生时触发它。在这里，我们关心的是缓冲区满的事件，即声音录制完成时。
- en: '`void playRecordedSound()` to play a sound once recorded. Play it at instances
    such as when the sound has finished being recorded in `callback_recorder()`. This
    is not technically correct because of potential race conditions but is fine for
    an illustration.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void playRecordedSound()`用于录制声音后播放。在例如`callback_recorder()`中声音录制完成时播放它。这从技术上来说并不完全正确，因为可能存在竞态条件，但作为示例是足够的。'
- en: Note
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_PartRecorder`.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书提供的成品项目名为`DroidBlaster_PartRecorder`。
- en: 'Before going any further, recording requires a specific Android permission
    and, of course, an appropriate Android device (you would not like an application
    to record your secret conversations behind your back!). This authorization has
    to be requested in the Android manifest:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步操作之前，录音需要特定的Android权限，当然还需要一个合适的Android设备（你不会希望应用程序在背后记录你的秘密对话吧！）。这个授权需要在Android清单中请求：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Creating and releasing the recorder
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并发布录音器
- en: 'Sounds are recorded with a recorder object created from the OpenSL ES engine,
    as usual. The recorder offers two interesting interfaces:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 声音通常是通过从OpenSL ES引擎创建的录音对象进行录音的。录音器提供了两个有趣的接口：
- en: '`SLRecordItf`: This interface is used to start and stop recording. The identifier
    is `SL_IID_RECORD`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLRecordItf`：这个接口用于开始和停止录制。其标识符为`SL_IID_RECORD`。'
- en: '`SLAndroidSImpleBufferQueueItf`: This manages a sound queue for the recorder.
    This is an Android extension provided by NDK because the current OpenSL ES 1.0.1
    specification does not support recording to a queue. The identifier is `SL_IID_ANDROIDSIMPLEBUFFERQUEUE`:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLAndroidSImpleBufferQueueItf`：这个接口管理录音机的声音队列。这是由NDK提供的Android扩展，因为当前的OpenSL
    ES 1.0.1规范不支持录制到队列中。其标识符为`SL_IID_ANDROIDSIMPLEBUFFERQUEUE`：'
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To create the recorder, you will need to declare your audio source and sink,
    similar to the following one. The data source is not a sound but a default recorder
    device (such as a microphone). On the other hand, the data sink (that is, the
    output channel) is not a speaker but a sound buffer in the PCM format (with the
    requested sampling, encoding, and endianness). The Android extension `SLDataLocator_AndroidSimpleBufferQueue`
    must be used to work with a recorder since the standard OpenSL buffer queues will
    not:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建录音机，你需要声明你的音频源和接收器，类似于以下内容。数据源不是声音，而是默认的录音设备（如麦克风）。另一方面，数据接收器（即输出通道）不是扬声器，而是PCM格式的声音缓冲区（具有请求的采样率、编码和字节序）。由于标准OpenSL缓冲队列无法工作，因此必须使用Android扩展`SLDataLocator_AndroidSimpleBufferQueue`来处理录音机：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When an application ends, do not forget to release the recorder object as all
    other OpenSL objects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序结束时，别忘了释放录音机对象，就像其他所有OpenSL对象一样。
- en: Recording a sound
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录制声音
- en: 'To record a sound, you need to create a sound buffer with an appropriate size
    according to the duration of your recording. You can adapt the `Sound` class to
    allow the creation of an empty buffer with a given size. The size depends on the
    sampling rate. For example, for a record of `2` seconds with a sampling rate of
    `44100` Hz and `16`-bit quality, the sound buffer size would look like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制声音，你需要根据录制时长创建一个适当大小的声音缓冲区。你可以调整`Sound`类，以允许创建给定大小的空缓冲区。大小取决于采样率。例如，对于`2`秒的录制，采样率为`44100`
    Hz和`16`位质量，声音缓冲区大小如下所示：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `recordSound()`, first stop the recorder, thanks to `SLRecordItf`, to ensure
    it is not already recording. Then, clear the queue to ensure your record buffer
    is used immediately. Finally, you can enqueue a new buffer and start recording:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recordSound()`中，首先通过`SLRecordItf`停止录音机，以确保它没有在录制。然后，清除队列以确保你的录音缓冲区立即使用。最后，你可以排队一个新的缓冲区并开始录制：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is perfectly possible to enqueue new sound buffers so that any current recording
    is processed to its end. This allows creating a continuous chain of recording
    or, in other words, streaming the recording. The sound being enqueued will be
    processed only once the previous is filled.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以排队新的声音缓冲区，以便处理完当前录制的内容。这允许创建连续的录制链，换句话说，就是录制流。排队的声音只有在之前的缓冲区填满后才会被处理。
- en: Recording a callback
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录制回调
- en: 'You eventually need to know when your sound buffer has finished recording.
    To do so, register a callback triggered when a recorder event happens (for example,
    a buffer has been filled). An event mask should be set to ensure that callback
    is called only when a buffer has been filled (`SL_RECORDEVENT_BUFFER_FULL`). A
    few others are available in `OpenSLES.h`, but not all are supported (`SL_RECORDEVENT_HEADATLIMIT`,
    and so on):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终需要知道你的声音缓冲区何时完成录制。为此，注册一个在录音事件发生时触发的回调（例如，一个缓冲区已满）。应设置一个事件掩码，以确保仅在缓冲区已满时调用回调（`SL_RECORDEVENT_BUFFER_FULL`）。在`OpenSLES.h`中有其他一些可用，但并非所有都受支持（如`SL_RECORDEVENT_HEADATLIMIT`等）：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, when `callback_recorder()` is triggered, stop recording and play the
    recorded buffer with `playRecordedSound()`. The recorded buffer needs to be enqueued
    in the audio player's queue for playback, as we did in the previous section. You
    can use a specific `SoundQueue` to play the sound for simplicity purposes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当`callback_recorder()`被触发时，停止录制并通过`playRecordedSound()`播放已录制的缓冲区。录制的缓冲区需要像前一部分一样排入音频播放器的队列中以便播放。为了简化，你可以使用特定的`SoundQueue`来播放声音。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In summary, we saw in this chapter how to initialize OpenSL ES on Android. The
    engine object is the main entry point to manage all OpenSL objects. Objects in
    OpenSL follow a specific lifecycle of creation, realization, and destruction.
    Then, we saw how to play background music from an encoded file and in-memory sounds
    with a sound buffer queue. Finally, we discovered how to record and then play
    a sound in a way that is thread-safe and non-blocking.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本章中我们了解了如何在Android上初始化 OpenSL ES。引擎对象是管理所有OpenSL对象的主要入口点。OpenSL中的对象遵循特定的生命周期：创建、实现和销毁。然后，我们学习了如何从编码文件播放背景音乐以及使用声音缓冲队列在内存中播放声音。最后，我们发现了如何以线程安全和非阻塞的方式录制并播放声音。
- en: Do you prefer OpenSL ES over Java APIs? If all you need is a nice high-level
    API, Java APIs may suit your requirements better. If you need finer playback or
    recording control, there is no significant difference between low-level Java APIs
    and OpenSL ES. In this case, the choice should be architectural. If your code
    is mainly Java, you should probably go with Java.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否更喜欢 OpenSL ES 而不是 Java API？如果你只需要一个高级别的好用API，那么Java API可能更适合你的需求。如果你需要更精细的播放或录音控制，低级Java
    API和OpenSL ES之间没有显著差异。在这种情况下，选择应该是基于架构的。如果你的代码主要是Java，那么你或许应该选择Java。
- en: If you need to reuse an existing sound-related library, optimize the performance,
    or perform intense computations, such as sound filtering on the fly, OpenSL ES
    is probably the right choice. OpenSL ES is also the way to go to low-latency,
    although Android is not quite there yet (fragmentations, device-specific issues,
    and so on). At the least, this verbose API is probably the one that is going to
    give the best performance. There is no garbage collector overhead and aggressive
    optimization is favored in the native code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复用现有的与声音相关的库，优化性能，或者执行高强度计算，比如实时声音过滤，OpenSL ES 可能是正确的选择。OpenSL ES 也是实现低延迟的方式，尽管Android在这方面还没有完全达到（存在碎片化，特定设备问题等）。至少，这个详尽的API很可能会提供最佳性能。它没有垃圾收集的开销，并且在本地代码中鼓励进行积极的优化。
- en: 'Whatever choice you make, know that the Android NDK has a lot more to offer.
    After dealing with [Chapter 6](ch06.html "Chapter 6. Rendering Graphics with OpenGL
    ES"), *Rendering Graphics with OpenGL ES* and [Chapter 7](ch07.html "Chapter 7. Playing
    Sound with OpenSL ES"), *Playing Sound with OpenSL ES*, the next chapter will
    take care of handling input natively: keyboard, touches, and sensors.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做出什么选择，要知道Android NDK还有更多内容可以提供。在处理了[第6章](ch06.html "第6章. 使用OpenGL ES渲染图形")*使用OpenGL
    ES渲染图形*和[第7章](ch07.html "第7章. 使用OpenSL ES播放声音")*使用OpenSL ES播放声音*之后，下一章将介绍如何本地处理输入：键盘、触摸和传感器。
