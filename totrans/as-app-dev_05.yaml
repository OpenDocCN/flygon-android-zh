- en: Chapter 5. Creating User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have created your first project and have become familiar with the
    code editor and its functionalities, we will begin our application by creating
    our user interface. Is there more than one way to create a user interface using
    Android Studio? How can you add components to your user interface? Have you ever
    wondered how to make your applications support different screen sizes and resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the creation of the user interfaces using layouts. The
    layouts can be created using a graphical view or a text-based view. We will learn
    how to use both of them to create our layout. We will also code a *Hello World*
    application using simple components. We will learn about fragmentation on different
    Android-based devices and how to prepare our application for this issue. We will
    end this chapter with basic notions of handling events on our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Existing layout editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the UI theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graphical editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the main layout located at `/src/main/res/layout/activity_main.xml` in
    our project. The graphical editor will be opened by default. Initially, this main
    layout contains just a text view with a **Hello world!** message. To switch between
    the graphical and the text editor, click on the bottom tabs, **Design** and **Text**.
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical editor](img/5273OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The toolbar contains some options to change the layout style and preview. The
    options of the toolbar are explained throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical editor](img/5273OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The components tree displays the components placed in the layout as a hierarchy.
    The properties inspector shows the properties of the selected component from the
    layout and it allows us to change them.
  prefs: []
  type: TYPE_NORMAL
- en: The palette lists the existing **UI** (**User Interface**) components to place
    in our layout. The palette organizes the components in different categories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**: A layout is a container object to distribute the components on
    the screen. The root element of a user interface is a layout object, but layouts
    can also contain more layouts, creating a hierarchy of components structured in
    layouts. The recommendation is to keep this layout hierarchy as simple as possible.
    Our main layout has a relative layout as a root element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widgets**: Buttons, checkboxes, text views, switches, image views, progress
    bars, spinners, or web views are in this category. They are the most common components
    used in most layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Fields**: These are inputs in which users can type text. The difference
    between them is the type of text users can type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: These are containers group components that share a common behavior.
    Radio groups, list views, scroll views, or tab hosts are some of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date & Time**: These are components related to date and time, as a calendar
    or clocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expert**: These components are not as common as the ones in the widgets category,
    but it is worth taking a look at them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: These are components that allow us to include our custom components,
    which are usually other layouts from our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text-based editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Change the graphical editor to the text editor by clicking on the **Text** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![The text-based editor](img/5273OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The toolbar is the same as the graphical editor. The preview displays the layout
    but it cannot be changed, you should use the design tab instead. The components
    are added to the layout using their XML declarations. The properties are also
    configured using the XML declarations. Like the graphical editor, the text editor
    shows just the text view element inside the root layout.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created our main activity, the associated layout was also created. This
    is a way to create a layout, while creating an activity.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add an independent layout without creating a new activity, then
    click with the right mouse button on the layouts folder (`res/layout/`) and navigate
    to **New** | **Layout resource file**. You can also navigate to the menu option
    **File** | **New** | **Layout resource file**. Type the filename and the root
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Once the layout is created, the associated activity can be changed from the
    editor to another one. If the layout has no activity, any existing one can be
    linked to it from the editor. To accomplish this, in the toolbar of the layout
    editor, search for the activity option, click on it, and select the **Associate
    with other Activity** option. A dialog box that lists all the activities of your
    project will be opened so you can select one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our main layout is a relative layout and contains a text view saying **Hello
    world!**, but let's add a new component. The easiest way to do this is using the
    graphical editor, so open the design tab. Select a component and drag it into
    the layout preview, for example, navigate to **Text Fields** | **Person Name**
    and place it below the text view.
  prefs: []
  type: TYPE_NORMAL
- en: In the component tree view, now there is a new `EditText` object. Keep the text
    field selected to examine its properties loaded in the properties inspector. Let's
    change some of them and observe the differences in the layout preview and in the
    component tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**layout:width**: Its current value is `wrap_content`. This option will adapt
    the width of the field to its content. Change it to `match_parent` to adapt it
    to the parent layout width (the root relative layout).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**hint**: Type `Enter your name` as the hint of the field. The hint is a text
    shown when the field is empty to indicate the information that should be typed.
    Due to the field having a default value, `Name`, the hint is not visible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**id**: Its current ID is `@+id/editText`. This ID will be used from the code
    to get access to this object and is the one displayed in the component tree. Change
    it to `@+id/editText_name` to easily distinguish it from other text fields. Check
    that in the component tree the component ID has also changed.![Adding components](img/5273OS_05_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**text**: Delete the value of this field. The hint should now be visible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we switch to the text editor, we can see the XML definition of the text
    field with the properties we edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the text editor, the existing components and their properties can also
    be changed. Modify the text view ID (`android:id` property) from `@+id/textView`
    to `@+id/textView_greeting`. Having a descriptive ID is important since it will
    be used from our code. Descriptive variable names allow the code to be self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another component using the text editor this time. Press the open
    tag key and start typing `Button`. Let the suggestion list appear and select a
    `Button` object. Inside the `Button` tag, add the next properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create the ID property with the value `@+id/button_accept`. Let the width and
    height adapt to the button content (`wrap_content` value). Place the button below
    the name text field using the `android:layout_below` property. We reference the
    name text field by its ID (`@+id/editText_name`). Center horizontally the button
    in the parent layout using the `layout_centerHorizontal` property. Set the text
    of the button (`Accept`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The button is displayed in the layout preview. The next screenshot shows that
    if we switch to the graphical editor, the button is also displayed in it and in
    the component tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding components](img/5273OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Supporting multiple screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating an Android application, we have to be aware of the existence of
    multiple screen sizes and screen resolutions. It is important to check how our
    layouts are displayed in different screen configurations. To accomplish this,
    Android Studio provides a functionality to change the layout preview when we are
    in the design mode.
  prefs: []
  type: TYPE_NORMAL
- en: We can find this functionality in the toolbar, the **device definition** option
    used in the preview is by default **Nexus 4**. Click on it to open the list of
    available device definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting multiple screens](img/5273OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try some of them. The difference between a tablet device and a device like the
    Nexus one are very notable. We should adapt the views to all the screen configurations
    our application supports to ensure they are displayed optimally.
  prefs: []
  type: TYPE_NORMAL
- en: The device definitions indicate the screen inches, the resolution, and the screen
    density. Android divides into ldpi, mdpi, hdpi, xhdpi, and even xxhdpi the screen
    densities.
  prefs: []
  type: TYPE_NORMAL
- en: '**ldpi** (**low-density dots per inch**): About 120 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mdpi** (**medium-density dots per inch**): About 160 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hdpi** (**high-density dots per inch**): About 240 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xhdpi** (**extra-high-density dots per inch**): About 320 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xxhdpi** (**extra-extra-high-density dots per inch**): About 480 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last dashboards published by Google show that most devices have high-density
    screens (34.3 percent), followed by xhdpi (23.7 percent) and mdpi (23.5 percent).
    Therefore, we can cover 81.5 percent of the devices by testing our application
    using these three screen densities. Official Android dashboards are available
    at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  prefs: []
  type: TYPE_NORMAL
- en: Another issue to keep in mind is the **device orientation**. Do we want to support
    the landscape mode in our application? If the answer is yes, we have to test our
    layouts in the landscape orientation. On the toolbar, click on the layout state
    option to change the mode from portrait to landscape or from landscape to portrait.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case that our application supports the landscape mode and the layout
    does not display as expected in this orientation, we may want to create a variation
    of the layout. Click on the first icon of the toolbar, that is, the configuration
    option, and select the option **Create Landscape Variation**. A new layout will
    be opened in the editor. This layout has been created in the resources folder,
    under the directory `layout-land` and using the same name as the portrait layout:
    `/src/main/res/layout-land/activity_main.xml`. Now we can edit the new layout
    variation perfectly conformed to the landscape mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a variation of the layout for *xlarge* screens. Select
    the option **Create layout-xlarge Variation**. The new layout will be created
    in the `layout-xlarge` folder: `/src/main/res/layout-xlarge/activity_main.xml`.
    Android divides into *small*, *normal*, *large*, and *xlarge* the actual screen
    sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**small**: Screens classified in this category are at least 426 dp x 320 dp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**normal**: Screens classified in this category are at least 470 dp x 320 dp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**large**: Screens classified in this category are at least 640 dp x 480 dp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xlarge**: Screens classified in this category are at least 960 dp x 720 dp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **dp** is a density independent pixel, equivalent to one physical pixel on
    a 160 dpi screen.
  prefs: []
  type: TYPE_NORMAL
- en: The last dashboards published by Google show that most devices have a normal
    screen size (79.6 percent). If you want to cover a bigger percentage of devices,
    test your application by also using a small screen (9.5 percent), so the coverage
    will be 89.1 percent of devices.
  prefs: []
  type: TYPE_NORMAL
- en: To display multiple device configurations at the same time, in the toolbar click
    on the configuration option and select the option **Preview All Screen Sizes**,
    or click on the **Preview Representative Sample** to open just the most important
    screen sizes. We can also delete any of the samples by clicking on it using the
    right mouse button and selecting the **Delete** option of the menu. Another useful
    action of this menu is the **Save screenshot** option, which allows us to take
    a screenshot of the layout preview.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting multiple screens](img/5273OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we create some layout variations, we can preview all of them selecting the
    option **Preview Layout Versions**.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the UI theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layouts and widgets are created using the default UI theme of our project. We
    can change the appearance of the elements of the UI by creating styles. Styles
    can be grouped to create a theme and a theme can be applied to a whole activity
    or application. Some themes are provided by default, such as the Holo style. Styles
    and themes are created as resources under the `/src/res/values` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the main layout using the graphical editor. The selected theme for our
    layout is indicated in the toolbar: `AppTheme`. This theme was created for our
    project and can be found in the styles file (`/src/res/values/styles.xml`). Open
    the styles file and notice that this theme is an extension of another theme (`Theme.Light`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To custom our theme, edit the styles file. For example, add the next line in
    the `AppTheme` definition to change the window background color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and switch to the layout tab. The background is now light gray.
    This background color will be applied to all our layouts due to the fact that
    we configured it in the theme and not just in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: To completely change the layout theme, click on the theme option from the toolbar
    in the graphical editor. The theme selector dialog is now opened, displaying a
    list of the available themes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the UI theme](img/5273OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The themes created in our own project are listed in the **Project Themes** section.
    The section **Manifest Themes** shows the theme configured in the application
    manifest file (`/src/main/AndroidManifest.xml`). The **All** section lists all
    the available themes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user interface would be useless if the rest of the application could not
    interact with it. Events in Android are generated when the user interacts with
    our application. All the UI widgets are children of the `View` class and they
    share some events handled by the next listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnClickListener`: Captures the event when the user clicks the view element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCreateContextMenu`: Captures the event when the user performs a long click
    on the view element and we want to open a context menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDragListener`: Captures the event when the user drags and drops the event
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnFocusChange`: Captures the event when the user navigates from an element
    to another in the same view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnKeyListener`: Captures the event when the user presses any key while the
    view element has the focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnLongClickListener`: Captures the event when the user touches the view element
    and holds it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTouchListener`: Captures the event when the user touches the view element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these events and listeners, some UI widgets have some more specific
    ones. Checkboxes can register a listener to capture when its state changes (`OnCheckedChangeListener`),
    or spinners can register a listener to capture when an item is clicked (`OnItemClickListener`).
  prefs: []
  type: TYPE_NORMAL
- en: The most common event to capture is when the user clicks on the view elements.
    For this event, there is an easy way to handle it, using the view properties.
    Select the accept button in our layout and look for the `onClick` property. This
    property indicates the name of the method that will be executed when the user
    clicks on the button. This method has to be created in the activity associated
    with the current layout, in this case, in our main activity, `MainActivity.java`.
    Type `onAcceptClick` as the value of this property.
  prefs: []
  type: TYPE_NORMAL
- en: Open the main activity to create the method definition. An event callback method
    when a view is clicked has to be public, with a void return type, and it receives
    the view that has been clicked as a parameter. This method will be executed every
    time the user clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the main activity we can interact with all the components of the interface,
    so when the user clicks on the accept button, our code can read the text from
    the name field and change the greeting to include the name in it.
  prefs: []
  type: TYPE_NORMAL
- en: To get the reference to a view object, use the `findViewById` method inherited
    from the `Activity` class. This method receives the ID of the component and returns
    the `View` object corresponding to that ID. The returned view object has to be
    casted to its specific class in order to use its methods, such as the `getText`
    method of the `EditText` class to get the name typed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first two lines of the method, the references to the elements of the
    layout are retrieved: the text view that contains the greeting and the text field
    where the user can type a name. The components are found by its ID, the same ID
    we indicated in the properties of the element in the layout file. All the IDs
    of resources are included in the `R` class. The `R` class is autogenerated in
    the build phase and we must not edit it. If this class is not autogenerated, then
    probably some file of our resources contains an error.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line is a conditional statement to check that the user typed a name,
    a case in which the text will be replaced by a new greeting that contains that
    name. In the next chapters we will learn how to execute our application in an
    emulator and we will be able to test this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case the event we want to handle is not the user click, then we have to
    create and add the listener by code in the `onCreate` method of the activity.
    There are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the listener interface in the activity and then add the unimplemented
    methods. The methods required by the interface are the methods to receive the
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a private anonymous implementation of the listener in the activity file.
    The methods that receive the events are implemented in this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the listener implementation has to be assigned to the view element
    using the setter methods, `setOnClickListener`, `setOnCreateContextMenu`, `setOnDragListener`,
    `setOnFocusChange`, `setOnKeyListener`, and so on. The listener assignment is
    usually included in the `onCreate` method of the activity. If the listener was
    implemented directly by the activity, then the parameter indicated to the setter
    method is its own activity using the keyword `this` as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The activity should then implement the listener and the `onClick` method required
    by the listener interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, we have learned how to create and edit the user
    interface layouts by using both the graphical and the text-based editors. We finished
    our first small application and we have upgraded it with some basic components.
    The user should now be able to create a simple layout and to test it with different
    styles, screens sizes and screen resolutions. We have also learned about the different
    available UI themes and finally, we have learned about events and how to handle
    them using listeners.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about Google Play available services and how
    to integrate them into our project using Android Studio. We will learn how to
    install and integrate different libraries available with Google technology such
    as Google Maps, Google Plus, and more.
  prefs: []
  type: TYPE_NORMAL
