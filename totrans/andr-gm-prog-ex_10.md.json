["```java\npublic class Border extends GameObject{\n\n  public Border(float mapWidth, float mapHeight){\n\n        setType(Type.BORDER);\n        //border center is the exact center of map\n        setWorldLocation(mapWidth/2,mapHeight/2);\n\n        float w = mapWidth;\n        float h = mapHeight;\n        setSize(w, h);\n\n       // The vertices of the border represent four lines\n       // that create a border of a size passed into the constructor\n       float[] borderVertices = new float[]{\n           // A line from point 1 to point 2\n            - w/2, -h/2, 0,\n            w/2, -h/2, 0,\n            // Point 2 to point 3\n            w/2, -h/2, 0,\n            w/2, h/2, 0,\n            // Point 3 to point 4\n            w/2, h/2, 0,\n            -w/2, h/2, 0,\n            // Point 4 to point 1\n            -w/2, h/2, 0,\n            - w/2, -h/2, 0,\n    };\n\n        setVertices(borderVertices);\n\n  }\n\n}\n```", "```java\n// Our game objects\nSpaceShip ship;\nBorder border;\n\n```", "```java\n// Create our game objects\n\n// First the ship in the center of the map\ngm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n\n// The deadly border\ngm.border = new Border(gm.mapWidth, gm.mapHeight);\n\n```", "```java\ngm.ship.draw(viewportMatrix);\ngm.border.draw(viewportMatrix);\n\n```", "```java\nsetWorldLocation(10,10);\n```", "```java\nsetWorldLocation(worldLocationX,worldLocationY);\n```", "```java\npublic class Star extends GameObject{\n\n    // Declare a random object here because\n    // we will use it in the update() method\n    // and we don't want GC to have to keep clearing it up\n    Random r;\n\n    public Star(int mapWidth, int mapHeight){\n    setType(Type.STAR);\n    r = new Random();\n    setWorldLocation(r.nextInt(mapWidth),r.nextInt(mapHeight));\n\n    // Define the star\n    // as a single point\n    // in exactly the coordinates as its world location\n    float[] starVertices = new float[]{\n\n                0,\n                0,\n                0\n\n    };\n\n    setVertices(starVertices);\n\n    }\n```", "```java\npublic void update(){\n\n  // Randomly twinkle the stars\n     int n = r.nextInt(1000);\n     if(n == 0){\n       // Switch on or off\n       if(isActive()){\n         setActive(false);\n        }else{\n          setActive(true);\n        }\n   }\n\n}\n```", "```java\n// Our game objects\nSpaceShip ship;\nBorder border;\nStar[] stars;\nint numStars = 200;\n\n```", "```java\n// The deadly border\ngm.border = new Border(gm.mapWidth, gm.mapHeight);\n\n// Some stars\ngm.stars = new Star[gm.numStars];\nfor (int i = 0; i < gm.numStars; i++) {\n\n // Pass in the map size so the stars no where to spawn\n gm.stars[i] = new Star(gm.mapWidth, gm.mapHeight);\n}\n\n```", "```java\n// Start drawing!\n\n// Some stars\nfor (int i = 0; i < gm.numStars; i++) {\n\n // Draw the star if it is active\n if(gm.stars[i].isActive()) {\n gm.stars[i].draw(viewportMatrix);\n }\n}\n\ngm.ship.draw(viewportMatrix);\ngm.border.draw(viewportMatrix);\n```", "```java\nprivate void update(long fps) {\n\n // Update (twinkle) the stars\n for (int i = 0; i < gm.numStars; i++) {\n gm.stars[i].update();\n }\n\n}\n```", "```java\npublic void setRotationRate(float rotationRate) {\n  this.rotationRate = rotationRate;\n}\n\npublic float getTravellingAngle() {\n  return travellingAngle;\n}\n\npublic void setTravellingAngle(float travellingAngle) {\n  this.travellingAngle = travellingAngle;\n}\n\npublic float getFacingAngle() {\n  return facingAngle;\n}\n\npublic void setFacingAngle(float facingAngle) {\n  this.facingAngle = facingAngle;\n}\n```", "```java\nvoid move(float fps){\n  if(xVelocity != 0) {\n       worldLocation.x += xVelocity / fps;\n    }\n\n     if(yVelocity != 0) {\n       worldLocation.y += yVelocity / fps;\n    }\n\n     // Rotate\n     if(rotationRate != 0) {\n       facingAngle = facingAngle + rotationRate / fps;\n    }\n\n}\n```", "```java\npublic float getxVelocity() {\n  return xVelocity;\n}\n\npublic void setxVelocity(float xVelocity) {\n  this.xVelocity = xVelocity;\n}\n\npublic float getyVelocity() {\n  return yVelocity;\n}\n\npublic void setyVelocity(float yVelocity) {\n  this.yVelocity = yVelocity;\n}\n\npublic float getSpeed() {\n  return speed;\n}\n\npublic void setSpeed(float speed) {\n  this.speed = speed;\n}\n\npublic float getMaxSpeed() {\n  return maxSpeed;\n}\n\npublic void setMaxSpeed(float maxSpeed) {\n  this.maxSpeed = maxSpeed;\n}\n```", "```java\nboolean isThrusting;\nprivate boolean isPressingRight = false;\nprivate boolean isPressingLeft = false;\n```", "```java\nsetSize(width, length);\n\nsetMaxSpeed(150);\n\n// It will be useful to have a copy of the\n```", "```java\npublic void update(long fps){\n\nfloat speed = getSpeed();\nif(isThrusting) {\n  if (speed < getMaxSpeed()){\n       setSpeed(speed + 5);\n     }\n\n     }else{\n       if(speed > 0) {\n         setSpeed(speed - 3);\n        }else {\n         setSpeed(0);\n        }\n}\n```", "```java\nsetxVelocity((float) \n  (speed* Math.cos(Math.toRadians(getFacingAngle() + 90))));\n\nsetyVelocity((float) \n  (speed* Math.sin(Math.toRadians(getFacingAngle() + 90))));\n\n```", "```java\nif(isPressingLeft){\n  setRotationRate(360);\n}\n\nelse if(isPressingRight){\n  setRotationRate(-360);\n     }else{\n       setRotationRate(0);\n    }\n\n     move(fps);\n}\n```", "```java\npublic boolean pullTrigger() {\n  //Try and fire a shot\n  // We could control rate of fire from here\n  // But lets just return true for unrestricted rapid fire\n  // You could remove this method and any code which calls it\n\n   return true;\n}\n\npublic void setPressingRight(boolean pressingRight) {\n  isPressingRight = pressingRight;\n}\n\npublic void setPressingLeft(boolean pressingLeft) {\n  isPressingLeft = pressingLeft;\n}\n\npublic void toggleThrust() {\n  isThrusting = ! isThrusting;\n}\n```", "```java\n// Update (twinkle) the stars\nfor (int i = 0; i < gm.numStars; i++) {\n  gm.stars[i].update();\n}\n\n// Run the ship,s update() method\ngm.ship.update(fps);\n\n```", "```java\npublic class Bullet extends GameObject {\n\n  private boolean inFlight = false;\n\n  public Bullet(float shipX, float shipY) {\n       super();\n\n       setType(Type.BULLET);\n\n       setWorldLocation(shipX, shipY);\n\n       // Define the bullet\n       // as a single point\n       // in exactly the coordinates as its world location\n       float[] bulletVertices = new float[]{\n\n                0,\n                0,\n                0\n\n       };\n\n    setVertices(bulletVertices);\n\n}\n```", "```java\npublic void shoot(float shipFacingAngle){\n\n     setFacingAngle(shipFacingAngle);\n     inFlight = true;\n     setSpeed (300);\n}\n\npublic void resetBullet(PointF shipLocation){\n\n     // Stop moving if bullet out of bounds\n     inFlight = false;\n     setxVelocity(0);\n     setyVelocity(0);\n     setSpeed(0);\n     setWorldLocation(shipLocation.x, shipLocation.y);\n\n}\n\npublic boolean isInFlight(){\n  return  inFlight;\n}\n```", "```java\npublic void update(long fps, PointF shipLocation){\n        // Set the velocity if bullet in flight\n        if(inFlight){\n            setxVelocity((float)(getSpeed()* \n               Math.cos(Math.toRadians(getFacingAngle() + 90))));\n            setyVelocity((float)(getSpeed()* \n               Math.sin(Math.toRadians(getFacingAngle() + 90))));\n        }else{\n            // Have it sit inside the ship\n            setWorldLocation(shipLocation.x, shipLocation.y);\n        }\n\n        move(fps);\n    }\n}\n```", "```java\nint numStars = 200;\nBullet [] bullets;\nint numBullets = 20;\n\n```", "```java\n// Some bullets\ngm.bullets = new Bullet[gm.numBullets];\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i] = new Bullet(\n     gm.ship.getWorldLocation().x,\n     gm.ship.getWorldLocation().y);\n}\n```", "```java\n// Update all the bullets\nfor (int i = 0; i < gm.numBullets; i++) {\n\n    // If not in flight they will need the ships location\n    gm.bullets[i].update(fps, gm.ship.getWorldLocation());\n\n}\n```", "```java\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i].draw(viewportMatrix);\n}\n```", "```java\nprivate InputController ic;\nprivate SoundManager sm;\n```", "```java\npublic AsteroidsView(Context context, int screenX, int screenY) {\n  super(context);\n\n sm = new SoundManager();\n sm.loadSound(context);\n ic = new InputController(screenX, screenY);\n     gm = new GameManager(screenX, screenY);\n```", "```java\nsetEGLContextClientVersion(2);\nsetRenderer(new AsteroidsRenderer(gm,sm,ic));\n\n```", "```java\npublic AsteroidsRenderer(GameManager gameManager,\n SoundManager soundManager, InputController inputController) {\n\n        gm = gameManager;\n sm = soundManager;\n ic = inputController;\n\n       handyPointF = new PointF();\n       handyPointF2 = new PointF();\n\n}\n```", "```java\npublic class SoundManager {\n    private SoundPool soundPool;\n    private int shoot = -1;\n    private int thrust = -1;\n    private int explode = -1;\n    private int shipexplode = -1;\n    private int ricochet = -1;\n    private int blip = -1;\n    private int nextlevel = -1;\n    private int gameover = -1;\n\n    public void loadSound(Context context){\n        soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);\n        try{\n            //Create objects of the 2 required classes\n            AssetManager assetManager = context.getAssets();\n            AssetFileDescriptor descriptor;\n\n            //create our fx\n            descriptor = assetManager.openFd(\"shoot.ogg\");\n            shoot = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"thrust.ogg\");\n            thrust = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"explode.ogg\");\n            explode = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"shipexplode.ogg\");\n            shipexplode = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"ricochet.ogg\");\n            ricochet = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"blip.ogg\");\n            blip = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"nextlevel.ogg\");\n            nextlevel = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"gameover.ogg\");\n            gameover = soundPool.load(descriptor, 0);\n\n        }catch(IOException e){\n            //Print an error message to the console\n            Log.e(\"error\", \"failed to load sound files\");\n        }\n    }\n\n    public void playSound(String sound){\n        switch (sound){\n            case \"shoot\":\n                soundPool.play(shoot, 1, 1, 0, 0, 1);\n                break;\n\n            case \"thrust\":\n                soundPool.play(thrust, 1, 1, 0, 0, 1);\n                break;\n\n            case \"explode\":\n                soundPool.play(explode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"shipexplode\":\n                soundPool.play(shipexplode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"ricochet\":\n                soundPool.play(ricochet, 1, 1, 0, 0, 1);\n                break;\n\n            case \"blip\":\n                soundPool.play(blip, 1, 1, 0, 0, 1);\n                break;\n\n            case \"nextlevel\":\n                soundPool.play(nextlevel, 1, 1, 0, 0, 1);\n                break;\n\n            case \"gameover\":\n                soundPool.play(gameover, 1, 1, 0, 0, 1);\n                break;\n\n        }\n\n    }\n}\n```", "```java\n@Override\n    public boolean onTouchEvent(MotionEvent motionEvent) {\n        ic.handleInput(motionEvent, gm, sm);\n        return true;\n    }\n```", "```java\npublic class InputController {\n\n    private int currentBullet;\n\n    Rect left;\n    Rect right;\n    Rect thrust;\n    Rect shoot;\n    Rect pause;\n\n    InputController(int screenWidth, int screenHeight) {\n\n        //Configure the player buttons\n        int buttonWidth = screenWidth / 8;\n        int buttonHeight = screenHeight / 7;\n        int buttonPadding = screenWidth / 80;\n\n        left = new Rect(buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth,\n            screenHeight - buttonPadding);\n\n        right = new Rect(buttonWidth + buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth + buttonPadding + buttonWidth,\n            screenHeight - buttonPadding);\n\n        thrust = new Rect(screenWidth - buttonWidth - \n            buttonPadding,\n            screenHeight - buttonHeight - buttonPadding - \n            buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding - buttonHeight - \n            buttonPadding);\n\n        shoot = new Rect(screenWidth - buttonWidth - \n            buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding);\n\n        pause = new Rect(screenWidth - buttonPadding - \n            buttonWidth,\n            buttonPadding,\n            screenWidth - buttonPadding,\n            buttonPadding + buttonHeight);\n```", "```java\n    }    \n    public ArrayList getButtons(){\n\n        //create an array of buttons for the draw method\n        ArrayList<Rect> currentButtonList = new ArrayList<>();\n        currentButtonList.add(left);\n        currentButtonList.add(right);\n        currentButtonList.add(thrust);\n        currentButtonList.add(shoot);\n        currentButtonList.add(pause);\n        return  currentButtonList;\n    }\n```", "```java\npublic void handleInput(MotionEvent motionEvent,GameManager l,                                      \n  SoundManager sound){\n\n        int pointerCount = motionEvent.getPointerCount();\n\n        for (int i = 0; i < pointerCount; i++) {\n        int x = (int) motionEvent.getX(i);\n        int y = (int) motionEvent.getY(i);\n\n          switch (motionEvent.getAction() & \n             MotionEvent.ACTION_MASK) {\n\n            case MotionEvent.ACTION_DOWN:\n                    if (right.contains(x, y)) {\n                    l.ship.setPressingRight(true);\n                    l.ship.setPressingLeft(false);\n                 } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(true);\n                    l.ship.setPressingRight(false);\n                    } else if (thrust.contains(x, y)) {\n                    l.ship.toggleThrust();\n                    } else if (shoot.contains(x, y)) {\n                        if (l.ship.pullTrigger()) {\n                        l.bullets[currentBullet].shoot\n                                (l.ship.getFacingAngle());\n\n                            currentBullet++;\n                       // If we are on the last bullet restart\n                       // from the first one again\n                       if(currentBullet == l.numBullets){\n                            currentBullet = 0;\n                        }\n\n                           sound.playSound(\"shoot\");\n                    }\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                    }\n                    break;\n\n            case MotionEvent.ACTION_UP:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(false);\n                }\n\n                break;\n\n            case MotionEvent.ACTION_POINTER_DOWN:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(true);\n                    l.ship.setPressingLeft(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(true);\n                 l.ship.setPressingRight(false);\n                } else if (thrust.contains(x, y)) {\n                    l.ship.toggleThrust();\n                } else if (shoot.contains(x, y)) {\n                    if (l.ship.pullTrigger()) {\n                    l.bullets[currentBullet].shoot\n                            (l.ship.getFacingAngle());\n\n                        currentBullet++;\n                    // If we are on the last bullet restart\n                    // from the first one again\n                    if(currentBullet == l.numBullets){\n                        currentBullet = 0;\n                    }\n                    sound.playSound(\"shoot\");\n                    }\n                } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                }\n                break;\n\n            case MotionEvent.ACTION_POINTER_UP:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(false);\n                }\n\n                break;\n            }\n         }\n\n    }\n}\n```", "```java\npublic class Asteroid extends GameObject{\n\n    PointF[] points;\n\n    public Asteroid(int levelNumber, int mapWidth, int mapHeight){\n        super();\n\n        // set a random rotation rate in degrees per second\n        Random r = new Random();\n        setRotationRate(r.nextInt(50 * levelNumber) + 10);\n\n        // travel at any random angle\n        setTravellingAngle(r.nextInt(360));\n\n        // Spawn asteroids between 50 and 550 on x and y\n        // And avoid the extreme edges of map\n        int x = r.nextInt(mapWidth - 100)+50;\n        int y = r.nextInt(mapHeight - 100)+50;\n\n        // Avoid the center where the player spawns\n        if(x > 250 && x < 350){ x = x + 100;}\n        if(y > 250 && y < 350){ y = y + 100;}\n\n        // Set the location\n        setWorldLocation(x,y);\n\n        // Make them a random speed with the maximum\n        // being appropriate to the level number\n        setSpeed(r.nextInt(25 * levelNumber)+1);\n\n        setMaxSpeed(140);\n\n        // Cap the speed\n        if (getSpeed() > getMaxSpeed()){\n            setSpeed(getMaxSpeed());\n        }\n\n        // Make sure we know this object is a ship\n        setType(Type.ASTEROID);\n\n        // Define a random asteroid shape\n        // Then call the parent setVertices()\n        generatePoints();\n\n    }\n```", "```java\npublic void update(float fps){\n\n  setxVelocity ((float) (getSpeed() * Math.cos(Math.toRadians  (getTravellingAngle() + 90))));\n\n  setyVelocity ((float) (getSpeed() * Math.sin(Math.toRadians(getTravellingAngle() + 90))));\n\n     move(fps);\n\n}\n```", "```java\n// Create a random asteroid shape\npublic void generatePoints(){\n  points = new PointF[7];\n\n   Random r = new Random();\n   int i;\n\n     // First a point roughly centre below 0\n     points[0] = new PointF();\n     i = (r.nextInt(10))+1;\n     if(i % 2 == 0){i = -i;}\n     points[0].x = i;\n     i = -(r.nextInt(20)+5);\n     points[0].y = i;\n\n     // Now a point still below centre but to the right and up a bit\n     points[1] = new PointF();\n     i = r.nextInt(14)+11;\n     points[1].x = i;\n     i = -(r.nextInt(12)+1);\n     points[1].y =  i;\n\n     // Above 0 to the right\n     points[2] = new PointF();\n     i = r.nextInt(14)+11;\n     points[1].x = i;\n     i = r.nextInt(12)+1;\n     points[2].y = i;\n\n     // A point roughly centre above 0\n     points[3] = new PointF();\n     i = (r.nextInt(10))+1;\n     if(i % 2 == 0){i = -i;}\n     points[3].x = i;\n     i = r.nextInt(20)+5;\n     points[3].y =  i;\n\n     // left above 0\n     points[4] = new PointF();\n     i = -(r.nextInt(14)+11);\n     points[4].x = i;\n     i = r.nextInt(12)+1;\n     points[4].y = i ;\n\n     // left below 0\n     points[5] = new PointF();\n     i = -(r.nextInt(14)+11);\n     points[5].x =  i;\n     i = -(r.nextInt(12)+1);\n\n     points[5].y = i;\n```", "```java\n  // Now use these points to draw our asteroid\n  float[] asteroidVertices = new float[]{\n     // First point to second point\n     points[0].x, points[0].y, 0,\n     points[1].x, points[1].y, 0,\n\n     // 2nd to 3rd\n     points[1].x, points[1].y, 0,\n     points[2].x, points[2].y, 0,\n\n     // 3 to 4\n     points[2].x, points[2].y, 0,\n     points[3].x, points[3].y, 0,\n\n     // 4 to 5\n     points[3].x, points[3].y, 0,\n     points[4].x, points[4].y, 0,\n\n     // 5 to 6\n     points[4].x, points[4].y, 0,\n     points[5].x, points[5].y, 0,\n\n     // 6 back to 1\n     points[5].x, points[5].y, 0,\n     points[0].x, points[0].y, 0,\n};\n\nsetVertices(asteroidVertices);\n\n}// End method\n\n}// End class\n```", "```java\nAsteroid [] asteroids;\nint numAsteroids;\nint numAsteroidsRemaining;\nint baseNumAsteroids = 10;\nint levelNumber = 1;\n```", "```java\n// For all our asteroids\nasteroids = new Asteroid[500];\n```", "```java\n// Determine the number of asteroids\ngm.numAsteroids = gm.baseNumAsteroids * gm.levelNumber;\n// Set how many asteroids need to be destroyed by player\ngm.numAsteroidsRemaining = gm.numAsteroids;\n// Spawn the asteroids\n\nfor (int i = 0; i < gm.numAsteroids * gm.levelNumber; i++) {\n     // Create a new asteroid\n     // Pass in level number so they can be made\n     // appropriately dangerous.\n     gm.asteroids[i] = new Asteroid\n      (gm.levelNumber, gm.mapWidth, gm.mapHeight);\n\n}\n```", "```java\n// Update all the asteroids\nfor (int i = 0; i < gm.numAsteroids; i++) {\n  if (gm.asteroids[i].isActive()) {\n    gm.asteroids[i].update(fps);\n  }\n}\n```", "```java\n// The bullets\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i].draw(viewportMatrix);\n}\n\nfor (int i = 0; i < gm.numAsteroids; i++) {\n if (gm.asteroids[i].isActive()) {\n gm.asteroids[i].draw(viewportMatrix);\n }\n\n}\n\n```", "```java\nimport android.graphics.PointF;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport static android.opengl.GLES20.GL_FLOAT;\nimport static android.opengl.GLES20.GL_LINES;\nimport static android.opengl.GLES20.glDrawArrays;\nimport static android.opengl.GLES20.glEnableVertexAttribArray;\nimport static android.opengl.GLES20.glGetAttribLocation;\nimport static android.opengl.GLES20.glGetUniformLocation;\nimport static android.opengl.GLES20.glUniform4f;\nimport static android.opengl.GLES20.glUniformMatrix4fv;\nimport static android.opengl.GLES20.glUseProgram;\nimport static android.opengl.Matrix.orthoM;\nimport static android.opengl.GLES20.glVertexAttribPointer;\nimport static com.gamecodeschool.c10asteroids.GLManager.A_POSITION;\nimport static com.gamecodeschool.c10asteroids.GLManager.COMPONENTS_PER_VERTEX;\nimport static com.gamecodeschool.c10asteroids.GLManager.FLOAT_SIZE;\nimport static com.gamecodeschool.c10asteroids.GLManager.STRIDE;\nimport static com.gamecodeschool.c10asteroids.GLManager.U_COLOR;\nimport static com.gamecodeschool.c10asteroids.GLManager.U_MATRIX;\n```", "```java\npublic class GameButton {\n\n    // For button coordinate\n    // into a GL space coordinate (-1,-1 to 1,1)\n    // for drawing on the screen\n    private final float[] viewportMatrix = new float[16];\n\n    // A handle to the GL glProgram -\n    // the compiled and linked shaders\n    private static int glProgram;\n\n    // How many vertices does it take to make\n    // our button\n    private int numVertices;\n\n    // This will hold our vertex data that is\n    // passed into openGL glProgram\n    private FloatBuffer vertices;\n```", "```java\npublic GameButton(int top, int left, \n    int bottom, int right, GameManager gm){\n\n    //The HUD needs its own viewport\n    // notice we set the screen height in pixels as the\n    // starting y coordinates because\n    // OpenGL is upside down world :-)\n    orthoM(viewportMatrix, 0, 0, \n        gm.screenWidth, gm.screenHeight, 0, 0, 1f);\n\n        // Shrink the button visuals to make\n        // them less obtrusive while leaving\n        // the screen area they represent the same.\n        int width = (right - left) / 2;\n        int height = (top - bottom) / 2;\n        left = left + width / 2;\n        right = right - width / 2;\n        top = top - height / 2;\n        bottom = bottom + height / 2;\n\n        PointF p1 = new PointF();\n        p1.x = left;\n        p1.y = top;\n\n        PointF p2 = new PointF();\n        p2.x = right;\n        p2.y = top;\n\n        PointF p3 = new PointF();\n        p3.x = right;\n        p3.y = bottom;\n\n        PointF p4 = new PointF();\n        p4.x = left;\n        p4.y = bottom;\n\n        // Add the four points to an array of vertices\n        // This time, because we don't need to animate the border\n        // we can just declare the world space coordinates, the\n        // same as above.\n        float[] modelVertices = new float[]{\n                // A line from point 1 to point 2\n                p1.x, p1.y, 0,\n                p2.x, p2.y, 0,\n                // Point 2 to point 3\n                p2.x, p2.y, 0,\n                p3.x, p3.y, 0,\n                // Point 3 to point 4\n                p3.x, p3.y, 0,\n                p4.x, p4.y, 0,\n                // Point 4 to point 1\n                p4.x, p4.y, 0,\n                p1.x, p1.y, 0\n        };\n```", "```java\n       // Store how many vertices and \n       // elements there is for future use\n       final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n       int numElements = modelVertices.length;\n       numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n       // Initialize the vertices ByteBuffer object based on the\n       // number of vertices in the button and the number of\n       // bytes there are in the float type\n       vertices = ByteBuffer.allocateDirect(\n                numElements\n                * FLOAT_SIZE)\n                .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n       // Add the button into the ByteBuffer object\n       vertices.put(modelVertices);\n\n       glProgram = GLManager.getGLProgram();\n\n}\n```", "```java\npublic void draw(){\n\n    // And tell OpenGl to use the glProgram\n    glUseProgram(glProgram);\n\n    // Now we have a glProgram we need the locations\n    // of our three GLSL variables\n    int uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);\n\n    int aPositionLocation = \n        glGetAttribLocation(glProgram, A_POSITION);\n\n    int uColorLocation = glGetUniformLocation(glProgram, U_COLOR);\n\n    vertices.position(0);\n\n    glVertexAttribPointer(\n        aPositionLocation,\n        COMPONENTS_PER_VERTEX,\n        GL_FLOAT,\n        false,\n        STRIDE,\n        vertices);\n\n    glEnableVertexAttribArray(aPositionLocation);\n\n    // give the new matrix to OpenGL\n    glUniformMatrix4fv(uMatrixLocation, 1, false, viewportMatrix, 0);\n\n    // Assign a different color to the fragment shader\n    glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);\n\n    // Draw the lines\n    // start at the first element of the\n    // vertices array and read in all vertices\n    glDrawArrays(GL_LINES, 0, numVertices);\n\n}\n}// End class\n```", "```java\npublic class TallyIcon {\n\n    // For button coordinate\n    // into a GL space coordinate (-1,-1 to 1,1)\n    // for drawing on the screen\n    private final float[] viewportMatrix = new float[16];\n\n    // A handle to the GL glProgram -\n    // the compiled and linked shaders\n    private static int glProgram;\n\n    // How many vertices does it take to make\n    // our button\n    private int numVertices;\n\n    // This will hold our vertex data that is\n    // passed into openGL glProgram\n    //private final FloatBuffer vertices;\n    private FloatBuffer vertices;\n\n    public TallyIcon(GameManager gm, int nthIcon){\n\n        // The HUD needs its own viewport\n        // notice we set the screen height in pixels as the\n        // starting y coordinates because\n        // OpenGL is upside down world :-)\n        orthoM(viewportMatrix, 0, 0,\n          gm.screenWidth, gm.screenHeight, 0, 0f, 1f);\n\n        float padding = gm.screenWidth / 160;\n        float iconHeight = gm.screenHeight / 15;\n        float iconWidth = 1; // square icons\n        float startX = 10 + (padding + iconWidth)* nthIcon;\n        float startY = iconHeight * 2 + padding;\n\n        PointF p1 = new PointF();\n        p1.x = startX;\n        p1.y = startY;\n\n        PointF p2 = new PointF();\n        p2.x = startX;\n        p2.y = startY - iconHeight;\n\n        // Add the four points to an array of vertices\n        // This time, because we don't need to animate the border\n        // we can just declare the world space coordinates, the\n        // same as above.\n        float[] modelVertices = new float[]{\n                // A line from point 1 to point 2\n                p1.x, p1.y, 0,\n                p2.x, p2.y, 0,\n\n        };\n\n        // Store how many vertices and \n        //elements there is for future use\n        final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n        int numElements = modelVertices.length;\n        numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n        // Initialize the vertices ByteBuffer object based on the\n        // number of vertices in the button and the number of\n        // bytes there are in the float type\n        vertices = ByteBuffer.allocateDirect(\n                numElements\n                * FLOAT_SIZE)\n                .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n        // Add the button into the ByteBuffer object\n        vertices.put(modelVertices);\n\n        glProgram = GLManager.getGLProgram();\n    }\n```", "```java\n    public void draw(){\n\n        // And tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Now we have a glProgram we need the locations\n        // of our three GLSL variables\n        int uMatrixLocation = \n        glGetUniformLocation(glProgram, U_MATRIX);\n\n        int aPositionLocation = \n        glGetAttribLocation(glProgram, A_POSITION);\n\n        int uColorLocation = \n        glGetUniformLocation(glProgram, U_COLOR);\n\n        vertices.position(0);\n\n        glVertexAttribPointer(\n                aPositionLocation,\n                COMPONENTS_PER_VERTEX,\n                GL_FLOAT,\n                false,\n                STRIDE,\n                vertices);\n\n        glEnableVertexAttribArray(aPositionLocation);\n\n        // Just give the passed in matrix to OpenGL\n        glUniformMatrix4fv(uMatrixLocation, 1, \n          false, viewportMatrix, 0);\n\n        // Assign a color to the fragment shader\n        glUniform4f(uColorLocation, 1.0f, 1.0f, 0.0f, 1.0f);\n\n        // Draw the lines\n        // start at the first element of the vertices array and read in all vertices\n        glDrawArrays(GL_LINES, 0, numVertices);\n    }\n```", "```java\npublic class LifeIcon {\n\n     // Remember the static import for GLManager\n\n     // For button coordinate\n     // into a GL space coordinate (-1,-1 to 1,1)\n     // for drawing on the screen\n     private final float[] viewportMatrix = new float[16];\n\n     // A handle to the GL glProgram -\n     // the compiled and linked shaders\n     private static int glProgram;\n\n     // Each of the above constants also has a matching int\n     // which will represent its location in the open GL glProgram\n     // In GameButton they are declared as local variables\n\n     // How many vertices does it take to make\n     // our button\n     private int numVertices;\n\n     // This will hold our vertex data that is\n     // passed into openGL glProgram\n     //private final FloatBuffer vertices;\n     private FloatBuffer vertices;\n\n     public LifeIcon(GameManager gm, int nthIcon){\n\n     // The HUD needs its own viewport\n     // notice we set the screen height in pixels as the\n     // starting y coordinates because\n     // OpenGL is upside down world :-)\n     orthoM(viewportMatrix, 0, 0,\n       gm.screenWidth, gm.screenHeight, 0, 0f, 1f);\n\n     float padding = gm.screenWidth / 160;\n     float iconHeight = gm.screenHeight / 15;\n     float iconWidth = gm.screenWidth / 30;\n     float startX = 10 + (padding + iconWidth)* nthIcon;\n     float startY = iconHeight;\n\n     PointF p1 = new PointF();\n     p1.x = startX;\n     p1.y = startY;\n\n     PointF p2 = new PointF();\n     p2.x = startX + iconWidth;\n     p2.y = startY;\n\n     PointF p3 = new PointF();\n     p3.x = startX + iconWidth/2;\n     p3.y = startY - iconHeight;\n\n     // Add the four points to an array of vertices\n     // This time, because we don't need to animate the border\n     // we can just declare the world space coordinates, the\n     // same as above.\n     float[] modelVertices = new float[]{\n               // A line from point 1 to point 2\n               p1.x, p1.y, 0,\n               p2.x, p2.y, 0,\n               // Point 2 to point 3\n               p2.x, p2.y, 0,\n               p3.x, p3.y, 0,\n               // Point 3 to point 1\n               p3.x, p3.y, 0,\n               p1.x, p1.y, 0,\n\n  };\n\n     // Store how many vertices and elements there is for future \n     // use\n     final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n     int numElements = modelVertices.length;\n     numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n     // Initialize the vertices ByteBuffer object based on the\n     // number of vertices in the button and the number of\n     // bytes there are in the float type\n     vertices = ByteBuffer.allocateDirect(\n              numElements\n              * FLOAT_SIZE)\n              .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n     // Add the button into the ByteBuffer object\n     vertices.put(modelVertices);\n\n       glProgram = GLManager.getGLProgram();\n     }\n```", "```java\n    public void draw(){\n\n            // And tell OpenGl to use the glProgram\n            glUseProgram(glProgram);\n\n            // Now we have a glProgram we need the locations\n            // of our three GLSL variables\n            int uMatrixLocation = glGetUniformLocation \n              (glProgram, U_MATRIX);\n            int aPositionLocation = glGetAttribLocation \n              (glProgram, A_POSITION);\n            int uColorLocation = glGetUniformLocation \n               (glProgram, U_COLOR);\n\n            vertices.position(0);\n\n            glVertexAttribPointer(\n                    aPositionLocation,\n                    COMPONENTS_PER_VERTEX,\n                    GL_FLOAT,\n                    false,\n                    STRIDE,\n                    vertices);\n\n            glEnableVertexAttribArray(aPositionLocation);\n\n            // Just give the passed in matrix to OpenGL\n            glUniformMatrix4fv(uMatrixLocation, 1, \n              false, viewportMatrix, 0);\n            // Assign a color to the fragment shader\n            glUniform4f(uColorLocation, 1.0f, \n              1.0f, 0.0f, 1.0f);\n            // Draw the lines\n            // start at the first element of \n            // the vertices array and read in all vertices\n            glDrawArrays(GL_LINES, 0, numVertices);\n        }\n\n}\n```", "```java\nTallyIcon[] tallyIcons;\nint numLives = 3;\nLifeIcon[] lifeIcons;\n```", "```java\nlifeIcons = new LifeIcon[50];\ntallyIcons = new TallyIcon[500];\n```", "```java\n// This will hold our game buttons\nprivate final GameButton[] gameButtons = new GameButton[5];\n```", "```java\n// Now for the HUD objects\n// First the life icons\nfor(int i = 0; i < gm.numLives; i++) {\n    // Notice we send in which icon this represents\n    // from left to right so padding and positioning is correct.\n    gm.lifeIcons[i] = new LifeIcon(gm, i);\n}\n\n// Now the tally icons (1 at the start)\nfor(int i = 0; i < gm.numAsteroidsRemaining; i++) {\n    // Notice we send in which icon this represents\n    // from left to right so padding and positioning is correct.\n    gm.tallyIcons[i] = new TallyIcon(gm, i);\n}\n\n// Now the buttons\nArrayList<Rect> buttonsToDraw = ic.getButtons();\nint i = 0;\nfor (Rect rect : buttonsToDraw) {\n    gameButtons[i] = new GameButton(rect.top, rect.left, \n        rect.bottom, rect.right, gm);\n\n    i++;\n\n}\n```", "```java\n// the buttons\nfor (int i = 0; i < gameButtons.length; i++) {\n  gameButtons[i].draw();\n}\n\n// Draw the life icons\nfor(int i = 0; i < gm.numLives; i++) {\n     // Notice we send in which icon this represents\n     // from left to right so padding and positioning is correct.\n     gm.lifeIcons[i].draw();\n}\n\n// Draw the level icons\nfor(int i = 0; i < gm.numAsteroidsRemaining; i++) {\n  // Notice we send in which icon this represents\n  // from left to right so padding and positioning is correct.\n  gm.tallyIcons[i].draw();\n}\n```"]