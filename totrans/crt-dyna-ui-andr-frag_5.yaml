- en: Chapter 5. Creating Rich Navigation with Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrates the role of fragments in creating a rich user interface
    navigation experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Swipe navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of the Android action bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The close relationship between the action bar and fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating menus with fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to implement solutions that utilize
    fragments to provide rich user navigation, including swipe navigation, tab navigation,
    and drop-down list navigation.
  prefs: []
  type: TYPE_NORMAL
- en: A brave new world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, fragments provide us with the ability to closely control and
    manage our application user interface. Through the use of the `FragmentTransaction`
    class we can provide the user with the experience of moving from one screen to
    another by simply switching between different fragments. This takes us to an entirely
    new way of thinking: a brave new world of application design.'
  prefs: []
  type: TYPE_NORMAL
- en: When we create our user interface in this way, the activity acts as a sort of
    screen manager with the fragments implementing the screens themselves. This concept
    of managing the individual application screens as fragments within an activity
    is so powerful that it has become the foundation of some of the most compelling
    navigation features of the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Android provides classes that cooperate with this design pattern to enable us
    to create rich navigation and screen management experiences, in a simple way.
    These classes provide a variety of features, including transition effects along
    with some familiar user interface metaphors.
  prefs: []
  type: TYPE_NORMAL
- en: Making navigation fun with swipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many applications involve several screens of data that a user might want to
    browse or flip through to view each screen. As an example, think of an application
    where we list a catalogue of books with each book in the catalogue appearing on
    a single screen. A book''s screen contains an image, title, and description like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making navigation fun with swipe](img/3095_05_01_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To view each book''s information, the user needs to move to each screen. We
    could put a next button and a previous button on the screen, but a more natural
    action is for the user to use their thumb or finger to swipe the screen from one
    edge of the display to the other and have the screen with the next book''s information
    slide into place as represented in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making navigation fun with swipe](img/3095_05_02_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This creates a very natural navigation experience, and honestly, is a more fun
    way to navigate through an application than using buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing swipe navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing swipe navigation is pretty simple, and fragments are at the core.
    Each of the screens is implemented as a fragment derived class. Each screen can
    be a completely different fragment derived class or the screens can be instances
    of the same fragment derived class with different data. To create a book browser
    app such as the one shown in the previous screenshot, we can use a simple fragment
    derived class that sets the book image, title, and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one thing about the fragment derived class that is a bit unusual.
    At the time of this writing, the classes involved in managing swipe navigation
    are relatively new and are only available in the `android.support.v4.app` package.
    As a result, the fragment derived class created by us must inherit from the support
    package version of the `Fragment` class, `android.support.v4.app.Fragment`, even
    when our app is targeting the Android versions that natively support fragments.
    The fragment class definition will appear similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Managing the swipe fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Presenting the individual fragments that represent the application screens
    requires an adapter to manage the creation and delivery of each fragment. The
    Android support library includes two classes that provide this capability: `FragmentPagerAdapter`
    and `FragmentStatePagerAdapter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `FragmentPagerAdapter` class is useful for scenarios where there are a small
    number of fragments. When a given fragment instance is created, it is directly
    stored in the `FragmentManager` class and that same instance is re-used each time
    that fragment's page is displayed. The fragment's `onDestroyView` method is called
    when the user switches to a different fragment, but not the `onDestroy` method.
    It's important that we only use the `FragmentPagerAdapter` class in cases where
    there's a relatively small number of fragments, because we should assume that
    once a fragment is created, it will exist as long as the `FragmentPagerAdapter`
    class exists.
  prefs: []
  type: TYPE_NORMAL
- en: The `FragmentStatePagerAdapter` class is useful for scenarios where there is
    a large number of fragments, because fragments may be destroyed when they are
    no longer visible. Fragments managed by `FragmentStatePagerAdapter` will always
    have their `onDestroyView` method called, and may have their `onDestroy` method
    called as well. The call to the `onDestroy` method does not necessarily occur
    as soon as the user swipes to another fragment it may occur much later depending
    on the device's available resources. The `FragmentStatePagerAdapter` class gives
    the fragment an opportunity to save its state through the platform's call to the
    `onSaveInstanceState` method.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to discard and recreate the contained fragments also makes the `FragmentStatePagerAdapter`
    class useful for scenarios where the list of fragments being displayed may change.
    The details of implementing an updatable `FragmentStatePagerAdapter` instance
    are beyond the scope of this book, but an example is available at [http://bit.ly/UpdateFragmentStatePagerAdapter](http://bit.ly/UpdateFragmentStatePagerAdapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a book browser app as seen in the previous screenshot, we''ll extend
    the `FragmentPagerAdapter` class because we''ll be displaying just a few books.
    We''ll name our class as `BookPagerAdapter`, the declaration of which is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement our `BookPagerAdapter` class, we just need to override a few methods.
    The primary method, `getItem`, is responsible for returning each fragment instance.
    Our `getItem` method appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the app displays a particular book's page for the first time, the `getItem`
    method is called with the index of the page as a parameter named `idx` in our
    code. Before creating the fragment, we retrieve the book title, description, and
    image resource ID from arrays containing those values and store them in a `Bundle`
    instance. We then create an instance of our `BookFragment` class and associate
    the argument `Bundle` instance with it. Finally, we return the `BookFragment`
    reference. When our `BookFragment` instance is displayed, it will access the values
    in the argument `Bundle` instance and display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now must override two additional methods: `getPageTitle` and `getCount`.
    The `getPageTitle` method returns the string that is visible in the thin bar above
    each fragment. Like the `getItem` method, the `getPageTitle` method receives the
    index of the page being displayed. The `getPageTitle` method simply returns a
    value from an array containing short versions of the page title, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getCount` method is responsible for returning the number of screens we''ll
    be displaying. We can simply return the length of the array we''re using in the
    `getPageTitle` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Implementing our `BookPagerAdapter` class takes care of the code that manages
    our fragments. Now, we just need to put the appropriate layout within our activity
    and connect it with the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the swipe UI into place
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The swipe user interface behavior and effects come from two Android classes:
    `ViewPager` and `PagerTitleStrip`. The `ViewPager` class is the primary class.
    It manages the user interaction, provides the swipe animation effects, and cooperates
    with the adapter class that provides each screen''s fragment. The `PagerTitleStrip`
    class handles the displaying of the thin title bar above each fragment. The string
    values returned from our `BookPagerAdapter` class'' `getPageTitle` method are
    displayed within the `PagerTitleStrip` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a layout resource file for our application''s activity called
    `activity_main.xml` containing the `ViewPager` and `PagerTitleStrip` classes,
    as shown in the following XML layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our layout resource file contains `ViewPager` as the root node, and is set to
    occupy the entire activity. The `ViewPager` class has an ID value of `pager`.
    The `PagerTitleStrip` class is set to fill the full width of `ViewPager`, and
    to be positioned at the top. Alternatively we could set the `layout_gravity` attribute
    to a value of `bottom` to position `PagerTitleStrip` at the bottom of the `ViewPager`
    class' display area. Although, other values for the `layout_gravity` attribute
    are technically valid, they tend to be problematic. As a general rule, we want
    to limit our choices for the `layout_gravity` attribute to be either `top` or
    `bottom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our complete layout and have already created the adapter that will
    manage the fragments within our application. We''re now ready to declare our activity
    class, which we''ll name `MainActivity`. The class declaration appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're inheriting from the support library class `FragmentActvity`
    rather than the regular `Activity` class. This is due to the same issue we discussed
    when we declared our `BookFragment` class. The classes that provide the swipe
    behavior are in the support library; therefore, they expect all fragment-related
    classes to be from that library. Our activity class includes member variables
    for our `BookPagerAdapter` and `ViewPager` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is connect our `BookPagerAdapter` class to the
    `ViewPager` class. We''ll do that in our `onCreate` method, which appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our job here is pretty easy. We call the `setContentView` method
    with the `R.layout.activity_main` resource we just created. When the `setContentView`
    method returns, we create our `BookPagerAdapter` instance passing the activity's
    `FragmentManager` instance and the activity's `this` pointer so our `BookPagerAdapter`
    can use it as the context. With our `BookPagerAdapter` created, we use the activity
    class' `findViewById` method to get a reference to the `ViewPager` class that
    we created with the layout resource file. Finally, we call the `ViewPager` instance's
    `setAdapter` method to connect the `BookPagerAdapter` instance to our `ViewPager`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: We now have everything in place. Our book browser is all ready for the user
    to browse through our list of books using swipe navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio and swipe navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we''re working with Android Studio, getting started at building an app with
    swipe navigation is easy. In the **New Project** wizard, on the dialog where we
    set the activity and layout name, select **Scrollable Tabs + Swipe** for **Navigation
    Type** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Studio and swipe navigation](img/3095_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting project will include a layout resource file containing `ViewPager`
    and `PagerTitleStrip`, along with stubbed-out code for the `FragmentPagerAdapter`,
    `Fragment`, and `Activity` derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: Improving navigation with the ActionBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Beginning at API Level 11 (Android 3.0), Android moved away from using traditional
    menus to instead use the ActionBar. The ActionBar provides action items that are
    a combination of button-based actions that appear directly on the ActionBar and
    menu-based actions that appear in a drop-down list when the user taps on the Action
    overflow button. The following screenshot shows the available ActionBar actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Improving navigation with the ActionBar](img/3095_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What many developers don''t realize is that the button-based and menu-based
    actions are just a small subset of what the ActionBar actually does. The ActionBar
    now serves as a central point for many navigation-related behaviors. Two of these
    behaviors are tied directly to fragments: tab navigation and drop-down navigation.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To incorporate the ActionBar in applications targeting versions of Android with
    an API Level below 11, use the `ActionBarCompat` class available in the Android
    Support Library. For more information on the `ActionBarCompat` class visit [http://bit.ly/ActionBarCompat](http://bit.ly/ActionBarCompat).
  prefs: []
  type: TYPE_NORMAL
- en: Navigating randomly with tabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tabs are an effective navigation model. They're well understood by users, and
    make moving between screens within an app easy. Unlike swipe navigation that requires
    the user to move through screens in order, tab navigation allows the user to move
    from one screen to another in any order they like. Android has supported tab navigation
    since the original release of the platform. Historically, the challenge of implementing
    tab navigation was that it was unrelated to other navigation models and required
    using a special activity class and other tab-specific classes. With the ActionBar,
    this is all changed. Now, tab navigation is just another use of the common fragment
    programming model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ActionBar allows us to associate an instance of a fragment derived class
    with each tab. The following screenshot shows the top portion of the screen of
    two different devices, with the ActionBar displaying tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigating randomly with tabs](img/3095_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the ActionBar automatically adapts the way the tabs are displayed
    in response to the available screen space. On the narrower device, the ActionBar
    places the tabs under the main portion of the ActionBar, whereas on the wider
    device with more horizontal screen space, the tabs appear directly on the main
    portion of the ActionBar.
  prefs: []
  type: TYPE_NORMAL
- en: Managing tab selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ActionBar manages all the heavy lifting when it comes to implementing tab
    navigation. It draws the tabs, indicates which tab is currently selected, and
    even takes care of beginning and committing a fragment transaction. All we have
    to do is handle which fragment is visible, based on the tab currently selected.
    We do this by providing an implementation of the `ActionBar.TabListener` interface
    for each tab. The following code shows the declaration of a class implementing
    the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `TabListener` implementation has two member variables. The boolean member
    variable, `mFirstSelect`, is used to control the special handling that's necessary
    the first time the fragment managed by our `SimpleTabListener` class is selected.
    The other member variable, `mFragment`, holds a reference to the fragment that
    is managed by the `TabListener` instance, which is set in our `SimpleTabListener`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `TabListener` interface method we''ll implement is the `onTabSelected`
    method. As the method name indicates, `onTabSelected` is called each time the
    tab associated with this `TabListener` instance becomes the selected tab. The
    `onTabSelected` method is implemented as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Two parameters are passed to the `onTabSelected` method. The first parameter
    is a reference to the tab instance that is associated with our `TabListener` implementation.
    The second parameter is the `FragmentTransaction` instance that is managed by
    the ActionBar. The ActionBar starts this transaction, and will commit the transaction
    after `onTabSelected` returns.
  prefs: []
  type: TYPE_NORMAL
- en: The first time the `onTabSelected` method is called, we use the passed `FragmentTransaction`
    instance to add our fragment to the display using the `add` method. As we discussed
    in the previous chapter, the first parameter to the `add` method is the ID of
    the view group under which we want the fragment to be placed. Just as when we're
    managing `FragmentsTransaction` ourselves, this can be any valid view group within
    the activity layout. In the previous code, we're using a special ID value that
    is predefined by Android, `android.R.id.content`. The `android.R.id.content` ID
    value indicates that we want the fragment to occupy the entire content area of
    the activity rather than be placed under a specific view group within the activity.
  prefs: []
  type: TYPE_NORMAL
- en: We only use the `add` method the first time the tab is selected; every time
    thereafter, we use the `FragmentTransaction` class' `attach` method. We'll talk
    more about that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `TabListener` interface method we''ll implement is the `onTabUnselected`
    method, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `onTabUnselected` method receives the same parameters as the `onTabSelected`
    method. Our implementation of this method is simple, having only one line in which
    we call the `FragmentTransaction` class' `detach` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `detach` method call in the `onTabUnselected` method works together with
    the `attach` method call in the `onTabSelected` method. Once the fragment is initially
    added to the activity, as we do in the `onTabSelected` method the first time the
    fragment is shown, we can then call the `detach` method to tear down the fragment's
    view hierarchy, but leave the fragment associated with the activity. When we call
    the `attach` method within the `onTabSelected` method, the next time the user
    selects the tab for the fragment, the fragment's view hierarchy is rebuilt at
    the same place within the activity where the fragment was originally added.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of calling the `detach` and `attach` methods allows us to manage
    the fragments more efficiently. When we call the `detach` method, the fragment's
    `onDestroyView` method is called, but not the `onDestroy` method. When we later
    call the `attach` method, the fragment's `onCreateView` method is called, but
    not the `onCreate` method, because the fragment does not need to be fully recreated
    just its view hierarchy needs to be recreated.
  prefs: []
  type: TYPE_NORMAL
- en: There is a bit of potential confusion related to method names that we need to
    be aware of. When a fragment instance is passed to the `FragmentTransaction` class'
    `detach` method, the `Fragment` class' `onDetach` method does not get called.
    This is because the `detach` method tears down the fragment's view hierarchy but
    leaves the fragment associated with the activity; the fragment remains attached.
    Similarly, when a fragment instance is passed to the `FragmentTransaction` class'
    `attach` method, the `Fragment` class' `onAttach` method does not get called because
    the fragment is already attached to the activity. This is certainly a little confusing,
    but it ultimately comes down to a bad choice of method names on the part of the
    API designers rather than being a technical inconsistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method on the `TabListener` interface, `onTabReselected`, is called
    in scenarios where the user taps the tab that is already selected; in other words,
    the user reselects the same tab. In most cases, this method can be left empty,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Connecting the fragments to the tabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With our `TabListener` implementation in place, we can now connect the fragments
    to the tabs. We''ll do this in the activity''s `onCreate` method, which is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our `onCreate` implementation, we start by getting a reference to the ActionBar,
    and putting the ActionBar into tab navigation mode. This step is essential; without
    it, the tabs we add will never be visible.
  prefs: []
  type: TYPE_NORMAL
- en: For the first tab, we create the fragment that will serve as the body of the
    tab. This can be virtually any fragment derived class. We then associate our `TabListener`
    implementation with the fragment. With the fragment and `TabListener` implementation
    in place, we create a new `ActionBar.Tab` instance with the call to the `newTab`
    method, we then set the text that will display within the tab, and associate our
    `TabListener` instance with the tab. Finally, we add the `ActionBar.Tab` instance
    to the ActionBar with the `addTab` method. We then repeat those steps for the
    second tab.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we now have tab navigation implemented in our application. Using
    this technique, we're able to leverage all the capabilities of fragments and implement
    tab-based navigation in a way that is consistent with other ways we use fragments.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that may appear unusual about our `onCreate` method implementation
    is the absence of a call to the `setContentView` method. In this case, we don't
    need to associate a layout resource with the activity, because we're using the
    special-purpose `android.R.id.content` resource ID when we call the `add` method
    in our `onTabSelected` implementation. As we mentioned earlier, the resource ID
    `android.R.id.content` indicates that the fragment occupies the entire content
    area. If we wanted the tab to control the display of a fragment within some view
    group, we would call `setContentView` with a resource containing the desired layout.
    We would then use the ID of the view group within that layout in our call to the
    `add` method.
  prefs: []
  type: TYPE_NORMAL
- en: Providing direct access with drop-down list navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tab navigation works well when an app has just a few predictable screens, but
    quickly becomes cluttered if there are a large number of screens. For those scenarios
    where an app has a large number of screens or possibly the number of screens might
    even change over time, drop-down list navigation provides a much better solution
    than tabs. Drop-down list navigation places a drop-down list on the ActionBar
    containing the list of available screen names. When the user chooses a screen
    name from the list, the app immediately displays the corresponding screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the most familiar use of this navigation model on Android is the Android
    e-mail app, which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing direct access with drop-down list navigation](img/3095_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the Android e-mail app, the list of different available e-mail folder screens
    appears in the drop-down list. Tapping the ActionBar displays the list and then
    selecting the screen name from the list immediately displays the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating drop-down list navigation in our apps is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Managing fragment selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike tab navigation, where the ActionBar takes a very active role in managing
    the transition from one fragment to another, in drop-down list navigation the
    ActionBar takes a much more hands-off approach. Basically, the ActionBar simply
    notifies the app that the selection has changed, and leaves the details of switching
    fragments up to the app. To handle the notification we need to provide an implementation
    of the `ActionBar.OnNavigationListener` interface. The implementation declaration
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `ActionBar.OnNavigationListener` implementation has a single member variable,
    `mFragmentManager`, to hold a reference to the activity's `FragmentManager` instance.
    The `FragmentManager` reference is passed to our class in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike in tab navigation where each tab instance is managed by a separate `TabListener`
    instance, in drop-down list navigation a single `OnNavigationListener` implementation
    handles all the selections. The `OnNavigationListener` interface''s only method,
    `onNavigationItemSelected`, is called each time the selection changes and is responsible
    for taking care of displaying the appropriate fragment, as shown in the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We receive the zero-based index of the selection as the first parameter, `itemPosition`.
    We'll be populating the list of screen names from a simple `String` array so the
    second parameter, `itemId`, does not have value to us. If we were to use a more
    structured data source, the `itemId` parameter would contain the ID of the selection.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `switch` statement, we create an instance of the appropriate fragment
    derived class. Once we have the fragment instance, we replace the currently visible
    fragment with the one we just created. We again use the layout resource ID, `android.R.id.content`,
    indicating that the fragment occupies the entire content area of the activity.
    Just as with tab navigation, we could instead use the ID value of a view group
    within the activity's layout, if we prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're explicitly creating and committing the `FragmentTransaction`
    instance in our code. This is another important difference from how tab navigation
    is managed; we're responsible for all the details. The test that the local variable,
    `fragment`, is not null is just a sanity check. As long as we don't display more
    than three values for the user to select from, the `fragment` variable will never
    be null.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a method return value of `true` simply indicates that we have handled
    the event.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the navigation choices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now need to provide the ActionBar with the information necessary to display
    the list of navigation choices. We do that in the activity''s `onCreate` method,
    which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first step in setting up drop-down list navigation is to put the ActionBar
    into list navigation mode with the call to the `setNavigationMode` method. The
    drop-down list containing the screen choices appears directly on the ActionBar,
    which can be problematic if the ActionBar attempts to show both the drop-down
    list and the activity title text. To make room for the list, we call the `setDisplayShowTitleEnabled`
    method with a value of `false` so that the title doesn't display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We retrieve the list of display values from the array resource, which is a
    regular `String` array. We wrap the `String` array in an instance of the `ArrayAdapter`
    class just as we would if we were planning to associate the `String` array with
    a standard `ListView` instance appearing within a layout definition for an activity.
    The `String` array resource definition appears as shown in the following XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We then create an instance of `SimpleNavigationListener`, which we had defined
    earlier. Finally, we set the list of displayed screen names and the screen selection
    handler by calling the `setListNavigationCallbacks` method to associate the `ArrayAdapter`
    and `SimpleNavigationListener` implementations with the `ActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: With that we have drop-down navigation fully implemented. When we run the application,
    the list of screen selections will appear as shown in the following screenshot.
    The ActionBar initially appears as shown on the left-hand side in the following
    screenshot, with the currently selected screen's name displayed. When the user
    taps on the currently selected screen name, the list expands to display the list
    of available screen names as shown on the right-hand side of the following screenshot.
    With the list expanded, the user can easily jump directly to any of the available
    screens by tapping on the desired screen's name within the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing the navigation choices](img/3095_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Studio and drop-down list navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we're working with Android Studio, we can create a project that supports
    drop-down list navigation directly from the **New Project** wizard by selecting
    **Dropdown** as the **Navigation Type**, similar to the way we created a project
    with swipe navigation. The resulting project will contain a stubbed-out `ActionBar.OnNavigationListener`
    implementation along with the code within the activity to put the ActionBar into
    drop-down list navigation mode, and associate the `ActionBar.OnNavigationListener`
    implementation with the ActionBar.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fragments are the foundation of modern Android app development, allowing us
    to display multiple application screens within a single activity. Thanks to the
    flexibility provided by fragments, we can now incorporate rich navigation into
    our apps with relative ease. Using these rich navigation capabilities, we're able
    to create a more dynamic user interface experience that make our apps more compelling
    and that users find more fun to work with.
  prefs: []
  type: TYPE_NORMAL
