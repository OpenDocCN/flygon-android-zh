- en: Chapter 9. Porting Existing Libraries to Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 将现有库移植到Android
- en: '*There are two main reasons why one would be interested in the Android NDK:
    first, for performance, and, second, for portability. In the previous chapters,
    we saw how to access the main native Android APIs from native code for efficiency
    purposes. In this chapter, we will bring the whole C/C++ ecosystem to Android,
    well, at least discovering the path, as decades of C/C++ development would be
    difficult to fit the limited memory of mobile devices anyway! Indeed, C and C++
    are still some of the most widely used programming languages nowadays.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 人们关注Android NDK主要有两个原因：首先是为了性能，其次是为了可移植性。在前面的章节中，我们看到了如何从本地代码访问主要的本地Android
    API以提高效率。在本章中，我们将把整个C/C++生态系统带到Android，至少探索这条路径，因为几十年的C/C++开发很难适应移动设备有限的内存！确实，C和C++仍然是现今最广泛使用的编程语言之一。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In previous NDK releases, portability was limited due to the partial support
    of C++, especially **Exceptions** and **Run-Time Type** Information (**RTTI**,
    a basic C++ reflection mechanism to get data types at runtime such as `instanceof`
    in Java). Any library requiring them could not be ported without modifying their
    code or installing a custom NDK (the **Crystax NDK**, rebuilt by the community
    from official sources, and available at [http://www.crystax.net/](http://www.crystax.net/)).
    Hopefully, many of these restrictions have been lifted since (except wide character
    support).*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在之前的NDK版本中，由于对C++的支持不完整，特别是**异常**和**运行时类型信息**（**RTTI**，一个基本的C++反射机制，用于在运行时获取数据类型，例如Java中的`instanceof`），可移植性受到限制。任何需要这些特性的库，如果不修改代码或安装自定义NDK（由社区从官方源代码重建的**Crystax
    NDK**，可在[http://www.crystax.net/](http://www.crystax.net/)获取），都无法移植。幸运的是，许多这些限制已经解除（除了宽字符支持）。
- en: Although not necessarily difficult, porting an existing library is not a trivial
    process. A few APIs might be missed (despite good POSIX support), some `#define`
    directives have to be tweaked, some dependencies have to be ported, as well as
    dependencies of dependencies. Some libraries will be easy to port, while some
    other will involve more effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不一定困难，但移植现有库并非易事。可能会缺少一些API（尽管POSIX支持良好），一些`#define`指令需要调整，一些依赖项以及依赖项的依赖项需要移植。一些库将容易移植，而另一些则需要更多努力。
- en: 'In this chapter, in order to port existing code to Android, we are going to
    learn how to do the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了将现有代码移植到Android，我们将学习如何进行以下代码操作：
- en: Activate the **Standard Template Library** (**STL**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活**标准模板库**（**STL**）
- en: Port the **Box2D** physics engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植**Box2D**物理引擎
- en: Prebuild and use the **Boost** framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预构建并使用**Boost**框架
- en: Discover more in-depth how to write NDK module **Makefiles**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解如何编写NDK模块**Makefiles**
- en: By the end of this chapter, you should understand the native building process
    and know how to use Makefiles appropriately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该了解本地构建过程，并知道如何适当使用Makefiles。
- en: Activating the Standard Template Library
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活标准模板库
- en: The Standard Template Library is a normalized library of containers, iterators,
    algorithms, and helper classes to ease most common programming operations, such
    as dynamic arrays, associative arrays, strings, sorting, and so on. This library
    gained recognition among developers over the years and is widely spread. Developing
    in C++ without the STL is like coding with one hand behind your back!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模板库是一个标准化的容器、迭代器、算法和辅助类的库，可以简化大多数常见的编程操作，如动态数组、关联数组、字符串、排序等。这个库在开发者中得到了多年的认可并被广泛传播。在C++中开发而不使用STL，就像一只手背在身后编程一样！
- en: In this first part, let's embed GNU STL in DroidBlaster to ease collection management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，让我们将GNU STL嵌入DroidBlaster，以便简化集合管理。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part16`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`DroidBlaster_Part16`。
- en: Time for action – activating GNU STL in DroidBlaster
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——在DroidBlaster中激活GNU STL
- en: 'Let''s activate and make use of the STL in DroidBlaster. Edit the `jni/Application.mk`
    file beside `jni/Android.mk` and write the following content. That''s it! Your
    application is now STL-enabled, thanks to this single line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在DroidBlaster中激活并使用STL。编辑`jni/Application.mk`文件，旁边是`jni/Android.mk`，并写入以下内容。就这样！你的应用程序现在启用了STL，多亏了这一行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*What just happened?*'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'In only a single line of code, we have activated GNU STL in the `Application.mk`
    file! This STL implementation, selected through the `APP_STL` variable, replaces
    the default NDK C/C++ runtime. The following three STL implementations are currently
    supported:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Application.mk` 文件中，我们只用一行代码就激活了 GNU STL！这个通过 `APP_STL` 变量选择的 STL 实现，替换了默认的
    NDK C/C++ 运行时。目前支持以下三种 STL 实现：
- en: '**GNU STL** (more commonly **libstdc++**), the official GCC STL: This is often
    the preferred choice when using the STL on an NDK project. Exceptions and RTTI
    are supported.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU STL**（更常见的名称是 **libstdc++**），官方 GCC STL：这通常是在 NDK 项目中使用 STL 的首选。支持异常和
    RTTI。'
- en: '**STLport** (a multiplatform STL): This implementation is not actively maintained
    and lacks some features. Choose it as a last resort. Exceptions and RTTI are supported.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STLport**（多平台 STL）：这个实现现在没有积极维护，并且缺少一些功能。在万不得已的情况下选择它。支持异常和 RTTI。'
- en: '**Libc++**: This is part of LLVM (the technology behind the Clang compiler)
    and aims to provide a functional C++ 11 runtime. Note that this library is now
    becoming the default STL on OS-X and may gain popularity in the future. Exceptions
    and RTTI are supported. Libc++ support is still incomplete and experimental. Libc++
    is often chosen in conjunction with the Clang compiler (read more about this in
    the *Mastering module Makefiles* section).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Libc++**：这是 LLVM 的一部分（Clang 编译器背后的技术），旨在提供一个功能性的 C++ 11 运行时。请注意，这个库现在正在成为
    OS-X 上的默认 STL，并且将来可能会变得更加流行。支持异常和 RTTI。Libc++ 的支持仍然是不完整的和实验性的。Libc++ 通常与 Clang
    编译器一起选择（在 *掌握模块 Makefiles* 部分了解更多信息）。'
- en: 'Android also provides two other C++ runtimes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓还提供了另外两个 C++ 运行时：
- en: '**System**: This is the default NDK runtime when no STL implementation is activated.
    Its code name is **Bionic** and it provides a minimalist set of headers (`cstdint`,
    `cstdio`, `cstring`, and so on). Bionic does not provide STL features, as well
    as exceptions and **run-time type information** (**RTTI**). For more details about
    its limitations, have a look at `$ANDROID_NDK/docs/system/libc/OVERVIEW.html`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：当没有激活任何 STL 实现时，这是 NDK 的默认运行时。其代码名称为 **Bionic**，并提供了一组最小化的头文件（`cstdint`，`cstdio`，`cstring`
    等）。Bionic 不提供 STL 功能，以及异常和**运行时类型信息**（**RTTI**）。关于其限制的更多详情，请查看 `$ANDROID_NDK/docs/system/libc/OVERVIEW.html`。'
- en: '**Gabi**: This is similar to the System runtime, except that it supports exceptions
    and RTTI.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gabi**：这类似于系统运行时，不同之处在于它支持异常和 RTTI。'
- en: We will see in the part dedicated to **Boost** in this chapter how to enable
    exceptions and RTTI during compilation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章专门讨论 **Boost** 的部分，我们将看到如何在编译过程中启用异常和 RTTI。
- en: 'Each runtime is linkable either statically or dynamically (at the notable exception
    of the default system C/C++ runtime). Dynamically loaded runtimes are posts fixed
    with `_shared`, and statically loaded ones with `_static`. The full list of runtime
    identifiers you can pass to `APP_STL` is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行时都可以静态或动态链接（默认系统 C/C++ 运行时除外）。动态加载的运行时以 `_shared` 作为后缀，静态加载的则以 `_static`
    作为后缀。你可以传递给 `APP_STL` 的运行时标识符完整列表如下：
- en: '`system`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system`'
- en: '`gabi++_static` and `gabi++_shared`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gabi++_static` 和 `gabi++_shared`'
- en: '`stlport_static` and `stlport_shared`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stlport_static` 和 `stlport_shared`'
- en: '`gnustl_static` and `gnustl_shared`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnustl_static` 和 `gnustl_shared`'
- en: '`c++_static` and `c++_shared`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c++_static` 和 `c++_shared`'
- en: Remember that shared libraries need to be loaded manually at runtime. If you
    forget to load a shared library, an error is raised at runtime as soon as dependent
    libraries modules are loaded. As the compiler cannot predict in advance which
    functions are going to be called, libraries are loaded entirely in memory, even
    if most of their contents remain unused.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，共享库需要在运行时手动加载。如果你忘记加载一个共享库，那么在加载依赖库模块时，运行时就会引发错误。由于编译器无法提前预测哪些函数将被调用，因此库将完全加载到内存中，即使它们的大部分内容未被使用。
- en: On the other hand, static libraries are in fact loaded with dependent libraries.
    Indeed, static libraries do not really exist as such at runtime. Their content
    is copied into dependent libraries at compile time when they are linked. Since
    the linker knows precisely which part of the library gets called from the embedding
    module, it can strip its code and keep only what is needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态库实际上是与依赖库一起加载的。实际上，在运行时并不真正存在静态库。在编译时链接时，它们的内容被复制到依赖库中。由于链接器确切地知道库的哪部分被嵌入模块调用，因此它可以剥离其代码，只保留需要的部分。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Stripping** is the process of discarding unnecessary symbols from binaries.
    This helps reducing (potentially a lot!) binary size after linkage. This can be
    somewhat compared to the Proguard shrinking post processing in Java.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**剥离**是丢弃二进制文件中不必要符号的过程。这有助于在链接后减少（可能是大量！）二进制文件大小。这可以与Java中的Proguard收缩后处理进行比较。'
- en: However, linking results in binary code duplication if a static library is included
    more than once. Such a situation can potentially lead to a waste of memory or,
    more worryingly, issues related to, for example, global variable duplication.
    However, static C++ constructors in shared libraries are called only once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果静态库被多次包含，链接将导致二进制代码重复。这种情况可能导致内存浪费，或者更令人担忧的是，例如全局变量重复的问题。但是，共享库中的静态C++构造函数只被调用一次。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you should avoid using static libraries that are included more
    than once in a project unless you know what you are doing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非你知道自己在做什么，否则应该避免在项目中多次使用静态库。
- en: Another point to consider is that Java applications can load shared libraries
    only, which can themselves be linked against either shared or static libraries.
    For example, the main library of `NativeActivity` is a shared library, specified
    through the `android.app.lib_name` manifest property. Shared libraries referenced
    from another library must be loaded manually before. The NDK does not do it itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，Java应用程序只能加载共享库，这些共享库可以链接到共享或静态库。例如，`NativeActivity`的主库是一个共享库，通过`android.app.lib_name`清单属性指定。从另一个库引用的共享库必须在之前手动加载。NDK不会自动处理。
- en: 'Shared libraries can be loaded easily, using `System.loadLibrary()` in a JNI
    applications, but `NativeActivity` are "transparent" activities. So, if you decide
    to use shared libraries, the only solution is to write your own Java activity,
    inheriting from `NativeActivity` and invoking the appropriate `loadLibrary()`
    directives. For instance, below is what DroidBlaster activity would look like,
    if we were using `gnustl_shared` instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在JNI应用程序中，共享库可以通过`System.loadLibrary()`轻松加载，但`NativeActivity`是“透明”的活动。因此，如果你决定使用共享库，唯一的解决方案是编写自己的Java活动，从`NativeActivity`继承并调用适当的`loadLibrary()`指令。例如，如果我们使用`gnustl_shared`，DroidBlaster活动可能如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you prefer to load your native library directly from native code, you can
    use the system call `dlopen()`, which is also provided by the NDK.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意直接从本地代码加载本地库，你可以使用NDK提供的系统调用`dlopen()`。
- en: Now that the STL is enabled, let's employ it in DroidBlaster.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经启用了STL，让我们在DroidBlaster中使用它。
- en: Time for action – read files with STL stream
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——使用STL流读取文件
- en: 'Let''s use the STL to read resources from the SD card instead of the application
    asset directory, as shown in the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用STL从SD卡读取资源，而不是应用程序资源目录，如下步骤所示：
- en: Obviously, enabling the STL is useless if we do not actively use it in our code.
    Let's take advantage of this opportunity to switch from asset files to external
    files (on a `sdcard` or internal memory).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，如果我们不在代码中主动使用STL，那么启用STL是毫无用处的。让我们借此机会从资源文件切换到外部文件（位于`sdcard`或内部存储）。
- en: 'Open the existing file, `jni/Resource.hpp`, and do the following:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开现有文件`jni/Resource.hpp`，进行以下操作：
- en: Include the `fstream` and `string` STL headers.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`fstream`和`string`STL头文件。
- en: Use a `std::string` object for the file name and replace the Asset management
    members with an `std::ifstream` object (that is, an input file stream).
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::string`对象作为文件名，并用`std::ifstream`对象（即输入文件流）替换资产管理成员。
- en: Change the `getPath()` method to return a C string from the new `string` member.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`getPath()`方法，使其从新的`string`成员返回C字符串。
- en: 'Remove the `descriptor()` method and the `ResourceDescriptor` class (descriptors
    work with the Asset API only) , as shown in the following:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除`descriptor()`方法和`ResourceDescriptor`类（描述符只与Asset API一起工作），如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the corresponding implementation file `jni/Resource.cpp`. Replace the
    previous implementation, based on the asset management API with STL streams and
    strings. Files will be opened in binary mode, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开相应的实现文件`jni/Resource.cpp`。用基于STL流和字符串的资产管理API替换之前的实现。文件将以二进制模式打开，如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To read the file length, we can use the `stat()` POSIX primitive from the `sys/stat.h`
    header:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取文件长度，我们可以使用来自`sys/stat.h`头文件的`stat()` POSIX原始函数：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can use STL string comparison operator to compare two `Resource`
    objects:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用STL字符串比较运算符来比较两个`Resource`对象：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These changes to the reading system should be almost transparent, except for
    the BGM, whose content was played through an asset file descriptor.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于阅读系统的这些更改应该是几乎透明的，除了背景音乐（BGM），其内容是通过资产文件描述符播放的。
- en: 'Now, we need to provide a real file. So, in `jni/SoundService.cpp`, change
    the data source by replacing the `SLDataLocator_AndroidFD` structure with `SLDataLocation_URI`,
    as shown in the following:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个真实的文件。因此，在`jni/SoundService.cpp`中，通过将`SLDataLocator_AndroidFD`结构替换为`SLDataLocation_URI`来更改数据源，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AndroidManifest.xml` file, add the permission to read SD card files
    as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`AndroidManifest.xml`文件中，添加读取SD卡文件的权限，如下所示： '
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copy all asset resources from the asset directory to your device SD card (or
    internal memory, depending on your device) in `/sdcard/droidblaster`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有资产资源从资产目录复制到你的设备SD卡（或根据你的设备，内部存储）中的`/sdcard/droidblaster`。
- en: '*What just happened?*'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have seen how to access binary files located on the SD card with STL streams.
    We have also switched the OpenSL ES player from a file descriptor to a file name
    locator. The file name itself is created here from an STL string. STL strings
    are a real benefit as they allow us to get rid of complex C string manipulation
    primitives.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过STL流访问位于SD卡上的二进制文件。我们还把OpenSL ES播放器从文件描述符切换到了文件名定位器。文件名本身是在这里从STL字符串创建的。STL字符串是一个真正的优势，因为它们让我们摆脱了复杂的C字符串操作原语。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Almost all Android devices can store files in an additional storage location
    mounted in directory `/sdcard`. ""Almost"" is the important word here. Since the
    first Android G1, the meaning of ""sdcard"" has changed. Some recent devices have
    an external storage that is in fact internal (for example, flash memory on some
    tablets), and some others have a second storage location at their disposal (although
    in most cases, the second storage is mounted inside `/sdcard`). Moreover, the
    `/sdcard` path itself is not engraved into the marble. So, to detect safely the
    additional storage location, the only solution is to rely on JNI by calling `android.os.Environment.getExternalStorageDirectory()`.
    You can also check that storage is available with `getExternalStorageState()`.
    Note that the word ""External"" in API method name is here for historical reasons
    only. Also, the permission `WRITE_EXTERNAL_STORAGE` in manifest is required.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Android设备都可以在挂载在`/sdcard`目录的附加存储位置存储文件。这里“几乎”是重要的词。从第一款Android G1开始，“sdcard”的含义已经改变。一些最近的设备有一个实际上是内部的外部存储（例如，某些平板电脑上的闪存），还有一些其他设备可以使用第二个存储位置（尽管在大多数情况下，第二个存储是挂载在`/sdcard`内部的）。此外，`/sdcard`路径本身并不是刻在大理石上的。因此，为了安全地检测附加存储位置，唯一的解决方案是依靠JNI调用`android.os.Environment.getExternalStorageDirectory()`。你也可以通过`getExternalStorageState()`检查存储是否可用。请注意，API方法名称中的“External”一词仅出于历史原因。此外，需要在manifest中请求`WRITE_EXTERNAL_STORAGE`权限。
- en: The STL provides much more features than Files and Strings. The most popular
    among them are probably STL containers. Let's see some usage examples in DroidBlaster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: STL提供的功能远不止Files和Strings。其中最受欢迎的可能是STL容器。让我们在DroidBlaster中看看一些使用示例。
- en: Time for action – using STL containers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——使用STL容器
- en: 'Let''s now replace raw arrays with standard STL containers by following these
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤将原始数组替换为标准的STL容器：
- en: 'Open the `jni/GraphicsManager.hpp` header and include the headers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/GraphicsManager.hpp`头文件并包含以下头文件：
- en: '`Vector`, which defines an STL container encapsulating C arrays (with a few
    more interesting features such as dynamic resizing)'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector`，它定义了一个STL容器，封装了C数组（并带有一些更有趣的特性，如动态调整大小）'
- en: '`Map`, which encapsulates the equivalent of a Java HashMap (that is, an associative
    array)'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`，它封装了相当于Java HashMap的东西（也就是关联数组）'
- en: Then, remove the `textureResource` member in the `TextureProperties` structure.
    Use a `map` container instead of a raw array for `mTextures` (prefixed with the
    `std` namespace). The first parameter is the key type and the second the value
    type.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在`TextureProperties`结构中移除`textureResource`成员。使用`map`容器代替`mTextures`的原始数组（使用`std`命名空间前缀）。第一个参数是键类型，第二个是值类型。
- en: 'Finally, replace all the other raw arrays with a `vector`, as shown in the
    following:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，将所有其他原始数组替换为以下所示的`vector`：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Edit `jni/GraphicsManager.cpp` and initialize the new STL containers in the
    constructor initialization list as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/GraphicsManager.cpp`并在构造函数初始化列表中初始化新的STL容器，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `vector::push_back()` method to insert components into the `mComponents`
    list when they get registered, as shown in the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件注册时，使用`vector::push_back()`方法将组件插入到`mComponents`列表中，如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `start()`, we can iterate through the vector using an iterator to initialize
    each registered component, as shown in the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`start()`中，我们可以使用迭代器遍历向量，以初始化每个已注册的组件，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `stop()`, we can iterate through the map (with second representing entry''s
    value) and vector collections to release each allocated OpenGL resource this time,
    as shown in the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stop()`中，我们可以遍历map（其中second表示条目的值）和向量集合，以释放这次分配的每个OpenGL资源，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also iterate over components stored to render them in `update()`, as shown
    in the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要在`update()`中遍历存储的组件以渲染它们，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since textures are expensive resources, use the `map` to check if a texture
    has already been loaded before loading and caching a new instance, as shown in
    the following:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于纹理是昂贵的资源，在加载和缓存新实例之前，使用`map`检查纹理是否已经加载，如下所示：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the defined `vector` objects to save shaders and vertex buffers. Use `push_back()`
    again to add an element to the vector, as shown in the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用定义的`vector`对象保存着色器和顶点缓冲区。再次使用`push_back()`向向量中添加一个元素，如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, open `jni/SpriteBatch.hpp`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`jni/SpriteBatch.hpp`。
- en: 'Here again, include and use `vector` objects instead of raw arrays:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，包含并使用`vector`对象，而不是原始数组：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `jni/SpriteBatch.cpp`, replace the usage of raw arrays with vectors, as
    shown in the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/SpriteBatch.cpp`中，用向量替换原始数组的用法，如下所示：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'During the loading and drawing process, loop over the `vector`. You can use
    an `iterator` (here in `load()`), as shown in the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载和绘制过程中，遍历`vector`。你可以在`load()`中使用一个`iterator`，如下所示：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, declare a `std::vector` in `jni/Asteroid.hpp` as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/Asteroid.hpp`中声明一个`std::vector`，如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the vector to insert and iterate over bodies in `jni/Asteroid.cpp`, as
    shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Asteroid.cpp`中使用向量插入和遍历body，如下代码所示：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: There has been a use of STL containers throughout the application to replace
    raw C arrays. For example, we have managed a set of `Asteroid` game objects inside
    an STL container vector instead of a raw C array. We have also replaced the texture
    cache using an STL map container. STL containers have many advantages, such as
    automatically handling memory management (array resizing operations and so on),
    to alleviate our burden.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个应用程序中已经使用了STL容器来替换原始的C数组。例如，我们使用STL容器向量而不是原始C数组来管理一组`Asteroid`游戏对象。我们还使用STL
    map容器替换了纹理缓存。STL容器具有许多优点，如自动处理内存管理（数组调整大小操作等），以减轻我们的负担。
- en: STL is definitely a huge improvement that avoids repetitive and error-prone
    code. Many open source libraries require it and it can now be ported without much
    trouble. More documentation about it can be found at [http://www.cplusplus.com/reference/stl](http://www.cplusplus.com/reference/stl)
    and on SGI's website (publisher of the first STL) at [http://www.sgi.com/tech/stl](http://www.sgi.com/tech/stl).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: STL绝对是一个巨大的改进，它避免了重复和容易出错的代码。许多开源库需要它，现在可以毫不费力地移植。关于它的更多文档可以在[http://www.cplusplus.com/reference/stl](http://www.cplusplus.com/reference/stl)以及SGI的网站（第一个STL的发布者）上找到，地址是[http://www.sgi.com/tech/stl](http://www.sgi.com/tech/stl)。
- en: 'When developing for performance, standard STL containers are not always the
    best choice, especially in terms of memory management and allocation. Indeed,
    STL is an all-purpose library, written for common cases. Alternative libraries
    might be considered for performance-critical code. A few examples are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能开发中，标准的STL容器并不总是最佳选择，特别是在内存管理和分配方面。实际上，STL是一个通用的库，是为了常见情况而编写的。对于性能至关重要的代码，可以考虑使用其他库。以下是一些例子：
- en: '**EASTL**: This is an STL replacement developed by Electronic Arts with gaming
    in mind. An extract is available in the repository at [https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL).
    A must-read paper detailing EASTL technical details can be found on the Open Standards
    website at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EASTL**：这是由Electronic Arts开发的，考虑到游戏而设计的STL替代品。在仓库中可以找到其摘录，地址是[https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL)。一份详细介绍EASTL技术细节的必读论文可以在Open
    Standards网站上找到，地址是[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html)。'
- en: '**Bitsquid Foundation library**: This is another STL replacement targeting
    games and can be found at [https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bitsquid Foundation库**：这是另一个针对游戏设计的STL替代品，可以在[https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/)找到。'
- en: '**RDESTL**: This is an open source subset of the STL, based on the EASTL technical
    paper, which was published several years before EASTL code release. The code repository
    can be found at [http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RDESTL**：这是一个开源的STL子集，基于EASTL技术论文，该论文在EASTL代码发布前几年就已经发表。代码仓库可以在[http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/)找到。'
- en: '**Google SparseHash**: This is for a high performance associative array library
    (note that RDESTL is also quite good at that).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google SparseHash**：这是一个高性能的关联数组库（注意，RDESTL在这方面也相当不错）。'
- en: This is far from exhaustive. Just define your exact needs to make the most appropriate
    choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这远非详尽无遗。只需定义你的确切需求，以做出最合适的选择。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: STL is still the best choice for most applications or libraries. Before going
    away from it, profile your source code and make sure it is really necessary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用或库来说，STL仍然是最佳选择。在放弃它之前，分析你的源代码，确保这样做是真正必要的。
- en: Porting Box2D to Android
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Box2D移植到Android
- en: With the STL in our basket, we are ready to port almost any library to Android.
    Actually, many third-party libraries are already ported and many more are coming.
    However, when nothing is available, you have to rely on our own skills.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有STL工具，我们已准备好将几乎任何库移植到Android。实际上，许多第三方库已经被移植，还有更多正在路上。然而，当没有可用的资源时，你就得依靠自己的技能。
- en: To see how to handle this situation, we are now going to port Box2D with the
    NDK. Box2D is a highly popular physics simulation engine initiated by Erin Catto
    in 2006\. Many 2D games, either amateur or professional like Angry Birds, embed
    this powerful open source library. It is available in several languages, including
    Java, though its primary language is C++.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何处理这种情况，我们现在将使用NDK移植Box2D。Box2D是一个高度流行的物理模拟引擎，由Erin Catto于2006年发起。许多2D游戏，无论是业余的还是专业的，如愤怒的小鸟，都嵌入了这个强大的开源库。它支持多种语言，包括Java，但其主要语言是C++。
- en: 'Box2D is an answer to the complex subject, that is, physics simulation. Maths,
    numerical integration, software optimization, and so on are some of the multiple
    techniques applied to simulate rigid body movements and collisions in a 2D environment.
    Bodies are the essential element of Box2D and are characterized by the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D是针对复杂主题的一个答案，即物理模拟。数学、数值积分、软件优化等都是模拟二维环境中刚体运动和碰撞的多种技术。刚体是Box2D的基本元素，其特点如下：
- en: A geometrical **shape** (polygons, circles, and so on)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个几何**形状**（多边形、圆形等）
- en: Physics properties (such as **density**, **friction**, **restitution**, and
    so on)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理属性（如**密度**、**摩擦**、**恢复系数**等）
- en: Movement **constraints** and **joints** (to link bodies together and restrict
    their movement)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动**约束**和**关节**（将物体连接在一起并限制其运动）
- en: All these bodies are orchestrated inside a *World* that steps simulation according
    to time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些物体都在一个名为*世界*的模拟环境中，根据时间进行模拟。
- en: So, now that you know the very basics of Box2D, let's port and integrate it
    in DroidBlaster to simulate collisions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了Box2D的基础知识，那么让我们将其移植并集成到DroidBlaster中，以模拟碰撞。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part17`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名为`DroidBlaster_Part17`。
- en: Time for action – compiling Box2D on Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——在Android上编译Box2D
- en: 'First, let''s port Box2D on the Android NDK following these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下步骤在Android NDK上移植Box2D：
- en: Box2D 2.3.1 archive is provided with this book in directory `Libraries/box2d`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 2.3.1归档文件包含在本书的`Libraries/box2d`目录中。
- en: Unzip Box2D source archive (2.3.1 in this book) into `${ANDROID_NDK}/sources/`
    (beware directory must be named `box2d`).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压Box2D源代码归档文件（本书中使用的是2.3.1版）到`${ANDROID_NDK}/sources/`（注意目录必须命名为`box2d`）。
- en: Create and open an `Android.mk` file in the root of the `box2d` directory.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`box2d`目录的根目录中创建并打开一个`Android.mk`文件。
- en: First, save the current directory inside the `LOCAL_PATH` variable. This step
    is always necessary because an NDK build system may switch to another directory
    at any time during compilation.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，将当前目录保存到`LOCAL_PATH`变量中。这一步始终是必要的，因为NDK构建系统在编译过程中的任何时候都可能切换到另一个目录。
- en: After this, list all Box2D source files to compile, as shown in the following.
    We are interested in source file name only, which can be found in `${ANDROID_NDK}/sources/box2d/Box2D/Box2D`.
    Use the `LS_CPP` helper function to avoid copying each filename.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，列出所有要编译的 Box2D 源文件，如下所示。我们只关心可以在 `${ANDROID_NDK}/sources/box2d/Box2D/Box2D`
    中找到的源文件名。使用 `LS_CPP` 辅助函数以避免复制每个文件名。
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, write the Box2D module definition for a static library. First, call the
    `$(CLEAR_VARS)` script. This script has to be included before any module definition
    to remove any potential change made by other modules, and to avoid any unwanted
    side effects. Then, define the following settings:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为静态库编写 Box2D 模块定义。首先调用 `$(CLEAR_VARS)` 脚本。这个脚本必须在任何模块定义之前包含，以移除其他模块可能做出的任何更改，并避免任何不希望出现的副作用。然后，定义以下设置：
- en: 'Module name in `LOCAL_MODULE`: The module name is suffixed with _static to
    avoid a name collision with the shared version we are going to define right after.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE` 中的模块名称：模块名称以 _static 结尾，以避免与即将定义的共享版本名称冲突。'
- en: Module source files in `LOCAL_SRC_FILES` (using `BOX2D_CPP` defined previously).
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `LOCAL_SRC_FILES` 中的模块源文件（使用之前定义的 `BOX2D_CPP`）。
- en: Header file directory exported to client modules in `LOCAL_EXPORT_C_INCLUDES`.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`LOCAL_EXPORT_C_INCLUDES`中将头文件目录导出到客户端模块。
- en: 'Header file used internally for module compilation in `LOCAL_C_INCLUDES`. Here,
    the headers used for Box2D compilation and the headers needed for the client module
    are the same (and are often the same in other libraries). So, reuse `LOCAL_EXPORT_C_INCLUDES`,
    as defined previously, in the following way:'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `LOCAL_C_INCLUDES` 中用于模块编译的内部头文件。这里，用于 Box2D 编译的头文件和客户端模块需要的头文件是相同的（在其他库中通常也是相同的）。因此，以下方式重用之前定义的
    `LOCAL_EXPORT_C_INCLUDES`：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Android.mk` archive is provided in the `Libraries/box2d` directory.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Android.mk` 文件位于 `Libraries/box2d` 目录中。'
- en: 'Open DroidBlaster `Android.mk` and link against `box2d_static` by appending
    it to `LOCAL_STATIC_LIBRARIES`. Indicate which `Android.mk` module file to include
    with the `import-module` directive. Remember that modules are found, thanks to
    the `NDK_MODULE_PATH` variable, which points by default to `${ANDROID_NDK}/sources`,
    as shown in the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 DroidBlaster 的 `Android.mk` 文件，并将 `box2d_static` 添加到 `LOCAL_STATIC_LIBRARIES`
    中以链接它。使用 `import-module` 指令指出要包含哪个 `Android.mk` 模块文件。请记住，由于 `NDK_MODULE_PATH`
    变量指向默认的 `${ANDROID_NDK}/sources`，因此可以找到模块，如下所示：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Optionally, activate include file resolution in Eclipse if you see warnings
    about Box2D including files. To do so, in Eclipse **Project properties**, navigate
    to **the C/C++ General/Paths and Symbols** section and then the **Includes** tab,
    and add the Box2d directory `${env_var:ANDROID_NDK}/sources/box2d`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Eclipse 中看到有关 Box2D 包含文件的警告，可以选择激活包含文件的解析。为此，在 Eclipse 的 **项目属性** 中，导航到
    **C/C++ 通用/路径和符号** 部分，然后是 **包含** 选项卡，并添加 Box2d 目录 `${env_var:ANDROID_NDK}/sources/box2d`。
- en: '*What just happened?*'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Launch the DroidBlaster compilation. Box2D is compiled without errors. We have
    ported our second open source library (after `libpng`) to Android thanks to the
    NDK! We can finally reuse one of the many wheels already created by the community!
    Porting a native library to Android involves mainly writing an `Android.mk` module
    makefile to describe source files, dependencies, compilation flags, and so on,
    as we have done until now for our main module DroidBlaster.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 DroidBlaster 编译。Box2D 编译无误。借助 NDK，我们将第二个开源库（继 `libpng` 之后）移植到了 Android！我们终于可以重用社区已经创建的众多轮子之一了！将原生库移植到
    Android 主要涉及编写一个 `Android.mk` 模块 makefile 来描述源文件、依赖项、编译标志等，正如我们现在为我们的主模块 DroidBlaster
    所做的那样。
- en: 'We have seen some of the most essential variables to use in a module, and they
    are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了模块中一些最关键的变量，它们如下所示：
- en: '`LOCAL_MODULE`: This declares a unique module name where the final library
    name depends on its value'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_MODULE`：这声明了一个唯一的模块名称，最终的库名称取决于其值。'
- en: '`LOCAL_SRC_FILES`: This lists all the files to compile relative to the module''s
    root'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`：这列出了所有相对于模块根目录的待编译文件。'
- en: '`LOCAL_C_INCLUDES`: This defines `include` file directories'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_C_INCLUDES`：这定义了 `include` 文件目录。'
- en: '`LOCAL_EXPORT_C_INCLUDES`: This defines `include` file directories but for
    including modules this time'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_EXPORT_C_INCLUDES`：这定义了 `include` 文件目录，但这次是用于包含模块。'
- en: 'The order to build Box2D module build is given by one of the following directives:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Box2D 模块的顺序由以下指令之一给出：
- en: '`BUILD_STATIC_LIBRARY`: This compiles the module as a static library'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_STATIC_LIBRARY`：这将模块编译为静态库。'
- en: '`BUILD_SHARED_LIBRARY`: This also compiles the module but as a shared library
    this time'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_SHARED_LIBRARY`：这次也会编译模块，但作为共享库'
- en: A module can be compiled as a static or shared library in the same way as the
    STL. Compilation is performed dynamically (that is, on-demand) each time a client
    application imports the module or changes its compilation settings. Hopefully,
    the NDK is able to compile sources incrementally.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以像 STL 一样编译为静态或共享库。编译是动态执行的（即按需），每次客户端应用程序导入模块或更改其编译设置时都会执行。希望 NDK 能够增量编译源代码。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To create a module for a header only library, such as parts of Boost or GLM
    (a library for OpenGL ES matrix calculations), define a module without `LOCAL_SRC_FILES`
    defined. Only `LOCAL_MODULE` and `LOCAL_EXPORT_C_INCLUDES` are necessary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要为仅包含头文件的库（如 Boost 或 GLM（用于 OpenGL ES 矩阵计算的库）的部分）创建模块，请定义一个没有 `LOCAL_SRC_FILES`
    的模块。只需要 `LOCAL_MODULE` 和 `LOCAL_EXPORT_C_INCLUDES`。
- en: From the client `Android.mk` perspective (that is `the DroidBlaster` makefile
    in our case), the NDK `import-module` directive triggers, roughly speaking, include
    sub-module `Android.mk` files. Without it, the NDK will not be able to discover
    dependent modules, compile them, and include their headers. All the modules, the
    main module as well as the sub-modules, are produced in `<PROJECT_DIR>/libs`,
    and intermediate binary files are in `<PROJECT_DIR>/obj` for the main application
    module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端 `Android.mk` 的角度来看（即我们的 `DroidBlaster` makefile），NDK `import-module` 指令大致上触发包含子模块
    `Android.mk` 文件。没有它，NDK 将无法发现依赖模块、编译它们并包含它们的头文件。所有模块，包括主模块和子模块，都生成在 `<PROJECT_DIR>/libs`
    中，主应用程序模块的中间二进制文件在 `<PROJECT_DIR>/obj` 中。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `import-module` directive should be located at the end of the file to avoid
    altering module definition.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`import-module` 指令应位于文件末尾，以避免更改模块定义。'
- en: 'The following are the three ways to link against "sub-module" libraries in
    the main `Android.mk` Makefile:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主 `Android.mk` Makefile 中链接“子模块”库的三种方法：
- en: Static libraries must be listed in the `LOCAL_STATIC_LIBRARIES` variable (as
    we have done for Box2D)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态库必须在 `LOCAL_STATIC_LIBRARIES` 变量中列出（例如我们对 Box2D 所做的那样）
- en: Shared libraries need to be listed in the `LOCAL_SHARED_LIBRARIES` variable
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库需要在 `LOCAL_SHARED_LIBRARIES` 变量中列出
- en: Shared system libraries should be listed in `LOCAL_LDLIBS` (as we have done
    for OpenGL ES, for example)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享系统库应该在 `LOCAL_LDLIBS` 中列出（例如我们对 OpenGL ES 所做的那样）
- en: For more information about Makefiles, see the *Mastering module Makefiles* section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Makefiles 的更多信息，请参见 *掌握模块 Makefiles* 部分。
- en: 'Writing a Makefile is an important part of the porting process. However, it
    is not always sufficient. Porting a library can be slightly more involved, depending
    on its originating platforms. For example, a piece code already ported to iOS
    is often easier to port to Android. In more complex cases, it may become necessary
    to patch code to make it behave properly on Android. When you are condemned to
    such a hard and non-trivial task, which is honestly quite frequent, always consider
    the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Makefile 是移植过程的重要组成部分。然而，它并不总是足够的。根据库的原始平台，移植库可能会更加复杂。例如，已经移植到 iOS 的代码通常更容易移植到
    Android。在更复杂的情况下，可能需要修补代码以使其在 Android 上正常工作。当你被这样一个艰难且非琐碎的任务所困扰时，这实际上是非常频繁的，请始终考虑以下事项：
- en: Make sure required libraries exist, and port them first if not.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所需的库存在，如果不存在，请先移植它们。
- en: Look for the main configuration header file if one is provided with your library
    (as this is often the case). It is a good place to tweak enabled or disabled features,
    remove unwanted dependencies, or define new Macros.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果随库提供了主配置头文件（通常是这样），请查找它。这是调整启用或禁用功能、移除不需要的依赖或定义新宏的好地方。
- en: Give attention to system-related macros (that is, `#ifdef _LINUX` ...), which
    are one of the first places to look for changes to make in the code. Generally,
    one will need to define macros, such as `_ANDROID_`, and insert them where appropriate.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意与系统相关的宏（即 `#ifdef _LINUX` ...），这是查找代码中需要更改的第一地方之一。通常，需要定义宏，比如 `_ANDROID_`，并将其适当地插入到代码中。
- en: Comment non-essential code to check if the library can compile and if its core
    features can possibly work. Indeed, do not bother fixing everything if you are
    unsure yet whether it will work.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释掉非必要代码，以检查库是否可以编译以及其核心功能是否可能工作。实际上，如果你还不确定它是否能工作，就不要费力修复所有问题。
- en: Hopefully, Box2D was not tight to a specific platform, as it relies mainly on
    pure C/C++ computation and not on external APIs. In such cases, porting code becomes
    much easier. Now that Box2D is compiled, let's run it in our own code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Box2D并未依赖于特定的平台，因为它主要依赖于纯C/C++计算，而不是外部API。在这种情况下，代码移植变得更容易。现在Box2D已经编译完成，让我们在自己的代码中运行它。
- en: Time for action – running Box2D physics engine
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手操作——运行Box2D物理引擎的时间到了。
- en: 'Let''s rewrite the DroidBlaster physics engine with Box2D with the following
    steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤用Box2D重写DroidBlaster物理引擎：
- en: Open the `jni/PhysicsManager.hpp` header and insert the Box2D `include` file.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/PhysicsManager.hpp`头文件，并插入Box2D的`include`文件。
- en: Define a constant `PHYSICS_SCALE` to convert the body position from physics
    to game coordinates. Indeed, Box2D uses its own scale for a better precision.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个常数`PHYSICS_SCALE`，以将物体位置从物理坐标系转换为游戏坐标系。实际上，Box2D使用自己的比例以获得更好的精度。
- en: 'Then, replace `PhysicsBody` with a new structure, `PhysicsCollision`, that
    will indicate which bodies entered in collision, as shown in the following:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，用一个新的结构体`PhysicsCollision`替换`PhysicsBody`，这将指示哪些物体进入了碰撞，如下所示：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, make `PhysicsManager` inherit from `b2ContactListener`. A contact listener
    gets notified about new collisions each time the simulation is updated. Our `PhysicsManager`
    inherits one of its method's named `BeginContact()`, used to react to collisions.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让`PhysicsManager`继承自`b2ContactListener`。接触监听器会在每次更新模拟时收到新的碰撞通知。我们的`PhysicsManager`继承了一个名为`BeginContact()`的方法，用于对碰撞做出反应。
- en: 'We will need three more methods, which are as follows:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要三种方法，如下所示：
- en: '`loadBody()` to create a new entity within the physics engine'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadBody()`用于在物理引擎中创建一个新的实体'
- en: '`loadTarget()` to create an entity that moves toward a target (our spaceship)'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadTarget()`用于创建向目标（我们的太空船）移动的实体'
- en: '`start()` to initialize the engine when the game starts'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`用于在游戏开始时初始化引擎'
- en: 'Also, define member variables, which are as follows:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，定义以下成员变量：
- en: '`mWorld` represents the whole Box2D simulation which contains all the bodies
    we are going to create'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mWorld`代表整个Box2D模拟，其中包含我们将要创建的所有物体'
- en: '`mBodies` is the list of all the physics entities we have registered'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBodies`是我们已注册的所有物理实体的列表'
- en: '`mLocations` contains a copy of the `b2Body` position in game coordinates (instead
    of physics coordinates which have a different scale)'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mLocations`包含`b2Body`在游戏坐标系（而不是物理坐标系，其尺度不同）中的位置的副本'
- en: '`mBoundsBodyObj` defines the boundaries in which our space ship will be able
    to move'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBoundsBodyObj`定义了我们的太空船可以移动的边界'
- en: '[PRE25]'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implement `jni/PhysicsManager.cpp`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/PhysicsManager.cpp`。
- en: Iteration constants determine the simulation accuracy. Here, Box2D is going
    to handle mainly collisions and simple movements. So, fixing velocity and position
    iterations to `6` and `2`, respectively, is sufficient (more about their meaning
    a bit later).
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代常数决定了模拟的精确度。在这里，Box2D主要处理碰撞和简单移动。因此，将速度和位置迭代分别固定为`6`和`2`就足够了（稍后会详细介绍它们的意义）。
- en: 'Initialize the new `PhysicsManager` members and let it listen to collision
    events with `SetContactListener()` on the `mWorld` object, as shown in the following:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化新的`PhysicsManager`成员，并让它在`mWorld`对象上通过`SetContactListener()`监听碰撞事件，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Initialize Box2D world boundaries when the game starts. These boundaries match
    the display window size converted into *physics system coordinates*. Indeed, the
    physics system uses its own predefined scale to preserve float-point value accuracy.
    We need four edges to define these boundaries, as shown in the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏开始时，初始化Box2D世界的边界。这些边界与转换为*物理系统坐标系*的显示窗口大小相匹配。实际上，物理系统使用自己的预定义比例以保持浮点值精度。我们需要四个边缘来定义这些边界，如下所示：
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Initialize and register asteroid or ship physics bodies in `loadBody()`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loadBody()`中初始化并注册小行星或飞船的物理实体。
- en: The body definition describes a dynamic body (as opposed to static), awake (that
    is, actively simulated by Box2D), and which cannot rotate (a property especially
    important for polygon shapes, meaning that it is always pointing upward).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 物体定义描述了一个动态物体（相对于静态物体），它是唤醒的（即由Box2D积极模拟），并且不能旋转（对于多边形形状，这一属性尤为重要，意味着它总是朝上的）。
- en: Also note how we save a `PhysicsCollision` self-reference in the `userData`
    field, in order to access it later inside Box2D callbacks.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还请注意我们如何在`userData`字段中保存`PhysicsCollision`自身的引用，以便稍后在Box2D回调中访问它。
- en: 'Define the body shape, which we approximate to a circle. Note that Box2D requires
    a half dimension, from the object''s center to its borders, as shown in the following
    code snippet:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义身体形状，我们将其近似为圆形。请注意，Box2D 需要一个半尺寸，从物体的中心到其边界，如下代码片段所示：
- en: '[PRE28]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Body fixture is the "glue" that ties together body definition, shape, and physical
    properties. We also use it to set the body's category and mask, and to filter
    collisions between objects (for instance, asteroids can collide with the ship
    but not between themselves in DroidBlaster). One bit represents one category.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 身体夹具是将身体定义、形状和物理属性联系在一起的“胶水”。我们还使用它来设置身体的类别和掩码，以及过滤对象之间的碰撞（例如，在 DroidBlaster
    中，行星可以与飞船碰撞，但它们之间不能相互碰撞）。一个位表示一个类别。
- en: 'Finally, effectively instantiate your `body` inside the Box2D physical world,
    as shown in the following code:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在 Box2D 物理世界中有效实例化你的 `body`，如下代码所示：
- en: '[PRE29]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `loadTarget()` method that creates a Box2D mouse joint to simulate
    spaceship movements. Such a `Joint` defines an empty target toward which the body
    (here specified in parameter) moves, like a kind of elastic. The settings used
    here (`maxForce`, `dampingRatio`, and `frequencyHz`) control how the ship reacts
    and can be determined by tweaking them, as shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `loadTarget()` 方法，创建一个 Box2D 鼠标关节以模拟飞船移动。这样的 `Joint` 定义了一个空的靶标，身体（在此处指定参数）像弹性一样向其移动。这里使用的设置（`maxForce`、`dampingRatio`
    和 `frequencyHz`）控制飞船如何反应，可以通过调整它们来确定，如下代码所示：
- en: '[PRE30]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Write the `update()` method.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `update()` 方法。
- en: First, clear any collision flag buffered in `BeginContact()` during previous
    iteration.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，清除在上一轮迭代中 `BeginContact()` 缓冲的任何碰撞标志。
- en: Then, perform simulation by calling `Step()`. The time period specifies how
    much time must be simulated. Iterations constants determine simulation accuracy.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，通过调用 `Step()` 进行模拟。时间周期指定必须模拟的时间。迭代常数决定了模拟的准确性。
- en: 'Finally, loop over all of the physics bodies to extract their coordinates,
    convert them from Box2D to game coordinates, and store the result into our own
    `Location` object, as shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，遍历所有物理体以提取它们的坐标，将它们从 Box2D 坐标转换为游戏坐标，并将结果存储到我们自己的 `Location` 对象中，如下代码所示：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finish with the `BeginContact()` method inherited by `b2ContactListener`. This
    callback notifies new collisions between bodies, two at a time (named `A` and
    `B`). Event information is stored in a `b2contact` structure, which contains various
    properties, such as friction, restitution, and the two bodies, involved through
    their fixture. These fixtures contain in themselves a reference to our own `PhysicsCollision`.
    We can use the following link to switch the `PhysicsCollision` collision flag
    when Box2D detects one contact:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用继承自 `b2ContactListener` 的 `BeginContact()` 方法结束。这个回调通知两个物体（名为 `A` 和 `B`）之间新发生的碰撞。事件信息存储在
    `b2contact` 结构中，其中包含各种属性，例如摩擦力、恢复系数以及通过其夹具涉及的两个物体。这些夹具本身包含对我们自己的 `PhysicsCollision`
    的引用。当 Box2D 检测到一个接触时，我们可以使用以下链接切换 `PhysicsCollision` 碰撞标志：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `jni/Asteroid.hpp`, replace the usage of `PhysicsBody` with Box2D `b2Body`
    structure, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Asteroid.hpp` 中，将 `PhysicsBody` 的使用替换为 Box2D `b2Body` 结构，如下代码所示：
- en: '[PRE33]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `jni/Asteroid.cpp`, scale constants and boundaries to the physics coordinate
    system:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Asteroid.cpp` 中，将常数和边界缩放到物理坐标系：
- en: '[PRE34]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, update the way an asteroid body is registered. Register physics properties
    with a category and mask. Here, asteroids are declared as belonging to category
    1 (`0X1` in hexadecimal notation), and only bodies in group 2 (`0X2` in hexadecimal)
    are considered when evaluating collisions:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新行星体的注册方式。用类别和掩码注册物理属性。在这里，行星被声明为属于类别 1（十六进制表示为 `0X1`），在评估碰撞时只考虑组 2（十六进制表示为
    `0X2`）中的物体：
- en: '[PRE35]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace and update the remaining code to accommodate the use of the new `b2Body`
    structure instead of the `PhysicsBody` one:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换并更新剩余的代码，以适应使用新的 `b2Body` 结构而不是 `PhysicsBody` 结构：
- en: '[PRE36]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, also update `spawn()` code to initialize the `PhysicsBody`, as shown
    in the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，也更新 `spawn()` 代码以初始化 `PhysicsBody`，如下代码所示：
- en: '[PRE37]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Open `jni/Ship.hpp` to turn it into a Box2D body.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `jni/Ship.hpp` 文件，将其转换为 Box2D body。
- en: Add a new `b2Body` parameter to the `registerShip()` method.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向 `registerShip()` 方法中添加一个新的 `b2Body` 参数。
- en: 'Then, define the following two additional methods:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，定义以下两个附加方法：
- en: '`update()`, which contains some new game logic to destroy the ship when it
    collides with asteroids'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`，其中包含一些新的游戏逻辑，当飞船与行星碰撞时销毁飞船'
- en: '`isDestroyed()` to indicate if the ship has been destroyed'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDestroyed()` 指示飞船是否已被销毁'
- en: 'Declare the following necessary variables:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明以下必要的变量：
- en: '`mBody` to manage the ship representation in Box2D'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBody` 用于在 Box2D 中管理飞船的表示'
- en: '`mDestroyed` and `mLives` for the game logic'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mDestroyed` 和 `mLives` 用于游戏逻辑'
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Declare a few new constants in `jni/Ship.cpp`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jni/Ship.cpp` 中声明一些新的常量。
- en: 'Then, initialize the new member variables properly. Note that you don''t need
    to play the collision sound anymore in `initialize()`:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接着，适当初始化新的成员变量。注意，在 `initialize()` 中不再需要播放碰撞声音：
- en: '[PRE39]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In `update()`, check if the ship body has collided with an asteroid. To do so,
    check the `PhysicsCollision` structure stored in the ship `b2Body` custom user
    data. Remember that its content is set in the `PhysicsManager::BeginContact()`
    method
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update()` 中，检查飞船体是否与小行星发生碰撞。为此，检查存储在飞船 `b2Body` 自定义用户数据中的 `PhysicsCollision`
    结构。记住，其内容是在 `PhysicsManager::BeginContact()` 方法中设置的
- en: When the ship collides, we can decrease its life and play a collision sound.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当飞船发生碰撞时，我们可以减少其生命值并播放碰撞声音。
- en: If it has no more life, we can start playing a destruction animation. The body
    should be inactive when this happens to avoid further collision with asteroids.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它没有生命值了，我们可以开始播放销毁动画。当这种情况发生时，物体应该是非激活状态，以避免与更多的小行星发生碰撞。
- en: 'When ship is fully destroyed, we can save its state so that the game loop can
    act appropriately, as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当飞船完全被销毁时，我们可以保存其状态，以便游戏循环可以适当作出反应，如下代码所示：
- en: '[PRE40]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Update the `jni/MoveableBody.hpp` component so that it returns a `b2Body` structure
    in `registerMoveableBody()`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `jni/MoveableBody.hpp` 组件，使其在 `registerMoveableBody()` 中返回一个 `b2Body` 结构。
- en: 'Add the following two new members:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加以下两个新的成员：
- en: '`mBody` for the physical body'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBody` 用于物理体'
- en: '`mTarget` for the mouse joint:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTarget` 用于鼠标关节：'
- en: '[PRE41]'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Adapt `jni/MoveableBody.cpp` constants to the new scale and initialize new
    members in the constructor:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 `jni/MoveableBody.cpp` 中的常量以适应新的比例，并在构造函数中初始化新成员：
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, set up and update the `physicsbody` so that it follows the ship''s target.
    The target moves according to user input, as shown in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置并更新 `physicsbody` 以跟随飞船的目标。目标根据用户输入移动，如下代码所示：
- en: '[PRE43]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, edit `jni/DroidBlaster.cpp` and change the ship registration code
    to accommodate the new changes, as shown in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑 `jni/DroidBlaster.cpp` 并更改飞船注册代码以适应新的变化，如下代码所示：
- en: '[PRE44]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Don''t forget to start the `PhysicsManager` in `onActivate()`, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在 `onActivate()` 中启动 `PhysicsManager`，如下代码所示：
- en: '[PRE45]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Terminate by updating and checking ship state in `onStep()`. When it is destroyed,
    exit the game loop as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onStep()` 中通过更新并检查飞船状态来结束。当它被销毁时，按以下方式退出游戏循环：
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We have created a physical simulation using the Box2D physics engine. More
    specifically, we have seen how to do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Box2D 物理引擎创建了一个物理模拟。更具体地说，我们已经了解了如何执行以下操作：
- en: Create a Box2D world to describe the physical simulation
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Box2D 世界以描述物理模拟
- en: Define a physical representation of entities (ships and asteroids)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实体的物理表示（飞船和小行星）
- en: Step a simulation
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步进模拟
- en: Filter and detect collisions between entities
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选并检测实体之间的碰撞
- en: Extract simulation state (that is, coordinates) to feed the graphical representation
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取模拟状态（即坐标）以供图形表示使用
- en: Box2D uses its own allocators to optimize memory management. So, to create and
    destroy Box2D objects, one needs to systematically use the provided factory methods
    (`CreateX()`, `DestroyX()`). Most of the time, Box2D will manage memory automatically
    for you. When an object is destroyed, all related *child objects* get destroyed
    (for instance, the bodies are destroyed when the world is destroyed). But, if
    you need to get rid of your objects earlier, and thus manually, always destroy
    the bodies.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 使用自己的分配器来优化内存管理。因此，要创建和销毁 Box2D 对象，需要系统地使用提供的工厂方法（`CreateX()`, `DestroyX()`）。大多数情况下，Box2D
    会自动为你管理内存。当一个对象被销毁时，所有相关的 *子对象* 也会被销毁（例如，当世界被销毁时，物体也会被销毁）。但是，如果你需要提前摆脱这些对象，即手动操作，请始终先销毁物体。
- en: Box2D is a complex piece of code and is quite hard to tune properly. Let's dive
    a bit deeper into the way its world is described and how to handle collision.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 是一段复杂的代码，并且相当难以正确调整。让我们深入了解一下它的世界描述方式以及如何处理碰撞。
- en: Diving into the Box2D world
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入 Box2D 世界
- en: 'The central point of access in Box2D is the `b2World` object, which stores
    a collection of physical bodies to simulate. A Box2D body is composed of the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 的核心接入点是 `b2World` 对象，它存储了一系列物理体以进行模拟。Box2D 的物体由以下部分组成：
- en: '`b2BodyDef`: This defines the body type (`b2_staticBody, b2_dynamicBody`, and
    so on) and initial properties, such as its position, angle (in radians), and so
    on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2BodyDef`：这定义了物体类型（`b2_staticBody, b2_dynamicBody` 等）和初始属性，如位置、角度（以弧度为单位）等。'
- en: '`b2Shape`: This is used for collision detection and to derive body mass from
    its density. It can be a `b2PolygonShape`, `b2CircleShape`, and so on.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2Shape`：这用于碰撞检测，并根据其密度导出物体质量。它可以是 `b2PolygonShape`、`b2CircleShape` 等等。'
- en: '`b2FixtureDef`: This links together a body shape, a body definition, and its
    physical properties, such as density.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2FixtureDef`：这把物体形状、物体定义及其物理属性（如密度）联系在一起。'
- en: '`b2Body`: This is a body instance in the world (that is, one per game object).
    It is created from a body definition, a shape, and a fixture.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2Body`：这是世界中的一个物体实例（即每个游戏对象一个）。它由一个物体定义、一个形状和一个夹具创建。'
- en: 'Bodies are characterized by a few physical properties, which are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 物体具有以下几个物理特性：
- en: '**Shape**: This represents a circle in DroidBlaster, although a polygon or
    box could also be used.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：这代表 DroidBlaster 中的一个圆形，尽管也可以使用多边形或盒子。'
- en: '**Density**: This is expressed in kg/m2 to compute body mass depending on its
    shape and size. Value should be greater or equal to `0.0`. A bowling ball has
    a bigger density than a soccer ball.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：这用 kg/m² 表示，根据物体的形状和大小计算其质量。值应大于或等于 `0.0`。保龄球的密度大于足球。'
- en: '**Friction**: This indicates how much a body slides on another (for example,
    a car on a road or on an icy path). Values are typically in the range `0.0` to
    `1.0`, where `0.0` implies no friction and `1.0` implies strong friction.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦力**：这表示一个物体在另一个物体上滑动的程度（例如，汽车在道路上或结冰的路面上）。值通常在 `0.0` 到 `1.0` 范围内，其中 `0.0`
    表示没有摩擦力，`1.0` 表示摩擦力很大。'
- en: '**Restitution**: This indicates how much a body reacts to a collision, for
    example, a bouncing ball. Value `0.0` means no restitution and `1.0` means full
    restitution.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复系数**：这表示一个物体在碰撞中的反应程度，例如弹跳的球。值 `0.0` 表示没有恢复，`1.0` 表示完全恢复。'
- en: 'When running, bodies are subject to the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，物体受到以下影响：
- en: '**Forces**: This makes bodies move linearly.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力**：这使物体线性移动。'
- en: '**Torques**: This represents rotational force applied on a body.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扭矩**：这代表施加在物体上的旋转力。'
- en: '**Damping**: This is similar to friction, although it does not only occur when
    a body is in contact with another. Consider it as the effect of drag slowing down
    a body.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼**：这类似于摩擦力，尽管它不仅仅发生在物体与其他物体接触时。将它视为阻力减缓物体速度的效果。'
- en: Box2D is tuned for worlds containing objects at a scale from `0.1` to `10` (unit
    in meters). When used outside this range, again, numerical approximation can make
    simulation inaccurate. Thus, it is very necessary to scale coordinates from the
    Box2D referential, where objects should to be kept in the (rough) range [`0.1`,
    `10`], and to the game, or directly to the graphics referential. This is why we
    have defined `SCALE_FACTOR` to scale coordinate transformation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 调整用于包含从 `0.1` 到 `10`（以米为单位）规模对象的世界。当超出这个范围使用时，数值近似可能导致模拟不准确。因此，非常有必要将坐标从
    Box2D 参考系缩放到游戏，或直接到图形参考系，其中物体应在（大致）范围 [`0.1`, `10`] 内。这就是我们定义 `SCALE_FACTOR` 来缩放坐标转换的原因。
- en: More on collision detection
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于碰撞检测的更多内容
- en: Several ways of detecting and handling collisions exist in Box2D. The most basic
    one consists of checking all contacts stored in the world or in a body after they
    are updated. However, this can result in missed contacts that happen surreptitiously
    during Box2D internal iterations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Box2D 中存在多种检测和处理碰撞的方法。最基本的一种是在世界或物体更新后检查存储的所有接触。然而，这可能导致在 Box2D 内部迭代期间意外发生的接触被遗漏。
- en: 'A better way we have seen to detect contacts is the `b2ContactListener`, which
    can be registered on the world object. The following four callbacks can be overridden:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的一种更好的检测接触的方法是 `b2ContactListener`，它可以注册到世界对象上。以下四个回调可以被重写：
- en: '`BeginContact (b2Contact)`: This detects when two bodies enter in collision.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginContact (b2Contact)`：这检测两个物体开始碰撞的时刻。'
- en: '`EndContact(b2Contact)`: This is a counterpart of `BeginContact()`, which indicates
    when bodies are not in collision any more. A call to `BeginContact()` is always
    followed by a matching `EndContact()`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EndContact(b2Contact)`: 这是 `BeginContact()` 的对应部分，表示物体不再发生碰撞。对 `BeginContact()`
    的调用总是紧跟着一个匹配的 `EndContact()`。'
- en: '`PreSolve (b2Contact, b2Manifold)`: This is called after a collision is detected
    but before collision resolution, that is, before impulse resulting from the collision
    is computed. The `b2Manifold` structure holds information about contact points,
    normals, and so on in a single place.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreSolve (b2Contact, b2Manifold)`: 在检测到碰撞但还未进行碰撞解决时调用，即计算碰撞产生的冲量之前。`b2Manifold`
    结构在单个位置保存有关接触点、法线等信息。'
- en: '`PostSolve(b2Contact, b2ContactImpulse)`: This is called after actual impulse
    (that is, physical reaction) has been computed by Box2D.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSolve(b2Contact, b2ContactImpulse)`: 在Box2D计算出实际的冲量（即物理反应）之后调用。'
- en: The first two callbacks are interesting to trigger game logic (for example,
    entity destruction). The last two are interesting to alter physics simulation
    (more specifically to ignore some collisions by *disabling* a contact) while it
    is being computed, or to get more accurate details about it. For instance, use
    `PreSolve()` to create a one-sided platform to which an entity collides only when
    it falls from above (not when it jumps from below). Use `PostSolve()` to detect
    collision strength and calculate damages accordingly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个回调对于触发游戏逻辑很有用（例如，销毁实体）。最后两个回调对于在计算过程中改变物理模拟很有用（更具体地，通过*禁用*接触来忽略某些碰撞），或者获取更准确的详细信息。例如，使用
    `PreSolve()` 创建一个单向平台，只有当实体从上方掉落时才会与之碰撞（而不是从下方跳起时）。使用 `PostSolve()` 来检测碰撞强度并相应地计算伤害。
- en: The `PreSolve()` and `PostSolve()` methods can be called several times between
    `BeginContact()` and `EndContact()`, which can be called themselves from zero
    to several times during one world update. A contact can begin during one simulation
    step and terminate after several steps. In that case, event-solving callbacks
    occur continuously during "in-between" steps. As many collisions can occur while
    stepping simulation. Thus, callbacks can be called a lot of times and should be
    as efficient as possible.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreSolve()` 和 `PostSolve()` 方法可以在 `BeginContact()` 和 `EndContact()` 之间被多次调用，而这些方法本身在一个世界更新期间可以被调用零次到多次。一个接触可以在一个模拟步骤中开始，并在几个步骤后结束。在这种情况下，事件解决回调会在“中间”步骤中连续发生。因为模拟步骤中可能会发生很多碰撞。因此，回调可能会被多次调用，应该尽可能高效。'
- en: When analyzing collisions inside the `BeginContact()` callback, we buffered
    a collision flag. This is necessary because Box2D reuses the `b2Contact` parameter
    passed when a callback is triggered. In addition, as these callbacks are called
    while simulation is computed, physics bodies cannot be destroyed at that instant,
    only after simulation stepping is over. Thus, it is highly advised to copy any
    information gathered there for `postprocessing` (for example, to destroy entities).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `BeginContact()` 回调中分析碰撞时，我们缓冲了一个碰撞标志。这是必要的，因为Box2D在触发回调时重用传递的 `b2Contact`
    参数。此外，由于这些回调是在计算模拟时调用的，物理物体不能立即销毁，只能在模拟步骤结束后销毁。因此，强烈建议复制那里的任何信息以进行`后处理`（例如，销毁实体）。
- en: Collision modes and filtering
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞模式与过滤
- en: 'I would like to point out that Box2D offers a so-called `bullet` mode that
    can be activated on a body definition using corresponding Boolean member:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，Box2D提供了一个所谓的`bullet`模式，可以通过相应的布尔成员在物体定义上激活：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The bullet mode is necessary for fast moving objects like bullets! By default,
    Box2D uses **Discrete Collision Detection**, which considers bodies at their final
    position for collision detection, missing any body located between initial and
    final positions. However, for a fast moving body, the whole path followed should
    be considered. This is more formally called **Continuous Collision Detection**
    (**CCD**). Obviously, CCD is expensive and should be used with parsimony. Please
    refer to the following figure:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像子弹这样快速移动的对象，子弹模式是必要的！默认情况下，Box2D 使用**离散碰撞检测**，它只考虑最终位置上的物体进行碰撞检测，会漏掉位于初始位置和最终位置之间的任何物体。然而，对于一个快速移动的物体，应该考虑整个路径。这更正式地称为**连续碰撞检测**（**CCD**）。显然，CCD是代价高昂的，应当谨慎使用。请参考以下图表：
- en: '![Collision modes and filtering](img/9645_09_02.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞模式与过滤](img/9645_09_02.jpg)'
- en: 'We sometimes want to detect when bodies overlap without generating collisions
    (like a car reaching the finish line): this is called a sensor. A sensor can be
    easily set by setting the `isSensor` Boolean member to `true` in the fixture as
    follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望检测到物体重叠而不产生碰撞（比如一辆车到达终点线）：这称为传感器。通过以下方式在夹具中将`isSensor`布尔成员设置为`true`可以轻松设置传感器：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A sensor can be queried with a listener through `BeginContact()` and `EndContact()`
    or by using the `IsTouching()` shortcut on a `b2Contact` class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过监听器通过`BeginContact()`和`EndContact()`查询传感器，或者通过在`b2Contact`类上使用`IsTouching()`快捷方式。
- en: Another important aspect of collision is not colliding or, more precisely, filtering
    collisions. A kind of filtering can be performed in `PreSolve()` by disabling
    contacts. This is the most flexible and powerful solution, but also the most complex.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞的另一个重要方面是不发生碰撞，或者更准确地说，过滤碰撞。在`PreSolve()`中可以通过禁用接触来执行一种过滤。这是最灵活和强大的解决方案，但也是最复杂的。
- en: 'But, as we have seen it, filtering can be performed in a more simple way by
    using a categories and masks technique. Each body is assigned one or more category
    (each being represented by one bit in a short integer, the `categoryBits` member)
    and a mask describing categories of the body they can collide with (each filtered
    category being represented by a bit set to 0, the `maskBits` member), as shown
    in the following figure:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们所看到的，可以通过使用类别和掩码技术以更简单的方式进行过滤。每个物体分配一个或多个类别（每个类别在短整数中由一个位表示，即`categoryBits`成员）和一个描述它们可以与之碰撞的物体类别的掩码（每个被过滤的类别由设置为0的位表示，即`maskBits`成员），如下图所示：
- en: '![Collision modes and filtering](img/9645_09_04.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞模式和过滤](img/9645_09_04.jpg)'
- en: In the preceding figure, `Body A` is in categories `1` and `3`, and collides
    with bodies in categories `2` and `4`, which is the case for this poor `Body B`,
    unless its mask filters collision with `Body A` categories (that is, `1` and `3`).
    In other words, both bodies A and B must agree to collide!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，`Body A`属于类别`1`和`3`，并与类别`2`和`4`的物体发生碰撞，这对于这个可怜的`Body B`来说也是如此，除非它的掩码过滤掉了与`Body
    A`类别（即`1`和`3`）的碰撞。换句话说，两个物体A和B必须都同意发生碰撞！
- en: 'Box2D also has a notion of collision groups. A body has a collision group set
    to any of the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D也有碰撞组的概念。一个物体的碰撞组可以是以下任意一个：
- en: '**Positive integer**: This means others bodies with the same collision group
    value can collide'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正整数**：这意味着具有相同碰撞组值的其它物体可以发生碰撞'
- en: '**Negative integer**: This means others bodies with the same collision group
    value are filtered'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负整数**：这意味着具有相同碰撞组值的其它物体将被过滤'
- en: Using collision groups could have also been a solution to avoid collision between
    asteroids in DroidBlaster, although it is less flexible than categories and masks.
    Note that groups are filtered before categories.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用碰撞组也可以作为DroidBlaster中避免小行星之间碰撞的解决方案，尽管它不如类别和掩码灵活。注意，组别在类别之前被过滤。
- en: A more flexible solution than category and group filters is the `b2ContactFilter`
    class. This class has a `ShouldCollide(b2Fixture, b2Fixture)` method that you
    can customize to perform your own filtering. Actually, category/group filtering
    are themselves implemented that way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 比 category 和 group 过滤器更灵活的解决方案是`b2ContactFilter`类。这个类有一个`ShouldCollide(b2Fixture,
    b2Fixture)`方法，你可以自定义它以执行你自己的过滤。实际上，category/group 过滤器本身就是以这种方式实现的。
- en: Going further with Box2D
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步了解Box2D
- en: 'This short introduction to Box2D gives you only an overview of what Box2D is
    capable of! The following non-exhaustive list has been left in the shadow:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于Box2D的简短介绍仅让你了解了Box2D的能力！以下非详尽列表被留在了阴影中：
- en: Joints to link two bodies together
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于连接两个物体的关节
- en: '**Raycasting** to query a physics world (for example, which location is a gun
    pointing toward)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**光线投射**来查询物理世界（例如，枪指向哪个位置）
- en: 'Contact properties: normals, impulses, manifolds, and so on'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接触属性：法线、冲量、流形等
- en: Tip
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Box2D has now a little brother called **LiquidFun**, which is used to simulate
    fluids. You can download and see it in action at [http://google.github.io/liquidfun/](http://google.github.io/liquidfun/).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D现在有一个小兄弟叫做**LiquidFun**，用于模拟流体。你可以下载并在[http://google.github.io/liquidfun/](http://google.github.io/liquidfun/)查看它的效果。
- en: Box2D has a really nice documentation with useful information that can be found
    at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html). Moreover,
    Box2D is packaged with a test bed directory (in `Box2D/Testbed/Tests`) featuring
    many use cases. Have a look at them to get a better understanding of its capabilities.
    Because physics simulations can sometimes be rather tricky, I also encourage you
    to visit Box2D forum, which is quite active, at [http://www.box2d.org/forum/](http://www.box2d.org/forum/).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 有一个非常棒的文档，其中包含有用的信息，可以在 [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)
    找到。此外，Box2D 带有一个测试床目录（在 `Box2D/Testbed/Tests` 中），其中包含许多用例。查看它们以更好地了解其功能。由于物理模拟有时可能相当棘手，我还建议您访问相当活跃的
    Box2D 论坛，地址是 [http://www.box2d.org/forum/](http://www.box2d.org/forum/)。
- en: Prebuilding Boost on Android
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 上预编译 Boost
- en: If STL is the most common framework among C++ programs, Boost probably comes
    second. A real Swiss army knife! This toolkit contains a profusion of utilities
    to handle most common needs, and even more.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说 STL 是 C++ 程序中最常见的框架，那么 Boost 可能就是第二位。它就像一把瑞士军刀！这个工具箱包含大量用于处理最常见需求的实用工具，甚至更多。
- en: 'Most Boost features are provided as header-only code, which means that we do
    not need to compile it. Including headers is enough of an advantage to use it.
    This is the case of the most popular features of Boost: **Smart Pointers**, a
    reference-counting pointer class that handles memory allocation and de-allocation
    automatically. They avoid most memory leaks and pointer misuse for almost free.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Boost 功能以头文件形式提供，这意味着我们无需编译它。包含头文件就足以使用它的优势。最流行的 Boost 功能就是这种情况：**智能指针**，这是一个引用计数的指针类，可以自动处理内存分配和释放。它们几乎免费地避免了大多数内存泄漏和指针误用。
- en: However, a few parts of Boost require compilation first, such as the threading
    or the unit test library. We are now going to see how to build them with the Android
    NDK and compile a unit test executable.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Boost 的某些部分需要先编译，比如线程或单元测试库。我们现在将了解如何使用 Android NDK 构建它们并编译一个单元测试可执行文件。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Resulting project is provided with this book under the name `DroidBlaster_Part18`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了名为 `DroidBlaster_Part18` 的项目结果。
- en: Time for action – prebuilding Boost static library
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 预编译 Boost 静态库
- en: 'Let''s prebuild Boost for Android as a static library with the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤将 Boost 作为静态库预编译到 Android 上：
- en: Download Boost from [http://www.boost.org/](http://www.boost.org/) (Version
    1.55.0, in this book). Unzip the archive into `${ANDROID_NDK}/sources`. Name the
    directory `boost`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://www.boost.org/](http://www.boost.org/) 下载 Boost（本书中使用的是 1.55.0 版本）。将归档文件解压到
    `${ANDROID_NDK}/sources` 目录下，并将目录命名为 `boost`。
- en: Open a command line window and go to the `boost` directory. Launch `bootstrap.bat`
    on Windows or .`/bootstrap.sh` on Linux and Mac OS X to build **b2**. This program,
    previously named **BJam**, is a custom building tool similar to **Make**.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开命令行窗口，进入 `boost` 目录。在 Windows 上运行 `bootstrap.bat` 或在 Linux 和 Mac OS X 上运行
    `./bootstrap.sh` 来构建 **b2**。这个程序，之前名为 **BJam**，是一种类似于 **Make** 的自定义构建工具。
- en: Note
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Boost 1.55.0 archive is provided with this book in the `Libraries/boost` directory.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中提供了 Boost 1.55.0 归档文件，位于 `Libraries/boost` 目录。
- en: 'Change the NDK build command in DroidBlaster to generate verbose compilation
    logs. To do so, in Eclipse **Project properties**, navigate to the **C/C++ Build**
    section. There, you should see the following build command: `ndk-build NDK_DEBUG=1`.
    Change it to `build NDK_DEBUG=0 V=1` to compile in release mode with verbose logs.'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改 DroidBlaster 中的 NDK 构建命令，以生成详细的编译日志。为此，在 Eclipse 的 **项目属性** 中，导航到 **C/C++
    Build** 部分。在那里，您应该看到以下构建命令：`ndk-build NDK_DEBUG=1`。将其更改为 `build NDK_DEBUG=0 V=1`
    以在发布模式下编译并生成详细日志。
- en: Rebuild DroidBlaster (you might need to clean your project first). If you look,
    for example, at the following compilation extract, you should see some logs similar
    to the extract below. This log, although barely readable, gives all the information
    about the commands run to build DroidBlaster.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建 DroidBlaster（您可能需要先清理项目）。例如，如果您查看下面的编译摘录，您应该会看到一些与下面摘录相似的日志。这个日志虽然几乎难以阅读，但它提供了构建
    DroidBlaster 运行的所有命令的信息。
- en: The toolchain used to build DroidBlaster (`arm-linux-androideabi-4.6`)
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建 DroidBlaster 的工具链（`arm-linux-androideabi-4.6`）
- en: The system on which DroidBlaster is built (`linux-x86_64`)
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DroidBlaster 所构建的系统（`linux-x86_64`）
- en: The compiler executable (`arm-linux-androideabi-g++`)
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可执行文件（`arm-linux-androideabi-g++`）
- en: The archiver executable (`arm-linux-androideabi-ar`)
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档器可执行文件（`arm-linux-androideabi-ar`）
- en: Also all the compilation flags passed to them (here for ARM processors)
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还包括传递给它们的所有编译标志（这里针对ARM处理器）
- en: 'We can use the following as an inspiration source to determine `Boost` compilation
    flags (in this flag soup!):'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将以下内容作为确定`Boost`编译标志（在这锅标志汤中！）的灵感来源：
- en: '[PRE49]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `boost` directory, open the `tools/build/v2/user-config.jam` file. This
    file, like its name suggests, is a configuration file that can be set up to customize
    `Boost` compilation. Initial content contains only comments and can be erased.
    Start including the following content:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`boost`目录中，打开`tools/build/v2/user-config.jam`文件。这个文件，如它的名字所示，是一个配置文件，可以设置以定制`Boost`编译。初始内容只包含注释，可以删除。开始包含以下内容：
- en: '[PRE50]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Compilation is performed statically. **BZip** is deactivated because it is
    unavailable, by default, on Android (we could however compile it separately):'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译是静态执行的。默认情况下，**BZip**在Android上不可用，因此被禁用（不过我们可以单独编译它）：
- en: '[PRE51]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Retrieve the `android_ndk` environment variable which points to the NDK location
    on disk.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指向NDK在磁盘上位置的`android_ndk`环境变量。
- en: Declare what we could call a "configuration" `android4.6_armeabi`.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明我们可以称之为“配置”的`android4.6_armeabi`。
- en: Then, reconfigure Boost to use the NDK ARM GCC toolchain (`g++`, `ar`, and `ranlib`)
    in static mode, the archiver being in charge of creating the static library. We
    can use the information found in the log in step 2 to fill their respective paths.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，重新配置Boost以在静态模式下使用NDK ARM GCC工具链（`g++`，`ar`和`ranlib`），归档器负责创建静态库。我们可以使用第2步日志中找到的信息来填充它们各自的路徑。
- en: 'The `sysroot` directive indicates which Android API release to compile and
    link against. The specified directory, located in the NDK, contains `include`
    files and libraries specific to this release, as shown in the following code:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sysroot`指令指示编译和链接针对哪个Android API版本。在NDK中指定的目录包含特定于此版本的`include`文件和库，如下代码所示：'
- en: '[PRE52]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Boost needs exceptions and RTTI. Enable them with the `–fexceptions` and `–frtti`
    flags, as shown in the following code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost需要异常和RTTI。使用`–fexceptions`和`–frtti`标志启用它们，如下代码所示：
- en: '[PRE53]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A few options have to be defined to tweak `Boost` compilation. This is where
    we can take inspiration from the compilation flags discovered in step 2, such
    as the following:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要定义几个选项来调整`Boost`的编译。这里我们可以借鉴第2步中发现的编译标志，例如：
- en: '`-march=armv5te` to specify the target platform'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-march=armv5te`以指定目标平台'
- en: '`-mthumb`, which indicates that generated code should use thumb instructions
    (`-marm` could also be used to use ARM instructions instead)'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mthumb`，表示生成的代码应使用thumb指令（也可以使用`-marm`来使用ARM指令））'
- en: '`-0s` to enable compiler optimizations'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-0s`以启用编译器优化'
- en: '`-DNDEBUG` to request compilation in release mode'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DNDEBUG`以请求以发布模式编译'
- en: 'Also include or tweak additional ones, such as the following:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还包括或调整其他附加标志，例如：
- en: -`D__arm__`, `-D__ARM_ARCH_5__`, and so on, which help to determine the target
    platform from code
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D__arm__`，`-D__ARM_ARCH_5__`等，有助于从代码中确定目标平台'
- en: '`-DANDROID`, `-D__ANDROID__`, which help to determine the target OS'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DANDROID`，`-D__ANDROID__`有助于确定目标操作系统'
- en: '`-DBOOST_ASIO_DISABLE_STD_ATOMIC` to disable the use `std::atomic`, which is
    buggy on Android (something that can be learnt only through (bad) "experience"…).'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-DBOOST_ASIO_DISABLE_STD_ATOMIC`以禁用`std::atomic`的使用，它在Android上是错误的（这是只能通过（不好）的“经验”学到的…）。'
- en: '[PRE54]'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: From a terminal pointing located in the boost directory, launch the compilation
    using the following command line. We need to exclude the **Python** module, which
    requires additional libraries not available on the NDK by default.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指向boost目录的终端，使用以下命令行启动编译。我们需要排除**Python**模块，因为它需要默认在NDK上不可用的附加库。
- en: '[PRE55]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Final static libraries are generated in `android-armeabi/lib/`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的静态库生成在`android-armeabi/lib/`目录中。
- en: Repeat the same steps for the ArmV7 and X86 platforms, creating a new configuration
    for each of them. The staging directory must be `armeabi-v7a` for ArmV7 and `android-x86`
    for X86.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对ArmV7和X86平台重复相同的步骤，为每个平台创建一个新的配置。对于ArmV7，暂存目录必须是`armeabi-v7a`，对于X86，必须是`android-x86`。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`user-config.jam`随本书一起提供，位于`Libraries/boost`目录中。
- en: '*What just happened?*'
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have customized the Boost configuration to use the raw Android GCC toolchain
    as a standalone compiler (that is, without the NDK wrappers). We have declared
    various flags to adapt compilation to Android target platforms. Then, we have
    built Boost manually using its dedicated building tool `b2`. Now, every time Boost
    is updated or modified, code has to be manually compiled again with `b2`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定制了Boost配置，使用原始的Android GCC工具链作为独立的编译器（即，不使用NDK包装器）。我们声明了各种标志以适应Android目标平台的编译。然后，我们使用其专用的构建工具`b2`手动构建Boost。现在，每次更新或修改Boost，代码都需要使用`b2`重新手动编译。
- en: We have also forced NDK-Build to generate verbose logs with the `V=1` argument.
    This is helpful to either troubleshoot compilation issues or to get feedback on
    what and how NDK-Build is compiling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`V=1`参数强制NDK-Build生成详细的日志。这对于排除编译问题或了解NDK-Build编译的内容和方式非常有帮助。
- en: 'Finally, we have enabled release compilation mode, that is, with code optimizations,
    by switching `NDK_DEBUG` to `0`. This could have also been done by setting `APP_OPTIM
    := release` in `jni/Application.mk`. There are five main optimization levels in
    GCC, and they are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将`NDK_DEBUG`设置为`0`来启用发布编译模式，即进行代码优化。也可以通过在`jni/Application.mk`中设置`APP_OPTIM
    := release`来实现。GCC中有五个主要的优化级别，它们如下所示：
- en: '**-O0**: This disables any optimization. This is automatically set by the NDK
    when `APP_OPTIM` is set to `debug` (more about this in the last part about Makefiles
    in this chapter).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-O0**：这禁用任何优化。当`APP_OPTIM`设置为`debug`时，NDK会自动设置此选项（关于这一点，在本章关于Makefiles的最后一部分会有更多介绍）。'
- en: '**-O1**: This allows basic optimizations without increasing compilation time
    too much. These optimizations do not require any speed-space tradeoffs, which
    mean that they produce faster code without increasing executable size.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-O1**：这允许进行基本优化，而不会过多增加编译时间。这些优化不需要任何速度和空间的权衡，这意味着它们可以产生更快的代码，而不会增加可执行文件的大小。'
- en: '**-O2**: This allows advanced optimization (including `-O1`), but at the expense
    of compilation time. Like `–O1`, these optimizations do not require speed-space
    tradeoffs.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-O2**：这允许进行高级优化（包括`-O1`），但会增加编译时间。与`–O1`一样，这些优化不需要速度和空间的权衡。'
- en: '**-O3**: This performs aggressive optimizations (including `-O2`), which can
    increase executable size, such as **function inlining**. This is generally profitable
    but, sometimes, counterproductive (for example, increasing memory usage can also
    increase cache misses).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-O3**：这执行积极的优化（包括`-O2`），可能会增加可执行文件的大小，例如**函数内联**。这通常是有益的，但有时可能会适得其反（例如，增加内存使用也可能增加缓存未命中）。'
- en: '**-Os**: This optimizes compiled code size (a subset of `–O2`) before speed.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Os**：这优先优化编译代码的大小（`–O2`的子集），其次才是速度。'
- en: Although `-Os` or `–O2` is generally the way to go for release mode, `-O3` can
    also be considered for performance-critical code. The `-0x` flags being shortcuts
    for the various GCC optimization flags, enabling `–O2` and appending additional
    "fine-grain" flags (for example, `-finline-functions`), are an option too. Whatever
    option you choose, the best way to find the best choice is simply by performing
    benchmarking! To get more information about the numerous GCC optimization options,
    have a look at [http://gcc.gnu.org/](http://gcc.gnu.org/).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在发布模式下通常使用`-Os`或`–O2`，但对于性能关键代码也可以考虑使用`-O3`。`-0x`标志是各种GCC优化标志的快捷方式，启用`–O2`并附加额外的“细粒度”标志（例如，`-finline-functions`）也是一个选项。无论您选择哪种选项，找到最佳选择的最简单方法就是进行基准测试！要获取有关众多GCC优化选项的更多信息，请查看[http://gcc.gnu.org/](http://gcc.gnu.org/)。
- en: Now that the Boost module is prebuilt, we can embed any of its libraries in
    our application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Boost模块已经预建好了，我们可以将它的任何库嵌入到我们的应用程序中。
- en: Time for action – compiling an executable linked to Boost
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间——编译与Boost链接的可执行文件
- en: 'Let''s use the Boost unit test library to build our own unit test executable
    through the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤使用Boost单元测试库来构建我们自己的单元测试可执行文件：
- en: 'Still in the `boost` directory, create a new `Android.mk` file to declare the
    newly prebuilt libraries as Android modules and make them available to NDK applications.
    This file needs to contain one module declaration per library. For example, define
    one module `boost_unit_test_framework`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`boost`目录下，创建一个新的`Android.mk`文件，将新预建的库声明为Android模块，以便NDK应用程序可以使用。这个文件需要为每个库包含一个模块声明。例如，定义一个名为`boost_unit_test_framework`的模块：
- en: '`LOCAL_SRC_FILES` reference the static library `libboost_unit_test_framework.a`
    we have built with b2.'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SRC_FILES`引用了我们使用b2构建的静态库`libboost_unit_test_framework.a`。'
- en: Use the `$(TARGET_ARCH_ABI)` variable to determine the right path to use, which
    depends on the target platform. Its value can be `armeabi`, `armeabi-v7a`, or
    `x86`. If you compile DroidBlaster for X86, the NDK will look for `libboost_unit_test_framework.a`
    in `androidx86/lib`.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `$(TARGET_ARCH_ABI)` 变量来确定正确的路径，这取决于目标平台。它的值可以是 `armeabi`、`armeabi-v7a` 或
    `x86`。如果你为 X86 编译 DroidBlaster，NDK 将在 `androidx86/lib` 中查找 `libboost_unit_test_framework.a`。
- en: '`LOCAL_EXPORT_C_INCLUDES` automatically appends boost root directory to the
    include file directory list of the including module.'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_EXPORT_C_INCLUDES` 会自动将 Boost 根目录添加到包含模块的包含文件目录列表中。'
- en: 'Indicate that this module is a prebuilt library with the `$(PREBUILT_STATIC_LIBRARY)`
    directive:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指明这个模块是一个预构建的库，使用 `$(PREBUILT_STATIC_LIBRARY)` 指令：
- en: '[PRE56]'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: More modules can be declared in the same file with the same set of lines (for
    example, `boost_thread`).
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以在同一个文件中声明更多的模块，使用相同的行集（例如，`boost_thread`）。
- en: Note
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中提供的最终 `user-config.jam` 文件位于 `Libraries/boost` 目录中。
- en: 'Go back to the `DroidBlaster` project and create a new directory `test` containing
    the unit test file `test/Test.cpp`. Write a test to check the behavior, for example,
    of the `TimeManager`, as shown in the following code:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `DroidBlaster` 项目，并创建一个名为 `test` 的新目录，其中包含单元测试文件 `test/Test.cpp`。编写一个测试来检查例如
    `TimeManager` 的行为，如下代码所示：
- en: '[PRE57]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To include Boost in an application, we need to link it with an STL implementation
    supporting exceptions and RTTI. Enable them globally in the `Application.mk` file,
    as shown in the following code:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在应用程序中包含 Boost，我们需要将它与支持异常和 RTTI 的 STL 实现链接起来。在 `Application.mk` 文件中全局启用它们，如下代码所示：
- en: '[PRE58]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, open DroidBlaster `jni/Android.mk` and create a second module named
    `DroidBlaster_test` before the `import-module` section. This module compiles the
    additional `test/Test.cpp` test file and must be linked to the Boost unit test
    library. Build this module as an executable, and not a shared library, with `$(BUILD_EXECUTABLE)`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 DroidBlaster 的 `jni/Android.mk` 文件，在 `import-module` 部分之前创建一个名为 `DroidBlaster_test`
    的第二个模块。这个模块编译额外的 `test/Test.cpp` 测试文件，并且必须链接到 Boost 单元测试库。将此模块构建为可执行文件，而不是共享库，使用
    `$(BUILD_EXECUTABLE)`。
- en: 'Finally, import the `Boost` module itself in the import-module section, as
    shown in the following code:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在 `import-module` 部分导入 `Boost` 模块本身，如下代码所示：
- en: '[PRE59]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Build the project. If you look into the `libs` folder, you should see one `droidblaster_test`
    file in addition to the shared library. This is an executable file that we can
    run on an emulator or a rooted device (given you have the right to deploy and
    change permission on a file). Deploy this file and run it (here on an Arm V7 emulator
    instance):'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。如果你查看 `libs` 文件夹，除了共享库之外，你应该能看到一个 `droidblaster_test` 文件。这是一个可执行文件，我们可以在模拟器或已获得权限的设备上运行（假设你有部署和更改文件权限的权利）。部署这个文件并运行它（这里在一个
    Arm V7 模拟器实例上）：
- en: '[PRE60]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![Time for action – compiling an executable linked to Boost](img/9645_09_01.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 编译一个链接到 Boost 的可执行文件](img/9645_09_01.jpg)'
- en: '*What just happened?*'
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have created a fully native executable using a Boost prebuilt module and
    can run it on Android. Boost prebuilt static libraries have been "published" from
    the Boost `Android.mk` module file in the `Boost` directory.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Boost 预构建模块创建了一个完全本地的可执行文件，并且可以在 Android 上运行它。Boost 预构建静态库已经从 `Boost`
    目录中的 Boost `Android.mk` 模块文件“发布”。
- en: 'Indeed, there exist four main ways to build a native library. We have already
    seen `BUILD_STATIC_LIBRARY` and `BUILD_SHARED_LIBRARY` in the Box2D part. Two
    more options coexist, which are as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，构建本地库有四种主要方法。我们在 Box2D 部分已经看到了 `BUILD_STATIC_LIBRARY` 和 `BUILD_SHARED_LIBRARY`。还有两个共存的选择，如下所示：
- en: '`PREBUILT_STATIC_LIBRARY` to use an existing (that is, prebuilt) binary static
    library'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_STATIC_LIBRARY` 用于使用现有的（即预构建的）二进制静态库。'
- en: '`PREBUILT_SHARED_LIBRARY` to use an existing binary shared library'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUILT_SHARED_LIBRARY` 用于使用现有的二进制共享库'
- en: These directives indicate that libraries are ready for linking.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令表明库已经准备好进行链接。
- en: 'Inside the main module file, as we have seen for Box2D, submodules linked need
    to be listed in:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在主模块文件内部，正如我们在 Box2D 中看到的，需要列出链接的子模块：
- en: '`LOCAL_SHARED_LIBRARIES` for shared libraries'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_SHARED_LIBRARIES` 用于共享库'
- en: '`LOCAL_STATIC_LIBRARIES` for static libraries'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_STATIC_LIBRARIES` 用于静态库'
- en: The same rule applies whether the library is prebuilt or not. Modules, whether
    they are static, shared, prebuilt, or built on-demand, must be imported in the
    final main module using the NDK `import-module` directive.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 无论库是否是预构建的，都适用相同的规则。无论是静态的、动态的、预构建的还是按需构建的模块，都必须使用NDK的`import-module`指令在最终的
    main 模块中导入。
- en: When a prebuilt library is linked to a main module, source files are not necessary.
    Include files are obviously still required. Thus, prebuilt libraries are an appropriate
    choice if you want to provide a library to third parties without releasing sources.
    On the other hand, on-demand compilation allows tweaking compilation flags on
    all included libraries (such as optimization flags, the ARM mode, and so on) from
    your main `Application.mk` project file.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个预构建的库被链接到主模块时，源文件并不是必需的。显然，头文件仍然是必需的。因此，如果你想在不对第三方公开源代码的情况下提供一个库，预构建库是一个合适的选择。另一方面，按需编译允许从你的主`Application.mk`项目文件中调整所有包含库的编译标志（如优化标志、ARM模式等）。
- en: To properly link with Boost, we have also enabled exceptions and RTTI on the
    whole project. Exceptions and RTTI are activated very easily by appending `-fexceptions`
    and `-frtti` to either the `APP_CPPFLAGS` directive in the `Application.mk` file
    or the `LOCAL_CPPFLAGS` file of the concerned library. By default, Android compiles
    with `-fno-exceptions` and `-fno-rtti` flags.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确链接Boost，我们还在整个项目中启用了异常和运行时类型信息（RTTI）。通过在`Application.mk`文件中的`APP_CPPFLAGS`指令或者相关库的`LOCAL_CPPFLAGS`文件中添加`-fexceptions`和`-frtti`，可以很容易地激活异常和RTTI。默认情况下，Android编译时带有`-fno-exceptions`和`-fno-rtti`标志。
- en: Indeed, exceptions have the reputation of making the compiled code bigger and
    less efficient. They prevent the compiler from performing some clever optimizations.
    However, whether exceptions are worse than error checking, or even no check at
    all, is a highly debatable question. In fact, Google's engineers dropped them
    in the first releases because GCC 3.x generated a poor exception handling code
    for ARM processors. However, the build chain now uses GCC 4.x, which does not
    suffer from this flaw. Compared to manual error checking and handling of exceptional
    cases, this penalty might not be so significant most of the time. Thus, the choice
    of exceptions is up to you (and your embedded libraries)!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，异常处理会让编译后的代码体积变大且效率降低。它会阻止编译器执行一些巧妙的优化。然而，异常处理是否比错误检查更糟糕，甚至不如完全不检查，这是一个高度有争议的问题。实际上，谷歌的工程师在最初的版本中放弃了异常处理，因为GCC
    3.x为ARM处理器生成的异常处理代码质量不佳。但是现在构建链使用了GCC 4.x，这个缺陷已经不存在了。与手动错误检查和处理异常情况相比，这种开销大多数时候可能并不显著。因此，是否选择异常处理取决于你（以及你使用的嵌入式库）！
- en: Tip
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Exception handling in C++ is not easy and imposes a strict discipline! They
    must be used strictly for exceptional cases and require carefully designed code.
    Have a look at the **Resource Acquisition Is Initialization** (**RAII**) idiom
    to properly handle them. For more information, have a look at [http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的异常处理并不容易，它要求严格的纪律！它们必须严格用于异常情况，并要求精心设计的代码。可以查看**资源获取即初始化**（**RAII**）习惯用法来正确处理它们。更多信息，请查看[http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)。
- en: Obviously, Boost provides much more interesting features than unit tests. Discover
    its full richness in its official documentation at [http://www.boost.org/doc/libs](http://www.boost.org/doc/libs).
    Beware, Boost is subject to regular breaking changes or bugs on Android since
    it is not very actively maintained and tested on that platform. Be prepared to
    investigate and fix problems directly in its code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Boost提供的功能远比单元测试有趣得多。在其官方文档[http://www.boost.org/doc/libs](http://www.boost.org/doc/libs)中探索其全部丰富特性。注意，由于Boost在Android平台上没有得到积极维护和测试，因此它可能会经常出现破坏性更改或错误。
- en: Now that we have seen in practice how to write module Makefiles, let's learn
    more about them.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经实际了解了如何编写模块Makefiles，让我们进一步了解它们。
- en: Mastering module Makefiles
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握模块Makefiles
- en: Android Makefiles are an essential piece of the NDK building process. Thus,
    to build and manage a project properly, it is important to understand the way
    they work.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Android Makefiles是NDK构建过程的重要组成部分。因此，为了正确构建和管理项目，理解它们的工作方式是很重要的。
- en: Makefile variables
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile 变量
- en: 'Compilation settings are defined through a set of predefined NDK variables.
    We have already seen the three most important ones: `LOCAL_PATH, LOCAL_MODULE`,
    and `LOCAL_SRC_FILES`, but many others exist. We can differentiate the following
    four types of variables, each with a different prefix:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 编译设置是通过一组预定义的NDK变量来定义的。我们已经看到了三个最重要的变量：`LOCAL_PATH, LOCAL_MODULE`和`LOCAL_SRC_FILES`，但还有许多其他变量存在。我们可以区分以下四种类型的变量，每种类型的前缀都不同：
- en: '`LOCAL_` variables: These are dedicated to individual module compilation and
    are defined in `Android.mk` files.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL_`变量：这些专门用于单个模块编译，在`Android.mk`文件中定义。'
- en: '`APP_` variables: These refer to application-wide options and are set in `Application.mk`.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APP_`变量：这些指的是应用范围内的选项，在`Application.mk`中设置。'
- en: '`NDK_` variables: These are mainly internal variables that usually refer to
    environment variables (for example, `NDK_ROOT`, `NDK_APP_CFLAGS,` or `NDK_APP_CPPFLAGS`).
    There are two notable exceptions: `NDK_TOOLCHAIN_VERSION` and `NDK_APPLICATION_MK`.
    The latter can be passed to the NDK-Build in parameter to define a different `Application.mk`
    location.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NDK_`变量：这些主要是内部变量，通常指的是环境变量（例如，`NDK_ROOT`, `NDK_APP_CFLAGS`或`NDK_APP_CPPFLAGS`）。有两个值得注意的例外：`NDK_TOOLCHAIN_VERSION`和`NDK_APPLICATION_MK`。后者可以传递给NDK-Build参数，以定义不同的`Application.mk`位置。'
- en: '`PRIVATE_` prefixed variables: These are for NDK internal use only.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`PRIVATE_`前缀的变量：这些仅用于NDK内部使用。
- en: 'The following table contains a non-exhaustive list of `LOCAL` variables:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了一个非详尽的`LOCAL`变量列表：
- en: '| Variable | Description |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCAL_PATH` | To specify the root location of source files. Must be defined
    at the beginning of the `Android.mk` file before `include $(CLEAR_VARS)`. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_PATH` | 用于指定源文件的根位置。必须在`Android.mk`文件中的`include $(CLEAR_VARS)`之前定义。
    |'
- en: '| `LOCAL_MODULE` | To define module name, it must be unique among all modules.
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_MODULE` | 用于定义模块名称，它必须在所有模块中保持唯一。 |'
- en: '| `LOCAL_MODULE_FILENAME` | To override default name of the compiled module,
    which is:`- lib<module name>.so` for shared libraries.`- lib<module name>.a` for
    static libraries.No custom file extensions can be specified so that `.so` or`.a`
    remains appended. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_MODULE_FILENAME` | 用于重写编译模块的默认名称，对于共享库是：`- lib<模块名称>.so`，对于静态库是：`-
    lib<模块名称>.a`。不能指定自定义文件扩展名，因此`.so`或`.a`仍会附加在后面。 |'
- en: '| `LOCAL_SRC_FILES` | To define the list of source files to compile, each separated
    by a space and relative to `LOCAL_PATH`. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_SRC_FILES` | 用于定义要编译的源文件列表，每个文件以空格分隔，相对于`LOCAL_PATH`。 |'
- en: '| `LOCAL_C_INCLUDES` | To specify header file directories for both C and C++
    languages. The directory can be relative to the `${ANDROID_NDK}` directory, but
    unless you need to include a specific NDK file, you are advised to use absolute
    paths (which can be built from Makefile variables such as `$(LOCAL_PATH)`). |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_C_INCLUDES` | 用于指定C和C++语言的头文件目录。该目录可以是相对于`${ANDROID_NDK}`目录的，但除非你需要包含特定的NDK文件，否则建议使用绝对路径（可以从Makefile变量如`$(LOCAL_PATH)`构建）。
    |'
- en: '| `LOCAL_CPP_EXTENSION` | To change default C++ file extension, that is, `.cpp`
    (for example, `.cc` or `.cxx`). A list of file extensions separated by a space,
    can be specified. Extensions are necessary for GCC to determine which file is
    related to which language. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_CPP_EXTENSION` | 用于更改默认的C++文件扩展名，即`.cpp`（例如，`.cc`或`.cxx`）。可以指定以空格分隔的文件扩展名列表。扩展名对于GCC确定哪个文件与哪种语言相关是必要的。
    |'
- en: '| `LOCAL_CFLAGS`, `LOCAL_CPPFLAGS`, `LOCAL_LDLIBS` | To specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_CFLAGS`, `LOCAL_CPPFLAGS`, `LOCAL_LDLIBS` | 用于指定编译和链接的任何选项、标志或宏定义。第一个适用于C和C++，第二个仅适用于C++，最后一个用于链接器。
    |'
- en: '| `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES` | To declare a dependency
    with other modules (not system libraries), shared and static modules, respectively.
    `LOCAL_SHARED_LIBRARIES` manage dependencies whereas `LOCAL_LDLIBS` should be
    used for declaring system libraries. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES` | 分别声明与其他模块（非系统库）的共享和静态模块依赖关系。`LOCAL_SHARED_LIBRARIES`管理依赖关系，而`LOCAL_LDLIBS`应用于声明系统库。
    |'
- en: '| `LOCAL_ARM_MODE`, `LOCAL_ARM_NEON`, `LOCAL_DISABLE_NO_EXECUTE`, `LOCAL_FILTER_ASM`
    | Advanced variables dealing with processors and assembler/binary code generation.
    They are not necessary for most programs. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_ARM_MODE`, `LOCAL_ARM_NEON`, `LOCAL_DISABLE_NO_EXECUTE`, `LOCAL_FILTER_ASM`
    | 处理器和汇编器/二进制代码生成的高级变量。对于大多数程序来说它们不是必需的。 |'
- en: '| `LOCAL_EXPORT_C_INCLUDES`, `LOCAL_EXPORT_CFLAGS`, `LOCAL_EXPORT_CPPFLAGS`,
    `LOCAL_EXPORT_LDLIBS` | To define additional options or flags in import modules
    that should be appended to client module options. For example, if a module A defines`LOCAL_EXPORT_LDLIBS
    := -llog`because it needs an Android logging module. Then, module B, that depends
    on module A, will be automatically linked to `–llog`.`LOCAL_EXPORT_` variables
    are not used when compiling the module that exports them. If required, they also
    need to be specified in their `LOCAL` counterpart. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL_EXPORT_C_INCLUDES`, `LOCAL_EXPORT_CFLAGS`, `LOCAL_EXPORT_CPPFLAGS`,
    `LOCAL_EXPORT_LDLIBS` | 在导入模块中定义额外的选项或标志，这些选项或标志应附加到客户端模块选项中。例如，如果一个模块A定义了`LOCAL_EXPORT_LDLIBS
    := -llog`，因为它需要一个Android日志模块。那么，依赖于模块A的模块B将自动链接到`–llog`。`LOCAL_EXPORT_`变量在编译导出它们的模块时不使用。如果需要，它们还需要在它们的`LOCAL`对应项中指定。
    |'
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/ANDROID-MK.html`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些变量的文档可以在`${ANDROID_NDK}/docs/ANDROID-MK.html`找到。
- en: 'The following table contains a non-exhaustive list of the `APP` variables (all
    are optional):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含了`APP`变量的非详尽列表（所有都是可选的）：
- en: '| Variable | Description |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `APP_PROJECT_PATH` | To specify the root of your application project. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `APP_PROJECT_PATH` | 指定应用程序项目的根目录。 |'
- en: '| `APP_MODULES` | The list of modules to compile with their identifier. Dependent
    modules are also included. This can be used, for example, to force the generation
    of a static library. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `APP_MODULES` | 要编译的模块及其标识符的列表。还包括依赖的模块。例如，可以用来强制生成静态库。 |'
- en: '| `APP_OPTIM` | Set to `release` or `debug` to adapt compilation settings to
    the type of build you want. When not specified explicitly, the NDK determines
    the build type using the debuggable flag in the AndroidManifest. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `APP_OPTIM` | 设置为`release`或`debug`，以使编译设置适应您想要的构建类型。当未明确指定时，NDK使用AndroidManifest中的可调试标志来确定构建类型。
    |'
- en: '| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | To globally specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | 全局指定编译和链接的任何选项、标志或宏定义。第一个适用于C和C++，第二个仅适用于C++，最后一个适用于链接器。
    |'
- en: '| `APP_BUILD_SCRIPT` | To redefine the location of the Android.mk file (by
    default in project''s `jni` directory). |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `APP_BUILD_SCRIPT` | 重新定义Android.mk文件的存放位置（默认在项目的`jni`目录中）。 |'
- en: '| `APP_ABI` | List of ABI (that is, "CPU architectures") supported by the application,
    separated by a space. Currently supported values are `armeabi`, `armeabi-v7a`,
    `x86`, mips, or `all`. Each module is recompiled once per ABI. So, the more ABI
    you support, the more time it will get to build. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `APP_ABI` | 应用程序支持的ABI（即“CPU架构”）列表，以空格分隔。目前支持的值有`armeabi`、`armeabi-v7a`、`x86`、`mips`或`all`。每个模块针对每个ABI重新编译一次。因此，支持的ABI越多，构建所需的时间就越长。
    |'
- en: '| `APP_PLATFORM` | Name of the target Android platform. This information is
    found by default in the `project.properties` file. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `APP_PLATFORM` | 目标Android平台的名称。此信息默认在`project.properties`文件中找到。 |'
- en: '| `APP_STL` | The C++ runtime to use. Possible values are `system`, `gabi++_static`,
    `gabi++_shared`, `stlport_static`, `stlport_shared`, `gnustl_static`, `gnustl_shared`,
    `c++_static`, and `c++_shared`. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `APP_STL` | 要使用的C++运行时。可能的值有`system`、`gabi++_static`、`gabi++_shared`、`stlport_static`、`stlport_shared`、`gnustl_static`、`gnustl_shared`、`c++_static`和`c++_shared`。
    |'
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/APPLICATION-MK.html`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些变量的文档可以在`${ANDROID_NDK}/docs/APPLICATION-MK.html`找到。
- en: Enabling C++ 11 support and the Clang compiler
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用C++ 11支持和Clang编译器
- en: The `NDK_TOOLCHAIN_VERSION` variable can be redefined in the `Application.mk`
    file to explicitly select the compilation toolchain. Possible values for the NDK
    R10 are `4.6` (now deprecated), `4.8`, and `4.9`, which simply correspond to GCC
    versions. Possible version numbers might change in future releases of the NDK.
    To find them, have a look at the `$ANDROID_NDK/toolchains` directory.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`NDK_TOOLCHAIN_VERSION`变量可以在`Application.mk`文件中重新定义，以显式选择编译工具链。对于NDK R10，可能的值有`4.6`（现已弃用）、`4.8`和`4.9`，这些值分别对应于GCC版本。未来NDK版本中可能更改的可能版本号。要找到它们，请查看`$ANDROID_NDK/toolchains`目录。'
- en: 'The Android NDK provides C++ 11 support, starting with the GCC 4.8 toolchain.
    You can enable it by appending the `-std=c++11` compilation flag and activating
    GNU STL (STL Port is not supported and Libc++ only partially supported at the
    time this book was written) to get proper C++11 support. The following is an example
    of `an Android.mk` extract with C++11 activated:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK从GCC 4.8工具链开始提供C++ 11支持。通过添加`-std=c++11`编译标志并激活GNU STL（STL Port在此书编写时不受支持，而Libc++只部分支持），可以获得适当的C++11支持。以下是激活了C++11的`Android.mk`提取示例：
- en: '[PRE61]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Switching to GCC4.8 and C++11 might not feel like a breeze. Indeed, the compiler,
    let's say, is a bit less permissive than before. In case you run into trouble
    when compiling legacy code with this new toolchain, try the `–fpermissive` flag
    (or rewrite your code!).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到GCC4.8和C++11可能不会一帆风顺。实际上，这个编译器，比如说，比之前要严格一些。如果你在使用这个新工具链编译旧代码时遇到麻烦，尝试使用`–fpermissive`标志（或者重写你的代码！）。
- en: Moreover, beware, although C++11 support is quite large, you might still encounter
    a few problems or missing features.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，尽管C++11的支持已经很广泛，但你可能仍然会遇到一些问题或缺失的功能。
- en: To enable Clang, the LLVM-based compiler (famous for being used by Apple), in
    place of GCC, simply set `NDK_TOOLCHAIN_VERSION` to `clang`. You can also specify
    compiler version, such as `clang3.4` or `clang3.5`. Again, possible version numbers
    might change in future releases of the NDK. To find them, have a look at the `$ANDROID_NDK/toolchains`
    directory.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基于LLVM的编译器Clang（因被苹果使用而著名），代替GCC，只需将`NDK_TOOLCHAIN_VERSION`设置为`clang`。你也可以指定编译器版本，比如`clang3.4`或`clang3.5`。同样，可能的版本号可能会在NDK的未来版本中发生变化。要找到它们，请查看`$ANDROID_NDK/toolchains`目录。
- en: Makefile Instructions
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Makefile指令
- en: Makefile is a real language with programming instructions and functions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile是一种真正的语言，包含编程指令和函数。
- en: 'Makefiles can be broken down into several sub-Makefiles, included with the
    `include` instruction. Variable initialization comes in the following two flavors:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Makefiles可以分解为几个子Makefiles，通过`include`指令包含。变量初始化有两种方式：
- en: Simple affectation (`operator :=`), which expands variables at the time they
    are initialized
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单赋值（`operator :=`），在变量初始化时展开变量
- en: Recursive affectation (`operator =`), which re-evaluates the affected expression
    each time it is called
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归赋值（`operator =`），每次调用时重新评估受影响的表达式
- en: 'The following conditional and loop instructions are available: `ifdef/endif`,
    `ifeq/endif`, `ifndef/endif`, `and for…in/do/done`. For example, to display a
    message only when a variable is defined, do:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件判断和循环指令可用：`ifdef/endif`，`ifeq/endif`，`ifndef/endif`，以及`for…in/do/done`。例如，仅当定义了变量时，才显示消息，可以这样做：
- en: '[PRE62]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'More advanced stuff, such as functional `if`, `and`, `or`, and so on, are at
    your disposal, but are rarely used. Makefiles also provide some useful built-in
    functions, which are given in the following table:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的内容，如函数式`if`、`and`、`or`等，可供使用，但很少被使用。Makefiles还提供了一些有用的内置函数，如下表所示：
- en: '| `$(info <message>)` | Allows printing messages to the standard output. This
    is the most essential tool when writing Makefiles! Variables inside information
    messages are allowed. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `$(info <message>)` | 允许将消息打印到标准输出。这是编写Makefiles时最关键的工具！信息消息中允许使用变量。'
- en: '| `$(warning <message>)`, `$(error <message>)` | Allows printing a warning
    or a fatal error that stops compilation. These messages can be parsed by Eclipse.
    |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `$(warning <message>)`，`$(error <message>)` | 允许打印警告或致命错误，停止编译。这些消息可以被Eclipse解析。'
- en: '| `$(foreach <variable>`, `<list>`, `<operation>)` | Performs an operation
    on a list of variables. Each element of the list is expanded in the first argument
    variable, before the operation is applied to it. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `$(foreach <variable>`, `<list>`, `<operation>)` | 对变量列表执行操作。在应用操作之前，列表中的每个元素都会在第一个参数变量中展开。'
- en: '| `$(shell <command>)` | Executes a command outside of Make. This brings all
    the power of Unix Shell into Makefiles but is heavily system-dependent. Avoid
    it if possible. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `$(shell <command>)` | 在Make外部执行命令。这将为Makefiles带来Unix Shell的所有强大功能，但非常依赖于系统。如果可能，避免使用它。'
- en: '| `$(wildcard <pattern>)` | Selects files and directory names according to
    a pattern. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `$(wildcard <pattern>)` | 根据模式选择文件和目录名称。'
- en: '| `$(call <function>)` | Allows evaluating a function or macro. One macro we
    have seen is `my-dir`, which returns the directory path of the last executed Makefile.
    This is why `LOCAL_PATH := $(call my-dir)` is systematically written at the beginning
    of each `Android.mk` file to save in the current Makefile directory. |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `$(call <function>)` | 允许评估一个函数或宏。我们见过的宏之一是 `my-dir`，它返回最后一个执行的 Makefile
    的目录路径。这就是为什么每个 `Android.mk` 文件的开头都会写上 `LOCAL_PATH := $(call my-dir)`，以保存当前 Makefile
    目录。 |'
- en: 'Custom functions can easily be written with the `call` directive. These functions
    look somewhat similar to recursively affected variables, except that the arguments
    can be defined: `$(1)` for first argument, `$(2)` for second argument, and so
    on. A call to a function can be performed in a single line, as shown in the following
    code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `call` 指令可以轻松编写自定义函数。这些函数看起来类似于递归赋值的变量，不同之处在于可以定义参数：`$(1)` 代表第一个参数，`$(2)`
    代表第二个参数，依此类推。函数的调用可以在单行中执行，如下代码所示：
- en: '[PRE63]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Strings and files manipulation functions are available too, as shown in the
    following table:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和文件操作函数也是可用的，如下表所示：
- en: '| `$(join <str1>, <str2>)` | Concatenates two strings. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `$(join <str1>, <str2>)` | 连接两个字符串。 |'
- en: '| `$(subst <from>,``<replacement>,<string>)`,`$(patsubst <pattern>,``<replacement>,<string>)`
    | Replaces each occurrence of a substring by another. The second one is more powerful
    because it allows using patterns (which must start with "%"). |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `$(subst <from>,``<replacement>,<string>)`,`$(patsubst <pattern>,``<replacement>,<string>)`
    | 将字符串中的每个子串替换为另一个。第二个更强大，因为它允许使用模式（必须以 "%" 开头）。 |'
- en: '| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | Filter
    strings from a text matching patterns. This is useful for filtering files. For
    example, the following line filters any C file:`$(filter %.c, $(my_source_list))`
    |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | 从匹配模式的文本中过滤字符串。这对于过滤文件很有用。例如，以下行过滤任何
    C 文件：`$(filter %.c, $(my_source_list))` |'
- en: '| `$(strip <string>)` | Removes any unnecessary whitespace. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `$(strip <string>)` | 移除任何不必要的空白。 |'
- en: '| `$(addprefix <prefix>,<list>)`,`$(addsuffix <suffix>, <list>)` | Append a
    prefix and suffix, respectively, to each element of the list, each element being
    separated by a space. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `$(addprefix <prefix>,<list>)`,`$(addsuffix <suffix>, <list>)` | 分别向列表中的每个元素添加前缀和后缀，每个元素由空格分隔。
    |'
- en: '| `$(basename <path1>, <path2>, ...)` | Returns a string from which file extensions
    are removed. |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `$(basename <path1>, <path2>, ...)` | 返回一个移除了文件扩展名的字符串。 |'
- en: '| `$(dir <path1>, <path2>)`,`$(notdir <path1>, <path2>)` | Extracts the directory
    and the filename in a path respectively. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `$(dir <path1>, <path2>)`,`$(notdir <path1>, <path2>)` | 分别提取路径中的目录和文件名。
    |'
- en: '| `$(realpath <path1>, <path2>, ...)`,`$(abspath <path1>, <path2>, ...)` |
    Return both canonical paths of each path argument, except that the second one
    does not evaluate symbolic links. |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| `$(realpath <path1>, <path2>, ...)`,`$(abspath <path1>, <path2>, ...)` |
    返回每个路径参数的规范路径，但第二个不评估符号链接。 |'
- en: This is just really an overview of what Makefiles are capable of. For more information,
    refer to the full Makefile documentation available at [http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html).
    If you are allergic to Makefiles, have a look at CMake. CMake is a simplified
    Make system, already building many open source libraries on the market. A port
    of CMake on Android is available at [http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 Makefiles 功能的概览。更多信息，请参考在 [http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html)
    可用的完整 Makefile 文档。如果你对 Makefiles 过敏，可以看看 CMake。CMake 是一个简化的 Make 系统，已经在市场上构建了许多开源库。CMake
    在 Android 上的端口可以在 [http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake)
    找到。
- en: Have a go hero – mastering Makefiles
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手英雄 - 掌握 Makefiles
- en: 'We can play in a variety of ways with Makefiles:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用多种方式玩转 Makefiles：
- en: 'Try the affectation operator. For example, write down the following piece of
    code, which uses the `:= operator`, in your `Android.mk` file:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试赋值运算符。例如，在你的 `Android.mk` 文件中写下以下代码片段，它使用了 `:=` 运算符：
- en: '[PRE64]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Watch the result when launching compilation. Then, perform the same using `=`.
    Print current optimization mode. Use `APP_OPTIM` and the internal variable, `NDK_APP_CFLAGS`,
    and observe the difference between the `release` and `debug` modes:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察启动编译时的结果。然后，使用 `=` 执行相同的操作。打印当前优化模式。使用 `APP_OPTIM` 和内部变量 `NDK_APP_CFLAGS`，观察
    `release` 和 `debug` 模式之间的区别：
- en: '[PRE65]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Check that variables are properly defined, for example:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查变量是否正确定义，例如：
- en: '[PRE66]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Try to use the `foreach` instruction to print the list of files and directories
    inside the project''s root directory and its `jni` folder (and make sure to use
    recursive affectation):'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `foreach` 指令打印项目根目录及其 `jni` 文件夹内的文件和目录列表（并确保使用递归赋值）：
- en: '[PRE67]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Try to create a macro to log a message to the standard output and its time:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建一个宏，将消息和时间记录到标准输出：
- en: '[PRE68]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, test the `my-dir` macro-behavior, to understand why `LOCAL_PATH :=
    $(call my-dir)` is systematically written at the beginning of each `Android.mk`
    file:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，测试 `my-dir` 宏的行为，了解为什么每个 `Android.mk` 文件的开头都会系统性地写出 `LOCAL_PATH := $(call
    my-dir)`：
- en: '[PRE69]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: CPU Architectures (ABI)
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU 架构（ABI）
- en: 'Compiled native C/C++ code on current Android ARM devices follows an **Application
    Binary Interface** (**ABI**). An ABI specifies the binary code format (instruction
    set, calling conventions, and so on). GCC translates code into this binary format.
    ABIs are thus strongly related to processors. The target ABI can be selected in
    the `Application.mk` file with the `APP_ABI` variable. There exist five main ABIs
    supported on Android, which are as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Android ARM 设备上的原生 C/C++ 代码遵循一个**应用程序二进制接口**（**ABI**）。ABI 规定了二进制代码格式（指令集、调用约定等）。GCC
    将代码翻译成这种二进制格式。因此，ABI 与处理器密切相关。可以在 `Application.mk` 文件中通过 `APP_ABI` 变量选择目标 ABI。在
    Android 上支持五种主要 ABI，如下所示：
- en: '**thumb**: This is the default option, which should be compatible with all
    ARM devices. Thumb is a special instruction set which encodes instructions on
    16 bit, instead of 32 bit, to improve code size (useful for devices with constrained
    memory). The instruction set is severely restricted compared to ArmEABI.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thumb**：这是默认选项，应与所有 ARM 设备兼容。Thumb 是一种特殊的指令集，它用16位而不是32位编码指令，以提高代码大小（对内存受限的设备很有用）。与
    ArmEABI 相比，指令集受到严格限制。'
- en: '**armeabi** (Or Arm v5): This should run on all ARM devices. Instructions are
    encoded on 32 bit but may be more concise than Thumb code. Arm v5 does not support
    advanced extensions such as floating point acceleration and is thus slower than
    Arm v7.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**armeabi**（或 Arm v5）：这应该能在所有 ARM 设备上运行。指令编码为32位，但可能比 Thumb 代码更简洁。Arm v5 不支持浮点加速等高级扩展，因此比
    Arm v7 慢。'
- en: '**armeabi-v7a**: This supports extensions such as Thumb-2 (similar to Thumb
    but with additional 32-bit instructions) and VFP, plus some optional extensions,
    such as NEON. Code compiled for Arm V7 will not run on Arm V5 processors.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**armeabi-v7a**：这支持如 Thumb-2（类似于 Thumb，但增加了额外的32位指令）和 VFP 等扩展，以及一些可选扩展，如 NEON。为
    Arm V7 编译的代码不能在 Arm V5 处理器上运行。'
- en: '**x86**: This is for "*PC-like*" architectures (that is, Intel/AMD) and, more
    specifically, Intel Atom processors. This ABI provides specific extensions, such
    as MMX or SSE.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x86**：这是针对“*PC-like*”架构（即 Intel/AMD）的，更具体地说，是针对 Intel Atom 处理器的。这个 ABI 提供了特定的扩展，如
    MMX 或 SSE。'
- en: '**mips**: This is for MIPS processors developed by Imagination Technologies
    (which also produce the PowerVR graphics processors). Only a few devices exist
    at the time this book was written.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mips**：这是针对由 Imagination Technologies 开发的 MIPS 处理器（该公司还生产 PowerVR 图形处理器）。在撰写本书时，只有少数设备存在。'
- en: By default, the compiled binaries of each ABI are embedded in the APK. The most
    appropriate is selected at installation time. Google Play also supports the upload
    of different APKs for each ABI to limit application size.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个 ABI 编译的二进制文件都嵌入在 APK 中。在安装时选择最合适的。Google Play 还支持上传针对每个 ABI 的不同 APK，以限制应用程序大小。
- en: Advanced instruction sets (NEON, VFP, SSE, MSA)
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级指令集（NEON、VFP、SSE、MSA）
- en: If you are reading this book, code performance is probably one of your main
    criteria. To achieve this, ARM created a SIMD instruction set (acronym Single
    Instruction Multiple Data, that is, process several data in parallel with one
    instruction) called NEON, which has been introduced along with the VFP (floating
    point accelerated) unit. NEON is not available on all chips (for example, Nvidia
    Tegra 2 does not support it), but is quite popular in intensive multimedia applications.
    They are also a good way to compensate the weak VFP unit of some processors (for
    example, Cortex-A8).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，代码性能可能是你的主要标准之一。为了达到这个目标，ARM 创建了一个 SIMD 指令集（即单指令多数据，简称 Single Instruction
    Multiple Data，即使用一条指令并行处理多个数据），名为 NEON，它与 VFP（浮点加速）单元一起引入。NEON 并不是所有芯片都可用（例如，Nvidia
    Tegra 2 不支持它），但在密集型多媒体应用中相当受欢迎。它们也是一些处理器（例如，Cortex-A8）弱 VFP 单元的良好补偿方式。
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A NEON code can be written in a separate assembler file in a dedicated `asm
    volatile` block with assembler instructions, or in a C/C++ file or as intrinsics
    (NEON instructions encapsulated in a GCC C routine). Intrinsics should be used
    with much care as GCC is often unable to generate efficient machine code (or requires
    lots of tricky hints). Writing real assembler code is generally advised.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: NEON 代码可以写在单独的汇编文件中，使用专门的 `asm volatile` 块和汇编指令，或者写在 C/C++ 文件中，或者作为内联函数（将 NEON
    指令封装在 GCC C 例程中）。使用内联函数时要小心，因为 GCC 经常无法生成高效的机器代码（或者需要很多巧妙的提示）。通常建议编写真正的汇编代码。
- en: 'X86 CPUs have their own set of extensions that are different from the ARM ones:
    MMX, SSE, SSE2, and SSE3\. SSE instruction sets are the Intel equivalent of NEON
    SIMS instructions. The latest SSE4 instructions are generally not supported on
    current X86 processors. Obviously, SSE and NEON are not compatible, which means
    that a code specifically written for NEON needs to be rewritten for SSE and reciprocally.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: X86 CPU 具有一套与 ARM 不同的扩展指令集：MMX、SSE、SSE2 和 SSE3。SSE 指令集相当于英特尔的 NEON SIMD 指令。最新的
    SSE4 指令通常不被当前 X86 处理器支持。显然，SSE 和 NEON 不兼容，这意味着专门为 NEON 编写的代码需要重写以适应 SSE，反之亦然。
- en: Tip
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Android provides a `cpu-features.h` API (with the `android_getCpuFamily()`and
    `android_getCpuFeatures()` methods) to detect available features on the host device
    at runtime. It helps in detecting the CPU (ARM, X86) and its capabilities (ArmV7
    support, NEON, VFP, and so on).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了一个 `cpu-features.h` API（包含 `android_getCpuFamily()` 和 `android_getCpuFeatures()`
    方法），可以在运行时检测宿主设备上的可用特性。它有助于检测 CPU（ARM、X86）及其能力（支持 ArmV7、NEON、VFP 等）。
- en: NEON, SSE, and modern processors in general are not easy to master. The Internet
    is full of examples to get inspiration from. Reference technical documentation
    can be found on the ARM website at [http://infocenter.arm.com/](http://infocenter.arm.com/)
    and the Intel developer manuals at [http://www.intel.com/](http://www.intel.com/).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: NEON、SSE 和现代处理器通常不易掌握。互联网上有很多可以借鉴的例子。参考技术文档可以在 ARM 网站 [http://infocenter.arm.com/](http://infocenter.arm.com/)
    和英特尔开发者手册 [http://www.intel.com/](http://www.intel.com/) 上找到。
- en: MIPS also has its own SIMD instruction set named MSA. It provides features such
    as vector arithmetics and branching operations, or conversion between integer
    and floating-point values. For more information, have a look at [http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS 也有自己的 SIMD 指令集 MSA。它提供了诸如向量算术和分支操作，或者整数和浮点值之间的转换等功能。更多信息请查看 [http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp)。
- en: 'All this stuff is interesting but it does not answer the question you are probably
    asking yourself: how hard it is to port code from ARM to X86 (or reciprocally)?
    The answer is "it depends":'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都很有趣，但它并没有回答你可能问自己的问题：从 ARM 移植代码到 X86（或反之）有多难？答案是“视情况而定”：
- en: If you use pure C/C++ native code, without specific instruction set, code should
    be portable simply by appending `x86` or `mips` to the `APP_ABI` variable.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用纯 C/C++ 本地代码，没有特定的指令集，只需将 `x86` 或 `mips` 追加到 `APP_ABI` 变量，代码应该是可移植的。
- en: If your code contains assembly code, you will need to rewrite the corresponding
    part for other ABI or provide a fallback.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码包含汇编代码，你将需要为其他 ABI 重写相应部分或提供备用方案。
- en: If your code contains specific instruction sets such as NEON (using C/C++ intrinsics
    or assembly code), you will need to rewrite corresponding part for other ABIs
    or provide a fallback.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码包含特定的指令集，如 NEON（使用 C/C++ 内联函数或汇编代码），你将需要为其他 ABI 重写相应部分或提供备用方案。
- en: If your code depends on specific memory alignment, you might need to use explicit
    alignment. Indeed, when you compile a data structure, the compiler might use padding
    to align data in memory appropriately for faster memory accesses. However, alignment
    requirements are different depending on the ABI.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码依赖于特定的内存对齐，你可能需要使用显式对齐。确实，当你编译一个数据结构时，编译器可能会使用填充来适当地对齐内存中的数据，以便更快地访问内存。然而，对齐要求根据
    ABI 的不同而不同。
- en: For example, 64-bit variables on ARM are aligned to 8, which means, for example,
    that double must have a memory address, which is a multiple of 8\. X86 memory
    can be more densely packed.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ARM 上的 64 位变量对齐到 8，这意味着，例如，double 必须有一个内存地址，该地址是 8 的倍数。X86 内存可以更紧凑地排列。
- en: Tip
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Data alignment is not an issue the vast majority of the time, except if you
    explicitly depend on data location (for example, if you use serialization). Even
    if you have no alignment issues, it is always interesting to tweak or optimize
    structure layouts to avoid useless padding and get better performances.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐在绝大多数情况下都不是问题，除非你显式依赖于数据位置（例如，如果你使用序列化）。即使你没有对齐问题，调整或优化结构布局以避免无用的填充并获得更好的性能总是有趣的。
- en: So, most of the time, porting code from one ABI to another should be rather
    simple. In specific cases, provide fallbacks when specific CPU features or assembly
    code is necessary. Finally, beware, some memory alignment issues might arise in
    some rare cases.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大部分时间，将代码从一个ABI移植到另一个ABI应该是相当简单的。在特定情况下，当需要特定的CPU特性或汇编代码时，提供备用方案。最后，注意，有些罕见的内存对齐问题可能会出现。
- en: Tip
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we have seen in the Prebuilding Boost part, each ABI has its own compilation
    flags to optimize compilation. Although the default GCC options used by the NDK
    are an appropriate basis, tweaking them can improve efficiency and performance.
    For example, you can use `-mtune=atom -mssse3 -mfpmath=sse` to optimize release
    code on X86 platforms.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在预构建Boost部分所看到的，每个ABI都有其自己的编译标志来优化编译。尽管NDK使用的默认GCC选项是适当的基础，但调整它们可以提高效率和性能。例如，你可以在X86平台上使用`-mtune=atom
    -mssse3 -mfpmath=sse`来优化发布代码。
- en: Summary
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter introduced a fundamental aspect of the NDK: portability. Thanks
    to the recent improvements in the building toolchain, the Android NDK can now
    take advantage of the vast C/C++ ecosystem. It unlocks the door of a productive
    environment, where code is shared with other platforms with the aim of creating
    new cutting-edge applications efficiently.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了NDK的一个基本方面：可移植性。得益于构建工具链最近的改进，Android NDK现在可以利用庞大的C/C++生态系统。它开启了一个高效的生产环境，在这个环境中，代码可以与其他平台共享，旨在高效地创建新的尖端应用。
- en: More specifically, you learned how to activate the STL with a simple flag in
    the NDK makefile system. We have ported the Box2D library into an NDK module that
    is reusable among Android projects. You also saw how to prebuild Boost using the
    raw NDK toolchain, without any wrapper. We have enabled exceptions and RTTI and
    discovered in depth how to write module makefiles.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，你学会了如何在NDK makefile系统中通过一个简单的标志来激活STL。我们将Box2D库移植成了一个可以在Android项目中重复使用的NDK模块。你也了解了如何使用原始的NDK工具链预构建Boost，而不需要任何封装。我们启用了异常和RTTI，并深入探讨了如何编写模块makefiles。
- en: We have highlighted the path toward the creation of professional applications
    using the NDK as a leverage. But do not expect all C/C++ libraries to be ported
    so easily. Talking about paths, we are almost at the end. At least, this was the
    last chapter about DroidBlaster.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了使用NDK作为杠杆创建专业应用的路径。但不要期望所有的C/C++库都能如此容易地移植。说到路径，我们几乎到了尽头。至少，这是关于DroidBlaster的最后章节。
- en: The next and last chapters will introduce RenderScript, an advanced technology
    to maximize your Android app performance.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节也是最后一章，将介绍RenderScript，这是一种先进的技术，可以最大限度地提高你的Android应用性能。
