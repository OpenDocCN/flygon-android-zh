- en: Chapter 10. Move and Draw with OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement all the graphics, game play, and movement.
    In just over 30 pages, we will complete everything except collision detection.
    We can achieve this much because of the groundwork we laid in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will draw a static border around our game world, then some blinking
    stars, followed by adding movement to our spaceship as well as some bullets. After
    that, we will quickly add controls for the player and we will be whizzing around
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will also make some noise by implementing our `SoundManager` class with some
    new sound FX.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we will add randomly shaped asteroids that move across the
    world while spinning around at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can add a HUD to highlight the touchable areas of the screen and provide
    a tally of the remaining player lives and asteroids that need destroying before
    the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a static game border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this simple class, we define four sets of points that will represent four
    lines. Unsurprisingly, the `GameObject` class will draw the border using these
    points as the end points of lines.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, which is the entirety of the class, we set the type by calling
    `setType()`, the world location as the center of the map, and `height` and `width`
    as the height and width of the entire map.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the four lines in a float array and call `setVertices()` to
    prepare a `FloatBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Border` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then declare a `Border` object as a member of `GameManager` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the `createObjects` method of `AsteroidsRenderer` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can draw our border by adding a line of code into the `draw` method
    of the `AsteroidsRendrer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the game. If you want to actually see the border, you can change
    the location to which we initialize the ship to somewhere near the border. Remember
    that in the `draw` method, we center the viewport around the ship. To see the
    border, change this one line in the `SpaceShip` class to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the game to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a static game border](img/B043422_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Change it back to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will fill up the area within the border with stars.
  prefs: []
  type: TYPE_NORMAL
- en: Twinkling stars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will get a bit more mobile than a static border. Here, we will add an `update`
    method to a simple `Star` class, which can be used to randomly switch the star
    on and off.
  prefs: []
  type: TYPE_NORMAL
- en: We set the type as `normal` and create a random location for the star within
    the confines of the border and call `setWorldLocation()` as always.
  prefs: []
  type: TYPE_NORMAL
- en: Stars will be drawn as points, so our vertex array will simply contain one vertex
    at model space 0,0,0\. Then, we call `setVertices()` as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `Star`, and enter the discussed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here is our `Star` class's `update` method. As we can see, there is a one in
    a 1000 chance in each frame that the star will switch its status. For more blinking,
    use a lower seed, and for less blinking, use a higher seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare a `Star` array, as a member of `GameManager`, and an extra
    `int` variable to control how many stars we want to draw, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the array of `Star` objects in the `createObjects` method of `AsteroidsRenderer`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can draw our stars by adding these lines of code into the `draw` method
    of the `AsteroidsRenderer` class. Note that we draw the stars first as they are
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, to make them blink, we call their `update` method from the `AsteroidsRenderer`
    class''s `update` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twinkling stars](img/B043422_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bringing the spaceship to life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to add a bit more functionality to our `GameObject` class. We
    do so in `GameObject` because bullets and asteroids share a surprising amount
    of similarities with a spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a bunch of getters and setters to get and set the rotation rate, traveling
    angle, and facing angle. Add the following methods to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add a `move` method, which adjusts the *x* and *y* coordinates as well
    as the `facingAngle` of the object based on the current frames per second. Add
    the `move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our additions to the `GameObject` class, add these getters and
    setters for velocity, speed, and maximum speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make some additions to the `SpaceShip` class. Add these three members
    to the `SpaceShip` class to control if the player''s ship is turning or moving
    forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `SpaceShip` constructor, let''s set the maximum speed of the
    ship. I have highlighted the new line of code among the existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the `SpaceShip` class, we add an `update` method that, first of all,
    increases and decreases the speed based on whether `isThrusting` is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, we set the *x* and *y* velocity based on the angle, which way the ship
    is facing, and the speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use speed multiplied by the cosine of the angle the ship is facing to set
    the velocity on the *x* axis. This works because the cosine function is a perfect
    variant that will return a value of -1 or 1, when the ship is facing exactly left
    or right, respectively; the variant returns a precise value of 0 when the ship
    is pointing exactly up or down. It also returns fine values in between as well.
    The sine of the angle works in exactly the same way on the *y* axis. The slightly
    convoluted looking code is because we need to convert our angle to radians and
    we must add 90 degrees to our `facingAngle` because 0 degrees is pointing to three
    o''clock. This fact is not conducive to using it on an *x*, *y* plane the way
    we have it, so we modify it by 90 degrees and the ship moves as expected. For
    more information about how this works check out this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we set the rotation rate based on whether the player is turning left or
    right. Finally, we call `move()` to put all the updates into effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to add a `pullTrigger` method, which for now, we just return `true`.
    We also provide three methods for our future `InputController` to call and trigger
    the `update` method to make its various changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are already drawing the ship in each frame, but we need to add one line
    of code in the `AsteroidsRenderer` class''s `update` method. Add this line of
    code to call the `SpaceShip` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we can't actually move until we add the player controls. Let's quickly
    add some bullets to the game. Then, we will add sound and controls so that we
    can see and hear the cool new features we added.
  prefs: []
  type: TYPE_NORMAL
- en: Rapid fire bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've been addicted to games since Pong in the '70s, and remember my delight
    when a friend actually had a Space Invaders machine in his home for about a week.
    Although what really made asteroids so much better than Space Invaders, was how
    quickly you could shoot. In that tradition, we will make a satisfying, rapid fire
    stream of bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Bullet`, which has one vertex and will be drawn with
    a point. Note that we also declare and initialize an `inFlight` Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the `shoot` method that sets the `facingAngle` of the bullet to
    that of the ship. This will cause the bullet to move in the direction the ship
    was facing at the time the fire button was pressed. We also set `inFlight` to
    true and see how this is used in the `update` method. Finally, we set the speed
    to `300`.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a `resetBullet` method, which sets the bullet inside the ship and
    cancels its velocity and speed. This gives us a clue as to how we will implement
    our bullets. The bullets will sit invisibly inside the ship until they are fired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, we move the bullet based on its `facingAngle` and speed, only if `inFlight`
    is true. Otherwise, we keep the bullet inside the ship. Then, we call `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a `Bullet` class, we can declare an array, to hold a bunch of objects
    of this type in our `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initialize them in `createObjects()` right after our stars from the last section
    in `AsteroidsRenderer`. Note how we initialize their location in the game world
    as the center of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Update them in the `update` method, again right after our blinking stars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Draw them in the `draw` method, once more, after the stars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The bullets are now ready to be fired!
  prefs: []
  type: TYPE_NORMAL
- en: We will add a `SoundManager` and `InputController` class, then we can see our
    ship and its rapid fire gun in action.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing existing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's quickly add our `SoundManager` and `InputController` classes to this project
    because they only need a little tweak to accommodate our needs here too.
  prefs: []
  type: TYPE_NORMAL
- en: Add a member for a `SoundManager` and an `InputController` object in both the
    `AsteroidsView` and `AsteroidsRenderer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the new objects in the `onCreate` method of the `AsteroidsView`
    class and call the `loadSound` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Also in `AsteroidsView`, add an extra two arguments to the call to the `AsteroidsRenderer`
    constructor to pass in references to the `SoundManager` and `InputController`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `AsteroidsRenderer` constructor add the two extra parameters and
    initialize the two new members like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You will have errors in your IDE until we add the two classes. We will do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SoundManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SoundManager` class works exactly the same way as it did with the previous
    project, so there is nothing new to explain here.
  prefs: []
  type: TYPE_NORMAL
- en: Add all the sound files from the download bundle `Chapter10/assets` folder to
    the assets folder of your project. As in the last two projects, you may need to
    create the assets folder in the `.../app/src/main` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, you can use the sound effects provided or create your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new class to the project called `SoundManager`. Note that the functionality
    of the class is identical to the last project, but the code is different simply
    because of the names of the sound files and their related variables. Add this
    code to the `SoundManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to call `playSound()` from anywhere we have a reference to
    our new class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the InputController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This works the same way as it did in the last project, except that we call the
    appropriate `PlayerShip` methods instead of Bob's. Furthermore, we will not be
    moving the viewport while paused, so it is not necessary to handle the screen
    touches differently when the game is paused; making this `InputController` a little
    simpler and shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `onTouchEvent` method to the `AsteroidsView` class to pass responsibility
    for handling touches to `InputController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add a new class called `InputController`, and add the following code which is
    straightforward, except for the way that we handle the player firing a shot.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a member `int currentBullet` that keeps track of which bullet from
    our soon-to-be-declared array we are going to shoot next. Then, we can count the
    bullets out when the fire button is pressed and go back to the first bullet, right
    after the last one in the array is fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `InputController` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's bundle all our buttons together in a list and make them available with
    a public method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we handle the input as we have before, except we call our `Ship` class's
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can fly around and loose off a few space rounds! Of course, you will
    have to estimate the screen positions until we get our HUD drawn later in this
    chapter. Don't forget that the player needs to tap the pause button (top-right)
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that at the moment, we don't use the `resetBullet` method, and that once
    you have shot your twenty bullets, you will not be able to shoot any more. We
    can do a quick check to see if the bullet was at a location outside the border
    and then call `resetBullet`, but we will handle this fully, in conjunction with
    all the collision detection, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can't have an asteroids game without any asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing and moving the asteroids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At last, we will add our cool, spinning asteroids. First, we will look at the
    constructor that is fairly similar to the other game object constructors, except
    that we set the world location randomly. However, take a little extra care not
    to spawn them in the center of the map, where the spaceship starts the game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Asteroid` and add this constructor. Note that we
    have not defined any vertices. We delegate this to the `generatePoints` method
    that we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our update method simply calculates the velocity based on speed and traveling
    angle as we did for the `SpaceShip` class. It then calls `move()` in the usual
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the `generatePoints` method, which will create a randomly shaped
    asteroid. Simply explained, each asteroid will have six vertices. Each vertex
    has a randomly generated position but within fairly strict limits, so we don't
    get any overlapping lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have our six points that we use to build our array of floats that represent
    the vertices. Finally, we call `setVertices()` to create our `ByteBuffer`. Note
    that the asteroids will be drawn as a series of lines, which is why the last vertex
    in the array is the same as the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now as you have probably come to expect, we add an array to `GameManager` to
    hold all our asteroids. At the same time, we will declare some variables which
    will hold the level the player is currently on, as well as the starting (base)
    number of asteroids. Then soon, when we initialize all our asteroids, we will
    see how we will determine the number of asteroids that will need to be destroyed
    to clear a level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the array in the `GameManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the objects themselves in the `createObjects` method using our previously
    declared variables to determine the number of asteroids based on the current level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Update them in the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can draw all our asteroids in the `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the game and check out those smooth, 60+ FPS, spinning asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing and moving the asteroids](img/B043422_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to make it easy to control the ship by adding button graphics,
    as well as some other overlay information, with a HUD.
  prefs: []
  type: TYPE_NORMAL
- en: Scores and the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HUD objects will never be rotated. In addition, they are defined in the
    `InputController` class based on screen coordinates, not the game world or even
    Open GL coordinates. Therefore, our `GameObject` class is not a suitable parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, each of the three HUD classes will have their own
    `draw` method. We will see how we draw them at a consistent size and screen position
    using a new viewport matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created all three of our HUD classes, we will add all of the object
    declarations, initializations, and drawing code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding control buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first HUD object we will make a class for, is a simple button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am showing all the imports explicitly, as they do not get imported automatically.
    Note that the next two classes will need these as well. The code is all in the
    download bundle as usual, if you wish to just copy and paste it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and call it `GameButton`, then add the following import statements.
    Be sure to state the correct package name based on which chapter's code you are
    using or the name you gave your project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare some members; `viewportMatrix` into which we will put our
    new matrix for the viewport transformation from the `InputController` class's
    screen based coordinates—An int `glprogram` value, an `int numVertices` value,
    and a `FloatBuffer` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in the constructor is make our viewport matrix by calling
    `orthoM()` with the screen height and width as `0,0`. This makes OpenGL map a
    coordinate range that is identical to the device resolution over the top of the
    OpenGL coordinate range.
  prefs: []
  type: TYPE_NORMAL
- en: We then get the coordinates of the passed in button and shrink it down to make
    it smaller. Then, we initialize a vertex array as four lines to represent a button.
    Clearly, we will need to create a new button object to represent each and every
    button from our `InputController` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we duplicate a little of the code from `GameObject` to prepare `ByteBuffer`,
    but still we use our static `GLManager.getGLProgram()` to get a handle to a GL
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement the `draw` method, which is a simplified version of the
    `draw` method from `GameObject`. Note that we don't need to mess around with model,
    translation, and rotation matrices, and also that we pass a different color to
    the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tally icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is the same as `GameButton`, except that a tally icon will be a single
    straight vertical line; therefore, we only need two vertices.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that we have a parameter in the constructor called `nthIcon`.
    It will be the responsibility of the calling code to let `TallyIcon` know the
    total quantity of already created `TallyIcon` objects, plus one. Then, the current
    `TallyIcon` object can use the padding variable to position itself appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `TallyIcon` and enter the following code. As we have,
    previously, include the static imports as required. Here is the code for all the
    declarations and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is the draw method which is probably looking quite familiar by now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now for the final HUD element.
  prefs: []
  type: TYPE_NORMAL
- en: Life icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last icon will be a kind of mini-ship to indicate how many lives the player
    has remaining.
  prefs: []
  type: TYPE_NORMAL
- en: We will construct a triangle shape out of lines to create a nice hollow effect.
    Note that the `LifeIcon` constructor also uses an `nthIcon` element to control
    the padding and on screen position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `LifeIcon` and enter the following code, remembering
    all the imports that will not auto-import. Here are the declarations and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `draw` method of the `LifeIcon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We have our three HUD classes, and we can draw them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring, initializing, and drawing the HUD objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will declare, initialize, and draw our HUD objects just like all the `GameObject`
    classes. However, note that, as expected, we don't pass a viewport matrix to the
    `draw` method because the HUD classes provide their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these members to `GameManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with the `asteroids` array, initialize `tallyIcons` and `lifeIcons`
    in the `GameManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member array to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code to create objects of all our new HUD classes. Add it to the `createObjects`
    method just before the closing curly brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can draw our HUD based on the number of lives remaining and the number
    of asteroids left before the next level. Add this code to the end of the `draw`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You can now fly around and admire your new HUD.
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring, initializing, and drawing the HUD objects](img/B043422_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, if we are going to make any use of our lives and asteroid tally indicators,
    then we first need to be able to shoot asteroids as well as detect them when the
    ship gets hit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We achieved lots in this chapter, and indeed it would be simple to quickly add
    more game objects. Perhaps, an occasional UFO like in the original arcade classic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will use what we learned in previous projects to set
    up collision detection and finish off the game. However, a game with precise,
    clean, smooth moving lines deserves much more accurate collision detection than
    we used so far.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will concentrate solely on implementing precise, efficient collision
    detection that will make our Asteroids simulator complete.
  prefs: []
  type: TYPE_NORMAL
