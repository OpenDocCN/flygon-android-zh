- en: Chapter 10. Move and Draw with OpenGL ES 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用OpenGL ES 2进行移动和绘制
- en: In this chapter, we will implement all the graphics, game play, and movement.
    In just over 30 pages, we will complete everything except collision detection.
    We can achieve this much because of the groundwork we laid in the last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现所有的图形、游戏玩法和移动。在30多页的内容中，我们将完成除了碰撞检测之外的所有内容。我们能完成这么多，是因为我们在上一章打下了基础。
- en: First, we will draw a static border around our game world, then some blinking
    stars, followed by adding movement to our spaceship as well as some bullets. After
    that, we will quickly add controls for the player and we will be whizzing around
    the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将在游戏世界周围绘制一个静态边界，然后是一些闪烁的星星，接着为我们的太空船添加移动以及一些子弹。在那之后，我们将快速添加玩家的控制，我们将在屏幕上飞快地移动。 '
- en: We will also make some noise by implementing our `SoundManager` class with some
    new sound FX.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过实现带有一些新声音效果的`SoundManager`类来制造一些噪音。
- en: Once this is done, we will add randomly shaped asteroids that move across the
    world while spinning around at the same time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们将添加随机形状的小行星，这些小行星在旋转的同时穿过整个世界。
- en: Then, we can add a HUD to highlight the touchable areas of the screen and provide
    a tally of the remaining player lives and asteroids that need destroying before
    the next level.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加一个HUD来突出屏幕的可触摸区域，并提供剩余玩家生命值和需要摧毁的小行星数量的统计。
- en: Drawing a static game border
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制静态游戏边界
- en: In this simple class, we define four sets of points that will represent four
    lines. Unsurprisingly, the `GameObject` class will draw the border using these
    points as the end points of lines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类中，我们定义了四组点，它们将代表四条线。毫不奇怪，`GameObject`类将使用这些点作为线的端点来绘制边界。
- en: In the constructor, which is the entirety of the class, we set the type by calling
    `setType()`, the world location as the center of the map, and `height` and `width`
    as the height and width of the entire map.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，也就是类的全部内容，我们通过调用`setType()`设置类型，将世界位置设置为地图中心，以及将`height`和`width`设置为整个地图的高度和宽度。
- en: Then, we define the four lines in a float array and call `setVertices()` to
    prepare a `FloatBuffer`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在一个float数组中定义四条线，并调用`setVertices()`来准备一个`FloatBuffer`。
- en: 'Create a new class called `Border` and add the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Border`的新类，并添加以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then declare a `Border` object as a member of `GameManager` like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像这样在`GameManager`中声明一个`Border`对象：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Initialize it in the `createObjects` method of `AsteroidsRenderer` like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`createObjects`方法中这样初始化它：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can draw our border by adding a line of code into the `draw` method
    of the `AsteroidsRendrer` class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`AsteroidsRendrer`类的`draw`方法中添加一行代码来绘制我们的边界：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can now run the game. If you want to actually see the border, you can change
    the location to which we initialize the ship to somewhere near the border. Remember
    that in the `draw` method, we center the viewport around the ship. To see the
    border, change this one line in the `SpaceShip` class to this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了。如果你想实际看到边界，可以将我们初始化飞船的位置改到靠近边界的地方。记住，在`draw`方法中，我们将视口围绕飞船居中。要看到边界，将`SpaceShip`类中的这一行改为这样：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the game to take a look.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏看看效果。
- en: '![Drawing a static game border](img/B043422_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![绘制静态游戏边界](img/B043422_10_01.jpg)'
- en: 'Change it back to this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 改回这一行：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we will fill up the area within the border with stars.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在边框内填充星星。
- en: Twinkling stars
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪烁的星星
- en: We will get a bit more mobile than a static border. Here, we will add an `update`
    method to a simple `Star` class, which can be used to randomly switch the star
    on and off.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使边界更加动态，而不仅仅是静态的。在这里，我们将向一个简单的`Star`类中添加一个`update`方法，该方法可以用来随机地打开或关闭星星。
- en: We set the type as `normal` and create a random location for the star within
    the confines of the border and call `setWorldLocation()` as always.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类型设置为`normal`，并在边界的范围内为星星创建一个随机位置，并像往常一样调用`setWorldLocation()`。
- en: Stars will be drawn as points, so our vertex array will simply contain one vertex
    at model space 0,0,0\. Then, we call `setVertices()` as usual.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 星星将被绘制成点，因此我们的顶点数组将只包含模型空间0,0,0的一个顶点。然后，我们像往常一样调用`setVertices()`。
- en: 'Create a new class, call it `Star`, and enter the discussed code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，命名为`Star`，并输入我们讨论过的代码：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here is our `Star` class's `update` method. As we can see, there is a one in
    a 1000 chance in each frame that the star will switch its status. For more blinking,
    use a lower seed, and for less blinking, use a higher seed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Star`类的`update`方法。正如我们所见，每一帧都有千分之一的机会让星星改变其状态。为了更多闪烁，请使用较低的种子值，为了减少闪烁，请使用较高的种子值。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then declare a `Star` array, as a member of `GameManager`, and an extra
    `int` variable to control how many stars we want to draw, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`GameManager`中声明一个`Star`数组成员，以及一个额外的`int`变量来控制我们想要绘制的星星数量，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Initialize the array of `Star` objects in the `createObjects` method of `AsteroidsRenderer`
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`createObjects`方法中初始化`Star`对象的数组，如下所示：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can draw our stars by adding these lines of code into the `draw` method
    of the `AsteroidsRenderer` class. Note that we draw the stars first as they are
    in the background.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`AsteroidsRenderer`类的`draw`方法中添加以下代码行来绘制我们的星星。注意，我们首先绘制星星，因为它们在背景中。
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, to make them blink, we call their `update` method from the `AsteroidsRenderer`
    class''s `update` method like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使它们闪烁，我们从`AsteroidsRenderer`类的`update`方法中调用它们的`update`方法，如下所示：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now run the game:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了：
- en: '![Twinkling stars](img/B043422_10_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![闪烁的星星](img/B043422_10_02.jpg)'
- en: Bringing the spaceship to life
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让飞船生动起来
- en: First, we need to add a bit more functionality to our `GameObject` class. We
    do so in `GameObject` because bullets and asteroids share a surprising amount
    of similarities with a spaceship.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的`GameObject`类添加更多功能。我们在`GameObject`中这样做，因为子弹和行星与飞船共享许多惊人的相似之处。
- en: 'We need a bunch of getters and setters to get and set the rotation rate, traveling
    angle, and facing angle. Add the following methods to the `GameObject` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一堆获取器和设置器来获取和设置旋转速率、行驶角度和面向角度。向`GameObject`类添加以下方法：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we add a `move` method, which adjusts the *x* and *y* coordinates as well
    as the `facingAngle` of the object based on the current frames per second. Add
    the `move` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加一个`move`方法，该方法根据当前的每秒帧数调整对象的*x*和*y*坐标以及`facingAngle`。添加`move`方法：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To complete our additions to the `GameObject` class, add these getters and
    setters for velocity, speed, and maximum speed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善我们对`GameObject`类的添加，为速度、速度和最大速度添加以下获取器和设置器：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can make some additions to the `SpaceShip` class. Add these three members
    to the `SpaceShip` class to control if the player''s ship is turning or moving
    forward:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`SpaceShip`类添加一些内容。向`SpaceShip`类添加以下三个成员，以控制玩家的飞船是否在转向或向前移动：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, inside the `SpaceShip` constructor, let''s set the maximum speed of the
    ship. I have highlighted the new line of code among the existing code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`SpaceShip`构造函数内部，让我们设置飞船的最大速度。我在现有代码中突出了新的一行代码：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, in the `SpaceShip` class, we add an `update` method that, first of all,
    increases and decreases the speed based on whether `isThrusting` is true or false.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`SpaceShip`类中，我们添加一个`update`方法，首先根据`isThrusting`是真是假来增加或减少速度。
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, we set the *x* and *y* velocity based on the angle, which way the ship
    is facing, and the speed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据角度、船舶面向的方向以及速度来设置*x*和*y*速度。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We use speed multiplied by the cosine of the angle the ship is facing to set
    the velocity on the *x* axis. This works because the cosine function is a perfect
    variant that will return a value of -1 or 1, when the ship is facing exactly left
    or right, respectively; the variant returns a precise value of 0 when the ship
    is pointing exactly up or down. It also returns fine values in between as well.
    The sine of the angle works in exactly the same way on the *y* axis. The slightly
    convoluted looking code is because we need to convert our angle to radians and
    we must add 90 degrees to our `facingAngle` because 0 degrees is pointing to three
    o''clock. This fact is not conducive to using it on an *x*, *y* plane the way
    we have it, so we modify it by 90 degrees and the ship moves as expected. For
    more information about how this works check out this tutorial:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用速度乘以船舶面向角度的余弦值来设置在*x*轴上的速度。这样做有效是因为余弦函数是一个完美的变量，当船舶分别面向左或右时，它会返回-1或1的值；当船舶正好指向上或下时，该变量返回精确的0值。它也在两者之间的角度返回精细的值。正弦函数在*y*轴上以完全相同的方式工作。代码看起来有些复杂，这是因为我们需要将角度转换为弧度，并且必须给我们的`facingAngle`加上90度，因为0度是指向三点钟方向。这个事实不利于我们按照现在的方式在*x*,
    *y*平面上使用它，所以我们将其修改为90度，船舶就能如预期般移动了。有关这一工作原理的更多信息，请查看以下教程：
- en: '[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we set the rotation rate based on whether the player is turning left or
    right. Finally, we call `move()` to put all the updates into effect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们根据玩家是向左还是向右转动来设置旋转速度。最后，我们调用`move()`以使所有更新生效。
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we need to add a `pullTrigger` method, which for now, we just return `true`.
    We also provide three methods for our future `InputController` to call and trigger
    the `update` method to make its various changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个`pullTrigger`方法，目前我们只需返回`true`。我们还提供了三种方法供未来的`InputController`调用，触发`update`方法以进行各种更改。
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are already drawing the ship in each frame, but we need to add one line
    of code in the `AsteroidsRenderer` class''s `update` method. Add this line of
    code to call the `SpaceShip` class''s `update` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在每一帧中绘制了飞船，但我们需要在`AsteroidsRenderer`类的`update`方法中添加一行代码。添加这行代码以调用`SpaceShip`类的`update`方法：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously, we can't actually move until we add the player controls. Let's quickly
    add some bullets to the game. Then, we will add sound and controls so that we
    can see and hear the cool new features we added.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们添加玩家控制之前，我们实际上无法移动。让我们快速向游戏中添加一些子弹。然后，我们将添加声音和控制，这样我们就可以看到和听到我们添加的酷炫新功能。
- en: Rapid fire bullets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速连发子弹
- en: I've been addicted to games since Pong in the '70s, and remember my delight
    when a friend actually had a Space Invaders machine in his home for about a week.
    Although what really made asteroids so much better than Space Invaders, was how
    quickly you could shoot. In that tradition, we will make a satisfying, rapid fire
    stream of bullets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪70年代的Pong游戏以来，我就沉迷于游戏，记得当一位朋友在家中拥有一台太空侵略者游戏机大约一周时，我是多么兴奋。尽管真正让小行星比太空侵略者好的地方在于，你可以多快地进行射击。秉承这一传统，我们将制作一个令人满意的快速子弹流。
- en: Create a new class called `Bullet`, which has one vertex and will be drawn with
    a point. Note that we also declare and initialize an `inFlight` Boolean.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Bullet`的新类，它有一个顶点，并将被绘制成一个点。注意，我们还声明并初始化了一个`inFlight`布尔值。
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we have the `shoot` method that sets the `facingAngle` of the bullet to
    that of the ship. This will cause the bullet to move in the direction the ship
    was facing at the time the fire button was pressed. We also set `inFlight` to
    true and see how this is used in the `update` method. Finally, we set the speed
    to `300`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`shoot`方法，它将子弹的`facingAngle`设置为飞船的`facingAngle`。这将导致子弹在按下开火按钮时沿飞船面向的方向移动。我们还设置`inFlight`为真，并查看在`update`方法中是如何使用它的。最后，我们将速度设置为`300`。
- en: We also add a `resetBullet` method, which sets the bullet inside the ship and
    cancels its velocity and speed. This gives us a clue as to how we will implement
    our bullets. The bullets will sit invisibly inside the ship until they are fired.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`resetBullet`方法，它将子弹设置在飞船内部并取消其速度和速度。这让我们对如何实现我们的子弹有了线索。子弹将在飞船内部不可见，直到它们被发射。
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, we move the bullet based on its `facingAngle` and speed, only if `inFlight`
    is true. Otherwise, we keep the bullet inside the ship. Then, we call `move()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们根据子弹的`facingAngle`和速度移动子弹，但只有当`inFlight`为真时。否则，我们将子弹保留在飞船内部。然后，我们调用`move()`。
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we have a `Bullet` class, we can declare an array, to hold a bunch of objects
    of this type in our `GameManager` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个`Bullet`类，可以在`GameManager`类中声明一个数组，用来保存这一类型的多个对象。
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Initialize them in `createObjects()` right after our stars from the last section
    in `AsteroidsRenderer`. Note how we initialize their location in the game world
    as the center of the ship.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createObjects()`中初始化它们，就在`AsteroidsRenderer`中上一节星星之后。注意我们是如何将它们在游戏世界中的位置初始化为飞船的中心。
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Update them in the `update` method, again right after our blinking stars.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中更新它们，就在我们的闪烁星星之后。
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Draw them in the `draw` method, once more, after the stars.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法中绘制它们，再次在星星之后。
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The bullets are now ready to be fired!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹现在已准备好发射！
- en: We will add a `SoundManager` and `InputController` class, then we can see our
    ship and its rapid fire gun in action.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`SoundManager`和`InputController`类，然后我们可以看到我们的飞船及其快速开火枪支的行动。
- en: Reusing existing classes
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用现有类
- en: Let's quickly add our `SoundManager` and `InputController` classes to this project
    because they only need a little tweak to accommodate our needs here too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速将`SoundManager`和`InputController`类添加到这个项目中，因为它们只需要稍作调整就能满足我们这里的需求。
- en: Add a member for a `SoundManager` and an `InputController` object in both the
    `AsteroidsView` and `AsteroidsRenderer` classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsView`和`AsteroidsRenderer`类中都添加一个`SoundManager`和一个`InputController`对象的成员。
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Initialize the new objects in the `onCreate` method of the `AsteroidsView`
    class and call the `loadSound` method like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsView`类的`onCreate`方法中初始化新对象，并像这样调用`loadSound`方法：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Also in `AsteroidsView`, add an extra two arguments to the call to the `AsteroidsRenderer`
    constructor to pass in references to the `SoundManager` and `InputController`
    objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`AsteroidsView`中，向`AsteroidsRenderer`构造函数的调用中添加两个额外的参数，以传递对`SoundManager`和`InputController`对象的引用。
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now in the `AsteroidsRenderer` constructor add the two extra parameters and
    initialize the two new members like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`AsteroidsRenderer`构造函数中添加两个额外的参数，并像这样初始化两个新成员：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will have errors in your IDE until we add the two classes. We will do that
    now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加这两个类之前，你的IDE中会有错误。我们现在就来做这件事。
- en: Adding the SoundManager class
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`SoundManager`类
- en: The `SoundManager` class works exactly the same way as it did with the previous
    project, so there is nothing new to explain here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager`类的工作方式与上一个项目完全一样，所以这里没有什么新内容需要解释。'
- en: Add all the sound files from the download bundle `Chapter10/assets` folder to
    the assets folder of your project. As in the last two projects, you may need to
    create the assets folder in the `.../app/src/main` folder of your project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载包`Chapter10/assets`文件夹中的所有声音文件添加到项目的assets文件夹中。与最后两个项目一样，你可能需要在项目的`.../app/src/main`文件夹中创建assets文件夹。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As usual, you can use the sound effects provided or create your own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，你可以使用提供的声音效果，或者创建自己的效果。
- en: 'Now, add a new class to the project called `SoundManager`. Note that the functionality
    of the class is identical to the last project, but the code is different simply
    because of the names of the sound files and their related variables. Add this
    code to the `SoundManager` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向项目中添加一个名为`SoundManager`的新类。请注意，该类的功能与上一个项目完全相同，但代码不同仅仅是因为声音文件和相关变量的名称不同。将以下代码添加到`SoundManager`类中：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are now ready to call `playSound()` from anywhere we have a reference to
    our new class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从任何有对新类引用的地方调用`playSound()`。
- en: Adding the InputController class
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加`InputController`类
- en: This works the same way as it did in the last project, except that we call the
    appropriate `PlayerShip` methods instead of Bob's. Furthermore, we will not be
    moving the viewport while paused, so it is not necessary to handle the screen
    touches differently when the game is paused; making this `InputController` a little
    simpler and shorter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个项目中的处理方式相同，只是我们调用适当的`PlayerShip`方法，而不是Bob的。此外，当游戏暂停时，我们不会移动视口，因此无需在游戏暂停时以不同的方式处理屏幕触摸；这使得这个`InputController`更简单，更短。
- en: 'Add the `onTouchEvent` method to the `AsteroidsView` class to pass responsibility
    for handling touches to `InputController`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsView`类中添加`onTouchEvent`方法，以将处理触摸的责任传递给`InputController`：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add a new class called `InputController`, and add the following code which is
    straightforward, except for the way that we handle the player firing a shot.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`InputController`的新类，并添加以下代码，这些代码很直观，除了我们处理玩家发射子弹的方式。
- en: We declare a member `int currentBullet` that keeps track of which bullet from
    our soon-to-be-declared array we are going to shoot next. Then, we can count the
    bullets out when the fire button is pressed and go back to the first bullet, right
    after the last one in the array is fired.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个成员`int currentBullet`，用于跟踪我们将要发射的下一个子弹，来自我们即将声明的数组。然后，当按下开火按钮时，我们可以计算子弹数量，并在数组中的最后一个子弹发射后回到第一个子弹。
- en: 'Create a new class called `InputController` and enter the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`InputController`的新类，并输入以下代码：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's bundle all our buttons together in a list and make them available with
    a public method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有按钮捆绑在一个列表中，并通过一个公共方法使它们可用。
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we handle the input as we have before, except we call our `Ship` class's
    methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们像以前一样处理输入，只是调用我们的`Ship`类的方法。
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we can fly around and loose off a few space rounds! Of course, you will
    have to estimate the screen positions until we get our HUD drawn later in this
    chapter. Don't forget that the player needs to tap the pause button (top-right)
    first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以四处飞行并发射几轮太空子弹！当然，在绘制本章后面的HUD之前，您将不得不估计屏幕位置。别忘了玩家需要首先点击暂停按钮（右上角）。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that at the moment, we don't use the `resetBullet` method, and that once
    you have shot your twenty bullets, you will not be able to shoot any more. We
    can do a quick check to see if the bullet was at a location outside the border
    and then call `resetBullet`, but we will handle this fully, in conjunction with
    all the collision detection, in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前我们不使用`resetBullet`方法，一旦您发射了二十颗子弹，您将无法再射击。我们可以快速检查子弹是否位于边界外，然后调用`resetBullet`，但我们将与所有的碰撞检测一起，在下一章中完全处理这个问题。
- en: Of course, we can't have an asteroids game without any asteroids.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有行星的话，我们不能有一个行星游戏。
- en: Drawing and moving the asteroids
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制和移动行星
- en: At last, we will add our cool, spinning asteroids. First, we will look at the
    constructor that is fairly similar to the other game object constructors, except
    that we set the world location randomly. However, take a little extra care not
    to spawn them in the center of the map, where the spaceship starts the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加酷炫的旋转行星。首先，我们将看看与其他游戏对象构造函数相当相似的构造函数，不同之处在于我们随机设置世界位置。但是，需要特别小心，不要在游戏开始的太空船中心位置生成它们。
- en: Create a new class called `Asteroid` and add this constructor. Note that we
    have not defined any vertices. We delegate this to the `generatePoints` method
    that we will see soon.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Asteroid`的新类，并添加这个构造函数。注意我们没有定义任何顶点。我们将这个任务委托给即将看到的`generatePoints`方法。
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our update method simply calculates the velocity based on speed and traveling
    angle as we did for the `SpaceShip` class. It then calls `move()` in the usual
    way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更新方法仅根据速度和移动角度计算速度，就像我们对`SpaceShip`类所做的那样。然后以常规方式调用`move()`。
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we see the `generatePoints` method, which will create a randomly shaped
    asteroid. Simply explained, each asteroid will have six vertices. Each vertex
    has a randomly generated position but within fairly strict limits, so we don't
    get any overlapping lines.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到`generatePoints`方法，它将创建一个随机形状的行星。简单来说，每个行星都有六个顶点。每个顶点都有一个随机生成的位置，但限制相当严格，这样我们就不会得到任何重叠的线条。
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, we have our six points that we use to build our array of floats that represent
    the vertices. Finally, we call `setVertices()` to create our `ByteBuffer`. Note
    that the asteroids will be drawn as a series of lines, which is why the last vertex
    in the array is the same as the first.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有六个点用来构建表示顶点的浮点数数组。最后，我们调用`setVertices()`来创建我们的`ByteBuffer`。请注意，行星将被绘制成一系列的线条，这就是数组中的最后一个顶点与第一个顶点相同的原因。
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now as you have probably come to expect, we add an array to `GameManager` to
    hold all our asteroids. At the same time, we will declare some variables which
    will hold the level the player is currently on, as well as the starting (base)
    number of asteroids. Then soon, when we initialize all our asteroids, we will
    see how we will determine the number of asteroids that will need to be destroyed
    to clear a level.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，我们在`GameManager`中添加了一个数组来保存所有的行星。同时，我们还将声明一些变量，用来记录玩家当前的关卡以及初始（基础）的行星数量。随后，当我们初始化所有行星时，我们将看到如何确定需要摧毁的行星数量以完成一个关卡。
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Initialize the array in the `GameManager` constructor:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameManager`构造函数中初始化数组：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Initialize the objects themselves in the `createObjects` method using our previously
    declared variables to determine the number of asteroids based on the current level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createObjects`方法中使用我们之前声明的变量来初始化对象本身，根据当前关卡确定行星的数量。
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Update them in the `update` method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中更新它们。
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, we can draw all our asteroids in the `draw` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`draw`方法中绘制所有的行星。
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, run the game and check out those smooth, 60+ FPS, spinning asteroids.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行游戏并查看那些流畅的60+ FPS旋转行星。
- en: '![Drawing and moving the asteroids](img/B043422_10_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![绘制和移动行星](img/B043422_10_03.jpg)'
- en: Now, we need to make it easy to control the ship by adding button graphics,
    as well as some other overlay information, with a HUD.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过添加按钮图像以及一些其他覆盖信息，包括HUD，来使控制飞船变得容易。
- en: Scores and the HUD
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数和HUD（头上显示装置）
- en: The HUD objects will never be rotated. In addition, they are defined in the
    `InputController` class based on screen coordinates, not the game world or even
    Open GL coordinates. Therefore, our `GameObject` class is not a suitable parent
    class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: HUD对象永远不会被旋转。另外，它们是在`InputController`类中根据屏幕坐标定义的，而不是游戏世界或甚至是OpenGL坐标。因此，我们的`GameObject`类不是一个合适的父类。
- en: For the sake of simplicity, each of the three HUD classes will have their own
    `draw` method. We will see how we draw them at a consistent size and screen position
    using a new viewport matrix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这三个HUD类将各自拥有自己的`draw`方法。我们将看到如何使用新的视口矩阵以一致的大小和屏幕位置绘制它们。
- en: Once we have created all three of our HUD classes, we will add all of the object
    declarations, initializations, and drawing code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们所有的HUD类之后，我们将添加所有的对象声明、初始化和绘制代码。
- en: Adding control buttons
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制按钮
- en: The first HUD object we will make a class for, is a simple button.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为第一个HUD对象创建一个类，这是一个简单的按钮。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I am showing all the imports explicitly, as they do not get imported automatically.
    Note that the next two classes will need these as well. The code is all in the
    download bundle as usual, if you wish to just copy and paste it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我明确地展示了所有的导入语句，因为它们不会自动导入。请注意，接下来的两个类也需要这些。代码像往常一样包含在下载包中，如果你希望直接复制粘贴。
- en: Create a new class and call it `GameButton`, then add the following import statements.
    Be sure to state the correct package name based on which chapter's code you are
    using or the name you gave your project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类，将其命名为`GameButton`，然后添加以下导入语句。请确保根据你使用的章节代码或你给项目命的名声明正确的包名。
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we declare some members; `viewportMatrix` into which we will put our
    new matrix for the viewport transformation from the `InputController` class's
    screen based coordinates—An int `glprogram` value, an `int numVertices` value,
    and a `FloatBuffer` class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一些成员；`viewportMatrix`，我们将把来自`InputController`类的基于屏幕坐标的视口变换的新矩阵放入其中——一个整型`glprogram`值，一个`int
    numVertices`值，以及一个`FloatBuffer`类。
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing we do in the constructor is make our viewport matrix by calling
    `orthoM()` with the screen height and width as `0,0`. This makes OpenGL map a
    coordinate range that is identical to the device resolution over the top of the
    OpenGL coordinate range.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中我们首先通过调用`orthoM()`并传入屏幕的高度和宽度作为`0,0`来创建我们的视口矩阵。这使得OpenGL将一个与设备分辨率相同的坐标范围映射到OpenGL坐标范围之上。
- en: We then get the coordinates of the passed in button and shrink it down to make
    it smaller. Then, we initialize a vertex array as four lines to represent a button.
    Clearly, we will need to create a new button object to represent each and every
    button from our `InputController` class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取传入按钮的坐标并将其缩小以使其变小。然后，我们初始化一个顶点数组作为四条线来表示一个按钮。显然，我们将需要创建一个新的按钮对象来代表`InputController`类中的每个按钮。
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we duplicate a little of the code from `GameObject` to prepare `ByteBuffer`,
    but still we use our static `GLManager.getGLProgram()` to get a handle to a GL
    program.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从`GameObject`复制了一些代码来准备`ByteBuffer`，但我们仍然使用我们的静态`GLManager.getGLProgram()`来获取GL程序的句柄。
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we implement the `draw` method, which is a simplified version of the
    `draw` method from `GameObject`. Note that we don't need to mess around with model,
    translation, and rotation matrices, and also that we pass a different color to
    the fragment shader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了`draw`方法，这是来自`GameObject`的`draw`方法的简化版本。注意我们不需要处理模型、转换和旋转矩阵，并且我们传递了一个不同的颜色给片段着色器。
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tally icons
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数字符
- en: This class is the same as `GameButton`, except that a tally icon will be a single
    straight vertical line; therefore, we only need two vertices.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与`GameButton`相同，不同之处在于计数字符将是一个单一的垂直直线；因此，我们只需要两个顶点。
- en: However, note that we have a parameter in the constructor called `nthIcon`.
    It will be the responsibility of the calling code to let `TallyIcon` know the
    total quantity of already created `TallyIcon` objects, plus one. Then, the current
    `TallyIcon` object can use the padding variable to position itself appropriately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，我们在构造函数中有一个名为`nthIcon`的参数。调用代码需要负责让`TallyIcon`知道已经创建的`TallyIcon`对象的总数量加一。然后，当前的`TallyIcon`对象可以使用内边距变量来适当定位自己。
- en: 'Create a new class called `TallyIcon` and enter the following code. As we have,
    previously, include the static imports as required. Here is the code for all the
    declarations and the constructor:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `TallyIcon` 的新类，并输入以下代码。像之前一样，根据需要包含静态导入。以下是所有声明和构造函数的代码：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is the draw method which is probably looking quite familiar by now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 draw 方法，现在看起来可能相当熟悉了。
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now for the final HUD element.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后的 HUD 元素。
- en: Life icons
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命图标
- en: Our last icon will be a kind of mini-ship to indicate how many lives the player
    has remaining.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的图标将是一种迷你飞船，用来指示玩家还剩下多少生命。
- en: We will construct a triangle shape out of lines to create a nice hollow effect.
    Note that the `LifeIcon` constructor also uses an `nthIcon` element to control
    the padding and on screen position.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线条构建一个三角形形状，以创建一个漂亮的空心效果。请注意，`LifeIcon` 构造函数还使用 `nthIcon` 元素来控制填充和屏幕上的位置。
- en: 'Create a new class called `LifeIcon` and enter the following code, remembering
    all the imports that will not auto-import. Here are the declarations and the constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `LifeIcon` 的新类，并输入以下代码，记住所有不会自动导入的导入语句。以下是声明和构造函数：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the `draw` method of the `LifeIcon` class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `LifeIcon` 类的 `draw` 方法：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We have our three HUD classes, and we can draw them to the screen.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了三个 HUD 类，并且可以将它们绘制到屏幕上。
- en: Declaring, initializing, and drawing the HUD objects
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明、初始化并绘制 HUD 对象
- en: We will declare, initialize, and draw our HUD objects just like all the `GameObject`
    classes. However, note that, as expected, we don't pass a viewport matrix to the
    `draw` method because the HUD classes provide their own.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像所有 `GameObject` 类一样声明、初始化并绘制我们的 HUD 对象。但是请注意，如预期的那样，我们不向 `draw` 方法传递视口矩阵，因为
    HUD 类提供了自己的视口矩阵。
- en: 'Add these members to `GameManager`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `GameManager` 添加这些成员：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As we did with the `asteroids` array, initialize `tallyIcons` and `lifeIcons`
    in the `GameManager` constructor:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对 `asteroids` 数组的操作一样，在 `GameManager` 构造函数中初始化 `tallyIcons` 和 `lifeIcons`：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a new member array to the `AsteroidsRenderer` class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `AsteroidsRenderer` 类添加一个新的成员数组：
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add this code to create objects of all our new HUD classes. Add it to the `createObjects`
    method just before the closing curly brace:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这段代码以创建我们所有新 HUD 类的对象。将其添加到 `createObjects` 方法中的闭合大括号之前：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can draw our HUD based on the number of lives remaining and the number
    of asteroids left before the next level. Add this code to the end of the `draw`
    method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据剩余的生命次数和升级前剩余的asteroids数量来绘制我们的 HUD。将此代码添加到 `draw` 方法的末尾：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can now fly around and admire your new HUD.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以飞来飞去，欣赏你的新 HUD 了。
- en: '![Declaring, initializing, and drawing the HUD objects](img/B043422_10_04.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![声明、初始化并绘制 HUD 对象](img/B043422_10_04.jpg)'
- en: Obviously, if we are going to make any use of our lives and asteroid tally indicators,
    then we first need to be able to shoot asteroids as well as detect them when the
    ship gets hit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想要充分利用生命和 asteroid 计数指示器，那么我们首先需要能够射击 asteroid，并在飞船被击中时检测到它们。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We achieved lots in this chapter, and indeed it would be simple to quickly add
    more game objects. Perhaps, an occasional UFO like in the original arcade classic.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们取得了很大的成就，实际上可以很容易地快速添加更多的游戏对象。也许，可以像原始街机经典游戏中那样偶尔添加一个 UFO。
- en: In the next chapter we will use what we learned in previous projects to set
    up collision detection and finish off the game. However, a game with precise,
    clean, smooth moving lines deserves much more accurate collision detection than
    we used so far.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用在前一个项目中学习到的内容来设置碰撞检测，并完成游戏。然而，一个拥有精确、清晰、平滑移动线条的游戏，理应比我们至今所使用的更精确的碰撞检测。
- en: So, we will concentrate solely on implementing precise, efficient collision
    detection that will make our Asteroids simulator complete.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将专注于实现精确高效的碰撞检测，以使我们的 Asteroids 仿真模拟器得以完善。
