- en: Let us Chat in a Smart Way - Messaging API and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The era of innovation has empowered us to chip away at numerous new shrewd subjects.
    Social media is currently an intense medium of communication. Taking a gander
    at the developing pattern of online networking and innovation, we could state
    that the belief system of social media has advanced and wiped out many difficulties
    of communication. Just about a couple of decades back, the communication medium
    was letters. A couple of centuries back, it was trained birds. If we still look
    back, we will definitely get a few more stories to comprehend the way people used
    to communicate in those days. Now, we are in the generation of IoT, wearable smart
    devices, and an era of smartphones, where communication happens across the planet
    in a fraction of a second. Without elaborating about communication, let's build
    a mobile and wear application that exhibits the power of Google wear messaging
    APIs to assist us in building chat application with a Wear companion application
    to administer and respond to the messages being received. To support the process
    of chatting, we will be using Google's very own technology Firebase in this chapter.
    We will not deep dive into the Firebase technologies, but we will surely understand
    the essentials of using Firebase in mobile platforms and working with wear technologies.
    A Firebase real-time database reflects the data being updated in its hashmap structure.
    Essentially, these are the stream of key-value pairs that Firebase works with.
    The data gets updated with minimal internet bandwidth requirement and instantly.
  prefs: []
  type: TYPE_NORMAL
- en: To support the process of chatting, we will be using Google's very own technology,
    Firebase, in this chapter. We will comprehend a generic registration and login
    process for the mobile platform and we will have space for all the registered
    members and enable every one of them to chat exclusively by picking one user from
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Firebase to your mobile application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `GoogleApiClient`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Message API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a wear module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's understand how to set up Firebase to our project. It follows a few
    steps that we need to carry out before using Firebase technologies in the project.
    First, we need to apply the Firebase plugin and then the dependencies that we
    use in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For installing Firebase, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Firebase console [https://console.firebase.google.com](https://console.firebase.google.com):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose Add project in the console and fill the necessary information about
    the project. After the project is successfully added, you will see the following
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The get started page helps you set up the project for different platforms.
    Let''s choose the second option, which says Add Firebase to your Android app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the project package name and, for further security purposes, you can add
    the SHA-1 fingerprint, but that is optional. Now register the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Download the config file. The `google-services.json` file will have all the
    important configuration for the app and place it in the app directory of your
    project structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s fire up Android Studio and create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure the package name is the same as the one mentioned in the Firebase
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s choose the targeted platforms that are both phone and Wear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, add Empty Activity to the mobile activity chooser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select **Blank Wear Activity** in the wear activity chooser for generating
    blank wear activity code through the Android Studio template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, name your class and XML files and finish the project for Android Studio
    to generate boiler for your mobile and wear module. Using file explorer or finder,
    go to the directory structure and copy and paste the `google-services.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since we are building wear and mobile app together and the `app` directory name
    will be mobile for mobile and wear for wear projects, we shall copy the config
    file (`google-services.json`) inside the mobile directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the config file, it is time to add the plugin classpath dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the mobile Gradle module dependency, apply the plugin to the bottom
    of all the tag scope, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To help Gradle to manage dependencies and the order of events that Gradle uses
    to build the project, we are supposed to add Google Play services dependencies
    at the bottom of the Gradle file. However, it will also avoid the conflict with
    other Google dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful sync, the Firebase SDKs are integrated into our project.
    Now, we can get started using features that we are interested in. In this project,
    for the scope of a chatting feature, we will be using the Firebase Realtime database.
    Let''s add the dependency to the same gradle file inside the dependencies. We
    will use the volley network library for fetching the user''s list from the Firebase
    users node. We need to add the design support library for material design support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On off the chance if you see gradle error please add the following packaging
    in gradle file under dependency section.
  prefs: []
  type: TYPE_NORMAL
- en: '`packagingOptions {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/DEPENDENCIES.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/LICENSE.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/NOTICE.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/NOTICE''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/LICENSE''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/DEPENDENCIES''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/notice.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/license.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/dependencies.txt''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude ''META-INF/LGPL2.1''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: After all the necessary project setup, let's conceptualize the chatting application
    that we are going to build.
  prefs: []
  type: TYPE_NORMAL
- en: A basic chat application needs a registration process and, to avoid anonymous
    chats or, at least, to know with whom we are chatting, we need the sender and
    receiver names. The first screen is going to be the login screen with the username
    and password fields allowing already registered users to start chatting with the
    users. Then, we have the registration screen with the same username and password
    fields. Once the user successfully registers, we will ask the user to enter the
    credentials and allow them to have access to the list-of-users screen, where one
    can pick with whom they want to chat.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptualizing the chatting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A login screen with input fields for users to enter the credentials will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The registration screen with input fields will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot represents the user screen that shows the list of
    registered users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The chat screen with the actual chat messages will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Wear Chat Application will look as follows on round screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When a message enters the handheld device, it should notify wear and, from the
    wear device, users should be able to send a reply to that message. In this chapter,
    we will see a working mobile and wear chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Data Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wearable Data Layer API is part of the Google Play services that establishes
    the communication channel to handheld device apps and wear apps. Using the `GoogleApiClient`
    class, we can get access to the Data Layer. Primarily, the Data Layer is used
    in the Wear app to communicate with the handheld device, but using it for connecting
    to the network is discouraged. When we create the `GoogleAPIClient` class using
    the builder pattern, we will be attaching `Wearable.API` to the `addAPI` method.
    When we add multiple APIs in `GoogleApiclient`, there is a chance of the client
    instance failing into the `onConnection` fail callbacks. It's a good approach
    to add an API through `addApiIfAvailable()`. This will take care of most of the
    hard work; it will add the API if it's available. After adding all this using
    `addConnectionCallbacks`, we can handle the Data Layer events. We need to start
    the connection of the client instance by calling the `connect()` method. After
    a successful connection, we can use the Data Layer API.
  prefs: []
  type: TYPE_NORMAL
- en: Data Layer events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events allow the developer to listen to what's happening in the communication
    channel. A successful communication channel will be able to send the status of
    the call when it's complete. These events will allow the developer to monitor
    all the state changes and data changes in a wireless communication channel. The
    Data Layer API returns pending results on an incomplete transaction, such as `putdataitem()`.
    The pending results will be automatically queued in the background when the transaction
    is incomplete and, if we don't handle it, this operation will be completed in
    the background. However, pending results need to be handled; pending result will
    wait for the result status and it has two methods to wait for the results synchronously
    and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Data Layer code is running in the UI thread, we should avoid making
    blocking calls to the Data Layer API. Using asynchronous callbacks to the `pendingresult`
    object, we will be able to check the status and other vital information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Data Layer code is running in a separate thread in a background service,
    such as `wearableListenerService`, it''s alright to block the calls and you can
    call the `await()` method on the `pendingresult` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Data Layer events can be monitored in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class that extends to `WearableListenerService`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An activity that implements `DataApi.DataListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both the facilities, we override the methods to handle the data events.
    Typically, we need to create the instance in both wearable and handheld apps.
    We can override the methods that we need for the application use case. Essentially,
    `WearableListenerService` has the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onDataChanged()`: Whenever this is created, deleted, or updated, the system
    will trigger this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMessageReceived()`: A message sent from a node triggers this event in the
    target node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCapabilityChanged()`: This event is triggered when a capability of an instance
    advertise becomes available on the network. We can check the nearby nodes by calling
    `isnearby().`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods are executed in a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `WearableListenerService`, we need to create a class that extends
    `WearableListenerService`. Listen for the events that you''re interested in, such
    as `onDataChanged()`. Declare an `intent` filter in your Android manifest to notify
    the system about your `WearableListenerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And register the service in the manifest as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `DATA_CHANGED` action replaces the previously recommended `BIND_LISTENER`
    action so that only specific events go through the path. We will understand more
    while we are working on a live project in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Capability API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This API helps in advertising the capabilities given by nodes in the wear network.
    Capabilities are local to the application. Utilizing the Data Layer and Message
    API, we can communicate with the nodes. To discover whether the target node is
    proficient in doing certain actions, we have to utilize the capability API, for
    instance on the off chance that we need to launch an activity from wear.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the capability API to your application, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an XML configuration file in the `res/values` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a resource named `android_wear_capabilities`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the capability that the device provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Java program for `voice_transcription`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the setup and designs to implement the chat application,
    let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile app implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile app for the chat application utilises Google's Firebase real-time
    database. Whenever a user sends a message, it reflects in the Firebase console
    in real time. Stories aside, now that we have all the screens up and ready, let's
    get started on writing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have the color that we are going to be using, let''s declare the colors
    in the colors value XML file under the `res` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the design, we have a curved edge button with a teal color background.
    To make a similar button, we need to create an XML resource in the `drawable`
    directory and call it as `buttonbg.xml`, which is basically a `selector` tag,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `selector` tag, we have an `item` tag that conveys the states; any
    normal button will have states, such as clicked, released, and default. Here,
    we have taken the default button background and pressed state and, using the `item`
    property tags, such as shape and corners, we are carving the button, as shown
    in the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the comfort of not having multiple changes, we will not refactor `MainActivity`
    into `LoginActivity`, rather we will consider `MainActivity` as the `LoginActivity`.
    Now, in `activity_main.xml`, let''s add the following code to the login screen
    design. For making the screen dynamic, we will be adding the code under `scrollview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for completing the login design, we need two input fields, one button
    instance, and one clickable link instance. The completed login screen code would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another activity and call it `RegistrationActivity`, which has
    a similar component requirement as the login activity, two input fields, and one
    button. The complete code for the XML layout looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a list of the user''s activity that will have a list of
    users. Call it as the `UsersList` activity and it will have one simple `ListView`
    and `TextView` for addressing the empty list. The complete XML code for `UsersListActivity`
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another activity for the chat screen. We will call it `ChatActivity`.
    Add the following code inside the activity XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to include a layout for editing the message. Create another XML file
    named `message_area.xml` inside the `layout` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, all our visual elements are in place to get started on writing our programming
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this following permission in the manifest file before we start working
    on our activity Java files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainActivity` file, let''s create all the instances and map them to
    their XML ID that we placed in `activity_main.xml`. Inside the `MainActivity`
    class, in the global scope, declare the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect all these instances to their XML visual elements, as follows,
    using the `findViewById()` method inside the `oncreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the user clicks on the Register link, it should take the user to
    the registration activity. Using `intent`, we will achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By clicking on the login button, it should do a network call, check whether
    the user exists in Firebase, and show the proper action on success. Before we
    write the login logic, let's write the registration logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In registration, activity connects all the components in the Java file using
    the `findViewById()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach a click listener to `mSubmit` and fetch the inputs in the `onClick`
    listener to make sure we are not passing an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Having a simple validation check will make the app strong from error prone
    situations. The validation and fetching input from the input fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We now need to reach Firebase for registering the user. Before we proceed, let's
    log in to the Firebase console, [https://console.firebase.google.com](https://console.firebase.google.com),
    and go to the project that we created before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the left-hand side menu, we will see the database option and choose
    it. In the rules tab, by default, the read and write authorizations are set to
    `null`. It would be ideal if you change it to `true`, but this is not suggested
    when you are writing a production application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When we set a read and write permission to true, essentially, we are telling
    Firebase anyone can read and write on the off chance that they have an endpoint
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the intricacies of making the URL public, we will use it in the project.
    Now, in the `mSubmit` click listener, we will be checking for a few validations
    and fetch the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: We should finish the code for the `mSubmit` click listener. After the `else
    if` instance of the password key field, let's make an else case for doing all
    the Firebase network operations. We will make the Firebase reference URL, push
    the child values, and utilize the `volley` network library. We will check whether
    the username exists and, on the off chance that it exists, we will allow the user
    to use the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Firebase endpoint URL for this project is [https://packt-wear.firebaseio.com](https://packt-wear.firebaseio.com)
    and the node name can be anything we wish to add for users. Let''s add [https://packt-wear.firebaseio.com/users](https://packt-wear.firebaseio.com/users);
    the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using `volley`, we can add the request queues and handle the network request
    in a very efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the complete registration activity class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's jump into `MainActivity` for user login logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, let''s create a class with static instances as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we have seen in the registration screen, let''s validate it inside
    the login screen using the `volley` library, let''s check whether the username
    exists. If a valid user with a valid password logs in, we will have to allow the
    user to the chat screen. The following code goes inside the login click listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after allowing the user to have a successful login, we need to show a
    list of users, ignoring the one who logged in. But the user should be able to
    see other lists of users. Now, let''s work on getting the list of users in `ListView`.
    Let''s connect the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, right in the `onCreate` method, we will initiate the `volley` and fetch
    the list of users, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we make our Firebase endpoint URL public, anybody can read and write to
    the endpoint if they have the URL. I am just using the URL and adding `.json`
    as an extension so that it will return the JSON result. Now, we need to write
    one last method for managing the success result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have completed one flow, which is `onBoarding` the user and showing
    a list of users who are available to chat. Now, it's time to work on the actual
    chatting logic. Let's start working on `ChatActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the message background, we will be adding two drawable resources files:
    `rounded_corner1.xml` and `rounded_corner2.xml`. Let''s add the XML code for the
    drawable resource files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For `rounded_corner2.xml`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the necessary instances for the Firebase chat activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On clicking the send button, using the `push()` method, we can update Firebase
    with the username and with the message that they sent across:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are callbacks we need to implement from the Firebase `addChildEventListener()`.
    In the `onChildAdded` method, we can show the messages added. The following code
    completes Firebase and adds the background for the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addMessageBox` method changes the sender and receiver message background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for `ChatActivity` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have the complete working chatting module for a mobile application. Now,
    let's write the Wear module for the chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Wear App implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of the wear module is that the wear device should receive new
    messages and show it in the app and users should be able to reply to that message
    from the wear device. In this, we will understand the classes and APIs for the
    Wear and mobile app to establish communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the boilerplate code that Android Studio has generated a code for the
    timer app. All we need to do is delete all the code and just keep the `onCreate()`
    method. Later, in the `activity_main.xml` file, let''s add the user interface
    that helps the user to chat. Here, I will have `Edittext` and `Textview`, and
    a button that sends the message to the mobile device. Let''s add the XML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the User Interface is ready. While we want to receive and send messages
    to mobiles, we need to write a service class that extends to `WearableListenerService`
    and the service class needs to be registered in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, register the `service` class in the manifest file within the application
    tag scope as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We are registering the `wear` service with the newest standard. Earlier, we
    had to register the service using the `BIND_LISTENER` API. Due to its inefficiency,
    it is deprecated. We have to use the previous `DATA_CHANGED` and `MESSAGE_RECEIVED`
    APIs, since they let the app listen to a particular path. Whereas the `BIND_LISTENER`
    API was listening to the wide range of system messages and that was a performance
    and battery level drawback. The following code illustrates the deprecated `BIND_LISTENER`
    registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering the service in the manifest, we can directly work `MainActivity`
    in the Wear module. Before we get started, make sure you have removed all the
    boilerplate code in `MainActivity` with only an `onCreate` method, which looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect all the XML components in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the interfaces from `GoogleApiClient` that helps in finding
    connected nodes and for handling failure scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After implementing `ConnectionCallbacks` and `OnConnectionFailedListener`,
    we have to override a few methods from this interface, namely, the `onConnected`,
    `onConnectionSuspended`, and `onConnectionFailed` methods. Most of our logic will
    be programmed in the `onConnected` method. Now, inside the `MainActivity` scope,
    we need to write a class that extends `BroadcastReciever` with the overriding
    `onReceive` method for listening to the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the Local Broadcast receiver in the `onCreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare `GoogleApiClient` and Node instances with `WEAR_PATH` for sending messages
    from wear that the mobile app will listen to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And initialize the `mGoogleApiclient` in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onConnected` method, we will use the wearable node API for fetching
    all the connected nodes. It can be a wear or mobile device, which is paired. Using
    the following code, we will know which wear devices are paired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to attach `clicklistener` to the `send` button instance for fetching
    the value from `edittext` and passing it to a method that sends the message to
    the mobile device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendMessage` method takes one string argument and sends the same string
    message to the connected node as bytes. Using `MessageAPI`, we will send the message
    to the mobile. The following code explains how this is achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s override the `onstart` and `onstop` methods for seeking help in connecting
    and disconnecting `GoogleAPIClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete wear module `MainActivity` code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The Wear module is ready to receive and send the message to the connected device.
    Now, we need to upgrade our mobile module to receive and send the messages to
    the wear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the mobile module and create a service class `WearListner` and override
    the `onMessageReceived` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, register this `WearListner` class in the manifest within the application
    tag scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now let's switch our work-scope to mobile module and add the following changes
    for deeplinking with wear and mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `ConnectionCallbacks` and `OnConnectionFailedListener` interfaces
    from the `GoogleApiClient` class in `ChatActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the methods from the `ConnectionCallbacks` and `OnConnectionFailedListener`
    interfaces similar to what we did for wear `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize `GoogleApiClient` in the `onCreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the broadcast receiver class within `ChatActivity` along with the string
    message we received. We need to pass it in the `addMessageBox` method, which we
    have written already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Register `MessageReciever` in the `onCreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After registering the broadcast receiver, write the `SendToDataLayerThread`
    class that extends to the `Thread` class for taking all the load in the separate
    thread, but on UI Thread. In the `void run` method, we will check for all the
    connected nodes and loop through the connected node. Once the connection is established,
    we will use `MessageAPI` to send the message as shown in the code. The Message
    API `sendMessage` method looks for certain parameters, such as `googleclient`,
    and the connected Node ID path, exactly what we registered in the wear manifest
    and the actual message as bytes. Using the `SendMessageResult` instance, we developers
    can make sure of whether the message fired from the device reached the nodes successfully
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to initialize the `sendtoDatalayer` thread in a the few of methods
    in `chatActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When `reference1` is updated with some child events, we need to add the message
    to the `sendToDatalayer` thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following callbacks for connecting and disconnecting the `GoogleApiClient`,
    Add the callbacks in the `ChatActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The chatting application is complete with wear and mobile interaction. Every
    message that chat activity receives is sent to wear and the reply from wear is
    updated to the mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat screen that shows the basic conversation between two users looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wear app screen will look as follows in a round dial watch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can utilize the Firebase real-time database
    as a chatting medium. We assembled a straightforward messaging application that
    can send a reply from a wear device. There is ample space to this project to enhance
    the elements of the project. We have seen how a chatting application can send
    and receive messages crosswise over wear and handheld devices. We have conceptualised
    a chatting application from scratch and we have set Data Layer events for the
    nodes to communicate with each other. The basic idea of Messaging API is to strengthen
    our understanding of wearable communication. Also the `GoogleApiClient` class
    plays a noteworthy part in Play services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand notifications, Firebase functions, and
    how push notifications can be triggered using Firebase functions.
  prefs: []
  type: TYPE_NORMAL
