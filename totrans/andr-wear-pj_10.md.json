["```java\n <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n```", "```java\n <meta-data\n     android:name=\"com.google.android.wearable.watchface.preview\"\n     android:resource=\"@drawable/preview_face\" />\n <meta-data\n     android:name=\n     \"com.google.android.wearable.watchface.preview_circular\"\n     android:resource=\"@drawable/preview_face_circular\" />\n\n```", "```java\n <intent-filter>\n     <action android:name=\"android.service.wallpaper.WallpaperService\" \n     />\n     <category\n         android:name=\n         \"com.google.android.wearable.watchface.category.WATCH_FACE\" />\n </intent-filter>\n\n```", "```java\npublic class PacktWatchFace extends CanvasWatchFaceService{\n\n@Override\npublic Engine onCreateEngine() {\n    return new Engine();\n}\n\nprivate class Engine extends CanvasWatchFaceService.Engine{\n\n  }\n}\n\n```", "```java\n<service\n    android:name=\".PacktWatchFace\"\n    android:label=\"PacktWatchface Wear\"\n    android:permission=\"android.permission.BIND_WALLPAPER\" >\n    <meta-data\n        android:name=\"android.service.wallpaper\"\n        android:resource=\"@xml/watch_face\" />\n    <meta-data\n        android:name=\"com.google.android.wearable.watchface.preview\"\n        android:resource=\"@mipmap/ic_launcher\" />\n    <meta-data\n        android:name=\n        \"com.google.android.wearable.watchface.preview_circular\"\n        android:resource=\"@mipmap/ic_launcher\" />\n\n    <intent-filter>\n        <action android:name=\n        \"android.service.wallpaper.WallpaperService\" />\n\n        <category android:name=\n        \"com.google.android.wearable.watchface.category.WATCH_FACE\" />\n    </intent-filter>\n</service>\n\n```", "```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<wallpaper xmlns:android=\"http://schemas.android.com/apk/res/android\"/>\n\n```", "```java\n<uses-permission android:name=\"com.google.android.permission.PROVIDE_BACKGROUND\" />\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n```", "```java\n//Essential instances\nprivate static Paint textPaint, boldTextPaint, backGround, whiteBackground, darkText;\nprivate static Calendar calendar;\nprivate static final long INTERACTIVE_UPDATE_RATE_MS = TimeUnit.SECONDS.toMillis(1);\nprivate static final int MSG_UPDATE_TIME = 0;\n\n```", "```java\nbackGround = new Paint() {{ setARGB(255, 120, 190, 0); }};\ntextPaint = createPaint(false, 40);\nboldTextPaint = createPaint(true, 40);\nwhiteBackground = createPaint(false, 0);\ndarkText = new Paint() {{ setARGB(255, 50, 50, 50); setTextSize(18); }};\n\n```", "```java\nprivate Paint createPaint(final boolean bold, final int fontSize) {\n    final Typeface typeface = (bold) ? Typeface.DEFAULT_BOLD : \n    Typeface.DEFAULT;\n\n    return new Paint()\n    {{\n        setARGB(255, 255, 255, 255);\n        setTextSize(fontSize);\n        setTypeface(typeface);\n        setAntiAlias(true);\n    }};\n}\n\n```", "```java\nsetWatchFaceStyle(new WatchFaceStyle.Builder(PacktWatchFace.this)\n    .setAcceptsTapEvents(true)\n    .build());\n\n```", "```java\n@Override\npublic void onTapCommand(\n        @TapType int tapType, int x, int y, long eventTime) {\n    switch (tapType) {\n        case WatchFaceService.TAP_TYPE_TAP:\n            // Handle the tap\n            Toast.makeText(PacktWatchFace.this, \"Tapped\", \n            Toast.LENGTH_SHORT).show();\n            break;\n\n        // There are other cases, not mentioned here. <a \n        href=\"https://developer.android.com/training/wearables/watch-\n        faces/interacting.html\">Read Android guide</a>\n        default:\n            super.onTapCommand(tapType, x, y, eventTime);\n            break;\n    }\n}\n\n```", "```java\n@Override\npublic void onApplyWindowInsets(WindowInsets insets) {\n    super.onApplyWindowInsets(insets);\n    boolean isRound = insets.isRound();\n\n    if(isRound) {\n        // Render the Face in round mode.\n    } else {\n        // Render the Face in square (or rectangular) mode.\n    }\n}\n\n```", "```java\n  @Override\n        public void onDraw(Canvas canvas, Rect bounds) {\n            calendar = Calendar.getInstance();\n\n            canvas.drawRect(0, 0, bounds.width(), bounds.height(), \n            whiteBackground); // Entire background Canvas\n            canvas.drawRect(0, 60, bounds.width(), 240, backGround);\n\n            canvas.drawText(new SimpleDateFormat(\"cccc\")\n            .format(calendar.getTime()), 130, 120, textPaint);\n\n            // String time = String.format\n            (\"%02d:%02d\", mTime.hour, mTime.minute);\n            String time = new SimpleDateFormat\n            (\"hh:mm a\").format(calendar.getTime());\n            canvas.drawText(time, 130, 170, boldTextPaint);\n\n            String date = new SimpleDateFormat\n            (\"MMMM dd, yyyy\").format(calendar.getTime());\n            canvas.drawText(date, 150, 200, darkText);\n        }\n\n```", "```java\n@Override\npublic void onVisibilityChanged(boolean visible) {\n    super.onVisibilityChanged(visible);\n\n    if (visible) {\n        registerReceiver();\n        // Update time zone in case it changed while we weren't \n        visible.\n        calendar = Calendar.getInstance();\n    } else {\n        unregisterReceiver();\n    }\n\n    // Whether the timer should be running depends on whether we're \n    visible (as well as\n    // whether we're in ambient mode), so we may need to start or stop \n    the timer.\n    updateTimer();\n}\n\nprivate void registerReceiver() {\n    if (mRegisteredTimeZoneReceiver) {\n        return;\n    }\n    mRegisteredTimeZoneReceiver = true;\n    IntentFilter filter = new \n    IntentFilter(Intent.ACTION_TIMEZONE_CHANGED);\n    PacktWatchFace.this.registerReceiver(mTimeZoneReceiver, filter);\n}\n\nprivate void unregisterReceiver() {\n    if (!mRegisteredTimeZoneReceiver) {\n        return;\n    }\n    mRegisteredTimeZoneReceiver = false;\n    PacktWatchFace.this.unregisterReceiver(mTimeZoneReceiver);\n}\n\n/**\n * Starts the {@link #mUpdateTimeHandler} timer if it should be running and isn't currently\n * or stops it if it shouldn't be running but currently is.\n */\nprivate void updateTimer() {\n    mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n    if (shouldTimerBeRunning()) {\n        mUpdateTimeHandler.sendEmptyMessage(MSG_UPDATE_TIME);\n    }\n}\n\n```", "```java\nprivate boolean shouldTimerBeRunning() {\n    return isVisible() && !isInAmbientMode();\n}\n\n```", "```java\n private void handleUpdateTimeMessage() {\n        invalidate();\n        if (shouldTimerBeRunning()) {\n            long timeMs = System.currentTimeMillis();\n            long delayMs = INTERACTIVE_UPDATE_RATE_MS\n                    - (timeMs % INTERACTIVE_UPDATE_RATE_MS);\n            mUpdateTimeHandler.sendEmptyMessageDelayed(MSG_UPDATE_TIME, \n            delayMs);\n        }\n    }\n}\n\n```", "```java\nprivate static class EngineHandler extends Handler {\n    private final WeakReference<Engine> mWeakReference;\n\n    public EngineHandler(PacktWatchFace.Engine reference) {\n        mWeakReference = new WeakReference<>(reference);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n        PacktWatchFace.Engine engine = mWeakReference.get();\n        if (engine != null) {\n            switch (msg.what) {\n                case MSG_UPDATE_TIME:\n                    engine.handleUpdateTimeMessage();\n                    break;\n            }\n        }\n    }\n}\n\n```", "```java\nbitmapObj = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher);\n\n// And set the bitmap object in onDraw methods canvas            canvas.drawBitmap(bob, 0, 40, null);\n\n```", "```java\n/**\n * Created by ashok.kumar on 27/04/17.\n */\n\npublic class PacktWatchFace extends CanvasWatchFaceService{\n\n    //Essential instances\n    private static Paint textPaint, boldTextPaint, backGround, \n    whiteBackground, darkText;\n    private static Calendar calendar;\n    private static final long INTERACTIVE_UPDATE_RATE_MS = \n    TimeUnit.SECONDS.toMillis(1);\n    private static final int MSG_UPDATE_TIME = 0;\n\n    @Override\n    public Engine onCreateEngine() {\n        return new Engine();\n    }\n\n    private class Engine extends CanvasWatchFaceService.Engine {\n\n        final Handler mUpdateTimeHandler = new EngineHandler(this);\n\n        final BroadcastReceiver mTimeZoneReceiver = new \n        BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                calendar = Calendar.getInstance();\n            }\n        };\n        boolean mRegisteredTimeZoneReceiver = false;\n\n        boolean mLowBitAmbient;\n\n        @Override\n        public void onCreate(SurfaceHolder holder) {\n            super.onCreate(holder);\n\n            setWatchFaceStyle(new WatchFaceStyle.Builder\n            (PacktWatchFace.this)\n                    .setCardPeekMode(WatchFaceStyle.PEEK_MODE_SHORT)\n                    .setBackgroundVisibility\n                    (WatchFaceStyle.BACKGROUND_VISIBILITY_INTERRUPTIVE)\n                    .setShowSystemUiTime(false)\n                    .build());\n\n            backGround = new Paint() {{ setARGB(255, 120, 190, 0); }};\n            textPaint = createPaint(false, 40);\n            boldTextPaint = createPaint(true, 40);\n            whiteBackground = createPaint(false, 0);\n            darkText = new Paint() \n            {{ setARGB(255, 50, 50, 50); setTextSize(18); }};\n\n            setWatchFaceStyle(new WatchFaceStyle.Builder\n            (PacktWatchFace.this)\n                    .setAcceptsTapEvents(true)\n                    .build());\n\n            calendar = Calendar.getInstance();\n        }\n\n        private Paint createPaint\n        (final boolean bold, final int fontSize) {\n            final Typeface typeface = \n            (bold) ? Typeface.DEFAULT_BOLD : Typeface.DEFAULT;\n\n            return new Paint()\n            {{\n                setARGB(255, 255, 255, 255);\n                setTextSize(fontSize);\n                setTypeface(typeface);\n                setAntiAlias(true);\n            }};\n        }\n\n        @Override\n        public void onTapCommand(\n                @TapType int tapType, int x, int y, long eventTime) {\n            switch (tapType) {\n                case WatchFaceService.TAP_TYPE_TAP:\n                    // Handle the tap\n                    Toast.makeText(PacktWatchFace.this, \n                    \"Tapped\", Toast.LENGTH_SHORT).show();\n                    break;\n\n                default:\n                    super.onTapCommand(tapType, x, y, eventTime);\n                    break;\n            }\n        }\n\n        @Override\n        public void onDestroy() {\n            mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n            super.onDestroy();\n        }\n\n        @Override\n        public void onPropertiesChanged(Bundle properties) {\n            super.onPropertiesChanged(properties);\n            mLowBitAmbient = properties.getBoolean\n            (PROPERTY_LOW_BIT_AMBIENT, false);\n        }\n\n        @Override\n        public void onTimeTick() {\n            super.onTimeTick();\n            invalidate();\n        }\n\n        @Override\n        public void onAmbientModeChanged(boolean inAmbientMode) {\n            super.onAmbientModeChanged(inAmbientMode);\n            if (inAmbientMode) {\n                if (mLowBitAmbient) {\n                }\n                invalidate();\n            }\n\n            updateTimer();\n        }\n\n        @Override\n        public void onDraw(Canvas canvas, Rect bounds) {\n            calendar = Calendar.getInstance();\n\n            canvas.drawRect(0, 0, bounds.width(), bounds.height(), \n            whiteBackground); // Entire background Canvas\n            canvas.drawRect(0, 60, bounds.width(), 240, backGround);\n\n            canvas.drawText(new SimpleDateFormat(\"cccc\")\n            .format(calendar.getTime()), 130, 120, textPaint);\n\n            // String time = String.format(\"%02d:%02d\", mTime.hour, \n            mTime.minute);\n            String time = new SimpleDateFormat\n            (\"hh:mm a\").format(calendar.getTime());\n            canvas.drawText(time, 130, 170, boldTextPaint);\n\n            String date = new SimpleDateFormat\n            (\"MMMM dd, yyyy\").format(calendar.getTime());\n            canvas.drawText(date, 150, 200, darkText);\n        }\n\n        @Override\n        public void onVisibilityChanged(boolean visible) {\n            super.onVisibilityChanged(visible);\n\n            if (visible) {\n                registerReceiver();\n                calendar = Calendar.getInstance();\n            } else {\n                unregisterReceiver();\n            }\n\n            updateTimer();\n        }\n\n        private void registerReceiver() {\n            if (mRegisteredTimeZoneReceiver) {\n                return;\n            }\n            mRegisteredTimeZoneReceiver = true;\n            IntentFilter filter = new IntentFilter\n            (Intent.ACTION_TIMEZONE_CHANGED);\n            PacktWatchFace.this.registerReceiver\n            (mTimeZoneReceiver, filter);\n        }\n\n        private void unregisterReceiver() {\n            if (!mRegisteredTimeZoneReceiver) {\n                return;\n            }\n            mRegisteredTimeZoneReceiver = false;\n            PacktWatchFace.this.unregisterReceiver(mTimeZoneReceiver);\n        }\n\n        private void updateTimer() {\n            mUpdateTimeHandler.removeMessages(MSG_UPDATE_TIME);\n            if (shouldTimerBeRunning()) {\n                mUpdateTimeHandler.sendEmptyMessage(MSG_UPDATE_TIME);\n            }\n        }\n\n        private boolean shouldTimerBeRunning() {\n            return isVisible() && !isInAmbientMode();\n        }\n\n        private void handleUpdateTimeMessage() {\n            invalidate();\n            if (shouldTimerBeRunning()) {\n                long timeMs = System.currentTimeMillis();\n                long delayMs = INTERACTIVE_UPDATE_RATE_MS\n                        - (timeMs % INTERACTIVE_UPDATE_RATE_MS);\n                mUpdateTimeHandler\n                .sendEmptyMessageDelayed(MSG_UPDATE_TIME, delayMs);\n            }\n        }\n    }\n\n    private static class EngineHandler extends Handler {\n        private final WeakReference<Engine> mWeakReference;\n\n        public EngineHandler(PacktWatchFace.Engine reference) {\n            mWeakReference = new WeakReference<>(reference);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            PacktWatchFace.Engine engine = mWeakReference.get();\n            if (engine != null) {\n                switch (msg.what) {\n                    case MSG_UPDATE_TIME:\n                        engine.handleUpdateTimeMessage();\n                        break;\n                }\n            }\n        }\n    }\n}\n\n```", "```java\n mHourPaint = new Paint();\n mHourPaint.setColor(mWatchHandColor);\n mHourPaint.setStrokeWidth(HOUR_STROKE_WIDTH);\n mHourPaint.setAntiAlias(true);\n mHourPaint.setStrokeCap(Paint.Cap.ROUND);\n mHourPaint.setShadowLayer(SHADOW_RADIUS, 0, 0, mWatchHandShadowColor);\n\n mMinutePaint = new Paint();\n mMinutePaint.setColor(mWatchHandColor);\n mMinutePaint.setStrokeWidth(MINUTE_STROKE_WIDTH);\n mMinutePaint.setAntiAlias(true);\n mMinutePaint.setStrokeCap(Paint.Cap.ROUND);\n mMinutePaint.setShadowLayer(SHADOW_RADIUS, 0, 0, \n mWatchHandShadowColor);\n\n mSecondPaint = new Paint();\n mSecondPaint.setColor(mWatchHandHighlightColor);\n mSecondPaint.setStrokeWidth(SECOND_TICK_STROKE_WIDTH);\n mSecondPaint.setAntiAlias(true);\n mSecondPaint.setStrokeCap(Paint.Cap.ROUND);\n mSecondPaint.setShadowLayer(SHADOW_RADIUS, 0, 0, \n mWatchHandShadowColor);\n\n mTickAndCirclePaint = new Paint();\n mTickAndCirclePaint.setColor(mWatchHandColor);\n mTickAndCirclePaint.setStrokeWidth(SECOND_TICK_STROKE_WIDTH);\n mTickAndCirclePaint.setAntiAlias(true);\n mTickAndCirclePaint.setStyle(Paint.Style.STROKE);\n mTickAndCirclePaint.setShadowLayer(SHADOW_RADIUS, 0, 0, \n mWatchHandShadowColor);\n\n```"]