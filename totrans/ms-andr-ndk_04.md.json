["```java\nclass iMountPoint: public iIntrusiveCounter\n{\npublic:\n```", "```java\n  virtual bool FileExists( const std::string& VirtualName ) const = 0;\n```", "```java\n  virtual std::string MapName( const std::string& VirtualName ) const = 0;\n```", "```java\n  virtual clPtr<iRawFile> CreateReader( const std::string& VirtualName ) const = 0;\n```", "```java\n  virtual void SetName( const std::string& N ) { FName = N; }\n  virtual std::string GetName() const { return FName; }\nprivate:\n  std::string FName;\n};\n```", "```java\nclPtr<iIStream> CreateReader( const std::string& FileName ) const;\n```", "```java\nvoid Mount( const std::string& PhysicalPath );\n```", "```java\nstd::string VirtualNameToPhysical(\n  const std::string& Path ) const;\n```", "```java\n  bool FileExists( const std::string& Name ) const;\n```", "```java\nprivate:\n  clPtr<iMountPoint> FindMountPointByName( const std::string& ThePath );\n  void AddMountPoint( const clPtr<iMountPoint>& MP );\n  clPtr<iMountPoint> FindMountPoint( const std::string& FileName ) const;\n```", "```java\n  std::vector< clPtr<iMountPoint> > FMountPoints;\n};\n```", "```java\nauto f = g_FS->CreateReader( \"test.txt\" );\n```", "```java\nclPtr<iIStream> clFileSystem::CreateReader(\n  const std::string& FileName ) const\n{\n  std::string Name = Arch_FixFileName( FileName );\n  clPtr<iMountPoint> MountPoint = FindMountPoint( Name );\n```", "```java\n  if ( !MountPoint ) { return make_intrusive<clFileMapper>( make_intrusive<clNullRawFile>() ); }\n  return make_intrusive<clFileMapper>( MountPoint->CreateReader( Name ) );\n}\n```", "```java\nclPtr<iMountPoint> clFileSystem::FindMountPoint( const std::string& FileName ) const\n{\n  if ( FMountPoints.empty() )\n  {\n    return nullptr;\n  }\n  if ( ( *FMountPoints.begin() )->FileExists( FileName ) )\n  {\n    return ( *FMountPoints.begin() );\n  }\n```", "```java\n  for ( auto i = FMountPoints.rbegin();\n    i != FMountPoints.rend(); ++i )\n  {\n    if ( ( *i )->FileExists( FileName ) )\n    {\n      return ( *i );\n    }\n  }\n  return *( FMountPoints.begin() );\n}\n```", "```java\nbool clFileSystem::FileExists( const std::string& Name ) const\n{\n  if ( Name.empty() || Name == \".\" ) { return false; }\n  clPtr<iMountPoint> MP = FindMountPoint( Name );\n  return MP ? MPD->FileExists( Name ) : false;\n}\n```", "```java\nstd::string clFileSystem::VirtualNameToPhysical(\n  const std::string& Path ) const\n{\n  if ( FS_IsFullPath( Path ) ) { return Path; }\n  clPtr<iMountPoint> MP = FindMountPoint( Path );\n  return ( !MP ) ? Path : MP->MapName( Path );\n}\n```", "```java\nvoid clFileSystem::AddMountPoint( const clPtr<iMountPoint>& MP )\n{\n  if ( !MP ) { return; }\n  if ( std::find( FMountPoints.begin(), FMountPoints.end(), MP ) == FMountPoints.end() )\n  {\n    FMountPoints.push_back( MP );\n  }\n}\n```", "```java\nvoid clFileSystem::Mount( const std::string& PhysicalPath )\n{\n  clPtr<iMountPoint> MP;\n```", "```java\n  if ( Str::EndsWith( PhysicalPath, \".apk\" ) || Str::EndsWith( PhysicalPath, \".zip\" ) )\n  {\n    auto Reader = make_intrusive<clArchiveReader>();\n    bool Result = Reader->OpenArchive( CreateReader( PhysicalPath ) );\n    MP = make_intrusive<clArchiveMountPoint>( Reader );\n  }\n  else\n```", "```java\n  {\n    #if !defined( OS_ANDROID )\n      if ( !FS_FileExistsPhys( PhysicalPath ) )\n      return;\n    #endif\n      MP = make_intrusive<clPhysicalMountPoint>(PhysicalPath );\n  }\n```", "```java\n  MP->SetName( PhysicalPath );\n  AddMountPoint( MP );\n}\n```", "```java\nclass iIStream: public iIntrusiveCounter\n{\npublic:\n```", "```java\n  virtual std::string GetVirtualFileName() const = 0;\n  virtual std::string GetFileName() const = 0;\n```", "```java\n  virtual void   Seek( const uint64 Position ) = 0;\n  virtual uint64 GetSize() const = 0;\n  virtual uint64 GetPos() const = 0;\n  virtual bool   Eof() const = 0;\n```", "```java\n  virtual uint64 Read( void* Buf, const uint64 Size ) = 0;\n```", "```java\n  virtual const ubyte* MapStream() const = 0;\n```", "```java\n  virtual const ubyte* MapStreamFromCurrentPos() const = 0;\n};\n```", "```java\nclass clFileMapper: public iIStream\n{\npublic:\n```", "```java\n  explicit FileMapper( clPtr<iRawFile> File ):\n    FFile( File ), FPosition( 0 ) {}\n  virtual ~FileMapper() {}\n```", "```java\n  virtual std::string GetVirtualFileName() const\n  { return FFile->GetVirtualFileName(); }\n  virtual std::string GetFileName() const\n  { return FFile->GetFileName(); }\n```", "```java\n  virtual uint64 Read( void* Buf, uint64 Size )\n  {\n    uint64 RealSize = ( Size > GetBytesLeft() ) ? GetBytesLeft() : Size;\n    if ( !RealSize ) { return 0; }\n    memcpy( Buf, ( FFile->GetFileData() + FPosition ),static_cast<size_t>( RealSize ) );\n    FPosition += RealSize;\n    return RealSize;\n  }\n```", "```java\n  virtual void Seek( const uint64 Position)\n  { FPosition = Position; }\n  virtual uint64 GetSize() const\n  { return FFile->GetFileSize(); }\n  virtual bool Eof() const\n  { return ( FPosition >= FFile->GetFileSize() ); }\n  virtual const ubyte* MapStream() const\n  { return FFile->GetFileData(); }\n  virtual const ubyte* MapStreamFromCurrentPos() const\n  { return ( FFile->GetFileData() + FPosition ); }\n```", "```java\nprivate:\n  clPtr<iRawFile> FFile;\n  uint64 FPosition;\n};\n```", "```java\nclass iRawFile: public iIntrusiveCounter\n{\npublic:\n  iRawFile() {}\n  virtual ~iRawFile() {}\n```", "```java\n  std::string GetVirtualFileName() const\n  { return FVirtualFileName; }\n  std::string  GetFileName() const\n  { return FFileName; }\n    void SetVirtualFileName( const std::string& VFName )\n    { FVirtualFileName = VFName; }\n    void SetFileName( const std::string& FName )\n    { FFileName = FName; }\n```", "```java\n    virtual const ubyte* GetFileData() const = 0;\n    virtual uint64 GetFileSize() const = 0;\n```", "```java\n  private:\n    std::string    FFileName;\n    std::string    FVirtualFileName;\n  };\n```", "```java\nclass clRawFile: public iRawFile\n{\npublic:\n  RawFile() {}\n  virtual ~RawFile() { Close(); }\n```", "```java\n  bool Open( const std::string& FileName,\n    const std::string& VirtualFileName )\n  {\n    SetFileName( FileName );\n    SetVirtualFileName( VirtualFileName );\n    FSize = 0;\n    FFileData = nullptr;\n```", "```java\n    #ifdef _WIN32\n      FMapFile = CreateFileA( FFileName.c_str(), GENERIC_READ,\n        FILE_SHARE_READ, nullptr, OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,\n        nullptr );\n```", "```java\n      FMapHandle = CreateFileMapping( FMapFile,\n        nullptr, PAGE_READONLY, 0, 0, nullptr );\n      FFileData = ( ubyte* )MapViewOfFile( FMapHandle, FILE_MAP_READ, 0, 0, 0 );\n```", "```java\n      if ( !FFileData )\n      {\n        CloseHandle( ( HANDLE )FMapHandle );\n        return false;\n      }\n```", "```java\n      DWORD dwSizeLow = 0, dwSizeHigh = 0;\n      dwSizeLow = ::GetFileSize( FMapFile, &dwSizeHigh );\n      FSize = ( ( uint64 )dwSizeHigh << 32 )\n        | ( uint64 )dwSizeLow;\n```", "```java\n    #else\n      FFileHandle = open( FileName.c_str(), O_RDONLY );\n      struct stat FileInfo;\n```", "```java\n      if ( !fstat( FFileHandle, &FileInfo ) )\n      {\n        FSize = static_cast<uint64_t>( FileInfo.st_size );\n```", "```java\n      if ( FSize )\n        FFileData = ( uint8_t* )( mmap( nullptr, FSize, PROT_READ, MAP_PRIVATE, FFileHandle, 0 ) );\n      }\n```", "```java\n      close( FFileHandle );\n    #endif\n      return true;\n  }\n```", "```java\n  void Close()\n  {\n```", "```java\n    #ifdef _WIN32\n      if ( FFileData  ) { UnmapViewOfFile( FFileData ); }\n      if ( FMapHandle ) { CloseHandle( (HANDLE)FMapHandle ); }\n      CloseHandle( ( HANDLE )FMapFile );\n```", "```java\n    #else\n      if ( FFileData )\n      {\n        munmap( reinterpret_cast<void*>( FFileData ), FSize );\n      }\n    #endif\n  }\n```", "```java\n  virtual const ubyte* GetFileData() const { return FFileData; }\n  virtual uint64       GetFileSize() const { return FSize; }\nprivate:\n  #ifdef _WIN32\n    HANDLE    FMapFile;\n    HANDLE    FMapHandle;\n  #else\n    int       FFileHandle;\n  #endif\n    ubyte*    FFileData;\n    uint64    FSize;\n};\n```", "```java\nclass clPhysicalMountPoint: public iMountPoint\n{\npublic:\n```", "```java\n  clPhysicalMountPoint( const std::string& PhysicalName ):FPhysicalName( PhysicalName )\n  {\n    Str_AddTrailingChar( &FPhysicalName, PATH_SEPARATOR );\n  }\n  virtual ~PhysicalMountPoint() {}\n```", "```java\n  virtual bool FileExists( const std::string& VirtualName ) const override\n  {\n    return FS_FileExistsPhys( MapName( VirtualName ) );\n  }\n\n```", "```java\n  virtual std::string  MapName( const std::string& VirtualName )const override\n  {\n    return FS_IsFullPath( VirtualName ) ? VirtualName : ( FPhysicalName + VirtualName );\n  }\n```", "```java\n  virtual clPtr<iRawFile> CreateReader(\n    const std::string& VirtualName ) const override\n  {\n    std::string PhysName = MapName( VirtualName );\n    auto File = make_intrusive<clRawFile>();\n    if ( File->Open( FS_ValidatePath( PhysName ), VirtualName ) ) { return File; }\n    return make_intrusive<clNullRawFile>();\n  }\n```", "```java\nprivate:\n  std::string FPhysicalName;\n};\n```", "```java\ninline bool FS_IsFullPath( const std::string& Path )\n{\n  return ( Path.find( \":\\\\\" ) != std::string::npos ||\n  #if !defined( _WIN32 )\n    ( Path.length() && Path[0] == '/' ) ||\n  #endif\n    Path.find( \":/\" )  != std::string::npos ||\n    Path.find( \".\\\\\" ) != std::string::npos );\n}\n```", "```java\ninline std::string FS_ValidatePath( const std::string& PathName )\n{\n  std::string Result = PathName;\n  for ( size_t i = 0; i != Result.length(); ++i )\n    if ( Result[i] == '/' || Result[i] == '\\\\' )\n    {\n      Result[i] = PATH_SEPARATOR;\n    }\n  return Result;\n}\n```", "```java\ninline bool FS_FileExistsPhys( const std::string& PhysicalName )\n{\n  #ifdef _WIN32\n    struct _stat buf;\n    int Result = _stat( FS_ValidatePath( PhysicalName ).c_str(),\n      &buf );\n  #else\n    struct stat buf;\n    int Result = stat( FS_ValidatePath( PhysicalName ).c_str(),\n      &buf );\n  #endif\n    return Result == 0;\n}\n```", "```java\n#if defined( _WIN32 )\n  const char PATH_SEPARATOR = '\\\\';\n#else\n  const char PATH_SEPARATOR = '/';\n#endif\n```", "```java\nclass clMemRawFile: public iRawFile\n{\npublic:\n```", "```java\n  clMemRawFile( const uint8_t* BufPtr, size_t BufSize, bool OwnsBuffer )\n  : FOwnsBuffer( OwnsBuffer )\n  , FBuffer( BufPtr )\n  , FBufferSize( BufSize )\n  {}\n```", "```java\n  virtual const uint8_t* GetFileData() const override\n  { return FBuffer; }\n  virtual uint64_t GetFileSize() const override\n  { return FBufferSize; }\nprivate:\n  const uint8_t* FBuffer;\n  size_t FBufferSize;\n};\n```", "```java\nclass clAliasMountPoint: public iMountPoint\n{\npublic:\n  explicit clAliasMountPoint( const clPtr<iMountPoint>& Src )\n  : Falias(), FMP( Src )\n  {}\n  virtual bool FileExists( const std::string& VirtualName ) const { return FMP->FileExists( FAlias + VirtualName ); }\n  virtual std::string MapName( const std::string& VirtualName ) const { return FMP->MapName( FAlias + VirtualName ); }\n  virtual clPtr<iRawFile> CreateReader( const std::string& VirtualName ) const { return FMP->CreateReader( FAlias + VirtualName ); }\nprivate:\n  std::string FAlias;\n  clPtr<iMountPoint> FMP;\n};\n```", "```java\nvoid clFileSystem::AddAlias( const std::string& SrcPath, const std::string& Alias )\n{\n  if (clPtr<iMountPoint> MP = FindMountPointByName( SrcPath ) ) AddMountPoint(new AliasMountPoint( MP, Alias ) );\n}\n```", "```java\nclass iOStream: public iIntrusiveCounter\n{\npublic:\n  iOStream() {};\n  virtual ~iOStream() {};\n  virtual std::string GetFileName() const = 0;\n  virtual void   Seek( const uint64 Position ) = 0;\n  virtual uint64 GetFilePos() const = 0;\n  virtual uint64 Write(const void* Buf, const uint64 Size) = 0;\n};\n```", "```java\nclass clMemFileWriter: public iOStream\n{\npublic:\n```", "```java\n  clMemFileWriter()\n  : FBlob( make_intrusive<clBlob>() )\n  , FFileName()\n  , FPosition( 0 )\n  {}\n  explicit clMemFileWriter( const clPtr<clBlob>& Blob )\n  : FBlob( Blob )\n  , FFileName()\n  , FPosition( 0 )\n  {}\n```", "```java\n  virtual void Seek( const uint64 Position )\n  {\n    FPosition = ( Position > FBlob->GetSize() ) ? FBlob->GetSize() - 1 : Position;\n  }\n```", "```java\n  virtual uint64_t Write( const void* Buf, uint64_t Size ) override\n  {\n    return FBlob->AppendBytes( Buf,static_cast<size_t>( Size ) );\n  }\n```", "```java\nclass clArchiveReader: public iIntrusiveCounter\n{\nprivate:\n```", "```java\n  struct sFileInfo\n  {\n    /// offset to the file\n    uint64 FOffset;\n    /// uncompressed file size\n    uint64 FSize;\n    /// compressed file size\n    uint64 FCompressedSize;\n    /// Compressed data\n    void* FSourceData;\n  };\n```", "```java\n  std::vector<sFileInfo> FFileInfos;\n  std::vector<std::string> FFileNames;\n  std::vector<std::string> FRealFileNames;\n  mutable std::map<std::string, int> FFileInfoIdx;\n  std::map<int, const void*> FExtractedFromArchive;\n```", "```java\n  clPtr<iIStream> FSourceFile;\npublic:\n  clArchiveReader()\n  : FFileInfos()\n  , FRealFileNames()\n  , FFileInfoIdx()\n  , FSourceFile()\n  {}\n  virtual ~clArchiveReader()\n  { CloseArchive(); }\n```", "```java\n  bool OpenArchive( const clPtr<iIStream>& Source )\n  {\n   if ( !Source ) { return false; }\n   if ( !CloseArchive() ) { return false; }\n   if ( !Source->GetSize() ) { return false ; }\n   FSourceFile = Source;\n   return Enumerate_ZIP();\n  }\n  bool CloseArchive()\n  {\n    FFileInfos.clear();\n    FFileInfoIdx.clear();\n    FFileNames.clear();\n    FRealFileNames.clear();\n    ClearExtracted();\n    FSourceFile = nullptr;\n    return true;\n  }\n```", "```java\n  bool ExtractSingleFile( const std::string& FileName,\n    const std::string& Password, std::atomic<int>* AbortFlag,\n    std::atomic<float>* Progress, const clPtr<iOStream>& Out );\n```", "```java\n  bool FileExists( const std::string& FileName ) const\n  {\n    return GetFileIdx( FileName ) > -1;\n  }\n  uint64 GetFileSizeIdx( const std::string& FileName ) const\n  {\n    return ( Idx > -1 ) ? FFileInfos[ Idx ].FSize : 0;\n  }\n```", "```java\n  const void* GetFileDataIdx( int Idx )\n  {\n    if ( Idx <= -1 ) { return nullptr; }\n    if ( FExtractedFromArchive.count( Idx ) > 0 )\n    {\n      return FExtractedFromArchive[Idx]->GetDataConst();\n    }\n```", "```java\n    auto Blob = GetFileData_ZIP( Idx );\n    if ( Blob )\n    {\n      FExtractedFromArchive[Idx] = Blob;\n      return Blob->GetDataConst();\n    }\n    return nullptr;\n  }\n```", "```java\n  int GetFileIdx( const std::string& FileName ) const\n  {\n    return ( FFileInfoIdx.count( FileName ) > 0 ) ? FFileInfoIdx[ FileName ] : -1;\n  }\n```", "```java\n  size_t GetNumFiles() const { return FFileInfos.size(); }\n  std::string GetFileName( int Idx ) const\n  { return FFileNames[Idx]; }\n```", "```java\nprivate:\n  bool Enumerate_ZIP();\n  const void* GetFileData_ZIP( size_t Idx );\n```", "```java\n  void ClearExtracted()\n  {\n    FExtractedFromArchive.clear();\n  }\n```", "```java\n  clPtr<clBlob> clArchiveReader::GetFileData_ZIP( int Idx )\n  {\n    if ( FExtractedFromArchive.count( Idx ) > 0 )\n    {\n      return FExtractedFromArchive[ Idx ];\n    }\n```", "```java\n    clPtr<clMemFileWriter> Out =\n      clFileSystem::CreateMemWriter( \"mem_blob\",\n        FFileInfos[ Idx ].FSize );\n```", "```java\n    if ( ExtractSingleFile( FRealFileNames[ Idx ], \"\",\n      nullptr, nullptr, Out ) )\n    {\n```", "```java\n      return Out->GetBlob();\n    }\n    return make_intrusive<clBlob>();\n  }\n```", "```java\n  bool clArchiveReader::ExtractSingleFile(\n    const std::string& FileName, const std::string& Password,\n    std::atomic<int>* AbortFlag, std::atomic<float>* Progress,\n    const clPtr<iOStream>& Out )\n  {\n    std::string ZipName = FileName;\n    std::replace( ZipName.begin(), ZipName.end(), '\\\\', '/' );\n    clPtr<iIStream> TheSource = FSourceFile;\n    FSourceFile->Seek( 0 );\n```", "```java\n    zlib_filefunc64_def ffunc;\n    fill_functions( TheSource.GetInternalPtr(), &ffunc );\n    unzFile UnzipFile = unzOpen2_64( \"\", &ffunc );\n    if ( unzLocateFile(UnzipFile, ZipName.c_str(), 0) != UNZ_OK )\n    {\n```", "```java\n      return false;\n    }\n```", "```java\n    int ErrorCode = ExtractCurrentFile_ZIP( UnzipFile,\n      Password.empty() ? nullptr : Password.c_str(),\n      AbortFlag, Progress, Out );\n    unzClose( UnzipFile );\n    return ErrorCode == UNZ_OK;\n  }\n```", "```java\n  int ExtractCurrentFile_ZIP( unzFile UnzipFile,\n    const char* Password, std::atomic<int>* AbortFlag,\n    std::atomic<float>* Progress, const clPtr<iOStream>& Out )\n  {\n    char FilenameInzip[1024];\n    unz_file_info64 FileInfo;\n```", "```java\n    int ErrorCode = unzGetCurrentFileInfo64( UnzipFile,\n      &FileInfo, FilenameInzip, sizeof( FilenameInzip ),\n      nullptr, 0, nullptr, 0 );\n    if ( ErrorCode != UNZ_OK ) { return ErrorCode; }\n```", "```java\n    ErrorCode = unzOpenCurrentFilePassword( uf, password );\n    if ( ErrorCode != UNZ_OK ) { return err; }\n```", "```java\n    uint64_t FileSize = ( uint64_t )FileInfo.uncompressed_size;\n```", "```java\n    Out->Reserve( ( size_t )FileSize );\n    unsigned char Buffer[ WRITEBUFFERSIZE ];\n    uint64_t TotalBytes = 0;\n    int BytesRead = 0;\n    do\n    {\n```", "```java\n      if ( AbortFlag && *AbortFlag ) break;\n\n```", "```java\n      BytesRead = unzReadCurrentFile( UnzipFile, Buffer, WRITEBUFFERSIZE );\n      if ( BytesRead < 0 ) { break; }\n      if ( BytesRead > 0 )\n      {\n        TotalBytes += BytesRead;\n        Out->Write( Buffer, BytesRead );\n      }\n```", "```java\n      if ( Progress )\n      {\n        *Progress = (float)TotalBytes / (float)FileSize;\n      }\n    }\n    while ( BytesRead > 0 );\n```", "```java\n    ErrorCode = unzCloseCurrentFile( UnzipFile );\n    return ErrorCode;\n  }\n```", "```java\n  bool Enumerate_ZIP()\n  {\n    clPtr<iIStream> TheSource = FSourceFile;\n    FSourceFile->Seek( 0 );\n```", "```java\n    zlib_filefunc64_def ffunc;\n    fill_functions( TheSource.GetInternalPtr(), &ffunc );\n    unzFile UnzipFile = unzOpen2_64( \"\", &ffunc );\n```", "```java\n    unz_global_info64 gi;\n    int ErrorCode = unzGetGlobalInfo64( uf, &gi );\n```", "```java\n    for ( uLong i = 0; i < gi.number_entry; i++ )\n    {\n      if ( ErrorCode != UNZ_OK ) { break; }\n      char filename_inzip[256];\n      unz_file_info64 file_info;\n      ErrorCode = unzGetCurrentFileInfo64( UnzipFile, &file_info, filename_inzip, sizeof(filename_inzip), nullptr, 0, nullptr, 0 );\n      if ( ErrorCode != UNZ_OK ) { break; }\n      if ( ( i + 1 ) < gi.number_entry )\n      {\n        ErrorCode = unzGoToNextFile( UnzipFile );\n        if ( ErrorCode != UNZ_OK ) { break; }\n      }\n```", "```java\n      sFileInfo Info;\n      Info.FOffset = 0;\n      Info.FCompressedSize = file_info.compressed_size;\n      Info.FSize = file_info.uncompressed_size;\n      FFileInfos.push_back( Info );\n```", "```java\n      std::string TheName = Arch_FixFileName(filename_inzip);\n      FFileInfoIdx[ TheName ] = ( int )FFileNames.size();\n      FFileNames.emplace_back( TheName );\n      FRealFileNames.emplace_back( filename_inzip );\n    }\n```", "```java\n    unzClose( UnzipFile );\n    return true;\n  }\n```", "```java\n  static voidpf ZCALLBACK zip_fopen ( voidpf opaque, const void* filename, int mode )\n  {\n    ( ( iIStream* )opaque )->Seek( 0 );\n    return opaque;\n  }\n```", "```java\n  static uLong ZCALLBACK zip_fread ( voidpf opaque, voidpf stream, void* buf, uLong size )\n  {\n    iIStream* S = ( iIStream* )stream;\n    int64 CanRead = ( int64 )size;\n    int64 Sz = S->GetSize();\n    int64 Ps = S->GetPos();\n    if ( CanRead + Ps >= Sz ) { CanRead = Sz - Ps; }\n    if ( CanRead > 0 ) {  S->Read( buf, ( uint64 )CanRead ); }\n    else { CanRead = 0; }\n    return ( uLong )CanRead;\n  }\n```", "```java\n  static ZPOS64_T ZCALLBACK zip_ftell(voidpf opaque, voidpf stream)\n  {\n    return ( ZPOS64_T )( ( iIStream* )stream )->GetPos();\n  }\n```", "```java\n  static long ZCALLBACK zip_fseek ( voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin )\n  {\n    iIStream* S = ( iIStream* )stream;\n    int64 NewPos = ( int64 )offset;\n    int64 Sz = ( int64 )S->GetSize();\n    switch ( origin )\n    {\n      case ZLIB_FILEFUNC_SEEK_CUR:\n        NewPos += ( int64 )S->GetPos(); break;\n      case ZLIB_FILEFUNC_SEEK_END:\n        NewPos = Sz - 1 - NewPos; break;\n      case ZLIB_FILEFUNC_SEEK_SET: break;\n      default:  return -1;\n    }\n    if ( NewPos >= 0 && ( NewPos < Sz ) )\n    {\n      S->Seek( ( uint64 )NewPos );\n    }\n    else\n    {\n      return -1;\n    }\n    return 0;\n  }\n```", "```java\n  static int ZCALLBACK zip_fclose( voidpf opaque, voidpf stream )\n  {\n    return 0;\n  }\n  static int ZCALLBACK zip_ferror( voidpf opaque, voidpf stream )\n  {\n    return 0;\n  }\n```", "```java\n  void fill_functions( iIStream* Stream, zlib_filefunc64_def* pzlib_filefunc_def )\n  {\n    pzlib_filefunc_def->zopen64_file = zip_fopen;\n    pzlib_filefunc_def->zread_file = zip_fread;\n    pzlib_filefunc_def->zwrite_file = NULL;\n    pzlib_filefunc_def->ztell64_file = zip_ftell;\n    pzlib_filefunc_def->zseek64_file = zip_fseek;\n    pzlib_filefunc_def->zclose_file = zip_fclose;\n    pzlib_filefunc_def->zerror_file = zip_ferror;\n    pzlib_filefunc_def->opaque = Stream;\n  }\n```", "```java\n  class clArchiveMountPoint: public iMountPoint\n  {\n  public:\n    explicit clArchiveMountPoint( const clPtr<ArchiveReader>& R )\n    : FReader(R) {}\n```", "```java\n    virtual clPtr<iRawFile> CreateReader(\n      const std::string& VirtualName ) const\n    {\n      std::string Name = Arch_FixFileName( VirtualName );\n      const void* DataPtr  = FReader->GetFileData( Name );\n      size_t FileSize = static_cast<size_t>( FReader->GetFileSize( Name ) );\n      auto File = clMemRawFile::CreateFromManagedBuffer( DataPtr, FileSize );\n      File->SetFileName( VirtualName );\n      File->SetVirtualFileName( VirtualName );\n      return File;\n    }\n```", "```java\n    virtual bool FileExists( const std::string& VirtualName )const\n    {\n      return FReader->FileExists( Arch_FixFileName( VirtualName ) );\n    }\n```", "```java\n    virtual std::string MapName( const std::string& VirtualName ) const\n    { return VirtualName; }\n```", "```java\n  private:\n    clPtr<clArchiveReader> FReader;\n  };\n```", "```java\n  @Override protected void onCreate( Bundle icicle )\n  {\n    onCreateNative( getApplication().getApplicationInfo().sourceDir );\n  }\n  public static native void onCreateNative( String APKName );\n```", "```java\n  extern \"C\"\n  {\n    JNIEXPORT void JNICALL\n    Java_com_packtpub_ndkmastering_AppActivity_onCreateNative( JNIEnv* env, jobject obj, jstring APKName )\n    {\n      g_APKName = ConvertJString( env, APKName );\n      LOGI( \"APKName = %s\", g_APKName.c_str() );\n      OnStart( g_APKName );\n    }\n  }\n```", "```java\n  std::string ConvertJString( JNIEnv* env, jstring str )\n  {\n    if ( !str ) { return std::string(); }\n    const jsize len = env->GetStringUTFLength( str );\n    const char* strChars = env->GetStringUTFChars( str, ( jboolean* )0 );\n    std::string Result( strChars, len );\n    env->ReleaseStringUTFChars( str, strChars );\n    return Result;\n  }\n```", "```java\n  void OnStart( const std::string& RootPath )\n  {\n    auto FS = make_intrusive<clFileSystem>();\n    FS->Mount( \"\" );\n    FS->Mount( RootPath );\n    FS->AddAliasMountPoint( RootPath, \"assets\" );\n    const char* ArchiveName = \"test.zip\";\n    auto File = FS->CreateReader( ArchiveName );\n    auto Reader = make_intrusive<clArchiveReader>();\n    if ( !Reader->OpenArchive( File ) )\n    {\n      LOGI( \"Bad archive: %s\", ArchiveName );\n      return;\n    }\n```", "```java\n    for ( size_t i = 0; i != Reader->GetNumFiles(); i++ )\n    {\n      LOGI( \"File[%i]: %s\", i,\n      Reader->GetFileName( i ).c_str() );\n      const char* Data = reinterpret_cast<const char*>( Reader->GetFileDataIdx( i ) );\n      LOGI( \"Data: %s\", std::string( Data,\n        static_cast<size_t>(\n          Reader->GetFileSizeIdx( i ) ) ).c_str() );\n    }\n  }\n```"]