- en: Chapter 5. Writing a Fully Native Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In previous chapters, we have breached Android NDK''s surface using JNI. But
    there is much more to find inside! The NDK includes its own set of specific features,
    one of them being **Native Activities**. Native activities allow creating applications
    based only on native code, without a single line of Java. No more JNI! No more
    references! No more Java!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In addition to native activities, the NDK brings some APIs for native access
    to Android resources, such as **display windows**, **assets**, **device configuration**…
    These APIs help in getting rid of the tortuous JNI bridge often necessary to embed
    native code. Although there is a lot still missing, and not likely to be available
    (Java remains the main platform language for GUIs and most frameworks), multimedia
    applications are a perfect target to apply them...*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This chapter initiates a native C++ project developed progressively throughout
    this book: **DroidBlaster**. Based on a top-down viewpoint, this sample scrolling
    shooter will feature 2D graphics, and, later on, 3D graphics, sound, input, and
    sensor management. In this chapter, we will create its base structure and main
    game components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now enter the heart of the Android NDK by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fully native activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling main activity events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing display window natively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving time and calculating delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a native Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NativeActivity` class provides a facility to minimize the work necessary
    to create a native application. It lets the developer get rid of all the boilerplate
    code to initialize and communicate with native code and concentrate on core functionalities.
    This *glue* Activity is the simplest way to write applications, such as games
    without a line of Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part1`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a basic native Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to see how to create a minimal native activity that runs an
    event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new hybrid Java/C++ project, as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `DroidBlaster`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the project into a native project, as already seen in the previous chapter.
    Name the native module `droidblaster`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the native source and header files that have been created by ADT.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the reference to the Java `src` directory in **Project Properties** |
    **Java Build Path** | **Source**. Then, remove the directory itself on disk.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of all layouts in the `res/layout` directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of `jni/droidblaster.cpp` if it has been created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In `AndroidManifest.xml`, use `Theme.NoTitleBar.Fullscreen` as the application
    theme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a `NativeActivity` that refers to the native module named `droidblaster`
    (that is, the native library we will compile) using the meta-data property `android.app.lib_name`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the file `jni/Types.hpp`. This header will contain common types and
    the header `cstdint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's write a logging class to get some feedback in the Logcat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `jni/Log.hpp` and declare a new class `Log`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the `packt_Log_debug` macro to allow the activating or deactivating
    of debug messages with a simple compile flag:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `jni/Log.cpp` file and implement the `info()` method. To write
    messages to Android logs, the NDK provides a dedicated logging API in the `android/log.h`
    header, which can be used similarly as `printf()` or `vprintf()` (with `varArgs`)
    in C:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write other log methods, `error()`, `warn()`, and `debug()`, which are almost
    identical, except the level macro, which are respectively `ANDROID_LOG_ERROR,
    ANDROID_LOG_WARN`, and `ANDROID_LOG_DEBUG` instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Application events in `NativeActivity` can be processed with an event loop.
    So, create `jni/EventLoop.hpp` to define a class with a unique method `run()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the `android_native_app_glue.h` header, which defines the `android_app`
    structure. It represents what could be called an **applicative context**, where
    all the information is related to the native activity; its state, its window,
    its event queue, and so on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create `jni/EventLoop.cpp` and implement the activity event loop in the `run()`
    method. Include a few log events to get some feedback in Android logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the whole activity lifetime, the `run()` method loops continuously over
    events until it is requested to terminate. When an activity is about to be destroyed,
    the `destroyRequested` value in the `android_app` structure is changed internally
    to indicate to the client code that it must exit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, call `app_dummy()` to ensure the glue code that ties native code to `NativeActivity`
    is not stripped by the linker. We will see more about this in [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create `jni/Main.cpp` to define the program entry point `android_main()`,
    which runs the event loop in a new file `Main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Edit the `jni/Android.mk` file to define the `droidblaster` module (the `LOCAL_MODULE`
    directive).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the C++ files to compile the `LOCAL_SRC_FILES` directive with the help
    of the `LS_CPP` macro (more about this in [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Link `droidblaster` with the `native_app_glue` module (the `LOCAL_STATIC_LIBRARIES`
    directive) and `android` (required by the **Native App Glue** module), as well
    as the `log` libraries (the `LOCAL_LDLIBS` directive):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `jni/Application.mk` to compile the native module for multiple `ABI`s.
    We will use the most basic ones, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build and run the application. Of course, you will not see anything tremendous
    when starting this application. Actually, you will just see a black screen! However,
    if you look carefully at the **LogCat** view in Eclipse (or the `adb logcat` command),
    you will discover a few interesting messages that have been emitted by your native
    application in reaction to activity events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We initiated a Java Android project without a single line of Java code! Instead
    of referencing a child of `Activity` in `AndroidManifest`, we referenced the `android.app.NativeActivity`
    class provided by the Android framework.
  prefs: []
  type: TYPE_NORMAL
- en: '`NativeActivity` is a Java class, launched like any other Android activity
    and interpreted by the Dalvik Virtual Machine like any other Java class. However,
    we never faced it directly. `NativeActivity` is in fact a helper class provided
    with Android SDK, which contains all the necessary glue code to handle application
    events (lifecycle, input, sensors, and so on) and broadcasts them transparently
    to native code. Thus, a native activity does not eliminate the need for JNI. It
    just hides it under the cover! However, the native C/C++ module run by `NativeActivity`
    is executed outside Dalvik boundaries in its own thread, entirely natively (using
    the Posix Thread API)!'
  prefs: []
  type: TYPE_NORMAL
- en: '`NativeActivity` and native code are connected together through the `native_app_glue`
    module. The Native App Glue has the responsibility of:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching the native thread, which runs our own native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving events from `NativeActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing these events to the native thread event loop for further processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Native glue` module code is located in `${ANDROID_NDK}/sources/android/native_app_glue`
    and can be analyzed, modified, or forked at will (see [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*, for
    more information). The headers related to native APIs such as, `looper.h`, can
    be found in `${ANDROID_NDK}/platforms/<Target Platform>/<Target Architecture>/usr/include/android/`.
    Let's see in more detail how it works.
  prefs: []
  type: TYPE_NORMAL
- en: More about the Native App Glue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our own native code entry point is declared inside the `android_main()` method,
    which is similar to the main methods in desktop applications. It is called only
    once when `NativeActivity` is instantiated and launched. It loops over application
    events until `NativeActivity` is terminated by the user (for example, when pressing
    a device's back button) or until it exits by itself (more about this in the next
    part).
  prefs: []
  type: TYPE_NORMAL
- en: The `android_main()` method is not the real native application entry point.
    The real entry point is the `ANativeActivity_onCreate()` method hidden in the
    `android_native_app_glue` module. The event loop we implemented in `android_main()`
    is in fact a delegate event loop, launched in its own native thread by the glue
    module. This design decouples native code from the `NativeActivity` class, which
    is run on the UI thread on the Java side. Thus, even if your code takes a long
    time to handle an event, `NativeActivity` is not blocked and your Android device
    still remains responsive.
  prefs: []
  type: TYPE_NORMAL
- en: The delegate native event loop in `android_main()` is itself composed, in our
    example, of two nested while loops. The outer one is an infinite loop, terminated
    only when activity destruction is requested by the system (indicated by the `destroyRequested`
    flag). It executes an inner loop, which processes all pending application events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The inner `For` loop polls events by calling `ALooper_pollAll()`. This method
    is part of the `Looper` API, which can be described as a general-purpose event
    loop manager provided by Android. When timeout is set to `-1`, like in the preceding
    example, `ALooper_pollAll()` remains blocked while waiting for events. When at
    least one is received, `ALooper_pollAll()` returns and the code flow continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `android_poll_source` structure describing the event is filled and is then
    used by client code for further processing. This structure looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `process()` function pointer can be customized to process application events
    manually, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in this part, the event loop receives an `android_app` structure
    in parameter. This structure, described in `android_native_app_glue.h`, contains
    some contextual information as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `void* userData` | Pointer to any data you want. This is essential in giving
    some contextual information to the activity or input event callbacks. |'
  prefs: []
  type: TYPE_TB
- en: '| `void (*pnAppCmd)(…)` and `int32_t (*onInputEvent)(…)` | These member variables
    represent the event callbacks triggered by the Native App Glue when an activity
    or an input event occurs. We will see more about this in the next section. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANativeActivity* activity` | Describes the Java native activity (its class
    as a JNI object, its data directories, and so on) and gives the necessary information
    to retrieve a JNI context. |'
  prefs: []
  type: TYPE_TB
- en: '| `AConfiguration* config` | Describes the current hardware and system state,
    such as the current language and country, the current screen orientation, density,
    size, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `void* savedState size_t` and `savedStateSize` | Used to save a buffer of
    data when an activity (and thus its native thread) is destroyed and later restored.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AInputQueue* inputQueue` | Provides input events (used internally by the
    native glue). We will see more about input events in [Chapter 8](ch08.html "Chapter 8. Handling
    Input Devices and Sensors"), *Handling Input Devices and Sensors*. |'
  prefs: []
  type: TYPE_TB
- en: '| `ALooper* looper` | Allows attaching and detaching event queues used internally
    by the native glue. Listeners poll and wait for events sent on a communication
    pipe. |'
  prefs: []
  type: TYPE_TB
- en: '| `ANativeWindow* window` and `ARect contentRect` | Represents the "drawable"
    area on which graphics can be drawn. The `ANativeWindow` API, declared in `native_window.h`,
    allows retrieval of the window width, height, and pixel format, and the changing
    of these settings. |'
  prefs: []
  type: TYPE_TB
- en: '| `int activityState` | Current activity state, that is, `APP_CMD_START`, `APP_CMD_RESUME`,
    `APP_CMD_PAUSE`, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `int destroyRequested` | When equal to `1`, it indicates that the application
    is about to be destroyed and the native thread must be terminated immediately.
    This flag has to be checked in the event loop. |'
  prefs: []
  type: TYPE_TB
- en: The `android_app` structure also contains some additional data for internal
    use only, which should not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing all these details is not essential to program native programs but can
    help you understand what's going on behind your back. Let's now see how to handle
    these activity events.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Activity events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part, a native event loop was run, which flushes events without
    really processing them. In this second part, we are going to discover more about
    these events occurring during the activity lifecycle, and how to process them,
    spending the remaining time stepping our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part2`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – stepping the event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's extend the previous example to step our application when events are processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `jni/Types.hpp` and define a new type status to represent return codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `jni/ActivityHandler.hpp` header and define an "interface" to observe
    native activity events. Each possible event has its own handler method: `onStart()`,
    `onResume()`, `onPause()`, `onStop()`, `onDestroy()`, and so on. However, we are
    generally interested in three specific moments in the activity life cycle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onActivate()`, invoked when the activity is resumed and its window is available
    and focused'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDeactivate()`, invoked when the activity is paused or the display window
    loses its focus or is destroyed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStep()`, invoked when no event has to be processed and computations can
    take place'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Enhance `jni/EventLoop.hpp` with the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`activate()` and `deactivate()`, executed when an activity availability changes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback_appEvent()`, which is static and routes events to `processActivityEvent()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, define some member variables as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mActivityHandler` observes activity events. This instance is given as a constructor
    parameter and requires the inclusion of `ActivityHandler.hpp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mEnabled` saves the application state when the application is active/paused'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mQuit` indicates the event loop needs to exit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `jni/EventLoop.cpp`. The constructor initialization list itself is trivial
    to implement. Then, fill the `android_app` application context with additional
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`userData` points to any data you want. It is the only information accessible
    from `callback_appEvent()` declared previously. In our case, this is the `EventLoop`
    instance (that is, `this`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAppCmd` points to an internal callback triggered each time an event occurs.
    In our case, this is the role devoted to the static method `callback_appEvent()`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Update the `run()` main event loop. Instead of blocking when there is no more
    activity event to process, `ALooper_pollAll()` must let the program flow continue
    to perform the recurrent processing. Here, processing is performed by the listener
    in `mActivityHandler.onStep()`. This behavior is obviously only needed when the
    application is enabled.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, allow the activity to be terminated programmatically using the `AnativeActivity_finish()`
    method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We changed our event loop to update our application, instead of blocking uselessly,
    when there are no more events to process. This behavior is specified in `ALooper_pollAll()`
    by its first parameter, timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: When timeout is `-1`, as defined previously, call is blocking until events are
    received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When timeout is `0`, call is non-blocking so that, if nothing remains in the
    queue, the program flow continues (the inner while loop is terminated) and makes
    it possible to perform recurrent processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When timeout is greater than `0`, we have a blocking call, which remains until
    an event is received or the duration is elapsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we want to step the activity (that is, perform computations) when it is
    in active state (`mEnabled` is `true`); in that case, timeout is `0`. When the
    activity is in deactivated state (`mEnabled` is `false`), events are still processed
    (for example, to resurrect the activity) but nothing needs to get computed. The
    thread has to be blocked to avoid consuming battery and processor time uselessly;
    in that case, timeout is `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all pending events are processed, the listener is stepped. It can request
    the application to be terminated, for example, if the game is finished. To leave
    the application programmatically, the NDK API provides the `AnativeActivity_finish()`
    method to request activity termination. Termination does not occur immediately
    but after the last few events (pause, stop, and so on) are processed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling Activity events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not done yet. Let''s continue our example to handle activity events
    and log them to the **LogCat** view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue editing `jni/EventLoop.cpp`. Implement `activate()` and `deactivate()`.Check
    both activity states before notifying the listener (to avoid untimely triggering).
    We consider an activity as activated only if a display window is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Route activity events from the static callback `callback_appEvent()` to the
    member method `processAppEvent()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To do so, retrieve the `EventLoop` instance, thanks to the `userData` pointer
    (this being unavailable from a static method). Effective event processing is then
    delegated to `processAppEvent()`, which brings us back to the object-oriented
    world. The command, that is the activity event, given by the native glue is passed
    at the same time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Process the forwarded events in `processAppEvent()`. The `pCommand` parameter
    contains an enumeration value (`APP_CMD_*`), which describes the occurring event
    (`APP_CMD_START, APP_CMD_GAINED_FOCUS`, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the event, activate or deactivate the event loop and notify the
    listener:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activation occurs when the activity gains focus. This event is always the last
    event that occurs after the activity is resumed and the window is created. Getting
    focus means that the activity can receive input events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deactivation occurs when the window loses focus or the application is paused
    (both can occur first). For security, deactivation is also performed when the
    window is destroyed, although this should always occur after the focus is lost.
    Losing focus means that the application does not receive input events anymore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A few events, such as `APP_CMD_WINDOW_RESIZED`, are available but never triggered.
    Do not listen to them unless you are ready to stick your hands in the glue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `jni/DroidBlaster.hpp`, which implements the `ActivityHandler` interface
    and all its methods (some have been skipped here for conciseness). This class
    will run the game logic as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement `jni/DroidBlaster.cpp` with all the required handlers. To keep this
    introduction to the activity lifecycle simple, we are just going to log each event
    that occurs. Use `onStart()` as a model for all the handlers that have been skipped
    in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps are limited to a simple thread sleep (to avoid flooding the Android log),
    which requires the inclusion of `unistd.h`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the event loop is now run directly by the `DroidBlaster` class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, initialize and run the `DroidBlaster` game in the `android_main()`
    entry point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you like a black screen, you are served! Again, this time, everything happens
    in the Eclipse **LogCat** view. All messages that have been emitted in reaction
    to application events are displayed here, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We created a minimalist framework, which handles application events in the native
    thread using an event-driven approach. Events (which are named commands) are redirected
    to a listener object, which performs its own specific computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Native activity events correspond mostly to classic Java activity events. Events
    are a critical and rather tricky point that any application needs to handle. They
    occur generally in pairs, such as `start/stop`, `resume/pause`, `create/destroy`,
    `create window/destroy window`, or `gain/lose focus`. Although they occur most
    of the time in a predetermined order, some specific cases may cause different
    behaviors, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Leaving the application using the back button destroys the activity and native
    thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaving the application using the home button stops the activity and releases
    the window. The native thread is kept on hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the device's home button for a long time and then getting back should
    cause a loss and gain of focus only. The native thread is kept on hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shutting down the phone screen and switching it back should terminate and reinitialize
    the window right after the activity is resumed. The native thread is kept on hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When changing screen orientation (not applicable here), the whole activity may
    not lose its focus, although the recreated activity will regain it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the activity lifecycle is essential to develop Android applications.
    Have a look at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)
    in the official Android documentation for a detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Native App Glue gives you a chance to save your activity state before it
    is destroyed by triggering `APP_CMD_SAVE_STATE`. The state must be saved in the
    `android_app` structure in `savedState`, which is a pointer to a memory buffer
    to save, and in `savedStateSize`, which is the size of the memory buffer to save.
    The buffer must be allocated by ourselves, using `malloc()` (deallocation being
    automatic), and must not contain pointers, only "raw" data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing window surface natively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application events are essential to understand, but not very exciting. An interesting
    feature of the Android NDK is the ability to access the display window natively.
    With this privileged access, applications can draw any graphics they want onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now exploit this feature to get a graphic feedback in our application:
    a red square on screen. This square is going to represent the spaceship the user
    will control during the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part3`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – displaying raw graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make `DroidBlaster` more interactive with some graphics and game components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `jni/Types.hpp` and create a new structure `Location` to hold entity positions.
    Also, define a macro to generate a random value in the requested range as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file, `jni/GraphicsManager.hpp`. Define a structure `GraphicsElement`,
    which contains the location and dimensions of the graphical element to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the same file, define a `GraphicsManager` class as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getRenderWidth()` and `getRenderHeight()` to return the display size'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerElement()` is a `GraphicsElement` factory method that tells the manager
    what element to draw'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()` and `update()initialize` the manager and render the screen for each
    frame respectively'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few member variables are needed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mApplication` stores the application context needed to access the display
    window'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mRenderWidth` and `mRenderHeight` for the display size'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mElements` and `mElementCount` for a table of all the elements to draw'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `jni/GraphicsManager.cpp`, starting with the constructor, destructor,
    and registration methods. They manage the list of `GraphicsElement` to update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `start()` method to initialize the manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, use the `ANativeWindow_setBuffersGeometry()` API method to force the
    window depth format to 32 bits. The two zeros passed in parameters are the required
    window width and height. They are ignored unless initialized with a positive value.
    In such a case, the requested window area defined by width and height is scaled
    to match the screen size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, retrieve all the necessary window dimensions in an `ANativeWindow_Buffer`
    structure. To fill this structure, the window must be first locked with `ANativeWindow_lock()`,
    and then unlocked with `AnativeWindow_unlockAndPost()` once done.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write the `update()`method, which renders raw graphics each time an application
    is stepped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The window surface must be locked before any draw operation takes place with
    `AnativeWindow_lock()`. Again, the `AnativeWindow_Buffer` structure is filled
    with window information for width and height, but more importantly, the `stride`
    and `bits` pointer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `stride` gives the distance in "pixels" between two successive pixel lines
    in the window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `bits` pointer gives direct access to the window surface, in much the same
    way as the Bitmap API, as seen in the previous chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these two pieces of information, any pixel-based operations can be performed
    natively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, clear the window memory area with `0` to get a black background.
    A brute-force approach using `memset()` can be applied for that purpose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once cleared, draw all elements registered with `GraphicsManager`. Each element
    is represented as a red square onscreen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First, compute the coordinates (upper-left and bottom-right corners) of the
    elements to draw.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, clip their coordinates to avoid drawing outside the window memory area.
    This operation is rather important as going beyond window limits might result
    in a segmentation fault:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: After that, draw each pixel of the element on screen. The `line` variable points
    to the beginning of the first line of pixels on which the element is drawn. This
    pointer is computed using the stride (distance between two lines of pixels) and
    the top `Y` coordinate of the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we can loop over window pixels to draw a red square representing the element.
    Start from the left `X` coordinate to the right `X` coordinate of the element,
    switching from one pixel line to another (that is, on the `Y` axis) when the end
    of each is reached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finish drawing operations with `ANativeWindow_unlockAndPost()` and pend call
    to `pendANativeWindow_lock()`. These must always be called in pairs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new component `jni/Ship.hpp` that represents our spaceship.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will handle initialization only for now, using `initialize()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Ship` is created with the factory method `registerShip()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `GraphicsManager` and the ship `GraphicsElement` are needed to initialize
    the ship properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `jni/Ship.cpp`. The important part is `initialize()`, which positions
    the ship on the lower quarter of the screen, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the newly created manager and component to `jni/DroidBlaster.hpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the `jni/DroidBlaster.cpp` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize `GraphicsManager` and the `Ship` component in `onActivate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the manager in `onStep()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compile and run `DroidBlaster`. The result should be a simple red square representing
    our spaceship in the first quarter of the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphical feedback is provided through the `ANativeWindow` API, which gives
    native access to the display window. It allows manipulating its surface like a
    bitmap. Similarly, accessing the window surface requires locking and unlocking
    both before and after processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnativeWindow` API is defined in `android/native_window.h` and `android/native_window_jni.h`.
    It provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ANativeWindow_setBuffersGeometry()` initializes the Pixel format (or Depth
    format) and size of the window buffer. The possible Pixel formats are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW_FORMAT_RGBA_8888` for 32-bit colors per pixel, 8 bits for each of the
    Red, Green, Blue, and Alpha (for transparency) channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_FORMAT_RGBX_8888` is the same as the previous one, except that the
    Alpha channel is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOW_FORMAT_RGB_565` for 16-bit colors per pixel (5 bits for Red and Blue,
    and 6 for the Green channel).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the supplied dimension is `0`, the window size is used. If it is non-zero,
    then the window buffer is scaled to match window dimensions when displayed onscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`ANativeWindow_lock()` must be called before performing any drawing operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ANativeWindow_unlockAndPost()` releases the window after drawing operations
    are done and sends it to the display. It must be called in a pair with `ANativeWindow_lock()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ANativeWindow_acquire()` gets a reference, in the Java way, on the specified
    window to prevent potential deletion. This might be necessary if you do not have
    fine control on the surface life cycle:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ANativeWindow_fromSurface()` associates the window with the given Java `android.view.Surface`.
    This method automatically acquires a reference to the given surface. It must be
    released with `ANativeWindow_release()` to avoid memory leaks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ANativeWindow_release()` removes an acquired reference to allow freeing window
    resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following methods return the width, height (in pixels), and the format
    of the window surface. The returned value is negative incase an error occurs.
    Note that these methods are tricky to use because their behavior is a bit inconsistent.
    Prior to Android 4, it is preferable to lock the surface once to get reliable
    information (which is already provided by `ANativeWindow_lock()`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now know how to draw. However, how do we animate what is drawn? A key is
    needed in order to do this: *time*.'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring time natively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who talk about graphics also need to talk about timing. Indeed, Android
    devices have different capabilities, and animations should be adapted to their
    speed. To help us in this task, Android gives access to time primitives, thanks
    to its good support of Posix APIs.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with these capabilities, we will use a timer to move asteroids
    onscreen according to time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part4`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating graphics with a timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's animate the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `jni/TimeManager.hpp` with the `time.h` manager and define the following
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reset()` to initialize the manager.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()` to measure game step duration.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elapsed()` and `elapsedTotal()` to get game step duration and game duration.
    They are going to allow the adaptation of the application behavior to the device
    speed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now()` is a utility method to recompute the current time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the following member variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mFirstTime` and `mLastTime` to save a time checkpoint in order to compute
    `elapsed()` and `elapsedTotal()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mElapsed` and `mElapsedTotal` to save computed time measures'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Implement `jni/TimeManager.cpp`. When reset, `TimeManager` saves the current
    time computed by the `now()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `update()` which checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: elapsed time since last frame in `mElapsed`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: elapsed time since the very first frame in `mElapsedTotal`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it is important to work with double types when handling the current
    time to avoid losing accuracy. Then, the resulting delay can be converted back
    to float for the elapsed time, since the time difference between the two frames
    is quite low.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the current time in the `now()` method. Use the Posix primitive `clock_gettime()`
    to retrieve the current time. A monotonic clock is essential to ensure that the
    time always goes forward and is not subject to system changes (for example, if
    the user travels around the world):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file, `jni/PhysicsManager.hpp`. Define a structure `PhysicsBody`
    to hold asteroid location, dimensions, and velocity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a basic `PhysicsManager`. We need a reference to `TimeManager` to adapt
    bodies of movements to time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a method `update()` to move asteroids during each game step. The `PhysicsManager`
    stores the asteroids to update in `mPhysicsBodies` and `mPhysicsBodyCount`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `jni/PhysicsManager.cpp`, starting with the constructor, destructor,
    and registration methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move asteroids in `update()` according to their velocity. The computation is
    performed according to the amount of time between the two game steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `jni/Asteroid.hpp` component with the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`initialize()` to set up asteroids with random properties when the game starts'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()` to detect asteroids that get out of game boundaries'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spawn()` is used by both `initialize()` and `update()` to set up one individual
    asteroid'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also need the following members:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mBodies` and `mBodyCount` to store the list of asteroids to be managed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A few integer members to store game boundaries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the `jni/Asteroid.cpp` implementation. Start with a few constants, as
    well as the constructor and registration method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up boundaries in `initialize()`. Asteroids are generated above the top of
    screen (in `mMinBound`, the maximum boundary `mUpperBound` is twice the height
    of the screen). They move from the top to the bottom of the screen. Other boundaries
    correspond to screen edges padded with a margin (representing twice the size of
    an asteroid).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, initialize all asteroids using `spawn()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During each game step, check the asteroids that get out of bounds and reinitialize
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, initialize each asteroid in `spawn()`, with velocity and location
    being generated randomly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the newly created managers and components to `jni/DroidBlaster.hpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register asteroids with `GraphicsManager` and `PhysicsManager` in the `jni/DroidBlaster.cpp`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the newly added classes in `onActivate()` properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile and run the application. This time it should be a bit more animated!
    Red squares representing asteroids cross the screen at a constant rhythm. The
    `TimeManger` helps with setting the pace.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Timers are essential to display animations and movement at the correct speed.
    They can be implemented with the POSIX method `clock_gettime()`, which retrieves
    time with a high precision, theoretically to the nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we used the `CLOCK_MONOTONIC` flag to set up the timer. A
    monotonic clock gives the elapsed clock time from an arbitrary starting point
    in the past. It is unaffected by potential system date change, and thus cannot
    go back in the past like other options. The downside with `CLOCK_MONOTONIC` is
    that it is system-specific and it is not guaranteed to be supported. Hopefully
    Android supports it, but care should be taken when porting Android code to other
    platforms. Another point specific to Android to be aware of is that monotonic
    clocks stop when the system is suspended.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative, that is less precise and affected by changes in the system
    time (which may or may not be desirable), is `gettimeofday()`, which is also provided
    in `ctime`. The usage is similar but the precision is in microseconds instead
    of nanoseconds. The following could be a usage example that could replace the
    current `now()` implementation in `TimeManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For more information, have a look at the Man-pages at [http://man7.org/linux/man-pages/man2/clock_gettime.2.html](http://man7.org/linux/man-pages/man2/clock_gettime.2.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android NDK allows us to write fully native applications without a line
    of Java code. `NativeActivity` provides a skeleton to implement an event loop
    that processes application events. Associated with the Posix time management API,
    the NDK provides the required base to build complex multimedia applications or
    games.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we created `NativeActivity` that polls activity events to start
    or stop native code accordingly. We accessed the display window natively, like
    a bitmap, to display raw graphics. Finally, we retrieved time to make the application
    adapt to device speed using a monotonic clock.
  prefs: []
  type: TYPE_NORMAL
- en: The basic framework initiated here will form the base of the 2D/3D game that
    we will develop throughout this book. However, although the flat design is in
    fashion nowadays, we need something a bit fancier than red squares!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover how to render advanced graphics with OpenGL
    ES 2 for Android.
  prefs: []
  type: TYPE_NORMAL
