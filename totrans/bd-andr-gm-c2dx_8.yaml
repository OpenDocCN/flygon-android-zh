- en: Chapter 8. Adding Native Java Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been creating our game by using only the programming language
    in which the Cocos2d-x game framework has been written (C++); nevertheless, the
    Android API written by Google is only available in the Java layer of the application.
    In this chapter, you will learn how to communicate our native C++ code with the
    higher end Java core by using the **Java Native Interface** (**JNI**) capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Cocos2d-x structure for the Android platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the JNI capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Java code to the Cocos2d-x game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding ads to the game by inserting the Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Cocos2d-x structure for the Android platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Setting Up Your Development Environment"),
    *Setting Up Your Development Environment*, when we were installing all the required
    components for building the Cocos2d-x framework, we told you to download and install
    Android **Native Development Kit** (**NDK**), which allows us to build the Android
    applications by using the C++ language instead of using the mainstream Java technology
    core for which the Android API has been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an Android application is launched, it looks in its `AndroidManisfest.xml`
    file for an activity definition that has the intent filter `android.intent.action.MAIN`,
    and then it will run the Java class. The following listing shows the segment of
    the `AndroidManifest.xml` file generated by the Cocos new script, where the activity
    to be launched when the Android application starts is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cocos2d-x project creation script has created a Java class named `AppActivity`
    and it is located in the `src` folder of the `proj.android` directory under the
    `org.cocos2dx.cpp` Java package name. This class has no body and extends from
    the `Cocos2dxActivity` class, as we can appreciate in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Cocos2dxActivity` class loads the native C++ framework core in its `onCreate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the JNI capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JNI offers a bridge between the C++ code and the Java code. The Cocos2d-x framework
    provides us with a JNI helper, which makes it easier to integrate the C++ code
    and the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The `JniHelper` C++ class has a method called `getStaticMethodInfo`. This receives
    as parameters, a `JniMethodInfo` object to store all the data that is required
    to invoke the corresponding Java code, the class name where the static method
    is located, the name of the method, and its signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to find out the method signature for JNI, you could use the `javap`
    command: so, for instance, if we would like to know what the signatures of the
    methods contained in the `AppActivity` class are , then we just need to open a
    console window , go to your `proj.android\bin\classes` directory, and type the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular case you will receive as a response, the signature of the
    `null` constructor created automatically for the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, through the property `env` attached to the `JniMethodInfo` instance,
    we can invoke the Java method with a set of methods contained by this object,
    all starting with `Call…`. In the code that we are going to write in the next
    section, we will use the `CallStaticVoid` method in order to call a static method
    that does not return any value, as its name suggests. Please note that if you
    want to pass a Java string as a parameter, then you will need to call the `NewStringUTF`
    method of the `env` property, pass `const char*`, and it will return a `jstring`
    instance, which you can use to pass to a Java method that receives a string, as
    we show in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you have created instances of `jstring` or any other Java abstraction
    class within your C++ code, then make sure that you delete those after passing
    the value to the Java core, so that we don''t have unnecessary references in the
    memory. This can be achieved by calling the `DeleteLocalRef` method located in
    the `env` property of the `JniMethodInfo` instance and passing the Java abstraction
    reference that you want to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The concepts exposed in this section will be applied to the code listings in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Java code to the Cocos2d-x game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to create a simple integration between these two technologies,
    which will allow our Cocos2d-x C++ game to show a toast message using the Android
    Java API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A toast in Android is a pop-up message that is displayed for a specified amount
    of time without the option of being hidden before the predefined time. The screenshot
    at the end of this section shows what a toast message looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cocos2d-x runs within a Java activity, so in order to show the native Android
    toast message, we will create a Java class that will have a static method called
    `showToast`. This will receive a string, and then it will show it in a toast.
    In order to have access to the Cocos2d-x game activity, we will add a static attribute
    of type `Activity` to that class and will initialize it in the overridden `onCreate`
    method. Then, we will create a public static method that will allow us to access
    this instance from anywhere within our Java code. After these modifications our
    `AppActivity` Java class code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create the referred `JniFacade` Java class inside our `com.packtpub.jni`
    package, which in its body will only have one static void method that receives
    a string as a parameter, and then shows a toast on the UI thread with the received
    message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our code in the Java side, let us add the `JniBridge` C++ class
    to our `classes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `JniBridge.h` header file we will write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us create the implementation file, `JniBridge.cpp`, where we are going
    to invoke our static Java method called `showToast`, which receives a string as
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, here we are using the `JniMethodInfo` structure and the `JniHelper`
    class bundled with the Cocos2d-x framework in order to invoke the `showToast`
    method and send it the c string in our C++ code, which was converted into a Java
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us include our `JniBridge.h` header file in our `HelloWorldScene.cpp`
    implementation file, so that we can have access to our bridge to the Java code
    from within our main scene class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now at the end of the `init` method located in the `HelloWorld.cpp` implementation
    file, we are going to call the `showToast` static method in order to use the Android
    Java API for displaying a native toast message, displaying the text sent from
    our C++ code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Java code to the Cocos2d-x game](img/B04193_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can appreciate from the previous screenshot, we have achieved our goal
    of displaying a native Java toast message from our C++ game logic code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ads to the game by inserting Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have created an interaction between our C++ game
    logic code and the Java layer of our Android app by using JNI. In this section,
    we are going to modify our Android-specific code in order to show the Google **AdMob**
    banners in our Android game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AdMob is a Google platform that allows you to monetize your app by displaying
    ads, it also has analytics tools, and tools for in-app purchases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to show the Google AdMob banners, we need to add the `Google Play
    Services` library to our project. In order to do this, we first need to download
    it and its dependency, the Android Support Library, by using the Android SDK Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the environment](img/B04193_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you have successfully downloaded the **Google Play Services** and its
    dependencies, you will need to add the Android.support.v4 to your project, since
    it is required by the Google Play Services library. For this, we are going to
    copy the `android-support-v4.jar` file located on the following path: `<ADT PATH>\sdk\extras\android\support\v4`
    to the `libs` folder contained in our Android project, then we are going to add
    it to our build path by right-clicking on our project in the Eclipse''s package
    explorer , then click on **Build Path**, and then click on **Configure Build Path**.
    The **Java Build Path** configuration window will show up, click on the **Add
    JARS…** button and add the `android-support-v4.jar` file in the `libs` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to copy the Google Play Services code that we have just downloaded.
    This is now located on the `<ADT PATH>\sdk\extras\google\google_play_services`
    to our workspace path. You can find out what the path to your workspace is by
    right-clicking on your Eclipse Java project, then clicking on the **properties**,
    and finally, selecting the **Resource** option on the left; there you will see
    the **Location** information as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the environment](img/B04193_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have set up the dependency, so let us now add the Google Play Services library,
    by navigating to **File** | **import** | **Android** | **Existing Android Code
    Into Workspace** | **Browse …**. Then, browse to the location where you have copied
    the Google Play Services from the previous step. Deselect all projects but `google-play-services_lib`
    and click on **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the environment](img/B04193_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the `google-play-services_lib` project in our workspace, let
    us configure it as a library for our Cocos2d-x game project. For this, we are
    going to right-click our project on the package explorer again, click on the **properties**,
    click on the **Android** section in the left pane, and then at the lower bottom
    section of the screen, we are going to click the **Add…** button in order to add
    the `google-play-services_lib` library to our Eclipse project, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the environment](img/B04193_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are all set and ready to move to our next section, where we are going
    to use the libraries that we have just added for displaying the Google AdMob ads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our AdMob banner is going to be shown at the top of the screen, we
    are now going to move our mute button to the bottom, so that it is not covered
    by the banner. We are going to achieve this by changing the position of the mute
    and unmute buttons. Instead of assigning the height of the screen minus half of
    the mute sprite height as its vertical position, we will now set its *y* component
    as the screen height minus the double of the mute button''s height, as we show
    in the following line of code in the `initMuteButton` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the Android manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to modify our Android manifest in order to insert
    it in the required configuration for using the Google Play Services library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to add two snippets, one of which will be just next to the opening
    application tag that will indicate the version of the Google Play Services being
    used, as we can appreciate in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second snippet that we are going to add is the `AdActivity` declaration,
    which will be added just next to the declaration of our game activity, so that
    our game is aware of this built-in activity located in the Google Play Services
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Java code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the libraries configured and the Android manifest modified,
    the ads library is ready for use. We are going to add an ad initialization method
    to our `AppActivity` class, and we are going to call it after we call the implementation
    of its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of the following example, we are going to use a sample AdMob ID,
    which you may substitute with your own ID. You can find more information about
    how to create your own AdMob ID at [http://www.google.com/admob](http://www.google.com/admob).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to the previous section we are not using JNI, since we are not interacting
    at all with the C++ code; instead, we are modifying the Android activity that
    was created by the `cocos` command in order to add more graphic elements to view
    a side of the OpenGL E's view that was defined in the template.
  prefs: []
  type: TYPE_NORMAL
- en: We simply created a frame layout programmatically and added an `adView` instance
    to it; finally, we added this frame layout as a content view to the game activity,
    then we specified its desired position by using the gravity layout parameters,
    and this is how we were finally able to display the Google ad at the top of the
    screen. Please note that you could modify the location of the ad, that is, where
    you want it to be displayed, by simply modifying the layout parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that we have added `adView` to our frame layout after the ad was successfully
    loaded. By using `AdListener`, if you add the `adView` instance before the ad
    finishes launching, then it will not be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our Google AdMob looks like after tying everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Java code](img/B04193_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have accomplished our goal of embedding the core Java code in our Cocos2d-x
    game. Now we are going to show all the parts of our game that have been modified
    throughout this chapter together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we show the header file of the C++ JNI bridge (`JniBridge.h`) that we
    have created from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined the header of our `JniBridge`, let us write the implementation
    file (`JniBridge.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see what our gameplay class header (`HelloWorldScene.h`) looks like
    after including our `JniBridge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will show you what the `HelloWorldScene.cpp` method looks like at the
    end of this, the final chapter of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed the position of the mute button in the code, so that it is
    not covered by the ad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our `AppActivity.java` class looks like after all our modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our `JniFacade.java` class file looks like at the end of this
    chapter: package `com.packtpub.jni`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our `Android.mk` file located at `proj.android\jni` looks like
    after we add our `JniBridge.cpp` file in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this is what our `AndroidManifest.xml` file looks like at the end
    of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to add the interaction between our C++ game
    logic code and the Android core Java layer by using JNI, we have also displayed
    the Google AdMob banner in our game by directly modifying the Java `Activity`
    class code that was created during the invocation of the `cocos` command.
  prefs: []
  type: TYPE_NORMAL
