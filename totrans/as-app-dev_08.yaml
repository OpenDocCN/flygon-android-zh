- en: Chapter 8. Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debugging environment is one of the most important features of an IDE. Using
    a debugging tool allows you to easily optimize your application and improve its
    performance. Do you want to use one of these debug tools while programming in
    Android Studio? Android Studio includes the **Dalvik Debug Monitor Server** (**DDMS**)
    debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will start by learning about the run and debug options and
    how to emulate our application in one of the Android virtual devices we learned
    to create in the previous chapter. We will learn about the debugger tab, the console
    tab, and the LogCat tab in depth. We will also learn how to use breakpoints using
    the debugger and how to run our application stopping in those breakpoints. We
    will end this chapter with information about each tab available in the advanced
    debugging tool included in Android Studio DDMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LogCat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DDMS tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications can be run from Android Studio in a real device using the
    USB connection or in a virtual device using the emulator. Virtual devices make
    it possible to test our applications in different types of hardware and software
    configurations. In this chapter we are using the emulator to run and debug our
    application because of its simplicity and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: To directly run an application, navigate to the menu **Run** | **Run 'MyApplication'**.
    You can also click on the play icon button from the toolbar. To debug an application,
    navigate to the menu **Run** | **Debug 'MyApplication'** or click on the bug icon
    from the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: When we select the debug option, a dialog to choose the device is opened. The
    first option is to choose a running device; the available connected devices are
    listed, real or virtual ones. The second option is to launch a new instance of
    the emulator; the available virtual devices are listed. Check the **Launch emulator**
    option and select the virtual device created in [Chapter 7](ch07.html "Chapter 7. Tools"),
    *Tools*. Click on **OK**. The emulator will be launched. The next time we run
    or debug the application, the emulator is already running, so we will choose the
    first option (**Choose a running device**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and debugging](img/5273OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While debugging, on the bottom of Android Studio there are three tabs: **Debugger**,
    **Console**, and **LogCat**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Console** displays the events that are taking place while the emulator
    is being launched. Open it to examine the messages and check that the emulator
    and the application are correctly being executed. The actions that should appear
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Waiting for device`: Start point when the emulator is being launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uploading file`: The application is packed and stored in the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Installing`: The application is being installed in the device. After the installation
    a success message should be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Launching application`: The application starts to execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Waiting for process`: The application should now be running and the debug
    system tries to connect to the application process in the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the success of the previous steps, the application will be visible in
    the emulator. Test it by typing any name in the text input and click on the **Accept**
    button. The greeting message should change.
  prefs: []
  type: TYPE_NORMAL
- en: The **Debugger** manages the breakpoints, controls the execution of the code,
    and shows information about the variables. To add a breakpoint in our code, just
    click on the left edge of a line code. A red point will appear next to the line
    code to indicate the breakpoint. To delete the breakpoint, click on it. If you
    click on a breakpoint using the right mouse button, more options are available.
    We can disable it without deleting it or we can set a condition for the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Add a breakpoint in the conditional statement of the `onAcceptClick` method
    of our main activity and debug the application again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running and debugging](img/5273OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter your name in the application and click on the **Accept** button. When
    the execution gets to the breakpoint, it pauses and the debugger tab is opened.
    Since we added the breakpoint in the conditional statement, before assigning the
    text, our greeting message has not changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the debugger tab we can examine the method call hierarchy and the variables
    state at that point of execution. The available variables are the parameter of
    the method (`v`), the `TextView` and `EditText` objects obtained by the `findViewById`
    method and the reference to the current activity (`this`). Expand the `EditText`
    object named as `et_name` and search for the property `mText`. This property should
    contain the name you typed before:'
  prefs: []
  type: TYPE_NORMAL
- en: To execute the next line of code without stepping into the method call, navigate
    to **Run** | **Step Over** or use the keyboard shortcut indicated for this option,
    usually key *F8*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To step into the method call, navigate to **Run** | **Step Into** or press *F7*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To resume the execution until the next breakpoint if there is one, navigate
    to **Run** | **Resume Program** or press *F9*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop the execution, navigate to **Run** | **Stop** or press *Ctrl* + *F2*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options, among others, are also available from the debugger tab as icon
    shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `tv_greeting` object to check the value of its `mText` property.
    Now step over the conditional statement and step over the call of the `setText`
    method. Notice how the value of the `mText` property has changed. Finally, resume
    the execution so the greeting message changes in the device screen.
  prefs: []
  type: TYPE_NORMAL
- en: LogCat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LogCat** is the Android logging system that displays all the log messages
    generated by the Android system in the running device. Log messages have several
    levels of significance. From the LogCat tab we can filter the log messages by
    these levels. For example, if we select the information level as filter, the messages
    from information, warning, and error levels will be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![LogCat](img/5273OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To print log messages from our code we need to import the `Log` class. This
    class has a method for each level: `v` method for debug level, `d` method for
    verbose, `i` method for information, `w` method for warning, and `e` method for
    error messages. These methods receive two string parameters. The first string
    parameter usually identifies the source class of the message and the second string
    parameter identifies the message itself. To identify the source class, we recommend
    using a constant static string tag, although in the next example we directly use
    the string to simplify the code. Add the following log messages in the `onAcceptClick`
    method of our main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have a log message to inform about the name obtained from the user input
    and a log message to print a warning if the user did not type any name. Remove
    any breakpoint we previously created and then debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: The LogCat tab has printed all the log messages generated by the device, so
    reading the messages of our application can be complex. We need to filter the
    messages. In the LogCat tab there is an expandable list with the **No Filters**
    option selected. Expand it and select the option **Edit Filter Configuration**.
    A dialog to create filters is opened. Log messages can be filtered by their tag
    or their content using regular expressions, by the name of the package that printed
    them, by the process ID (PID), or by their level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new filter named `MyApplication` and filter by **Package Name** using
    the package of our application as value: `com.example.myapplication`. Click on
    **OK**. Now the LogCat log has been filtered and it is easier to read our messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Focus the emulator window, enter a name in the application, and click on **Accept**.
    Observe how our log message is printed in the LogCat view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete your name in the application and click on **Accept**. This time, the
    warning message is printed. Notice the different colors used for each type of
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we double-click on a LogCat entrance, we can navigate to the source line
    that generated that log message.
  prefs: []
  type: TYPE_NORMAL
- en: DDMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dalvik Debug Monitor Server (DDMS) is a more advanced debugging tool from
    the SDK that has also been integrated into Android Studio. This tool is able to
    monitor both a real device and the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: To open the DDMS perspective navigate to **Tools** | **Android** | **Monitor
    (DDMS included)**. You can also click on the Android icon button from the toolbar.
    A new window will be opened with the DDMS perspective.
  prefs: []
  type: TYPE_NORMAL
- en: On the left part of the window, the list of connected devices is shown. Currently,
    just our virtual device is listed. In the devices section the list of the processes
    running on each device is also presented. We should be able to locate our application
    in the processes of the device we launched before. From the toolbar of the devices
    section, we can stop a process using the stop sign icon button. We can also take
    a screen capture of the virtual device by clicking on the camera icon button.
    Some of the other options will be explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right part of the window, detailed information of the device is provided.
    This information is divided into seven tabs: **Threads**, **Heap**, **Allocation
    Tracker**, **Network Statistics**, **File Explorer**, **Emulator Control**, and
    **System Information**. On the bottom part of the window is the LogCat, which
    has been also integrated in the DDMS perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The threads tab displays the list of threads that belong to the selected process.
    Select our application process from the devices section. The process is identified
    by the package name `com.example.myapplication`. Click on the **Update Threads**
    icon button from the toolbar of the devices section and the threads will be loaded
    in the content of the tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Threads](img/5273OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first columns are the IDs of the threads. The **Status** column indicates
    the thread state, **utime** indicates the total time spent by the thread executing
    user code, **stime** indicates the total time spent by the thread executing system
    code, and **Name** indicates the name of the thread. The threads that interest
    us are those that spend time executing our user code.
  prefs: []
  type: TYPE_NORMAL
- en: This tool is useful if we create threads in our application apart from the main
    thread. We can check if they are being executed at a certain point of the application
    or if their execution time is moderate or not.
  prefs: []
  type: TYPE_NORMAL
- en: Method profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Method profiling is a tool to measure the performance of the methods'' execution
    in the selected process. The measured parameters are the number of calls and the
    CPU time spent while executing. There are two types of spent time, the exclusive
    and the inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exclusive time**: Time spent in the execution of the method itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inclusive time**: Total time spent in the execution of the method. This measure
    includes the time spent by any called methods inside the method. These called
    functions are known as its children methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To collect the method profiling data, select our application process from the
    devices section and click on the **Start Method Profiling** icon button from the
    toolbar of the devices section, next to the **Update Threads** icon button. Then
    perform some actions in the application, for example, in our example application,
    type a name and click on the **Accept** button in order to execute the `onAcceptClick`
    method of the main activity. Stop the method profiling by clicking on the **Stop
    Method Profiling** icon button.
  prefs: []
  type: TYPE_NORMAL
- en: When the method profiling is stopped, a new tab with the resultant trace is
    opened in the DDMS perspective. On the top of this new tab, the method calls are
    represented in a time graph; each row belongs to a thread. On the bottom of the
    trace, the summary of the time spent in a method is represented in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Order the methods by their name to search for our `onAcceptClick` method. Click
    on it to expand the detailed information about the execution of this method. Notice
    the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: The children methods called inside the `onAcceptClick` method are listed. We
    can see the `EditText.getText` method, the `Activity.findViewById` method, or
    the `TextView.setText` method, which indeed we directly call inside the method
    in the following screenshot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number of calls. For example, we can see that the `Activity.findViewById`
    method is called twice: that is one call to find the `TextView` object and a second
    call to find the `EditText` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exclusive time columns have no value for the parents or children methods
    due to their own definition of this type of measured time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Method profiling](img/5273OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Method profiling is very useful to detect methods that spend too much time in
    its execution and be able to optimize them. We can learn which are the most expensive
    methods, to avoid unnecessary calls to them.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heap tab displays the heap memory usage information and statistics of the
    selected process. Select the application process and click on the **Update Heap**
    icon button from the toolbar of the devices section to enable it. The heap information
    is shown after a garbage collector (GC) execution. To force it, click on the **Cause
    GC** button or click on the garbage icon button from the toolbar of the devices
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table displays the summary of the heap usage: the total size, the
    allocated space, the free space, and the number of allocated objects. The statistics
    table gives the details of the objects allocated in the heap by its type: the
    number of objects, the total size of those objects, the size of the smallest and
    largest objects, the median size, and the average size. Select one of the types
    to load the bottom bar graph. The graph draws the number of the objects of that
    type by its size in bytes. If we click on the graph using the right mouse button,
    we can change its properties (title, colors, font, labels...) and save it as an
    image in PNG format.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap](img/5273OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Allocation tracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The allocation tracker tab displays the memory allocations of the selected process.
    Select the application process and click on the **Start Tracking** button to start
    tracking the memory information. Then click on the **Get Allocations** button
    to get the list of allocated objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the filter on the top of the tab to filter the objects allocated
    in our own classes. Type our package name in the filter, `com.example.myapplication`.
    For each object, the table shows its allocation size, the thread, the object or
    class, and the method in which the object was allocated. Click on any object to
    see more information, for example, the line number that allocated it. Finally,
    click on the **Stop Tracking** button.
  prefs: []
  type: TYPE_NORMAL
- en: The allocation tracker is very useful to examine the objects that are being
    allocated when doing certain interactions in our application in order to improve
    the memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Network statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network statistics tab displays how our application uses the network resources.
    To get the network statistics of any application that uses the network, click
    on the **Start** button. The data transfers will start to appear in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The network statistics are useful to optimize the network requests in our code
    and control the data transferred at a certain point of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: File Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tab exposes the whole filesystem of the device. For each element we can
    examine its size, date, or permissions. Navigate to `/data/app/` to search for
    our application package file, `com.example.myapplication.apk`.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Emulator control allows us to emulate some special states or activities in
    the virtual device. We can test our application in different environments and
    situations to check that it behaves as expected. If our application has features
    that depend on the device physical location, we can use mock locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telephony Status**: Choose the voice and data status, its speed, and latency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telephony Actions**: Simulate an incoming call or SMS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location Controls**: Set the geolocation of the device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system information tab presents the frame render time, the total CPU load,
    and the total memory usage of the device as graphs. We can search for our application
    and easily compare it along with the rest of the processes running on the device.
  prefs: []
  type: TYPE_NORMAL
- en: We can change the properties of the graphs such as colors, font, title and we
    can save them as images in the PNG format. To open these options, click on the
    graph elements using the right mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Open the CPU load and save the graph when our application is running in the
    foreground. Then close the application and update the CPU load by clicking on
    the **Update from Device** button. Notice the difference between both graphs and
    notice the growth of the idle percentage.
  prefs: []
  type: TYPE_NORMAL
- en: '![System information](img/5273OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, the users should know the different launch options
    for their application and how to use the console and the LogCat for debugging.
    They should also have learned how to debug an application and to interpret the
    data provided by the DDMS in each of the tabs available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will prepare our application for its release using Android
    Studio. First we will learn about the necessary steps to prepare our application
    before building it in the release mode. We will learn about how the applications
    are compressed in `APK` files and how to generate our own `APK`. Finally, we will
    learn how to get our certificate as developers and how to generate a signed `APK`
    file, making it ready for release.
  prefs: []
  type: TYPE_NORMAL
