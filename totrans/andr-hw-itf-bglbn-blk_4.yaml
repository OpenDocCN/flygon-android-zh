- en: Chapter 4. Storing and Retrieving Data with I2C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you used GPIOs to exchange simple digital data with the
    outside world. However, what about interfacing with more advanced devices that
    require complex sequences of bits or bytes for communication?
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular interfacing buses in use today within embedded systems
    is the **Inter-Integrated Circuit** serial bus (commonly abbreviated as **IIC**,
    **I**2**C**, or **I2C**). In this chapter, you will learn how to write an app
    that uses the BBB''s I2C interface to store data to and retrieve data from a FRAM
    chip. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding I2C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing for I2C on the BBB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing I2C devices in the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an I2C interface circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the I2C FRAM example app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding I2C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Originally developed by Philips Semiconductor in 1982 as a bus for communicating
    with the ICs, the I2C protocol has become a general-use bus that is supported
    by a wide variety of IC manufacturers. I2C is a multimaster and multislave bus,
    though the most common configuration is that of a single master device and one
    or more slave devices on a single bus. An I2C master device sets the pace for
    the bus by generating a clock signal, and it initiates communication with the
    slave devices. Slave devices receive the master's clock signal and respond to
    the master's queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only four wires are required to communicate via I2C:'
  prefs: []
  type: TYPE_NORMAL
- en: One clock signal (SCL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One data signal (SDA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive supply voltage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring only two pins (for the SCL and SDA signals) to communicate with a
    number of slave devices makes I2C an enticing interfacing option. One of the difficulties
    in hardware interfacing is effectively allocating a limited number of processor
    pins to best handle communicating with a large number of different devices simultaneously.
    By only requiring two processor pins to communicate with a variety of devices,
    I2C frees up pins that can now be allocated to other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding I2C](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of the I2C bus with a single master device and three slave devices
  prefs: []
  type: TYPE_NORMAL
- en: Devices that use I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the flexibility and wide usage of the I2C bus, there are many devices
    that use it for communication. Different varieties of storage devices, such as
    EEPROM and FRAM ICs, are commonly interfaced via I2C. For example, the EEPROMs
    present on BBB capes are all accessed by the BBB's processor via I2C. Sensors
    for temperature, pressure, and humidity, accelerometers, LCD controllers, and
    stepper motor controllers are all examples of devices that are available through
    the I2C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing for I2C on the BBB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AM335X processor of the BBB provides three I2C buses:'
  prefs: []
  type: TYPE_NORMAL
- en: I2C0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BBB exposes the I2C1 and I2C2 buses via its P9 header, but the I2C0 bus
    is not easily accessible. I2C0 currently provides the communication channel between
    the BBB's processor and the HDMI framer chip of the built-in HDMI cape, so it
    should be considered unavailable for your use (unless you would like to void your
    warranty by soldering wires directly to the traces and chip pins on the BBB).
  prefs: []
  type: TYPE_NORMAL
- en: The I2C1 bus is available for your general use and is often the *go to* bus
    for I2C interfacing. If I2C1 is at its maximum capacity or unavailable, the I2C2
    bus is also available for your use.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to I2C via the P9 header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, I2C1 is not muxed to any pins and I2C2 is available via the P9.19
    and P9.20 pins. I2C2 provides I2C communication between the identification EEPROMs
    present on external cape boards and the kernel's capemgr. You can mux I2C2 to
    other pins, or even disable it entirely, but if you do so, the capemgr will no
    longer be able to automatically detect the presence of cape boards that are attached
    to the BBB. Generally speaking, you probably do not want to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows each of the potential pins on the P9 header where
    I2C signals can be muxed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to I2C via the P9 header](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Locations of the I2C buses on the P9 header with different pinmux modes
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing for I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deciding how you would like your pins to be muxed when using I2C in your
    projects, keep the following items in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid muxing any single I2C signal to more than one pin. Doing so wastes one
    of your pins for no good reason.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid muxing I2C2 away from its default location, as this prevents the capemgr
    from automatically detecting cape boards connected to the BBB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the default I2C2 bus for your own projects, but note that it is
    clocked at 100 KHz and the addresses 0x54 through 0x57 are reserved for cape EEPROMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Muxing the I2C1 channel to P9.17 and P9.18 conflicts with the SPI0 channel,
    so you generally wouldn't want to use this configuration if you also wish to use
    SPI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing I2C devices in the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I2C buses and devices are exposed in user space as files in the `/dev` filesystem.
    I2C buses are exposed as the `/dev/i2c-X` file, where `X` is the logical number
    of the I2C channel. While the hardware signals for the I2C bus are clearly numbered
    as 0, 1, and 2, the logical channel numbers won't necessarily be the same as their
    hardware counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Logical channel numbers are assigned in the order that the I2C channels are
    initialized in the Device Tree. For example, the I2C2 channel is usually the second
    I2C channel initialized by the kernel. Therefore, even though it is physical I2C
    channel 2, it will be logical I2C channel 1 and accessible as the `/dev/i2c-1`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath all of the layers of Android APIs and services, Android ultimately
    interacts with device drivers in the kernel by opening files in the `/dev` and
    `/sys` filesystems and then reading, writing, or performing `ioctl()` calls on
    those files. While it is possible to interact with any I2C device using only the
    `ioctl()` calls on the `/dev/i2c-X` files to directly control the I2C bus, this
    approach is complicated and generally should be avoided. Instead, you should try
    to use a kernel driver that communicates with your device on the I2C bus for you.
    You can then make `ioctl()` calls on the file exposed by that kernel driver to
    easily control your device.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android for FRAM use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files to your
    Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable a kernel device driver that handles FRAM
    interfacing, mux the pins to enable the I2C1 bus, and allow your apps to access
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as I2C is concerned, the `BB-PACKTPUB-00A0.dtbo` overlay muxes the P9.24
    and P9.26 pins into the I2C SCL and SDA signals. In the `PacktHAL.tgz` file, the
    source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts` file.
    The code responsible for muxing these two pins is located in the `bb_i2c1a1_pins`
    node within `fragment@0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this sets up the muxing, it doesn''t assign and configure a device driver
    to these pins. The `fragment@1` node performs this kernel driver allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Without going into too much detail, there are four settings in `fragment@1`
    that are of interest to you:'
  prefs: []
  type: TYPE_NORMAL
- en: The first setting is `pinctrl-0`, which ties this node of the Device Tree to
    the pins muxed in the `bb_i2c1a1_pins` node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second setting is `clock-frequency`, which sets the I2C bus speed to 400
    KHz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third setting is `compatible`, which specifies the particular kernel driver
    (the `24c256` driver for EEPROM-like devices) that will handle our hardware device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last setting is `reg`, which specifies the address on the I2C bus where
    this device will reside (`0x50`, in our case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an I2C-interfacing circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an understanding of where I2C devices are connected to the
    BBB and how the Linux kernel presents an interface to those devices, it is time
    to connect an I2C device to the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction
    to Android and the BeagleBone Black"), *Introduction to Android and the BeagleBone
    Black*, you will be interfacing with a FRAM chip in this chapter. Specifically,
    it is a Fujitsu Semiconductor MB85RC256V FRAM chip. This 8-pin chip provides 32
    KB of nonvolatile storage. This particular chip is only available in a **small
    outline package** (**SOP**), which is a surface mount chip that can be difficult
    to work with when building prototype circuits. Luckily for us, the AdaFruit breakout
    board for the FRAM already has the chip mounted, which makes prototyping simple
    and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t disassemble your circuit!**'
  prefs: []
  type: TYPE_NORMAL
- en: The FRAM circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as positioned
    in the diagram (towards the bottom of the breadboard), you can simply leave the
    FRAM breakout board and wires in place as you build the remaining circuits in
    this book. This way, it will already be constructed and working when you reach
    [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing
    Solution").
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the FRAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each I2C device must use an address to identify itself on the I2C bus. The FRAM
    chip that we are using can be configured to use an address in the range of 0x50
    to 0x57\. This is a common address range for EEPROM devices. The exact address
    is set by using the address lines (A0, A1, A2) of the breakout board. The FRAM
    has a base address of 0x50\. If the A0, A1, and/or A2 lines are connected to a
    3.3 V signal, 0x1, 0x2, and/or 0x4 are added to the address, respectively. For
    this interfacing project, none of the addressing lines are connected, which results
    in the FRAM retaining its base address of 0x50 on the I2C bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the FRAM](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The FRAM breakout board (the A0, A1, and A2 addressing lines are the three right-most
    terminals of the board)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The addresses of many I2C devices are configurable by connecting the address
    pins of the device to either the ground or voltage signals. This is because there
    can be multiple copies of the same device on a single I2C bus. The circuit designer
    can assign a different address to each device by rewiring the address pins, rather
    than having to buy different parts with different pre-assigned addresses that
    do not conflict with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the connections between the FRAM breakout board and
    the BBB. The four main I2C bus signals (+3.3 V, ground, and I2C SCL/SDA) are made
    using the pins of the P9 connector, so we've placed the breadboard on the P9 side
    of the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the FRAM](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The complete I2C-interfacing circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect P9.1 (ground) to the vertical ground bus of the breadboard and connect
    P9.3 (3.3 V) to the vertical VCC bus of the breadboard. These connections are
    identical to the ones made for the GPIO breadboard circuit that you created in
    [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The I2C signals, SCL and SDA, are on the P9.24 and P9.26 pins, respectively.
    Wire the P9.24 pin to the pin marked SCL on the breakout board, and wire the P9.26
    pin to the pin marked SDA on the breakout board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire the ground bus to the GND pin of the breakout board and wire the VCC bus
    to the VCC pin of the breakout board. Leave the **write protect** (**WP**) pin
    and the three address pins (A0, A1, A2) unconnected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The FRAM breakout board is now electrically connected to the BBB and is ready
    for your use. Double-check your wiring against the diagram of the complete FRAM
    interfacing circuit to ensure that everything is connected properly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the FRAM connection with I2C tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I2C tools are a set of utilities that allow you to probe and interact with
    the I2C bus. These tools work on systems that use a Linux kernel, and they are
    included in the BBBAndroid image. The utilities interact with the I2C bus by opening
    the `/dev/i2c-X` device files and making `ioctl()` calls on them. By default,
    you must have root access to use `i2c-tools`, but BBBAndroid reduces the permissions
    on the `/dev/i2c-X` files so that any process (including `i2c-tools`) can read
    and write information about the I2C buses.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s try using the `i2cdetect` utility in `i2c-tools`. `i2cdetect`
    will sweep a specified I2C bus and identify bus addresses where I2C devices are
    located. Using the ADB shell, you will probe the i2c-2 physical bus, which is
    also the second logical bus (`/dev/i2c-1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output of `i2cdetect` shows every device detected on the current bus. Any
    address that is not in use has a `--` identifier. Any address that is reserved
    for a device driver in the Device Tree, but does not currently have a device located
    at that address, has a `UU` identifier. If a device is detected at a particular
    address, the device's two-digit hexadecimal address will appear as an identifier
    in the `i2cdetect` output.
  prefs: []
  type: TYPE_NORMAL
- en: The output of `i2cdetect` shows that the Device Tree has allocated drivers for
    four I2C devices on the i2c-2 physical bus. These four devices are the EEPROMs
    at addresses 0x54-0x57 of the capemgr. The devices aren't actually present because
    no cape boards are connected to the BBB, so each address has a `UU` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the FRAM breakout board is electrically connected to the BBB, you must
    verify that the FRAM is a visible device on the I2C bus. To do this, use `i2cdetect`
    to examine the devices present on the i2c-1 physical bus (logical bus 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Double-check your wiring**'
  prefs: []
  type: TYPE_NORMAL
- en: If the `i2cdetect` output shows a `UU` at the 0x50 address location, you know
    that the I2C bus does not recognize the FRAM as being attached. Make sure that
    you don't accidentally swap the SCL (P9.24) and SDA (P9.26) wires when connecting
    the FRAM breakout board to the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the I2C FRAM example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine our example Android app that interfaces with
    the FRAM using I2C on BBB. The purpose of this application is to demonstrate how
    to use PacktHAL to perform FRAM reads and writes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with the FRAM
    from within your Android apps. These functions allow you to retrieve blocks of
    data from the FRAM and write new data to be stored on the FRAM. The low-level
    details of the hardware interfacing are implemented in PacktHAL, so you can quickly
    and easily get your apps interacting with the FRAM breakout board.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging through the FRAM app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app as well as the precompiled `.apk` package, are located in the `chapter4.tgz`
    file, which is available for download from the Packt website. Follow the same
    process to download and add the app to your Eclipse ADT environment that was described
    in [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*.
  prefs: []
  type: TYPE_NORMAL
- en: The app's user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the `fram` app on the Android system to see the app's UI. If you are
    using a touchscreen cape, you can simply touch the **fram** app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the **fram**
    app icon to launch the app. As this app accepts text input from the user, you
    might find it convenient to connect a USB keyboard to the BBB. Otherwise, you'll
    be able to use the onscreen Android keyboard to input text.
  prefs: []
  type: TYPE_NORMAL
- en: This app's UI is a bit more complex than that of the GPIO app in the last chapter,
    but it is still fairly simple. As it is so simple, the only activity that the
    app has is the default `MainActivity`. The UI consists of two text fields, two
    buttons, and two text views.
  prefs: []
  type: TYPE_NORMAL
- en: '![The app''s user interface](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The FRAM sample app screen
  prefs: []
  type: TYPE_NORMAL
- en: The top text field has the `saveEditText` identifier in the `activity_main.xml`
    file. The `saveEditText` field accepts up to 60 characters that will be stored
    to the FRAM. The top button with the **Save** label has the `saveButton` identifier.
    This button has an `onClick()` method called `onClickSaveButton()` that triggers
    the process of interfacing with the FRAM to store the text contained within the
    `saveEditText` text field.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom text field has the `loadEditText` identifier. This text field will
    display any data that is held in the FRAM. The bottom button with the **Load**
    label has the `loadButton` identifier. This button has an `onClick()` method called
    `onClickLoadButton()` that triggers the process of interfacing with the FRAM to
    load the first 60 bytes of data and then updating the text displayed in the `loadEditText`
    text field.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the PacktHAL FRAM functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FRAM interface functionality in PacktHAL is implemented in four C functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openFRAM()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readFRAM()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeFRAM()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeFRAM()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `openFRAM()` function opens the file in the `/dev` filesystem that provides
    the interface to the 24c256 EEPROM kernel driver. Its counterpart function is
    `closeFRAM()`, which closes this file once hardware interfacing with the FRAM
    is no longer needed. The `readFRAM()` function reads a buffer of data from the
    FRAM, and the `writeFRAM()` function writes a buffer of data to the FRAM for persistent
    storage. Together, these four functions provide all of the necessary functionality
    that you need to interact with the FRAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `gpio` app from the previous chapter, the `fram` app loads the
    PacktHAL shared library via a `System.loadLibrary()` call to access the PacktHAL
    FRAM interface functions and the JNI wrapper functions that call them. However,
    unlike the `gpio` app, the `MainActivity` class of the `fram` app does not specify
    methods with the `native` keyword to call the PacktHAL JNI-wrapper C functions.
    Instead, it leaves the hardware interfacing to an *asynchronous task* class named
    `HardwareTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the AsyncTask class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HardwareTask` extends the `AsyncTask` class, and using it provides a major
    advantage over the way hardware interfacing is implemented in the `gpio` app.
    `AsyncTask`s allows you to perform complex and time-consuming hardware-interfacing
    tasks without your app becoming unresponsive while the tasks are executed. Each
    instance of an `AsyncTask` class can create a new **thread of execution** within
    Android. This is similar to how multithreaded programs found on other OSes spin
    new threads to handle file and network I/O, manage UIs, and perform parallel processing.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, the `gpio` app only used a single thread during its
    execution. This thread is the main UI thread that is part of all Android apps.
    The UI thread is designed to handle UI events as quickly as possible. When you
    interact with a UI element, that element's handler method is called by the UI
    thread. For example, clicking a button causes the UI thread to invoke the button's
    `onClick()` handler. The `onClick()` handler then executes a piece of code and
    returns to the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Android is constantly monitoring the execution of the UI thread. If a handler
    takes too long to finish its execution, Android shows an **Application Not Responding**
    (**ANR**) dialog to the user. You *never* want an ANR dialog to appear to the
    user. It is a sign that your app is running inefficiently (or even not at all!)
    by spending too much time in handlers within the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the AsyncTask class](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Application Not Responding dialog in Android
  prefs: []
  type: TYPE_NORMAL
- en: The `gpio` app in the last chapter performed reads and writes of the GPIO states
    very quickly from within the UI thread, so the risk of triggering the ANR was
    very small. Interfacing with the FRAM is a much slower process. With the BBB's
    I2C bus clocked at its maximum speed of 400 KHz, it takes approximately 25 microseconds
    to read or write a byte of data when using the FRAM. While this is not a major
    concern for small writes, reading or writing the entire 32,768 bytes of the FRAM
    can take close to a full second to execute!
  prefs: []
  type: TYPE_NORMAL
- en: Multiple reads and writes of the full FRAM can easily trigger the ANR dialog,
    so it is necessary to move these time-consuming activities out of the UI thread.
    By placing your hardware interfacing into its own `AsyncTask` class, you decouple
    the execution of these time-intensive tasks from the execution of the UI thread.
    This prevents your hardware interfacing from potentially triggering the ANR dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the details of the HardwareTask class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AsyncTask` base class of `HardwareTask` provides many different methods,
    which you can further explore by referring to the Android API documentation. The
    four `AsyncTask` methods that are of immediate interest for our hardware-interfacing
    efforts are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPreExecute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doInBackground()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPostExecute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these four methods, only the `doInBackground()` method executes within its
    own thread. The other three methods all execute within the context of the UI thread.
    Only the methods that execute within the UI thread context are able to update
    screen UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning the details of the HardwareTask class](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The thread contexts in which the HardwareTask methods and the PacktHAL functions
    are executed
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like the `MainActivity` class of the `gpio` app in the last chapter, the
    `HardwareTask` class provides four `native` methods that are used to call PacktHAL
    JNI functions related to FRAM hardware interfacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `openFRAM()` method initializes your app's access to a FRAM located on a
    logical I2C bus (the `bus` parameter) and at a particular bus address (the `address`
    parameter). Once the connection to a particular FRAM is initialized via an `openFRAM()`
    call, all `readFRAM()` and `writeFRAM()` calls will be applied to that FRAM until
    a `closeFRAM()` call is made.
  prefs: []
  type: TYPE_NORMAL
- en: The `readFRAM()` method will retrieve a series of bytes from the FRAM and return
    it as a Java `String`. A total of `bufferSize` bytes are retrieved starting at
    an offset of `offset` bytes from the start of the FRAM. The `writeFRAM()` method
    will store a series of bytes to the FRAM. A total of `bufferSize` characters from
    the Java string `buffer` are stored in the FRAM started at an offset of `offset`
    bytes from the start of the FRAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `fram` app, the `onClick()` handlers for the **Load** and **Save** buttons
    in the `MainActivity` class each instantiate a new `HardwareTask`. Immediately
    after the instantiation of `HardwareTask`, either the `loadFromFRAM()` or `saveToFRAM()`
    method is called to begin interacting with the FRAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `loadFromFRAM()` and `saveToFRAM()` methods in the `HardwareTask`
    class call the base `AsyncTask` class `execution()` method to begin the new thread
    creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each `AsyncTask` instance can only have its `execute()` method called once.
    If you need to run an `AsyncTask` a second time, you must instantiate a new instance
    of it and call the `execute()` method of the new instance. This is why we instantiate
    a new instance of `HardwareTask` in the `onClick()` handlers of the **Load** and
    **Save** buttons, rather than instantiating a single `HardwareTask` instance and
    then calling its `execute()` method many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execute()` method automatically calls the `onPreExecute()` method of the
    `HardwareTask` class. The `onPreExecute()` method performs any initialization
    that must occur prior to the start of the new thread. In the `fram` app, this
    requires disabling various UI elements and calling `openFRAM()` to initialize
    the connection to the FRAM via PacktHAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Disabling your UI elements**'
  prefs: []
  type: TYPE_NORMAL
- en: When you are performing a background operation, you might wish to keep your
    app's user from providing more input until the operation is complete. During a
    FRAM read or write, we do not want the user to press any UI buttons or change
    the data held within the `saveText` text field. If your UI elements remain enabled
    all the time, the user can launch multiple `AsyncTask` instances simultaneously
    by repeatedly hitting the UI buttons. To prevent this, disable any UI elements
    required to restrict user input until that input is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `onPreExecute()` method finishes, the `AsyncTask` base class spins
    a new thread and executes the `doInBackground()` method within that thread. The
    lifetime of the new thread is only for the duration of the `doInBackground()`
    method. Once `doInBackground()` returns, the new thread will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As everything that takes place within the `doInBackground()` method is performed
    in a background thread, it is the perfect place to perform any time-consuming
    activities that would trigger an ANR dialog if they were executed from within
    the UI thread. This means that the slow `readFRAM()` and `writeFRAM()` calls that
    access the I2C bus and communicate with the FRAM should be made from within `doInBackground()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `loadData` and `saveData` string variables used in the `readFRAM()` and
    `writeFRAM()` calls are both class variables of `HardwareTask`. The `saveData`
    variable is populated with the contents of the `saveEditText` text field via a
    `saveEditText.toString()` call in the `HardwareTask` class' `onPreExecute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How do I update the UI from within an AsyncTask thread?**'
  prefs: []
  type: TYPE_NORMAL
- en: While the `fram` app does not make use of them in this example, the `AsyncTask`
    class provides two special methods, `publishProgress()` and `onPublishProgress()`,
    that are worth mentioning. The `AsyncTask` thread uses these methods to communicate
    with the UI thread while the `AsyncTask` thread is running. The `publishProgress()`
    method executes within the `AsyncTask` thread and triggers the execution of `onPublishProgress()`
    within the UI thread. These methods are commonly used to update progress meters
    (hence the name `publishProgress`) or other UI elements that cannot be directly
    updated from within the `AsyncTask` thread. You will use the `publishProgress()`
    and `onPublishProgress()` methods in [Chapter 6](part0041_split_000.html#page
    "Chapter 6. Creating a Complete Interfacing Solution"), *Creating a Complete Interfacing
    Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: After `doInBackground()` has completed, the `AsyncTask` thread terminates. This
    triggers the calling of `doPostExecute()` from the UI thread. The `doPostExecute()`
    method is used for any post-thread cleanup and updating any UI elements that need
    to be modified. The `fram` app uses the `closeFRAM()` PacktHAL function to close
    the current FRAM context that it opened with `openFRAM()` in the `onPreExecute()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The user must now be notified that the task has been completed. If the **Load**
    button was pressed, then the string displayed in the `loadTextField` widget is
    updated via the `MainActivity` class `updateLoadedData()` method. If the **Save**
    button was pressed, a `Toast` message is displayed to notify the user that the
    save was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Giving Toast feedback to the user**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Toast` class is a great way to provide quick feedback to your app's user.
    It pops up a small message that disappears after a configurable period of time.
    If you perform a hardware-related task in the background and you want to notify
    the user of its completion without changing any UI elements, try using a `Toast`
    message! `Toast` messages can only be triggered by methods that are executing
    from within the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning the details of the HardwareTask class](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of the `Toast` message
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `onPostExecute()` method will re-enable all of the UI elements
    that were disabled in `onPreExecute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `onPostExecute()` method has now finished its execution and the app is back
    to patiently waiting for the user to make the next `fram` access request by pressing
    either the **Load** or **Save** button.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you ready for a challenge?**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen all of the pieces of the `fram` app, why not change it
    to add new functionality? For a challenge, try adding a counter that indicates
    to the user how many more characters can be entered into the `saveText` text field
    before the 60-character limit is reached. We have provided one possible implementation
    of this in the `chapter4_challenge.tgz` file, which is available for download
    from the Packt's website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the I2C bus. You constructed a circuit
    that connected an I2C FRAM breakout board to the BBB, and then you did some basic
    testing on the circuit using `i2cdetect` from `i2c-tools` to ensure that the circuit
    was constructed properly and the kernel is able to interact with the circuit via
    the filesystem. You also learned about the portions of the PacktHAL `init.{ro.hardware}.rc`
    file and Device Tree overlay that are responsible for configuring and making the
    I2C bus and I2C device drivers available for your app's use. The `fram` app in
    this chapter demonstrated how to use the `AsyncTask` class to perform time-intensive
    hardware interfacing tasks without stalling the app's UI thread and triggering
    the ANR dialog.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the high-speed **serial peripheral
    interface** (**SPI**) bus and use it to interface with an environmental sensor.
  prefs: []
  type: TYPE_NORMAL
