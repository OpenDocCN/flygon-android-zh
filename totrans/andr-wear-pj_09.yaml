- en: Let us Chat in a Smart Way - Notifications and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter helped us in building a conversational messaging application,
    but the Wear app had a very normal user interface with no notifications whatsoever.
    Notification is a very important aspect of a messaging application, but it needs
    complex infrastructure to process the notification. When the sender sends a message
    to the receiver, the receiver should get a notification conveying certain information,
    such as the sender name, and a quick message preview.
  prefs: []
  type: TYPE_NORMAL
- en: Notification is a component in Android that we can use to display information.
    In the case of a messaging application, the receiver should get the push notification
    to instantiate the notification component. So, whenever there is a real-time database
    update in Firebase, both the handheld device and the Wear device should get the
    notification. Thankfully, we don't need a server to handle the notification; Firebase
    will handle push notifications for your messaging application. When there is an
    update in the real-time database, we need to fire a push notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material design Wear app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase functions are the smartest solution for monitoring database triggers
    and many more server-related executions. Instead of hosting a server, which listens
    to Firebase database changes and then fires the push notification, we shall utilize
    one of the Firebase technologies to complete this task. Firebase functions has
    an efficient control on all the Firebase technologies, such as Firebase authentication,
    storage, analytics, and so on. Firebase functions can be used in various aspects;
    for example, when your analytic cohorts meet some milestone, you can send targeted
    notifications, invites, and so on. Any server level business logic that you might
    want to implement in your Firebase system has been made with Firebase functions.
    We will use Firebase functions for sending push notifications whenever a database
    trigger occurs. We need an entry level JavaScript understanding to complete this
    task.
  prefs: []
  type: TYPE_NORMAL
- en: To get started on Firebase functions, we need Node.js environment that you can
    install it from [https://nodejs.org/](https://nodejs.org/). When you install Node.js,
    it will also install **node package manager** (**npm**). It helps install the
    JavaScript frameworks, plugins, and so on. After installing Node.js, go to the
    terminal or your command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether node is installed by entering `$node --version`. If the CLI returns
    the latest version number, then you are good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you encounter any errors, you should execute the command in the super user
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to a directory in which you wish to save the Firebase function programs
    and authenticate yourself using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After successful authentication you can initialize the Firebase functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The CLI tool will generate the Firebase function and the necessary code in the
    directory you initialized. Open `index.js` in your favorite editor. We create
    a Firebase function for the `Realtime` database events with `functions.database`
    to handle the real-time database triggers. We shall call ref(path) to reach to
    the particular database `path. onwrite()` method from the functions, which will
    send notifications whenever there is an update in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to construct our notification payload, let''s understand our real-time
    database structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that messages have a child named `ashok_geetha`, which conveys that
    these two users' conversations are stored inside with a unique Firebase ID. For
    this implementation, we will pick `ashok_geetha` for push notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `index.js` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we have different firebase structure, using the url-id configuration we
    can trigger the firebase functions for making the pushnotification to work with
    all your users. We just need to make the following change in the url. `/messages/{ChatID}/{pushId}`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the terminal, complete the deployment of Firebase functions with the
    `$ firebase deploy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous Node.js setup fires the push notification using the Firebase functions.
    Now, we need a mechanism to receive the message from the Firebase in our local
    mobile and Wear application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to Android Studio and add the following dependency to your mobile project
    gradle module file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the dependency, create a class called `MessagingService`, which
    extends to the `FirebaseMessagingService` class. The `FirebaseMessaging` class
    extends to `com.google.firebase.iid.zzb` and the `zzb` class extends to Android
    `Service` class. This class will help the communication process between Firebase
    messaging and Android application. It also can display notifications automatically.
    Let''s create the class and extend it to the `FirebaseMessagingService` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to add the override method `onMessageReceived`. This method receives
    the notification when app is at the foreground or background and we can retrieve
    all the notification parameters with the `getnotification()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoteMessage` object will have all the data we sent in the notification
    payload from Firebase functions. Inside the method, add the following code to
    get the title and message content. We are sending a message in the title param
    on the Firebase functions; you can customize it as per your use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For constructing notification, we will use `NotificationCompat.Builder` and,
    when a user clicks on the notification, we will take him to `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the method inside `onMessageReceived` and pass the content to the `sendNotification`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete class code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now register the previous service in the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After all, we now have a service for listening to `pushNotification` but we
    need to listen to the particular string we are sending. We can add the string
    to some constants or to the XML file, but when we ask Firebase to send particular
    channel notifications, then we need to subscribe to a channel that is called topic.
    Add the following code in `ChatActivity` and inside the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the earlier operation global, create a class that extends to the `Application`
    class. Inside the `oncreate` method, we can subscribe to the topic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to register the application class in the manifest. The application
    class holds the control on the `onCreate` method of the application lifecycle
    and it will help in maintaining the application life state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! We have successfully configured push notification and are
    receiving it on our mobile phones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the connected Wear device, we will be able to see the following notification
    when we receive it. By default, the `NotificationCompat.Builder` class will help
    Wear devices to receive notifications, and if we want to customize it, we can
    do so by following the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Wear notification component, we can receive the reply right from the
    Wear device to the mobile application. To be able to achieve this, we will use
    the `WearExtender` component from the `NotificationCompat` class. Using this setup,
    users will be able to access the voice input, **Input method framework** (**IMF**),
    and Emoji to reply to the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There will be numerous use cases where we need to send a quick response with
    already stored replies and or quick typing facility. In that case, we can make
    use of `Action.WearableExtender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the project, let's update our messaging service class, where we are
    firing the notification component when the background service receives a push
    notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following instances to global scope of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When a reply is received from the Wear, we will keep that in reference and
    pass it to the notification handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Wear notification is evolving with every new Android release and, right within
    the `NotificationCompat.Builder`, we have all the features that can make your
    mobile app interact with the Wear device. When you have a mobile app and it has
    interactions, such as notifications and so on, from the Wear device, you can get
    textual replies even if you don't have a Wear companion application.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging service class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `MessagingService` class, we have a method called `sendNotification`
    that fires a notification to Wear and mobile devices. Let''s update the method
    with the following code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous methodwhich features in Wear device to have the IMF input, voice
    reply, and drawing emoji symbols. The complete class after modifying the code
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The notification received will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user clicks on the notification, he or she will be given three options,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After receiving the notification on the Wear device, the user will reply with
    his or her thoughts via text or voice input or with the help of emojis. To handle
    this scenario, we need to write one broadcast receiver. Let''s create a class
    called `MessageReplyReceiver`, extend it to the `BroadcastReceiver` class, and
    override the `onReceive` method. When you get the reply, just update the intent
    with the `conversationId. onReceive` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `remoteIntent` object, to receive the data and convert the intent
    data to text, use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `MessageReplyReceiver` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, register `broadcastreceiver` in the manifest as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are completely ready to receive data from the Wear notification component
    to the local application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The voice input screen from the Wear notification component will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the Draw emoji on this screen and Android will predict what you have drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'IMF can be used to reply by typing the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to use Firebase functions to send push
    notifications and to use the notification component from the Wear support library.
    Notifications are integral components in smart devices; they play a crucial role
    by reminding users. We have understood the `NotificationCompat.Builder` class
    and the `WearableExtender` class. We have also explored the input method framework
    and the easiest way to reply with multiple reply mechanisms, such as emojis, voice
    support, and so on.
  prefs: []
  type: TYPE_NORMAL
