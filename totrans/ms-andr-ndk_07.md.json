["```java\nclass iCanvas: public iIntrusiveCounter\n{\npublic:\n```", "```java\n  virtual void SetColor( int R, int G, int B ) = 0;\n  virtual void SetColor( const ivec4& C ) = 0;\n```", "```java\n  virtual void Clear() = 0;\n```", "```java\n  virtual void Rect( int X, int Y,\n    int W, int H, bool Filled ) = 0;\n  virtual void Line( int X1, int Y1, int X2, int Y2 ) = 0;\n```", "```java\n  virtual int CreateTexture( const clPtr<clBitmap>& Pixels ) = 0;\n  virtual int UpdateTexture( int Idx, const clPtr<clBitmap>& Pixels ) = 0;\n  virtual void DeleteTexture( int Idx ) = 0;\n```", "```java\n  virtual void TextureRect( int X, int Y, int W, int H, int SX, int SY, int SW, int SH, int Idx ) = 0;\n```", "```java\n  virtual void TextStr( int X1, int Y1, int X2, int Y2, const std::string& Str, int Size, const LVector4i& Color, int FontID );\n```", "```java\n  virtual void Present() = 0;\n};\n```", "```java\nclass clSDLCanvas: public iCanvas\n{\nprivate:\n  SDL_Renderer* m_Renderer;\npublic:\n  explicit clSDLCanvas( const clPtr<clSDLWindow>& Window )\n  {\n    m_Renderer = SDL_CreateRenderer( Window->GetSDLWindow(), -1, SDL_RENDERER_ACCELERATED );\n  }\n  virtual ~clSDLCanvas();\n```", "```java\n  virtual void Rect( int X, int Y, int W, int H, bool Filled ) override\n  {\n    SDL_Rect R = { X, Y, W, H };\n    Filled ?\n      SDL_RenderFillRect( m_Renderer, &R ) :\n      SDL_RenderDrawRect( m_Renderer, &R );\n  }\n```", "```java\n  virtual void SetColor( int R, int G, int B ) override;\n  {\n    SDL_SetRenderDrawColor( m_Renderer, R, G, B, 0xFF );\n  }\n  virtual void SetColor( const ivec4& C ) override;\n  {\n    SDL_SetRenderDrawColor( m_Renderer, C.x, C.y, C.z, C.w );\n  }\n  virtual void Clear() override;\n  {\n    SDL_RenderClear( m_Renderer );\n  }\n  virtual void Present() override\n  {\n    SDL_RenderPresent( m_Renderer );\n  }\n```", "```java\n  std::vector<SDL_Texture*> m_Textures;\n```", "```java\n  int CreateTexture( const clPtr<clBitmap>& Pixels )\n  {\n    if ( !Pixels ) return -1;\n    SDL_Texture* Tex = SDL_CreateTexture( m_Renderer,\n      SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, Pixels->GetWidth(), Pixels->GetHeight() );\n    SDL_Rect Rect = { 0, 0, Pixels->GetWidth(), Pixels->GetHeight() };\n```", "```java\n    void* TexturePixels = nullptr;\n    int Pitch = 0;\n    int Result = SDL_LockTexture( Tex, &Rect, &TexturePixels, &Pitch );\n```", "```java\n    memcpy( TexturePixels, Pixels->FBitmapData, Pitch * Pixels->GetHeight() );\n    SDL_UnlockTexture(Tex);\n```", "```java\n    int Idx = (int)m_Textures.size();\n    m_Textures.push_back( Tex );\n    return Idx;\n  }\n```", "```java\n  int UpdateTexture( int Idx, const clPtr<clBitmap>& Pixels )\n  {\n    if ( !Pixels ) return;\n    if ( !Pixels || Idx < 0 || Idx >= (int)m_Textures.size() )\n    {\n      return -1;\n    }\n```", "```java\n    Uint32 Fmt;\n    int Access;\n    int W, H;\n    SDL_QueryTexture( m_Textures[Idx], &Fmt, &Access, &W, &H );\n    SDL_Rect Rect = { 0, 0, W, H };\n    void* TexturePixels = nullptr;\n    int Pitch = 0;\n    int res = SDL_LockTexture( m_Textures[Idx], &Rect, &TexturePixels, &Pitch );\n```", "```java\n    memcpy( TexturePixels, Pixels->FBitmapData, Pitch * H );\n    SDL_UnlockTexture( m_Textures[Idx] );\n  }\n```", "```java\n  void DeleteTexture( int Idx )\n  {\n    if ( Idx < 0 || Idx >= (int)m_Textures.size() )\n    {\n      return;\n    }\n    SDL_DestroyTexture( m_Textures[Idx] );\n    m_Textures[Idx] = 0;\n  }\n```", "```java\n  void TextureRect( int X, int Y, int W, int H,\n    int SX, int SY, int SW, int SH, int Idx )\n  {\n    SDL_Rect DstRect = { X, Y, X + W, Y + H };\n    SDL_Rect SrcRect = { SX, SY, SX + SW, SY + SH };\n    SDL_RenderCopy( m_Renderer, m_Textures[Idx], &SrcRect, &DstRect);\n  }\n```", "```java\n  virtual void TextStr(\n    int X1, int Y1, int X2, int Y2,\n    const std::string& Str, int Size,\n    const LVector4i& Color, int FontID );\n};\n```", "```java\nstatic const char RectvShaderStr[] = R\"(\n  uniform vec4 u_RectSize;\n  in vec4 in_Vertex;\n  in vec2 in_TexCoord;\n  out vec2 Coords;\n  void main()\n  {\n    Coords = in_TexCoord;\n    float X1 = u_RectSize.x;\n    float Y1 = u_RectSize.y;\n    float X2 = u_RectSize.z;\n    float Y2 = u_RectSize.w;\n    float Width = X2 - X1;\n    float Height = Y2 - Y1;\n```", "```java\n    vec4 VertexPos = vec4( X1 + in_Vertex.x * Width, Y1 + in_Vertex.y * Height,in_Vertex.z, in_Vertex.w ) * vec4( 2.0, -2.0, 1.0, 1.0 ) + vec4( -1.0, 1.0, 0.0, 0.0 );\n    gl_Position = VertexPos;\n  }\n)\";\n```", "```java\nstatic const char RectfShaderStr[] = R\"(\n  uniform vec4 u_Color;\n  out vec4 out_FragColor;\n  in vec2 Coords;\n  void main()\n  {\n    out_FragColor = u_Color;\n  }\n)\";\n```", "```java\nstatic const char TexRectfShaderStr[] = R\"(\n  uniform vec4 u_Color;\n  out vec4 out_FragColor;\n  in vec2 Coords;\n  uniform sampler2D Texture0;\n  void main()\n  {\n    out_FragColor = u_Color * texture( Texture0, Coords );\n  }\n)\";\n```", "```java\nclGLCanvas::clGLCanvas( const clPtr<clSDLWindow>& Window )\n: m_Window( Window )\n{\n```", "```java\n  LGL3 = std::unique_ptr<sLGLAPI>( new sLGLAPI() );\n  LGL::GetAPI( LGL3.get() );\n```", "```java\n  m_Rect = clGeomServ::CreateRect2D( 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, false, 1 );\n  m_RectVA = new clGLVertexArray();\n  m_RectVA->SetVertexAttribs( m_Rect );\n```", "```java\n  m_RectSP = new clGLSLShaderProgram( RectvShaderStr, RectfShaderStr );\n  m_TexRectSP = new clGLSLShaderProgram( RectvShaderStr, TexRectfShaderStr );\n}\n```", "```java\nvec4 clGLCanvas::ConvertScreenToNDC( int X, int Y, int W, int H ) const\n{\n  float WinW = static_cast<float>( m_Window->GetWidth() );\n  float WinH = static_cast<float>( m_Window->GetHeight() );\n  vec4 Pos( static_cast<float>( X ) / WinW,\n    static_cast<float>( Y ) / WinH,\n    static_cast<float>( X + W ) / WinW,\n    static_cast<float>( Y + H ) / WinH );\n  return Pos;\n}\n```", "```java\nvoid clGLCanvas::Rect( int X, int Y, int W, int H, bool Filled )\n{\n  vec4 Pos = ConvertScreenToNDC( X, Y, W, H );\n  LGL3->glDisable( GL_DEPTH_TEST );\n  m_RectSP->Bind();\n  m_RectSP->SetUniformNameVec4Array( \"u_Color\", 1, m_Color );\n  m_RectSP->SetUniformNameVec4Array( \"u_RectSize\", 1, Pos );\n```", "```java\n  if ( m_Color.w < 1.0f )\n  {\n    LGL3->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    LGL3->glEnable( GL_BLEND );\n  }\n  m_RectVA->Draw( false );\n```", "```java\n  if ( m_Color.w < 1.0f )\n  {\n    LGL3->glDisable( GL_BLEND );\n  }\n}\n```", "```java\nint clGLCanvas::CreateTexture( const clPtr<clBitmap>& Pixels )\n{\n  if ( !Pixels ) return -1;\n  m_Textures.emplace_back( new clGLTexture() );\n  m_Textures.back()->LoadFromBitmap( Pixels );\n  return m_Textures.size()-1;\n}\n```", "```java\nvoid clGLCanvas::UpdateTexture( int Idx, const clPtr<clBitmap>& Pixels )\n{\n  if ( m_Textures[ Idx ] ) m_Textures[ Idx ]->LoadFromBitmap( Pixels );\n}\nvoid clGLCanvas::DeleteTexture( int Idx )\n{\n  m_Textures[ Idx ] = nullptr;\n}\n```", "```java\nvoid clGLCanvas::TextureRect( int X, int Y, int W, int H, int SX, int SY, int SW, int SH, int Idx )\n{\n  if ( Idx < 0 || Idx >= (int)m_Textures.size() )\n  {\n    return;\n  }\n  vec4 Pos = ConvertScreenToNDC( X, Y, W, H );\n  LGL3->glDisable( GL_DEPTH_TEST );\n```", "```java\n  m_Textures[ Idx ]->Bind( 0 );\n```", "```java\n  m_TexRectSP->Bind();\n  m_TexRectSP->SetUniformNameVec4Array( \"u_Color\", 1, m_Color );\n  m_TexRectSP->SetUniformNameVec4Array( \"u_RectSize\", 1, Pos );\n```", "```java\n  LGL3->glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );\n  LGL3->glEnable( GL_BLEND );\n  m_RectVA->Draw( false );\n  LGL3->glDisable( GL_BLEND );\n}\n```", "```java\nclass clTextRenderer\n{\n  std::vector<sFTChar> FString;\n```", "```java\n  struct sFTChar\n  {\n    FT_UInt FChar;\n    FT_UInt FIndex;\n```", "```java\n    FT_Glyph FGlyph;\n```", "```java\n    FT_F26Dot6 FWidth;\n    FT_F26Dot6 FAdvance;\n```", "```java\n    FTC_Node FCacheNode;\n```", "```java\n    sFTChar()\n    : FChar( 0 ), FIndex( ( FT_UInt )( -1 ) )\n    , FGlyph( nullptr ), FAdvance( 0 )\n    , FWidth( 0 ), FCacheNode( nullptr )\n    { }\n  };\n```", "```java\nbool TextRenderer::LoadStringWithFont( const std::string& S, int ID, int Height )\n{\n  if ( ID < 0 ) { return false; }\n```", "```java\n  FFace = GetSizedFace( ID, Height );\n  if ( !FFace ) { return false; }\n  bool UseKerning = FT_HAS_KERNING( FFace );\n```", "```java\n  DecodeUTF8( S.c_str() );\n```", "```java\n  for ( size_t i = 0, count = FString.size(); i != count; i++ )\n  {\n    sFTChar& Char = FString[i];\n    FT_UInt ch = Char.FChar;\n```", "```java\n    Char.FIndex = ( ch != '\\r' && ch != '\\n' ) ?\n      GetCharIndex( ID, ch ) : -1;\n```", "```java\n    Char.FGlyph = ( Char.FIndex != -1 ) ?\n      GetGlyph( ID, Height, ch, FT_LOAD_RENDER, &Char.FCacheNode ) : nullptr;\n```", "```java\n    if ( !Char.FGlyph || Char.FIndex == -1 ) continue;\n    SetAdvance( Char );\n```", "```java\n    if ( i > 0 && UseKerning )\n    {\n      Kern( FString[i - 1], Char );\n    }\n  }\n  return true;\n}\n```", "```java\nvoid TextRenderer::SetAdvance( sFTChar& Char )\n{\n  Char.FAdvance = Char.FWidth = 0;\n  if ( !Char.FGlyph ) return;\n```", "```java\n  Char.FAdvance = Char.FGlyph->advance.x >> 10;\n```", "```java\n  FT_BBox bbox;\n  FT_Glyph_Get_CBoxPTR( Char.FGlyph,\n    FT_GLYPH_BBOX_GRIDFIT, &bbox );\n  Char.FWidth = bbox.xMax;\n```", "```java\n  if ( Char.FWidth == 0 && Char.FAdvance != 0 )\n  {\n    Char.FWidth = Char.FAdvance;\n  }\n}\n```", "```java\nvoid TextRenderer::Kern( sFTChar& Left, const sFTChar& Right )\n{\n```", "```java\n  if ( Left.FIndex == -1 || Right.FIndex == -1 ) return;\n  FT_Vector Delta;\n```", "```java\n  FT_Get_KerningPTR( FFace, Left.FIndex, Right.FIndex, FT_KERNING_DEFAULT, &Delta );\n```", "```java\n  Left.FAdvance += Delta.x;\n}\n```", "```java\nvoid TextRenderer::CalculateLineParameters( int* Width, int* MinY, int* MaxY, int* BaseLine ) const\n{\n```", "```java\n  int StrMinY = -1000, StrMaxY = -1000;\n  if ( FString.empty() ) StrMinY = StrMaxY = 0;\n```", "```java\n  int SizeX = 0;\n  for ( size_t i = 0 ; i != FString.size(); i++ )\n  {\n    if ( FString[i].FGlyph == nullptr ) continue;\n```", "```java\n    FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph )FString[i].FGlyph;\n    SizeX += FString[i].FAdvance;\n    int Y = BmpGlyph->top;\n    int H = BmpGlyph->bitmap.rows;\n```", "```java\n    if ( Y > StrMinY ) StrMinY = Y;\n    if ( H - Y > StrMaxY ) StrMaxY = H - Y;\n  }\n```", "```java\n  if ( Width ) { *Width = ( SizeX >> 6 ); }\n  if ( BaseLine ) { *BaseLine = StrMaxY; }\n  if ( MinY ) { *MinY = StrMinY; }\n  if ( MaxY ) { *MaxY = StrMaxY; }\n}\n```", "```java\nbool TextRenderer::DecodeUTF8( const char* InStr )\n{\n```", "```java\n  FIndex = 0;\n  FBuffer = InStr;\n```", "```java\n  FLength = ( int )strlen( InStr );\n  FString.clear();\n  int R = DecodeNextUTF8Char();\n```", "```java\n  while ( ( R != UTF8_LINE_END ) && ( R != UTF8_DECODE_ERROR ) )\n  {\n    sFTChar Ch;\n```", "```java\n    Ch.FChar = R;\n    FString.push_back( Ch );\n    R = DecodeNextUTF8Char();\n  }\n  return ( R != UTF8_DECODE_ERROR );\n}\n```", "```java\nvoid TextRenderer:\n\n{\n  LoadStringWithFont( TextString, FontID, FontHeight );\n```", "```java\n  int x = StartX << 6;\n  for ( size_t j = 0 ; j != FString.size(); j++ )\n  {\n    if ( FString[j].FGlyph != 0 )\n    {\n      FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph ) FString[j].FGlyph;\n```", "```java\n      int in_x = ( x >> 6 ) +\n        ( LeftToRight ? 1 : -1 ) * BmpGlyph->left;\n```", "```java\n      if ( !LeftToRight )\n      {\n        in_x += BmpGlyph->bitmap.width;\n        in_x = StartX + ( StartX - in_x );\n      }\n      DrawGlyphOnBitmap( Out, &BmpGlyph->bitmap,\n        in_x, Y - BmpGlyph->top, Color );\n    }\n```", "```java\n    x += FString[j].FAdvance;\n  }\n}\n```", "```java\nclPtr<clBitmap> TextRenderer::RenderTextWithFont( const std::string& TextString, int FontID, int FontHeight, const ivec4& Color, bool LeftToRight )\n{\n  if ( !LoadStringWithFont( TextString, FontID, FontHeight ) )\n  { return nullptr; }\n  int W, Y;\n  int MinY, MaxY;\n  CalculateLineParameters( &W, &MinY, &MaxY, &Y );\n  int H2 = MaxY + MinY;\n```", "```java\n  clPtr<clBitmap> Result = make_intrusive<clBitmap>( W, H2, L_BITMAP_BGRA8 );\n  Result->Clear();\n```", "```java\n  RenderLineOnBitmap( TextString, FontID, FontHeight, LeftToRight ? 0 : W - 1, MinY, Color, LeftToRight, Result );\n  return Result;\n}\n```", "```java\nvoid TextRenderer::DrawGlyphOnBitmap( const clPtr<clBitmap>& Out, FT_Bitmap* Bitmap, int X0, int Y0, const ivec4& Color ) const\n{\n  int W = Out->GetWidth();\n  int Width = W - X0;\n  if ( Width > Bitmap->width ) { Width = Bitmap->width; }\n  for ( int Y = Y0 ; Y < Y0 + Bitmap->rows ; ++Y )\n  {\n    unsigned char* Src = Bitmap->buffer +\n      ( Y - Y0 ) * Bitmap->pitch;\n```", "```java\n    if ( FMaskMode )\n    {\n      for ( int X = X0 + 0 ; X < X0 + Width ; X++ )\n      {\n        int Int = *Src++;\n        int OutMaskCol = ( Int & 0xFF );\n        Out->SetPixel(X, Y,\n          ivec4i(OutMaskCol,\n            OutMaskCol, OutMaskCol, 255) );\n      }\n    }\n    else\n```", "```java\n    {\n      for ( int X = X0 + 0 ; X < X0 + Width ; X++ )\n      {\n        unsigned int Int = *Src++;\n        ivec4 Col = BlendColors(Color, Out->GetPixel(X, Y), (Int & 0xFF));\n        if ( Int > 0 )\n        {\n          Col.w = Int;\n          Out->SetPixel(X, Y, Col);\n        }\n      }\n    }\n  }\n}\n```", "```java\ninline LVector4i BlendColors( const LVector4i& C1, const LVector4i& C2, unsigned int F )\n{\n  int r = ((C1.x) * F >> 8) + ((C2.x) * (255 - F) >> 8);\n  int g = ((C1.y) * F >> 8) + ((C2.y) * (255 - F) >> 8);\n  int b = ((C1.z) * F >> 8) + ((C2.z) * (255 - F) >> 8);\n  return LVector4i(r, g, b, 255);\n}\n```", "```java\nFT_Library FLibrary;\n```", "```java\nFTC_Manager FManager;\n```", "```java\nFTC_ImageCache FImageCache;\nFTC_CMapCache FCMapCache;\n```", "```java\nstd::map<std::string, void*> FAllocatedFonts;\n```", "```java\nstd::map<std::string, FT_Face> FFontFaceHandles;\n```", "```java\nFT_Error clTextRenderer::LoadFontFile( const std::string& FileName )\n{\n  if ( !FInitialized ) { return -1; }\n```", "```java\n  if ( FAllocatedFonts.count( FileName ) > 0 ) { return 0; }\n```", "```java\n  clPtr<clBlob> DataBlob = LoadFileAsBlob(g_FS, FileName);\n  int DataSize = DataBlob->GetSize();\n  char* Data = new char[DataSize];\n  memcpy( Data, DataBlob->GetData(), DataSize );\n```", "```java\n  FT_Face TheFace;\n  FT_Error Result = FT_New_Memory_FacePTR( FLibrary, ( FT_Byte* )Data, ( FT_Long )DataSize, 0, &TheFace );\n  if ( Result == 0 )\n  {\n    FFontFaceHandles[ FileName ] = TheFace;\n```", "```java\n    FAllocatedFonts[ FileName ] = ( void* )Data;\n    FFontFaces.push_back( FileName );\n  }\n  return Result;\n}\n```", "```java\nvoid clTextRenderer::InitFreeType()\n{\n```", "```java\n  FInitialized = LoadFT();\n  if ( FInitialized )\n  {\n    FInitialized = false;\n```", "```java\n    if ( FT_Init_FreeTypePTR( &FLibrary ) != 0 ) { return; }\n```", "```java\n    if ( FTC_Manager_NewPTR( FLibrary, 0, 0, 0, FreeType_Face_Requester, this, &FManager ) != 0 )\n    { return; }\n```", "```java\n    if ( FTC_ImageCache_NewPTR( FManager,\n      &FImageCache ) != 0)\n    {\n      return;\n    }\n    if ( FTC_CMapCache_NewPTR( FManager, &FCMapCache ) != 0 )\n    {\n      return;\n    }\n    FInitialized = true;\n  }\n}\n```", "```java\nvoid TextRenderer::StopFreeType()\n{\n```", "```java\n  FreeString();\n```", "```java\n  for ( auto p = FAllocatedFonts.begin();\n    p != FAllocatedFonts.end() ; p++ )\n  {\n    delete[] ( char* )( p->second );\n  }\n```", "```java\n  FFontFaces.clear();\n  if ( FManager ) { FTC_Manager_DonePTR( FManager ); }\n  if ( FLibrary ) { FT_Done_FreeTypePTR( FLibrary ); }\n}\n```", "```java\nvoid TextRenderer::FreeString()\n{\n  for ( size_t i = 0 ; i < FString.size() ; i++ )\n    if ( FString[i].FCacheNode != nullptr )\n      FTC_Node_UnrefPTR( FString[i].FCacheNode,\n        FManager );\n  FString.clear();\n}\n```", "```java\nFT_Error TextRenderer::FreeType_Face_Requester(\n  FTC_FaceID FaceID,\n  FT_Library Library,\n  FT_Pointer RequestData,\n  FT_Face* TheFace )\n{\n```", "```java\n  #if defined(_WIN64) || defined(__x86_64__)\n    long long int Idx = ( long long int )FaceID;\n    int FaceIdx = ( int )( Idx & 0x7FFFFFFFF );\n  #else\n    int FaceIdx = reinterpret_cast< int >( FaceID );\n  #endif\n```", "```java\n  if ( FaceIdx < 0 ) { return 1; }\n```", "```java\n  clTextRenderer* This = ( clTextRenderer* )RequestData;\n```", "```java\n  std::string FileName = This->FFontFaces[FaceIdx];\n```", "```java\n  FT_Error LoadResult = This->LoadFontFile( FileName );\n```", "```java\n  *TheFace = ( LoadResult == 0 ) ?\n    This->FFontFaceHandles[FileName] : nullptr;\n  return LoadResult;\n}\n```", "```java\nFT_Face clTextRenderer::GetSizedFace( int FontID, int Height )\n{\n```", "```java\n  FTC_ScalerRec Scaler;\n  Scaler.face_id = IntToID( FontID );\n  Scaler.height = Height;\n  Scaler.width = 0;\n  Scaler.pixel = 1;\n  FT_Size SizedFont;\n```", "```java\n  if ( FTC_Manager_LookupSizePTR( FManager, &Scaler,\n    &SizedFont ) != 0 ) return nullptr;\n  if ( FT_Activate_SizePTR( SizedFont ) != 0 ) return nullptr;\n  return SizedFont->face;\n}\n```", "```java\nFT_Glyph TextRenderer::GetGlyph( int FontID, int Height, FT_UInt Char, FT_UInt LoadFlags, FTC_Node* CNode )\n{\n```", "```java\n  FT_UInt Index = GetCharIndex( FontID, Char );\n```", "```java\n  FTC_ImageTypeRec ImageType;\n  ImageType.face_id = IntToID( FontID );\n  ImageType.height = Height;\n  ImageType.width = 0;\n  ImageType.flags = LoadFlags;\n```", "```java\n  FT_Glyph Glyph;\n  if ( FTC_ImageCache_LookupPTR( FImageCache,\n    &ImageType, Index, &Glyph, CNode ) != 0 )\n  { return nullptr; }\n  return Glyph;\n}\n```", "```java\nFT_UInt clTextRenderer::GetCharIndex( int FontID, FT_UInt Char )\n{\n  return FTC_CMapCache_LookupPTR( FCMapCache,\n    IntToID( FontID ), -1, Char );\n}\n```", "```java\ninline void* IntToID( int FontID )\n{\n  #if defined(_WIN64) || defined (__x86_64__)\n    long long int Idx = FontID;\n  #else\n    int Idx = FontID;\n  #endif\n    FTC_FaceID ID = reinterpret_cast<void*>( Idx );\n  return ID;\n}\n```", "```java\nint clTextRenderer::GetFontHandle( const std::string& FileName )\n{\n```", "```java\n  if ( LoadFontFile( FileName ) != 0 )\n  return -1;\n```", "```java\n  for ( int i = 0 ; i != ( int )FFontFaces.size() ; i++ ) { }\n  if ( FFontFaces[i] == FileName )\n    return i;\n  return -1;\n}\n```", "```java\nvoid clGLCanvas::TextStr( int X1, int Y1, int X2, int Y2, const std::string& Str, int Size, const ivec4& Color, int FontID )\n{\n```", "```java\n  auto B = TextRenderer::Instance()->RenderTextWithFont( Str, FontID, Size, Color, true );\n```", "```java\n  static int Texture = this->CreateTexture();\n```", "```java\n  UpdateTexture( Texture, B );\n```", "```java\n  int SW = X2 - X1 + 1, SH = Y2 - Y1 + 1;\n  this->TextureRect( X1, Y1, X2 - X1 + 1, Y2 - Y1 + 1, 0, 0, SW, SH, Texture );\n}\n```", "```java\nclTextRenderer* clTextRenderer::Instance()\n{\n  static clTextRenderer Instance;\n  return &Instance;\n}\n```", "```java\nclass clUIView: public iIntrusiveCounter\n{\nprotected:\n```", "```java\n  int m_X, m_Y;\n  int m_ScreenX, m_ScreenY;\n  int m_Width, m_Height;\n```", "```java\nprivate:\n  float m_ParentFractionX, m_ParentFractionY;\n  eAlignV m_AlignV;\n  eAlignH m_AlignH;\n  int m_FillMode;\n```", "```java\n  std::vector< clPtr<clUIView> > m_ChildViews;\n```", "```java\npublic:\n  clUIView():\n  m_X( 0 ), m_Y( 0 ), m_Width( 0 ), m_Height( 0 ),\n  m_ScreenX( 0 ), m_ScreenY( 0 ), m_ParentFractionX( 1.0f ),\n  m_ParentFractionY( 1.0f ), m_AlignV( eAlignV_DontCare ),\n  m_AlignH( eAlignH_DontCare ), m_ChildViews( 0 )\n  {}\n```", "```java\n  virtual void SetPosition( int X, int Y ) { m_X = X; m_Y = Y; }\n  virtual void SetSize( int W, int H )\n  { m_Width = W; m_Height = H; }\n  virtual void SetWidth( int W ) { m_Width = W; }\n  virtual void SetHeight( int H ) { m_Height = H; }\n  virtual int GetWidth() const { return m_Width; }\n  virtual int GetHeight() const { return m_Height; }\n  virtual int GetX() const { return m_X; }\n  virtual int GetY() const { return m_Y; }\n```", "```java\n  virtual void SetAlignmentV( eAlignV V ) { m_AlignV = V; }\n  virtual void SetAlignmentH( eAlignH H ) { m_AlignH = H; }\n  virtual eAlignV GetAlignmentV() const { return m_AlignV; }\n  virtual eAlignH GetAlignmentH() const { return m_AlignH; }\n  virtual void SetParentFractionX( float X )\n  { m_ParentFractionX = X; }\n  virtual void SetParentFractionY( float Y )\n  { m_ParentFractionY = Y; }\n```", "```java\n  virtual void Add( const clPtr<clUIView>& V )\n  {\n    m_ChildViews.push_back( V );\n  }\n  virtual void Remove( const clPtr<clUIView>& V )\n  {\n    m_ChildViews.erase( std::remove( m_ChildViews.begin(), m_ChildViews.end(), V ), m_ChildViews.end() );\n  }\n```", "```java\n  virtual const std::vector< clPtr<clUIView> >&\n    GetChildViews() const { return m_ChildViews; }\n```", "```java\n  virtual void Draw( const clPtr<iCanvas>& C )\n  {\n    this->PreDrawView( C );\n    for ( auto& i : m_ChildViews )\n    {\n      i->Draw( C );\n    }\n    this->PostDrawView( C );\n  }\n```", "```java\n  virtual void UpdateScreenPositions( int ParentX = 0, int ParentY = 0 )\n  {\n    m_ScreenX = ParentX + m_X;\n    m_ScreenY = ParentY + m_Y;\n    for ( auto& i : m_ChildViews )\n    {\n      i->UpdateScreenPositions( m_ScreenX, m_ScreenY );\n    }\n  }\n```", "```java\n  virtual void Update( double Delta )\n  {\n    for( auto& i: m_ChildViews )\n    i->Update( Delta );\n  }\n```", "```java\n  virtual bool OnTouch( int x, int y, bool Pressed )\n  {\n    if ( IsPointOver( x, y ) )\n    {\n```", "```java\n      for( auto& i: m_ChildViews )\n      {\n        if( i->OnTouch( x, y, Pressed ) )\n        return true;\n      }\n    }\n    return false;\n  }\n```", "```java\n  virtual bool IsPointOver( int x, int y ) const\n  {\n    return ( x >= m_ScreenX ) &&\n      ( x <= m_ScreenX + m_Width  ) &&\n      ( y >= m_ScreenY ) &&\n      ( y <= m_ScreenY + m_Height );\n  }\n```", "```java\nprotected:\n  virtual void PreDrawView( const clPtr<iCanvas>& C ) {};\n  virtual void PostDrawView( const clPtr<iCanvas>& C ) {};\n};\n```", "```java\nbool clSDLWindow::HandleEvent( const SDL_Event& Event );\n```", "```java\ncase SDL_MOUSEBUTTONDOWN:\n  OnTouch( Event.button.x, Event.button.y, true );\n  break;\ncase SDL_MOUSEBUTTONUP:\n  OnTouch( Event.button.x, Event.button.y, false );\n  break;\n```", "```java\nExitBtn->SetTouchHandler(\n  [](int x, int y )\n  {\n    LOGI( \"Exiting\" );\n    g_Window->RequestExit();\n    return true;\n  }\n);\n```", "```java\nclass clUIStatic: public clUIView\n{\npublic:\n  clUIStatic() : m_BackgroundColor( 255, 255, 255, 255 ) {}\n  virtual void SetBackgroundColor( const ivec4& C )\n  { m_BackgroundColor = C;};\nprotected:\n  virtual void PreDrawView( const clPtr<iCanvas>& C ) override\n  {\n    C->SetColor( m_BackgroundColor );\n    C->Rect(m_ScreenX, m_ScreenY, m_Width, m_Height, true);\n    clUIView::PreDrawView( C );\n  }\nprivate:\n  ivec4 m_BackgroundColor;\n};\n```", "```java\ntypedef std::function<bool(int x, int y)> sTouchHandler;\n  class clUIButton: public clUIStatic\n{\npublic:\n  clUIButton(): m_OnTouchHandler(nullptr) {}\n  virtual bool OnTouch( int x, int y, bool Pressed ) override\n  {\n    if( IsPointOver( x, y ) )\n    {\n      if(!Pressed && m_OnTouchHandler )\n      return m_OnTouchHandler(x, y);\n    }\n    return false;\n  }\n  virtual void SetTouchHandler(const sTouchHandler&& H)\n  { m_OnTouchHandler = H; }\nprivate:\n  sTouchHandler m_OnTouchHandler;\n};\n```", "```java\nauto MsgBox = make_intrusive<clUIButton>();\nMsgBox->SetParentFractionX( 0.5f );\nMsgBox->SetParentFractionY( 0.5f );\nMsgBox->SetAlignmentV( eAlignV_Center );\nMsgBox->SetAlignmentH( eAlignH_Center );\nMsgBox->SetBackgroundColor( ivec4( 255, 255, 255, 255) );\nMsgBox->SetTitle(\"Exit\");\nMsgBox->SetTouchHandler( [](int x, int y )\n  {\n    LOGI( \"Exiting\" );\n    g_Window->RequestExit();\n    return true;\n  }\n);\n```"]