["```java\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.content.res.AssetManager;\nimport android.media.AudioManager;\nimport android.media.SoundPool;\nimport android.util.Log;\n\nimport java.io.IOException;\n\npublic class SoundManager {\n    private SoundPool soundPool;\n    int shoot = -1;\n    int jump = -1;\n    int teleport = -1;\n    int coin_pickup = -1;\n    int gun_upgrade = -1;\n    int player_burn = -1;\n    int ricochet = -1;\n    int hit_guard = -1;\n    int explode = -1;\n    int extra_life = -1;\n```", "```java\npublic void loadSound(Context context){\n    soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);\n    try{\n        //Create objects of the 2 required classes\n        AssetManager assetManager = context.getAssets();\n        AssetFileDescriptor descriptor;\n\n        //create our fx\n        descriptor = assetManager.openFd(\"shoot.ogg\");\n        shoot = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"jump.ogg\");\n        jump = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"teleport.ogg\");\n        teleport = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"coin_pickup.ogg\");\n        coin_pickup = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"gun_upgrade.ogg\");\n        gun_upgrade = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"player_burn.ogg\");\n        player_burn = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"ricochet.ogg\");\n        ricochet = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"hit_guard.ogg\");\n        hit_guard = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"explode.ogg\");\n        explode = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"extra_life.ogg\");\n        extra_life = soundPool.load(descriptor, 0);\n\n    }catch(IOException e){\n        //Print an error message to the console\n        Log.e(\"error\", \"failed to load sound files\");\n\n    }\n\n}\n```", "```java\npublic void playSound(String sound){\n        switch (sound){\n            case \"shoot\":\n                soundPool.play(shoot, 1, 1, 0, 0, 1);\n                break;\n\n            case \"jump\":\n                soundPool.play(jump, 1, 1, 0, 0, 1);\n                break;\n\n            case \"teleport\":\n                soundPool.play(teleport, 1, 1, 0, 0, 1);\n                break;\n\n            case \"coin_pickup\":\n                soundPool.play(coin_pickup, 1, 1, 0, 0, 1);\n                break;\n\n            case \"gun_upgrade\":\n                soundPool.play(gun_upgrade, 1, 1, 0, 0, 1);\n                break;\n\n            case \"player_burn\":\n                soundPool.play(player_burn, 1, 1, 0, 0, 1);\n                break;\n\n            case \"ricochet\":\n                soundPool.play(ricochet, 1, 1, 0, 0, 1);\n                break;\n\n            case \"hit_guard\":\n                soundPool.play(hit_guard, 1, 1, 0, 0, 1);\n                break;\n\n            case \"explode\":\n                soundPool.play(explode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"extra_life\":\n                soundPool.play(extra_life, 1, 1, 0, 0, 1);\n                break;\n\n        }\n\n    }\n}// End SoundManager\n```", "```java\n// Our new engine classes\nprivate LevelManager lm;\nprivate Viewport vp;\nInputController ic;\nSoundManager sm;\n\n```", "```java\n// Initialize the viewport\nvp = new Viewport(screenWidth, screenHeight);\n\nsm = new SoundManager();\nsm.loadSound(context);\n\nloadLevel(\"LevelCave\", 15, 2);\n```", "```java\npublic class Player extends GameObject {\n\n final float MAX_X_VELOCITY = 10;\n boolean isPressingRight = false;\n boolean isPressingLeft = false;\n\n public boolean isFalling;\n private boolean isJumping;\n private long jumpTime;\n private long maxJumpTime = 700;// jump 7 10ths of second\n\n```", "```java\nprivate float xVelocity;\nprivate float yVelocity;\nfinal int LEFT = -1;\nfinal int RIGHT = 1;\nprivate int facing;\nprivate boolean moves = false;\n```", "```java\nvoid move(long fps){\n        if(xVelocity != 0) {\n            this.worldLocation.x += xVelocity / fps;\n        }\n\n        if(yVelocity != 0) {\n            this.worldLocation.y += yVelocity / fps;\n        }\n    }\n```", "```java\npublic int getFacing() {\n  return facing;\n}\n\npublic void setFacing(int facing) {\n  this.facing = facing;\n}\n\npublic float getxVelocity() {\n  return xVelocity;\n}\n\npublic void setxVelocity(float xVelocity) {\n  // Only allow for objects that can move\n  if(moves) {\n    this.xVelocity = xVelocity;\n  }\n}\n\npublic float getyVelocity() {\n  return yVelocity;\n}\n\npublic void setyVelocity(float yVelocity) {\n  // Only allow for objects that can move\n  if(moves) {\n    this.yVelocity = yVelocity;\n  }\n}\n\npublic boolean isMoves() {\n  return moves;\n}\n\npublic void setMoves(boolean moves) {\n  this.moves = moves;\n}\n\npublic void setActive(boolean active) {\n  this.active = active;\n}\n```", "```java\nsetHeight(HEIGHT); // 2 metre tall\nsetWidth(WIDTH); // 1 metre wide\n\n// Standing still to start with\nsetxVelocity(0);\nsetyVelocity(0);\nsetFacing(LEFT);\nisFalling = false;\n\n// Now for the player's other attributes\n// Our game engine will use these\nsetMoves(true);\nsetActive(true);\nsetVisible(true);\n//...\n\n```", "```java\npublic void update(long fps, float gravity) {\n if (isPressingRight) {\n this.setxVelocity(MAX_X_VELOCITY);\n } else if (isPressingLeft) {\n this.setxVelocity(-MAX_X_VELOCITY);\n } else {\n this.setxVelocity(0);\n }\n\n```", "```java\n//which way is player facing?\nif (this.getxVelocity() > 0) {\n  //facing right\n  setFacing(RIGHT);\n} else if (this.getxVelocity() < 0) {\n  //facing left\n  setFacing(LEFT);\n}//if 0 then unchanged\n```", "```java\n// Jumping and gravity\nif (isJumping) {\n  long timeJumping = System.currentTimeMillis() - jumpTime;\n  if (timeJumping < maxJumpTime) {\n    if (timeJumping < maxJumpTime / 2) {\n      this.setyVelocity(-gravity);//on the way up\n       } else if (timeJumping > maxJumpTime / 2) {\n          this.setyVelocity(gravity);//going down\n       }\n  } else {\n    isJumping = false;\n  }\n} else {\n      this.setyVelocity(gravity);\n      // Read Me!\n      // Remove this next line to make the game easier\n      // it means the long jumps are less punishing\n      // because the player can take off just after the platform\n      // They will also be able to cheat by jumping in thin air\n      isFalling = true;\n}\n```", "```java\n // Let's go!\n this.move(fps);\n}// end update()\n```", "```java\n// Set visible flag to true\ngo.setVisible(true);\n\nif (lm.isPlaying()) {\n // Run any un-clipped updates\n go.update(fps, lm.gravity);\n}\n\n} else {\n  // Set visible flag to false\n  //...\n```", "```java\ncanvas.drawText(\"playerY:\" +   lm.gameObjects.get(lm.playerIndex).getWorldLocation().y,\n  10, 140, paint);\n\ncanvas.drawText(\"Gravity:\" + \n lm.gravity, 10, 160, paint);\n\ncanvas.drawText(\"X velocity:\" +   lm.gameObjects.get(lm.playerIndex).getxVelocity(), \n 10, 180, paint);\n\ncanvas.drawText(\"Y velocity:\" +   lm.gameObjects.get(lm.playerIndex).getyVelocity(), \n 10, 200, paint);\n\n//for reset the number of clipped objects each frame\n```", "```java\npublic void switchPlayingStatus() {\n        playing = !playing;\n        if (playing) {\n            gravity = 6;\n        } else {\n            gravity = 0;\n        }\n    }\n```", "```java\n// Load all the GameObjects and Bitmaps\nloadMapData(context, pixelsPerMetre, px, py);\n\n//playing = true;\n//..\n```", "```java\n@Override\npublic boolean onTouchEvent(MotionEvent motionEvent) {\n  switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n    case MotionEvent.ACTION_DOWN:\n         lm.switchPlayingStatus();\n         break;\n   }\nreturn true;\n}\n```", "```java\nif (lm.isPlaying()) {\n    //Reset the players location as the centre of the viewport\n    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().x,\n        lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().y);}\n}// End of update()\n```", "```java\npublic class RectHitbox {\n    float top;\n    float left;\n    float bottom;\n    float right;\n    float height;\n\n    boolean intersects(RectHitbox rectHitbox){\n        boolean hit = false;\n\n        if(this.right > rectHitbox.left\n                && this.left < rectHitbox.right ){\n            // Intersecting on x axis\n\n            if(this.top < rectHitbox.bottom\n                    && this.bottom > rectHitbox.top ){\n                // Intersecting on y as well\n                // Collision\n                hit = true;\n            }\n        }\n\n        return hit;\n    }\n\n    public void setTop(float top) {\n        this.top = top;\n    }\n\n    public float getLeft() {\n        return left;\n    }\n\n    public void setLeft(float left) {\n        this.left = left;\n    }\n\n    public void setBottom(float bottom) {\n        this.bottom = bottom;\n    }\n\n    public float getRight() {\n        return right;\n    }\n\n    public void setRight(float right) {\n        this.right = right;\n    }\n\n    public float getHeight() {\n        return height;\n    }\n\n    public void setHeight(float height) {\n        this.height = height;\n    }\n}\n```", "```java\nprivate RectHitbox rectHitbox = new RectHitbox();\n```", "```java\npublic void setRectHitbox() {\n   rectHitbox.setTop(worldLocation.y);\n   rectHitbox.setLeft(worldLocation.x);\n   rectHitbox.setBottom(worldLocation.y + height);\n   rectHitbox.setRight(worldLocation.x + width);\n}\n\nRectHitbox getHitbox(){\n  return rectHitbox;\n}\n```", "```java\n// Where does the tile start\n// X and y locations from constructor parameters\nsetWorldLocation(worldStartX, worldStartY, 0);\nsetRectHitbox();\n}// End of Grass constructor\n```", "```java\nRectHitbox rectHitboxFeet;\nRectHitbox rectHitboxHead;\nRectHitbox rectHitboxLeft;\nRectHitbox rectHitboxRight;\n```", "```java\nrectHitboxFeet = new RectHitbox();\nrectHitboxHead = new RectHitbox();\nrectHitboxLeft = new RectHitbox();\nrectHitboxRight = new RectHitbox();\n```", "```java\n// Let's go!\nthis.move(fps);\n\n// Update all the hitboxes to the new location\n// Get the current world location of the player\n// and save them as local variables we will use next\nVector2Point5D location = getWorldLocation();\nfloat lx = location.x;\nfloat ly = location.y;\n\n//update the player feet hitbox\nrectHitboxFeet.top = ly + getHeight() * .95f;\nrectHitboxFeet.left = lx + getWidth() * .2f;\nrectHitboxFeet.bottom = ly + getHeight() * .98f;\nrectHitboxFeet.right = lx + getWidth() * .8f;\n\n// Update player head hitbox\nrectHitboxHead.top = ly;\nrectHitboxHead.left = lx + getWidth() * .4f;\nrectHitboxHead.bottom = ly + getHeight() * .2f;\nrectHitboxHead.right = lx + getWidth() * .6f;\n\n// Update player left hitbox\nrectHitboxLeft.top = ly + getHeight() * .2f;\nrectHitboxLeft.left = lx + getWidth() * .2f;\nrectHitboxLeft.bottom = ly + getHeight() * .8f;\nrectHitboxLeft.right = lx + getWidth() * .3f;\n\n// Update player right hitbox\nrectHitboxRight.top = ly + getHeight() * .2f;\nrectHitboxRight.left = lx + getWidth() * .8f;\nrectHitboxRight.bottom = ly + getHeight() * .8f;\nrectHitboxRight.right = lx + getWidth() * .7f;\n\n}// End update()\n```", "```java\npublic int checkCollisions(RectHitbox rectHitbox) {\n    int collided = 0;// No collision\n\n    // The left\n    if (this.rectHitboxLeft.intersects(rectHitbox)) {\n        // Left has collided\n        // Move player just to right of current hitbox\n        this.setWorldLocationX(rectHitbox.right - getWidth() * .2f);\n        collided = 1;\n    }\n\n    // The right\n    if (this.rectHitboxRight.intersects(rectHitbox)) {\n        // Right has collided\n        // Move player just to left of current hitbox\n        this.setWorldLocationX(rectHitbox.left - getWidth() * .8f);\n        collided = 1;\n    }\n\n    // The feet\n    if (this.rectHitboxFeet.intersects(rectHitbox)) {\n        // Feet have collided\n        // Move feet to just above current hitbox\n        this.setWorldLocationY(rectHitbox.top - getHeight());\n        collided = 2;\n    }\n\n    // Now the head\n    if (this.rectHitboxHead.intersects(rectHitbox)) {\n        // Head has collided. Ouch!\n        // Move head to just below current hitbox bottom\n        this.setWorldLocationY(rectHitbox.bottom);\n        collided = 3;\n    }\n\n    return collided;\n}\n```", "```java\npublic void setWorldLocationY(float y) {\n  this.worldLocation.y = y;\n}\n\npublic void setWorldLocationX(float x) {\n  this.worldLocation.x = x;\n}\n```", "```java\n// Set visible flag to true\ngo.setVisible(true);\n\n// check collisions with player\nint hit = lm.player.checkCollisions(go.getHitbox());\nif (hit > 0) {\n //collision! Now deal with different types\n switch (go.getType()) {\n\n default:// Probably a regular tile\n if (hit == 1) {// Left or right\n lm.player.setxVelocity(0);\n lm.player.setPressingRight(false);\n }\n\n if (hit == 2) {// Feet\n lm.player.isFalling = false;\n }\n\n break;\n }\n}\n\n```", "```java\npublic void setPressingRight(boolean isPressingRight) {\n        this.isPressingRight = isPressingRight;\n    }\n\n    public void setPressingLeft(boolean isPressingLeft) {\n        this.isPressingLeft = isPressingLeft;\n    }\n\n    public void startJump(SoundManager sm) {\n        if (!isFalling) {//can't jump if falling\n            if (!isJumping) {//not already jumping\n                isJumping = true;\n                jumpTime = System.currentTimeMillis();\n                sm.playSound(\"jump\");\n            }\n        }\n    }\n```", "```java\n@Override\n    public boolean onTouchEvent(MotionEvent motionEvent) {\n        if (lm != null) {\n            ic.handleInput(motionEvent, lm, sm, vp);\n        }\n        //invalidate();\n        return true;\n    }\n```", "```java\nimport android.graphics.Rect;\nimport android.view.MotionEvent;\nimport java.util.ArrayList;\n\npublic class InputController {\n\n    Rect left;\n    Rect right;\n    Rect jump;\n    Rect shoot;\n    Rect pause;\n\n    InputController(int screenWidth, int screenHeight) {\n\n        //Configure the player buttons\n        int buttonWidth = screenWidth / 8;\n        int buttonHeight = screenHeight / 7;\n        int buttonPadding = screenWidth / 80;\n\n        left = new Rect(buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth,\n            screenHeight - buttonPadding);\n\n        right = new Rect(buttonWidth + buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth + buttonPadding + buttonWidth,\n            screenHeight - buttonPadding);\n\n        jump = new Rect(screenWidth - buttonWidth - buttonPadding,\n            screenHeight - buttonHeight - buttonPadding -                           \n            buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding - buttonHeight -                           \n            buttonPadding);\n\n        shoot = new Rect(screenWidth - buttonWidth - buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding);\n\n        pause = new Rect(screenWidth - buttonPadding -                          \n            buttonWidth,\n            buttonPadding,\n            screenWidth - buttonPadding,\n            buttonPadding + buttonHeight);\n\n    }\n```", "```java\npublic ArrayList getButtons(){\n   //create an array of buttons for the draw method\n   ArrayList<Rect> currentButtonList = new ArrayList<>();\n   currentButtonList.add(left);\n   currentButtonList.add(right);\n   currentButtonList.add(jump);\n   currentButtonList.add(shoot);\n   currentButtonList.add(pause);\n   return  currentButtonList;\n}\n```", "```java\npublic void handleInput(MotionEvent motionEvent,LevelManager l,     \n  SoundManager sound, Viewport vp){\n\n    int pointerCount = motionEvent.getPointerCount();\n\n    for (int i = 0; i < pointerCount; i++) {\n\n        int x = (int) motionEvent.getX(i);\n        int y = (int) motionEvent.getY(i);\n\n        if(l.isPlaying()) {\n            switch  (motionEvent.getAction() &\n            MotionEvent.ACTION_MASK) {\n\n            case MotionEvent.ACTION_DOWN:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(true);\n                    l.player.setPressingLeft(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(true);\n                    l.player.setPressingRight(false);\n\n                    } else if (jump.contains(x, y)) {\n                    l.player.startJump(sound);\n\n                    } else if (shoot.contains(x, y)) {\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                    }\n\n                break;\n\n                case MotionEvent.ACTION_UP:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(false);\n                }\n\n                break;\n\n                case MotionEvent.ACTION_POINTER_DOWN:\n                if (right.contains(x, y)) {\n                    l.player.setPressingRight(true);\n                    l.player.setPressingLeft(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(true);\n                        l.player.setPressingRight(false);\n\n                    } else if (jump.contains(x, y)) {\n                    l.player.startJump(sound);\n\n                    } else if (shoot.contains(x, y)) {\n                    //Handle shooting here\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                }\n\n                    break;\n\n                case MotionEvent.ACTION_POINTER_UP:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(false);\n                   //Log.w(\"rightP:\", \"up\" );\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(false);\n                   //Log.w(\"leftP:\", \"up\" );\n\n                    } else if (shoot.contains(x, y)) {\n                    //Handle shooting here\n                    } else if (jump.contains(x, y)) {\n                   //Handle more jumping stuff here later\n                }\n\n                break;\n}// End if(l.playing)\n\n}else {// Not playing\n    //Move the viewport around to explore the map\n    switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n\n    case MotionEvent.ACTION_DOWN:\n\n        if (pause.contains(x, y)) {\n            l.switchPlayingStatus();\n            //Log.w(\"pause:\", \"DOWN\" );\n        }\n\n      break;\n            }\n        }\n    }\n}\n}\n```", "```java\n//draw buttons\npaint.setColor(Color.argb(80, 255, 255, 255));\nArrayList<Rect> buttonsToDraw;\nbuttonsToDraw = ic.getButtons();\n\nfor (Rect rect : buttonsToDraw) {\n  RectF rf = new RectF(rect.left, rect.top, \n    rect.right, rect.bottom);\n\n    canvas.drawRoundRect(rf, 15f, 15f, paint);\n}\n```", "```java\n//draw paused text\nif (!this.lm.isPlaying()) {\n    paint.setTextAlign(Paint.Align.CENTER);\n    paint.setColor(Color.argb(255, 255, 255, 255));\n\n    paint.setTextSize(120);\n    canvas.drawText(\"Paused\", vp.getScreenWidth() / 2,                       \n    vp.getScreenHeight() / 2, paint);\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Rect;\n\npublic class Animation {\n    Bitmap bitmapSheet;\n    String bitmapName;\n    private Rect sourceRect;\n    private int frameCount;\n    private int currentFrame;\n    private long frameTicker;\n    private int framePeriod;\n    private int frameWidth;\n    private int frameHeight;\n    int pixelsPerMetre;\n```", "```java\nAnimation(Context context, \n  String bitmapName, float frameHeight, \n  float frameWidth, int animFps, \n  int frameCount, int pixelsPerMetre){\n\n   this.currentFrame = 0;\n   this.frameCount = frameCount;\n   this.frameWidth = (int)frameWidth * pixelsPerMetre;\n   this.frameHeight = (int)frameHeight * pixelsPerMetre;\n   sourceRect = new Rect(0, 0, this.frameWidth, this.frameHeight);\n\n   framePeriod = 1000 / animFps;\n   frameTicker = 0l;\n   this.bitmapName = \"\" + bitmapName;\n   this.pixelsPerMetre = pixelsPerMetre;\n}\n```", "```java\npublic Rect getCurrentFrame(long time, \n    float xVelocity, boolean moves){\n\n    if(xVelocity!=0 || moves == false) {\n    // Only animate if the object is moving \n    // or it is an object which doesn't move\n    // but is still animated (like fire)\n\n        if (time > frameTicker + framePeriod) {\n            frameTicker = time;\n            currentFrame++;\n            if (currentFrame >= frameCount) {\n                currentFrame = 0;\n            }\n        }\n    }\n\n    //update the left and right values of the source of\n    //the next frame on the spritesheet\n    this.sourceRect.left = currentFrame * frameWidth;\n    this.sourceRect.right = this.sourceRect.left + frameWidth;\n\n    return sourceRect;\n\n}\n\n}// End of Animation class\n```", "```java\n// Most objects only have 1 frame\n// And don't need to bother with these\nprivate Animation anim = null;\nprivate boolean animated;\nprivate int animFps = 1;\n```", "```java\npublic void setAnimFps(int animFps) {\n  this.animFps = animFps;\n}\n\npublic void setAnimFrameCount(int animFrameCount) {\n  this.animFrameCount = animFrameCount;\n}\n\npublic boolean isAnimated() {\n  return animated;\n}\n```", "```java\npublic void setAnimated(Context context, int pixelsPerMetre,  \n  boolean animated){\n\n this.animated = animated;\n this.anim = new Animation(context, bitmapName,\n     height,\n     width,\n     animFps,\n     animFrameCount,\n     pixelsPerMetre );\n}\n```", "```java\npublic Rect getRectToDraw(long deltaTime){\n  return anim.getCurrentFrame(\n    deltaTime, \n    xVelocity, \n    isMoves());\n}\n```", "```java\nsetBitmapName(\"player\");\n\nfinal int ANIMATION_FPS = 16;\nfinal int ANIMATION_FRAME_COUNT = 5;\n\n// Set this object up to be animated\nsetAnimFps(ANIMATION_FPS);\nsetAnimFrameCount(ANIMATION_FRAME_COUNT);\nsetAnimated(context, pixelsPerMetre, true);\n\n// X and y locations from constructor parameters\nsetWorldLocation(worldStartX, worldStartY, 0);\n```", "```java\ntoScreen2d.set(vp.worldToScreen\n  go.getWorldLocation().x,\n  go.getWorldLocation().y,\n  go.getWidth(),\n  go.getHeight()));\n\nif (go.isAnimated()) {\n // Get the next frame of the bitmap\n // Rotate if necessary\n if (go.getFacing() == 1) {\n // Rotate\n Matrix flipper = new Matrix();\n flipper.preScale(-1, 1);\n Rect r = go.getRectToDraw(System.currentTimeMillis());\n Bitmap b = Bitmap.createBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n r.left,\n r.top,\n r.width(),\n r.height(),\n flipper,\n true);\n canvas.drawBitmap(b, toScreen2d.left, toScreen2d.top, paint);\n} else {\n // draw it the regular way round\n canvas.drawBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n go.getRectToDraw(System.currentTimeMillis()),\n toScreen2d, paint);\n}\n} else { // Just draw the whole bitmap\n canvas.drawBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n toScreen2d.left,\n toScreen2d.top, paint);\n}\n\n```"]