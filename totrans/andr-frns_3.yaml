- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android file systems and data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information in this chapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: • [Data in the shell](#S0015)
  prefs: []
  type: TYPE_NORMAL
- en: • [Type of memory](#S0090)
  prefs: []
  type: TYPE_NORMAL
- en: • [File systems](#S0105)
  prefs: []
  type: TYPE_NORMAL
- en: • [Mounted file systems and directory structures](#S0145)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the underlying hardware and software powering Android devices is fascinating,
    the primary focus of forensic analysts and security engineers is to acquire, analyze,
    and understand data stored on a device. Like other topics discussed, there are
    many nuances to this that are important to understand for effective analysis including
    what types of data are stored, where they are stored, how they are stored, and
    characteristics of the physical mediums on which they are stored. All of these
    factors play a major role in what data can be recovered and how they can be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: Data in the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forensic analysts are primarily concerned with data artifacts that can be recovered
    from the devices they investigate. Android is a combination of both well-known
    artifacts, such as those found in Linux, and entirely new ones, such as the Dalvik
    VM and the YAFFS2 file system. Adding to the complexity are the varying architectures
    that different manufacturers embrace.
  prefs: []
  type: TYPE_NORMAL
- en: While no single book or examiner could possibly cover this topic exhaustively,
    there are certain fundamental concepts common to Android devices. File systems,
    file, and other artifacts are at the core of what forensic analysts must understand
    about Android to maximize the effectiveness of their investigations.
  prefs: []
  type: TYPE_NORMAL
- en: What Data are Stored
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android devices store an enormous amount of data, typically combining both
    personal and work data. Apps are the primary source of these data, and there are
    a number of sources for apps including:'
  prefs: []
  type: TYPE_NORMAL
- en: • Apps that ship with Android
  prefs: []
  type: TYPE_NORMAL
- en: • Apps installed by the manufacturer
  prefs: []
  type: TYPE_NORMAL
- en: • Apps installed by the wireless carrier
  prefs: []
  type: TYPE_NORMAL
- en: • Additional Google/Android apps
  prefs: []
  type: TYPE_NORMAL
- en: • Apps installed by the user, typically from the Android Market
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](CHP007.html), Android Application and Forensic Analysis, will examine
    a number of these apps in detail, although it is certainly beyond the scope of
    this book to cover all possibilities. A sample of data found on Android devices
    includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Text messages (SMS/MMS)
  prefs: []
  type: TYPE_NORMAL
- en: • Contacts
  prefs: []
  type: TYPE_NORMAL
- en: • Call logs
  prefs: []
  type: TYPE_NORMAL
- en: • E-mail messages (Gmail, Yahoo, Exchange)
  prefs: []
  type: TYPE_NORMAL
- en: • Instant Messenger/Chat
  prefs: []
  type: TYPE_NORMAL
- en: • GPS coordinates
  prefs: []
  type: TYPE_NORMAL
- en: • Photos/Videos
  prefs: []
  type: TYPE_NORMAL
- en: • Web history
  prefs: []
  type: TYPE_NORMAL
- en: • Search history
  prefs: []
  type: TYPE_NORMAL
- en: • Driving directions
  prefs: []
  type: TYPE_NORMAL
- en: • Facebook, Twitter, and other social media clients
  prefs: []
  type: TYPE_NORMAL
- en: • Files stored on the device
  prefs: []
  type: TYPE_NORMAL
- en: • Music collections
  prefs: []
  type: TYPE_NORMAL
- en: • Calendar appointments
  prefs: []
  type: TYPE_NORMAL
- en: • Financial information
  prefs: []
  type: TYPE_NORMAL
- en: • Shopping history
  prefs: []
  type: TYPE_NORMAL
- en: • File sharing
  prefs: []
  type: TYPE_NORMAL
- en: App Data Storage Directory Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android applications primarily store data in two locations, internal and external
    storage, both of which will be covered in more detail later in this chapter. However,
    it is helpful to have a high-level understanding of the data storage directory
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the external data storage areas (the SD card and emulated SD cards), applications
    can store data in any location they wish. However, internal data storage is controlled
    by the Android APIs. When an application is installed (through either the market
    place or in the build shipped to the consumer), an internal data storage is saved
    in a subdirectory of /data/data/ named after the package name. For example, the
    default Android browser has a package name of com.android.browser and, as such,
    the data files are stored in /data/data/com.android.browser. While applications
    are not required to store data files, most do.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the applications /data/data subdirectory, there are a number of standard
    directories found in many applications as well as directories that developers
    control. The most common standard subdirectories are listed in [Table 4.1](#T0010).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 Common /data/data/<packageName> Subdirectories
  prefs: []
  type: TYPE_NORMAL
- en: '| shared_prefs | Directory Storing Shared Preferences in XML Format |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| lib | Custom library files an application requires |'
  prefs: []
  type: TYPE_TB
- en: '| files | Files the developer saves to internal storage |'
  prefs: []
  type: TYPE_TB
- en: '| cache | Files cached by the application, often cache files from the web browser
    or other apps that use the WebKit engine |'
  prefs: []
  type: TYPE_TB
- en: '| databases | SQLite databases and journal files |'
  prefs: []
  type: TYPE_TB
- en: '[Table 4.1](#T0010) only presents the most common subdirectories found in an
    application’s /data/data file. As we examine data more closely throughout this
    book, we will catalog many additional folders and data files.'
  prefs: []
  type: TYPE_NORMAL
- en: How Data are Stored
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android provides developers with five methods for storing data to a device.
    Forensic examiners can uncover data in at least four of the five formats. Therefore,
    it is important to understand each in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistent data are stored to either the NAND flash, the SD card, or the network.
    Specifically, the five methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Shared preferences
  prefs: []
  type: TYPE_NORMAL
- en: 2. Internal storage
  prefs: []
  type: TYPE_NORMAL
- en: 3. External storage
  prefs: []
  type: TYPE_NORMAL
- en: 4. SQLite
  prefs: []
  type: TYPE_NORMAL
- en: 5. Network
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the data that app developers store, the Linux kernel and Android stack
    provide information through logs, debugging, and other standard information services.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Preferences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Shared preferences allow a developer to store key-value pairs of primitive
    data types in a lightweight XML format. Primitive data types that can be stored
    in a preferences file include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '1. boolean: true or false'
  prefs: []
  type: TYPE_NORMAL
- en: '2. float: single-precision 32-bit IEEE 754 floating point'
  prefs: []
  type: TYPE_NORMAL
- en: '3. int: 32-bit signed two’s complement integer'
  prefs: []
  type: TYPE_NORMAL
- en: '4. long: 64-bit signed two’s complement integer'
  prefs: []
  type: TYPE_NORMAL
- en: '5. strings: string value, typically as a UTF-8'
  prefs: []
  type: TYPE_NORMAL
- en: With these basic types, developers can create and save simple values that power
    their application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared preferences files are typically stored in an application’s data directory
    in the shared_pref folder and end with .xml. On our reference HTC Incredible,
    the Android phone shared preferences directory are five XML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-01-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The com.android.phone_preferences.xml preferences file has examples of int,
    boolean, and string preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-02-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can tell, the XML file describes the string encoding type at the start
    of the file, UTF-8 in this case. There are three preferences that save various
    settings and characteristics. Perhaps most interesting from a forensics standpoint
    is the updateAreaCode.xml:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-03-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mobile directory number (MDN) is queried and the area code for the device
    is stored in this file, presumably to allow a seven-digit dialing option in areas
    supporting that feature.
  prefs: []
  type: TYPE_NORMAL
- en: Since many applications take advantage of the lightweight Shared Preferences
    method for storing key-value pairs, it can be a rich source of forensic data.
    This is especially true when examiners can recover older or deleted versions of
    the XML preferences file.
  prefs: []
  type: TYPE_NORMAL
- en: Files on Internal Storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Files allow developers to store more complicated data structures and are saved
    in several places on the file internal storage. The files are stored in the application’s
    /data/data subdirectory and the developer has control over the file type, name,
    and location. By default, the files can only be read by the application and even
    the device owner is prevented from viewing the files unless they have root access.
    The developer can override the security settings to allow other processes to read
    and even update the file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Identifying custom files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to determine which files in an application’s subdirectory fall
    into this category is by a process of elimination. Basically, any file in the
    application’s /data/data/ subdirectory which is *not* in the shared_prefs, lib,
    cache, or databases subdirectories is a file the developer created and controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine com.google.android.apps.maps that provides a good example of
    files saved on internal storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-04-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application uses most of the storage mechanisms available and stores files
    on internal storage in both the app_ and files directory. The app_ directory has
    several subdirectories and a cache_r.m file which is not of a known file format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-05-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The files directory stores many data files needed by the application to display
    and update Google Maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-06a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-06b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The files clearly indicate data that may be of interest to a forensic analyst
    or security engineer. A more thorough data analysis of applications and their
    data stored will be covered in [Chapter 7](CHP007.html), Android Application and
    Forensic Analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Files on External Storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While files stored on the internal device’s storage have strict security and
    location parameters, files on the various external storage devices have far fewer
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: First, one important motivation (beyond cost) for using a removable SD card
    is that the data could be used on other devices, presumably upgraded Android devices.
    If a consumer purchased a new Android device, inserted their previous SD card
    containing all of his or her family pictures and videos and found they were unable
    to access them, they would be quite upset.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate mounting the SD card on desktop computers to share files,
    SD cards are generally formatted with Microsoft’s FAT32 files system. While the
    file system is widely supported, it lacks the fine grained security mechanism
    built into file systems such as ext3, ext4, yaffs2, hfsplus, and more. Thus, by
    default, the files cannot enforce permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the com.google.android.apps.maps application referenced previously
    also stores data on the SD card in the Android/data subdirectory. The following
    is a listing of the files and directories from the reference HTC Incredible SD
    card, mounted at /mnt/sdcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-07-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the HTC Incredible ships with an emulated SD card that is stored
    directly on the NAND flash. The emulated SD card is mounted at /mnt/emmc. The
    following is a listing of a subdirectory that stores album JFIF thumbnail files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-08-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can tell, developers have great control over the name, format, and location
    of files on the external and emulated SD cards.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another NAND/SD card-based storage that developers leverage is a specific type
    of file—an SQLite database. Databases are used for structured data storage and
    SQLite is a popular database format appearing in many mobile systems as well as
    traditional operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is popular for many reasons. Notably the entire code base is of high
    quality, open source, and released to the public domain. The file format and the
    program itself are very compact and pack significant functionality in less than
    a few hundred kilobytes. Unlike more traditional relational database management
    systems (RDBMS), such as Oracle, MySQL, and Microsoft’s SQL Server, with SQLite
    the entire database is contained in a single cross-platform file.
  prefs: []
  type: TYPE_NORMAL
- en: The Android SDK provides dedicated APIs that allow developers to use SQLite
    databases in their applications. The SQLite files are generally stored on the
    internal storage under /data/data/<packageName>/databases. However, there are
    no restrictions on creating databases elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite databases are a rich source of forensic data. The built-in Android browser,
    based on the WebKit Open Source Project ([http://webkit.org/](http://webkit.org/)),
    provides a great example. In our referenced HTC Incredible, there were 28 SQLite
    databases located in subdirectories of /data/data/com.android.webkit. In this
    instance, the five subdirectories were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '• app_icons: 1 database of web page icons'
  prefs: []
  type: TYPE_NORMAL
- en: '• app_cache: 1 database containing web application data cache'
  prefs: []
  type: TYPE_NORMAL
- en: '• app_geolocation: 2 databases relating to GPS position and permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '• app_databases: 21 databases providing local database storage for supporting
    web sites'
  prefs: []
  type: TYPE_NORMAL
- en: '• databases: 3 databases for the browser and browser cache'
  prefs: []
  type: TYPE_NORMAL
- en: There is very high potential of recovering forensically valuable data from these
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final data storage mechanism available to developers is the network, a key
    benefit of a device designed to be network aware. Initially, very few applications
    took advantage of the network as a storage option. However, as the SDK, apps,
    and devices mature, the network storage option is being leveraged more.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Developer web site provides very few details for those interested
    in network storage. Their entire documentation is a mere two sentences long ([Data
    storage, n.d.](#BIB3)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the network (when it is available) to store and retrieve data on
    your own web-based services. To do network operations, use classes in the following
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: • java.net.^∗
  prefs: []
  type: TYPE_NORMAL
- en: • android.net.^∗
  prefs: []
  type: TYPE_NORMAL
- en: The packages referenced in the documentation essentially provide developers
    with the low-level APIs needed to interact with the network, web servers, and
    more. Apps that leverage the network require more custom coding and, while all
    of the forensically interesting data may not be stored on the device, often important
    configuration and database files are recoverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example (and as a sneak peak to [Chapter 7](CHP007.html), Android Application
    and Forensic Analysis), Dropbox is a popular file sharing web site which has mobile
    apps for Android, Blackberry, and iOS devices. Their current Android application
    (version 1.0.3.0) has been downloaded from the Android Market over 250,000 times
    and has over 35,000 user ratings, most quite high. After the app is installed,
    you can find the application folder at /data/data/com.dropbox.android with four
    standard directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-09-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The log.txt is a verbose log of activity and a few lines are provided for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-10-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some items of potential interest were emphasized in the above listing, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. All actions have time stamps
  prefs: []
  type: TYPE_NORMAL
- en: 2. Successfully authenticate user, user name provided
  prefs: []
  type: TYPE_NORMAL
- en: 3. Picture imported from Gallery
  prefs: []
  type: TYPE_NORMAL
- en: 4. Specific file on SD card is uploaded
  prefs: []
  type: TYPE_NORMAL
- en: 5. Dropbox service is interrupted by phone call
  prefs: []
  type: TYPE_NORMAL
- en: 'The app also has a shared preference file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-11-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick examination of the db.db yields the following data using the sqlite3
    command line program (you could also use a graphical SQLite browser to view the
    database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-12-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The database provides important forensic and security data about the Dropbox
    application, device, and ultimately the user and people they might interact with.
    The “Android intro.pdf” file was automatically synced to the Dropbox account by
    Dropbox when Android app was installed and logged into. When the shared PDF file
    was viewed, it was cached on the SD card. Additional metadata about the file and
    the use of it is contained in the database. Despite Dropbox’s extensive use of
    network data storage for their application, we could still recover useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel, System, and Application Logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One additional area where forensic analysts and security engineers can locate
    files and information relevant to an investigation or audit is the standard Linux
    file system. Unfortunately, that’s quite broad and overwhelming, but we can at
    least provide a starting place to look for relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: Log files and debugging are two common and effective ways in which developers
    and administrators both maintain their system and their apps. It provides an insight
    into the apps as well as the system running them. While not true in every case,
    it is possible to glean important information from an Android device by simply
    examining the various log and debug files.
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel logging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Linux kernel is the low level, abstract interface of the Linux operating
    system that provides access to the hardware of a device. Since the role of the
    kernel is central to all functions on the device, the ability to log key events
    and activities is highly leveraged. The kernel log is accessible on a Linux (and
    thus Android) device through the command dmesg. This will print to console all
    available kernel messages, a portion of which is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-13a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-13b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you may notice, the data are quite verbose and low level. However, it can
    provide important time stamps and activities, as well as a wealth of information
    about the device on boot-up. However, if the device has not been rebooted recently,
    the initial logs from startup are no longer available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command does not require any special permission on the device except that
    USB debugging must be enabled. If you ran this command on a device or emulator,
    you would have noticed that far too much data were displayed on your screen. You
    can determine the total number of lines available in the log by piping (or sending)
    the contents of dmesg to a program called wc (which stands for word count) and
    instructing it to count the number of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-14-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, on the reference HTC Incredible, we have 1859 lines in the kernel log.
    If you need to inspect the information more closely, or include it in a report,
    you can redirect the output of dmesg to a file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-15-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now examine the contents of the available kernel log by opening dmesg.log
    in a text editor or display program.
  prefs: []
  type: TYPE_NORMAL
- en: logcat
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Android has several additional debugging techniques available. One program,
    logcat, displays a continuously updated list of system and application debug messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-16a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-16b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A quick scan of the small log snippet above reveals
  prefs: []
  type: TYPE_NORMAL
- en: • Longitude and latitude data
  prefs: []
  type: TYPE_NORMAL
- en: • Date/time information
  prefs: []
  type: TYPE_NORMAL
- en: • Application details
  prefs: []
  type: TYPE_NORMAL
- en: The logging is very verbose and the sample provided here is just a small sample
    of what is available. Each log message begins with message type indicator, described
    in [Table 4.2](#T0015).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2 Log Method Types
  prefs: []
  type: TYPE_NORMAL
- en: '| Message Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| V | Verbose |'
  prefs: []
  type: TYPE_TB
- en: '| D | Debug |'
  prefs: []
  type: TYPE_TB
- en: '| I | Information |'
  prefs: []
  type: TYPE_TB
- en: '| W | Warning |'
  prefs: []
  type: TYPE_TB
- en: '| E | Error |'
  prefs: []
  type: TYPE_TB
- en: '| F | Fatal |'
  prefs: []
  type: TYPE_TB
- en: '| S | Silent |'
  prefs: []
  type: TYPE_TB
- en: 'The logcat program also provides logs from the full cellular radio debug, which
    can be viewed with the following command (only select portions of the radio logs
    included):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-17-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While the logging is verbose and generally cryptic, scanning the logs above
    can provide information such as:'
  prefs: []
  type: TYPE_NORMAL
- en: • Time of events (in Unix Epoch, e.g., t=1296218163)
  prefs: []
  type: TYPE_NORMAL
- en: • AT commands used by the cellular modem to communicate
  prefs: []
  type: TYPE_NORMAL
- en: • Recipient, size, time, and encoded SMS message
  prefs: []
  type: TYPE_NORMAL
- en: • Device’s cellular IP address, networking and location information
  prefs: []
  type: TYPE_NORMAL
- en: • Wireless carrier information
  prefs: []
  type: TYPE_NORMAL
- en: This information is of very low level. However, if such logs are recovered,
    they can reveal important information about a device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unix Epoch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unix Epoch time is a common format for time stamps in systems based on Unix/Linux.
    The time stamp is an integer value that represents the number of seconds (or milliseconds)
    since January 1, 1970\. A typical time stamp using seconds will have 10 digits
    while a time stamp using milliseconds will have 13 digits. Time stamps are covered
    in more details in [Chapter 7](CHP007.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'One final logcat feature is the event logs display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-18-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, this log is very verbose. However, as different events within the system
    occur, they log considerable information here. In the previous log snippet, we
    can see both an INSERT and SELECT statement on the mmssms.db, which is used to
    store text messages.
  prefs: []
  type: TYPE_NORMAL
- en: dumpsys
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next logging mechanism is accessed through a command called dumpsys.
  prefs: []
  type: TYPE_NORMAL
- en: Dumpsys provides information on services, memory, and other system details that
    can provide helpful information. Some of the types of information provided include
  prefs: []
  type: TYPE_NORMAL
- en: • Currently running services
  prefs: []
  type: TYPE_NORMAL
- en: • Dump of each service
  prefs: []
  type: TYPE_NORMAL
- en: • Services, broadcasts, pending intents, activities, and processes in current
    activity manager state
  prefs: []
  type: TYPE_NORMAL
- en: • Process information including memory, process IDs (PIDs), databases, and more
    used
  prefs: []
  type: TYPE_NORMAL
- en: Sample sections from the reference HTC Incredible dumpsys are listed next and
    each include a brief explanation of how the data might be valuable to a forensic
    analyst or security engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you run the dumpsys command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-19-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The section dumping details of the service “account” has valuable information
    about the various accounts used on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-20-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see not only programs used, but also at times the account name specific
    to the user. For example, the above reveals:'
  prefs: []
  type: TYPE_NORMAL
- en: • Google account with user name [book@viaforensics.com](mailto:book@viaforensics.com)
  prefs: []
  type: TYPE_NORMAL
- en: • Exchange ActiveSync (EAS) account with user name [book@viaforensics.com](mailto:book@viaforensics.com)
    (separate from the Google account above)
  prefs: []
  type: TYPE_NORMAL
- en: • Facebook account for Andrew Hoog
  prefs: []
  type: TYPE_NORMAL
- en: • Twitter account for viaforensics
  prefs: []
  type: TYPE_NORMAL
- en: • Google account for [personal@emailaddress.com](mailto:personal@emailaddress.com)
    (second one on the device)
  prefs: []
  type: TYPE_NORMAL
- en: 'Further in the log, the actual time stamps for the last 10 syncs are similarly
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-21-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another service is humorously named “iphonesubinfo,” which obviously has nothing
    to do with Apple’s iPhone despite the similarity in name.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-22-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both the phone type and Device ID (changed) are available from this section.
    The Device ID is not the device’s serial number but the Mobile Equipment Identifier
    (MEID), which uniquely identifies the device on the CDMA network.
  prefs: []
  type: TYPE_NORMAL
- en: Another great source of information is the location service that shows last
    known location information and time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-23-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most time stamps in Android are the number of milliseconds since January 1,
    1970, which is Unix Epoch time—in milliseconds instead of seconds, however. Since
    most tools convert Unix Epoch based on seconds, you can divide the number by 1000
    and then use a standard formula. If you built the Ubuntu workstation, you can
    convert using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-24-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will output in the workstation’s time zone. You can control the time zone,
    format, and many other parameters with various switches on the command. To see
    the full possibilities, run “date--help” or “man date.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the three cached locations above, we can see the system cached locations
    from both GPS satellites and cell towers at the following times:'
  prefs: []
  type: TYPE_NORMAL
- en: '1. GPS: Thu Jan 27 13:51:13 CST 2011'
  prefs: []
  type: TYPE_NORMAL
- en: '2. Cell: Fri Jan 28 09:56:48 CST 2011'
  prefs: []
  type: TYPE_NORMAL
- en: The locations are accurate for the time recorded and thus provide excellent
    historical information on the device’s location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The network state section provides additional information, including more detailed
    information on cell phone towers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-25a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-25b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One last section to point out, despite the level of technical details, is the
    memory information section, which is output for each PID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-26-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This may be useful not only for determining which processes are running, but
    also for determining the databases they access. For instance, a case may require
    the investigator to better understand what information is updated when an e-mail
    is received. In the above listing, you can see that the e-mail application (com.htc.android.mail)
    updates not only the mail.db, but also two web-related databases attached to the
    people_db. This information can be very useful when explaining how data on an
    Android device interrelates.
  prefs: []
  type: TYPE_NORMAL
- en: dumpstate
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another debug command is dumpstate that combines portions of previous debugs
    with system information. Similar to the other commands, you run the command with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-27-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first section displayed on an emulator or device with adbd running as root
    is stack traces from applications. However, on the reference HTC devices, dumpstate
    returns a permission denied. Immediately following is basic information about
    the device, build, radio, network and kernel details. The remaining log contains
    the sections outlined in [Table 4.3](#T0020).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3 Dumpstate Sections
  prefs: []
  type: TYPE_NORMAL
- en: '| Section | File or Command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Stack traces | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Device info | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| System | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Memory info | /proc/meminfo |'
  prefs: []
  type: TYPE_TB
- en: '| Cpu info | top -n 1 -d 1 -m 30 -t |'
  prefs: []
  type: TYPE_TB
- en: '| Procrank | (procrank) |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual memory stats | /proc/vmstat |'
  prefs: []
  type: TYPE_TB
- en: '| Vmalloc info | /proc/vmallocinfo |'
  prefs: []
  type: TYPE_TB
- en: '| Slab info | /proc/slabinfo |'
  prefs: []
  type: TYPE_TB
- en: '| Zoneinfo | /proc/zoneinfo |'
  prefs: []
  type: TYPE_TB
- en: '| System log | logcat -v time -d ^∗:v |'
  prefs: []
  type: TYPE_TB
- en: '| Event log | logcat -b events -v time -d ^∗:v |'
  prefs: []
  type: TYPE_TB
- en: '| Radio log | logcat -b radio -v time -d ^∗:v |'
  prefs: []
  type: TYPE_TB
- en: '| Network interfaces | netcfg |'
  prefs: []
  type: TYPE_TB
- en: '| Network routes | /proc/net/route |'
  prefs: []
  type: TYPE_TB
- en: '| Arp cache | /proc/net/arp |'
  prefs: []
  type: TYPE_TB
- en: '| Dump Wi-Fi firmware log | su root dhdutil -i eth0 upload /data/local/tmp/wlan_crash.dump
    |'
  prefs: []
  type: TYPE_TB
- en: '| System properties | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel log | dmesg |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel wakelocks | /proc/wakelocks |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel cpufreq | /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state
    |'
  prefs: []
  type: TYPE_TB
- en: '| Vold dump | vdc dump |'
  prefs: []
  type: TYPE_TB
- en: '| Secure containers | vdc asec list |'
  prefs: []
  type: TYPE_TB
- en: '| Processes | ps -p |'
  prefs: []
  type: TYPE_TB
- en: '| Processes and threads | ps -t -p -p |'
  prefs: []
  type: TYPE_TB
- en: '| Librank | librank |'
  prefs: []
  type: TYPE_TB
- en: '| Binder failed transaction log | /proc/binder/failed_transaction_log |'
  prefs: []
  type: TYPE_TB
- en: '| Binder transaction log | /proc/binder/transaction_log |'
  prefs: []
  type: TYPE_TB
- en: '| Binder transactions | /proc/binder/transactions |'
  prefs: []
  type: TYPE_TB
- en: '| Binder stats | /proc/binder/stats |'
  prefs: []
  type: TYPE_TB
- en: '| Binder process state | sh -c cat /proc/binder/proc/^∗ -p |'
  prefs: []
  type: TYPE_TB
- en: '| File systems and free space | df |'
  prefs: []
  type: TYPE_TB
- en: '| Package settings | /data/system/packages.xml: 2011-01-26 09:18:02 |'
  prefs: []
  type: TYPE_TB
- en: '| Package uid errors | /data/system/uiderrors.txt: 2010-11-14 22:52:26 |'
  prefs: []
  type: TYPE_TB
- en: '| Last kmsg | /proc/last_kmsg |'
  prefs: []
  type: TYPE_TB
- en: '| Last radio log | parse_radio_log /proc/last_radio_log |'
  prefs: []
  type: TYPE_TB
- en: '| Last panic console | /data/dontpanic/apanic_console |'
  prefs: []
  type: TYPE_TB
- en: '| Last panic threads | /data/dontpanic/apanic_threads |'
  prefs: []
  type: TYPE_TB
- en: '| Blocked process wait channels | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Backlights | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Dumpsys | dumpsys |'
  prefs: []
  type: TYPE_TB
- en: bugreport
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The final debugging command further builds on the previous commands and combines
    the logcat, dumpsys, and dumpstate debug output in a single command, and displays
    on screen for the purpose of submitting a bug report. The command is run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-28-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It starts by running dumpstate. When run against the reference HTC Incredible,
    the output was saved into a file and then a line count was performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-29-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the report generated over 42,000 lines of debug rich in time
    stamps, app data, and system information. Parsing this data will yield useful
    information. However, if the data are processed manually, the task is daunting.
  prefs: []
  type: TYPE_NORMAL
- en: Type of memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](CHP002.html), Android devices have two primary types
    of memory, volatile (RAM) and nonvolatile (NAND flash) memory. Each provides a
    different insight into the device’s data.
  prefs: []
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RAM is used by the system to load, execute, and manipulate key parts of the
    operating system, applications, or data, and is not saved on reboot. Like traditional
    computers, RAM can contain very important information which applications use to
    process data. Some examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Passwords
  prefs: []
  type: TYPE_NORMAL
- en: • Encryption keys
  prefs: []
  type: TYPE_NORMAL
- en: • Usernames
  prefs: []
  type: TYPE_NORMAL
- en: • App data
  prefs: []
  type: TYPE_NORMAL
- en: • Data from system processes and services
  prefs: []
  type: TYPE_NORMAL
- en: Recently, solutions for examining Android memory have emerged. One technique
    was documented by security researcher Thomas Cannon on his blog, which we will
    step through in detail ([Android reverse engineering, n.d.](#BIB2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Android provides a mechanism for dumping an application’s memory to a file
    by sending the app a special signal (SIGUSR1). To send the signal, you need an
    app’s PID, which you can find with the ps command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-30-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ps command lists all system and app processes as well as the parent process
    id, memory information, and the name. Since a typical device has many running
    processes, the above listing only displays a portion of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to run an interactive shell on the device with root privileges
    and set /data/misc with sufficient permissions to write and then read the memory
    dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-31-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Changing folder permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chmod command changes the permissions of the /data/misc folder granting
    read, write, and execute access to all user accounts on the system. This change
    is necessary for the successful memory dump. However, this is a system change
    overtly made by the forensic analyst. If such analysis is warranted, the change
    should be noted in your report and ideally the folder permissions should be restored
    to their default setting after the memory dump.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can send the signal needed to dump memory and display the contents
    of the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-32-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The file heap-dump-tm1296350817-pid1294.hprof contains the memory dump and
    we can exit the interactive adb shell and pull the file to your local workstation
    for analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-33-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, use any memory analysis technique you have at your disposal. For
    example, you could extract ASCII strings with the command strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-34-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and then view the contents of the file. A quick scan of Gmail’s memory provided
    information about various encryption libraries the app referenced as well as HTTP
    traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-35-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Facebook app, which uses a file format called JSON to encode and transfer
    data, yielded the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-36-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These examples were sanitized prior to inclusion in this book. However, you
    can see time stamps, profile updates, friend info, check-ins, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Memory analysis of an Android device can provide deep insight into the device’s
    internal structure as well as key information about the device owner. Over time,
    expect more solutions in the market to address analysis of Android memory.
  prefs: []
  type: TYPE_NORMAL
- en: NAND Flash
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike RAM, NAND flash is nonvolatile and thus the data are preserved even when
    the device is without power or rebooted. The NAND flash is used to store not only
    system files but also significant portions of the user’s data.
  prefs: []
  type: TYPE_NORMAL
- en: NAND flash memory has characteristics very different from the magnetic media
    found in modern hard drives. These properties make NAND flash ideal storage for
    mobile devices, while at the same time presenting a number of challenges for programmers
    and opportunities for forensic analysts.
  prefs: []
  type: TYPE_NORMAL
- en: First, NAND flash has no mechanically moving parts like the spinning platters
    and arms found in traditional magnetic hard drives. This improves the durability
    and reduces both the size and power consumption of the device. The memory is distributed
    as one or multiple chips, which often integrate both NAND flash and RAM (MCP,
    see [Chapter 2](CHP002.html)) and are directly integrated into the circuit board
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: NAND flash also has very high density and is cost effective to manufacture.
    This, of course, makes it very popular with manufacturers. One side effect of
    the manufacturing process and technology in general is that NAND flash literally
    ships with bad blocks directly from the manufacturer. The manufacturer will generally
    test the memory as part of the manufacturing process and mark bad blocks in a
    specific structure on the NAND flash, which is described in their documentation.
    Software, which then directly interacts with the NAND flash, can read the manufacturer’s
    bad block markers and will often implement a bad block table that can logically
    track the bad blocks on the system and remove them from operation. This greatly
    speeds up bad block detection and management. So while NAND flash is more physically
    durable than spinning platters, its error rate is much higher and must be accounted
    for in development and use.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant limitation of NAND flash is that it has a very limited write/erase
    life span before the block is no longer capable of storing data. The life span
    varies by device and is largely impacted by the amount of data stored per NAND
    flash cell, the central building block for storing the 1 or 0 bit(s). If the cell
    only stores a single bit (single-level cell or SLC) then the NAND flash is rated
    around 100k write/erase cycles for one-year data retention. However, NAND flash
    rarely uses SLC as manufacturers (and consumer) demand more data storage in similarly
    sized or smaller devices. The technology has moved to multilevel cells (MLC) where
    a cell can store two, three, or even more bits per cell. However, this not only
    complicates the manufacturing process and slows down the write/erase cycle, but
    it also significantly reduces the endurance of the device. A typical MLC NAND
    flash storing two bits per cell experiences a 10-fold reduction in endurance (measured
    as one-year data retention) with a value of approximately 10k write/erase cycles.
    As the bit density per cell increases, the endurance continues to drop, which
    obviously must be addressed by the controlling device.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike RAM and NOR flash which is also flash memory and typically used in systems
    such as a computer’s Basic Input Output System or BIOS, NAND flash cannot be accessed
    randomly. Instead, access to data is achieved via an allocation unit, called a
    page or chunk, which is typically between 512 and 2048 bytes, but generally increases
    as the overall size of NAND flash increases. Even though NAND flash does not provide
    the fast random access like RAM, access time is still quite fast because it does
    not require the mechanical platter and arm movements used in traditional spinning
    hard drives.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Page versus chunk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, we will use the word page and chunk synonymously to refer
    to the low-level data allocation unit referenced in NAND flash. While the allocation
    unit is usually referred to as a page, the YAFFS2 file system, which is a key
    component of Android, generally refers to the allocation unit as a chunk.
  prefs: []
  type: TYPE_NORMAL
- en: The chunks are then organized into a larger logical unit called a block, which
    is typically much larger than a traditional 512B hard drive sector. In most Android
    devices, the NAND flash blocks contain 64 chunks of data and each chunk is 2048
    bytes. Taking 64 × 2 KB yields a block size of 128 KB. Of course, this can and
    will change over time and is controlled by the NAND flash manufacturers. When
    a block is allocated for writing, the chunks inside the block are written sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very important characteristic of NAND flash is the operations available
    for reading and writing:'
  prefs: []
  type: TYPE_NORMAL
- en: • Read (page)
  prefs: []
  type: TYPE_NORMAL
- en: • Write (page)
  prefs: []
  type: TYPE_NORMAL
- en: • Erase (block)
  prefs: []
  type: TYPE_NORMAL
- en: While individual chunks can be read or written, the erase operation only functions
    at the block level. When a block is erased, the entire block is written over with
    1’s or 0xFF (hex).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: NAND flash erase operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The erase operation is the only mechanism by which a 0 can be changed to a
    1 in NAND flash.* This point is worth belaboring. In a traditional hard drive,
    if a value is changed from a 0 to a 1 (or vice versa), the program would simply
    seek to the value on the hard drive and apply the appropriate voltage to change
    and store the new value. However, the fundamental architecture of NAND flash provides
    only one mechanism to change a 0 to a 1 and that is via the erase function that
    is applied at the block level, not an individual page level. For this reason,
    a page can only be written once, and if the value of the page needs to change,
    the entire block must be erased and then the page can be written.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a specific example using a single byte for simplicity: Let’s say this
    particular byte holds the decimal value 179 and we want to add 39 for a total
    value of 218\. For those unfamiliar with converting numbers between base10, hex
    (base16), and binary (base2), the built-in calculator programs in Windows, Mac
    OS X, and Ubuntu Linux provide a programmer mode that will perform the conversions.
    For the numbers above, we have the conversions between numbering systems shown
    in [Table 4.4](#T0025).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.4 Decimal, Hex, and Binary Representation of Integers
  prefs: []
  type: TYPE_NORMAL
- en: '| Decimal (base10) | Hex (base16) | Binary (base2) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 179 | 0xB3 | 1011 0011 |'
  prefs: []
  type: TYPE_TB
- en: '| 218 | 0xDA | 1101 1010 |'
  prefs: []
  type: TYPE_TB
- en: 'So the value 179 contains three 0’s and two of them need to change to a 1 to
    present our new value of 218\. However, NAND flash cannot make that change without
    erasing the entire block. So, if this single byte was attempted without the erase,
    the result would be 146, not 218\. Here is how this happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-37-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the byte did not contain all 1’s (0xFF), the only portions of the write cycle
    that succeeded were 1’s either remaining a 1 or changing to a 0\. Anytime the
    write function encountered a 0 and was requested to change to a 1, it would fail
    and simply retain the 0 value. The resulting byte was 0x92 or 146 base10—clearly
    not the value intended. Another way to describe the write function is that it
    only changes the charged 1 values to a 0 where requested, the equivalent of the
    “logical and” of the two values.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a chunk can only be written once, and if it needs to be re-written,
    the entire block must first be erased.
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell, NAND flash imposes various restrictions and limitations and
    thus developers and file systems must be flash aware to effectively work within
    the constraints. Unlike traditional hard drives that ship with firmware to manage
    the device (including bad block), the NAND flash used in Android devices does
    not ship with a controller. All management of the memory must be implemented in
    software interfacing with the NAND flash. Two important techniques deployed are
    error-correcting code (ECC) and wear-leveling. Both have significant implications
    for forensics and data recovery.
  prefs: []
  type: TYPE_NORMAL
- en: First, ECC is a technique where an algorithm is used to detect data errors on
    read or write operations and correct some errors on the fly. Since NAND flash
    degrades over time through usage, the system must be able to detect when a page
    or block is going bad and recover the data stored there. After a number of errors
    or failed operations is exceeded (typically three failed operations), the page
    or block will be marked bad and added to the bad block table.
  prefs: []
  type: TYPE_NORMAL
- en: The second important algorithm used to effectively manage NAND flash on Android
    is the wear-leveling code that spreads the writing of data across the entire NAND
    flash to avoid overutilization of a single area, thus wearing those blocks out
    more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Many hardware devices that use NAND flash, such as removable USB thumb drivers
    and solid state drives (SSD), have controller logic bundled with the device, which
    provides the functions described above including bad block management, wear-leveling,
    and error-correcting code. However, Android devices were designed to integrate
    the NAND flash components directly, and thus a software management layer was needed
    to provide these important functions. The layer selected to manage the NAND flash
    was the Memory Technology Device (MTD) system.
  prefs: []
  type: TYPE_NORMAL
- en: MTD was developed to address the need of NAND flash and similar devices due
    to their unique characteristics. Prior to MTD, Linux supported primarily character
    devices and block devices. Neither device type addresses the unique properties
    of the newly developed memory devices. Additionally, while NAND flash was not
    strictly a block device (like traditional hard drives), exposure of block device
    characteristics to developers aided in development and support. By leveraging
    MTD, Android now had the necessary Flash Transition Layer (FTL) needed to effectively
    interact with the NAND flash. By taking this approach, Android did not lock manufacturers
    into using a small subset of NAND flash providers and associated controllers.
    Instead, they are free to use any NAND flash available and then “simply” integrate
    with MTD, which supports a wide range of NAND flash.
  prefs: []
  type: TYPE_NORMAL
- en: In Android, the MTD provides not only the block interface to the NAND flash
    but also the ECC, wear-leveling, and other critical functions. The ECC and other
    chunk metadata are stored in a reserved area called the out of band (OOB) or spare
    area. The OOB is located directly after each chunk on the NAND flash. While the
    chunk, block, and OOB layout is configurable, most Android devices to date have
    a 128 KB block consisting of 64 2,048 byte (2k) chunks each with a 64 byte OOB
    as shown in [Fig. 4.1](#F0010).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044f04-01-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FIGURE 4.1 Block (128 KB = 64 × 2k chunks + OOB).
  prefs: []
  type: TYPE_NORMAL
- en: The OOB not only stores information managed by MTD, but can also store metadata
    critical to the file system, provided the file system is NAND flash aware. While
    the system presents the block as 128 KB, when you add in the 64 OOB, each 64 bytes
    in size, there is an additional 4096 bytes (4 KB) bringing the total bytes used
    on the NAND flash to 132 KB.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Android devices, you can determine the MTD partitions by viewing the /proc/mtd
    file. On our reference HTC Incredible, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-38-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are seven MTD partitions and the following section will examine where
    they are mounted, and provide a high-level overview of the directories and files
    found. In the previous listing, the size and erasesize are both hex values that
    provide important MTD/NAND flash properties. The erasesize specifies the size
    of each block which is 0x20000 or 131,072 bytes or 128 KB (128 × 1024) in decimal.
    This is consistent with the block figure, specifically 64 pages, each 2048 (2 KB)
    in size. The size column specifies the overall size of that partition. So, in
    this instance, we have the MTD partitions as shown in [Table 4.5](#T0030).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.5 MTD Partitions Size Conversions
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The values from [Table 4.5](#T0030) can also be verified using the df (disk
    free) command that provides a listing of mounted file systems and their total,
    used, and available space. Following is the df data for /system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-39-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can tell, the size found in /proc/mtd is consistent in both our conversions
    and as displayed by the df command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established a fundamental understanding of NAND flash and MTD
    for Android, we will examine the various file systems used by Android.
  prefs: []
  type: TYPE_NORMAL
- en: File systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most Linux systems, there are several file systems in use on Android, many
    of which are used to boot and run the system. While we will touch on several of
    the file systems, the primary focus is on partitions where user data are stored,
    in particular the EXT, FAT32, and YAFFS2 file systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine what file systems a Linux kernel (and thus Android) supports,
    you can examine the contents of the file /proc/filesytem. On our reference HTC
    Incredible, it contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-40-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of the 18 file systems supported by the HTC Incredible, only five are backed
    by a physical device such as NAND flash or the SD card. The remaining file systems
    have the “nodev” property, which means that they are essentially virtual file
    systems that are not written to any physical device. Furthermore, only six of
    the nodev file systems are actually used on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. rootfs
  prefs: []
  type: TYPE_NORMAL
- en: 2. tmpfs
  prefs: []
  type: TYPE_NORMAL
- en: 3. cgroup
  prefs: []
  type: TYPE_NORMAL
- en: 4. proc
  prefs: []
  type: TYPE_NORMAL
- en: 5. sysfs
  prefs: []
  type: TYPE_NORMAL
- en: 6. devpts
  prefs: []
  type: TYPE_NORMAL
- en: 'And three of the device-backed file systems are used:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. ext3
  prefs: []
  type: TYPE_NORMAL
- en: 2. yaffs2
  prefs: []
  type: TYPE_NORMAL
- en: 3. vfat
  prefs: []
  type: TYPE_NORMAL
- en: The following sections provide a brief overview of most file systems, and an
    in-depth analysis of YAFFS2, where significant user data are stored.
  prefs: []
  type: TYPE_NORMAL
- en: rootfs, devpts, sysfs, and cgroup File Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many file systems in Linux are used to boot, operate, or manage the system and
    often will not contain information useful in a forensic investigation. However,
    security engineers and researchers may closely examine these file systems, and
    the kernel’s inner-workings, in an attempt to identify security holes and other
    weaknesses. We will quickly highlight four of the more infrastructure-related
    file systems found in Android.
  prefs: []
  type: TYPE_NORMAL
- en: First, rootfs is where the kernel mounts the root file system (the top of the
    directory tree, noted with a forward slash) at startup. In order for the kernel
    to complete the boot process, it needs access to core files and libraries, thus
    the need to mount the root file system. As the kernel finalizes the boot process,
    subsequent file systems are mounted as directories off the root file system. For
    example (and more on this later in the chapter), the root file system would be
    mounted at / and contain key files. Then a more complete system directory would
    be mounted at /system. You can see the root file system and directories by running
    the “ls -l” command from a shell or typing “mount” to see which file systems are
    mounted and in what directory of the root file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The devpts file system is used to provide simulated terminal sessions on an
    Android device, similar to connecting to a traditional Unix server using telnet
    or ssh. Each time a virtual terminal connects, a new node under /dev/pts is created.
    For example, if you have a single adb shell connection to an Android device, /dev/pts
    would show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-41-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, in the next example, there are two adb shell connections and one terminal
    app connection from an app installed on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-42-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the original /dev/pts/0 connection exists. However, two additional
    connections are now present and the one from the terminal app is run under the
    app’s unique user id (app_105).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sysfs is another virtual file system that contains configuration and control
    files for the device. On the HTC Incredible, the following top-level directories
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-43-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For curiosity’s sake, you can do an adb pull on /sys to your forensic workstation
    as the files can be read by any user. Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-44-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a large number of files were pulled, and you can now use the
    full suite of Linux tools to examine the data. While the forensic value of this
    information requires additional research, it clearly provides low-level information
    about the device that can assist in security research. For example, if you wanted
    to learn more about the NAND device, you could examine the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-45-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-46-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Understanding the NAND device in detail is clearly an important step in forensic
    and security analysis. With nearly 3000 files, there is considerable data to examine.
    Here is a quick way to look at the file names, paths, and sizes that will allow
    you to then easily examine relevant files (try running two terminal sessions and
    listing the files in one terminal and use copy/paste to “cat” the file contents
    in the other terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-47a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-47b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Additional sysfs analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond manually examining the sysfs file system, there are detailed resources
    on the Internet which provide additional background. One such resource is a paper
    by Patrick Mochel providing a helpful background ([The sysfs filesystem, n.d.](#BIB7)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final virtual file system is called cgroups and is used to track and aggregate
    tasks in the Linux file system. On the HTC Incredible, two cgroup file systems
    are created: one at /dev/cpuctl and the other at /acct. While additional analysis
    may yield results, the accounting data generally do not prove useful in forensic
    analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: proc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The proc file system provides detailed information about kernel, processes,
    and configuration parameters in a structured manner under the /proc directory.
    Some of the files can be examined by the shell user. However, many files prevent
    access unless you have root privileges. As before, one method for exploring the
    proc file system is to pull the files from the Android device onto your forensic
    workstation. It will take some time and could hang on certain files causing an
    incomplete copy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-48-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the HTC Incredible, the above process hung when trying to copy process 76
    and had to be canceled with a Ctrl-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-49-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before canceling, we successfully pulled 25 MB of data and nearly 6000 files.
    As with the sysfs examination, you can manually examine the data using the find
    command to locate and list files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-50-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can examine some files in /proc directly from the adb shell
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-51-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Valuable information about the device can be found in the proc file system.
    Examiners can audit these files and should start with files in the /proc directory
    instead of the subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: tmpfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: tmpfs is a file system that stores all files in virtual memory backed by RAM
    and, if present, the swap or cache file for the device. Most Android devices at
    this time do not have swap space. However, some aftermarket firmware enables this
    feature. The advantage of tmpfs is that by using RAM, the storage is very fast
    and also nonpermanent and hence not saved on reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for forensic examiners, this poses a challenge. If important data
    are located on a tmpfs mount point, it must be collected before the device is
    rebooted or loses power. It also presents a unique opportunity because the tmpfs
    is often readable by the shell user and forensic programs can be copied and executed
    in tmpfs without modifying the NAND flash or SD card. This may allow an examiner
    to acquire forensic data from an Android device without modifying the NAND flash
    or SD card in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Investigating tmpfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your primary interest is in memory analysis of the device, making changes
    to tmpfs is not advised unless you first have a forensic copy of the parts of
    memory you are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the HTC Incredible, the standard installation has four tmpfs mount points:'
  prefs: []
  type: TYPE_NORMAL
- en: • /dev
  prefs: []
  type: TYPE_NORMAL
- en: • /mnt/asec
  prefs: []
  type: TYPE_NORMAL
- en: • /app-cache
  prefs: []
  type: TYPE_NORMAL
- en: • /mnt/sdcard/.android_secure
  prefs: []
  type: TYPE_NORMAL
- en: The /dev directory contains device files that allow the kernel to read and write
    to attached devices such as NAND flash, SD card, character devices, and more.
    The /mnt/asec and /mnt/sdcard/.android_secure directories are a relatively new
    addition to Android and allow apps to be stored on the SD card instead of /data/data,
    which provides more storage.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the /app-cache is also a new addition and appears to provide
    tmpfs space, which apps can use. On the HTC Incredible, the Web Browser (com.andrew.browser)
    created a directory in /app-cache and stores cache files from web browsing.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-52-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the first listing, we can see that the app-cache directory has read, write,
    and browse permissions set for all users. In addition, the final “t” in the permissions
    “rwxrwxrwt” indicates that only root or the owner of the directory can delete
    or rename the directory.
  prefs: []
  type: TYPE_NORMAL
- en: The second listing shows the directory’s inside app-cache, which only has com.android.browser.
    However, as we dig deeper into the directory, we discover the directory and files
    we are most interested in only allow the app itself (com.android.browser, user
    id of app_12) or root access to the files.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-53-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have root access on the device, here is what the directory contained:'
  prefs: []
  type: TYPE_NORMAL
- en: • 1.4 MB of data
  prefs: []
  type: TYPE_NORMAL
- en: • 64 files
  prefs: []
  type: TYPE_NORMAL
- en: • 18 ASCII files (mostly CSS and JavaScript)
  prefs: []
  type: TYPE_NORMAL
- en: • 1 empty file
  prefs: []
  type: TYPE_NORMAL
- en: • 9 GIF files
  prefs: []
  type: TYPE_NORMAL
- en: • 5 HTML files
  prefs: []
  type: TYPE_NORMAL
- en: • 11 JPEG files
  prefs: []
  type: TYPE_NORMAL
- en: • 17 PNG files
  prefs: []
  type: TYPE_NORMAL
- en: • 3 UTF-8 files
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-54-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you browse the webviewCache directory from your Ubuntu workstation, you can
    easily preview images and other files ([Fig. 4.2](#F0015)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044f04-02-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FIGURE 4.2 Browser webviewCache from Ubuntu workstation.
  prefs: []
  type: TYPE_NORMAL
- en: The /app-cache tmpfs directory contains information that would be important
    in a forensic investigation. This underscores the growing need to educate front-line
    responders to ensure that devices are properly handled to maximize the forensic
    investigation’s effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Extended File System (EXT)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The extended file system (EXT) is the de facto file system for Linux developed
    specifically for the operating system. As you already know, Linux supports a large
    number of file systems. However, the default is EXT. Since the original version
    of EXT was developed in 1992, there have been three additional releases: EXT2,
    EXT3, and EXT4.'
  prefs: []
  type: TYPE_NORMAL
- en: Although EXT has been integral to most laptop, desktop, and server Linux distributions,
    it was not found in early Android devices. In 2010, however, EXT began to show
    up in devices, and on December 9, 2010, Google announced in their Android Developer
    blog that an increasing number of Android devices were going to move from YAFFS
    to the EXT ([Android developers blog, n.d.](#BIB1)). The move from YAFFS to EXT
    seems to be driven by several factors that were discussed online ([Way, n.d.](#BIB8)),
    including
  prefs: []
  type: TYPE_NORMAL
- en: • More Android devices are moving from raw NAND flash to regular block device
    (eMMC)
  prefs: []
  type: TYPE_NORMAL
- en: • EXT4 is a standard Linux file system that supports full Unix permissions and
    semantics
  prefs: []
  type: TYPE_NORMAL
- en: • EXT4 is stable and offers high performance
  prefs: []
  type: TYPE_NORMAL
- en: • YAFFS is single threaded, which would experience bottlenecks on forthcoming
    dual-core systems
  prefs: []
  type: TYPE_NORMAL
- en: 'The first Android device to use EXT4 is the Google Nexus S, and it is expected
    that many tablet devices running Android’s Honeycomb release will also use this
    new file system. As only one Android device currently uses EXT4, many changes
    are expected over time. Currently, the Nexus uses EXT4 in the following mount
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: • System image (read-only, /system)
  prefs: []
  type: TYPE_NORMAL
- en: • Local user data (read–write, /data/data)
  prefs: []
  type: TYPE_NORMAL
- en: • Cache partitions (read–write, /cache and possible others)
  prefs: []
  type: TYPE_NORMAL
- en: From a forensics standpoint, EXT4 is simply another file system that examiners
    need to understand and forensic tools need to support. Of course, most forensic
    tools do not fully (or even nominally) support EXT4 so this presents a bit of
    a problem. File carving techniques do work and it is expected that more forensic
    software will begin to support the file system over time.
  prefs: []
  type: TYPE_NORMAL
- en: FAT32/VFAT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android devices often have one or more Microsoft FAT32 partitions, generally
    on the SD card and eMMC. The reason for leveraging this venerable file system
    is not due to superior design but is due to sheer compatibility with other operating
    systems. Microsoft’s FAT32 file system was widely supported in most operating
    systems including Mac OS X, all Windows versions (obviously), Linux, and more.
    This means that Android data stored on the FAT32 partitions can be easily read,
    modified, or even deleted on other file systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, the file system driver for a FAT32 partition is called VFAT, not
    to be confused with Microsoft’s earlier Virtual FAT file system that bridged the
    FAT16 and FAT32 implementation by adding, among other features, long file name
    support. On the HTC Incredible, there are three mount points that use FAT32:'
  prefs: []
  type: TYPE_NORMAL
- en: • /mnt/sdcard
  prefs: []
  type: TYPE_NORMAL
- en: • /mnt/secure/asec
  prefs: []
  type: TYPE_NORMAL
- en: • /mnt/emmc
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [Chapter 3](CHP003.html)’s section on USB interfaces,
    when an Android device is connected to another computer, there is an option to
    expose the devices’ USB mass storage (UMS) interfaces to enable file sharing.
    On the HTC Incredible, both the /mnt/sdcard and /mnt/emmc partitions can be presented
    to other operating systems over the USB connection as a UMS device.
  prefs: []
  type: TYPE_NORMAL
- en: The /mnt/secure/asec partition is an encrypted partition on the SD card where
    Android devices can store apps. When the ability to run apps from the SD card
    was introduced, the security engineers were understandably concerned that app
    data could easily be damaged or compromised because file permissions are not maintained
    in the VFAT/FAT32 partitions. As such, the app (.apk file) is encrypted on the
    physical device and when in use, it is decrypted and temporarily stored at /mnt/asec
    or another location specified by design.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed previously, the removable SD card is mounted at /mnt/sdcard and
    generally contains photos, videos, thumbnails, downloaded files, text to speech
    temporary files, and Google Maps Navigation data as well as data from many Android
    Market applications. The newer /mnt/emmc is a FAT32 partition, not removable,
    and resides in storage architected into the device. In the devices examined thus
    far, the eMMC is formatted as FAT32, again for interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: YAFFS2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the first Android device was released, many people were surprised to see
    a relatively unknown file system play a key role in the system. YAFFS, which is
    an acronym for Yet Another Flash File System, is an open-source file system developed
    specifically for NAND flash and is licensed under both the GNU Public License
    (GPL) and a commercial license agreement for those who do not wish to follow the
    strict GPL guidelines ([YAFFS licence FAQs, n.d.](#BIB9)). Android devices use
    the latest release of YAFFS (YAFFS2) that follows more strict NAND flash guidelines
    meant to improve the endurance of the NAND flash while optimized to run on low-memory
    mobile or embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'YAFFS2 was developed by Aleph One Ltd, a company based in New Zealand. Driven
    by customer requests, Aleph One began YAFFS design in December 2001 and released
    the first publicly available source code in May 2002\. The primary developer (or
    certainly the most visible) is Charles Manning who is described as “The Embedded
    Janitor” and has been developing and “mopping up” embedded systems for 20 years
    ([YAFFS: the NAND-specific flash, n.d.](#BIB10)). Charles is quite active on the
    YAFFS mailing list and is the de facto expert on YAFFS and YAFFS2.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Additional YAFFS2 resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analysts and engineers interested in the internals of YAFFS2 are encouraged
    to read the full documentation (and source code, if that’s your thing) from [http://www.yaffs.net/](http://www.yaffs.net/)
    and sign up for the mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: YAFFS2 was built specifically for the growing NAND flash devices and has a number
    of important features that address the stringent needs of this medium. YAFFS2
    is
  prefs: []
  type: TYPE_NORMAL
- en: • a log-structured file system (which protects data even through unexpected
    power outages)
  prefs: []
  type: TYPE_NORMAL
- en: • provides built in wear-leveling and error correction
  prefs: []
  type: TYPE_NORMAL
- en: • capable of handling bad blocks
  prefs: []
  type: TYPE_NORMAL
- en: • fast and has a small footprint in RAM
  prefs: []
  type: TYPE_NORMAL
- en: However, since its usage was limited prior to Android, there are currently no
    forensic tools (commercial or open source) that support the file system. This
    leaves the forensic analysts with few options except to download the YAFFS2 source
    code, grab a forensic image of a partition, open it up in your favorite hex editor,
    and start digging. Although some utilities should develop over time, Android’s
    move to EXT4 may reduce the motivation for commercial forensic companies to develop
    such support.
  prefs: []
  type: TYPE_NORMAL
- en: As covered in the NAND flash section, YAFFS2 addressed the memory in blocks
    through the MTD subsystem and each block contains a set number of pages (called
    chunks in YAFFS documentation and code). When YAFFS2 is ready to write data to
    the NAND flash, it passes both the data and metadata structures to the MTD. The
    MTD is then responsible for writing (as well as reading) both the data and the
    metadata to the NAND flash.
  prefs: []
  type: TYPE_NORMAL
- en: For most Android devices, the MTD subsystem addressed NAND flash in blocks that
    are divided into 64 chunks with each chunk containing 2048 bytes (so blocks are
    128K) plus a 64-byte out-of-band/spare area (OOB) where various tags and metadata
    are stored. When a block is allocated for writing, it is assigned a sequence number
    that starts at 1 and increments with each new block.
  prefs: []
  type: TYPE_NORMAL
- en: All data structures stored in YAFFS2 are referred to as Objects and can be files,
    directories, symbolic links, and hard links. Each chunk either stores a yaffs_ObjectHeader
    (object metadata) or data for the object. The yaffs_ObjectHeader tracks various
    information including the Object type, the parent object, a checksum of the name
    to speed up searching, the object name, permissions and ownership, MAC information,
    and the size of the object if it is a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 64-byte OOB/spare area, YAFFS2 not only stores critical information
    about the chunk but also shares the area with the MTD subsystem. The critical
    YAFFS2 tags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '• 1 byte: block state (0xFF if block is good, any other value for a bad block)'
  prefs: []
  type: TYPE_NORMAL
- en: '• 4 bytes: 32-bit chunk ID (0 indicates that chunk is storing a yaffs_ObjectHeader,
    else data)'
  prefs: []
  type: TYPE_NORMAL
- en: '• 4 bytes: 32-bit Object ID (similar to traditional Unix inode)'
  prefs: []
  type: TYPE_NORMAL
- en: '• 2 bytes: number of data blocks in this chunk (all but final chunk will be
    fully allocated)'
  prefs: []
  type: TYPE_NORMAL
- en: '• 4 bytes: sequence number for this block'
  prefs: []
  type: TYPE_NORMAL
- en: '• 3 bytes: ECC for tags (in Android, handled by MTD)'
  prefs: []
  type: TYPE_NORMAL
- en: '• 12 bytes: ECC for data (in Android, handled by MTD)'
  prefs: []
  type: TYPE_NORMAL
- en: If an object is changed, a new yaffs_ObjectHeader is written to flash because
    NAND memory can only be written once before erasing. The old data and headers
    still exist but are ignored in the file structure by examining the values of the
    sequence number. Using this process complies with the guideline that blocks in
    NAND flash can never be re-written (only written once and then erased when no
    longer needed). This, of course, can be of enormous benefit to the data-recovery
    process as modified or deleted data will still exist on the NAND flash unless
    the block went through the garbage collection process used to erase a block and
    prepare it to accept new data.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when a file is deleted in YAFFS2, the parent directory for the ObjectHeader
    is moved to a special, hidden directory called unlinked. The file remains in this
    directory until all of the chunks in the file are erased. To achieve this, the
    file system tracks the number of chunks in the system for the file. When it reaches
    0, the remnants of the file no longer exist. At that point, it will no longer
    track the object in the unlinked directory.
  prefs: []
  type: TYPE_NORMAL
- en: While the file system structure can be regenerated completely from the OOB area
    and ObjectHeader information, this is not efficient—especially as the size of
    NAND flash memory grows. The structure is thus loaded and maintained in RAM (with
    writes to the NAND flash as needed) using a tree-node structure (T-node) to track
    all allocated chunks. T-nodes are a fixed 32 bytes and, at their lowest level
    (level 0), store an index used to locate the first chunk ID. As the file size
    grows, additional levels are added, which consist of eight pointers to other T-nodes.
  prefs: []
  type: TYPE_NORMAL
- en: To regenerate, YAFFS2 reads each chunk in its block allocation order, starting
    from the end and working back, and populates the file system structures as T-nodes
    in RAM. This requires scanning the entire NAND—a time-consuming operation. To
    work around this issue, checkpointing was developed for YAFFS2, which prefers
    the RAM structure to NAND flash (using 10 blocks) when it is properly unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: A few other key concepts are needed to round out your understanding on YAFFS2\.
    First, garbage collection is queued up and, if needed, is done each time a write-to-the-system
    occurs. If all the chunks in a block are no longer in use, the block is a candidate
    for garbage collection. The system is also capable of taking the “dirtiest” block,
    copying allocated chunks to new blocks, thus making the block available for garbage
    collection. To make the block available again, it is erased by writing all 1’s
    (0xFF).
  prefs: []
  type: TYPE_NORMAL
- en: 'On an Android device, we can find detailed information about the YAFFS2 file
    systems by examining the /proc/yaffs files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-55a-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![image](img/F100044u04-55b-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see many useful details, for example, on the “datadata” YAFFS2 partition
    mounted at /data/data. By examining the /proc/yaffs listing for this partition,
    we can learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. There are 1192 blocks (0 through 1191) and we know there are 64 chunks (2048
    bytes) per block. So, 128K × 1192 = 152,576K, which you can confirm by running
    the df command or examining /proc/mtd as we did above.
  prefs: []
  type: TYPE_NORMAL
- en: 2. The number of Page Reads, Page Writes, and Block Erasures are shown. This
    will provide a general idea of how much the NAND flash is used.
  prefs: []
  type: TYPE_NORMAL
- en: 3. One strategy in the garbage collection procedure is to find blocks that are
    nearly free, copy the remaining data out, and then mark the block available for
    collection. We can see this happening at a high rate (323,313).
  prefs: []
  type: TYPE_NORMAL
- en: 4. We can see there are no ECC errors detected.
  prefs: []
  type: TYPE_NORMAL
- en: 5. The YAFFS2 metadata reports over 643,000 unlinked files.
  prefs: []
  type: TYPE_NORMAL
- en: 6. YAFFS2 is not using software ECC and instead relies on either MTD or the
    NAND flash.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the system partition that does not have the high read and write
    usage of the /data/data direction, you will notice significant differences. Inspecting
    the /proc/yaffs file may help provide necessary background information when explaining
    error-correcting code, fragmented data, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to gain a deeper understanding of YAFFS2 is to simply create,
    modify, and examine the file system directly. All of this is possible on the Ubuntu
    workstation created for other exercises throughout the book. Since we already
    have a Linux virtual machine and the build-essential package installed (which
    includes the necessary C compiler and supporting packages), we need to now install
    the mtd-utils package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-56-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we download the latest YAFFS2 source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-57-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then extract yaffs2.tar.gz and compile so we can use the kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-58-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we are going to load the needed kernel modules to simulate an MTD in RAM
    (unless you happen to have some NAND flash lying around which you can hook up
    directly) and then mount a YAFFS2 partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a place to mount the file system in our home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-59-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we need to load a few kernel modules to enable MTD support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-60-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we create the simulated NAND flash with the nandsim kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-61-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Additional information on Linux MTD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux MTD web page provides more details on nandsim. The web site provides
    deep background information and support for MTD so please visit it for full details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional details on nandsim from the Linux MTD web site are provided here
    for direct reference ([NAND FAQ, n.d.](#BIB6)):'
  prefs: []
  type: TYPE_NORMAL
- en: '“NAND simulator (nandsim) is an extremely useful debugging and development
    tool which simulates NAND flashes in RAM or a file. To select the simulated flash
    type one should specify ID bytes of your flash—the ones which are returned by
    the “Read ID” command (0x90)—consult the flash manual. The following are examples
    of input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x33—16MiB, 512 bytes page
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x35—32MiB, 512 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x36—64MiB, 512 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x78—128MiB, 512 bytes
    page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x71—256MiB, 512 bytes
    page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00
    fourth_id_byte=0x15—64MiB, 2048 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00
    fourth_id_byte=0x15—128MiB, 2048 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00
    fourth_id_byte=0x15—256MiB, 2048 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00
    fourth_id_byte=0x15—512MiB, 2048 bytes page;
  prefs: []
  type: TYPE_NORMAL
- en: • modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51
    fourth_id_byte=0x95—1GiB, 2048 bytes page;”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the simulated NAND flash, we can verify size and partition
    info by examining the /proc/mtd just as we did directly on the Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-62-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The system shows that we have one MTD partition (mtd0), and erasesize in hex
    of 0x20000 bytes (128 KB), and a total size in hex of 0x4000000 (65,536 KB or
    64 MB). Next, we need to load the YAFFS2 kernel module into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-63-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we mount the YAFFS2 file system, let’s take a look at the uninitialized
    simulated NAND flash in a hex editor. If you try to use tools like dd or simply
    xxd to view the NAND flash device, you will not see the OOB areas because they
    are not exposed to most tools. This is to prevent the intermixed 64 bits of metadata
    from confusing programs that do not expect OOB in their file (imagine trying to
    display a PDF that has 64 bytes of binary OOB data after each 2k chunk). To read
    the full NAND flash including the OOB, we use the program nanddump that is part
    of the previously installed mtd-utils package. This will read the data and return
    them in binary. There are several options to consider which can be easily viewed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-64-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, we want to use nanddump to extract the full NAND with OOB
    and pipe the output to a hex editor (xxd) for viewing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-65-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the simulated NAND flash contains the expected 0xFF values that
    a blank or erased NAND flash should have. The above command will allow you to
    examine how the raw NAND flash is modified when we initialize and subsequently
    modify the file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, finally, we are ready to mount a YAFFS2 file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-66-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can verify the file system is mounted and accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-67-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we can see a YAFFS2 file system is mounted with read/write permissions
    at ~/mnt/yaffs2\. Even though we have not created any files, the directory contains
    a lost+found virtual directory where files and directories whose parent directory
    cannot be determined are stored. If you use the xxd hex editor again to examine
    the simulated NAND flash device, it will still contain 0xFF. However, if you write
    a single file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-68-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and put the contents “Android Forensics and Mobile Security” in the file, then
    when we examine the raw NAND flash, we can clearly see the YAFFS2 structures including
    the ObjectHeaders, Objects, and file contents. Here’s a portion of the hex content
    using nanddump and a slightly modified xxd command by adding the -a option that
    will skip 0x00 rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-69-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beginning at offset 0x0000000, we can see the blank ObjectHeader where we can
    easily see the file name in ASCII (book.txt). Beginning at 0x0000800 through 0x000083F,
    we can see the OOB data that is stored by YAFFS2 and then MTD as packed binary
    data and must be decided. The actual contents of the file are written to the NAND
    flash at 0x0000840\. We see another OOB from 0x0001040 through 0x000107F and then
    the ObjectHeader is written to the NAND flash again at 0x0001080 because the original
    ObjectHeader represented the blank file. Once we added the content and saved the
    file, the data was written to the NAND flash and a *new ObjectHeader was written*
    to the NAND flash. The new ObjectHeader reflects the new metadata about the Object
    including what chunks hold the data, MAC (modified, accessed, changed) data, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: A key point to understand is that YAFFS2 could not simply update the first ObjectHeader
    with this information because it would first have to erase that entire block.
    So instead it writes a new ObjectHeader, generates a high sequence number for
    that header which makes it the most up-to-date ObjectHeader for the file. As you
    can imagine, the old ObjectHeader and data remain on the NAND flash unless they
    go through garbage collection and thus provide a great opportunity to recover
    file metadata and contents using forensic techniques.
  prefs: []
  type: TYPE_NORMAL
- en: YAFFS Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this final section about YAFFS2, a fictitious scenario is presented to illustrate
    how ObjectHeaders and Objects are written to the NAND flash. The example was presented
    by Charles Manning in his “*How Yaffs Works*” ([How YAFFS works, n.d.](#BIB5)).
    Anyone interested in the internals of YAFFS is encouraged to print, read, or re-read
    this document. In the example, we use a NAND flash which, for simplicity, has
    four chunks per block and is erased (0xFF). After each change is described, a
    table will show the contents of the NAND flash.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an empty file on the NAND flash as shown in [Table 4.6](#T0035).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.6 Blank File Created
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ObjectHeader points to an empty file. Next, we write three chunks of data
    to the file, as shown in [Table 4.7](#T0040).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.7 Write Three Chunks of Data
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, this may seem straightforward. The object is now taking up the entire
    first block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fictitious NAND flash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, our fictitious NAND flash has four chucks per block, not the typical
    64 chunks we see in commercial NAND flash.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to save the file that will cause a new ObjectHeader to be
    written to the NAND flash as shown in [Table 4.8](#T0045).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.8 Save the File’s New ObjectHeader
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key point to understand here is that YAFFS2 is unable to go back and update
    the original ObjectHeader with the new size, chunks of data, and others. Instead,
    it must write a new ObjectHeader that will contain the metadata needed for the
    updated file. In YAFFS2, the new ObjectHeader is given a larger sequence number
    and thus it becomes the current ObjectHeader and YAFFS2 simply ignores the previous
    one (however, it remains on disk).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the file will be opened with read/write access and the first chunk of
    data will be given a new value. Finally, the file is saved and closed, which results
    in additional data written to the NAND flash, as shown in [Table 4.9](#T0050).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.9 Save the New Data and ObjectHeader
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, since we cannot simply change the original first chunk of data in the
    file, a new data chunk is written to the NAND flash and the previous data chunk
    is obsolete. This is achieved as yet another new ObjectHeader is written to the
    NAND flash, which points to the new first chunk of data for the file. Next, we
    are going to truncate the file to a zero length file and the resulting NAND flash
    changes are shown in [Table 4.10](#T0055).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.10 Truncate File and Write New ObjectHeader
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the file was truncated, none of the chunks in Block 0 are in use any longer.
    This makes the block available for garbage collection, which will occur on the
    next write cycle. This is referred to as lazy garbage collection because it uses
    an existing write cycle to perform any necessary garbage collection. As before,
    a new Object-Header is written to the NAND flash to account for the truncated
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we rename the file and the NAND flash results are shown in [Table 4.11](#T0060).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.11 Rename File and Write New ObjectHeader
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During this cycle, Block 0 was garbage collected and is now available for writing
    data. As the file was renamed, a new ObjectHeader was written to the NAND flash.
    With all chunks in Block 1 now obsolete, they are available for garbage collection.
    However, bear in mind that due to the limited endurance of NAND flash, write/erase
    cycles are avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The implications for forensics are that the entire history of ObjectHeader and
    Object data chunks, unless garbage collected, would remain on the NAND flash.
    With proper software, the NAND flash could be scanned and the entire history of
    the file system could essentially be rebuilt. Not only would the timeline contain
    the date/time of every edit, but it is possible to recover the actual state of
    the file. In practice, the state of the YAFFS2 partitions is not this simple.
    However, the general principle remains relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Mounted file systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have covered many components of Android’s memory systems in detail. Not only
    have we explored RAM and the NAND flash, but we have also examined many of the
    file systems in great detail. This background information will assist in your
    forensic and security analysis of Android devices. To better understand this more
    academic information, we will now explore the mounted file systems found on an
    Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Mounted File Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start with the file systems mounted on the HTC Incredible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-70-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you run the mount command without parameters, it returns the list of mounted
    file systems and their options. [Table 4.12](#T0065) is a description of the output
    using several entries. However, note that each entry above ends with “0 0” which
    is omitted from the table for space reasons. The “0 0” entry determines whether
    or not the file system is archived by the dump command and the pass number that
    determines the order in which the file system checker (fsck) checks the device/partition
    for errors at boot time. On most desktop or server Linux systems, the root file
    system has a pass number of 1 so it is checked prior to other file systems.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.12 Output of Mount Command Overview
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/T100044tabT0065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The /mnt/sdcard has many options. The options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '1. rw: mounted to allow read/write'
  prefs: []
  type: TYPE_NORMAL
- en: '2. dirsync: all updates to directories are done synchronously'
  prefs: []
  type: TYPE_NORMAL
- en: '3. nosuid: does not allow setuid (which would allow other users to execute
    programs using the permission of file owner)'
  prefs: []
  type: TYPE_NORMAL
- en: '4. nodev: does not interpret any file as a special block device'
  prefs: []
  type: TYPE_NORMAL
- en: '5. noexec: does not let all files execute from the file system'
  prefs: []
  type: TYPE_NORMAL
- en: '6. relatime: updates the file access time if older than the modified time'
  prefs: []
  type: TYPE_NORMAL
- en: '7. uid=1000: sets the owner of all files to 1000'
  prefs: []
  type: TYPE_NORMAL
- en: '8. gid=1015: sets the group of all files to 1015'
  prefs: []
  type: TYPE_NORMAL
- en: '9. fmask=0702: sets the umask applied to regular files only (set permissions
    ---rwxr-x, or user=none, group=read/write/execute,other=read/execute)'
  prefs: []
  type: TYPE_NORMAL
- en: '10. dmask=0702: sets the umask applied to directories only (set permissions
    ---rwxr-x, or user=none, group=read/write/execute,other=read/execute)'
  prefs: []
  type: TYPE_NORMAL
- en: '11. allow_utime=0020: controls the permission check of mtime/atime.'
  prefs: []
  type: TYPE_NORMAL
- en: '12. codepage=cp437: sets the codepage for converting to shortname characters
    on FAT and VFAT file systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '13. iocharset=iso8859-1: character set to use for converting between 8-bit
    characters and 16-bit Unicode characters. The default is iso8859-1\. Long file
    names are stored on disk in Unicode format.'
  prefs: []
  type: TYPE_NORMAL
- en: '14. shortname=mixed: defines the behavior for creation and display of file
    names that fit into 8.3 characters. If a long name for a file exists, it will
    always be the preferred display. Mixed displays the short name as is and stores
    a long name when the short name is not all upper case.'
  prefs: []
  type: TYPE_NORMAL
- en: '15. utf8: converts 16-bit Unicode characters on CD to UTF-8.'
  prefs: []
  type: TYPE_NORMAL
- en: '16. errors=remount-ro: defines the behavior when an error is encountered; in
    this case, remounts the file system read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the mount command options are explained in the manual page (man 8 mount).
    However, for most cases, a quick scan will reveal the information an examiner
    needs including the mount points, types, and permissions on the file systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The df command will provide information about the free space available on the
    mounted file systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-71-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, one of the mount points (/mnt/secure/asec) returned a permission
    denied when the shell user tried to determine how much disk space was free. By
    looking at the parent directory, we can see that only root has access to the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-72-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, two of these file systems/directories can be exposed through
    the USB mass storage (UMS) option and when that occurs, the permissions on the
    directories change. If the UMS option is not enabled, the file systems are fully
    accessible to the Android device as you can see for /mnt/emmc and /mnt/sdcard.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when UMS is active and the two file systems are available to the connected
    workstation, the permissions change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/F100044u04-73-9781597496513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all permissions on /mnt/emmc and /mnt/sdcard are removed and
    thus the Android device cannot access /mnt/emmc or /mnt/sdcard from the phone
    directly (i.e., it is exclusively shared with the connected workstation).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The physical memory, file systems, and data structures present on an Android
    device are the fundamental building blocks for data storage. Having a deep understanding
    of these structures will not only enable you to understand an Android device but
    to also perform your own research and development when presented with new file
    systems and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1\. *Android developers blog: Saving data safely*. (n.d.). Retrieved February
    2, 2011, from [http://android-developers.blogspot.com/2010/12/saving-data-safely.html](http://android-developers.blogspot.com/2010/12/saving-data-safely.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. *Android reverse engineering*. (n.d.). [thomascannon.net](http://thomascannon.net).
    Retrieved January 29, 2011, from [http://thomascannon.net/projects/android-reversing/](http://thomascannon.net/projects/android-reversing/).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. *Data storage*. (n.d.). Android Developers. Retrieved March 13, 2011, from
    [http://developer.android.com/guide/topics/data/data-storage.html#netw](http://developer.android.com/guide/topics/data/data-storage.html%23netw).
  prefs: []
  type: TYPE_NORMAL
- en: '4\. *How YAFFS works: the internals*. (n.d.). YAFFS. Retrieved February 4,
    2011, from [http://www.yaffs.net/how-yaffs-works-internals](http://www.yaffs.net/how-yaffs-works-internals).'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Nand Faq. (n.d.). *Memory technology device (MTD) subsystem for Linux*,
    Retrieved March 13, 2011, from [http://www.linux-mtd.infradead.org/faq/nand.html](http://www.linux-mtd.infradead.org/faq/nand.html).
  prefs: []
  type: TYPE_NORMAL
- en: 6\. *The sysfs filesystem*. (n.d.), Retrieved February 1, 2011, from [http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf](http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Way, T. (n.d.). *Android will be using ext4 starting with Gingerbread. Thoughts
    by Ted. Welcome to* [<ce:italic>thunk.org</ce:italic>](http://thunk.org), Retrieved
    February 2, 2011, from [http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/](http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/).
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Licence FAQs, Y. A. F. F. S. (n.d.). YAFFS, Retrieved February 4, 2011,
    from [http://www.yaffs.net/yaffs-licence-faqs](http://www.yaffs.net/yaffs-licence-faqs).
  prefs: []
  type: TYPE_NORMAL
- en: '9\. *YAFFS: the NAND-specific flash file system—Introductory Article*. (n.d.).
    Retrieved February 2, 2011, from [http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle](http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle).'
  prefs: []
  type: TYPE_NORMAL
