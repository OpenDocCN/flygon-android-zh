- en: Chapter 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: Android file systems and data structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android文件系统和数据结构
- en: Information in this chapter
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章信息
- en: • [Data in the shell](#S0015)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: • [壳层中的数据](#S0015)
- en: • [Type of memory](#S0090)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: • [内存类型](#S0090)
- en: • [File systems](#S0105)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • [文件系统](#S0105)
- en: • [Mounted file systems and directory structures](#S0145)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • [挂载的文件系统和目录结构](#S0145)
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: While the underlying hardware and software powering Android devices is fascinating,
    the primary focus of forensic analysts and security engineers is to acquire, analyze,
    and understand data stored on a device. Like other topics discussed, there are
    many nuances to this that are important to understand for effective analysis including
    what types of data are stored, where they are stored, how they are stored, and
    characteristics of the physical mediums on which they are stored. All of these
    factors play a major role in what data can be recovered and how they can be analyzed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然支持Android设备的底层硬件和软件非常吸引人，但法医分析师和安全工程师的主要关注点是获取、分析和理解设备上存储的数据。与讨论的其他主题一样，为了有效分析，了解存储的数据类型、存储位置、存储方式以及存储介质的物理特性等许多细微差别非常重要。所有这些因素在决定哪些数据可以恢复以及如何分析这些数据方面起着主要作用。
- en: Data in the Shell
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 壳层中的数据
- en: Forensic analysts are primarily concerned with data artifacts that can be recovered
    from the devices they investigate. Android is a combination of both well-known
    artifacts, such as those found in Linux, and entirely new ones, such as the Dalvik
    VM and the YAFFS2 file system. Adding to the complexity are the varying architectures
    that different manufacturers embrace.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 法医分析师主要关注可以从他们调查的设备中恢复的数据遗迹。Android结合了在Linux中发现的众所周知的遗迹以及完全新的遗迹，例如Dalvik VM和YAFFS2文件系统。不同制造商采用的多种架构增加了复杂性。
- en: While no single book or examiner could possibly cover this topic exhaustively,
    there are certain fundamental concepts common to Android devices. File systems,
    file, and other artifacts are at the core of what forensic analysts must understand
    about Android to maximize the effectiveness of their investigations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有一本书或检查员能够彻底涵盖这个话题，但Android设备有一些共同的基本概念。文件系统、文件和其他遗迹是法医分析师为了使调查效果最大化必须了解的Android核心内容。
- en: What Data are Stored
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储的数据类型
- en: 'Android devices store an enormous amount of data, typically combining both
    personal and work data. Apps are the primary source of these data, and there are
    a number of sources for apps including:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备存储大量数据，通常结合了个人和工作数据。应用程序是这些数据的主要来源，应用程序的来源包括：
- en: • Apps that ship with Android
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 随Android提供的应用程序
- en: • Apps installed by the manufacturer
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 制造商安装的应用程序
- en: • Apps installed by the wireless carrier
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 由无线运营商安装的应用程序
- en: • Additional Google/Android apps
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 额外的Google/Android应用
- en: • Apps installed by the user, typically from the Android Market
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: • 用户安装的应用程序，通常来自Android市场
- en: '[Chapter 7](CHP007.html), Android Application and Forensic Analysis, will examine
    a number of these apps in detail, although it is certainly beyond the scope of
    this book to cover all possibilities. A sample of data found on Android devices
    includes the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[第七章](CHP007.html)，Android应用程序和法医分析，将详细研究这些应用程序中的许多，尽管本书的范围当然不可能涵盖所有可能性。在Android设备上找到的数据样本包括以下内容：'
- en: • Text messages (SMS/MMS)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: • 短信（SMS/MMS）
- en: • Contacts
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: • 联系人
- en: • Call logs
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: • 通话记录
- en: • E-mail messages (Gmail, Yahoo, Exchange)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: • 电子邮件信息（Gmail、Yahoo、Exchange）
- en: • Instant Messenger/Chat
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 即时通讯/聊天
- en: • GPS coordinates
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: • GPS坐标
- en: • Photos/Videos
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: • 照片/视频
- en: • Web history
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: • 网络历史
- en: • Search history
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: • 搜索历史
- en: • Driving directions
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: • 驾驶方向
- en: • Facebook, Twitter, and other social media clients
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: • Facebook、Twitter和其他社交媒体客户端
- en: • Files stored on the device
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: • 设备上存储的文件
- en: • Music collections
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: • 音乐收藏
- en: • Calendar appointments
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: • 日程安排
- en: • Financial information
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: • 财务信息
- en: • Shopping history
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: • 购物历史
- en: • File sharing
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: • 文件共享
- en: App Data Storage Directory Structure
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用数据存储目录结构
- en: Android applications primarily store data in two locations, internal and external
    storage, both of which will be covered in more detail later in this chapter. However,
    it is helpful to have a high-level understanding of the data storage directory
    structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序主要在两个位置存储数据：内部存储和外部存储，这两部分将在本章后面详细介绍。然而，对数据存储目录结构有一个高层次的了解是有帮助的。
- en: In the external data storage areas (the SD card and emulated SD cards), applications
    can store data in any location they wish. However, internal data storage is controlled
    by the Android APIs. When an application is installed (through either the market
    place or in the build shipped to the consumer), an internal data storage is saved
    in a subdirectory of /data/data/ named after the package name. For example, the
    default Android browser has a package name of com.android.browser and, as such,
    the data files are stored in /data/data/com.android.browser. While applications
    are not required to store data files, most do.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部数据存储区域（SD卡和模拟SD卡），应用程序可以按意愿在任何位置存储数据。然而，内部数据存储由Android API控制。当应用程序安装后（通过市场或直接提供给消费者的构建版本），内部数据存储在以包名命名的/data/data/子目录中。例如，默认的Android浏览器具有包名com.android.browser，因此数据文件存储在/data/data/com.android.browser中。尽管应用程序不要求存储数据文件，但大多数都会存储。
- en: Inside the applications /data/data subdirectory, there are a number of standard
    directories found in many applications as well as directories that developers
    control. The most common standard subdirectories are listed in [Table 4.1](#T0010).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的/data/data子目录内部，有许多在许多应用程序中都能找到的标准目录以及开发者控制的目录。[表4.1](#T0010)列出了最常见的标准子目录。
- en: Table 4.1 Common /data/data/<packageName> Subdirectories
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 常见/data/data/<packageName>子目录
- en: '| shared_prefs | Directory Storing Shared Preferences in XML Format |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| shared_prefs | 以XML格式存储共享偏好设置的目录 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| lib | Custom library files an application requires |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| lib | 应用程序所需的自定义库文件 |'
- en: '| files | Files the developer saves to internal storage |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| files | 开发者保存到内部存储的文件 |'
- en: '| cache | Files cached by the application, often cache files from the web browser
    or other apps that use the WebKit engine |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| cache | 应用程序缓存的文件，通常是网页浏览器或其他使用WebKit引擎的应用程序的缓存文件 |'
- en: '| databases | SQLite databases and journal files |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| databases | SQLite数据库和日志文件 |'
- en: '[Table 4.1](#T0010) only presents the most common subdirectories found in an
    application’s /data/data file. As we examine data more closely throughout this
    book, we will catalog many additional folders and data files.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4.1](#T0010)仅展示了应用程序的/data/data文件中最常见的子目录。在本书的后续内容中，我们将详细列出许多额外的文件夹和数据文件。'
- en: How Data are Stored
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据存储方式
- en: Android provides developers with five methods for storing data to a device.
    Forensic examiners can uncover data in at least four of the five formats. Therefore,
    it is important to understand each in detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Android为开发者提供了五种在设备上存储数据的方法。法医检查员至少可以在五种格式中的四种中找到数据。因此，详细理解每一种格式非常重要。
- en: 'Persistent data are stored to either the NAND flash, the SD card, or the network.
    Specifically, the five methods are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 持久数据存储在NAND闪存、SD卡或网络上。具体来说，五种方法包括：
- en: 1. Shared preferences
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 共享偏好设置
- en: 2. Internal storage
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 内部存储
- en: 3. External storage
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 外部存储
- en: 4. SQLite
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 4. SQLite
- en: 5. Network
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 网络
- en: Beyond the data that app developers store, the Linux kernel and Android stack
    provide information through logs, debugging, and other standard information services.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用开发者存储的数据外，Linux内核和Android堆栈还通过日志、调试和其他标准信息服务提供信息。
- en: Shared Preferences
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享偏好设置
- en: 'Shared preferences allow a developer to store key-value pairs of primitive
    data types in a lightweight XML format. Primitive data types that can be stored
    in a preferences file include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 共享偏好设置允许开发者以轻量级的XML格式存储基本数据类型的键值对。可以在偏好设置文件中存储的基本数据类型包括以下几种：
- en: '1. boolean: true or false'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '1. boolean: 真或假'
- en: '2. float: single-precision 32-bit IEEE 754 floating point'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '2. float: 单精度32位IEEE 754浮点数'
- en: '3. int: 32-bit signed two’s complement integer'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '3. int: 32位有符号二进制补码整数'
- en: '4. long: 64-bit signed two’s complement integer'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '4. long: 64位有符号二进制补码整数'
- en: '5. strings: string value, typically as a UTF-8'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '5. strings: 字符串值，通常为UTF-8编码'
- en: With these basic types, developers can create and save simple values that power
    their application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些基本类型，开发者可以创建并保存为他们的应用程序提供动力的简单值。
- en: 'Shared preferences files are typically stored in an application’s data directory
    in the shared_pref folder and end with .xml. On our reference HTC Incredible,
    the Android phone shared preferences directory are five XML files:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 共享偏好设置文件通常存储在应用程序数据目录的shared_pref文件夹中，并以.xml结尾。在我们参考的HTC Incredible Android手机上，共享偏好设置目录包含五个XML文件：
- en: '![image](img/F100044u04-01-9781597496513.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-01-9781597496513.jpg)'
- en: 'The com.android.phone_preferences.xml preferences file has examples of int,
    boolean, and string preferences:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: com.android.phone_preferences.xml首选项文件包含了int、boolean和string首选项的示例：
- en: '![image](img/F100044u04-02-9781597496513.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-02-9781597496513.jpg)'
- en: 'As you can tell, the XML file describes the string encoding type at the start
    of the file, UTF-8 in this case. There are three preferences that save various
    settings and characteristics. Perhaps most interesting from a forensics standpoint
    is the updateAreaCode.xml:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，XML文件在文件开始处描述了字符串编码类型，在这种情况下是UTF-8。有三个首选项保存了各种设置和特性。从法医的角度来看，最有趣的可能就是updateAreaCode.xml了。
- en: '![image](img/F100044u04-03-9781597496513.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-03-9781597496513.jpg)'
- en: The mobile directory number (MDN) is queried and the area code for the device
    is stored in this file, presumably to allow a seven-digit dialing option in areas
    supporting that feature.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件查询了移动目录号码（MDN）并将设备的区号存储在此文件中，推测是为了在支持该功能的地区提供七位数字拨号选项。
- en: Since many applications take advantage of the lightweight Shared Preferences
    method for storing key-value pairs, it can be a rich source of forensic data.
    This is especially true when examiners can recover older or deleted versions of
    the XML preferences file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多应用程序利用轻量级的Shared Preferences方法来存储键值对，因此它可以成为丰富的法医数据来源。特别是当检查员可以恢复XML首选项文件的旧版本或已删除版本时，这一点尤其正确。
- en: Files on Internal Storage
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内部存储的文件
- en: Files allow developers to store more complicated data structures and are saved
    in several places on the file internal storage. The files are stored in the application’s
    /data/data subdirectory and the developer has control over the file type, name,
    and location. By default, the files can only be read by the application and even
    the device owner is prevented from viewing the files unless they have root access.
    The developer can override the security settings to allow other processes to read
    and even update the file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文件允许开发者存储更复杂的数据结构，并保存在文件内部存储的几个位置。这些文件存储在应用程序的/data/data子目录中，开发者可以控制文件类型、名称和位置。默认情况下，只有应用程序可以读取这些文件，即使设备所有者没有root权限也无法查看这些文件。开发者可以覆盖安全设置，允许其他进程读取甚至更新文件。
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Identifying custom files
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别自定义文件
- en: The best way to determine which files in an application’s subdirectory fall
    into this category is by a process of elimination. Basically, any file in the
    application’s /data/data/ subdirectory which is *not* in the shared_prefs, lib,
    cache, or databases subdirectories is a file the developer created and controls.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 确定应用程序子目录中哪些文件属于这一类别的最佳方式是通过排除法。基本上，应用程序中/data/data/子目录下不属于shared_prefs、lib、cache或databases子目录的任何文件都是开发者创建和控制的文件。
- en: 'Let’s examine com.google.android.apps.maps that provides a good example of
    files saved on internal storage:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一下com.google.android.apps.maps，它提供了保存于内部存储的文件的好例子：
- en: '![image](img/F100044u04-04-9781597496513.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-04-9781597496513.jpg)'
- en: 'The application uses most of the storage mechanisms available and stores files
    on internal storage in both the app_ and files directory. The app_ directory has
    several subdirectories and a cache_r.m file which is not of a known file format:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用了大多数可用的存储机制，在内部存储的app_和files目录中存储文件。app_目录有多个子目录和一个未知的cache_r.m文件格式：
- en: '![image](img/F100044u04-05-9781597496513.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-05-9781597496513.jpg)'
- en: 'The files directory stores many data files needed by the application to display
    and update Google Maps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: files目录存储了应用程序显示和更新Google Maps所需的大量数据文件：
- en: '![image](img/F100044u04-06a-9781597496513.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-06a-9781597496513.jpg)'
- en: '![image](img/F100044u04-06b-9781597496513.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-06b-9781597496513.jpg)'
- en: The files clearly indicate data that may be of interest to a forensic analyst
    or security engineer. A more thorough data analysis of applications and their
    data stored will be covered in [Chapter 7](CHP007.html), Android Application and
    Forensic Analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件清楚地表明了可能对法医分析师或安全工程师感兴趣的数据。在第[七章](CHP007.html)，Android应用程序和法医分析中，将更详细地介绍应用程序及其存储数据的数据分析。
- en: Files on External Storage
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部存储的文件
- en: While files stored on the internal device’s storage have strict security and
    location parameters, files on the various external storage devices have far fewer
    constraints.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存储在内部设备存储上的文件具有严格的安全性和位置参数，但各种外部存储设备上的文件限制要少得多。
- en: First, one important motivation (beyond cost) for using a removable SD card
    is that the data could be used on other devices, presumably upgraded Android devices.
    If a consumer purchased a new Android device, inserted their previous SD card
    containing all of his or her family pictures and videos and found they were unable
    to access them, they would be quite upset.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用可移动 SD 卡的一个重要动机（除了成本之外）是数据可以在其他设备上使用，可能是升级后的 Android 设备。如果消费者购买了一部新的 Android
    设备，插入之前包含他们所有家庭成员照片和视频的 SD 卡，却发现自己无法访问这些内容，他们将会非常沮丧。
- en: In order to facilitate mounting the SD card on desktop computers to share files,
    SD cards are generally formatted with Microsoft’s FAT32 files system. While the
    file system is widely supported, it lacks the fine grained security mechanism
    built into file systems such as ext3, ext4, yaffs2, hfsplus, and more. Thus, by
    default, the files cannot enforce permissions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在桌面计算机上挂载 SD 卡以共享文件，SD 卡通常使用微软的 FAT32 文件系统格式化。虽然该文件系统得到了广泛支持，但它缺少如 ext3、ext4、yaffs2、hfsplus
    等文件系统内置的细粒度安全机制。因此，默认情况下，文件无法强制执行权限。
- en: 'For example, the com.google.android.apps.maps application referenced previously
    also stores data on the SD card in the Android/data subdirectory. The following
    is a listing of the files and directories from the reference HTC Incredible SD
    card, mounted at /mnt/sdcard:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面提到的 com.google.android.apps.maps 应用程序也会在 Android/data 子目录下的 SD 卡上存储数据。以下是来自参考的
    HTC Incredible SD 卡（挂载在 /mnt/sdcard）的文件和目录列表：
- en: '![image](img/F100044u04-07-9781597496513.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-07-9781597496513.jpg)'
- en: 'Similarly, the HTC Incredible ships with an emulated SD card that is stored
    directly on the NAND flash. The emulated SD card is mounted at /mnt/emmc. The
    following is a listing of a subdirectory that stores album JFIF thumbnail files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，HTC Incredible 配备了一个存储在 NAND 闪存上的模拟 SD 卡。模拟 SD 卡挂载在 /mnt/emmc 上。以下是存储相册 JFIF
    缩略图的子目录列表：
- en: '![image](img/F100044u04-08-9781597496513.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-08-9781597496513.jpg)'
- en: As you can tell, developers have great control over the name, format, and location
    of files on the external and emulated SD cards.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，开发者对外部 SD 卡和模拟 SD 卡上的文件名称、格式和位置有着很大的控制权。
- en: SQLite
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQLite
- en: Another NAND/SD card-based storage that developers leverage is a specific type
    of file—an SQLite database. Databases are used for structured data storage and
    SQLite is a popular database format appearing in many mobile systems as well as
    traditional operating systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个开发者可以利用的 NAND/SD 卡存储方式是一种特定类型的文件——SQLite 数据库。数据库用于结构化数据存储，而 SQLite 是一个在许多移动系统以及传统操作系统上广泛出现的流行数据库格式。
- en: SQLite is popular for many reasons. Notably the entire code base is of high
    quality, open source, and released to the public domain. The file format and the
    program itself are very compact and pack significant functionality in less than
    a few hundred kilobytes. Unlike more traditional relational database management
    systems (RDBMS), such as Oracle, MySQL, and Microsoft’s SQL Server, with SQLite
    the entire database is contained in a single cross-platform file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 因多种原因而受到欢迎。值得注意的是整个代码库质量高，开源，并且发布到公共领域。文件格式和程序本身非常紧凑，在不到几百千字节的空间内实现了显著的功能。与
    Oracle、MySQL 和 Microsoft 的 SQL Server 等更传统的关系数据库管理系统（RDBMS）不同，SQLite 整个数据库包含在一个跨平台的单一文件中。
- en: The Android SDK provides dedicated APIs that allow developers to use SQLite
    databases in their applications. The SQLite files are generally stored on the
    internal storage under /data/data/<packageName>/databases. However, there are
    no restrictions on creating databases elsewhere.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 提供了专门的 API，允许开发者在他们的应用程序中使用 SQLite 数据库。SQLite 文件通常存储在内部存储的 /data/data/<packageName>/databases
    目录下。然而，创建数据库在其他位置并没有限制。
- en: 'SQLite databases are a rich source of forensic data. The built-in Android browser,
    based on the WebKit Open Source Project ([http://webkit.org/](http://webkit.org/)),
    provides a great example. In our referenced HTC Incredible, there were 28 SQLite
    databases located in subdirectories of /data/data/com.android.webkit. In this
    instance, the five subdirectories were as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库是丰富的法医数据来源。基于 WebKit 开源项目（[http://webkit.org/](http://webkit.org/)）的内置
    Android 浏览器提供了一个很好的例子。在我们参考的 HTC Incredible 中，有 28 个 SQLite 数据库位于 /data/data/com.android.webkit
    的子目录下。在这个例子中，五个子目录如下：
- en: '• app_icons: 1 database of web page icons'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: • app_icons：一个网页图标数据库
- en: '• app_cache: 1 database containing web application data cache'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • app_cache：一个包含网页应用数据缓存的数据库
- en: '• app_geolocation: 2 databases relating to GPS position and permissions'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '• app_geolocation: 与GPS位置和权限相关的2个数据库'
- en: '• app_databases: 21 databases providing local database storage for supporting
    web sites'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '• app_databases: 21个数据库，为支持网站提供本地数据库存储'
- en: '• databases: 3 databases for the browser and browser cache'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '• databases: 浏览器和浏览器缓存的3个数据库'
- en: There is very high potential of recovering forensically valuable data from these
    files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些文件中恢复具有取证价值的数据的可能性非常高。
- en: Network
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络
- en: The final data storage mechanism available to developers is the network, a key
    benefit of a device designed to be network aware. Initially, very few applications
    took advantage of the network as a storage option. However, as the SDK, apps,
    and devices mature, the network storage option is being leveraged more.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可用的最后一种数据存储机制是网络，这是设计为网络感知设备的一个关键优势。最初，很少有应用程序利用网络作为存储选项。然而，随着SDK、应用程序和设备的成熟，网络存储选项正在被更多地利用。
- en: The Android Developer web site provides very few details for those interested
    in network storage. Their entire documentation is a mere two sentences long ([Data
    storage, n.d.](#BIB3)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓开发者网站为那些对网络存储感兴趣的人提供了非常少的详细信息。他们的整个文档只有短短两句话长([Data storage, n.d.](#BIB3))。
- en: 'You can use the network (when it is available) to store and retrieve data on
    your own web-based services. To do network operations, use classes in the following
    packages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络可用时，您可以使用网络来存储和检索您自己的基于网络服务的数据。要进行网络操作，请使用以下软件包中的类：
- en: • java.net.^∗
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: • java.net.^∗
- en: • android.net.^∗
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: • android.net.^∗
- en: The packages referenced in the documentation essentially provide developers
    with the low-level APIs needed to interact with the network, web servers, and
    more. Apps that leverage the network require more custom coding and, while all
    of the forensically interesting data may not be stored on the device, often important
    configuration and database files are recoverable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中提到的软件包基本上为开发者提供了与网络、网络服务器等交互所需的基础API。利用网络的程序需要更多的自定义编码，而且并非所有具有取证价值的数据都存储在设备上，但通常可以恢复重要的配置和数据库文件。
- en: 'For example (and as a sneak peak to [Chapter 7](CHP007.html), Android Application
    and Forensic Analysis), Dropbox is a popular file sharing web site which has mobile
    apps for Android, Blackberry, and iOS devices. Their current Android application
    (version 1.0.3.0) has been downloaded from the Android Market over 250,000 times
    and has over 35,000 user ratings, most quite high. After the app is installed,
    you can find the application folder at /data/data/com.dropbox.android with four
    standard directories:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如（作为对[第7章](CHP007.html)，Android应用程序和取证分析的预览），Dropbox是一个受欢迎的文件共享网站，它有适用于Android、黑莓和iOS设备的移动应用。他们当前的Android应用程序（版本1.0.3.0）在Android
    Market上的下载量已超过25万次，拥有超过35,000个用户评分，大多数评分都很高。安装应用后，您可以在/data/data/com.dropbox.android找到应用程序文件夹，其中包括四个标准目录：
- en: '![image](img/F100044u04-09-9781597496513.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-09-9781597496513.jpg)'
- en: 'The log.txt is a verbose log of activity and a few lines are provided for reference:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: log.txt是活动详细日志，以下提供几行以供参考：
- en: '![image](img/F100044u04-10-9781597496513.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-10-9781597496513.jpg)'
- en: 'Some items of potential interest were emphasized in the above listing, specifically:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中强调了一些可能感兴趣的项，具体包括：
- en: 1. All actions have time stamps
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 所有操作都有时间戳
- en: 2. Successfully authenticate user, user name provided
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 成功认证用户，提供了用户名
- en: 3. Picture imported from Gallery
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 从图库导入图片
- en: 4. Specific file on SD card is uploaded
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 4. SD卡上的特定文件已上传
- en: 5. Dropbox service is interrupted by phone call
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 5. Dropbox服务被电话中断
- en: 'The app also has a shared preference file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用还有一个共享偏好文件：
- en: '![image](img/F100044u04-11-9781597496513.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-11-9781597496513.jpg)'
- en: 'A quick examination of the db.db yields the following data using the sqlite3
    command line program (you could also use a graphical SQLite browser to view the
    database):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sqlite3命令行程序快速检查db.db，可以得到以下数据（您也可以使用图形化SQLite浏览器查看数据库）：
- en: '![image](img/F100044u04-12-9781597496513.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-12-9781597496513.jpg)'
- en: The database provides important forensic and security data about the Dropbox
    application, device, and ultimately the user and people they might interact with.
    The “Android intro.pdf” file was automatically synced to the Dropbox account by
    Dropbox when Android app was installed and logged into. When the shared PDF file
    was viewed, it was cached on the SD card. Additional metadata about the file and
    the use of it is contained in the database. Despite Dropbox’s extensive use of
    network data storage for their application, we could still recover useful information.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库提供了关于Dropbox应用程序、设备以及最终用户和可能交互的人的重要法医和安全数据。"Android intro.pdf"文件在安装并登录Android应用时，由Dropbox自动同步到Dropbox账户。当查看共享的PDF文件时，它被缓存在SD卡上。关于文件及其使用的额外元数据包含在数据库中。尽管Dropbox在其应用程序中广泛使用网络数据存储，我们仍然可以恢复有用的信息。
- en: Kernel, System, and Application Logs
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内核、系统和应用程序日志
- en: One additional area where forensic analysts and security engineers can locate
    files and information relevant to an investigation or audit is the standard Linux
    file system. Unfortunately, that’s quite broad and overwhelming, but we can at
    least provide a starting place to look for relevant information.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的Linux文件系统中，法医分析师和安全工程师还可以找到与调查或审计相关的文件和信息。不幸的是，这个范围相当广泛且令人望而却步，但我们可以至少提供一个查找相关信息起点的地方。
- en: Log files and debugging are two common and effective ways in which developers
    and administrators both maintain their system and their apps. It provides an insight
    into the apps as well as the system running them. While not true in every case,
    it is possible to glean important information from an Android device by simply
    examining the various log and debug files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件和调试是开发人员和系统管理员维护系统和应用程序的两种常见且有效的方法。它提供了对应用程序以及运行它们的系统的洞察。虽然并非在每种情况下都适用，但只需检查Android设备上的各种日志和调试文件，就可能获得重要信息。
- en: Linux kernel logging
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Linux内核日志
- en: 'The Linux kernel is the low level, abstract interface of the Linux operating
    system that provides access to the hardware of a device. Since the role of the
    kernel is central to all functions on the device, the ability to log key events
    and activities is highly leveraged. The kernel log is accessible on a Linux (and
    thus Android) device through the command dmesg. This will print to console all
    available kernel messages, a portion of which is displayed here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是Linux操作系统的底层抽象接口，它提供了访问设备硬件的能力。由于内核在设备上的所有功能中都起着核心作用，因此记录关键事件和活动的能力非常有价值。在Linux（以及Android）设备上，可以通过命令dmesg访问内核日志。这将把所有可用的内核信息打印到控制台，部分信息如下所示：
- en: '![image](img/F100044u04-13a-9781597496513.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-13a-9781597496513.jpg)'
- en: '![image](img/F100044u04-13b-9781597496513.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-13b-9781597496513.jpg)'
- en: As you may notice, the data are quite verbose and low level. However, it can
    provide important time stamps and activities, as well as a wealth of information
    about the device on boot-up. However, if the device has not been rebooted recently,
    the initial logs from startup are no longer available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，数据非常详细且属于低级别。然而，它可以提供重要时间戳和活动信息，以及关于设备启动的大量信息。但是，如果设备最近没有重启，那么启动时的初始日志将不再可用。
- en: 'This command does not require any special permission on the device except that
    USB debugging must be enabled. If you ran this command on a device or emulator,
    you would have noticed that far too much data were displayed on your screen. You
    can determine the total number of lines available in the log by piping (or sending)
    the contents of dmesg to a program called wc (which stands for word count) and
    instructing it to count the number of lines:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在设备上不需要任何特殊权限，只需启用USB调试即可。如果您在设备或模拟器上运行此命令，您会注意到屏幕上显示了过多的数据。您可以通过将dmesg的内容传递（或发送）到名为wc（代表单词计数）的程序，并指示它计算日志中的行数来确定日志中的总行数：
- en: '![image](img/F100044u04-14-9781597496513.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-14-9781597496513.jpg)'
- en: 'So, on the reference HTC Incredible, we have 1859 lines in the kernel log.
    If you need to inspect the information more closely, or include it in a report,
    you can redirect the output of dmesg to a file with the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在参考的HTC Incredible上，我们有1859行内核日志。如果您需要更仔细地检查信息，或者将其包含在报告中，您可以使用以下命令将dmesg的输出重定向到文件中：
- en: '![image](img/F100044u04-15-9781597496513.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-15-9781597496513.jpg)'
- en: You can now examine the contents of the available kernel log by opening dmesg.log
    in a text editor or display program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过在文本编辑器或显示程序中打开dmesg.log来检查可用内核日志的内容。
- en: logcat
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: logcat
- en: Android has several additional debugging techniques available. One program,
    logcat, displays a continuously updated list of system and application debug messages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓有几个额外的调试技术可用。一个程序，logcat，显示一个持续更新的系统和应用程序调试信息列表。
- en: '![image](img/F100044u04-16a-9781597496513.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-16a-9781597496513.jpg)'
- en: '![image](img/F100044u04-16b-9781597496513.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-16b-9781597496513.jpg)'
- en: A quick scan of the small log snippet above reveals
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览上述的小日志片段可以揭示
- en: • Longitude and latitude data
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: • 经度和纬度数据
- en: • Date/time information
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: • 日期/时间信息
- en: • Application details
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: • 应用程序详情
- en: The logging is very verbose and the sample provided here is just a small sample
    of what is available. Each log message begins with message type indicator, described
    in [Table 4.2](#T0015).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录非常详细，这里提供的样本只是可用内容的一小部分。每个日志消息都以消息类型指示符开始，在[表4.2](#T0015)中有描述。
- en: Table 4.2 Log Method Types
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 日志方法类型
- en: '| Message Type | Description |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 消息类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| V | Verbose |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| V | 详细 |'
- en: '| D | Debug |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| D | 调试 |'
- en: '| I | Information |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| I | 信息 |'
- en: '| W | Warning |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| W | 警告 |'
- en: '| E | Error |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| E | 错误 |'
- en: '| F | Fatal |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| F | 致命 |'
- en: '| S | Silent |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| S | 静默 |'
- en: 'The logcat program also provides logs from the full cellular radio debug, which
    can be viewed with the following command (only select portions of the radio logs
    included):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: logcat程序还提供了完整的蜂窝无线调试日志，可以通过以下命令查看（仅包含部分无线日志）：
- en: '![image](img/F100044u04-17-9781597496513.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-17-9781597496513.jpg)'
- en: 'While the logging is verbose and generally cryptic, scanning the logs above
    can provide information such as:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日志记录详细且通常难以理解，但扫描上述日志可以提供如下信息：
- en: • Time of events (in Unix Epoch, e.g., t=1296218163)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: • 事件时间（以Unix纪元时间表示，例如，t=1296218163）
- en: • AT commands used by the cellular modem to communicate
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: • 用于与蜂窝调制解调器通信的AT命令
- en: • Recipient, size, time, and encoded SMS message
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: • 接收者、大小、时间和编码的短信信息
- en: • Device’s cellular IP address, networking and location information
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: • 设备的蜂窝IP地址、网络和位置信息
- en: • Wireless carrier information
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: • 无线运营商信息
- en: This information is of very low level. However, if such logs are recovered,
    they can reveal important information about a device.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息属于非常底层的。然而，如果恢复这些日志，它们可以揭示关于设备的重要信息。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: Unix Epoch
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unix纪元时间
- en: Unix Epoch time is a common format for time stamps in systems based on Unix/Linux.
    The time stamp is an integer value that represents the number of seconds (or milliseconds)
    since January 1, 1970\. A typical time stamp using seconds will have 10 digits
    while a time stamp using milliseconds will have 13 digits. Time stamps are covered
    in more details in [Chapter 7](CHP007.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Unix纪元时间是基于Unix/Linux系统的的时间戳常见格式。时间戳是一个整数值，表示自1970年1月1日以来的秒数（或毫秒数）。使用秒的时间戳通常有10位数字，而使用毫秒的时间戳将有13位数字。时间戳在[第7章](CHP007.html)中有更详细的介绍。
- en: 'One final logcat feature is the event logs display:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: logcat最后一个特性是事件日志显示：
- en: '![image](img/F100044u04-18-9781597496513.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-18-9781597496513.jpg)'
- en: Again, this log is very verbose. However, as different events within the system
    occur, they log considerable information here. In the previous log snippet, we
    can see both an INSERT and SELECT statement on the mmssms.db, which is used to
    store text messages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个日志非常详细。然而，随着系统内发生不同的事件，它们在这里记录了大量的信息。在之前的日志片段中，我们可以看到对mmssms.db的INSERT和SELECT语句，该数据库用于存储短信。
- en: dumpsys
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: dumpsys
- en: The next logging mechanism is accessed through a command called dumpsys.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个日志机制是通过一个名为dumpsys的命令访问的。
- en: Dumpsys provides information on services, memory, and other system details that
    can provide helpful information. Some of the types of information provided include
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Dumpsys提供了有关服务、内存和其他系统详细信息的信息，这些信息可能很有帮助。提供的一些信息类型包括
- en: • Currently running services
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: • 当前正在运行的服务
- en: • Dump of each service
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个服务的转储
- en: • Services, broadcasts, pending intents, activities, and processes in current
    activity manager state
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: • 当前活动管理器状态下的服务、广播、待定意图、活动和进程
- en: • Process information including memory, process IDs (PIDs), databases, and more
    used
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: • 包括内存、进程ID（PIDs）、数据库等在内的进程信息
- en: Sample sections from the reference HTC Incredible dumpsys are listed next and
    each include a brief explanation of how the data might be valuable to a forensic
    analyst or security engineer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来列出了来自参考 HTC Incredible dumpsys 的样本部分，并简要解释了这些数据对法医分析师或安全工程师可能具有的价值。
- en: 'First, you run the dumpsys command as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你按照如下方式运行 dumpsys 命令：
- en: '![image](img/F100044u04-19-9781597496513.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-19-9781597496513.jpg)'
- en: The section dumping details of the service “account” has valuable information
    about the various accounts used on the device.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及“account”服务详细信息的部分，包含了关于设备上使用的各种账户的宝贵信息。
- en: '![image](img/F100044u04-20-9781597496513.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-20-9781597496513.jpg)'
- en: 'You can see not only programs used, but also at times the account name specific
    to the user. For example, the above reveals:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以看到使用的程序，还可以看到特定于用户的账户名称。例如，上述信息透露了：
- en: • Google account with user name [book@viaforensics.com](mailto:book@viaforensics.com)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: • 具有用户名 [book@viaforensics.com](mailto:book@viaforensics.com) 的 Google 账户
- en: • Exchange ActiveSync (EAS) account with user name [book@viaforensics.com](mailto:book@viaforensics.com)
    (separate from the Google account above)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: • 与用户名 [book@viaforensics.com](mailto:book@viaforensics.com) 的 Exchange ActiveSync
    (EAS) 账户（与上述 Google 账户分开）
- en: • Facebook account for Andrew Hoog
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: • 安德鲁·胡格的 Facebook 账户
- en: • Twitter account for viaforensics
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: • viaforensics 的 Twitter 账户
- en: • Google account for [personal@emailaddress.com](mailto:personal@emailaddress.com)
    (second one on the device)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: • 为 [personal@emailaddress.com](mailto:personal@emailaddress.com) 的 Google 账户（设备上的第二个）
- en: 'Further in the log, the actual time stamps for the last 10 syncs are similarly
    provided:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志进一步内容中，同样提供了最后10次同步的实际时间戳：
- en: '![image](img/F100044u04-21-9781597496513.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-21-9781597496513.jpg)'
- en: Another service is humorously named “iphonesubinfo,” which obviously has nothing
    to do with Apple’s iPhone despite the similarity in name.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个服务被幽默地命名为“iphonesubinfo”，尽管名字相似，但显然与苹果的 iPhone 无关。
- en: '![image](img/F100044u04-22-9781597496513.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-22-9781597496513.jpg)'
- en: Both the phone type and Device ID (changed) are available from this section.
    The Device ID is not the device’s serial number but the Mobile Equipment Identifier
    (MEID), which uniquely identifies the device on the CDMA network.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一部分可以获取手机类型和设备 ID（已更改）。设备 ID 不是设备的序列号，而是移动设备标识符（MEID），在 CDMA 网络上唯一标识设备。
- en: Another great source of information is the location service that shows last
    known location information and time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的信息来源是位置服务，它显示最后已知的位置信息及时刻。
- en: '![image](img/F100044u04-23-9781597496513.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-23-9781597496513.jpg)'
- en: 'Most time stamps in Android are the number of milliseconds since January 1,
    1970, which is Unix Epoch time—in milliseconds instead of seconds, however. Since
    most tools convert Unix Epoch based on seconds, you can divide the number by 1000
    and then use a standard formula. If you built the Ubuntu workstation, you can
    convert using the following command line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统中的大多数时间戳是从1970年1月1日以来的毫秒数，这是 Unix 纪元时间——以毫秒为单位，而不是秒。由于大多数工具基于秒转换 Unix 纪元，你可以将数字除以1000，然后使用标准公式。如果你构建了
    Ubuntu 工作站，你可以使用以下命令行进行转换：
- en: '![image](img/F100044u04-24-9781597496513.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-24-9781597496513.jpg)'
- en: This will output in the workstation’s time zone. You can control the time zone,
    format, and many other parameters with various switches on the command. To see
    the full possibilities, run “date--help” or “man date.”
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在工作站时区输出。你可以使用命令行上的各种开关控制时区、格式和其他许多参数。要查看所有可能性，请运行“date --help”或“man date”。
- en: 'Examining the three cached locations above, we can see the system cached locations
    from both GPS satellites and cell towers at the following times:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述三个缓存位置，我们可以看到系统从 GPS 卫星和蜂窝塔在以下时间缓存了位置信息：
- en: '1. GPS: Thu Jan 27 13:51:13 CST 2011'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1. GPS：2011年1月27日 13:51:13 CST
- en: '2. Cell: Fri Jan 28 09:56:48 CST 2011'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 蜂窝：2011年1月28日 09:56:48 CST
- en: The locations are accurate for the time recorded and thus provide excellent
    historical information on the device’s location.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的位置信息是准确的，因此提供了设备位置的极佳历史信息。
- en: 'The network state section provides additional information, including more detailed
    information on cell phone towers:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 网络状态部分提供了额外的信息，包括关于手机塔的更详细信息：
- en: '![image](img/F100044u04-25a-9781597496513.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-25a-9781597496513.jpg)'
- en: '![image](img/F100044u04-25b-9781597496513.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-25b-9781597496513.jpg)'
- en: 'One last section to point out, despite the level of technical details, is the
    memory information section, which is output for each PID:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，尽管技术细节繁多，但内存信息部分对于每个进程 ID（PID）都会输出：
- en: '![image](img/F100044u04-26-9781597496513.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-26-9781597496513.jpg)'
- en: This may be useful not only for determining which processes are running, but
    also for determining the databases they access. For instance, a case may require
    the investigator to better understand what information is updated when an e-mail
    is received. In the above listing, you can see that the e-mail application (com.htc.android.mail)
    updates not only the mail.db, but also two web-related databases attached to the
    people_db. This information can be very useful when explaining how data on an
    Android device interrelates.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅有助于确定哪些进程正在运行，还有助于确定它们访问的数据库。例如，在某些情况下，调查人员可能需要更好地了解收到电子邮件时更新了哪些信息。在上面的列表中，你可以看到电子邮件应用程序（com.htc.android.mail）不仅更新了
    mail.db，还更新了与 people_db 相关联的两个与网络相关的数据库。在解释 Android 设备上的数据如何相互关联时，这些信息可能非常有用。
- en: dumpstate
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: dumpstate
- en: 'Another debug command is dumpstate that combines portions of previous debugs
    with system information. Similar to the other commands, you run the command with
    the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个调试命令是 dumpstate，它将之前的调试部分与系统信息结合在一起。与其他命令一样，你使用以下命令运行：
- en: '![image](img/F100044u04-27-9781597496513.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-27-9781597496513.jpg)'
- en: The first section displayed on an emulator or device with adbd running as root
    is stack traces from applications. However, on the reference HTC devices, dumpstate
    returns a permission denied. Immediately following is basic information about
    the device, build, radio, network and kernel details. The remaining log contains
    the sections outlined in [Table 4.3](#T0020).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 adbd 并以 root 权限的模拟器或设备上显示的第一个部分是应用程序的堆栈跟踪。然而，在参考的 HTC 设备上，dumpstate 命令返回权限被拒绝。紧接着是关于设备、构建版本、无线电、网络和内核详情的基本信息。剩余的日志包含了[表
    4.3](#T0020) 中概述的部分。
- en: Table 4.3 Dumpstate Sections
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '| 表 4.3 Dumpstate 部分 |'
- en: '| Section | File or Command |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 部分 | 文件或命令 |'
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Stack traces | N/A |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 堆栈跟踪 | N/A |'
- en: '| Device info | N/A |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 设备信息 | N/A |'
- en: '| System | N/A |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | N/A |'
- en: '| Memory info | /proc/meminfo |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 内存信息 | /proc/meminfo |'
- en: '| Cpu info | top -n 1 -d 1 -m 30 -t |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| CPU 信息 | top -n 1 -d 1 -m 30 -t |'
- en: '| Procrank | (procrank) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Procrank | (procrank) |'
- en: '| Virtual memory stats | /proc/vmstat |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟内存统计 | /proc/vmstat |'
- en: '| Vmalloc info | /proc/vmallocinfo |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| Vmalloc 信息 | /proc/vmallocinfo |'
- en: '| Slab info | /proc/slabinfo |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| Slab 信息 | /proc/slabinfo |'
- en: '| Zoneinfo | /proc/zoneinfo |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| Zoneinfo | /proc/zoneinfo |'
- en: '| System log | logcat -v time -d ^∗:v |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 系统日志 | logcat -v time -d ^∗:v |'
- en: '| Event log | logcat -b events -v time -d ^∗:v |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 事件日志 | logcat -b events -v time -d ^∗:v |'
- en: '| Radio log | logcat -b radio -v time -d ^∗:v |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 无线电日志 | logcat -b radio -v time -d ^∗:v |'
- en: '| Network interfaces | netcfg |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 网络接口 | netcfg |'
- en: '| Network routes | /proc/net/route |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 网络路由 | /proc/net/route |'
- en: '| Arp cache | /proc/net/arp |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| Arp 缓存 | /proc/net/arp |'
- en: '| Dump Wi-Fi firmware log | su root dhdutil -i eth0 upload /data/local/tmp/wlan_crash.dump
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 转储 Wi-Fi 固件日志 | su root dhdutil -i eth0 upload /data/local/tmp/wlan_crash.dump
    |'
- en: '| System properties | N/A |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 系统属性 | N/A |'
- en: '| Kernel log | dmesg |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 内核日志 | dmesg |'
- en: '| Kernel wakelocks | /proc/wakelocks |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 内核唤醒锁 | /proc/wakelocks |'
- en: '| Kernel cpufreq | /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 内核 cpufreq | /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state |'
- en: '| Vold dump | vdc dump |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| Vold 转储 | vdc dump |'
- en: '| Secure containers | vdc asec list |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 安全容器 | vdc asec list |'
- en: '| Processes | ps -p |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 进程 | ps -p |'
- en: '| Processes and threads | ps -t -p -p |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 进程和线程 | ps -t -p -p |'
- en: '| Librank | librank |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| Librank | librank |'
- en: '| Binder failed transaction log | /proc/binder/failed_transaction_log |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| Binder 失败事务日志 | /proc/binder/failed_transaction_log |'
- en: '| Binder transaction log | /proc/binder/transaction_log |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Binder 事务日志 | /proc/binder/transaction_log |'
- en: '| Binder transactions | /proc/binder/transactions |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Binder 事务 | /proc/binder/transactions |'
- en: '| Binder stats | /proc/binder/stats |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Binder 统计 | /proc/binder/stats |'
- en: '| Binder process state | sh -c cat /proc/binder/proc/^∗ -p |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Binder 进程状态 | sh -c cat /proc/binder/proc/^∗ -p |'
- en: '| File systems and free space | df |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统和空闲空间 | df |'
- en: '| Package settings | /data/system/packages.xml: 2011-01-26 09:18:02 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 包设置 | /data/system/packages.xml: 2011-01-26 09:18:02 |'
- en: '| Package uid errors | /data/system/uiderrors.txt: 2010-11-14 22:52:26 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 包 UID 错误 | /data/system/uiderrors.txt: 2010-11-14 22:52:26 |'
- en: '| Last kmsg | /proc/last_kmsg |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 最后的 kmsg | /proc/last_kmsg |'
- en: '| Last radio log | parse_radio_log /proc/last_radio_log |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 最后的无线电日志 | parse_radio_log /proc/last_radio_log |'
- en: '| Last panic console | /data/dontpanic/apanic_console |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 最后的恐慌控制台 | /data/dontpanic/apanic_console |'
- en: '| Last panic threads | /data/dontpanic/apanic_threads |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 最后的恐慌线程 | /data/dontpanic/apanic_threads |'
- en: '| Blocked process wait channels | N/A |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 被阻塞进程的等待通道 | 不适用 |'
- en: '| Backlights | N/A |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 背光 | 不适用 |'
- en: '| Dumpsys | dumpsys |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `dumpsys` | `dumpsys` |'
- en: bugreport
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`bugreport`'
- en: 'The final debugging command further builds on the previous commands and combines
    the logcat, dumpsys, and dumpstate debug output in a single command, and displays
    on screen for the purpose of submitting a bug report. The command is run as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一个调试命令在之前命令的基础上构建，并将`logcat`、`dumpsys`和`dumpstate`的调试输出组合在一个命令中，并在屏幕上显示，以便提交错误报告。该命令如下运行： '
- en: '![image](img/F100044u04-28-9781597496513.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-28-9781597496513.jpg)'
- en: 'It starts by running dumpstate. When run against the reference HTC Incredible,
    the output was saved into a file and then a line count was performed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先运行`dumpstate`。在针对参考的HTC Incredible运行时，输出被保存到文件中，然后执行了行数统计：
- en: '![image](img/F100044u04-29-9781597496513.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-29-9781597496513.jpg)'
- en: As you can see, the report generated over 42,000 lines of debug rich in time
    stamps, app data, and system information. Parsing this data will yield useful
    information. However, if the data are processed manually, the task is daunting.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，报告生成了超过42,000行的调试信息，其中包含时间戳、应用数据以及系统信息。解析这些数据将得到有用的信息。然而，如果手动处理这些数据，任务将非常艰巨。
- en: Type of memory
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存类型
- en: As discussed in [Chapter 2](CHP002.html), Android devices have two primary types
    of memory, volatile (RAM) and nonvolatile (NAND flash) memory. Each provides a
    different insight into the device’s data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](CHP002.html)所述，Android设备有两种主要类型的内存，易失性（RAM）和非易失性（NAND闪存）内存。每种内存都能从不同角度了解设备数据。
- en: RAM
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RAM
- en: 'RAM is used by the system to load, execute, and manipulate key parts of the
    operating system, applications, or data, and is not saved on reboot. Like traditional
    computers, RAM can contain very important information which applications use to
    process data. Some examples include the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用RAM加载、执行和操作操作系统、应用程序或数据的关键部分，并在重启时不会保存。与传统计算机一样，RAM可能包含非常重要的信息，应用程序使用这些信息来处理数据。以下是一些例子：
- en: • Passwords
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: • 密码
- en: • Encryption keys
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: • 加密密钥
- en: • Usernames
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: • 用户名
- en: • App data
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: • 应用数据
- en: • Data from system processes and services
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: • 系统进程和服务的数据
- en: Recently, solutions for examining Android memory have emerged. One technique
    was documented by security researcher Thomas Cannon on his blog, which we will
    step through in detail ([Android reverse engineering, n.d.](#BIB2)).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，出现了用于检查Android内存的解决方案。其中一种技术由安全研究员Thomas Cannon在他的博客上记录，我们将详细逐步介绍（[Android
    reverse engineering, n.d.](#BIB2)）。
- en: 'Android provides a mechanism for dumping an application’s memory to a file
    by sending the app a special signal (SIGUSR1). To send the signal, you need an
    app’s PID, which you can find with the ps command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一个机制，通过向应用发送特殊信号（SIGUSR1）将应用的内存转储到文件中。要发送信号，你需要知道应用的PID，你可以使用`ps`命令找到：
- en: '![image](img/F100044u04-30-9781597496513.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-30-9781597496513.jpg)'
- en: The ps command lists all system and app processes as well as the parent process
    id, memory information, and the name. Since a typical device has many running
    processes, the above listing only displays a portion of the output.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令列出了所有系统和应用进程以及父进程ID、内存信息以及名称。由于典型设备上有许多运行中的进程，上述列表仅显示输出的一部分。'
- en: 'Next, we need to run an interactive shell on the device with root privileges
    and set /data/misc with sufficient permissions to write and then read the memory
    dump:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在设备上以root权限运行交互式shell，并设置`/data/misc`具有足够的权限来写入，然后读取内存转储：
- en: '![image](img/F100044u04-31-9781597496513.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-31-9781597496513.jpg)'
- en: Warning
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Changing folder permissions
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改文件夹权限
- en: The chmod command changes the permissions of the /data/misc folder granting
    read, write, and execute access to all user accounts on the system. This change
    is necessary for the successful memory dump. However, this is a system change
    overtly made by the forensic analyst. If such analysis is warranted, the change
    should be noted in your report and ideally the folder permissions should be restored
    to their default setting after the memory dump.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod`命令用于更改`/data/misc`文件夹的权限，授予系统上所有用户账户读、写和执行访问权限。进行此更改是为了成功进行内存转储。然而，这是法医分析师明显进行的系统更改。如果此类分析是合理的，应在报告中记录此更改，理想情况下，在内存转储后应将文件夹权限恢复到默认设置。'
- en: 'From here, we can send the signal needed to dump memory and display the contents
    of the directory:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以发送进行内存转储所需的信号，并显示目录内容：
- en: '![image](img/F100044u04-32-9781597496513.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-32-9781597496513.jpg)'
- en: 'The file heap-dump-tm1296350817-pid1294.hprof contains the memory dump and
    we can exit the interactive adb shell and pull the file to your local workstation
    for analysis:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 heap-dump-tm1296350817-pid1294.hprof 包含了内存转储，我们可以退出交互式 adb shell 并将文件拉取到本地工作站进行分析：
- en: '![image](img/F100044u04-33-9781597496513.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-33-9781597496513.jpg)'
- en: 'From there, use any memory analysis technique you have at your disposal. For
    example, you could extract ASCII strings with the command strings:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，使用你手头上的任何内存分析技术。例如，你可以使用 strings 命令提取 ASCII 字符串：
- en: '![image](img/F100044u04-34-9781597496513.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-34-9781597496513.jpg)'
- en: 'and then view the contents of the file. A quick scan of Gmail’s memory provided
    information about various encryption libraries the app referenced as well as HTTP
    traffic:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后查看文件内容。快速扫描 Gmail 的内存提供了有关应用程序引用的各种加密库以及 HTTP 流量的信息：
- en: '![image](img/F100044u04-35-9781597496513.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-35-9781597496513.jpg)'
- en: 'The Facebook app, which uses a file format called JSON to encode and transfer
    data, yielded the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 JSON 的文件格式的 Facebook 应用程序，产生了以下内容：
- en: '![image](img/F100044u04-36-9781597496513.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-36-9781597496513.jpg)'
- en: These examples were sanitized prior to inclusion in this book. However, you
    can see time stamps, profile updates, friend info, check-ins, and more.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在将以下示例包含在本书中之前，已经对其进行了清理。但是，你可以看到时间戳、资料更新、朋友信息、签到等信息。
- en: Memory analysis of an Android device can provide deep insight into the device’s
    internal structure as well as key information about the device owner. Over time,
    expect more solutions in the market to address analysis of Android memory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Android 设备的内存分析可以深入了解设备的内部结构以及有关设备主人的关键信息。随着时间的推移，预计市场上会有更多解决方案来解决 Android
    内存分析的问题。
- en: NAND Flash
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NAND 闪存
- en: Unlike RAM, NAND flash is nonvolatile and thus the data are preserved even when
    the device is without power or rebooted. The NAND flash is used to store not only
    system files but also significant portions of the user’s data.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RAM 不同，NAND 闪存是非易失性的，因此即使设备没有电源或重新启动，数据也能得到保留。NAND 闪存不仅用于存储系统文件，还用于存储用户数据的很大一部分。
- en: NAND flash memory has characteristics very different from the magnetic media
    found in modern hard drives. These properties make NAND flash ideal storage for
    mobile devices, while at the same time presenting a number of challenges for programmers
    and opportunities for forensic analysts.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 闪存具有与现代硬盘中的磁性介质截然不同的特性。这些特性使 NAND 闪存成为移动设备的理想存储选择，同时也为程序员带来了许多挑战，为法医分析师提供了机会。
- en: First, NAND flash has no mechanically moving parts like the spinning platters
    and arms found in traditional magnetic hard drives. This improves the durability
    and reduces both the size and power consumption of the device. The memory is distributed
    as one or multiple chips, which often integrate both NAND flash and RAM (MCP,
    see [Chapter 2](CHP002.html)) and are directly integrated into the circuit board
    of the device.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，NAND 闪存没有像传统磁性硬盘中的旋转盘片和机械臂那样的机械移动部件。这提高了耐用性，并减少了设备的大小和功耗。内存以一个或多个芯片的形式分布，这些芯片通常将
    NAND 闪存和 RAM（MCP，请参阅[第2章](CHP002.html)）集成在一起，并直接集成在设备的电路板上。
- en: NAND flash also has very high density and is cost effective to manufacture.
    This, of course, makes it very popular with manufacturers. One side effect of
    the manufacturing process and technology in general is that NAND flash literally
    ships with bad blocks directly from the manufacturer. The manufacturer will generally
    test the memory as part of the manufacturing process and mark bad blocks in a
    specific structure on the NAND flash, which is described in their documentation.
    Software, which then directly interacts with the NAND flash, can read the manufacturer’s
    bad block markers and will often implement a bad block table that can logically
    track the bad blocks on the system and remove them from operation. This greatly
    speeds up bad block detection and management. So while NAND flash is more physically
    durable than spinning platters, its error rate is much higher and must be accounted
    for in development and use.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存还具有非常高的密度，并且制造起来成本效益高。这当然使其深受制造商的喜爱。一般而言，制造过程和技术的一个副作用是，NAND闪存在出厂时实际上就带有坏块。制造商通常会在制造过程中测试内存，并在NAND闪存上的特定结构中标记坏块，这在他们的文档中有描述。直接与NAND闪存交互的软件可以读取制造商的坏块标记，并常常实现一个坏块表，该表可以在系统上逻辑跟踪坏块，并将其从运行中移除。这大大加快了坏块检测和管理的速度。因此，尽管NAND闪存在物理上比旋转盘片更耐用，但其错误率要高得多，在开发和使用过程中必须考虑这一点。
- en: Another significant limitation of NAND flash is that it has a very limited write/erase
    life span before the block is no longer capable of storing data. The life span
    varies by device and is largely impacted by the amount of data stored per NAND
    flash cell, the central building block for storing the 1 or 0 bit(s). If the cell
    only stores a single bit (single-level cell or SLC) then the NAND flash is rated
    around 100k write/erase cycles for one-year data retention. However, NAND flash
    rarely uses SLC as manufacturers (and consumer) demand more data storage in similarly
    sized or smaller devices. The technology has moved to multilevel cells (MLC) where
    a cell can store two, three, or even more bits per cell. However, this not only
    complicates the manufacturing process and slows down the write/erase cycle, but
    it also significantly reduces the endurance of the device. A typical MLC NAND
    flash storing two bits per cell experiences a 10-fold reduction in endurance (measured
    as one-year data retention) with a value of approximately 10k write/erase cycles.
    As the bit density per cell increases, the endurance continues to drop, which
    obviously must be addressed by the controlling device.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存的另一个重要限制是，在块(block)无法再存储数据之前，其写入/擦除的生命周期非常有限。这个生命周期因设备而异，在很大程度上受到每个NAND闪存单元存储的数据量影响，这是存储1或0位(bit)的核心构建块。如果单元仅存储单个位（单层单元或SLC），则NAND闪存的评率为大约10万次写入/擦除周期，数据保持一年。然而，由于制造商（及消费者）要求在相似大小或更小的设备中存储更多的数据，NAND闪存很少使用SLC。该技术已经发展到多层单元（MLC），在这种单元中，每个单元可以存储两个、三个甚至更多的位。然而，这不仅使制造过程复杂化，减缓了写入/擦除周期，还显著降低了设备的耐用性。一个典型的存储每个单元两个位的MLC
    NAND闪存在耐久性（以一年数据保持期限衡量）上降低了10倍，大约为1万次写入/擦除周期。随着每个单元的位密度增加，耐久性继续下降，这显然必须由控制设备来解决。
- en: Unlike RAM and NOR flash which is also flash memory and typically used in systems
    such as a computer’s Basic Input Output System or BIOS, NAND flash cannot be accessed
    randomly. Instead, access to data is achieved via an allocation unit, called a
    page or chunk, which is typically between 512 and 2048 bytes, but generally increases
    as the overall size of NAND flash increases. Even though NAND flash does not provide
    the fast random access like RAM, access time is still quite fast because it does
    not require the mechanical platter and arm movements used in traditional spinning
    hard drives.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与RAM和NOR闪存这类通常用于计算机基本输入输出系统或BIOS的闪存不同，NAND闪存不能实现随机访问。相反，数据访问是通过一个分配单元来实现的，这个单元被称为页(page)或块(chunk)，通常大小在512到2048字节之间，但随着NAND闪存整体大小的增加，这个数值通常会增大。尽管NAND闪存不能像RAM那样提供快速随机访问，但其访问时间仍然相当快，因为它不需要像传统旋转硬盘那样使用机械盘片和磁臂移动。
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Page versus chunk
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页(page)与块(chunk)的区别
- en: Throughout this book, we will use the word page and chunk synonymously to refer
    to the low-level data allocation unit referenced in NAND flash. While the allocation
    unit is usually referred to as a page, the YAFFS2 file system, which is a key
    component of Android, generally refers to the allocation unit as a chunk.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将把“页”和“块”同义地使用，以指代NAND闪存中提到的低级数据分配单元。虽然分配单元通常被称为页，但作为Android关键组件的YAFFS2文件系统通常将分配单元称为块。
- en: The chunks are then organized into a larger logical unit called a block, which
    is typically much larger than a traditional 512B hard drive sector. In most Android
    devices, the NAND flash blocks contain 64 chunks of data and each chunk is 2048
    bytes. Taking 64 × 2 KB yields a block size of 128 KB. Of course, this can and
    will change over time and is controlled by the NAND flash manufacturers. When
    a block is allocated for writing, the chunks inside the block are written sequentially.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些数据块被组织成一个更大的逻辑单元，称为块，它通常比传统的512B硬盘扇区大得多。在大多数Android设备中，NAND闪存块包含64个数据块，每个块2048字节。64
    × 2 KB的块大小为128 KB。当然，随着时间的推移，这可能会发生变化，由NAND闪存制造商控制。当一个块被分配用于写入时，块内的数据块会按顺序写入。
- en: 'Another very important characteristic of NAND flash is the operations available
    for reading and writing:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存的另一个非常重要的特性是可用于读取和写入的操作：
- en: • Read (page)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: • 读取（页）
- en: • Write (page)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: • 写入（页）
- en: • Erase (block)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: • 擦除（块）
- en: While individual chunks can be read or written, the erase operation only functions
    at the block level. When a block is erased, the entire block is written over with
    1’s or 0xFF (hex).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以读取或写入单个数据块，但擦除操作只能在块级别进行。当一个块被擦除时，整个块会用1或0xFF（十六进制）覆盖。
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: NAND flash erase operation
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NAND闪存的擦除操作
- en: '*The erase operation is the only mechanism by which a 0 can be changed to a
    1 in NAND flash.* This point is worth belaboring. In a traditional hard drive,
    if a value is changed from a 0 to a 1 (or vice versa), the program would simply
    seek to the value on the hard drive and apply the appropriate voltage to change
    and store the new value. However, the fundamental architecture of NAND flash provides
    only one mechanism to change a 0 to a 1 and that is via the erase function that
    is applied at the block level, not an individual page level. For this reason,
    a page can only be written once, and if the value of the page needs to change,
    the entire block must be erased and then the page can be written.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*擦除操作是NAND闪存中将0更改为1的唯一机制。*这一点值得强调。在传统硬盘中，如果一个值从0更改为1（或反之），程序只需在硬盘上找到该值并施加适当的电压以更改并存储新值。然而，NAND闪存的基本架构只提供了一个机制来将0更改为1，即通过在块级别应用的擦除功能，而不是单个页级别。因此，一个页只能写入一次，如果需要更改页的值，则必须擦除整个块，然后才能写入页。'
- en: 'Here is a specific example using a single byte for simplicity: Let’s say this
    particular byte holds the decimal value 179 and we want to add 39 for a total
    value of 218\. For those unfamiliar with converting numbers between base10, hex
    (base16), and binary (base2), the built-in calculator programs in Windows, Mac
    OS X, and Ubuntu Linux provide a programmer mode that will perform the conversions.
    For the numbers above, we have the conversions between numbering systems shown
    in [Table 4.4](#T0025).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里举一个使用单个字节以简化说明的例子：假设这个特定的字节存储了十进制值179，我们想要加上39得到总值为218。对于那些不熟悉在十进制（base10）、十六进制（base16）和二进制（base2）之间转换数字的人来说，Windows、Mac
    OS X 和 Ubuntu Linux 的内置计算器程序提供了程序员模式，可以执行这些转换。对于上面的数字，我们在不同数制之间的转换如[表4.4](#T0025)所示。
- en: Table 4.4 Decimal, Hex, and Binary Representation of Integers
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4 整数的十进制、十六进制和二进制表示
- en: '| Decimal (base10) | Hex (base16) | Binary (base2) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 十进制（base10） | 十六进制（base16） | 二进制（base2） |'
- en: '| --- | --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 179 | 0xB3 | 1011 0011 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 179 | 0xB3 | 1011 0011 |'
- en: '| 218 | 0xDA | 1101 1010 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 218 | 0xDA | 1101 1010 |'
- en: 'So the value 179 contains three 0’s and two of them need to change to a 1 to
    present our new value of 218\. However, NAND flash cannot make that change without
    erasing the entire block. So, if this single byte was attempted without the erase,
    the result would be 146, not 218\. Here is how this happened:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，值179包含三个0，其中两个需要改变为1以表示我们新的值218。然而，NAND闪存在没有擦除整个块的情况下无法进行这种改变。所以，如果这个单个字节在没有擦除的情况下尝试，结果将是146，而不是218。以下是这种情况发生的原因：
- en: '![image](img/F100044u04-37-9781597496513.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-37-9781597496513.jpg)'
- en: As the byte did not contain all 1’s (0xFF), the only portions of the write cycle
    that succeeded were 1’s either remaining a 1 or changing to a 0\. Anytime the
    write function encountered a 0 and was requested to change to a 1, it would fail
    and simply retain the 0 value. The resulting byte was 0x92 or 146 base10—clearly
    not the value intended. Another way to describe the write function is that it
    only changes the charged 1 values to a 0 where requested, the equivalent of the
    “logical and” of the two values.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字节并不全是1（0xFF），写入周期中唯一成功的是1保持为1或变为0的部分。每当写入功能遇到0并请求变为1时，它就会失败并保持0值。结果字节为0x92或10进制的146——明显不是预期的值。另一种描述写入功能的方式是，它只将带电的1值按需改为0，这相当于两个值的“逻辑与”。
- en: In summary, a chunk can only be written once, and if it needs to be re-written,
    the entire block must first be erased.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一个数据块只能写入一次，如果需要重写，必须先擦除整个块。
- en: As you can tell, NAND flash imposes various restrictions and limitations and
    thus developers and file systems must be flash aware to effectively work within
    the constraints. Unlike traditional hard drives that ship with firmware to manage
    the device (including bad block), the NAND flash used in Android devices does
    not ship with a controller. All management of the memory must be implemented in
    software interfacing with the NAND flash. Two important techniques deployed are
    error-correcting code (ECC) and wear-leveling. Both have significant implications
    for forensics and data recovery.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，NAND闪存有其各种限制，因此开发人员和文件系统必须了解闪存特性，才能在限制内有效工作。与带有固件来管理设备（包括坏块）的传统硬盘不同，Android设备中使用的NAND闪存没有配备控制器。所有内存的管理都必须在软件层面实现，并与NAND闪存进行接口。部署的两个重要技术是错误校正码（ECC）和磨损均衡。这两者对法医分析和数据恢复都有重大影响。
- en: First, ECC is a technique where an algorithm is used to detect data errors on
    read or write operations and correct some errors on the fly. Since NAND flash
    degrades over time through usage, the system must be able to detect when a page
    or block is going bad and recover the data stored there. After a number of errors
    or failed operations is exceeded (typically three failed operations), the page
    or block will be marked bad and added to the bad block table.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，ECC是一种在读写操作中检测数据错误并即时纠正某些错误的算法。由于NAND闪存在使用过程中会逐渐退化，系统必须能够检测到页面或块何时出现问题并恢复存储在那里的数据。当错误次数或失败操作超过一定数量（通常是三次失败操作）时，页面或块将被标记为坏块，并添加到坏块表中。
- en: The second important algorithm used to effectively manage NAND flash on Android
    is the wear-leveling code that spreads the writing of data across the entire NAND
    flash to avoid overutilization of a single area, thus wearing those blocks out
    more quickly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上有效管理NAND闪存的第二个重要算法是磨损均衡代码，它将数据的写入分散到整个NAND闪存中，以避免过度使用单一区域，从而更快地磨损这些块。
- en: Many hardware devices that use NAND flash, such as removable USB thumb drivers
    and solid state drives (SSD), have controller logic bundled with the device, which
    provides the functions described above including bad block management, wear-leveling,
    and error-correcting code. However, Android devices were designed to integrate
    the NAND flash components directly, and thus a software management layer was needed
    to provide these important functions. The layer selected to manage the NAND flash
    was the Memory Technology Device (MTD) system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用NAND闪存的硬件设备，如可移动的USB闪存驱动器和固态硬盘（SSD），都带有与设备捆绑的控制器逻辑，提供上述功能，包括坏块管理、磨损均衡和错误校正码。然而，Android设备设计为直接集成NAND闪存组件，因此需要一个软件管理层来提供这些重要功能。选定的管理NAND闪存的层是Memory
    Technology Device（MTD）系统。
- en: MTD was developed to address the need of NAND flash and similar devices due
    to their unique characteristics. Prior to MTD, Linux supported primarily character
    devices and block devices. Neither device type addresses the unique properties
    of the newly developed memory devices. Additionally, while NAND flash was not
    strictly a block device (like traditional hard drives), exposure of block device
    characteristics to developers aided in development and support. By leveraging
    MTD, Android now had the necessary Flash Transition Layer (FTL) needed to effectively
    interact with the NAND flash. By taking this approach, Android did not lock manufacturers
    into using a small subset of NAND flash providers and associated controllers.
    Instead, they are free to use any NAND flash available and then “simply” integrate
    with MTD, which supports a wide range of NAND flash.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: MTD是为了满足NAND闪存及其类似设备的需要而开发的。在MTD之前，Linux主要支持字符设备和块设备。这两种设备类型都没有解决新型存储设备独特的特性。此外，虽然NAND闪存严格来说不是块设备（像传统硬盘那样），但向开发者暴露块设备特性有助于开发和支持。通过利用MTD，Android现在有了与NAND闪存有效交互所需的Flash
    Transition Layer（FTL）。通过这种方式，Android没有将制造商限制在只能使用少数NAND闪存供应商和相关控制器。相反，他们可以自由使用任何可用的NAND闪存，然后“简单”地与支持广泛NAND闪存的MTD集成。
- en: In Android, the MTD provides not only the block interface to the NAND flash
    but also the ECC, wear-leveling, and other critical functions. The ECC and other
    chunk metadata are stored in a reserved area called the out of band (OOB) or spare
    area. The OOB is located directly after each chunk on the NAND flash. While the
    chunk, block, and OOB layout is configurable, most Android devices to date have
    a 128 KB block consisting of 64 2,048 byte (2k) chunks each with a 64 byte OOB
    as shown in [Fig. 4.1](#F0010).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，MTD不仅为NAND闪存提供了块接口，还提供了ECC、磨损均衡和其他关键功能。ECC和其他块元数据存储在一个被称为OOB（带外）或备用区域的保留空间中。OOB位于NAND闪存上每个块的后面。虽然块、块和OOB布局是可配置的，但到目前为止，大多数Android设备都有一个128 KB的块，包含64个每块2048字节（2k）的块，每个块都有一个64字节的OOB，如图[4.1](#F0010)所示。
- en: '![image](img/F100044f04-01-9781597496513.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044f04-01-9781597496513.jpg)'
- en: FIGURE 4.1 Block (128 KB = 64 × 2k chunks + OOB).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 块（128 KB = 64 × 2k块 + OOB）。
- en: The OOB not only stores information managed by MTD, but can also store metadata
    critical to the file system, provided the file system is NAND flash aware. While
    the system presents the block as 128 KB, when you add in the 64 OOB, each 64 bytes
    in size, there is an additional 4096 bytes (4 KB) bringing the total bytes used
    on the NAND flash to 132 KB.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: OOB不仅存储由MTD管理的相关信息，还可以存储对文件系统至关重要的元数据，前提是文件系统要能识别NAND闪存。虽然系统将块呈现为128 KB，但加上64个大小为64字节的OOB后，额外的4096字节（4 KB）使得NAND闪存上总共使用的字节数达到了132 KB。
- en: 'On Android devices, you can determine the MTD partitions by viewing the /proc/mtd
    file. On our reference HTC Incredible, we have the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备上，您可以通过查看/proc/mtd文件来确定MTD分区。在我们的参考设备HTC Incredible上，我们有以下分区：
- en: '![image](img/F100044u04-38-9781597496513.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-38-9781597496513.jpg)'
- en: There are seven MTD partitions and the following section will examine where
    they are mounted, and provide a high-level overview of the directories and files
    found. In the previous listing, the size and erasesize are both hex values that
    provide important MTD/NAND flash properties. The erasesize specifies the size
    of each block which is 0x20000 or 131,072 bytes or 128 KB (128 × 1024) in decimal.
    This is consistent with the block figure, specifically 64 pages, each 2048 (2 KB)
    in size. The size column specifies the overall size of that partition. So, in
    this instance, we have the MTD partitions as shown in [Table 4.5](#T0030).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个MTD分区，下一节将检查它们的挂载位置，并提供一个关于找到的目录和文件的高级概述。在之前的列表中，size和erasesize都是十六进制值，提供了重要的MTD/NAND闪存属性。erasesize指定了每个块的大小，即0x20000或131,072字节或128 KB（128×1024）的十进制数。这与块图一致，特别是64页，每页2048（2 KB）的大小。size列指定了该分区的整体大小。因此，在这个实例中，我们有如[表4.5](#T0030)所示的MTD分区。
- en: Table 4.5 MTD Partitions Size Conversions
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5 MTD分区大小转换
- en: '![Image](img/T100044tabT0030.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0030.jpg)'
- en: 'The values from [Table 4.5](#T0030) can also be verified using the df (disk
    free) command that provides a listing of mounted file systems and their total,
    used, and available space. Following is the df data for /system:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4.5](#T0030)中的值也可以使用df（磁盘空闲）命令进行验证，该命令提供了已挂载文件系统及其总、已使用和可用空间的列表。以下是/system的df数据：'
- en: '![image](img/F100044u04-39-9781597496513.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-39-9781597496513.jpg)'
- en: As you can tell, the size found in /proc/mtd is consistent in both our conversions
    and as displayed by the df command.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，/proc/mtd 中找到的大小在我们的转换和 df 命令显示中是一致的。
- en: Now that we have established a fundamental understanding of NAND flash and MTD
    for Android, we will examine the various file systems used by Android.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对 Android 中的 NAND 闪存和 MTD 有了基本的了解，我们将研究 Android 使用的各种文件系统。
- en: File systems
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: Like most Linux systems, there are several file systems in use on Android, many
    of which are used to boot and run the system. While we will touch on several of
    the file systems, the primary focus is on partitions where user data are stored,
    in particular the EXT, FAT32, and YAFFS2 file systems.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Linux 系统一样，Android 中也使用了多个文件系统，其中许多用于启动和运行系统。虽然我们会提到多个文件系统，但主要关注的是存储用户数据的分区，特别是
    EXT、FAT32 和 YAFFS2 文件系统。
- en: 'To determine what file systems a Linux kernel (and thus Android) supports,
    you can examine the contents of the file /proc/filesytem. On our reference HTC
    Incredible, it contains the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定 Linux 内核（以及因此的 Android）支持哪些文件系统，你可以查看文件 /proc/filesytem 的内容。在我们参考的 HTC Incredible
    上，它包含以下内容：
- en: '![image](img/F100044u04-40-9781597496513.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-40-9781597496513.jpg)'
- en: 'Of the 18 file systems supported by the HTC Incredible, only five are backed
    by a physical device such as NAND flash or the SD card. The remaining file systems
    have the “nodev” property, which means that they are essentially virtual file
    systems that are not written to any physical device. Furthermore, only six of
    the nodev file systems are actually used on the device:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTC Incredible 支持的 18 个文件系统中，只有五个是由物理设备（如 NAND 闪存或 SD 卡）支持的。其余的文件系统具有“nodev”属性，这意味着它们本质上是虚拟文件系统，不会写入任何物理设备。此外，实际上在设备上只使用了六个
    nodev 文件系统：
- en: 1. rootfs
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 1. rootfs
- en: 2. tmpfs
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 2. tmpfs
- en: 3. cgroup
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 3. cgroup
- en: 4. proc
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 4. proc
- en: 5. sysfs
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 5. sysfs
- en: 6. devpts
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 6. devpts
- en: 'And three of the device-backed file systems are used:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个由设备支持的文件系统被使用：
- en: 1. ext3
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 1. ext3
- en: 2. yaffs2
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 2. yaffs2
- en: 3. vfat
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 3. vfat
- en: The following sections provide a brief overview of most file systems, and an
    in-depth analysis of YAFFS2, where significant user data are stored.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分提供了大多数文件系统的简要概述，以及对存储大量用户数据的 YAFFS2 的深入分析。
- en: rootfs, devpts, sysfs, and cgroup File Systems
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rootfs、devpts、sysfs 和 cgroup 文件系统
- en: Many file systems in Linux are used to boot, operate, or manage the system and
    often will not contain information useful in a forensic investigation. However,
    security engineers and researchers may closely examine these file systems, and
    the kernel’s inner-workings, in an attempt to identify security holes and other
    weaknesses. We will quickly highlight four of the more infrastructure-related
    file systems found in Android.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的许多文件系统用于启动、操作或管理系统，通常不会包含在取证调查中有用的信息。然而，安全工程师和研究人员可能会仔细检查这些文件系统以及内核的内部工作，试图找出安全漏洞和其他弱点。我们将快速强调在
    Android 中发现的四个与基础设施相关的文件系统。
- en: First, rootfs is where the kernel mounts the root file system (the top of the
    directory tree, noted with a forward slash) at startup. In order for the kernel
    to complete the boot process, it needs access to core files and libraries, thus
    the need to mount the root file system. As the kernel finalizes the boot process,
    subsequent file systems are mounted as directories off the root file system. For
    example (and more on this later in the chapter), the root file system would be
    mounted at / and contain key files. Then a more complete system directory would
    be mounted at /system. You can see the root file system and directories by running
    the “ls -l” command from a shell or typing “mount” to see which file systems are
    mounted and in what directory of the root file system.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，rootfs 是内核在启动时挂载根文件系统（目录树的顶部，用正斜杠表示）的位置。为了让内核完成启动过程，它需要访问核心文件和库，因此需要挂载根文件系统。随着内核完成启动过程，随后的文件系统作为根文件系统下的目录被挂载。例如（本章后面会详细介绍），根文件系统会被挂载在
    / 并包含关键文件。然后一个更完整的系统目录会被挂载在 /system。你可以通过从 shell 运行“ls -l”命令或输入“mount”来查看已挂载的文件系统以及它们在根文件系统中的目录。
- en: 'The devpts file system is used to provide simulated terminal sessions on an
    Android device, similar to connecting to a traditional Unix server using telnet
    or ssh. Each time a virtual terminal connects, a new node under /dev/pts is created.
    For example, if you have a single adb shell connection to an Android device, /dev/pts
    would show the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: devpts文件系统用于在Android设备上提供模拟的终端会话，类似于使用telnet或ssh连接到传统的Unix服务器。每次虚拟终端连接时，在/dev/pts下都会创建一个新节点。例如，如果你有一个adb
    shell连接到Android设备，/dev/pts将显示以下内容：
- en: '![image](img/F100044u04-41-9781597496513.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-41-9781597496513.jpg)'
- en: 'However, in the next example, there are two adb shell connections and one terminal
    app connection from an app installed on the device:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下一个示例中，有两个adb shell连接和一个来自设备上安装的应用程序的终端应用连接：
- en: '![image](img/F100044u04-42-9781597496513.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-42-9781597496513.jpg)'
- en: As you can see, the original /dev/pts/0 connection exists. However, two additional
    connections are now present and the one from the terminal app is run under the
    app’s unique user id (app_105).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原始的/dev/pts/0连接存在。但是现在有两个额外的连接，并且来自终端应用的连接是在应用独特的用户id（app_105）下运行的。
- en: 'Sysfs is another virtual file system that contains configuration and control
    files for the device. On the HTC Incredible, the following top-level directories
    exist:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Sysfs是另一个包含设备配置和控制文件的虚拟文件系统。在HTC Incredible上，存在以下顶级目录：
- en: '![image](img/F100044u04-43-9781597496513.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-43-9781597496513.jpg)'
- en: 'For curiosity’s sake, you can do an adb pull on /sys to your forensic workstation
    as the files can be read by any user. Execute the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，你可以将/sys目录下的文件通过adb pull命令拉取到你的取证工作站上，因为任何用户都可以读取这些文件。执行以下命令：
- en: '![image](img/F100044u04-44-9781597496513.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-44-9781597496513.jpg)'
- en: 'As you can see, a large number of files were pulled, and you can now use the
    full suite of Linux tools to examine the data. While the forensic value of this
    information requires additional research, it clearly provides low-level information
    about the device that can assist in security research. For example, if you wanted
    to learn more about the NAND device, you could examine the following directory:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大量文件被拉取，你现在可以使用完整的Linux工具套件来检查数据。尽管这些信息的取证价值需要进一步研究，但它清楚地提供了关于设备的低级信息，有助于安全研究。例如，如果你想了解更多关于NAND设备的信息，你可以检查以下目录：
- en: '![image](img/F100044u04-45-9781597496513.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-45-9781597496513.jpg)'
- en: 'And then each file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是每个文件：
- en: '![image](img/F100044u04-46-9781597496513.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-46-9781597496513.jpg)'
- en: 'Understanding the NAND device in detail is clearly an important step in forensic
    and security analysis. With nearly 3000 files, there is considerable data to examine.
    Here is a quick way to look at the file names, paths, and sizes that will allow
    you to then easily examine relevant files (try running two terminal sessions and
    listing the files in one terminal and use copy/paste to “cat” the file contents
    in the other terminal):'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽了解NAND设备显然是进行取证和安全分析的重要步骤。将近3000个文件，有大量数据需要检查。以下是一种快速查看文件名、路径和大小的方法，这将使你能够轻松检查相关文件（尝试在两个终端会话中列出文件，在一个终端中使用复制/粘贴来“cat”文件内容）：
- en: '![image](img/F100044u04-47a-9781597496513.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-47a-9781597496513.jpg)'
- en: '![image](img/F100044u04-47b-9781597496513.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-47b-9781597496513.jpg)'
- en: Tip
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Additional sysfs analysis
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加sysfs分析
- en: Beyond manually examining the sysfs file system, there are detailed resources
    on the Internet which provide additional background. One such resource is a paper
    by Patrick Mochel providing a helpful background ([The sysfs filesystem, n.d.](#BIB7)).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动检查sysfs文件系统外，互联网上还有详细资源提供了额外的背景信息。这样一个资源是Patrick Mochel的一篇论文，提供了有用的背景信息（[The
    sysfs filesystem, n.d.](#BIB7)）。
- en: 'The final virtual file system is called cgroups and is used to track and aggregate
    tasks in the Linux file system. On the HTC Incredible, two cgroup file systems
    are created: one at /dev/cpuctl and the other at /acct. While additional analysis
    may yield results, the accounting data generally do not prove useful in forensic
    analysis.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个虚拟文件系统被称为cgroups，用于跟踪和汇总Linux文件系统中的任务。在HTC Incredible上，创建了两个cgroup文件系统：一个在/dev/cpuctl，另一个在/acct。尽管可能通过进一步分析得到结果，但会计数据在取证分析中通常并不证明是有用的。
- en: proc
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: proc
- en: The proc file system provides detailed information about kernel, processes,
    and configuration parameters in a structured manner under the /proc directory.
    Some of the files can be examined by the shell user. However, many files prevent
    access unless you have root privileges. As before, one method for exploring the
    proc file system is to pull the files from the Android device onto your forensic
    workstation. It will take some time and could hang on certain files causing an
    incomplete copy.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: proc 文件系统在 /proc 目录下以结构化的方式提供了关于内核、进程和配置参数的详细信息。一些文件可以通过 shell 用户检查。然而，许多文件在你拥有
    root 权限之前阻止访问。如前所述，探索 proc 文件系统的一种方法是将文件从 Android 设备拉到你的法医工作站上。这需要一些时间，并且在某些文件上可能会挂起，导致复制不完整。
- en: '![image](img/F100044u04-48-9781597496513.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-48-9781597496513.jpg)'
- en: 'On the HTC Incredible, the above process hung when trying to copy process 76
    and had to be canceled with a Ctrl-C:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTC Incredible 上，上述过程在尝试复制进程 76 时挂起，不得不使用 Ctrl-C 取消：
- en: '![image](img/F100044u04-49-9781597496513.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-49-9781597496513.jpg)'
- en: 'Before canceling, we successfully pulled 25 MB of data and nearly 6000 files.
    As with the sysfs examination, you can manually examine the data using the find
    command to locate and list files:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在取消之前，我们成功提取了 25 MB 的数据和近 6000 个文件。与 sysfs 检查一样，你可以使用 find 命令手动检查数据，以定位并列出文件：
- en: '![image](img/F100044u04-50-9781597496513.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-50-9781597496513.jpg)'
- en: 'Alternatively, you can examine some files in /proc directly from the adb shell
    as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以直接从 adb shell 检查 /proc 中的某些文件，如下所示：
- en: '![image](img/F100044u04-51-9781597496513.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-51-9781597496513.jpg)'
- en: Valuable information about the device can be found in the proc file system.
    Examiners can audit these files and should start with files in the /proc directory
    instead of the subdirectories.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的宝贵信息可以在 proc 文件系统中找到。检查员可以审计这些文件，并且应该从 /proc 目录中的文件开始，而不是子目录。
- en: tmpfs
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tmpfs
- en: tmpfs is a file system that stores all files in virtual memory backed by RAM
    and, if present, the swap or cache file for the device. Most Android devices at
    this time do not have swap space. However, some aftermarket firmware enables this
    feature. The advantage of tmpfs is that by using RAM, the storage is very fast
    and also nonpermanent and hence not saved on reboot.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: tmpfs 是一个文件系统，它将所有文件存储在由 RAM 支持的虚拟内存中，如果有的话，还包括设备的交换或缓存文件。目前大多数 Android 设备没有交换空间。然而，一些售后固件启用了这个功能。tmpfs
    的优点是，通过使用 RAM，存储速度非常快，而且是非永久的，因此在重启时不会被保存。
- en: Of course, for forensic examiners, this poses a challenge. If important data
    are located on a tmpfs mount point, it must be collected before the device is
    rebooted or loses power. It also presents a unique opportunity because the tmpfs
    is often readable by the shell user and forensic programs can be copied and executed
    in tmpfs without modifying the NAND flash or SD card. This may allow an examiner
    to acquire forensic data from an Android device without modifying the NAND flash
    or SD card in any way.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于法医检查员来说，这是一个挑战。如果重要数据位于 tmpfs 挂载点上，必须在设备重启或断电之前收集这些数据。这也提供了一个独特的机会，因为 tmpfs
    通常可以被 shell 用户读取，并且法医程序可以复制并在 tmpfs 中执行，而无需修改 NAND 闪存或 SD 卡。这可能允许检查员在完全不修改 NAND
    闪存或 SD 卡的情况下从 Android 设备获取法医数据。
- en: Warning
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Investigating tmpfs
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调查 tmpfs
- en: If your primary interest is in memory analysis of the device, making changes
    to tmpfs is not advised unless you first have a forensic copy of the parts of
    memory you are interested in.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对设备内存分析的主要兴趣在于，除非你首先拥有你感兴趣的内存部分的法医级副本，否则不建议对 tmpfs 进行更改。
- en: 'On the HTC Incredible, the standard installation has four tmpfs mount points:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTC Incredible 上，标准安装有四个 tmpfs 挂载点：
- en: • /dev
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: • /dev
- en: • /mnt/asec
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: • /mnt/asec
- en: • /app-cache
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: • /app-cache
- en: • /mnt/sdcard/.android_secure
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: • /mnt/sdcard/.android_secure
- en: The /dev directory contains device files that allow the kernel to read and write
    to attached devices such as NAND flash, SD card, character devices, and more.
    The /mnt/asec and /mnt/sdcard/.android_secure directories are a relatively new
    addition to Android and allow apps to be stored on the SD card instead of /data/data,
    which provides more storage.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: /dev 目录包含设备文件，允许内核读取和写入连接的设备，如 NAND 闪存、SD 卡、字符设备等。/mnt/asec 和 /mnt/sdcard/.android_secure
    目录是 Android 的新增功能，允许应用存储在 SD 卡上，而不是 /data/data，从而提供更多存储空间。
- en: Interestingly, the /app-cache is also a new addition and appears to provide
    tmpfs space, which apps can use. On the HTC Incredible, the Web Browser (com.andrew.browser)
    created a directory in /app-cache and stores cache files from web browsing.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，/app-cache也是一个新增加的项，似乎提供了tmpfs空间，应用程序可以使用。在HTC Incredible上，网页浏览器（com.andrew.browser）在/app-cache中创建了一个目录，并存储了网页浏览的缓存文件。
- en: '![image](img/F100044u04-52-9781597496513.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-52-9781597496513.jpg)'
- en: From the first listing, we can see that the app-cache directory has read, write,
    and browse permissions set for all users. In addition, the final “t” in the permissions
    “rwxrwxrwt” indicates that only root or the owner of the directory can delete
    or rename the directory.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个列表中，我们可以看到app-cache目录对所有用户设置了读、写和浏览权限。此外，权限“rwxrwxrwt”中的最后一个“t”表示只有root或目录所有者才能删除或重命名目录。
- en: The second listing shows the directory’s inside app-cache, which only has com.android.browser.
    However, as we dig deeper into the directory, we discover the directory and files
    we are most interested in only allow the app itself (com.android.browser, user
    id of app_12) or root access to the files.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个列表显示了app-cache内部的目录，其中只有com.android.browser。但是，当我们深入到目录中时，我们发现我们最感兴趣的目录和文件只允许应用程序本身（com.android.browser，应用程序的用户ID为app_12）或root访问文件。
- en: '![image](img/F100044u04-53-9781597496513.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-53-9781597496513.jpg)'
- en: 'As we have root access on the device, here is what the directory contained:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在设备上拥有root权限，以下是目录包含的内容：
- en: • 1.4 MB of data
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: • 1.4 MB的数据
- en: • 64 files
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: • 64个文件
- en: • 18 ASCII files (mostly CSS and JavaScript)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: • 18个ASCII文件（主要是CSS和JavaScript）
- en: • 1 empty file
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: • 1个空文件
- en: • 9 GIF files
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: • 9个GIF文件
- en: • 5 HTML files
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: • 5个HTML文件
- en: • 11 JPEG files
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: • 11个JPEG文件
- en: • 17 PNG files
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: • 17个PNG文件
- en: • 3 UTF-8 files
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: • 3个UTF-8文件
- en: '![image](img/F100044u04-54-9781597496513.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-54-9781597496513.jpg)'
- en: If you browse the webviewCache directory from your Ubuntu workstation, you can
    easily preview images and other files ([Fig. 4.2](#F0015)).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从Ubuntu工作站浏览webviewCache目录，你可以轻松预览图像和其他文件（[图4.2](#F0015)）。
- en: '![image](img/F100044f04-02-9781597496513.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044f04-02-9781597496513.jpg)'
- en: FIGURE 4.2 Browser webviewCache from Ubuntu workstation.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 从Ubuntu工作站浏览的浏览器webviewCache。
- en: The /app-cache tmpfs directory contains information that would be important
    in a forensic investigation. This underscores the growing need to educate front-line
    responders to ensure that devices are properly handled to maximize the forensic
    investigation’s effectiveness.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: /app-cache tmpfs目录包含的信息在法医调查中非常重要。这强调了教育前线响应人员以确保设备得到妥善处理，以最大化法医调查有效性的日益需求。
- en: Extended File System (EXT)
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展文件系统（EXT）
- en: 'The extended file system (EXT) is the de facto file system for Linux developed
    specifically for the operating system. As you already know, Linux supports a large
    number of file systems. However, the default is EXT. Since the original version
    of EXT was developed in 1992, there have been three additional releases: EXT2,
    EXT3, and EXT4.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展文件系统（EXT）是Linux的默认文件系统，专门为操作系统开发。正如你已经知道的，Linux支持大量的文件系统。然而，默认的是EXT。自从1992年开发出EXT的原始版本以来，已经推出了三个额外的版本：EXT2、EXT3和EXT4。
- en: Although EXT has been integral to most laptop, desktop, and server Linux distributions,
    it was not found in early Android devices. In 2010, however, EXT began to show
    up in devices, and on December 9, 2010, Google announced in their Android Developer
    blog that an increasing number of Android devices were going to move from YAFFS
    to the EXT ([Android developers blog, n.d.](#BIB1)). The move from YAFFS to EXT
    seems to be driven by several factors that were discussed online ([Way, n.d.](#BIB8)),
    including
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EXT已经集成到大多数笔记本电脑、台式机和服务器Linux发行版中，但在早期的Android设备中并未发现EXT。然而，到了2010年，EXT开始出现在设备中，2010年12月9日，谷歌在他们的Android开发者博客上宣布，越来越多的Android设备将从YAFFS转移到EXT（[Android开发者博客，未标明日期](#BIB1)）。从YAFFS转向EXT似乎是由在线讨论的几个因素推动的（[Way，未标明日期](#BIB8)），包括
- en: • More Android devices are moving from raw NAND flash to regular block device
    (eMMC)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: • 越来越多的Android设备从原始NAND闪存转向常规块设备（eMMC）
- en: • EXT4 is a standard Linux file system that supports full Unix permissions and
    semantics
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: • EXT4是一个标准的Linux文件系统，支持完整的Unix权限和语义
- en: • EXT4 is stable and offers high performance
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: • EXT4稳定且性能高
- en: • YAFFS is single threaded, which would experience bottlenecks on forthcoming
    dual-core systems
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: • YAFFS是单线程的，在即将到来的双核系统上会遇到瓶颈
- en: 'The first Android device to use EXT4 is the Google Nexus S, and it is expected
    that many tablet devices running Android’s Honeycomb release will also use this
    new file system. As only one Android device currently uses EXT4, many changes
    are expected over time. Currently, the Nexus uses EXT4 in the following mount
    points:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款使用EXT4的Android设备是Google Nexus S，预计许多运行Android Honeycomb版本的平板设备也将使用这个新的文件系统。目前，Nexus在以下挂载点使用EXT4：
- en: • System image (read-only, /system)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: • 系统镜像（只读，/system）
- en: • Local user data (read–write, /data/data)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: • 本地用户数据（读写，/data/data）
- en: • Cache partitions (read–write, /cache and possible others)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: • 缓存分区（读写，/cache及其他可能）
- en: From a forensics standpoint, EXT4 is simply another file system that examiners
    need to understand and forensic tools need to support. Of course, most forensic
    tools do not fully (or even nominally) support EXT4 so this presents a bit of
    a problem. File carving techniques do work and it is expected that more forensic
    software will begin to support the file system over time.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证的角度来看，EXT4只是一个需要取证工具理解和支持的文件系统。当然，目前大多数取证工具并不完全（甚至只是名义上）支持EXT4，这确实带来了一些问题。文件雕刻技术是有效的，预计随着时间的推移，将会有更多的取证软件开始支持这个文件系统。
- en: FAT32/VFAT
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAT32/VFAT
- en: Android devices often have one or more Microsoft FAT32 partitions, generally
    on the SD card and eMMC. The reason for leveraging this venerable file system
    is not due to superior design but is due to sheer compatibility with other operating
    systems. Microsoft’s FAT32 file system was widely supported in most operating
    systems including Mac OS X, all Windows versions (obviously), Linux, and more.
    This means that Android data stored on the FAT32 partitions can be easily read,
    modified, or even deleted on other file systems.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备通常具有一个或多个Microsoft FAT32分区，通常位于SD卡和eMMC上。采用这种久经考验的文件系统并非因为其设计优越，而是因为其与其他操作系统的高度兼容性。FAT32文件系统在大多数操作系统中都得到广泛支持，包括Mac
    OS X、所有Windows版本（显然）、Linux等等。这意味着，存储在FAT32分区上的Android数据可以轻松地在其他文件系统上被读取、修改甚至删除。
- en: 'In Linux, the file system driver for a FAT32 partition is called VFAT, not
    to be confused with Microsoft’s earlier Virtual FAT file system that bridged the
    FAT16 and FAT32 implementation by adding, among other features, long file name
    support. On the HTC Incredible, there are three mount points that use FAT32:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，FAT32分区的文件系统驱动被称为VFAT，不要与微软早期桥接FAT16和FAT32实现的虚拟FAT文件系统混淆，后者增加了包括长文件名支持在内的其他功能。在HTC
    Incredible上，有3个使用FAT32的挂载点。
- en: • /mnt/sdcard
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: • `/mnt/sdcard`
- en: • /mnt/secure/asec
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: • `/mnt/secure/asec`
- en: • /mnt/emmc
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: • `/mnt/emmc`
- en: As you may recall from [Chapter 3](CHP003.html)’s section on USB interfaces,
    when an Android device is connected to another computer, there is an option to
    expose the devices’ USB mass storage (UMS) interfaces to enable file sharing.
    On the HTC Incredible, both the /mnt/sdcard and /mnt/emmc partitions can be presented
    to other operating systems over the USB connection as a UMS device.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[第3章](CHP003.html)关于USB接口的部分所记得的，当Android设备连接到另一台计算机时，可以选择暴露设备的USB大容量存储（UMS）接口以实现文件共享。在HTC
    Incredible上，`/mnt/sdcard`和`/mnt/emmc`分区可以通过USB连接作为UMS设备向其他操作系统呈现。
- en: The /mnt/secure/asec partition is an encrypted partition on the SD card where
    Android devices can store apps. When the ability to run apps from the SD card
    was introduced, the security engineers were understandably concerned that app
    data could easily be damaged or compromised because file permissions are not maintained
    in the VFAT/FAT32 partitions. As such, the app (.apk file) is encrypted on the
    physical device and when in use, it is decrypted and temporarily stored at /mnt/asec
    or another location specified by design.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`/mnt/secure/asec`分区是SD卡上的一个加密分区，Android设备可以在此存储应用程序。当引入了从SD卡运行应用程序的功能后，安全工程师们理所当然地担心应用程序数据可能会容易被损坏或泄露，因为VFAT/FAT32分区没有维护文件权限。因此，应用程序（.apk文件）在物理设备上被加密，在使用时会被解密并临时存储在`/mnt/asec`或其他指定位置。'
- en: As discussed previously, the removable SD card is mounted at /mnt/sdcard and
    generally contains photos, videos, thumbnails, downloaded files, text to speech
    temporary files, and Google Maps Navigation data as well as data from many Android
    Market applications. The newer /mnt/emmc is a FAT32 partition, not removable,
    and resides in storage architected into the device. In the devices examined thus
    far, the eMMC is formatted as FAT32, again for interoperability.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可移动的SD卡被挂载在/mnt/sdcard上，通常包含照片、视频、缩略图、下载的文件、文本语音临时文件以及Google Maps导航数据，还包括许多Android
    Market应用程序的数据。较新的/mnt/emmc是一个FAT32分区，不可移动，位于设备架构的存储中。在迄今为止检查的设备中，eMMC通常被格式化为FAT32，这也是为了互操作性。
- en: YAFFS2
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAFFS2
- en: When the first Android device was released, many people were surprised to see
    a relatively unknown file system play a key role in the system. YAFFS, which is
    an acronym for Yet Another Flash File System, is an open-source file system developed
    specifically for NAND flash and is licensed under both the GNU Public License
    (GPL) and a commercial license agreement for those who do not wish to follow the
    strict GPL guidelines ([YAFFS licence FAQs, n.d.](#BIB9)). Android devices use
    the latest release of YAFFS (YAFFS2) that follows more strict NAND flash guidelines
    meant to improve the endurance of the NAND flash while optimized to run on low-memory
    mobile or embedded devices.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个Android设备发布时，许多人对一个相对不知名的文件系统在系统中扮演关键角色感到惊讶。YAFFS（Yet Another Flash File
    System的缩写）是一个专门为NAND闪存开发的开放源代码文件系统，同时遵循GNU公共许可证（GPL）和商业许可协议，后者适用于那些不想严格遵守GPL指导方针的人（[YAFFS
    licence FAQs, n.d.](#BIB9)）。Android设备使用YAFFS的最新版本（YAFFS2），该版本遵循更严格的NAND闪存指导方针，旨在提高NAND闪存的耐久性，同时针对低内存移动或嵌入式设备进行优化。
- en: 'YAFFS2 was developed by Aleph One Ltd, a company based in New Zealand. Driven
    by customer requests, Aleph One began YAFFS design in December 2001 and released
    the first publicly available source code in May 2002\. The primary developer (or
    certainly the most visible) is Charles Manning who is described as “The Embedded
    Janitor” and has been developing and “mopping up” embedded systems for 20 years
    ([YAFFS: the NAND-specific flash, n.d.](#BIB10)). Charles is quite active on the
    YAFFS mailing list and is the de facto expert on YAFFS and YAFFS2.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'YAFFS2由新西兰的Aleph One Ltd公司开发。应客户要求，Aleph One于2001年12月开始了YAFFS的设计工作，并于2002年5月发布了首个公开可用的源代码。主要开发者（或至少是最知名的）是Charles
    Manning，他被描述为“嵌入式清洁工”，在过去的20年里一直在开发和完善嵌入式系统（[YAFFS: the NAND-specific flash, n.d.](#BIB10)）。Charles在YAFFS邮件列表上非常活跃，是YAFFS和YAFFS2方面的公认专家。'
- en: Tip
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Additional YAFFS2 resources
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加的YAFFS2资源
- en: Analysts and engineers interested in the internals of YAFFS2 are encouraged
    to read the full documentation (and source code, if that’s your thing) from [http://www.yaffs.net/](http://www.yaffs.net/)
    and sign up for the mailing list.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部结构感兴趣的 分析师和工程师们，鼓励他们阅读完整的YAFFS2文档（如果感兴趣，还可以阅读源代码），访问[http://www.yaffs.net/](http://www.yaffs.net/)并订阅邮件列表。
- en: YAFFS2 was built specifically for the growing NAND flash devices and has a number
    of important features that address the stringent needs of this medium. YAFFS2
    is
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS2是专门为日益增长的NAND闪存设备而构建的，它具有许多重要特性，满足这一介质严格的需求。YAFFS2是
- en: • a log-structured file system (which protects data even through unexpected
    power outages)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: • 支持日志结构文件系统（即使在意外断电情况下也能保护数据）
- en: • provides built in wear-leveling and error correction
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: • 提供内置的磨损均衡和错误校正
- en: • capable of handling bad blocks
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: • 能够处理坏块
- en: • fast and has a small footprint in RAM
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: • 快速且在RAM中占用空间小
- en: However, since its usage was limited prior to Android, there are currently no
    forensic tools (commercial or open source) that support the file system. This
    leaves the forensic analysts with few options except to download the YAFFS2 source
    code, grab a forensic image of a partition, open it up in your favorite hex editor,
    and start digging. Although some utilities should develop over time, Android’s
    move to EXT4 may reduce the motivation for commercial forensic companies to develop
    such support.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在Android之前其使用受到限制，目前没有（商业或开源）取证工具支持该文件系统。这使得取证分析师除了下载YAFFS2源代码，获取分区的取证映像，用你喜欢的十六进制编辑器打开并开始挖掘之外，几乎别无选择。尽管随着时间的推移可能会开发出一些工具，但Android转向EXT4可能会降低商业取证公司开发此类支持的积极性。
- en: As covered in the NAND flash section, YAFFS2 addressed the memory in blocks
    through the MTD subsystem and each block contains a set number of pages (called
    chunks in YAFFS documentation and code). When YAFFS2 is ready to write data to
    the NAND flash, it passes both the data and metadata structures to the MTD. The
    MTD is then responsible for writing (as well as reading) both the data and the
    metadata to the NAND flash.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如 NAND 闪存部分所述，YAFFS2 通过 MTD 子系统以块的形式处理内存，每个块包含一定数量的页面（在 YAFFS 文档和代码中称为数据块）。当
    YAFFS2 准备好将数据写入 NAND 闪存时，它将数据和元数据结构都传递给 MTD。MTD 然后负责将（以及读取）数据和元数据写入 NAND 闪存。
- en: For most Android devices, the MTD subsystem addressed NAND flash in blocks that
    are divided into 64 chunks with each chunk containing 2048 bytes (so blocks are
    128K) plus a 64-byte out-of-band/spare area (OOB) where various tags and metadata
    are stored. When a block is allocated for writing, it is assigned a sequence number
    that starts at 1 and increments with each new block.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 Android 设备，MTD 子系统以块的形式处理 NAND 闪存，这些块被划分为 64 个数据块，每个数据块包含 2048 字节（因此块为
    128K），加上一个 64 字节的带外/备用区域（OOB），各种标签和元数据都存储在这里。当为写入分配一个块时，它会被分配一个从 1 开始并随每个新块增加的序列号。
- en: All data structures stored in YAFFS2 are referred to as Objects and can be files,
    directories, symbolic links, and hard links. Each chunk either stores a yaffs_ObjectHeader
    (object metadata) or data for the object. The yaffs_ObjectHeader tracks various
    information including the Object type, the parent object, a checksum of the name
    to speed up searching, the object name, permissions and ownership, MAC information,
    and the size of the object if it is a file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS2 中存储的所有数据结构都被视为对象，可以是文件、目录、符号链接和硬链接。每个数据块要么存储一个 yaffs_ObjectHeader（对象元数据），要么存储对象的数据。yaffs_ObjectHeader
    跟踪各种信息，包括对象类型、父对象、用于加速搜索的名称校验和、对象名称、权限和所有权、MAC 信息，如果对象是文件，还包括对象的大小。
- en: 'In the 64-byte OOB/spare area, YAFFS2 not only stores critical information
    about the chunk but also shares the area with the MTD subsystem. The critical
    YAFFS2 tags are as follows:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 字节的 OOB/备用区域中，YAFFS2 不仅存储关于数据块的 critical 信息，还与 MTD 子系统共享该区域。关键的 YAFFS2
    标签如下：
- en: '• 1 byte: block state (0xFF if block is good, any other value for a bad block)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: • 1 字节：块状态（0xFF 表示块良好，其他值表示坏块）
- en: '• 4 bytes: 32-bit chunk ID (0 indicates that chunk is storing a yaffs_ObjectHeader,
    else data)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: • 4 字节：32位数据块 ID（0 表示数据块存储 yaffs_ObjectHeader，否则为数据）
- en: '• 4 bytes: 32-bit Object ID (similar to traditional Unix inode)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: • 4 字节：32位对象 ID（类似于传统的 Unix i 节点）
- en: '• 2 bytes: number of data blocks in this chunk (all but final chunk will be
    fully allocated)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: • 2 字节：此数据块中的数据块数（最后一个数据块除外，其余都会被完全分配）
- en: '• 4 bytes: sequence number for this block'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: • 4 字节：此块的序列号
- en: '• 3 bytes: ECC for tags (in Android, handled by MTD)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: • 3 字节：标签的 ECC（在 Android 中，由 MTD 处理）
- en: '• 12 bytes: ECC for data (in Android, handled by MTD)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: • 12 字节：数据的 ECC（在 Android 中，由 MTD 处理）
- en: If an object is changed, a new yaffs_ObjectHeader is written to flash because
    NAND memory can only be written once before erasing. The old data and headers
    still exist but are ignored in the file structure by examining the values of the
    sequence number. Using this process complies with the guideline that blocks in
    NAND flash can never be re-written (only written once and then erased when no
    longer needed). This, of course, can be of enormous benefit to the data-recovery
    process as modified or deleted data will still exist on the NAND flash unless
    the block went through the garbage collection process used to erase a block and
    prepare it to accept new data.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象被更改，新的 yaffs_ObjectHeader 将被写入闪存，因为 NAND 内存只能在擦除前写入一次。旧数据和头部仍然存在，但通过检查序列号的值，在文件结构中被忽略。这个过程符合
    NAND 闪存中的块永远不会被重写（只写入一次，然后在不再需要时擦除）的指导原则。当然，这对于数据恢复过程可能具有巨大的好处，因为除非块经历了用于擦除块并准备接受新数据的垃圾回收过程，否则修改或删除的数据仍然存在于
    NAND 闪存上。
- en: Similarly, when a file is deleted in YAFFS2, the parent directory for the ObjectHeader
    is moved to a special, hidden directory called unlinked. The file remains in this
    directory until all of the chunks in the file are erased. To achieve this, the
    file system tracks the number of chunks in the system for the file. When it reaches
    0, the remnants of the file no longer exist. At that point, it will no longer
    track the object in the unlinked directory.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在 YAFFS2 中删除文件时，ObjectHeader 的父目录会被移动到一个特殊的隐藏目录中，称为未链接目录。文件将保留在此目录中，直到文件中的所有块段被擦除。为了实现这一点，文件系统跟踪系统中文件的块段数量。当它达到
    0 时，文件残留部分不再存在。在这一点上，它将不再在未链接目录中跟踪对象。
- en: While the file system structure can be regenerated completely from the OOB area
    and ObjectHeader information, this is not efficient—especially as the size of
    NAND flash memory grows. The structure is thus loaded and maintained in RAM (with
    writes to the NAND flash as needed) using a tree-node structure (T-node) to track
    all allocated chunks. T-nodes are a fixed 32 bytes and, at their lowest level
    (level 0), store an index used to locate the first chunk ID. As the file size
    grows, additional levels are added, which consist of eight pointers to other T-nodes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件系统结构可以从 OOB 区域和 ObjectHeader 信息完全重新生成，但这并不高效——特别是随着 NAND 闪存大小的增长。因此，结构被加载到
    RAM 中并维护（根据需要写入 NAND 闪存），使用树节点结构（T 节点）来跟踪所有已分配的块段。T 节点是固定的 32 字节，在其最低级别（级别 0）存储一个索引，用于定位第一个块段
    ID。随着文件大小的增长，会添加额外的级别，这些级别由指向其他 T 节点的八个指针组成。
- en: To regenerate, YAFFS2 reads each chunk in its block allocation order, starting
    from the end and working back, and populates the file system structures as T-nodes
    in RAM. This requires scanning the entire NAND—a time-consuming operation. To
    work around this issue, checkpointing was developed for YAFFS2, which prefers
    the RAM structure to NAND flash (using 10 blocks) when it is properly unmounted.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS2 通过从块的分配顺序的末尾开始，逆向读取每个块段来重新生成，并在 RAM 中填充文件系统结构作为 T 节点。这需要扫描整个 NAND，这是一个耗时的操作。为了解决这个问题，YAFFS2
    开发了检查点机制，当它正常卸载时，该机制更喜欢将 RAM 结构保存到 NAND 闪存（使用 10 个块）。
- en: A few other key concepts are needed to round out your understanding on YAFFS2\.
    First, garbage collection is queued up and, if needed, is done each time a write-to-the-system
    occurs. If all the chunks in a block are no longer in use, the block is a candidate
    for garbage collection. The system is also capable of taking the “dirtiest” block,
    copying allocated chunks to new blocks, thus making the block available for garbage
    collection. To make the block available again, it is erased by writing all 1’s
    (0xFF).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更全面地了解 YAFFS2，还需要掌握一些其他关键概念。首先，垃圾回收是排队进行的，并且每次写入系统时如有需要都会执行。如果一个块中的所有块段都不再被使用，那么这个块就成为了垃圾回收的候选对象。系统还能够找到“最脏”的块，将已分配的块段复制到新块中，从而使该块可以进行垃圾回收。为了再次使用这个块，会通过写入全
    1（0xFF）来擦除它。
- en: 'On an Android device, we can find detailed information about the YAFFS2 file
    systems by examining the /proc/yaffs files:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 设备上，我们可以通过检查 `/proc/yaffs` 文件来找到关于 YAFFS2 文件系统的详细信息：
- en: '![image](img/F100044u04-55a-9781597496513.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-55a-9781597496513.jpg)'
- en: '![image](img/F100044u04-55b-9781597496513.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-55b-9781597496513.jpg)'
- en: 'We can see many useful details, for example, on the “datadata” YAFFS2 partition
    mounted at /data/data. By examining the /proc/yaffs listing for this partition,
    we can learn the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到许多有用的详细信息，例如，在挂载于 `/data/data` 的 “datadata” YAFFS2 分区上。通过检查该分区的 `/proc/yaffs`
    列表，我们可以了解到以下内容：
- en: 1. There are 1192 blocks (0 through 1191) and we know there are 64 chunks (2048
    bytes) per block. So, 128K × 1192 = 152,576K, which you can confirm by running
    the df command or examining /proc/mtd as we did above.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 有 1192 个块（从 0 到 1191），我们知道每个块有 64 个块段（2048 字节）。所以，128K × 1192 = 152,576K，你可以通过运行
    df 命令或像我们上面那样检查 /proc/mtd 来确认。
- en: 2. The number of Page Reads, Page Writes, and Block Erasures are shown. This
    will provide a general idea of how much the NAND flash is used.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 显示了页面读取、页面写入和块擦除的数量。这将提供一个关于 NAND 闪存使用情况的总体概念。
- en: 3. One strategy in the garbage collection procedure is to find blocks that are
    nearly free, copy the remaining data out, and then mark the block available for
    collection. We can see this happening at a high rate (323,313).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 垃圾回收过程中的一个策略是找到几乎空闲的块，将剩余数据复制出来，然后标记块为可收集。我们可以看到这个过程以很高的速率（323,313）发生。
- en: 4. We can see there are no ECC errors detected.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 我们可以看到没有检测到 ECC 错误。
- en: 5. The YAFFS2 metadata reports over 643,000 unlinked files.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 5. YAFFS2元数据报告超过63,000个未链接的文件。
- en: 6. YAFFS2 is not using software ECC and instead relies on either MTD or the
    NAND flash.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 6. YAFFS2不使用软件ECC，而是依赖于MTD或NAND闪存。
- en: If you compare the system partition that does not have the high read and write
    usage of the /data/data direction, you will notice significant differences. Inspecting
    the /proc/yaffs file may help provide necessary background information when explaining
    error-correcting code, fragmented data, and more.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较没有高读写使用的 `/data/data` 目录的系统分区，你会注意到明显的差异。检查 `/proc/yaffs` 文件可能有助于提供解释错误纠正代码、碎片化数据等时的必要背景信息。
- en: 'The best way to gain a deeper understanding of YAFFS2 is to simply create,
    modify, and examine the file system directly. All of this is possible on the Ubuntu
    workstation created for other exercises throughout the book. Since we already
    have a Linux virtual machine and the build-essential package installed (which
    includes the necessary C compiler and supporting packages), we need to now install
    the mtd-utils package:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 深入理解YAFFS2的最佳方式是直接创建、修改和检查文件系统。所有这些在本书其他练习中创建的Ubuntu工作站上都是可能的。由于我们已经安装了Linux虚拟机和build-essential软件包（包括必要的C编译器和支持软件包），我们现在需要安装mtd-utils软件包：
- en: '![image](img/F100044u04-56-9781597496513.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-56-9781597496513.jpg)'
- en: 'Then, we download the latest YAFFS2 source code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们下载最新的YAFFS2源代码：
- en: '![image](img/F100044u04-57-9781597496513.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-57-9781597496513.jpg)'
- en: 'And then extract yaffs2.tar.gz and compile so we can use the kernel module:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 然后解压yaffs2.tar.gz并编译，这样我们就可以使用内核模块了：
- en: '![image](img/F100044u04-58-9781597496513.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-58-9781597496513.jpg)'
- en: Next, we are going to load the needed kernel modules to simulate an MTD in RAM
    (unless you happen to have some NAND flash lying around which you can hook up
    directly) and then mount a YAFFS2 partition.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载必要的内核模块在RAM中模拟MTD（除非你恰好有一些可以直接连接的NAND闪存）然后挂载YAFFS2分区。
- en: 'First, we’ll create a place to mount the file system in our home directory:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在主目录中创建一个挂载文件系统的地方：
- en: '![image](img/F100044u04-59-9781597496513.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-59-9781597496513.jpg)'
- en: 'Next we need to load a few kernel modules to enable MTD support:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要加载几个内核模块以启用MTD支持：
- en: '![image](img/F100044u04-60-9781597496513.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-60-9781597496513.jpg)'
- en: 'Next, we create the simulated NAND flash with the nandsim kernel module:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用nandsim内核模块创建模拟的NAND闪存：
- en: '![image](img/F100044u04-61-9781597496513.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-61-9781597496513.jpg)'
- en: Tip
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Additional information on Linux MTD
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于Linux MTD的额外信息
- en: The Linux MTD web page provides more details on nandsim. The web site provides
    deep background information and support for MTD so please visit it for full details.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Linux MTD网页提供了关于nandsim的更多详细信息。该网站提供了MTD的深入背景信息和支持，请访问以获取完整详情。
- en: 'Additional details on nandsim from the Linux MTD web site are provided here
    for direct reference ([NAND FAQ, n.d.](#BIB6)):'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了来自Linux MTD网站的关于nandsim的额外详细信息以供直接参考（[NAND FAQ, n.d.](#BIB6)）：
- en: '“NAND simulator (nandsim) is an extremely useful debugging and development
    tool which simulates NAND flashes in RAM or a file. To select the simulated flash
    type one should specify ID bytes of your flash—the ones which are returned by
    the “Read ID” command (0x90)—consult the flash manual. The following are examples
    of input parameters:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: “NAND模拟器（nandsim）是一个极其有用的调试和开发工具，它可以在RAM或文件中模拟NAND闪存。要选择模拟的闪存类型，你应该指定你的闪存的ID字节——即通过“读取ID”命令（0x90）返回的字节——请参阅闪存手册。以下是输入参数的示例：
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x33—16MiB, 512 bytes page
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x33—16MiB, 512字节页”
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x35—32MiB, 512 bytes page;
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x35—32MiB, 512字节页；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x36—64MiB, 512 bytes page;
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x36—64MiB, 512字节页；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x78—128MiB, 512 bytes
    page;
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x78—128MiB, 512字节页；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x71—256MiB, 512 bytes
    page;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0x71—256MiB, 512字节页；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00
    fourth_id_byte=0x15—64MiB, 2048 bytes page;
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00
    fourth_id_byte=0x15—64MiB, 2048字节页；
- en: • modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00
    fourth_id_byte=0x15—128MiB, 2048 bytes page;
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00
    fourth_id_byte=0x15`创建一个128MiB的模拟NAND闪存，每页2048字节；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00
    fourth_id_byte=0x15—256MiB, 2048 bytes page;
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00
    fourth_id_byte=0x15`创建一个256MiB的模拟NAND闪存，每页2048字节；
- en: • modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00
    fourth_id_byte=0x15—512MiB, 2048 bytes page;
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: • 首先使用`modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00
    fourth_id_byte=0x15`创建一个512MiB的模拟NAND闪存，每页2048字节；
- en: • modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51
    fourth_id_byte=0x95—1GiB, 2048 bytes page;”
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51
    fourth_id_byte=0x95`创建一个1GiB的模拟NAND闪存，每页2048字节；
- en: 'Now that we have the simulated NAND flash, we can verify size and partition
    info by examining the /proc/mtd just as we did directly on the Android device:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经有了模拟的NAND闪存，我们可以像在Android设备上一样通过检查`/proc/mtd`来验证其大小和分区信息：
- en: '![image](img/F100044u04-62-9781597496513.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-62-9781597496513.jpg)'
- en: 'The system shows that we have one MTD partition (mtd0), and erasesize in hex
    of 0x20000 bytes (128 KB), and a total size in hex of 0x4000000 (65,536 KB or
    64 MB). Next, we need to load the YAFFS2 kernel module into memory:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 系统显示我们有一个MTD分区（mtd0），擦除大小为十六进制的0x20000字节（128 KB），总大小为十六进制的0x4000000（65,536 KB或64 MB）。接下来，我们需要将YAFFS2内核模块加载到内存中：
- en: '![image](img/F100044u04-63-9781597496513.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-63-9781597496513.jpg)'
- en: 'Before we mount the YAFFS2 file system, let’s take a look at the uninitialized
    simulated NAND flash in a hex editor. If you try to use tools like dd or simply
    xxd to view the NAND flash device, you will not see the OOB areas because they
    are not exposed to most tools. This is to prevent the intermixed 64 bits of metadata
    from confusing programs that do not expect OOB in their file (imagine trying to
    display a PDF that has 64 bytes of binary OOB data after each 2k chunk). To read
    the full NAND flash including the OOB, we use the program nanddump that is part
    of the previously installed mtd-utils package. This will read the data and return
    them in binary. There are several options to consider which can be easily viewed:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们挂载YAFFS2文件系统之前，先在十六进制编辑器中查看未初始化的模拟NAND闪存。如果你尝试使用`dd`或仅仅是`xxd`这样的工具来查看NAND闪存设备，你将看不到OOB区域，因为它们对大多数工具是不可见的。这是为了防止那些不期望文件中有OOB的程序的混淆（想象一下尝试显示每个2k数据块后都有64字节二进制OOB数据的PDF）。为了读取包括OOB在内的完整NAND闪存，我们使用之前安装的`mtd-utils`包中的`nanddump`程序。这将读取数据并以二进制形式返回它们。有几个选项可以考虑，可以很容易地查看：
- en: '![image](img/F100044u04-64-9781597496513.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-64-9781597496513.jpg)'
- en: 'For our purposes, we want to use nanddump to extract the full NAND with OOB
    and pipe the output to a hex editor (xxd) for viewing:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们想使用`nanddump`提取包含OOB的完整NAND，并将输出管道到十六进制编辑器（xxd）进行查看：
- en: '![image](img/F100044u04-65-9781597496513.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-65-9781597496513.jpg)'
- en: Notice that the simulated NAND flash contains the expected 0xFF values that
    a blank or erased NAND flash should have. The above command will allow you to
    examine how the raw NAND flash is modified when we initialize and subsequently
    modify the file system.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模拟的NAND闪存包含预期的0xFF值，这是空白或已擦除的NAND闪存应有的。上述命令将允许你检查在初始化和随后修改文件系统时，原始NAND闪存是如何被修改的。
- en: 'So, finally, we are ready to mount a YAFFS2 file system:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后，我们准备挂载YAFFS2文件系统：
- en: '![image](img/F100044u04-66-9781597496513.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-66-9781597496513.jpg)'
- en: 'You can verify the file system is mounted and accessible:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以验证文件系统是否已挂载并可访问：
- en: '![image](img/F100044u04-67-9781597496513.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-67-9781597496513.jpg)'
- en: 'So, we can see a YAFFS2 file system is mounted with read/write permissions
    at ~/mnt/yaffs2\. Even though we have not created any files, the directory contains
    a lost+found virtual directory where files and directories whose parent directory
    cannot be determined are stored. If you use the xxd hex editor again to examine
    the simulated NAND flash device, it will still contain 0xFF. However, if you write
    a single file with the following command:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到YAFFS2文件系统以读/写权限挂载在`~/mnt/yaffs2`目录下。尽管我们没有创建任何文件，但该目录包含一个`lost+found`虚拟目录，用于存放无法确定父目录的文件和目录。如果你再次使用`xxd`十六进制编辑器检查模拟的NAND闪存设备，它仍然会包含0xFF。但是，如果你使用以下命令写入单个文件：
- en: '![image](img/F100044u04-68-9781597496513.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-68-9781597496513.jpg)'
- en: 'and put the contents “Android Forensics and Mobile Security” in the file, then
    when we examine the raw NAND flash, we can clearly see the YAFFS2 structures including
    the ObjectHeaders, Objects, and file contents. Here’s a portion of the hex content
    using nanddump and a slightly modified xxd command by adding the -a option that
    will skip 0x00 rows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 并在文件中放入“Android取证与移动安全”的内容，然后当我们检查原始NAND闪存时，可以清楚地看到包括ObjectHeaders、Objects和文件内容的YAFFS2结构。以下是使用nanddump和稍微修改过的xxd命令（添加了-a选项以跳过0x00行）的部分十六进制内容：
- en: '![image](img/F100044u04-69-9781597496513.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-69-9781597496513.jpg)'
- en: Beginning at offset 0x0000000, we can see the blank ObjectHeader where we can
    easily see the file name in ASCII (book.txt). Beginning at 0x0000800 through 0x000083F,
    we can see the OOB data that is stored by YAFFS2 and then MTD as packed binary
    data and must be decided. The actual contents of the file are written to the NAND
    flash at 0x0000840\. We see another OOB from 0x0001040 through 0x000107F and then
    the ObjectHeader is written to the NAND flash again at 0x0001080 because the original
    ObjectHeader represented the blank file. Once we added the content and saved the
    file, the data was written to the NAND flash and a *new ObjectHeader was written*
    to the NAND flash. The new ObjectHeader reflects the new metadata about the Object
    including what chunks hold the data, MAC (modified, accessed, changed) data, and
    more.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 从偏移量0x0000000开始，我们可以看到空白的ObjectHeader，可以轻松地看到ASCII码中的文件名（book.txt）。从0x0000800到0x000083F，我们可以看到由YAFFS2存储并由MTD作为打包二进制数据存储的OOB数据，必须进行解析。文件的实际内容被写入到NAND闪存的0x0000840位置。我们从0x0001040到0x000107F看到了另一个OOB，然后在0x0001080位置再次写入ObjectHeader到NAND闪存，因为原始ObjectHeader表示的是空文件。一旦我们添加了内容并保存了文件，数据就被写入NAND闪存，并且一个*新的ObjectHeader被写入*到NAND闪存。新的ObjectHeader反映了关于对象的新元数据，包括哪些数据块保存了数据、MAC（修改、访问、更改）数据等。
- en: A key point to understand is that YAFFS2 could not simply update the first ObjectHeader
    with this information because it would first have to erase that entire block.
    So instead it writes a new ObjectHeader, generates a high sequence number for
    that header which makes it the most up-to-date ObjectHeader for the file. As you
    can imagine, the old ObjectHeader and data remain on the NAND flash unless they
    go through garbage collection and thus provide a great opportunity to recover
    file metadata and contents using forensic techniques.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的一个关键点是，YAFFS2不能简单地将此信息更新到第一个ObjectHeader，因为它首先需要擦除整个块。因此，它写入一个新的ObjectHeader，为该头部生成一个高序列号，使其成为文件的最新ObjectHeader。可以想象，旧的ObjectHeader和数据除非通过垃圾回收，否则会保留在NAND闪存上，从而为使用取证技术恢复文件元数据和内容提供了极大的机会。
- en: YAFFS Example
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: YAFFS示例
- en: In this final section about YAFFS2, a fictitious scenario is presented to illustrate
    how ObjectHeaders and Objects are written to the NAND flash. The example was presented
    by Charles Manning in his “*How Yaffs Works*” ([How YAFFS works, n.d.](#BIB5)).
    Anyone interested in the internals of YAFFS is encouraged to print, read, or re-read
    this document. In the example, we use a NAND flash which, for simplicity, has
    four chunks per block and is erased (0xFF). After each change is described, a
    table will show the contents of the NAND flash.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于YAFFS2的最后部分，提供了一个虚构的场景来说明ObjectHeaders和Objects是如何写入NAND闪存的。这个例子是由Charles
    Manning在他的“*Yaffs如何工作*”（[How YAFFS works, n.d.](#BIB5)）中提出的。任何对YAFFS内部感兴趣的人都被鼓励打印、阅读或重新阅读这份文件。在示例中，我们使用了一个NAND闪存，为了简单起见，该闪存每个块有四个数据块，并且已被擦除（0xFF）。在描述每个更改后，一个表格将显示NAND闪存的内容。
- en: First, we create an empty file on the NAND flash as shown in [Table 4.6](#T0035).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在NAND闪存上创建一个空文件，如[表4.6](#T0035)所示。
- en: Table 4.6 Blank File Created
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6 创建空白文件
- en: '![Image](img/T100044tabT0035.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0035.jpg)'
- en: The ObjectHeader points to an empty file. Next, we write three chunks of data
    to the file, as shown in [Table 4.7](#T0040).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: ObjectHeader指向一个空文件。接下来，我们向文件写入三个数据块，如[表4.7](#T0040)所示。
- en: Table 4.7 Write Three Chunks of Data
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.7 写入三个数据块
- en: '![Image](img/T100044tabT0040.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0040.jpg)'
- en: So far, this may seem straightforward. The object is now taking up the entire
    first block.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能看起来很简单。现在对象占据了第一个块的全部。
- en: Note
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fictitious NAND flash
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚构的NAND闪存
- en: Remember, our fictitious NAND flash has four chucks per block, not the typical
    64 chunks we see in commercial NAND flash.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的虚构NAND闪存每个块有四个数据块，而不是我们在商用NAND闪存中常见的64个数据块。
- en: Next, we are going to save the file that will cause a new ObjectHeader to be
    written to the NAND flash as shown in [Table 4.8](#T0045).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将保存文件，这将导致新的ObjectHeader被写入NAND闪存，如[表4.8](#T0045)所示。
- en: Table 4.8 Save the File’s New ObjectHeader
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.8 保存文件的新ObjectHeader
- en: '![Image](img/T100044tabT0045.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0045.jpg)'
- en: The key point to understand here is that YAFFS2 is unable to go back and update
    the original ObjectHeader with the new size, chunks of data, and others. Instead,
    it must write a new ObjectHeader that will contain the metadata needed for the
    updated file. In YAFFS2, the new ObjectHeader is given a larger sequence number
    and thus it becomes the current ObjectHeader and YAFFS2 simply ignores the previous
    one (however, it remains on disk).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要理解的关键点是，YAFFS2无法回过头来用新的大小、数据块和其他信息更新原始ObjectHeader。相反，它必须写入一个新的ObjectHeader，其中包含更新文件所需的元数据。在YAFFS2中，新的ObjectHeader被赋予更大的序列号，因此它成为当前的ObjectHeader，YAFFS2简单地忽略了之前的那个（然而，它仍然留在磁盘上）。
- en: Next, the file will be opened with read/write access and the first chunk of
    data will be given a new value. Finally, the file is saved and closed, which results
    in additional data written to the NAND flash, as shown in [Table 4.9](#T0050).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，文件将以读写权限打开，并给第一个数据块赋予新值。最后，保存并关闭文件，这会导致额外的数据写入NAND闪存，如[表4.9](#T0050)所示。
- en: Table 4.9 Save the New Data and ObjectHeader
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.9 保存新数据和ObjectHeader
- en: '![Image](img/T100044tabT0050.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0050.jpg)'
- en: Again, since we cannot simply change the original first chunk of data in the
    file, a new data chunk is written to the NAND flash and the previous data chunk
    is obsolete. This is achieved as yet another new ObjectHeader is written to the
    NAND flash, which points to the new first chunk of data for the file. Next, we
    are going to truncate the file to a zero length file and the resulting NAND flash
    changes are shown in [Table 4.10](#T0055).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于我们不能简单更改文件中的原始第一个数据块，因此将新的数据块写入NAND闪存，并将之前的数据块标记为过时。这通过向NAND闪存写入另一个新的ObjectHeader来实现，该ObjectHeader指向文件的新的第一个数据块。接下来，我们将文件截断为零长度文件，[表4.10](#T0055)展示了NAND闪存的变化。
- en: Table 4.10 Truncate File and Write New ObjectHeader
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.10 截断文件并写入新的ObjectHeader
- en: '![Image](img/T100044tabT0055.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0055.jpg)'
- en: As the file was truncated, none of the chunks in Block 0 are in use any longer.
    This makes the block available for garbage collection, which will occur on the
    next write cycle. This is referred to as lazy garbage collection because it uses
    an existing write cycle to perform any necessary garbage collection. As before,
    a new Object-Header is written to the NAND flash to account for the truncated
    file.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件被截断，块0中的所有数据块都不再使用。这使得该块可用于垃圾回收，将在下一个写入周期发生。这被称为懒惰垃圾回收，因为它使用现有的写入周期来执行必要的垃圾回收。与之前一样，新的ObjectHeader被写入NAND闪存，以解释被截断的文件。
- en: Finally, we rename the file and the NAND flash results are shown in [Table 4.11](#T0060).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重命名文件，NAND闪存的结果如[表4.11](#T0060)所示。
- en: Table 4.11 Rename File and Write New ObjectHeader
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.11 重命名文件并写入新的ObjectHeader
- en: '![Image](img/T100044tabT0060.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0060.jpg)'
- en: During this cycle, Block 0 was garbage collected and is now available for writing
    data. As the file was renamed, a new ObjectHeader was written to the NAND flash.
    With all chunks in Block 1 now obsolete, they are available for garbage collection.
    However, bear in mind that due to the limited endurance of NAND flash, write/erase
    cycles are avoided.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个周期中，块0进行了垃圾回收，现在可用于写入数据。由于文件被重命名，新的ObjectHeader被写入NAND闪存。块1中的所有数据块现在都过时了，它们可用于垃圾回收。然而，请记住，由于NAND闪存的有限耐久性，应避免写入/擦除周期。
- en: The implications for forensics are that the entire history of ObjectHeader and
    Object data chunks, unless garbage collected, would remain on the NAND flash.
    With proper software, the NAND flash could be scanned and the entire history of
    the file system could essentially be rebuilt. Not only would the timeline contain
    the date/time of every edit, but it is possible to recover the actual state of
    the file. In practice, the state of the YAFFS2 partitions is not this simple.
    However, the general principle remains relevant.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于法医调查来说，除非进行垃圾回收，否则ObjectHeader和Object数据块的整个历史都将保留在NAND闪存上。借助适当的软件，可以扫描NAND闪存，从而基本上重建文件系统的整个历史。时间线不仅会包含每次编辑的日期/时间，还有可能恢复文件的实际状态。实际上，YAFFS2分区的状态并非这么简单。然而，这个基本原则仍然是相关的。
- en: Mounted file systems
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载的文件系统
- en: We have covered many components of Android’s memory systems in detail. Not only
    have we explored RAM and the NAND flash, but we have also examined many of the
    file systems in great detail. This background information will assist in your
    forensic and security analysis of Android devices. To better understand this more
    academic information, we will now explore the mounted file systems found on an
    Android device.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细介绍了Android内存系统的许多组成部分。我们不仅探讨了RAM和NAND闪存，还详细检查了许多文件系统。这些背景信息将帮助您对Android设备进行法医和安全性分析。为了更好地理解这些更学术的信息，我们现在将探讨在Android设备上找到的已挂载文件系统。
- en: Mounted File Systems
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已挂载的文件系统
- en: 'Let us start with the file systems mounted on the HTC Incredible:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从HTC Incredible上挂载的文件系统开始：
- en: '![image](img/F100044u04-70-9781597496513.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/F100044u04-70-9781597496513.jpg)'
- en: When you run the mount command without parameters, it returns the list of mounted
    file systems and their options. [Table 4.12](#T0065) is a description of the output
    using several entries. However, note that each entry above ends with “0 0” which
    is omitted from the table for space reasons. The “0 0” entry determines whether
    or not the file system is archived by the dump command and the pass number that
    determines the order in which the file system checker (fsck) checks the device/partition
    for errors at boot time. On most desktop or server Linux systems, the root file
    system has a pass number of 1 so it is checked prior to other file systems.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行不带参数的mount命令时，它会返回已挂载的文件系统及其选项的列表。[表4.12](#T0065)是使用多个条目的输出描述。但是，请注意，上述每个条目都以“0
    0”结尾，由于空间原因，在表中省略了这部分。“0 0”条目确定文件系统是否由dump命令归档以及确定文件系统检查器（fsck）在引导时检查设备/分区错误的顺序的传递编号。在大多数桌面或服务器Linux系统上，根文件系统具有1的传递编号，因此它会在其他文件系统之前被检查。
- en: Table 4.12 Output of Mount Command Overview
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.12 mount命令输出概述
- en: '![Image](img/T100044tabT0065.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/T100044tabT0065.jpg)'
- en: 'The /mnt/sdcard has many options. The options are:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: /mnt/sdcard有许多选项。这些选项包括：
- en: '1. rw: mounted to allow read/write'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 1. rw：挂载以允许读写
- en: '2. dirsync: all updates to directories are done synchronously'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 2. dirsync：对目录的所有更新都是同步进行的
- en: '3. nosuid: does not allow setuid (which would allow other users to execute
    programs using the permission of file owner)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 3. nosuid：不允许设置setuid（这会允许其他用户使用文件所有者的权限执行程序）
- en: '4. nodev: does not interpret any file as a special block device'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 4. nodev：不将任何文件解释为特殊的块设备
- en: '5. noexec: does not let all files execute from the file system'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 5. noexec：不允许从文件系统执行所有文件
- en: '6. relatime: updates the file access time if older than the modified time'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 6. relatime：如果文件访问时间早于修改时间，则更新文件访问时间
- en: '7. uid=1000: sets the owner of all files to 1000'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 7. uid=1000：将所有文件的所有者设置为1000
- en: '8. gid=1015: sets the group of all files to 1015'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 8. gid=1015：将所有文件的组设置为1015
- en: '9. fmask=0702: sets the umask applied to regular files only (set permissions
    ---rwxr-x, or user=none, group=read/write/execute,other=read/execute)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 9. fmask=0702：仅对常规文件应用umask（设置权限---rwxr-x，或者用户=无，组=读写执行，其他=读执行）
- en: '10. dmask=0702: sets the umask applied to directories only (set permissions
    ---rwxr-x, or user=none, group=read/write/execute,other=read/execute)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 10. dmask=0702：仅对目录应用umask（设置权限---rwxr-x，或者用户=无，组=读写执行，其他=读执行）
- en: '11. allow_utime=0020: controls the permission check of mtime/atime.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 11. allow_utime=0020：控制mtime/atime的权限检查。
- en: '12. codepage=cp437: sets the codepage for converting to shortname characters
    on FAT and VFAT file systems.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 12. codepage=cp437：为FAT和VFAT文件系统转换短名称字符设置代码页。
- en: '13. iocharset=iso8859-1: character set to use for converting between 8-bit
    characters and 16-bit Unicode characters. The default is iso8859-1\. Long file
    names are stored on disk in Unicode format.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 13. iocharset=iso8859-1：用于在8位字符和16位Unicode字符之间转换的字符集。默认为iso8859-1。长文件名以Unicode格式存储在磁盘上。
- en: '14. shortname=mixed: defines the behavior for creation and display of file
    names that fit into 8.3 characters. If a long name for a file exists, it will
    always be the preferred display. Mixed displays the short name as is and stores
    a long name when the short name is not all upper case.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 14. shortname=mixed：定义了符合8.3字符限制的文件名的创建和显示行为。如果文件存在长文件名，它将始终优先显示。Mixed模式会按原样显示短名称，并在短名称不全为大写时存储长名称。
- en: '15. utf8: converts 16-bit Unicode characters on CD to UTF-8.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 15. utf8：将CD上的16位Unicode字符转换为UTF-8。
- en: '16. errors=remount-ro: defines the behavior when an error is encountered; in
    this case, remounts the file system read-only.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 16. errors=remount-ro：定义遇到错误时的行为；在这种情况下，重新以只读方式挂载文件系统。
- en: All of the mount command options are explained in the manual page (man 8 mount).
    However, for most cases, a quick scan will reveal the information an examiner
    needs including the mount points, types, and permissions on the file systems.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 所有挂载命令的选项在手册页（man 8 mount）中都有解释。然而，在大多数情况下，快速浏览将揭示审查员需要的信息，包括文件系统上的挂载点、类型和权限。
- en: 'The df command will provide information about the free space available on the
    mounted file systems:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: df 命令将提供有关已挂载文件系统上可用空间的免费信息：
- en: '![image](img/F100044u04-71-9781597496513.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-71-9781597496513.jpg)'
- en: 'As you can see, one of the mount points (/mnt/secure/asec) returned a permission
    denied when the shell user tried to determine how much disk space was free. By
    looking at the parent directory, we can see that only root has access to the directory:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当 shell 用户尝试确定可用磁盘空间量时，其中一个挂载点（/mnt/secure/asec）返回了权限被拒绝。通过查看父目录，我们可以看到只有
    root 用户可以访问该目录：
- en: '![image](img/F100044u04-72-9781597496513.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-72-9781597496513.jpg)'
- en: Interestingly, two of these file systems/directories can be exposed through
    the USB mass storage (UMS) option and when that occurs, the permissions on the
    directories change. If the UMS option is not enabled, the file systems are fully
    accessible to the Android device as you can see for /mnt/emmc and /mnt/sdcard.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当通过 USB 大容量存储（UMS）选项暴露这两个文件系统/目录时，目录的权限会发生变化。如果未启用 UMS 选项，正如你可以看到 /mnt/emmc
    和 /mnt/sdcard 的情况，文件系统对 Android 设备是完全可访问的。
- en: 'However, when UMS is active and the two file systems are available to the connected
    workstation, the permissions change:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当 UMS 激活并且两个文件系统对连接的工作站可用时，权限会发生变化：
- en: '![image](img/F100044u04-73-9781597496513.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![image](img/F100044u04-73-9781597496513.jpg)'
- en: As you can see, all permissions on /mnt/emmc and /mnt/sdcard are removed and
    thus the Android device cannot access /mnt/emmc or /mnt/sdcard from the phone
    directly (i.e., it is exclusively shared with the connected workstation).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，/mnt/emmc 和 /mnt/sdcard 上的所有权限都被移除了，因此 Android 设备不能直接从手机访问 /mnt/emmc 或
    /mnt/sdcard（即它是与连接的工作站独占共享的）。
- en: Summary
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The physical memory, file systems, and data structures present on an Android
    device are the fundamental building blocks for data storage. Having a deep understanding
    of these structures will not only enable you to understand an Android device but
    to also perform your own research and development when presented with new file
    systems and data structures.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备上的物理内存、文件系统及数据结构是数据存储的基本构建块。对这些结构的深入理解不仅能够帮助你理解 Android 设备，而且当面对新的文件系统和数据结构时，还能进行自己的研究和开发。
- en: References
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '1\. *Android developers blog: Saving data safely*. (n.d.). Retrieved February
    2, 2011, from [http://android-developers.blogspot.com/2010/12/saving-data-safely.html](http://android-developers.blogspot.com/2010/12/saving-data-safely.html).'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. *Android 开发者博客：安全保存数据*。（未注明日期）。2011 年 2 月 2 日检索自 [http://android-developers.blogspot.com/2010/12/saving-data-safely.html](http://android-developers.blogspot.com/2010/12/saving-data-safely.html)。
- en: 2\. *Android reverse engineering*. (n.d.). [thomascannon.net](http://thomascannon.net).
    Retrieved January 29, 2011, from [http://thomascannon.net/projects/android-reversing/](http://thomascannon.net/projects/android-reversing/).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. *Android 逆向工程*。（未注明日期）。[thomascannon.net](http://thomascannon.net)。2011
    年 1 月 29 日检索自 [http://thomascannon.net/projects/android-reversing/](http://thomascannon.net/projects/android-reversing/)。
- en: 3\. *Data storage*. (n.d.). Android Developers. Retrieved March 13, 2011, from
    [http://developer.android.com/guide/topics/data/data-storage.html#netw](http://developer.android.com/guide/topics/data/data-storage.html%23netw).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. *数据存储*。（未注明日期）。Android 开发者。2011 年 3 月 13 日检索自 [http://developer.android.com/guide/topics/data/data-storage.html#netw](http://developer.android.com/guide/topics/data/data-storage.html%23netw)。
- en: '4\. *How YAFFS works: the internals*. (n.d.). YAFFS. Retrieved February 4,
    2011, from [http://www.yaffs.net/how-yaffs-works-internals](http://www.yaffs.net/how-yaffs-works-internals).'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. *YAFFS 的工作原理：内部机制*。（未注明日期）。YAFFS。2011 年 2 月 4 日检索自 [http://www.yaffs.net/how-yaffs-works-internals](http://www.yaffs.net/how-yaffs-works-internals)。
- en: 5\. Nand Faq. (n.d.). *Memory technology device (MTD) subsystem for Linux*,
    Retrieved March 13, 2011, from [http://www.linux-mtd.infradead.org/faq/nand.html](http://www.linux-mtd.infradead.org/faq/nand.html).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. Nand Faq. （未注明日期）。*Linux 的内存技术设备（MTD）子系统*，2011 年 3 月 13 日检索自 [http://www.linux-mtd.infradead.org/faq/nand.html](http://www.linux-mtd.infradead.org/faq/nand.html)。
- en: 6\. *The sysfs filesystem*. (n.d.), Retrieved February 1, 2011, from [http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf](http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. *sysfs 文件系统*。(未知日期)，引自2011年2月1日，来自[http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf](http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf)。
- en: 7\. Way, T. (n.d.). *Android will be using ext4 starting with Gingerbread. Thoughts
    by Ted. Welcome to* [<ce:italic>thunk.org</ce:italic>](http://thunk.org), Retrieved
    February 2, 2011, from [http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/](http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/).
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. Way, T. (未知日期)。*从姜饼开始，Android 将开始使用 ext4。Ted 的思考。欢迎来到* [<ce:italic>thunk.org</ce:italic>](http://thunk.org)，引自2011年2月2日，来自[http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/](http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/)。
- en: 8\. Licence FAQs, Y. A. F. F. S. (n.d.). YAFFS, Retrieved February 4, 2011,
    from [http://www.yaffs.net/yaffs-licence-faqs](http://www.yaffs.net/yaffs-licence-faqs).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 许可证常见问题，Y. A. F. F. S. (未知日期)。YAFFS，引自2011年2月4日，来自[YAFFS 许可证常见问题](http://www.yaffs.net/yaffs-licence-faqs)。
- en: '9\. *YAFFS: the NAND-specific flash file system—Introductory Article*. (n.d.).
    Retrieved February 2, 2011, from [http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle](http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle).'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. *YAFFS：NAND 专用闪存文件系统—介绍性文章*。(未知日期)。引自2011年2月2日，来自[YAFFS：NAND 专用闪存文件系统—介绍性文章](http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle)。
