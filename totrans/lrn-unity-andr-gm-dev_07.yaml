- en: Chapter 7. Throwing Your Weight Around – Physics and a 2D Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 重量级投掷——物理与2D摄像机
- en: In the previous chapter, you learned about the special features of a mobile
    device and how to create touch and tilt controls. We also created a Monkey Ball
    game to use these new controls. The steering of the ball was done by tilting the
    device and collecting bananas by touching the screen. We also gave it some win
    and lose conditions by creating a timer and finish line.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你了解了移动设备的特殊功能以及如何创建触摸和倾斜控制。我们还制作了一个Monkey Ball游戏来使用这些新控制。通过倾斜设备来控制球的方向，并通过触摸屏幕收集香蕉。我们还通过创建计时器和终点线，为游戏添加了一些胜利和失败的条件。
- en: In this chapter, will we take a short break from the Monkey Ball game to explore
    Unity's physics engine. We will also take a look at the options available for
    creating a 2D game experience. To do all of this, we will be recreating one of
    the most popular mobile games on the market, **Angry Birds**. We will use physics
    to throw birds and destroy structures. We will also take a look at the creation
    of a level-selection screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将暂时放下Monkey Ball游戏，去探索Unity的物理引擎。我们还会看看创建2D游戏体验时可用的选项。为此，我们将重新制作市场上最受欢迎的移动游戏之一，**愤怒的小鸟**。我们将使用物理引擎来投掷小鸟并摧毁结构。我们还将看看如何创建一个关卡选择屏幕。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Unity physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity物理引擎
- en: Parallax scrolling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差滚动
- en: 2D pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D管线
- en: Level selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡选择
- en: We will be creating a new project for this chapter, so start up Unity and let's
    begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章创建一个新项目，启动Unity，让我们开始吧！
- en: 2D games in a 3D world
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在3D世界中制作2D游戏
- en: Perhaps the most little-known thing when developing games is the fact that it's
    possible to create 2D-style games in a 3D game engine, such as Unity. As with
    everything else, it comes with its own set of advantages and disadvantages, but
    the choice can be well worth it for generating a pleasing game experience. The
    foremost advantage is that you can use 3D assets for the game. This allows dynamic
    lighting and shadows to be easily included. However, when using a 2D engine, any
    shadow will need to be painted directly into the assets and you will be hard-pressed
    to make it dynamic. On the side of disadvantages is the use of 2D assets in the
    3D world. It is possible to use them, but large file sizes become necessary to
    achieve the desired detail and to keep it from appearing pixelated. Most 2D engines,
    however, make use of vector art that will keep the image's lines smooth as it
    is scaled up and down. Also, one is able to use normal animations for the 3D assets,
    but frame-by-frame animation is generally required for any 2D asset. Altogether,
    the advantages have outweighed the disadvantages for many developers, creating
    a large selection of great looking 2D games that you may never realize were actually
    made in a 3D game engine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，最鲜为人知的事实之一是可以在3D游戏引擎中，例如Unity，制作2D风格的游戏。与其它所有事物一样，它也有自己的一套优势和劣势，但为了生成令人满意的游戏体验，这个选择可能是非常值得的。最显著的优势是可以为游戏使用3D资源。这使得动态光照和阴影可以轻松地包含在内。然而，在使用2D引擎时，任何阴影都需要直接绘制到资源中，而且很难使其具有动态效果。关于劣势，是在3D世界中使用2D资源。虽然可以使用它们，但为了达到所需的细节并防止其出现像素化，需要较大的文件大小。然而，大多数2D引擎都使用矢量艺术，这样无论图像如何缩放，其线条都能保持平滑。此外，可以为3D资源使用常规动画，但任何2D资源通常都需要逐帧动画。总的来说，对于许多开发者而言，优势已经超过了劣势，他们创造了大量外观精美的2D游戏，你可能永远也不会意识到这些游戏实际上是在3D游戏引擎中制作的。
- en: To address the growing demand from developers for 2D game support, the Unity
    team has been additionally been working long and hard on creating an optimized
    2D pipeline for the 3D engine. When creating your project, you have the option
    to select 2D defaults, optimizing assets for use in a 2D game. While there is
    still no direct vector graphics support from Unity, many other features have been
    optimized to work better in a 2D world. One of the biggest features is the 2D
    optimization of the physics engine, which we will be focusing on in this chapter.
    All the principles that we will use will transfer over to 3D physics, which will
    save some trouble when setting up and working with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足开发者对 2D 游戏支持的不断增长的需求，Unity 团队一直在努力为 3D 引擎创建优化的 2D 流水线。创建项目时，你可以选择 2D 默认设置，优化资产以便在
    2D 游戏中使用。尽管 Unity 仍然没有直接支持矢量图形，但许多其他功能已经优化，以便在 2D 世界中更好地工作。最大的功能之一是物理引擎的 2D 优化，我们将在本章重点讨论这个问题。我们将使用所有原则，这些原则同样适用于
    3D 物理中，这将节省我们在设置和工作中的麻烦。
- en: Setting up the development environment
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'To explore making a 2D game in a primarily 3D engine, and the use of physics,
    we will be recreating a highly popular 2D game, Angry Birds. However, before we
    can dive into the meat of the game, we need to set up our development environment
    so that we are optimized for 2D game creation. Let''s use these steps to do this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索在主要以 3D 引擎中制作 2D 游戏，以及物理的使用，我们将重新制作一个广受欢迎的 2D 游戏，愤怒的小鸟。然而，在我们深入游戏的核心之前，我们需要设置开发环境，以便我们为
    2D 游戏创作进行优化。让我们使用以下步骤来完成此操作：
- en: To begin with, we need to create a new project in Unity. Naming it `Ch7_AngryBirds`
    will work well. We also need to select **2D** under **Templates**, so all the
    defaults are set for our 2D game.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在 Unity 中创建一个新项目，将其命名为 `Ch7_AngryBirds` 非常合适。同时，我们还需要在 **模板** 下选择 **2D**，这样所有默认设置都会为我们的
    2D 游戏做好准备。
- en: We also need to be sure to change the target platform in the **Build Settings**
    field to **Android** and set **Bundle Identifier** to an appropriate value. We
    don't want to have to worry about this later.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要确保在 **构建设置** 字段中将目标平台更改为 **Android**，并将 **捆绑标识符** 设置为适当的值。我们不希望以后还要为此担心。
- en: There are a few differences that you will notice right away. First, you can
    only pan from side to side and up and down when moving around in the scene. This
    is a setting that can be toggled in the top-middle of the **Scene** view, by clicking
    on the little **2D** button. Also, if you select the camera in the **Hierarchy**
    window, you can see that it simply appears as a white box in the **Scene** view.
    This is because it has been defaulted to use the **Orthographic** mode for its
    **Projection** setting, which you can see in the **Inspector** panel.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会立即注意到一些不同之处。首先，在场景中移动时，你只能从左右和上下平移。这是一个可以在 **场景** 视图的顶部中间通过点击小 **2D** 按钮来切换的设置。此外，如果你在
    **层次结构** 窗口中选择了相机，你可以看到它在 **场景** 视图中仅显示为一个白色盒子。这是因为它的 **投影** 设置默认为使用 **正交** 模式，你可以在
    **检查器** 面板中看到这一点。
- en: Note
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every camera has two options for how to render the game. A perspective renders
    everything by utilizing their distance from the camera, imitating the real world;
    objects that are farther away from the camera are drawn smaller than objects that
    are closer. An orthographic camera renders everything without this consideration;
    objects are not scaled based on their distance from the camera.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个相机都有两个关于如何渲染游戏的选项。透视相机利用物体与相机的距离来渲染一切，模仿现实世界；距离相机较远的物体绘制得比距离较近的物体小。正交相机在渲染时不考虑这一点；物体的绘制不会基于它们与相机的距离而缩放。
- en: Next, we are going to need a ground. So, go to the menu bar of Unity and navigate
    to **GameObject** | **3D Object** | **Cube**. This will work well as a simple
    ground.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个地面。因此，请转到 Unity 的菜单栏，导航到 **GameObject** | **3D Object** | **Cube**。这将作为一个简单的地面非常合适。
- en: To make it look a little like a ground, create a green material and apply it
    to the **Cube** GameObject.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让它看起来有点像地面，创建一个绿色材质，并将其应用到 **Cube** GameObject 上。
- en: The ground cube needs to be large enough to cover the whole of our field of
    play. To do this, set the cube's **Scale** attribute to `100` for the **X** axis,
    `10` for the **Y** axis, and `5` for the **Z** axis. Also, set its **Position**
    attribute to `30` for the **X** axis, `-5` for the **Y** axis, and `0` for the
    **Z** axis. Since nothing will be moving along the *x* axis, the ground only needs
    to be large enough for the other objects that will be in our scene to land on.
    It does, however, need to be wide and tall enough to keep the camera from seeing
    the edges.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地面立方体需要足够大以覆盖我们的整个游戏区域。为此，将立方体的**缩放**属性设置为**X**轴上的`100`，**Y**轴上的`10`，以及**Z**轴上的`5`。同时，将它的**位置**属性设置为**X**轴上的`30`，**Y**轴上的`-5`，以及**Z**轴上的`0`。由于沿*x*轴不会有任何移动，地面只需要足够大以供我们场景中的其他物体着陆即可。但是，它需要足够宽和高，以防止摄像机看到边缘。
- en: To optimize our ground cube for use in our 2D game, we need to change its collider.
    Select the **Cube** GameObject in the **Hierarchy** window and take a look at
    it in the **Inspector** panel. Right-click on the **Box Collider** component and
    select **Remove Component**. Next, at the top of Unity, navigate to **Component**
    | **Physics 2D** | **Box Collider 2D**. This component works just like a normal
    **Box Collider** component, except that it does not have limited depth.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了优化我们2D游戏中地面的立方体，我们需要更改其碰撞器。在**层次结构**窗口中选择**Cube** GameObject，并在**检查器**面板中查看它。右键点击**Box
    Collider**组件，选择**移除组件**。接下来，在Unity顶部导航至**组件** | **物理2D** | **Box Collider 2D**。这个组件的工作原理与普通的**Box
    Collider**组件一样，只是它没有深度限制。
- en: Right now, the ground looks rather dark due to the lack of light. From the menu
    bar of Unity, navigate to **GameObject** | **Light** | **Directional Light** in
    order to add some brightness to the scene.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，由于缺乏光线，地面看起来相当暗。在Unity的菜单栏中，导航至**GameObject** | **Light** | **Directional
    Light**，以向场景中添加一些亮度。
- en: Next, we need to keep all the objects that will be flying around the scene from
    straying too far and causing problems. To do this, we need to create some trigger
    volumes. The simplest way to do this is to create three empty **GameObjects**
    and give each a **Box Collider 2D** component. Be sure to check the **Is Trigger**
    checkbox in order to change them into trigger volumes.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保所有将在场景中飞行的物体不会移动得太远，从而引发问题。为此，我们需要创建一些触发器体积。最简单的方法是创建三个空的**GameObjects**，并为每个分配一个**Box
    Collider 2D**组件。确保勾选**Is Trigger**复选框，将它们转换为触发器体积。
- en: Position one at each end of the ground object and the last GameObject at about
    50 units above. Then, scale them to form a box with the ground. Each should be
    no thicker than a single unit.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个放在地面物体的每个端部，最后一个GameObject大约在50个单位的高度上。然后，将它们缩放以与地面形成一个盒子。每个的厚度都不应超过一个单位。
- en: To make the volumes actually keep objects from straying too far, we need to
    create a new script. Create a new script and name it `GoneTooFar`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让体积实际上能够阻止物体移动得太远，我们需要创建一个新的脚本。创建一个新的脚本，并将其命名为`GoneTooFar`。
- en: 'This script has a single, short function, `OnTriggerEnter2D`. We use this function
    to destroy any object that might enter the volume. This function is used by Unity''s
    physics system to detect when an object has entered a trigger volume. We will
    go into more detail regarding this later, but for now, know that one of the two
    objects, either the volume or the object entering it, needs a **Rigidbody** component.
    In our case, everything that we might want to remove when they enter the trigger
    will have a **Rigidbody** component:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有一个单独的短函数，`OnTriggerEnter2D`。我们使用这个函数来销毁可能进入该体积的任何物体。这个函数被Unity的物理系统用来检测物体何时进入触发器体积。我们稍后会详细介绍这一点，但现在，需要知道两个对象中的一个，要么是体积本身，要么是进入它的物体，需要有一个**Rigidbody**组件。在我们的例子中，所有我们可能希望它们进入触发器时移除的东西都将具有**Rigidbody**组件：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, return to Unity and add the script to the three trigger-volume objects.![Setting
    up the development environment](img/4691OT_07_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到Unity并将脚本添加到三个触发器体积对象上。![设置开发环境](img/4691OT_07_01.jpg)
- en: We have done the initial setup for our 2D game. By changing the project type
    from **3D** to **2D**, defaults in Unity are changed to be optimized for 2D game
    creation. The most immediately noticeable thing is that the camera is now in the
    **Orthographic** view, making everything appear flattened. We also created a ground
    and some trigger volumes for our scene. Together, these will keep our birds and
    anything else from straying too far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的2D游戏完成了初步设置。通过将项目类型从**3D**更改为**2D**，Unity的默认设置会改变以优化2D游戏创作。最立即注意到的是，现在摄像机处于**正交**视图，使一切看起来都变得扁平。我们还为我们的场景创建了一个地面和一些触发器体积。这些将共同防止我们的鸟类和任何其他物体走得太远。
- en: Physics
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理
- en: In Unity, physics simulation primarily focuses on the use of the **Rigidbody**
    component. When the **Rigidbody** component is attached to any object, it will
    be taken over by the physics engine. The object will fall with gravity and bump
    into any object that has a collider. In our scripts, making use of the `OnCollision`
    group of functions and the `OnTrigger` group of functions requires a **Rigidbody**
    component to be attached to at least one of the two interacting objects. However,
    a **Rigidbody** component can interfere with any specific movement we might cause
    the object to take. But the **Rigidbody** component can be marked as kinematic,
    which means that the physics engine will not move it, but it will only move when
    our script moves it. The **CharacterController** component that we used for our
    tank is a special, modified **Rigidbody**. In this chapter, we will be making
    heavy use of the **Rigidbody** component to tie all our birds, blocks, and pigs
    into the physics engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，物理模拟主要关注**Rigidbody**组件的使用。当**Rigidbody**组件附加到任何对象上时，它将被物理引擎接管。该对象将受到重力影响下落，并撞击任何带有碰撞器的物体。在我们的脚本中，使用`OnCollision`函数组和`OnTrigger`函数组至少需要将**Rigidbody**组件附加到两个交互对象中的一个。然而，**Rigidbody**组件可能会干扰我们可能让对象进行的任何特定移动。但是，**Rigidbody**组件可以被标记为运动学，这意味着物理引擎不会移动它，只有当我们的脚本移动它时，它才会移动。我们用于坦克的**CharacterController**组件是一个特殊的、修改过的**Rigidbody**。在本章中，我们将大量使用**Rigidbody**组件，将我们的鸟类、块和猪与物理引擎连接起来。
- en: Building blocks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建块
- en: 'For our first physics objects, we will create the blocks that the pig castles
    are built out of. We will be creating three types of blocks: wood, glass, and
    rubber. With these few simple blocks, we will be able to easily create a large
    variety of levels and structures to be smashed with birds.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个物理对象是猪城堡所使用的块。我们会创建三种类型的块：木头、玻璃和橡胶。通过这些简单的块，我们可以轻松构建多种关卡和结构，供鸟类撞击破坏。
- en: 'Each of the blocks we will be creating will be largely similar. So, we will
    start with the basic one, the wooden plank, and expand upon it to create the others.
    Let''s use these steps to create the blocks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的每个块在很大程度上都相似。因此，我们将从基本的木制木板开始，然后在此基础上创建其他类型的块。让我们按照以下步骤来创建这些块：
- en: First, we will create the plank of wood. To do this, we need another cube. Rename
    it `Plank_Wood`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个木制木板。为此，我们需要另一个立方体。将其重命名为`Plank_Wood`。
- en: Set the value of the plank's **Scale** to `0.25` for the **X** axis and `2`
    for both the **Y** and **Z** axes. Its scale on the *x* and *y* axes defines its
    size as seen by the player. The scale on the *z* axis helps us ensure that it
    will be hit by other physics objects in the scene.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将木板的**缩放**值设置为**X轴**的`0.25`和**Y轴和Z轴**的`2`。它在*x*和*y*轴上的缩放定义了玩家看到的大小。在*z*轴上的缩放有助于确保它会被场景中的其他物理对象击中。
- en: Next, create a new material using the `plank_wood` texture and apply it to the
    cube.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`plank_wood`纹理创建一个新材质，并将其应用到立方体上。
- en: To make this new wooden plank into a physics object suitable for our game, we
    need to remove the cube's **Box Collider** component and replace it with a **Box
    Collider 2D** component. Also, add a **Rigidbody** component. Make sure that your
    plank is selected; go to the menu bar of Unity and navigate to **Component** |
    **Physics 2D** | **Rigidbody 2D**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将这个新的木制木板转变为适合我们游戏的物理对象，我们需要移除立方体的**Box Collider**组件，并替换为**Box Collider 2D**组件。同时，添加一个**Rigidbody**组件。确保你的木板被选中；在Unity的菜单栏中，导航到**组件**
    | **物理2D** | **Rigidbody 2D**。
- en: Next, we need to make the plank function properly within our game; we need to
    create a new script and name it `Plank`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要让木板在我们的游戏中正常工作；我们需要创建一个新脚本，并将其命名为`Plank`。
- en: 'This script begins with a bunch of variables. The first two variables are used
    to track the health of the plank. We need to separate the total amount of health
    from the current health, so that we will be able to detect when the object has
    been reduced to its half-health. At this point, we will make use of our next three
    variables to change the object''s material to one that shows damage. The last
    variable is used when the object runs out of health and is destroyed. We will
    use it to increase the player''s score:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本以一堆变量开始。前两个变量用于跟踪木板的血量。我们需要将总血量与当前血量分开，这样当对象被削弱到一半血量时，我们就能检测到。在这一点上，我们将使用接下来的三个变量来更改对象材质以显示损坏。最后一个变量用于对象耗尽血量并被销毁时。我们将使用它来增加玩家的得分：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the script''s first function, we use `Awake` for initialization. We make
    sure that the object''s current health is the same as its total health and the
    `didSwap` flag is set to `false`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于脚本的第一个功能，我们使用`Awake`进行初始化。确保对象当前的血量与其总血量相同，并将`didSwap`标志设置为`false`：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we make use of the `OnCollisionEnter2D` function, which is just the 2D
    optimized version of the normal `OnCollisionEnter` function used in 3D. This is
    a special function, triggered by the **Rigidbody** component, that gives us information
    about what the object collided with and how. We use this information to find `collision.relativeVelocity.magnitude`.
    This is the speed at which the objects collided, and we use this as damage in
    order to reduce the current health. Next, the function checks to see whether the
    health has been reduced to half and calls the `SwapToDamaged` function if it has.
    By using the `didSwap` flag, we make sure that the function is only called once.
    Finally, the function checks to see whether the health has dropped below zero.
    If it has, the object is destroyed and we call the `LevelTracker` script, which
    we will soon be making, to add to the player''s score:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`OnCollisionEnter2D`函数，这是通常在3D中使用的`OnCollisionEnter`函数的2D优化版本。这是一个特殊函数，由**Rigidbody**组件触发，为我们提供了关于对象与何物碰撞以及如何碰撞的信息。我们使用这些信息来查找`collision.relativeVelocity.magnitude`。这是物体碰撞的速度，我们将其用作伤害以减少当前血量。接下来，函数检查血量是否已经减少到一半，如果是，则调用`SwapToDamaged`函数。通过使用`didSwap`标志，我们确保该函数只被调用一次。最后，函数检查血量是否降至零以下。如果是，对象将被销毁，我们调用`LevelTracker`脚本（我们很快就会制作）以增加玩家的得分：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, for the script, we have the `SwapToDamaged` function. It starts by
    setting the `didSwap` flag to `true`. Next, it checks to make sure that the `plankRenderer`
    and `damageMaterial` variables have references to other objects. Ultimately, it
    uses the `plankRenderer.sharedMaterial` value to change the material to the damaged-looking
    material:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于脚本，我们有`SwapToDamaged`函数。它首先将`didSwap`标志设置为`true`。接下来，它检查以确保`plankRenderer`和`damageMaterial`变量有对其他对象的引用。最终，它使用`plankRenderer.sharedMaterial`值将材质更改为看起来损坏的材质：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we can add our `Plank` script to our objects, we need to create the `LevelTracker`
    script that was mentioned earlier. Create it now.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将我们的`Plank`脚本添加到对象之前，我们需要创建之前提到的`LevelTracker`脚本。现在创建它。
- en: 'This script is fairly short and starts with a single variable. The variable
    will track the player''s score for the level and is static, so it can easily be
    changed as objects are destroyed, for points:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本相当简短，从单个变量开始。该变量将跟踪玩家在当前关卡的得分，是静态的，因此当对象被销毁时可以轻松更改得分：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we use the `Awake` function to make sure the player starts at zero when
    beginning a level:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Awake`函数以确保玩家在开始关卡时从零开始：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, for the script, we add the `AddScore` function. This function simply
    takes the amount of points passed to it and increases the player''s score. It
    is also static, so it can be called by any object in the scene without needing
    a reference to the script:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于脚本，我们添加了`AddScore`函数。这个函数简单地接收传递给它的分数并增加玩家的得分。它也是静态的，所以它可以在场景中的任何对象上被调用，而无需引用脚本：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Back in Unity, we need to create a new material using the `plank_wood_damaged`
    texture. This will be the material that the script will swap to.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，我们需要使用`plank_wood_damaged`纹理创建一个新材质。这将是脚本将切换到的材质。
- en: We need to add the `Plank` script to our `Plank_Wood` object. Connect the **Damaged
    Material** reference to the new material and the **Plank Renderer** reference
    to the object's **Mesh Renderer** component.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`Plank`脚本添加到我们的`Plank_Wood`对象中。将**Damaged Material**引用连接到新材质，将**Plank Renderer**引用连接到对象的**Mesh
    Renderer**组件。
- en: As we create different types of planks, we can adjust the value of **Total Health**
    to give them different strengths. A value of `25` works pretty well for the wood
    planks.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建不同类型的板子时，可以调整**总健康值**来赋予它们不同的强度。木板的这个值设为`25`效果相当不错。
- en: Next, create an empty **GameObject** and rename it `LevelTracker`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个空的**GameObject**，并将其重命名为`LevelTracker`。
- en: Add the `LevelTracker` script to the object, and it will begin to track the
    player's score.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LevelTracker`脚本添加到对象上，它将开始跟踪玩家的分数。
- en: If you want to see the wood plank in action, position it above the ground and
    hit the play button. As soon as the game starts, Unity's physics will take over
    and drop the plank with gravity. If it started out high enough, you will be able
    to see it switch textures as it loses health.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想看到木板的实际效果，将其定位在地面上方，然后点击播放按钮。游戏一开始，Unity的物理引擎就会接管，并让板子受重力落下。如果它一开始足够高，你将能够看到它在失去生命值时切换纹理。
- en: To make the other two planks that we need, select the `Plank_Wood` object and
    press *Ctrl* + *D* twice to duplicate it. Rename one plank to `Plank_Glass` and
    the other to `Plank_Rubber`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了制作我们需要的另外两种板子，选择`Plank_Wood`对象，并按*Ctrl* + *D*两次进行复制。将其中一个板子重命名为`Plank_Glass`，另一个重命名为`Plank_Rubber`。
- en: Next, create three new materials. One should be purple in color for the rubber
    plank, one should use the `plank_glass` texture for the glass plank, and the last
    material should use the `plank_glass_damaged` texture for when the glass plank
    is damaged. Apply the new materials to the proper locations for the new planks.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建三种新材料。一种是用于橡胶板，颜色应为紫色；另一种应使用`plank_glass`纹理，用于玻璃板；最后一种材料在玻璃板损坏时应使用`plank_glass_damaged`纹理。将新材料应用到新板子的适当位置。
- en: As for the health of the new planks, a value of `15` for the glass and `100`
    for the rubber will work well.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于新板子的生命值，玻璃的值设为`15`，橡胶的值设为`100`效果会很好。
- en: Finally, turn your three planks into prefabs and use them to build a structure
    for you to knock down. Feel free to scale them in order to make differently sized
    blocks, but leave the *z* axis alone. Also, all of the blocks should be positioned
    at `0` on the *z* axis and your structure should be centered around about `30`
    on the *x* axis.![Building blocks](img/4691OT_07_02.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将这三种板子转换为预制体，并使用它们构建一个待击倒的结构。可以自由缩放它们以制作不同大小的块，但不要改变*z*轴。此外，所有块都应该在*z*轴上定位为`0`，而你的结构应该在大约*x*轴上的`30`为中心点。![构建块](img/4691OT_07_02.jpg)
- en: We have created the building blocks we needed for the structures that are going
    to be knocked down in our game. We used a **Rigidbody** component to tie them
    into the physics engine. Also, we created a script that keeps track of their health
    and swaps to damaged materials when it drops below half. For this game, we are
    sticking to the 2D optimized versions of all the physics components. They work
    in exactly the same way as the 3D versions, just without the third axis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为游戏中将要被击倒的结构创建了所需的构建块。我们使用了**Rigidbody**组件将它们与物理引擎连接起来。同时，我们还创建了一个跟踪它们生命值的脚本，并在生命值降至一半以下时切换到损坏的材料。对于这个游戏，我们坚持使用所有物理组件的2D优化版本。它们的工作方式与3D版本完全相同，只是没有第三个坐标轴。
- en: Wood and glass work well as basic blocks. However, if we are going to make harder
    levels, we need something a little stronger. Try your hand at making a stone block.
    Create two textures and materials for it to show its pristine and damaged states.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 木材和玻璃作为基本块非常适用。然而，如果我们打算制作更难的关卡，我们需要一些更坚固的材料。尝试制作一个石块。为其创建两种纹理和材料，以展示其原始和损坏的状态。
- en: Physics materials
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理材料
- en: 'Physics materials are special types of materials that specifically tell the
    physics engine how two objects should interact. This does not affect the appearance
    of an object. It defines the friction and bounciness of a collider. We will use
    them to give our rubber plank some bounce and the glass plank some slide. With
    these few steps, we can quickly implement physics materials to create a pleasing
    effect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 物理材料是一种特殊的材料，它专门告诉物理引擎两个物体应该如何交互。这不会影响物体的外观。它定义了碰撞体的摩擦力和弹性。我们将使用它们让橡胶板具有弹性，让玻璃板具有滑动性。通过这几个步骤，我们可以快速实现物理材料，创建出令人满意的效果：
- en: Physics materials are created in the same way as everything else, in the **Project**
    panel. Right-click inside the **Project** panel and navigate to **Create** | **Physics2D
    Material**. Create two physics materials and name one of them `Glass` and the
    other `Rubber`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理材料与其它所有内容的创建方式相同，即在**项目**面板中创建。在**项目**面板内右键点击，导航至**创建** | **2D物理材料**。创建两个物理材料，将其中一个命名为`Glass`，另一个命名为`Rubber`。
- en: 'Select one of them and take a look at it in the **Inspector** window. The 2D
    version has only two values (the 3D version has a few extra values, but they are
    only used in more complex situations):'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其中一个，并在**检查器**窗口中查看它。2D版本只有两个值（3D版本有一些额外的值，但它们只在更复杂的情况下使用）：
- en: '**Friction**: This property controls the amount of movement lost when sliding
    along a surface. A value of zero denotes no friction, such as ice, and a value
    of one denotes a lot of friction, such as rubber.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦力**：这个属性控制沿着表面滑动时失去的运动量。值为零表示没有摩擦力，比如冰；值为一时表示摩擦力很大，比如橡胶。'
- en: '**Bounciness**: This property is how much of an object''s energy is reflected
    when it hits something or is hit by something. Zero means none of the energy is
    reflected, while a value of one means the object will reflect all of it.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这个属性指的是物体在撞击其他物体或被撞击时，有多少能量会被反射回来。零表示没有能量被反射，而值为一时，物体将反射所有能量。'
- en: For the `Glass` material, set the **Friction** value to `0.1` and **Bounciness**
    to `0`. For the `Rubber` material, set the **Friction** to `1` and **Bounciness**
    to `0.8`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Glass`材料，将**摩擦力**值设为`0.1`，**弹性**设为`0`。对于`Rubber`材料，将**摩擦力**设为`1`，**弹性**设为`0.8`。
- en: Next, select your `Plank_Glass` prefab and take a look at its **Box Collider
    2D** component. To apply your new physics materials, simply drag and drop them
    one by one from the **Project** panel to the **Material** slot. Do the same for
    your `Plank_Rubber` prefab, and any time an object hits one of them, the materials
    will be used to control their interaction.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择你的`Plank_Glass`预制体，并查看其**Box Collider 2D**组件。要应用你的新物理材料，只需从**项目**面板逐个拖放它们到**材质**槽中。对你的`Plank_Rubber`预制体做同样的操作，任何时候有物体撞击它们之一，这些材料都将用来控制它们的交互。
- en: We have created a pair of physics materials. They control how two colliders
    interact when they run into each other. Using these, we are given control over
    the amount of friction and bounciness that is possessed by any collider.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一对物理材料。它们控制两个碰撞体在相互碰撞时的交互方式。使用这些材料，我们可以控制任何碰撞体拥有的摩擦力和弹性。
- en: Characters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: Having a bunch of generic blocks is just the beginning of this game. Next, we
    are going to create a few characters to add some life to the game. We are going
    to need some evil pigs to destroy and some good birds to throw at them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一堆通用块只是这个游戏的开始。接下来，我们将创建一些角色来为游戏增添活力。我们需要一些邪恶的猪来摧毁，还需要一些好的鸟来投向它们。
- en: Creating the enemy
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌人
- en: 'Our first character will be the enemy pig. On their own, they don''t actually
    do anything. So, they are really just the wooden blocks we made earlier that happen
    to look like pigs. To make their destruction the goal of the game, however, we
    are going to expand our `LevelTracker` script to watch them and trigger a **Game
    Over** event if they are all destroyed. We will also expand the script to update
    the score on the screen and make it save the score for later use. Unlike our planks,
    which are cubes that we can only see one side of, pigs are created as flat textures
    and are used as sprites by Unity''s 2D pipeline. Let''s get started with these
    steps to create the pigs for our *Angry Birds* game:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首个角色将是敌人猪。它们本身实际上什么都不做。所以，它们实际上只是我们之前制作的看起来像猪的木块。然而，为了使它们的毁灭成为游戏的目标，我们将扩展我们的`LevelTracker`脚本来监视它们，如果它们全部被摧毁，则触发**游戏结束**事件。我们还将扩展脚本以在屏幕上更新分数，并将其保存以供以后使用。与只能看到一面的立方体木板不同，猪是作为平面纹理创建的，并由Unity的2D管线作为精灵使用。下面是创建我们*愤怒的小鸟*游戏中的猪的步骤：
- en: The pigs are created in a manner similar to that of the wood planks; however,
    they use a special 2D object called a sprite. A sprite is really just a flat object
    that always looks at the screen. Most 2D games are made with just a series of
    sprites for all the objects. You can create one by navigating to **GameObject**
    | **2D Object** | **Sprite**. Name it `Pig`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 猪的创建方式与木板的创建方式相似；但是，它们使用了一个特殊的2D对象，称为精灵。精灵实际上只是一个始终面向屏幕的平面物体。大多数2D游戏都是用一系列的精灵来制作所有对象。你可以通过导航至**游戏对象**
    | **2D对象** | **精灵**来创建一个。将其命名为`Pig`。
- en: To make your new sprite look like a pig, drag the `pig_fresh` image from the
    **Project** panel and drop it into the **Sprite** slot of the **Sprite Renderer**
    component.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让新的精灵看起来像只猪，从**项目**面板中拖动`pig_fresh`图像，并将其拖放到**Sprite Renderer**组件的**Sprite**槽中。
- en: Next, add a **Circle Collider 2D** component and a **Rigidbody 2D** component.
    The **Circle Collider 2D** component works just like the **Sphere Collider** components
    we have used previously but is optimized for working in a 2D game.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个**Circle Collider 2D**组件和一个**Rigidbody 2D**组件。**Circle Collider 2D**组件与我们之前使用的**Sphere
    Collider**组件类似，但它是为在2D游戏中工作而优化的。
- en: 'Before we can use our pigs in the game, we need to update the `Plank` script
    so that it can handle the changing of sprite images as well as materials. So,
    we open it up and add a variable at the beginning. This variable simply keeps
    track of which sprite to change to:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够在游戏中使用猪之前，我们需要更新`Plank`脚本，使其能够处理精灵图像以及材质的变化。因此，我们打开它并在开始处添加一个变量。这个变量简单地跟踪要切换到哪个精灵：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to add a small part to the end of our `SwapToDamaged` function.
    This `if` statement checks whether a sprite is available to change into. If it
    is, we convert our generic renderer variable into `SpriteRenderer` so that we
    can get access to the `sprite` variable on it, and update to our new image:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`SwapToDamaged`函数的末尾添加一小部分代码。这个`if`语句检查是否有可切换的精灵。如果有，我们将通用的渲染器变量转换为`SpriteRenderer`，这样我们就可以访问它上面的`sprite`变量，并更新为新图像：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add the `Plank` script to the pig and fill in the **Plank Renderer** slot with
    the **Sprite Renderer** component. Also, put the `pig_damage` image in the **Damage
    Sprite** slot. By changing this script a little, we will be able to save ourselves
    a lot of trouble later, when we may perhaps want to track the destruction of more
    than just pigs.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Plank`脚本添加到猪身上，并用**Sprite Renderer**组件填充**Plank Renderer**槽。同时，将`pig_damage`图像放入**Damage
    Sprite**槽中。通过稍微修改这个脚本，我们可以在之后节省很多麻烦，比如当我们可能想要追踪不仅仅是猪的摧毁情况时。
- en: Now, turn the pig into a prefab and add it to your structure. Remember that
    you need to leave them at zero on the *z* axis, but feel free to adjust their
    size, health and score values to give them some variety.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将猪转换成预制体并添加到你的结构中。记住，你需要将它们在*z*轴上的位置设为零，但你可以随意调整它们的大小、健康值和分数值，以增加一些多样性。
- en: Next, we need to expand the `LevelTracker` script. Open it up and we can add
    some more code.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要扩展`LevelTracker`脚本。打开它，我们可以添加一些更多的代码。
- en: 'First, we need to add a line at the very beginning of the script, so we can
    edit the text displayed in our GUI. Just like we have done previously, add this
    line at the very top of the script, where the other two lines that begin with
    `using` are:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在脚本的最开始添加一行，这样我们就可以编辑在GUI中显示的文本。就像我们之前做的那样，在脚本的最顶部添加这一行，那里还有以`using`开头的另外两行：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will next add some more variables at the beginning of the script. The first
    one, as its name suggests, will hold a list of all the pigs in our scene. The
    next is a flag for signaling that the game has ended. We also have three `Text`
    variables, so we can update the player''s score while they are playing, tell them
    why the game ended, and what their final score was. The last variable will allow
    you to turn on and turn off the final screen, where we tell the player whether
    or not they won:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在脚本的开始处添加一些变量。第一个变量，顾名思义，将保存我们场景中所有的猪的列表。下一个是一个标志，用来表示游戏已经结束。我们还有三个`Text`变量，以便在玩家玩游戏时更新他们的分数，告诉他们游戏结束的原因以及他们的最终得分。最后一个变量将允许你打开或关闭最后的屏幕，告诉玩家他们是否赢了：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to add a line to the `Awake` function. This simply makes sure
    that the group of GUI objects that tell the player how the game ended are turned
    off when the game starts:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Awake`函数中添加一行。这确保了在游戏开始时，告诉玩家游戏如何结束的GUI对象组是关闭的：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `LateUpdate` function, we first check whether the game has ended. If
    it hasn''t, we call another function to check whether all the pigs have been destroyed.
    We also update the display of the player''s score, both while they are playing
    and for the game over screen:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LateUpdate`函数中，我们首先检查游戏是否已经结束。如果没有，我们调用另一个函数来检查是否所有的猪都被摧毁了。同时，我们更新玩家的分数显示，无论是在游戏进行中还是游戏结束屏幕上：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we add the `CheckPigs` function. This function loops through the list
    of pigs to see whether they are all destroyed. Should it find one that hasn''t
    been destroyed, it exits the function. Otherwise, the game is flagged as being
    over and the player is given a message. We also turn off the in-game score and
    turn on the game over a group of GUI objects:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `CheckPigs` 函数。这个函数遍历猪的列表，查看它们是否都被摧毁。如果它发现有一个没有被摧毁，就会退出函数。否则，游戏被标记为结束，并给玩家一条信息。我们还会关闭游戏内得分并开启游戏结束的一组GUI对象：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `OutOfBirds` function will be called by the slingshot we are going to create
    later, when the player runs out of birds to launch at the pigs. If the game has
    not yet ended, the function ends the game and sets an appropriate message for
    the player. It also turns off the in-game score and turns on the game over a group
    of GUI objects, just like the previous function:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OutOfBirds` 函数将由我们稍后要创建的弹弓调用，当玩家没有鸟可以发射到猪身上时。如果游戏尚未结束，该函数将结束游戏并为玩家设置适当的信息。它还会关闭游戏内得分，并开启游戏结束的一组GUI对象，就像前一个函数一样：'
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have the `SaveScore` function. Here, we use the `PlayerPrefs` class.
    It lets you easily store and retrieve small amounts of data, perfect for our current
    needs. We just need to provide it with a unique key to save the data under. For
    this, we use a short string combined with the level''s index, as provided by `Application.loadedLevel`.
    Next, we use `PlayerPrefs.GetInt` to retrieve the last score that was saved. If
    there isn''t one, the zero that we passed to the function is returned as a default
    value. We compare the new score with the old score and use `PlayerPrefs.SetInt`
    to save the new score, if it is higher. Finally, the `Application.LoadLevel` function
    can be used to load any other scene in our game. All the scenes you intend to
    load have to be added to the **Build Settings** window, found in the **File**
    menu, and can be loaded by using either their name or their index, as shown here:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `SaveScore` 函数。这里我们使用 `PlayerPrefs` 类。它让你可以轻松地存储和检索少量数据，非常适合我们当前的需求。我们只需要提供一个唯一的键来保存数据。为此，我们使用一个简短字符串与
    `Application.loadedLevel` 提供的关卡索引组合。接下来，我们使用 `PlayerPrefs.GetInt` 来检索上次保存的分数。如果没有，则返回我们传递给函数的零作为默认值。我们将新分数与旧分数进行比较，并使用
    `PlayerPrefs.SetInt` 来保存更高的新分数。最后，`Application.LoadLevel` 函数可以用来加载我们游戏中的任何其他场景。所有你打算加载的场景都必须添加到**文件**菜单中的**构建设置**窗口中，并且可以通过使用它们的名称或索引来加载，如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that using `PlayerPrefs` is by far the easiest method of storing saved
    information in Unity. However, it is not the most secure. If you have experience
    changing values in the registry of your computer, you can easily find and make
    changes to these `PlayerPrefs` values from outside the game. This by no means
    makes it a bad path for storing game information. You should just be aware of
    it in case you ever make a game and wish to prevent the player from hacking and
    changing values in their game saves.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，使用 `PlayerPrefs` 是在Unity中存储保存信息的最简单方法。然而，它并不是最安全的。如果你有在计算机注册表中更改值的经验，你可以轻松地从游戏外部找到并更改这些
    `PlayerPrefs` 值。这并不意味着它不适合存储游戏信息。你只需要意识到这一点，以防你制作游戏时希望防止玩家黑客攻击并更改游戏存档中的值。
- en: Next, we need to create some GUI objects so that our player can see how they
    are doing in the game. Remember that you can find them by navigating to **GameObject**
    | **UI**. We are going to need three text objects, a button, and a panel.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一些GUI对象，以便玩家在游戏中了解自己的表现。记得你可以通过导航到**GameObject** | **UI**来找到它们。我们将需要三个文本对象、一个按钮和一个面板。
- en: The first text object should be named `Score`. It will display the player's
    points while the level is in progress. Anchor and position it in the top-left
    corner of the **Canvas** area.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个文本对象应命名为 `Score`。它将在关卡进行时显示玩家的得分。将其锚定在**画布**区域的左上角。
- en: The button needs to be a child of the panel. It should be anchored to the center
    of the screen and positioned just below it. Also, change the text of the button
    to something meaningful; `Return to Level Select` will work well here.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮需要成为面板的子对象。它应该锚定在屏幕中心，位置稍低于中心。同时，将按钮的文本更改为有意义的文字；这里使用`返回关卡选择`会很合适。
- en: For **On Click**, we need to click on the plus sign to add a new event. Select
    the `SaveScore` function of the `LevelTracker` script. Otherwise, we will not
    be able to record the player's high score and leave the level.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**点击操作**，我们需要点击加号来添加新的事件。选择`LevelTracker`脚本的`SaveScore`函数。否则，我们将无法记录玩家的最高分并结束关卡。
- en: The last two text objects should also be made children of the panel. Name one
    of them `Message`; it will tell our player why the level ended. The other should
    be named `FinalScore`, displaying the player's score when they are finished. They
    both need to be anchored to the center of the screen as well. Position the `FinalScore`
    object above the button, and the message above that.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个文本对象也应该被设置为面板的子对象。其中一个命名为`Message`；它会告诉玩家关卡结束的原因。另一个应命名为`FinalScore`，在玩家完成时显示他们的得分。它们都需要锚定在屏幕中心，同时将`FinalScore`对象放置在按钮上方，消息在它的上方。
- en: Finally, all the pig objects in our scene need to be added to the `LevelTracker`
    script's list by dragging and dropping each pig in the `Pigs` value under the
    **Inspector** window. Also, put each text object into its slot and the panel into
    the **Final Group** slot.![Creating the enemy](img/4691OT_07_03.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们场景中所有的猪对象都需要通过拖放每个猪到**检查器**窗口下的`Pigs`值来添加到`LevelTracker`脚本的列表中。同时，将每个文本对象放入其槽位，并将面板放入**最终组**槽位中。![创建敌人](img/4691OT_07_03.jpg)
- en: We created the pigs and updated our `LevelTracker` script to track them. The
    pigs are really just like the planks of wood, but they are circles instead of
    boxes. The updated `LevelTracker` script watches for the instance when all the
    pigs are destroyed and triggers a **Game Over** screen when they are. It also
    draws the score while the game is being played and saves this score when the level
    is over.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了猪，并更新了`LevelTracker`脚本来跟踪它们。这些猪实际上就像木板，但它们是圆形而不是盒子。更新的`LevelTracker`脚本监听所有猪被摧毁的实例，并在那时触发**游戏结束**屏幕。它还在游戏进行时绘制分数，并在关卡结束时保存这个分数。
- en: Our game doesn't quite work yet, but that doesn't mean it has to to look like
    the defaults that Unity provides. Use your skills from the previous chapters to
    make the interface elements that you have look better. Even just a change in the
    font will make a world of difference to how our game looks. Perhaps even try changing
    the background image of `Panel`, to add that last bit of flare to our game over
    screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏还没有完全运作起来，但这并不意味着它必须看起来像Unity提供的默认设置。使用你之前章节的技能，让已有的界面元素看起来更好。即使只是改变字体，也会让我们的游戏看起来大不相同。也许甚至尝试更改`Panel`的背景图像，为我们的游戏结束屏幕添加最后的亮点。
- en: Creating the ally
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建盟友
- en: 'Next, we need something to throw at the pigs and their fortifications. Here,
    we will create the simplest of birds. The red bird is essentially just a rock.
    It has no special powers and there is nothing particularly special about its code,
    besides health. You will also notice that the bird is a 3D model, giving it the
    shadows that the pigs are missing. Let''s use these steps to create the red bird:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些东西来投掷向猪和它们的防御工事。这里，我们将创建最简单的红鸟。红鸟本质上只是一个石头。它没有特殊能力，除了生命值之外，它的代码也没有特别之处。你还会注意到，鸟是一个3D模型，这使它拥有了猪所缺少的阴影。让我们按照以下步骤来创建红鸟：
- en: The red bird is another 3D model, so it is set up in a manner similar to that
    of the planks. Create an empty **GameObject**, naming it `Bird_Red`, and add the
    appropriate model from the `birds` model as a child, zeroing out its position
    and scaling it as needed to make it about a single unit across. The model should
    be rotated to align it along the *x* axis. If turned a little more toward the
    camera, the player is able to see the bird's face while still giving the impression
    of looking down the field of play.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红鸟是另一个3D模型，因此它的设置方式与木板类似。创建一个空的**游戏对象**，将其命名为`Bird_Red`，并将适当的模型从`birds`模型中作为子对象添加，将其位置和缩放调整到大约一个单位大小，并将模型沿*x*轴旋转对齐。如果稍微向摄像机方向旋转，玩家就能看到鸟的脸，同时仍然能够给玩家在看向游戏场地的印象。
- en: Next, give it a **Circle Collider 2D** component and a **Rigidbody 2D** component.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，给它一个**圆形碰撞器 2D**组件和一个**刚体 2D**组件。
- en: Now, we need to create a new script named `Bird`. This script will be a base
    for all our birds, tracking their health and triggering their special powers when
    appropriate.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为`Bird`的新脚本。这个脚本将成为我们所有鸟的基础，跟踪它们的生命值并在适当的时候触发它们的特殊能力。
- en: 'The script starts with three variables. The first will keep track of the bird''s
    current health. The second is a flag, so the bird will only use its special power
    once. It is marked as `protected` so that all our birds can use it while protecting
    it from interference from outside sources. The last will hold a reference to our
    **Rigidbody** component:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本从三个变量开始。第一个将跟踪鸟类的当前生命值。第二个是一个标志，这样鸟类只会使用一次特殊能力。它被标记为`protected`，这样我们的所有鸟类都可以使用它，同时防止外部干扰。最后一个将保存对我们**刚体**组件的引用：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Update` function does three checks before activating the bird''s special
    power. First, it checks whether it has already been done and then whether the
    screen has been touched. We can easily check whether any amount of touching has
    been done in this frame by checking the left mouse button, which Unity triggers
    if we touch our screen. Finally, it checks whether the bird has a **Rigidbody**
    component and whether it is being controlled by another script:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update`函数在激活鸟类的特殊能力之前会进行三次检查。首先，它会检查是否已经完成，然后检查屏幕是否被触摸。我们可以通过检查左键鼠标来轻松检查在本帧中是否进行了触摸操作，Unity在我们触摸屏幕时会触发这个动作。最后，它会检查鸟类是否有**刚体**组件，以及是否被其他脚本控制：'
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the case of the red bird, the `DoSpecial` function only sets its flag to
    `true`. It is marked as `virtual` so that we can override the function for the
    other birds and make them do some fancy things:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于红鸟来说，`DoSpecial`函数仅将其标志设置为`true`。它被标记为`virtual`，这样我们就可以为其他鸟类重写该函数，让它们做一些花哨的事情：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `OnCollisionEnter2D` function works in a similar way to that of the planks,
    subtracting health based on the strength of the collision and destroying the bird
    if it runs out of health:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter2D`函数与木板类似，根据碰撞的强度减少生命值，并在生命值耗尽时销毁鸟类：'
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Return to Unity and add the script to the `Bird_Red` object.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，并将脚本添加到`Bird_Red`对象。
- en: Complete the bird's creation by turning it into a prefab and deleting it from
    the scene. The slingshot we will be creating next will handle the creation of
    the birds when the game starts.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成鸟类创建的过程，将其转化为预制体，并从场景中删除。接下来我们将创建的弹弓会在游戏开始时处理鸟类的创建。
- en: We created the red bird. It is set up just like our other physics objects. We
    also created a script to handle the bird's health. This script will be expanded
    later when we create the other birds for our game.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一只红鸟。它的设置与我们其他的物理对象一样。我们还创建了一个脚本来处理鸟的生命值。这个脚本将在我们为游戏创建其他鸟类时进一步扩展。
- en: Controls
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制
- en: Next, we are going to give the player the ability to interact with the game.
    First, we will create a slingshot to throw the birds. Following that we will create
    the camera controls. We will even create a nice background effect to round out
    the look of our game.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将赋予玩家与游戏互动的能力。首先，我们将创建一个弹弓来投掷鸟类。之后，我们将创建相机控制。我们甚至将创建一个漂亮的背景效果，使我们的游戏外观更加完善。
- en: Attacking with a slingshot
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用弹弓攻击
- en: 'To attack the pig fortress, we have our basic bird ammo. We need to create
    a slingshot to hurl this ammo at the pigs. It will also handle the spawning of
    the birds at the beginning of the level and automatically reload as birds are
    used. When the slingshot runs out of birds, it will notify the `LevelTracker`
    script and the game will end. Finally, we will create a script that will keep
    the physics simulation from going on for too long. We don''t want to force the
    player to sit and watch a pig slowly roll across the screen. So, the script will,
    after a little while, start damping the movement of the **Rigidbody** components
    to make them stop rather than keep rolling. To do all of this, we are going to
    follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了攻击猪堡垒，我们有了基本的鸟类弹药。我们需要创建一个弹弓，将这种弹药投向猪。它还将处理在关卡开始时生成鸟类，并在使用鸟类后自动重新装填。当弹弓中没有鸟类时，它会通知`LevelTracker`脚本，游戏将结束。最后，我们将创建一个脚本来防止物理模拟持续过长时间。我们不想让玩家坐下来观看一只猪慢慢滚过屏幕。因此，脚本会在一段时间后开始减弱**刚体**组件的运动，使它们停下来，而不是继续滚动。为了完成所有这些工作，我们将按照以下步骤进行：
- en: To start off with the creation of the slingshot, add the slingshot model to
    the scene and position it at the origin. Scale it, as necessary, to make it about
    four units tall. Apply a light brown material to the `Fork` model and a dark brown
    one to the `Pouch` model.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始创建弹弓，将弹弓模型添加到场景中，并将其定位在原点。如有必要，将其缩放到大约四个单位的高度。为`Fork`模型应用浅棕色材质，为`Pouch`模型应用深棕色材质。
- en: Next, we need four empty GameObjects. Make them all the children of the `Slingshot`
    object.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要四个空的GameObject。将它们都设置为`Slingshot`对象的子对象。
- en: Name the first GameObject `FocalPoint` and center it between the forked prongs
    of the slingshot. This will be the point through which we fire all the birds.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将第一个GameObject命名为`FocalPoint`，并将其放置在弹弓叉齿之间。这将是我们发射所有鸟的中心点。
- en: The second GameObject is `Pouch`. First, set its rotation to `0` for the **X**
    axis, `90` for the **Y** axis, and `0` for the **Z** axis, making the blue arrow
    point forward along our field of play. Next, make the `pouch` model a child of
    this object, setting its position to `0` on the **X** and **Y** axes and `-0.5`
    on the **Z** axis and its rotation to `270` for **X**, `90` for **Y**, and `0`
    for **Z**. This will make the pouch appear in front of the current bird without
    having to make a complete pouch model.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个GameObject是`Pouch`。首先，将其**X轴**的旋转设置为`0`，**Y轴**的旋转设置为`90`，**Z轴**的旋转设置为`0`，使蓝色箭头沿着我们的游戏场指向前方。接下来，将`pouch`模型设置为该对象的子对象，将其**X轴和Y轴**的位置设置为`0`，**Z轴**的位置设置为`-0.5`，旋转设置为**X轴**的`270`度，**Y轴**的`90`度，**Z轴**的`0`度。这样，在不制作完整的袋子模型的情况下，袋子将出现在当前鸟的前面。
- en: The third GameObject is `BirdPoint`; this will position the bird that is being
    fired. Make it a child of the `Pouch` point and set its position to `0.3` on the
    **X** axis and `0` for the **Y** and **Z** axes.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个GameObject是`BirdPoint`；这将定位正在发射的鸟的位置。将其设置为`Pouch`点的子对象，并将其**X轴**的位置设置为`0.3`，**Y轴**和**Z轴**的位置设置为`0`。
- en: The last GameObject is `WaitPoint`; the birds waiting to be fired will be positioned
    behind this point. Set its position to `-4` for the **X** axis, `0.5` for the
    **Y** axis, and `0` for the **Z** axis.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个GameObject是`WaitPoint`；待发射的鸟将位于这个点后面。将其**X轴**的位置设置为`-4`，**Y轴**的位置设置为`0.5`，**Z轴**的位置设置为`0`。
- en: Next, rotate the `Fork` model so that we can see both prongs of the fork while
    it appears to be pointing forward. The values of `270` for the **X** axis, `290`
    for the **Y** axis, and `0` for the **Z** axis will work well.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，旋转`Fork`模型，以便我们能够看到叉子的两个叉齿，同时它看起来是指向前方。**X轴**的`270`度，**Y轴**的`290`度，以及**Z轴**的`0`度将会很合适。
- en: The `Slingshot` script will provide most of the interaction for the player.
    Create it now.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Slingshot`脚本将提供玩家的大部分互动功能。现在创建它。'
- en: 'We start this script with a group of variables. The first group will keep a
    reference to the damper that was mentioned earlier. The second group will keep
    track of the birds that will be used in the level. Next is a group of variables
    that will track the current bird that is ready to be fired. Fourth, we have some
    variables to hold references to the points we created a moment ago. The `maxRange`
    variable is the distance from the focal point to which the player can drag the
    pouch. The last two variables define how powerfully the bird will be launched:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从这个脚本开始使用一组变量。第一组变量将保存之前提到的阻尼器的引用。第二组变量将跟踪将在关卡中使用的鸟。接下来是一组变量，用于跟踪准备发射的当前鸟。第四组变量保存我们刚才创建的点的引用。`maxRange`变量是从焦点到玩家可以将袋子拖动的距离。最后两个变量定义了鸟被发射的力度：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with the other scripts, we use the `Awake` function for initialization.
    The `levelBirds` variable will hold references to all the bird prefabs that will
    be used in the level. We start by creating an instance of each one and storing
    its **Rigidbody** in the `currentBirds` variable. The `isKinematic` variable is
    set to `true` on each bird''s **Rigidbody** component so that it does not move
    when it is not in use. Next, it readies the first bird to be fired and, finally,
    it positions the remaining birds behind `waitPoint`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他脚本一样，我们使用`Awake`函数进行初始化。`levelBirds`变量将保存所有将在关卡中使用的鸟类预制体的引用。我们首先创建每个预制体的实例，并将其**刚体**保存在`currentBirds`变量中。每个鸟的**刚体**组件上的`isKinematic`变量设置为`true`，这样在不使用时它就不会移动。接下来，它准备好第一个要发射的鸟，最后，它将剩余的鸟定位在`waitPoint`后面：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `ReadyNextBird` function first checks whether we have run out of birds.
    If so, it finds the `LevelTracker` script to tell it that there are no birds left
    to fire. The `nextIndex` variable tracks the current location of the birds in
    the list to be fired by the player. Next, the function stores the next bird in
    the `toFireBird` variable and makes it a child of the `BirdPoint` object we created;
    its position and rotation are zeroed out. Finally, the fire and aim flags are
    reset:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadyNextBird`函数首先检查是否已经没有鸟可供发射。如果是这样，它会找到`LevelTracker`脚本来告诉它没有鸟可以发射了。`nextIndex`变量跟踪列表中待玩家发射的鸟的当前位置。接下来，该函数将下一个鸟存储在`toFireBird`变量中，并将其设置为之前创建的`BirdPoint`对象的子对象；其位置和旋转会被重置为零。最后，发射和瞄准标志会被重置：'
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `SetWaitPositions` function uses the position of `waitPoint` to position
    all the remaining birds behind the slingshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetWaitPositions`函数使用`waitPoint`的位置来定位弹弓后面所有剩余的鸟：'
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Update` function starts by checking whether the player has fired a bird,
    and watches the `rigidbodyDamper.allSleeping` variable to see whether all the
    physics objects have stopped moving. Once they do, the next bird is readied to
    be fired. If we have not fired, the aiming flag is checked and the `DoAiming`
    function is called to handle the aiming. If the player is neither aiming nor has
    just fired a bird, we check for touch input. If the player touches close enough
    to the focal point, we flag that the player has started aiming:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update`函数首先检查玩家是否已经发射了一只鸟，并观察`rigidbodyDamper.allSleeping`变量以判断所有物理对象是否已经停止移动。一旦它们停止，下一只鸟就会被准备好发射。如果我们还没有发射，会检查瞄准标志并调用`DoAiming`函数来处理瞄准。如果玩家既没有瞄准也没有刚刚发射鸟，我们会检查触摸输入。如果玩家触摸的位置足够接近焦点，我们会标记玩家已经开始瞄准：'
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `DoAiming` function checks whether the player has stopped touching the
    screen and fires the current bird when they have. If they have not, we position
    the pouch at the current touch point. Finally, the pouch''s position is limited
    to keep it within the maximum range:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DoAiming`函数检查玩家是否停止触摸屏幕，并在他们停止时发射当前的鸟。如果他们没有停止，我们会将袋子定位在当前的触摸点。最后，袋子的位置被限制在最大范围内：'
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `GetTouchPoint` function uses `ScreenPointToRay` to find out where the
    player is touching in 3D space. This is similar to when we were touching bananas;
    however, because this game is 2D, we can just look at the ray''s origin and return
    a zero for its *z* axis value:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetTouchPoint`函数使用`ScreenPointToRay`来找出玩家在3D空间中触摸的位置。这类似于我们触摸香蕉时的操作；然而，由于这个游戏是2D的，我们只需查看射线原点并返回其*z*轴值为零：'
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, for this script, we have the `FireBird` function. This function starts
    by setting our `didFire` flag to `true`. Next, it finds out the direction in which
    the bird needs to be fired by finding the direction from the pouch''s position
    to `focalPoint`. It also uses the distance between them to determine the power
    with which the bird needs to be fired, clamping it between our minimum and maximum
    strengths. Then, it releases the bird by clearing its parent and setting its `isKinematic`
    flag to `false`, after finding its **Rigidbody** component. To launch it, we use
    the `AddForce` function and pass it the direction multiplied by the power. `ForceMode2D.Impulse`
    is also passed to make that the force applied happens once and is immediate. Next,
    the pouch is positioned at `focalPoint`, as if it were actually under tension.
    Finally, we call `rigidbodyDamper.ReadyDamp` to start the damping of the **Rigidbody**
    component''s movement:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于这个脚本，我们有`FireBird`函数。这个函数首先将我们的`didFire`标志设置为`true`。接下来，它通过查找袋子位置到`focalPoint`的方向来确定需要发射鸟的方向。它还使用它们之间的距离来确定发射鸟所需的力度，并将其限制在我们的最小和最大力度之间。然后，它通过清除其父对象并将`isKinematic`标志设置为`false`来释放鸟，找到其**Rigidbody**组件。为了发射它，我们使用`AddForce`函数，并传递方向乘以力度。同时传递`ForceMode2D.Impulse`以使施加的力一次性且立即生效。接下来，袋子被定位在`focalPoint`，就像它真的在受力下一样。最后，我们调用`rigidbodyDamper.ReadyDamp`来开始**Rigidbody**组件移动的阻尼：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Before we can make use of the `Slingshot` script, we need to create the `RigidbodyDamper`
    script.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够使用`Slingshot`脚本之前，我们需要创建`RigidbodyDamper`脚本。
- en: 'This script starts with the following six variables. The first two define how
    long you need to wait before damping movement and how much you need to damp it
    by. The next two track whether damping can be applied and when it will start.
    The next is a variable that will be filled with a list of all the rigidbodies
    that are currently in the scene. Finally, it has the `allSleeping` flag that will
    be set to `true` when the movement has stopped:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从以下六个变量开始。前两个变量定义了在抑制移动之前需要等待的时间以及抑制的幅度。接下来的两个变量跟踪是否可以应用抑制以及何时开始。接下来是一个变量，它将被填充为当前场景中所有刚体的列表。最后，有一个`allSleeping`标志，当移动停止时，它将被设置为`true`：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `ReadyDamp` function starts by using `FindObjectsOfType` to fill the list
    with all the rigidbodies. The `dampTime` flag is set when you need to start damping
    as the sum of the current time and the wait length. It marks that the script can
    do its damping and resets the `allSleeping` flag. Finally, it uses `StartCoroutine`
    to call the `CheckSleepingRigidbodies` function. This is a special way of calling
    functions to make them run in the background without blocking the rest of the
    game from running:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadyDamp`函数首先使用`FindObjectsOfType`填充刚体列表。当需要开始抑制时，将`dampTime`标志设置为当前时间与等待时长的总和。它表示脚本可以执行抑制并重置`allSleeping`标志。最后，它使用`StartCoroutine`调用`CheckSleepingRigidbodies`函数。这是一种特殊的调用函数方式，使它们在后台运行，而不会阻止游戏的其余部分运行：'
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `FixedUpdate` function, we first check whether we can damp the movement
    and whether it is time to do it. If it is, we loop through all the rigidbodies,
    applying our damp to each one''s rotational and linear velocity. Those that are
    kinematic, controlled by scripts, and already sleeping—meaning that they have
    stopped moving—are skipped:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FixedUpdate`函数中，我们首先检查是否可以抑制移动以及是否到了执行抑制的时候。如果是，我们会遍历所有刚体，对每个刚体的旋转速度和线性速度应用我们的抑制。那些由脚本控制、已经处于休眠状态（意味着它们已经停止移动）的动力学刚体将被跳过：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `CheckSleepingRigidbodies` function is special and will run in the background.
    This is made possible by the `IEnumerator` flag at the beginning of the function
    and the `yield return null` line in the middle. Together, these allow the function
    to pause regularly and keep the rest of the game from freezing while it waits
    for the function to complete. The function starts by creating a check flag and
    using it to check whether all the rigidbodies have stopped moving. If one is still
    found to be moving, the flag is set to `false` and the function pauses until the
    next frame, when it will try again. When it reaches the end, because all the rigidbodies
    are sleeping, it sets the `allSleeping` flag to `true` so that the slingshot can
    be made ready for the next bird. It also stops itself from damping while the player
    is getting ready to fire the next bird:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CheckSleepingRigidbodies`函数是特殊的，它将在后台运行。这是通过函数开头的`IEnumerator`标志和中间的`yield
    return null`行实现的。这些使得函数可以定期暂停，并在等待函数完成时防止游戏其余部分冻结。函数开始时创建一个检查标志，并使用它来检查所有刚体是否已经停止移动。如果发现有一个仍在移动，标志将被设置为`false`，函数将暂停到下一帧，届时将再次尝试。当到达末尾时，因为所有刚体都处于休眠状态，它将`allSleeping`标志设置为`true`，以便下一次使用弹弓时做好准备。同时，在玩家准备发射下一只鸟时，它也会停止抑制：'
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we have the `AddBodiesToCheck` function. This function will be used
    by anything that spawns new physics objects after the player has fired the bird.
    It starts by creating a temporary list and expanding the current one. Next, it
    adds all the values from the temporary list to the expanded one. Finally, the
    list of rigidbodies are added after those of the temporary list:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`AddBodiesToCheck`函数。这个函数将被任何在玩家发射鸟之后生成新物理对象的物体使用。它开始时创建一个临时列表并扩展当前列表。接下来，它将临时列表中的所有值添加到扩展后的列表中。最后，在临时列表之后添加刚体列表：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Return to Unity and add the two scripts to the `Slingshot` object. In the `Slingshot`
    script component, connect the references to the `Rigidbody Damper` script component
    and to each of the points. Also, add as many references to the red bird prefab
    to the **Level Birds** list as you want for the level.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，将这两个脚本添加到`Slingshot`对象中。在`Slingshot`脚本组件中，连接到`Rigidbody Damper`脚本组件的引用以及每个点的引用。此外，根据关卡需要，将红色小鸟预制体引用添加到**Level
    Birds**列表中。
- en: To keep objects from rolling back and through the slingshot, add a **Box Collider
    2D** component to `Slingshot` and position it at the stock of the `Fork` model.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止物体滚回到弹弓中，请在`Slingshot`上添加一个**Box Collider 2D**组件，并将其定位在`Fork`模型的支架处。
- en: To finish off the look of the slingshot, we need to create the elastic bands
    that tie the pouch to the fork. We will do this by first creating the `SlingshotBand`
    script.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成弹弓的外观，我们需要创建将袋子与叉连接的弹性带子。我们首先通过创建`SlingshotBand`脚本来实现这一点。
- en: 'The script starts with two variables, one for the point that the band will
    end at and one to reference the `LineRenderer` variable that will draw it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本从两个变量开始，一个用于带子结束的点，另一个用于引用将绘制它的`LineRenderer`变量：
- en: '[PRE34]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Awake` function ensures that the `lineRenderer` variable has only two
    points and sets their initial positions:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Awake`函数确保`lineRenderer`变量只有两个点，并设置它们的初始位置：'
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `LateUpdate` function, we set the `lineRenderer` variable''s end position
    to the `endPoint` value. This point will move around with the pouch, so we need
    to constantly update the renderer:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LateUpdate`函数中，我们将`lineRenderer`变量的端点位置设置为`endPoint`值。这个点会随着袋子移动，因此我们需要不断更新渲染器：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Return to Unity and create an empty **GameObject**. Name it `Band_Near` and
    make it a child of the `Slingshot` object.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，并创建一个空**游戏对象**。将其命名为`Band_Near`，并使其成为`Slingshot`对象的子对象。
- en: As children of this new point, create a cylinder and a second empty **Gameobject**,
    named `Band`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为这个新点的子对象，创建一个圆柱体和一个名为`Band`的第二个空**游戏对象**。
- en: Give the cylinder a brown material and position it around the near prong of
    the slingshot fork. Be sure to remove the **Capsule Collider** component so that
    it doesn't get in the way. Also, don't be afraid to scale it in order to make
    it fit the look of the slingshot better.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给圆柱体一个棕色材质，并将其定位在弹弓叉近端。确保移除**胶囊碰撞器**组件，以免造成妨碍。同时，不要害怕进行缩放，以便更好地适应弹弓的外观。
- en: To the `Band` object, add a **Line Renderer** component found under **Effects**
    in the **Component** menu. After positioning it in the center of the cylinder,
    add the `SlingshotBand` script to the object.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Band`对象上，添加位于**组件**菜单下**效果**中的**线渲染器**组件。将其放置在圆柱体的中心后，为对象添加`SlingshotBand`脚本。
- en: To the **Line Renderer** component under **Materials**, you can put your brown
    material in the slot to color the band. Under **Parameters**, set the **Start
    Width** to `0.5` and the **End Width** to `0.2` in order to set the size of the
    line.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质**下的**线渲染器**组件中，你可以将棕色材质放入槽中以给带子着色。在**参数**下，将**开始宽度**设置为`0.5`，将**结束宽度**设置为`0.2`，以设置线条的大小。
- en: Next, create another empty **GameObject** and name it `BandEnd_Near`. Make it
    a child of the `Pouch` object and position it inside the pouch.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建另一个空**游戏对象**，并将其命名为`BandEnd_Near`。使其成为`Pouch`对象的子对象，并将其定位在袋子内部。
- en: Now, connect the script's references to its line renderer and end point.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将脚本的引用连接到其线渲染器和端点。
- en: To make the second band, duplicate the four objects we just created and position
    them according to the other prong of the fork. The end point for this band can
    just be moved back along the *z* axis to keep it out of the way of the birds.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了制作第二条带子，复制我们刚才创建的四个对象，并根据叉的另一端定位它们。这条带子的端点只需沿着*z*轴向后移动，以使其避开小鸟。
- en: Finally, turn the whole thing into a prefab so that it can be easily reused
    in other levels.![Attacking with a slingshot](img/4691OT_07_04.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其整个转换为预制体，以便在其他关卡中轻松复用。![使用弹弓攻击](img/4691OT_07_04.jpg)
- en: We created the slingshot that will be used to fire birds. We used techniques
    that we learned in the previous chapter to handle touch input and to track the
    player's finger while they aim and shoot. If you save your scene and position
    the camera to look at the slingshot, you will notice that it is complete, if not
    entirely playable. Birds can be fired at the pig fortress, although we can only
    see the destruction from within Unity's **Scene** view.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个用于发射小鸟的弹弓。我们使用了前一章学到的技术来处理触摸输入，并在玩家瞄准和射击时追踪玩家的手指。如果你保存你的场景，并将相机定位在观察弹弓的位置，你会注意到它已经完成，尽管还不是很完善。可以向猪堡垒发射小鸟，尽管我们只能在Unity的**场景**视图中看到破坏效果。
- en: Watching with the camera
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过相机观看
- en: 'The game is technically playable at this point, but it is kind of hard to see
    what is going on. Next, we will create a system to control the camera. The system
    will allow the player to drag the camera to the left and right, follow the bird
    when it is launched, and return to the slingshot when everything stops moving.
    There will also be a set of limits to keep the camera from going too far and viewing
    things we do not want the player to see, such as beyond the edge of the ground
    or sky we have created for the level. We will only need one, fairly short, script
    to control and manage our camera. Let''s create it with these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，游戏在技术上是可以玩的，但有点难以看清正在发生的事情。接下来，我们将创建一个控制系统来控制摄像机。该系统将允许玩家将摄像机向左和右拖动，当小鸟被发射时跟随小鸟，并在一切停止移动后返回弹弓位置。还将有一组限制，以防止摄像机走得太远，看到我们不希望玩家看到的东西，比如我们为关卡创建的地形或天空的边缘。我们只需要一个相对简短的脚本来控制和管理工作。让我们按照以下步骤创建它：
- en: To start and to keep everything organized, create a new empty **GameObject**
    and name it `CameraRig`. Also, to keep it simple, set its position to zero on
    each axis.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始并保持一切有序，创建一个新的空**GameObject**，并将其命名为`CameraRig`。同时，为了简化，将其在每个轴上的位置设置为0。
- en: Next, create three more empty **GameObjects** and name them `LeftPoint`, `RightPoint`,
    and `TopPoint`. Set their **Z** axis positions to `-5`. Position the `LeftPoint`
    object to be in front of the slingshot and `3` on the **Y** axis. The `RightPoint`
    object needs to be positioned in front of the pig structure you created. The `TopPoint`
    object can be over the slingshot but needs to be set to `8` on the **Y** axis.
    These three points will define the limits of where our camera can move when being
    dragged and following the birds.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建三个空的**GameObject**，并将它们命名为`LeftPoint`、`RightPoint`和`TopPoint`。将它们的**Z轴**位置设置为`-5`。将`LeftPoint`对象定位在弹弓前方，并在**Y轴**上设置为`3`的位置。`RightPoint`对象需要定位在你创建的猪结构前方。`TopPoint`对象可以位于弹弓上方，但在**Y轴**上需要设置为`8`。这三个点将定义当拖动和跟随小鸟时，摄像机可以移动的范围限制。
- en: Make all the three points and the `Main Camera` object children of the `CameraRig`
    object.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这三个点以及`Main Camera`对象设置为`CameraRig`对象的子对象。
- en: Now, we create the `CameraControl` script. This script will control all the
    movement and interaction with the camera.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`CameraControl`脚本。这个脚本将控制摄像机的所有移动和交互。
- en: 'Our variables for this script start with a reference to the slingshot; we need
    this so that we can follow the current bird when it is fired. The next are the
    references to the points we just created. The next group of variables control
    for how long the camera will sit without input before returning to take a look
    at the slingshot and how fast it will return. The `dragScale` variable controls
    how fast the camera actually moves when the player drags their finger across the
    screen, allowing you to keep the scene moving with the finger. The last group
    controls whether the camera can follow the current bird and how fast it can do
    so:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本脚本的变量从对弹弓的引用开始；我们需要这个引用以便在发射时跟随当前的小鸟。接下来是对我们刚刚创建的点进行引用。接下来的一组变量控制摄像机在没有输入的情况下停留多长时间，然后返回查看弹弓以及返回的速度。`dragScale`变量控制当玩家在屏幕上拖动手指时，摄像机实际移动的速度，使场景能够跟随手指移动。最后一组变量控制摄像机是否可以跟随当前的小鸟以及跟随的速度：
- en: '[PRE37]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `Awake` function, we first make certain that the camera is not following
    a bird and make it wait before heading to take a look at the slingshot. This allows
    you to initially point the camera to the pig fortress when the level starts and
    move to the slingshot after giving the player a chance to see what they are up
    against:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`函数中，我们首先确保摄像机没有跟随小鸟，并让它等待一段时间后再去查看弹弓。这样，当关卡开始时，你可以先将摄像机指向猪堡垒，并在给玩家一个机会观察他们面对的情况之后，移动到弹弓位置：
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `StartWait` function sets the time when it will start to head back to the
    slingshot and records the position that it is heading back from. This allows you
    to create a smooth transition:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartWait`函数设置它将开始返回弹弓的时间，并记录它从哪个位置返回。这允许你创建一个平滑的过渡：'
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we have the `Update` function. This function starts by checking whether
    the slingshot has fired. If it hasn''t, it checks whether the player has started
    aiming, signaling that the bird should be followed and zeroing out the velocity
    if they have. If they have not started aiming, the `followBird` flag is cleared.
    Next, the function checks whether it should follow and does so if it should, also
    calling the `StartWait` function—in case this is the frame in which the bird is
    destroyed. If it should not follow the bird, it checks for touch input and drags
    the camera if it finds any. The wait is again started in case the player removes
    their finger from this frame. Finally, it checks to see whether the slingshot
    is done firing the current bird and whether it is time to head back. Should both
    be true, the camera moves back to point at the slingshot:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有`Update`函数。此函数首先检查弹弓是否已经发射。如果没有，它检查玩家是否已经开始瞄准，这意味着应该跟随鸟，并在他们这样做时将速度归零。如果他们还没有开始瞄准，则清除`followBird`标志。接下来，函数检查是否应该跟随，如果应该，则执行跟随，并调用`StartWait`函数——以防这是鸟被销毁的帧。如果不应该跟随鸟，它检查触摸输入并拖动摄像机（如果有的话）。如果玩家在这一帧移开手指，将再次开始等待。最后，它检查弹弓是否完成了当前鸟的发射，以及是否是时候返回了。如果两者都正确，摄像机将移回到指向弹弓的位置：
- en: '[PRE40]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `FollowBird` function starts by making sure that there is a bird to follow,
    by checking the `toFireBird` variable on the `Slingshot` script, and stops following
    if a bird is not found. Should there be a bird, the function then determines a
    new point to move to, which will look directly at the bird. It then uses the `Vector3.SmoothDamp`
    function to smoothly follow the bird. This function works similar to a spring—the
    farther away it is from its target position, the faster it moves the object. The
    `followVelocity` variable is used to keep it moving smoothly. Finally, it calls
    another function to limit the camera''s position within the bounding points we
    set up earlier:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FollowBird`函数首先通过检查`Slingshot`脚本上的`toFireBird`变量确保有一个鸟可供跟随，如果没有找到鸟则停止跟随。如果有鸟，该函数就会确定一个新的移动点，该点将直接对准鸟。然后它使用`Vector3.SmoothDamp`函数平滑地跟随鸟。这个函数类似于弹簧——离目标位置越远，移动物体的速度越快。使用`followVelocity`变量使其保持平滑移动。最后，它调用另一个函数，以限制摄像机在我们先前设置的限制点内的位置：'
- en: '[PRE41]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `DragCamera` function, we use the `deltaPosition` value of the current
    touch to determine how far it has moved since the last frame. By scaling this
    value and subtracting the vector from the camera''s position, the function moves
    the camera as the player drags across the screen. This function also calls upon
    the `ClampPosition` function to keep the camera''s position within the field of
    play:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DragCamera`函数中，我们使用当前触控的`deltaPosition`值来确定自上一帧以来它移动了多远。通过缩放这个值并从摄像机位置减去该向量，函数使摄像机随着玩家在屏幕上的拖动而移动。此函数还调用`ClampPosition`函数，以确保摄像机位置保持在游戏场内：
- en: '[PRE42]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `ClampPosition` function starts by taking the camera''s current position.
    It then clamps the `x` position to be between those of the `leftPoint` and `rightPoint`
    variables'' `x` positions. Next, the `y` position is clamped between the `leftPoint`
    and `topPoint` variables'' `y` positions. Finally, the new position is reapplied
    to the camera''s transform:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClampPosition`函数首先获取摄像机的当前位置。然后它将`x`位置夹紧在`leftPoint`和`rightPoint`变量的`x`位置之间。接下来，`y`位置被夹紧在`leftPoint`和`topPoint`变量的`y`位置之间。最后，将新位置重新应用到摄像机的变换中：'
- en: '[PRE43]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have the `BackToLeft` function. It starts by using the time and
    our duration variable to determine how much progress the camera will have made
    to return to the slingshot. It records the camera''s current position and uses
    `Mathf.SmoothStep` on both the *x* and *y* axes to find a new position that is
    at an appropriate distance between the `waitPosition` variable and the `leftPoint`
    variable. Finally, the new position is applied:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`BackToLeft`函数。它首先使用时间和我们的持续时间变量来确定摄像机返回到弹弓时应该完成多少进度。它记录摄像机的当前位置，并在*x*和*y*轴上使用`Mathf.SmoothStep`找到一个位于`waitPosition`变量和`leftPoint`变量之间的适当距离的新位置。最后，应用新位置：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, return to Unity and add the new script to the `Main Camera` object. Connect
    the references to the slingshot and each of the points to finish it off.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回到Unity并将新脚本添加到`Main Camera`对象。连接到弹弓和每个点的引用以完成设置。
- en: Position the camera to point at your pig fortress and turn the whole rig into
    a prefab.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将摄像机定位以指向你的猪堡垒，并将整个装置转变成一个预制体。
- en: We created a camera rig that will let the player watch all the action as they
    play the game. The camera will now follow the birds as they are fired from the
    slingshot and can now be dragged by the player. By keying off the positions of
    a few objects, this movement is limited to keep the player from seeing things
    we don't want them to; if the camera is left idle for long enough, it will also
    return to look at the slingshot.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个摄像机装置，让玩家在玩游戏时可以观看所有的动作。现在相机将跟随从弹弓发射的小鸟，并且可以被玩家拖动。通过定位几个对象的位置，这种移动受到了限制，以防止玩家看到我们不想让他们看到的东西；如果相机闲置足够长的时间，它也会返回来观察弹弓。
- en: Another function of the camera, common to many mobile games, is the pinch-to-zoom
    gesture. It is such a simple gesture for the user to expect, but it can be complex
    for us to implement well. Try your hand at implementing it here. You can use `Input.touchCount`
    to detect whether there are two fingers touching the screen. Then, using the `Vector2.Distance`
    function, if you have recorded the distance from the last frame, it is possible
    to determine whether they are moving toward or away from each other. Once you
    have determined your zoom direction, just change the camera's `ortographicSize`
    variable to change how much can be seen; be sure to include some limits so that
    the player can't zoom in or out forever.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 相机在许多移动游戏中的另一个功能是通过捏合来进行缩放的手势。这对于用户来说是一个非常简单的手势，但对我们来说要实现好可能会很复杂。尝试在这里实现它。你可以使用`Input.touchCount`来检测是否有两个手指触摸屏幕。然后，使用`Vector2.Distance`函数，如果你记录了上一帧的距离，就可以确定它们是相互靠近还是远离。一旦确定了缩放方向，只需改变相机的`ortographicSize`变量，以改变可以看到的范围；确保包括一些限制，这样玩家就不能无限地放大或缩小。
- en: Now that we have all the pieces needed to make a complete level, we need some
    more levels. We need at least two more levels. You can use the blocks and pigs
    to create any level you might want. It is a good idea to keep structures centered
    around the same spot as our first level, giving the player an easier time dealing
    with them. Also, think about the difficulty of the level while making it so that
    you end up with an easy, medium, and hard level.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了制作完整关卡所需的所有部分，我们需要更多的关卡。我们至少还需要两个关卡。你可以使用积木和猪来创建你想要的任何关卡。最好保持结构围绕与我们的第一个关卡相同的中心点，这样玩家处理起来会更简单。同时，在制作关卡时也要考虑关卡的难度，以便最终拥有简单、中等和困难难度的关卡。
- en: Creating the parallax background
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视差背景
- en: 'A great feature of many 2D games is a parallax scrolling background. This simply
    means that the background is created in layers that scroll by at different speeds.
    Think of it as if you are looking out the window of your car. The objects that
    are far away appear to hardly move, while the ones that are near move by quickly.
    In a 2D game, it gives the illusion of depth and adds a nice touch to the look
    of the game. For this background, we will be layering several materials on a single
    plane. There are several other methods to create this same effect, but ours will
    make use of a single script that additionally allows you to control the speed
    of each layer. Let''s create it with these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 许多2D游戏的一个出色特性是视差滚动背景。这仅仅意味着背景是由以不同速度滚动的层次创建的。你可以把它想象成你从汽车窗户向外看。远处的物体看起来几乎不动，而近处的物体则快速移动。在2D游戏中，它给人以深度的错觉，并为游戏的外观增添了不错的触感。对于这个背景，我们将在单个平面上叠加几种材质。还有其他几种方法可以创建这种效果，但我们将使用一个脚本来实现，此外它还允许你控制每一层的滚动速度。让我们按照以下步骤来创建它：
- en: We will start this section with the creation of the `ParallaxScroll` script.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建`ParallaxScroll`脚本开始这一部分。
- en: 'This script starts with three variables. The first two variables keep track
    of each material and how fast they should scroll. The third keeps track of the
    camera''s last position, so we can track how far it moves in each frame:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从三个变量开始。前两个变量跟踪每种材质以及它们滚动的速度。第三个变量记录相机的最后位置，这样我们可以跟踪相机在每一帧中移动了多远：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `Start` function, we record the camera''s beginning position. We use
    `Start` instead of `Awake` here, in case the camera needs to do any special movement
    at the beginning of the game:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`函数中，我们记录相机的初始位置。这里我们使用`Start`而不是`Awake`，以防止相机在游戏开始时需要进行任何特殊的移动：
- en: '[PRE46]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we use the `LateUpdate` function to make changes after the camera has
    moved about. It starts by finding the camera''s new position and comparing the
    *x* axis values to determine how far it has moved. Next, it loops through the
    list of materials. The loop first gathers the current offset of its texture using
    `mainTextureOffset`. Next, the camera''s movement multiplied by the material''s
    speed is subtracted from the offset''s *x* axis to find a new horizontal position.
    Then, the new offset is applied to the material. Finally, the function records
    the camera''s last position for the next frame:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`LateUpdate`函数在摄像机移动后进行更改。它首先找到摄像机的新的位置，并通过比较*x*轴的值来确定它移动了多远。接下来，它遍历材质列表。循环首先使用`mainTextureOffset`收集材质当前纹理的偏移量。然后，将摄像机的移动乘以材质的速度从偏移量的*x*轴中减去，以找到新的水平位置。接着，将新的偏移量应用到材质上。最后，该函数记录摄像机在上一个帧中的位置，以供下一帧使用：
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Return to Unity and create six new materials. One for each background texture:
    `sky`, `hills_tall`, `hills_short`, `grass_light`, `grass_dark`, and `fronds`.
    All the materials, except for `sky`, need to use **Transparent** **Render Mode**.
    If they do not, we will not be able to see all the textures when they are layered.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，创建六个新的材质。每个背景纹理一个：`sky`，`hills_tall`，`hills_short`，`grass_light`，`grass_dark`和`fronds`。除了`sky`之外的所有材质，都需要使用**透明**的**渲染模式**。如果不用这种模式，我们将无法在分层时看到所有纹理。
- en: Before we can tile the images in the background, we need to adjust their **Import
    Settings**. Select each in turn and take a look at the **Inspector** window. Because
    we chose to make a 2D game, Unity imports all the images as sprites by default,
    which clamps the edges of our images and keeps them from repeating. For all our
    background images, change the **Texture Type** option to **Texture** and the **Wrap
    Mode** option to **Repeat**. This will let us use them in a way that makes it
    look like an infinite scrolling background.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够对背景中的图像进行平铺之前，我们需要调整它们的**导入设置**。逐个选择它们，并查看**检查器**窗口。由于我们选择制作一个2D游戏，Unity默认将所有图像作为精灵导入，这会导致我们的图像边缘被夹紧，无法重复。对于所有背景图像，将**纹理类型**选项更改为**纹理**，并将**环绕模式**选项更改为**重复**。这样我们就可以以无限滚动背景的方式使用它们。
- en: We also need to adjust the **Tiling** option for each of these new materials.
    For all of them, leave the **Y** axis as `1`. For the **X** axis, set `5` for
    the `sky`, `6` for `hills_tall`, `7` for `hills_shot`, `8` for `grass_dark`, `9`
    for `fronds`, and `10` for `grass_light`. This will offset all the features of
    the textures, so a long pan does not see features regularly lining up.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整这些新材质的**平铺**（Tiling）选项。对于所有材质，将**Y轴**保持为`1`。对于**X轴**，将`sky`设为`5`，`hills_tall`设为`6`，`hills_shot`设为`7`，`grass_dark`设为`8`，`fronds`设为`9`，`grass_light`设为`10`。这将偏移所有纹理特征，使得长距离的平移不会看到特征规律地排列。
- en: Next, create a new plane. Name it `Background` and remove its **Mesh Collider**
    component. Also, attach our `ParallaxScroll` script.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的平面。将其命名为`Background`，并移除其**网格碰撞器**组件。同时，附加我们的`ParallaxScroll`脚本。
- en: Position it at `30` on the **X** axis, `7` on the **Y** axis, and `10` on the
    **Z** axis. Set its rotation to `90` for the **X** axis, `180` for the **Y** axis,
    and `0` for **Z**. Also, set the scale to `10` for the **X** axis, `1` for the
    **Y** axis, and `1.5` for the **Z** axis. Altogether, these position the plane
    to face the camera and fill the background.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为**X轴**上的`30`，**Y轴**上的`7`，以及**Z轴**上的`10`。将其旋转设置为**X轴**上的`90`，**Y轴**上的`180`，以及**Z轴**上的`0`。同时，将缩放设置为**X轴**上的`10`，**Y轴**上的`1`，以及**Z轴**上的`1.5`。总的来说，这些设置使平面面向摄像机并填充背景。
- en: In the plane's **Mesh Renderer** component, expand the **Materials** list and
    set the value of **Size** to `6`. Add each of our new materials to the list slots
    in the order of `sky`, `hills_tall`, `hills_short`, `grass_dark`, `fronds`, and
    `grass_light`. Do the same for the **Materials** list in the **Parallax Scroll**
    script component.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在平面的**网格渲染器**组件中，展开**材质**列表，并将**大小**值设置为`6`。按顺序将我们的新材质添加到列表槽中，顺序为`sky`，`hills_tall`，`hills_short`，`grass_dark`，`fronds`和`grass_light`。对**视差滚动**脚本组件中的**材质**列表也执行相同的操作。
- en: Finally, in the **Parallax Scroll** script component, set the value of **Size**
    of the **Speeds** list to `6` and input the following values in the order of `0.03`,
    `0.024`, `0.018`, `0.012`, `0.006`, and `0`. These values will move the materials
    gently and evenly.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**视差滚动**脚本组件中，将**速度**列表中的**大小**值设置为`6`，并按顺序输入以下值：`0.03`，`0.024`，`0.018`，`0.012`，`0.006`和`0`。这些值将会使材质均匀柔和地移动。
- en: At this point, turning the background into a prefab will make it easy to reuse
    later.![Creating the parallax background](img/4691OT_07_05.jpg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，将背景变成预制体将使其在以后容易重用。[创建视差背景](img/4691OT_07_05.jpg)
- en: We created a parallax scroll effect. This effect will pan a series of background
    textures, giving the illusion of depth in our 2D game. To easily see it in action,
    press the play button and grab the camera in the **Scene** view, moving it from
    side to side in order to see the background change.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个视差滚动效果。这个效果将平移一系列背景纹理，为我们的2D游戏提供深度的错觉。要轻松查看它的效果，请按播放按钮并在**场景**视图中抓住相机，左右移动以查看背景变化。
- en: We have two other levels to add backgrounds to. Your challenge here is to create
    your own background. Use the techniques you learned in this section to create
    a night-style background. It can include a stationary moon, while everything else
    scrolls in the shot. For an added trick, create a cloud layer that slowly pans
    across the screen as well as with the camera and the rest of the background.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个关卡需要添加背景。这里的挑战是创建你自己的背景。使用你在本节中学到的技术来创建一个夜晚风格的背景。它可以包括一个静止的月亮，而其他所有内容在镜头中滚动。为了增加一个技巧，创建一个云层，它随着相机和背景的其他部分慢慢横穿屏幕。
- en: Adding more birds
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多小鸟
- en: 'There is one last set of assets that we need to create for our levels: the
    other birds. We will create three more birds that each have a unique special ability:
    a yellow bird that accelerates, a blue bird that splits into multiple birds, and
    a black bird that explodes. With these, our flock will be complete.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的关卡创建最后一组资产：其他的小鸟。我们将创建三只更多的小鸟，每只都有独特的特殊能力：加速的黄色小鸟，分裂成多只小鸟的蓝色小鸟，以及爆炸的黑色小鸟。有了这些，我们的鸟群就完整了。
- en: To make the creation of these birds easier, we will be making use of a concept
    called **inheritance**. Inheritance allows a script to expand upon the functions
    it is inheriting without the need to rewrite them. If used correctly, this can
    be very powerful and, in our case, will aid in the quick creation of multiple
    characters that are largely similar.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地创建这些小鸟，我们将利用一个称为**继承**的概念。继承允许脚本在不需要重写的情况下扩展其继承的功能。如果使用得当，这将非常强大，在我们的情况下，它将有助于快速创建多个大致相似的角色。
- en: The yellow bird
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黄色小鸟
- en: 'First, we will create the yellow bird. Largely, this bird functions exactly
    as the red bird. However, when the player touches the screen a second time, the
    bird''s special ability is activated and its speed increases. By extending the
    `Bird` script that we created earlier, this bird''s creation becomes quite simple.
    Because of the power of inheritance, the script we are creating here consists
    of only a handful of lines of code. Let''s create it with these steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建黄色小鸟。在很大程度上，这只鸟的功能与红色小鸟完全相同。然而，当玩家第二次触摸屏幕时，小鸟的特殊能力被激活，其速度会增加。通过扩展我们之前创建的`Bird`脚本，这只鸟的创建变得相当简单。由于继承的强大力量，我们在这里创建的脚本仅包含几行代码。让我们按照以下步骤来创建它：
- en: Start by creating the yellow bird in the same way as the red bird, using the
    `YellowBird` model instead.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照创建红色小鸟的相同方式，使用`YellowBird`模型来创建黄色小鸟。
- en: Instead of using the `Bird` script, we will create the `YellowBird` script.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是使用`Bird`脚本，而是将创建`YellowBird`脚本。
- en: 'This script needs to extend the `Bird` script, so replace `MonoBehaviour` with
    `Bird` on line four of our new script. It should look similar to the following
    code snippet:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本需要扩展`Bird`脚本，因此在我们新脚本的第四行，用`Bird`替换`MonoBehaviour`。它应该类似于以下代码片段：
- en: '[PRE48]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This script adds a single variable that will be used to multiply the bird''s
    current velocity:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本添加了一个单一变量，用于乘以小鸟的当前速度：
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we override the `DoSpecial` function and multiply the bird''s `body.velocity`
    variable when it is called:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`DoSpecial`函数，并在调用时乘以小鸟的`body.velocity`变量：
- en: '[PRE50]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Return to Unity, add the script to your new bird, connect the **Rigidbody**
    component reference, and turn it into a prefab. Add some to the list on your slingshot
    in order to use the bird in your level.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，将脚本添加到你的新小鸟中，连接**Rigidbody**组件引用，并将其变成一个预制体。在你的弹弓列表中添加一些，以便在你的关卡中使用这只鸟。
- en: We created the yellow bird. This bird is simple. It directly modifies its velocity
    to suddenly gain a boost of speed when the player touches the screen. As you will
    soon see, we use this same style of script to create all our birds.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了黄色小鸟。这只鸟很简单。当玩家触摸屏幕时，它会直接修改其速度，以突然获得速度的提升。正如你很快会看到的，我们使用这种风格的脚本来创建我们所有的鸟。
- en: The blue bird
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝色小鸟
- en: 'Next, we will create the blue bird. This bird splits into three birds when
    the player touches the screen. It will also extend the `Bird` script by using
    inheritance, reducing the amount of code that needs to be written to create the
    bird. Let''s do it with these steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建蓝色小鸟。当玩家触摸屏幕时，这种鸟会分裂成三只鸟。它还将通过继承扩展`Bird`脚本，减少编写创建鸟所需的代码量。让我们按照以下步骤进行：
- en: Again, start building your blue bird the same way as the previous two birds
    were built, substituting the appropriate model. You should also adjust the value
    of **Radius** of the **Circle Collider 2D** component to align appropriately with
    the small size of this bird.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，像前两只鸟一样开始构建你的蓝色小鸟，替换相应的模型。你还应该调整**Circle Collider 2D**组件的**Radius**值，以适应这种小鸟的小尺寸。
- en: Next, we create the `BlueBird` script.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`BlueBird`脚本。
- en: 'Again, adjust line four so that the script extends `Bird` instead of `MonoBehaviour`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，调整第四行，使脚本扩展`Bird`而不是`MonoBehaviour`：
- en: '[PRE51]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This script has three variables. The first variable is a list of prefabs to
    spawn when the bird splits. The next is the angle difference between each new
    bird that will be launched. The final variable is a value to spawn the birds a
    little ahead of their current position in order to keep them from getting stuck
    inside each other:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有三个变量。第一个变量是当鸟分裂时要生成的预制体列表。下一个是每个新发射鸟之间的角度差。最后一个变量是为了避免生成的鸟相互卡住，而将它们稍微提前生成的位置值：
- en: '[PRE52]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we override the `DoSpecial` function and start, as with the others, by
    marking that we made our special move. Next, it calculates half of the number
    of birds to spawn and creates an empty list to store the rigidbodies of the newly
    spawned birds:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重写`DoSpecial`函数，像其他鸟一样，首先标记我们完成了特殊动作。接下来，它计算要生成的鸟的一半数量，并创建一个空列表来存储新生成鸟的刚体：
- en: '[PRE53]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The function continues by looping through the list of birds, skipping the slots
    that are empty. It spawns the new birds at their position; after trying to store
    the object''s **Rigidbody**, it goes on to the next one if it is missing. The
    new **Rigidbody** component is then stored in the list:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数通过遍历鸟类列表，跳过空槽继续执行。它在它们的位置生成新鸟；尝试存储对象的**Rigidbody**后，如果缺失，它将继续下一个。然后将在列表中存储新的**Rigidbody**组件：
- en: '[PRE54]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Using `Quaternion.Euler`, a new rotation is created that will angle the new
    bird along a path that is split off from the main path. The new bird''s velocity
    is set to the rotated velocity of the current bird. An offset is calculated and
    it is then moved forward along its new path, so as to get out of the way of the
    other birds being spawned:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Quaternion.Euler`，创建一个新的旋转，使新鸟沿着从主路径分叉的路径偏转。新鸟的速度设置为当前鸟的旋转速度。计算偏移量，然后沿着新路径向前移动，以便为其他生成的鸟让路：
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After the loop, the function uses `FindObjectOfType` to find the slingshot
    that is currently in the scene. If it is found, it is changed to track the first
    new bird spawned as the one that was fired. The new list of rigidbodies is also
    set to the `rigidbodyDamper` variable, in order to be added to its list of rigidbodies.
    Finally, the script destroys the bird it is attached to, completing the illusion
    that the bird has been split apart:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环之后，函数使用`FindObjectOfType`查找当前场景中的弹弓。如果找到，将其更改为跟踪第一个新生成的鸟作为被发射的鸟。新的刚体列表也被设置为`rigidbodyDamper`变量，以便添加到其刚体列表中。最后，脚本销毁其附着的鸟，完成鸟被分裂的错觉：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before you add the script to your new bird, we actually need two blue birds:
    one that splits and one that does not. Duplicate your bird and name one `Bird_Blue_Split`
    and the other `Bird_Blue_Normal`. To the split bird, add the new script and to
    the normal bird, add the `Bird` script.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将脚本添加到你的新鸟之前，我们实际上需要两只蓝色小鸟：一只负责分裂，另一只不分裂。复制你的鸟，并将一个命名为`Bird_Blue_Split`，另一个命名为`Bird_Blue_Normal`。在分裂的鸟上添加新脚本，而在普通鸟上添加`Bird`脚本。
- en: Turn both the birds into prefabs and add the normal bird to the other's list
    of birds to be split into.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两只鸟都转变成预制体，并将普通鸟添加到另一只鸟的待分裂鸟列表中。
- en: We created the blue bird. This bird splits into multiple birds when the user
    taps the screen. The effect actually requires two birds that look identical, one
    that does the splitting and another that is split in two but does nothing special.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了蓝色小鸟。当用户点击屏幕时，这种鸟会分裂成多只鸟。实际上这个效果需要两只看起来完全相同的鸟，一只负责分裂，另一只被分裂成两半但不执行特殊动作。
- en: It is actually possible to add anything that we want to spawn to the blue bird's
    list of things to split into. Your challenge here is to create a rainbow bird.
    This bird can split into different types of birds, not just blue ones. Or, perhaps
    it is a stone bird that splits into stone blocks. For an extended challenge, create
    a mystery bird that randomly picks a bird from its list when it splits.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以将任何想要生成的对象添加到蓝色小鸟分裂时产生的对象列表中。这里的挑战是创建一个彩虹鸟。这种鸟可以分裂成不同类型的鸟，不仅仅是蓝色。或者，它可能是一个石鸟，分裂成石块。为了增加挑战，创建一个神秘鸟，在分裂时从其列表中随机选择一种鸟。
- en: The black bird
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑色小鸟
- en: 'Finally, we have the black bird. This bird explodes when the player touches
    the screen. As with all the birds discussed previously, it will extend the `Bird`
    script; inheriting from the red bird makes the black bird''s creation much easier.
    Let''s use these steps to do it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了黑色小鸟。当玩家触摸屏幕时，这只鸟会爆炸。与之前讨论的所有鸟一样，它将扩展`Bird`脚本；从红色小鸟继承使得黑色小鸟的创建变得容易得多。让我们使用这些步骤来完成它：
- en: As with the others, this bird is initially created in the same way as the red
    bird, readjusting the value of **Radius** on your **Circle Collider 2D** component
    for its increased size.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他鸟一样，这个鸟最初是以与红色小鸟相同的方式创建的，调整**Circle Collider 2D**组件上的**Radius**值以适应其增加的大小。
- en: Again, we create a new script to extend the `Bird` script. This time, it is
    called `BlackBird`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们创建一个新的脚本来扩展`Bird`脚本。这次，它被称为`BlackBird`。
- en: 'Do not forget to adjust line four to extend the `Bird` script and not `MonoBehaviour`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记调整第四行以扩展`Bird`脚本，而不是`MonoBehaviour`：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This script has two variables. The first variable is the size of the explosion
    and the second is its strength:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本有两个变量。第一个变量是爆炸的大小，第二个是它的强度：
- en: '[PRE58]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once more, we override the `DoSpecial` function, first marking that we did
    so. Next, we use `Physics2D.OverlapCircleAll` to acquire a list of all the objects
    that are within the range of the bird''s explosion, the 3D version of which is
    `Physics.OverlapSphere`. Next, we calculate where the explosion is coming from,
    which is just our bird''s position moved down three units. We move it down because
    explosions that throw debris up are more exciting than the ones that push debris
    out. The function then loops through the list, skipping any empty slots and those
    without rigidbodies:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们重写`DoSpecial`函数，首先标记我们已经这样做。接下来，我们使用`Physics2D.OverlapCircleAll`获取在鸟爆炸范围内的所有对象列表，其3D版本是`Physics.OverlapSphere`。然后，我们计算爆炸来自哪里，这仅仅是我们鸟的位置向下移动三个单位。我们将其向下移动，因为向上抛射碎片比向外推射碎片的爆炸更有趣。然后函数遍历列表，跳过任何空槽和没有刚体的对象：
- en: '[PRE59]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the object exists and has a **Rigidbody** component attached, we need to
    calculate how the explosion is going to affect this object, simulating the way
    an explosion''s strength is reduced the further away you are from it. First, we
    save ourselves some typing by grabbing the other object''s position. Next, we
    calculate where it is, relative to the position of the explosion. By dividing
    the magnitude or the length of the relative position by our `radius` variable,
    we can figure out how much force to apply to the object that was hit. Finally,
    we use `AddForceAtPosition` to give the object a kick as if the explosion was
    in a specific spot. The `ForceMode2D.Impulse` variable is used to apply the force
    immediately:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象存在并且附加了**Rigidbody**组件，我们需要计算爆炸将如何影响这个对象，模拟爆炸强度随距离增加而减弱的方式。首先，我们通过获取另一个对象的位置来节省一些输入。接下来，我们计算它相对于爆炸位置的位置。通过将相对位置的大小或长度除以我们的`radius`变量，我们可以计算出需要向被击中的对象施加多大的力。最后，我们使用`AddForceAtPosition`给对象一个像在特定位置爆炸一样的踢力。`ForceMode2D.Impulse`变量用于立即施加力：
- en: '[PRE60]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, the function destroys the exploded bird:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，函数销毁了已爆炸的鸟：
- en: '[PRE61]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As with the last two, apply your new script to your new bird and turn it into
    a prefab. You now have four birds to choose from when selecting the slingshot
    arsenal for each level.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与最后两只鸟一样，将你的新脚本应用于新鸟并将其变成预制体。现在，在每个级别选择弹弓武器库时，你有四种鸟可以选择。
- en: 'We created our fourth and last bird: the black bird. This bird explodes when
    the user touches the screen, throwing anything that might be near it into the
    sky. This can be a fun bird to play around with and is effective for destroying
    your pig forts.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了第四只也是最后一只鸟：黑色小鸟。当用户触摸屏幕时，这只鸟会爆炸，将附近的一切抛向空中。这可以是一种有趣的鸟来玩，对于摧毁你的猪堡垒非常有效。
- en: The black bird from the game we are imitating has the additional ability of
    a timed explosion after it has hit something. Try creating a timer for our black
    bird to recreate this effect. You will have to override the `OnCollisionEnter`
    function to start your timer and use `LateUpdate` to count down. Once your timer
    runs out, you can just use our `DoSpecial` function to actually cause the explosion.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模仿的游戏中的黑色小鸟具有额外的定时爆炸能力，在撞击到某物后触发。尝试为我们的黑色小鸟创建一个计时器，以重现这一效果。你需要重写`OnCollisionEnter`函数来启动计时器，并使用`LateUpdate`来倒计时。一旦计时器时间耗尽，你可以使用我们的`DoSpecial`函数来实际引发爆炸。
- en: 'Now that you know how to cause explosions, we have another challenge: create
    an explosive crate. You need to extend the `Plank` script to make it, and when
    enough damage is done to the crate, trigger the explosion. For an additional challenge,
    instead of making the crate explode, configure it to throw out a few bombs that
    explode when they hit something.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你知道如何引发爆炸，我们又有了一个挑战：创建一个爆炸箱子。你需要扩展`Plank`脚本来实现它，当箱子受到足够伤害时，触发爆炸。为了增加挑战性，你可以配置箱子，使其不是直接爆炸，而是抛出几个炸弹，这些炸弹在撞击到某物时爆炸。
- en: '![The black bird](img/4691OT_07_06.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![黑色小鸟](img/4691OT_07_06.jpg)'
- en: Level selection
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡选择
- en: 'Finally, we need to create our level selection screen. From this scene, we
    will be able to access and start playing all the levels we created earlier. We
    will also display the current high scores for each level. A new scene and a single
    script will serve us well in managing our level selection. Let''s use these steps
    to do it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个关卡选择屏幕。通过这个场景，我们可以访问并开始玩我们之前创建的所有关卡。我们还将显示每个关卡当前的最高分。一个新的场景和一个脚本就能很好地管理我们的关卡选择。让我们按照以下步骤进行操作：
- en: This last section begins by saving our current scene and pressing *Ctrl* + *N*
    to create a new one; we will name it `LevelSelect`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一部分开始时保存我们当前的场景，并按*Ctrl* + *N*创建一个新场景；我们将它命名为`LevelSelect`。
- en: For this scene, we need to create a single, short script also named `LevelSelect`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个场景，我们需要创建一个名为`LevelSelect`的简短脚本。
- en: 'This script is going to work with the buttons in the GUI to tell players about
    the high scores and load levels. However, before we can do this, we need to add
    a line at the very beginning of the script, along with the other `using` lines—just
    like the other scripts we have created that need to update the GUI:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本将和GUI中的按钮一起工作，告诉玩家高分和加载关卡。然而，在我们能做到这一点之前，我们需要在脚本的最前面添加一行，和其他需要更新GUI的脚本一样，与其他`using`行一起：
- en: '[PRE62]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first and only variable is a list of all the button text that we want to
    update, with the high scores for the levels they are associated with:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个也是唯一的变量是我们想要更新的所有按钮文本的列表，以及它们关联关卡的分数：
- en: '[PRE63]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first function is the `Awake` function. Here, it loops through all the
    buttons, finds the high score for it, and updates the text to display it. `PlayerPrefs.GetInt`
    is the opposite of the `SetInt` function we used earlier to save the high score:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个函数是`Awake`函数。这里，它会遍历所有按钮，找到它对应的高分，并更新文本以显示它。`PlayerPrefs.GetInt`与我们之前用来保存高分的`SetInt`函数相反：
- en: '[PRE64]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The second and last function for this script is `LoadLevel`. It will receive
    a number from the GUI button and use it to load the level that the players want
    to play:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的第二个也是最后一个函数是`LoadLevel`。它将从GUI按钮接收一个数字，并使用它来加载玩家想要玩的关卡：
- en: '[PRE65]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Return to Unity and add the script to the `Main Camera` object.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，并将脚本添加到`Main Camera`对象。
- en: Next, we need to create three buttons. Without these, our player will not be
    able to select a level to play. Make each of them of `200` units square and position
    them in a row in the center of the screen. Also, increase the value of **Font
    Size** to `25`, so that the text is easy to read.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建三个按钮。没有这些，我们的玩家将无法选择一个关卡来玩。使每个按钮为`200`单位大小，并将它们排成一行放在屏幕中央。同时，将**字体大小**增加到`25`，以便文本易于阅读。
- en: Drag each of the buttons' `Text` children to the **Button Texts** list on the
    `Main Camera` component's **Level Select** script component. The way they are
    ordered in this list is the order in which they will get their text and high score
    information changed.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个按钮的`Text`子对象拖动到`Main Camera`组件的**Level Select**脚本组件中的**Button Texts**列表。它们在这个列表中的顺序就是它们将改变文本和高分信息显示的顺序。
- en: Also, each button needs a new **On Click** event. Select `Main Camera` for the
    object and then navigate to **LevelSelect** | **LoadLevel (int)** for the function.
    Then, each button needs a number. The button that has its **Text** child in the
    **Button Texts** list should have the number `1` since it will display the information
    for level one. The second has `2`, the third has `3`, and so on. Each button must
    have the same number as the order in the list, or they will cause a different
    level to load than what the player is expecting.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，每个按钮都需要一个新的**点击**事件。为对象选择`主相机`，然后导航到**LevelSelect** | **LoadLevel (int)**
    函数。然后，每个按钮都需要一个数字。在**按钮文本**列表中的其**文本**子项的按钮应该有数字`1`，因为它将显示第一关的信息。第二个按钮有`2`，第三个有`3`，依此类推。每个按钮必须有与列表中顺序相同的数字，否则它们将加载与玩家预期不同的关卡。
- en: Finally, open **Build Settings** and add your scenes to the **Scenes in Build**
    list. Clicking and dragging on the scenes in the list will let you reorder them.
    Make sure that your **LevelSelect** scene is first and has an index of zero at
    the right-hand side. The rest of your scenes can appear in whatever order you
    desire. However, beware as they will be associated with the buttons in the same
    order.![Level selection](img/4691OT_07_07.jpg)
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开**构建设置**并将你的场景添加到**构建中的场景**列表中。通过点击并拖动列表中的场景，你可以重新排序它们。确保你的**LevelSelect**场景排在第一位，并且在右侧的索引为零。其余的场景可以按照你希望的任何顺序出现。但是要注意，它们将与按钮以相同的顺序关联。![关卡选择](img/4691OT_07_07.jpg)
- en: We have created a level selection screen. It has a list of buttons associated
    with the levels in our game. When a button is pressed, `Application.LoadLevel`
    starts that level. We also made use of `PlayerPrefs.GetInt` to retrieve the high
    scores for each of the levels.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个关卡选择屏幕。它有一个与游戏中关卡相关联的按钮列表。当按下按钮时，`Application.LoadLevel`会开始那个关卡。我们还使用了`PlayerPrefs.GetInt`来获取每个关卡的高分。
- en: Here, the challenge is to style the GUI to make the screen look great. A logo
    and a background will help a lot. Additionally, take a look at the **Scrollbar**
    GUI object if you have more than three levels. This object will let you create
    a function that offsets the level buttons when the user scrolls through a list
    of levels that are far greater in size than can be easily seen on the screen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，挑战在于设计GUI样式，使屏幕看起来很棒。一个标志和背景将大有帮助。此外，如果你有超过三个关卡，请查看**滚动条**GUI对象。这个对象将允许你创建一个函数，当用户浏览比屏幕上容易看到的更大的关卡列表时，可以偏移关卡按钮。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about physics in Unity and recreated the incredibly
    popular mobile game, *Angry Birds*. Using Unity's physics system, we are able
    to make all the levels that we will ever want to play. With this game, we also
    explored Unity's 2D pipeline for creating great 2D games. Our birds and slingshot
    are 3D assets, giving us the ability to light and shade them. The pigs and background,
    however, are 2D images, reducing our lighting options but allowing greater detail
    in the assets. The 2D images were also crucial in the creation of the parallax
    scrolling effect of the background. Finally, the blocks that make up the levels
    appear to be 2D but are actually 3D blocks. We also created a level-selection
    screen. From here, the player can see their high scores and pick any of the levels
    that we created.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Unity中的物理系统，并重新制作了极其流行的移动游戏，*愤怒的小鸟*。使用Unity的物理系统，我们能够制作出我们想要玩的所有关卡。通过这个游戏，我们还探索了Unity的2D管线，用于创建优秀的2D游戏。我们的鸟和弹弓是3D资源，使我们能够对它们进行光照和阴影处理。然而，猪和背景是2D图像，这减少了我们的光照选项，但使资源具有更高的细节。2D图像在创建背景的视差滚动效果方面也至关重要。最后，构成关卡的方块看似2D，实际上是3D方块。我们还创建了一个关卡选择屏幕。从这里，玩家可以看到他们的高分并选择我们创建的任何关卡。
- en: In the next chapter, we return to the Monkey Ball game we started in the previous
    chapter. We are going to create and add all of the special effects that finish
    off a game. We will add the bouncing and popping sound effects that every Monkey
    Ball game needs. We will also add various particle effects. When the bananas are
    collected, they will create a small explosion, rather than just disappearing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到上一章开始制作的猴子球游戏。我们将创建并添加所有使游戏完整的特殊效果。我们将添加每个猴子球游戏都需要的声音弹跳和爆裂效果。我们还会添加各种粒子效果。当香蕉被收集时，它们将产生一个小型爆炸，而不是简单地消失。
