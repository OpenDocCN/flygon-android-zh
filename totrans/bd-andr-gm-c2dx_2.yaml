- en: Chapter 2. Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover how to create and handle all your game graphics.
    We will create the scenes, the transitions between those using the game director,
    create sprites, locate them in the desired position, move them around using actions,
    and bring our characters to life using animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the game menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple screen resolutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene concept is very important within the Cocos2d-x game engine, since
    all the displayed screens in our game are considered scenes. Creating an analogy
    between Cocos2d-x and the Android native Java development, we can say that a Cocos2d-x
    scene is equivalent to what Android calls activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter we introduced the `AppDelegate` class, and we explained
    that it has the responsibility of loading the framework on the device and then
    executing the game-specific code. This class contains the `ApplicationDidFinishLaunching`
    method, which is the entry point of our code. In this method, we instantiate the
    scene that is going to first be displayed in our game, and then request the `director`
    to load it, as we can see in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the C++ code is run in a single Android activity; nevertheless, we can add
    native activities to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scene, in itself, is not an object container, that is why it should contain
    at least one instance of the `Layer` class so that we can add objects to it. This
    layer creation process has been encapsulated in the framework of macro `CREATE_FUNC`.
    You just have to invoke the macro and pass the name of the class as a parameter,
    and it will generate the Layer creation code.
  prefs: []
  type: TYPE_NORMAL
- en: Layer manipulation had multiple uses related to event handling in the previous
    versions of the framework; nevertheless, the event dispatcher engine was completely
    rewritten in version 3.0\. The only reason why the Layer concept still exists
    in Cocos2d-x 3.4 is compatibility. The framework creators officially announced
    that they may remove the Layer concept in further versions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the director
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scenes are controlled by the Cocos2d-x director, which is a class that handles
    our game flow. It applies the singleton design pattern, which ensures that there
    is only one instance of the class. It controls the kind of scene that should be
    presented through a scene stack, similar to how Android handles scenes.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the last scene pushed to the stack is the one that is going
    to be presented to the user. When the scene is removed, the user will be able
    to see the scene that was previously visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are using the single director instance more than once in a single function,
    we can store its reference on a local variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can also store it on a class attribute so that it is accessible from all
    over the class. This will allow us to type less, and it will also represent a
    performance improvement, so that we are not making several calls to the `getInstance`
    static method each time we want to access the singleton instance.
  prefs: []
  type: TYPE_NORMAL
- en: Director instance can also provide us with useful information, such as screen
    dimensions, and debug information, which is enabled in our Cocos project by default.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start and create our game. The first feature that we are going to add
    is the functionality for pausing and resuming our game. Let's start building –
    we'll start by setting up the screen that will appear when we pause the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will achieve this by adding a new pause scene to the scene stack. When this
    screen is removed from the stack, the HelloWorld scene will show up because it
    was the displayed screen before the pause scene was pushed into the scene stack.
    The following code listing shows how we can easily pause our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our resources files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created our Cocos2d-x project, some resources such as images and fonts
    have been added by default to the `Resources` folder of our project. We are going
    to organize them, so that it is easier to handle them. For that matter, we are
    going to create an `Image` folder in the `Resources` directory. In this new folder,
    we are going to put all our images. Later on in this chapter, we will explain
    how we are going to organize the different versions of each image according to
    the Android device screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Within the resources bundled with this chapter, we have provided you with the
    images that you will need in order to build the code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our pause scene header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let us create our pause scene header file. We have created it using
    the `HelloWorld.h` header file as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can avoid typing `cocos2d` each time you refer to the Cocos2d-x class contained
    in the `cocos2d` namespace by typing `using namespace cocos2d`; nevertheless,
    using it in a header file is considered a bad practice, because the code may fail
    to compile it when there are any repeated field names within all the included
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the pause scene implementation file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let us create our pause scene implementation file. Analogous to what we
    did in the previous section, we will create this file based on the `HelloWorld.cpp`
    file created by the project creation script.
  prefs: []
  type: TYPE_NORMAL
- en: Within the following code, you will find the menu creation code bundled in the
    Cocos2d-x template project. We will explain how to create the game menus in a
    further section of this chapter, you will also learn font creation, and this will
    be explained in detail in [Chapter 5](ch05.html "Chapter 5. Handling Text and
    Fonts"), *Handling Texts and Fonts*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the generated `HelloWorldScene.h` scene, we are now adding the following
    line of code after the definition of the `menuCloseCallback` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create the implementation for the `pauseCallBack` method in the
    `HelloWorldScene.cpp` implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the `closeItem` creation by making it call the `pauseCallBack`
    method rather than the `menuCloseCallBack` method, so this line will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we have created a simple pause scene, and this is pushed to the scene stack
    when the close button is pressed and it is closed when the blue button is pressed
    from within the pause scene.
  prefs: []
  type: TYPE_NORMAL
- en: We will now add the `PauseScene.cpp` file to the android makefile named `Android.mk`
    located on the `jni` folder of your eclipse project on the `LOCAL_SRC_FILES` section
    above `HelloWorldScene.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The director is also responsible for playing the transitions while swapping
    scenes, Cocos2d-x 3.4 currently offers more than 35 different scene transition
    effects, such as fades, flips, page turn, split, and zoom among others.
  prefs: []
  type: TYPE_NORMAL
- en: Transition is a subclass of the `Scene` class, which means that you can pass
    a transition instance to any method that receives a scene object, such as `runWithScene`,
    `replaceScene`, or `pushScene` methods from the `director` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us use a simple transition effect, when passing from the gameplay scene
    to the pause scene. We will simply do this by creating a new instance of the `TransitionFlipX`
    class and passing it to the director''s `pushScene` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Understanding nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node represents all the visible objects on the screen, it is, in fact, the superclass
    of all the scene elements, including the scene itself. It is the base framework
    class, and it has the basic methods that allow you to handle graphics characteristics,
    such as position and depth.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our game, the sprites represent the images of our scenes, just like the background,
    the enemies, and our player.
  prefs: []
  type: TYPE_NORMAL
- en: Later in [Chapter 4](ch04.html "Chapter 4. User Input"), *User Input*, we will
    add event listeners to the scenes, so that it can interact with the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very easy to instantiate the Cocos2d-x core classes. We have seen that
    the `scene` class has a `create` method; similarly, the `sprite` class has a static
    method with the same name, as we can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Cocos2d-x currently supports PNG, JPG, and TIF image formats for sprites; nevertheless,
    it is highly recommended that we use the PNG images, because of its transparency
    capabilities, which are not present in either the JPG or the TIF format, and also
    because of the image quality that is provided by this format in a fair file size.
    That is why you will see that all the Cocos2d-x-generated templates and samples
    use this image format.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created our own sprite, we can easily position it on the screen
    by using the `setPosition` method, but before doing it, we will explain the anchor
    point concept.
  prefs: []
  type: TYPE_NORMAL
- en: Setting anchor points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All sprites have a reference point called the **anchor point**. When we position
    a sprite using the `setPosition` method, what the framework actually does is that
    it sets the specified two-dimensional position to the anchor point so that it
    affects the whole image. By default, the anchor point is set to the sprite''s
    center, as we can see in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting anchor points](img/B04193_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the Cocos2d-x coordinate system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Cocos2d-x coordinate system, unlike most of the computerized graphic engines,
    has its origin (0,0) at the lower left part of the screen, as we can see in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Cocos2d-x coordinate system](img/B04193_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So if we want to position our sprite at the origin point (0,0), we can achieve
    it by calling the `setPosition` method contained in the sprite class. It is overloaded,
    so it can receive either two floats indicating x and y position, a `Point` class
    instance, or a `Vec2` instance. Although the `Vec2` instances are used in the
    generated code, the official Cocos2d-x documentation states that passing the floating
    numbers is up to 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this code, we can see that only the upper right zone of the
    sprite is visible, which represents only 25 percent of its size, as we have shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Cocos2d-x coordinate system](img/B04193_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, in case you would like the sprite to be shown at the origin, you have many
    options, such as positioning the sprite at the point that corresponds to half
    of the sprite''s height and half of its width, which could be determined by using
    the sprite method, `getContentSize`, which returns a size object that has the
    sprite height and width properties. Another option, which might be easier than
    this, is to reset the sprite anchor point to (0,0) ; so that when the sprite is
    positioned at the origin of the screen, it is completely visible and located at
    the lower leftmost region of the screen. The `setAnchorPoint` method receives
    a `Vec2` instance as the parameter. In the following code listing, we are passing
    a `Vec2` instance pointing to the origin (0,0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Vec2` class has a constructor that receives no parameters, it creates a
    `Vec2` object with an initial value of 0,0.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute our code, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Cocos2d-x coordinate system](img/B04193_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why the default anchor point location is at the center of the sprite
    is because it makes it easier to be positioned at the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sprites to the scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After our sprite object is created and positioned, we need to add it to our
    scene by using the `addChild` method, which contains two parameters: the pointer
    to the node that you want to add to the scene and an integer that represents its
    position in *z* axis. The node with the highest *z* value will be displayed above
    those with lower values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us add the background image to our `HelloWorld` scene: we are going
    to do it by following the same steps we used in order to position the bomb at
    the lower left area of the screen in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now added our background in a *z* position of -1, so any node with
    a position of 0 or higher will be displayed on top of the background, as we can
    see in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sprites to the scene](img/B04193_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Positioning sprites outside the visible area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have a bomb, which doesn't move, at the bottom of the screen. We will
    now position it at the top center zone of the screen, outside the visible region,
    so that when we get this sprite to move, it will look like it is raining bombs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we previously mentioned, let us position our bomb in the visible area, and
    then, in the next section we will make it move toward the ground using the actions
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the `setAnchorPoint` sentence; so, now, the bombs have a default
    anchor point, and we have modified the `setPosition` statement, so that now, we
    are positioning it just in the visible area.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the player sprite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let us create and position our player sprite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code we created a player sprite. We used the default anchor
    point that points directly to the center of the image and centered it horizontally
    by positioning it to half of the screen width and 23 percent of the screen height,
    since the background image provided in this book for this chapter was drawn within
    those proportions. We have added it with a z value of 0, so this means that it
    will be displayed in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us take care of the bomb, let us position it in the visible area, and
    then, in the next section, we will make it move it toward the ground using the
    actions functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the `setAnchorPoint` sentence; so now, the bombs have the default
    anchor point, and we have modified the `setPosition` statement, so now, we are
    positioning it in the visible area.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter we have used many images, which, as we have previously
    mentioned are stored in the `Resources` folder of our Cocos2d-x project. You could
    create sub folders to organize your files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily tell our sprites to perform concrete actions, such as jump, move,
    skew, and so on. It requires a few lines to get our sprites to execute the desired
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Moving sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can make our sprite move to a specific area of the screen by creating a `MoveTo`
    action and then making the sprite execute the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code listing, we are making the bomb fall to the bottom of
    the screen by simply writing the following code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have created a `moveTo` node that will move the bomb sprite to the current
    horizontal position, but it will also move it to the bottom of the screen until
    it is not visible. In order to achieve this, we made it move to the y position
    of the negative half of the height of the sprite. Since the anchor point is set
    to the center point of the sprite, moving it to the negative half of its height
    will be enough to make it move outside the screen's visible area.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is crashing with our player sprite, but the bomb just continues
    downward as it still doesn't detect the collisions. In the next chapter, we will
    add collision handling to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cocos2d-x 3.4 has its own physics engine, which includes an easy mechanism to
    detect the collisions among sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to move our sprite to a position that is relative to its current
    location, we can use the `MoveBy` class, which receives the parameters of how
    much we want the sprite to move horizontally and vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can make the sprite move in the opposite direction by using the `reverse`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we have a predefined sequence of actions that we want to execute in
    several parts of our code, this can be handled by sequences. As the name suggests,
    it consists of a list of actions that are executed in a predefined order, which
    can be reversed if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: It is very common to use sequences each time we use actions, so in the sequence
    we add the `moveTo` node, and then a function call that executes a method after
    the movement has finished, so that it will allow us to delete the sprite from
    the memory, reposition it, or do any other common tasks that are required in video
    games.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are creating a sequence where we first demand the
    bombs to move to the ground, and we request to execute the `moveFinished` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we pass a `nullptr` parameter at the end of the sequence, so Cocos2d-x
    will stop executing the items in the sequence, when it sees this value; if you
    don't specify it, then this will cause your game to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since version 3.0, Cocos2d-x recommends using the `nullptr` keyword for referring
    to the null pointers rather than utilizing the conventional NULL macro, which
    will still work, but is not considered as best practice within C++.
  prefs: []
  type: TYPE_NORMAL
- en: Animating sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to give a more professional aspect to our game, we could animate our
    sprites so that it does not constantly show a still image but rather displays
    animated characters, enemies, and obstacles. Cocos2d-x provides an easy mechanism
    to add these kinds of animations to our sprites, as we can appreciate in the following
    code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Improving performance with sprite sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we can create sprite animations based on the images located in several
    files, as we have done in our previous code, it would be very inefficient to load
    a large number of files. That is why we prefer loading a single file that contains
    several images. In order to achieve this, a plain text file with the `plist` extension
    indicates the exact location of each image within the file, Cocos2d-x is able
    to read this plain text file and extract all the images from a single sprite sheet
    file. There are many tools that allow you to create your own sprite sheet, the
    most popular one is the texture packer, which you can download from [https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker)
    and try for free on Windows or Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the resources we are including are: a `plist` file named `bunny.plist`
    and the `bunny_ss.png` sprite sheet created with texture packer. You can load
    any frame of this sheet with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Game menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common to have menus in some part of our games, such as the main
    screen and the configuration screen. This framework provides us with a simple
    way to add menus to our games.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code listing shows the menu creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the previous listing, we have first created a menu item
    by instantiating the `MenuItemImage` class and passing three parameters to the
    `create` method: the first parameter indicates what image should be displayed
    for the menu item, the second is the image that should be displayed when the image
    is selected, and the third parameter specifies the method that should be invoked
    when the menu item is selected.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cocos2d-x branch 3 now allows the programmer to use the lambda expressions to
    handle the menu items.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple screen resolutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating games, you should decide which screen resolutions you are planning
    to support, and then create all the images with a size that will neither look
    pixelated on high resolution screens nor affect performance while loading on the
    low capability devices. All those versions of images should have the same name
    but they should be stored in different directories in the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have three directories: the first with the images in high
    resolution, the second with the images in mid resolution, and the third with the
    images in low resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After having all our images in the adequate sizes so as to suit all the resolution
    needs, we have to write the code that picks the right image set based on the device''s
    screen resolution. As we have mentioned before, the `AppDelegate` class contains
    `applicationDidFinishLaunching`, which is launched immediately after the Cocos2d-x
    framework is loaded on the device. In this method we are going to write our multiple
    screen resolution code, as we can see in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Modify the `AndroidManifest.xml` file by setting the value of `android:screenOrientation`
    to `portrait`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the complete code of the `HelloWorldScene.cpp` implementation file,
    where we have created and positioned our background, our animated player, and
    our moving bomb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in the `init` function, we are going to instantiate and initialize our
    sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add animations using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are going to create the sequence that will move our bomb from the top
    to the bottom of the screen. After the movement is complete, we will specify to
    call the `moveFinished` method. We just use this for printing a log message for
    testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows us how our game looks after putting together all
    the codes done during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting everything together](img/B04193_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to create our game scenes, and how to add
    sprites and menus to it. We have also learned how to animate sprites easily and
    move them around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to move our sprites in a more realistic
    way by using the built-in physics engine; with it, we will easily configure the
    motion and add collision detection to our game.
  prefs: []
  type: TYPE_NORMAL
