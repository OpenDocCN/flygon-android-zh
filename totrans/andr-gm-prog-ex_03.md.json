["```java\n// SurfaceView allows us to handle the onTouchEvent\n@Override\npublic boolean onTouchEvent(MotionEvent motionEvent) {\n\n    // There are many different events in MotionEvent\n    // We care about just 2 - for now.\n    switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n\n        // Has the player lifted their finger up?\n        case MotionEvent.ACTION_UP:\n // Do something here\n            break;\n\n        // Has the player touched the screen?\n        case MotionEvent.ACTION_DOWN:\n // Do something here\n           break;\n    }\n   return true;\n}\n```", "```java\nprivate boolean boosting;\n```", "```java\nboosting = false;\n```", "```java\npublic void setBoosting() {\n  boosting = true;\n}\n\npublic void stopBoosting() {\n  boosting = false;\n}\n```", "```java\n// Has the player lifted there finger up?\ncase MotionEvent.ACTION_UP:\n player.stopBoosting();\n  break;\n\n// Has the player touched the screen?\ncase MotionEvent.ACTION_DOWN:\n player.setBoosting();\n  break;\n```", "```java\nprivate final int GRAVITY = -12;\n\n// Stop ship leaving the screen\nprivate int maxY;\nprivate int minY;\n\n//Limit the bounds of the ship's speed\nprivate final int MIN_SPEED = 1;\nprivate final int MAX_SPEED = 20;\n```", "```java\npublic void update() {\n\n  // Are we boosting?\n  if (boosting) {\n    // Speed up\n    speed += 2;\n  } else {\n    // Slow down\n    speed -= 5;\n  }\n\n  // Constrain top speed\n  if (speed > MAX_SPEED) {\n    speed = MAX_SPEED;\n}\n\n  // Never stop completely\n  if (speed < MIN_SPEED) {\n    speed = MIN_SPEED;\n}\n\n  // move the ship up or down\n  y -= speed + GRAVITY;\n\n  // But don't let ship stray off screen\n  if (y < minY) {\n    y = minY;\n  }\n\n  if (y > maxY) {\n    y = maxY;\n  }\n\n}\n```", "```java\n// Get a Display object to access screen details\nDisplay display = getWindowManager().getDefaultDisplay();\n// Load the resolution into a Point object\nPoint size = new Point();\ndisplay.getSize(size);\n```", "```java\n// Create an instance of our Tappy Defender View\n// Also passing in this.\n// Also passing in the screen resolution to the constructor\ngameView = new TDView(this, size.x, size.y);\n\n```", "```java\nTDView(Context context, int x, int y) {\n```", "```java\nplayer = new PlayerShip(context, x, y);\n```", "```java\npublic PlayerShip(Context context, int screenX, int screenY) {\n```", "```java\nmaxY = screenY - bitmap.getHeight();\nminY = 0;\n```", "```java\npublic class EnemyShip{\n    private Bitmap bitmap;\n    private int x, y;\n    private int speed = 1;\n\n    // Detect enemies leaving the screen\n    private int maxX;\n    private int minX;\n\n    // Spawn enemies within screen bounds\n    private int maxY;\n    private int minY;\n}\n```", "```java\n//Getters and Setters\npublic Bitmap getBitmap(){\n  return bitmap;\n}\n\npublic int getX() {\n  return x;\n}\n\npublic int getY() {\n  return y;\n}\n```", "```java\n// Constructor\npublic EnemyShip(Context context, int screenX, int screenY){\n    bitmap = BitmapFactory.decodeResource \n    (context.getResources(), R.drawable.enemy);\n\n  maxX = screenX;\n  maxY = screenY;\n  minX = 0;\n  minY = 0;\n\n  Random generator = new Random();\n  speed = generator.nextInt(6)+10;\n\n  x = screenX;\n  y = generator.nextInt(maxY) - bitmap.getHeight();\n}\n```", "```java\npublic void update(int playerSpeed){\n\n  // Move to the left\n  x -= playerSpeed;\n  x -= speed;\n\n  //respawn when off screen\n  if(x < minX-bitmap.getWidth()){\n    Random generator = new Random();\n    speed = generator.nextInt(10)+10;\n    x = maxX;\n    y = generator.nextInt(maxY) - bitmap.getHeight();\n  }\n}\n```", "```java\n// Move to the left\nx -= playerSpeed;\nx -= speed;\n```", "```java\nif(x < minX-bitmap.getWidth()){\n```", "```java\n// Game objects\nprivate PlayerShip player;\npublic EnemyShip enemy1;\n\n```", "```java\npublic EnemyShip enemy2;\npublic EnemyShip enemy3;\n\n```", "```java\n// Initialize our player ship\nplayer = new PlayerShip(context, x, y);\nenemy1 = new EnemyShip(context, x, y);\nenemy2 = new EnemyShip(context, x, y);\nenemy3 = new EnemyShip(context, x, y);\n\n```", "```java\n// Update the player\nplayer.update();\n// Update the enemies\nenemy1.update(player.getSpeed());\nenemy2.update(player.getSpeed());\nenemy3.update(player.getSpeed());\n```", "```java\n// Draw the player\ncanvas.drawBitmap\n    (player.getBitmap(), player.getX(), player.getY(), paint);\n\ncanvas.drawBitmap\n (enemy1.getBitmap(), \n enemy1.getX(), \n enemy1.getY(), paint);\n\ncanvas.drawBitmap\n (enemy2.getBitmap(), \n enemy2.getX(), \n enemy2.getY(), paint);\n\ncanvas.drawBitmap\n (enemy3.getBitmap(), \n enemy3.getX(), \n enemy3.getY(), paint);\n\n```", "```java\npublic class SpaceDust {\n\n    private int x, y;\n    private int speed;\n\n    // Detect dust leaving the screen\n    private int maxX;\n    private int maxY;\n    private int minX;\n    private int minY;\n\n    // Constructor\n    public SpaceDust(int screenX, int screenY){\n\n        maxX = screenX;\n        maxY = screenY;\n        minX = 0;\n        minY = 0;\n\n        // Set a speed between  0 and 9\n        Random generator = new Random();\n        speed = generator.nextInt(10);\n\n        //  Set the starting coordinates\n        x = generator.nextInt(maxX);\n        y = generator.nextInt(maxY);\n    }\n\n    public void update(int playerSpeed){\n        // Speed up when the player does\n        x -= playerSpeed;\n        x -= speed;\n\n        //respawn space dust\n        if(x < 0){\n            x = maxX;\n            Random generator = new Random();\n            y = generator.nextInt(maxY);\n            speed = generator.nextInt(15);\n        }\n    }\n\n    // Getters and Setters\n    public int getX() {\n\n        return x;\n    }\n\n    public int getY() {\n\n        return y;\n    }\n}\n```", "```java\n// Make some random space dust\npublic ArrayList<SpaceDust> dustList = new\n  ArrayList<SpaceDust>();\n```", "```java\nint numSpecs = 40;\n\nfor (int i = 0; i < numSpecs; i++) {\n  // Where will the dust spawn?\n  SpaceDust spec = new SpaceDust(x, y);\n  dustList.add(spec);\n}\n```", "```java\nfor (SpaceDust sd : dustList) {\n  sd.update(player.getSpeed());\n}\n```", "```java\n// White specs of dust\npaint.setColor(Color.argb(255, 255, 255, 255));\n\n//Draw the dust from our arrayList\nfor (SpaceDust sd : dustList) {\n      canvas.drawPoint(sd.getX(), sd.getY(), paint);\n\n    // Draw the player\n    // ...\n}\n```", "```java\nif(ship.getHitbox().right > enemy.getHitbox().left  \n    && ship.getHitbox().left < enemy.getHitbox().right ){\n    // Ship is intersecting enemy on x axis\n    //But they could be at different heights\n\n    if(ship.getHitbox().top < enemy.getHitbox().bottom  \n        && ship.getHitbox().bottom > enemy.getHitbox().top ){\n        // Ship is intersecting enemy on y axis as well\n        // Crash\n    }\n}\n```", "```java\n// Get the distance of the two objects from \n// the edges of the circles on the x axis\ndistanceX = (ship.getHitBox.centerX + ship.getHitBox.radius) - \n  (enemy.getHitBox.centerX + enemy.getHitBox.radius;\n\n// Get the distance of the two objects from \n// the edges of the circles on the y axis\ndistanceY = (ship.getHitBox.centerY + ship.getHitBox.radius) -  \n  (enemy.getHitBox.centerY + enemy.getHitBox.radius;\n\n// Calculate the distance between the center of each circle\ndouble distance = Math.sqrt\n    (distanceX * distanceX + distanceY * distanceY);\n\n// Finally see if the two circles overlap\nif (distance < ship.getHitBox.radius + enemy.getHitBox.radius) {\n    // bump\n}\n```", "```java\n// A hit box for collision detection\nprivate Rect hitBox;\n```", "```java\npublic Rect getHitbox(){\n  return hitBox;\n}\n```", "```java\n// Initialize the hit box\nhitBox = new Rect(x, y, bitmap.getWidth(), bitmap.getHeight());\n```", "```java\n// Refresh hit box location\nhitBox.left = x;\nhitBox.top = y;\nhitBox.right = x + bitmap.getWidth();\nhitBox.bottom = y + bitmap.getHeight();\n```", "```java\n// This is used by the TDView update() method to\n// Make an enemy out of bounds and force a re-spawn\npublic void setX(int x) {\n  this.x = x;\n}\n```", "```java\n// Collision detection on new positions\n// Before move because we are testing last frames\n// position which has just been drawn\n\n// If you are using images in excess of 100 pixels\n// wide then increase the -100 value accordingly\nif(Rect.intersects\n  (player.getHitbox(), enemy1.getHitbox())){\n    enemy1.setX(-100);\n}\n\nif(Rect.intersects\n  (player.getHitbox(), enemy2.getHitbox())){\n    enemy2.setX(-100);\n}\n\nif(Rect.intersects\n  (player.getHitbox(), enemy3.getHitbox())){\n    enemy3.setX(-100);\n}\n```", "```java\n// Rub out the last frame\ncanvas.drawColor(Color.argb(255, 0, 0, 0));\n\n// For debugging\n// Switch to white pixels\npaint.setColor(Color.argb(255, 255, 255, 255));\n\n// Draw Hit boxes\ncanvas.drawRect(player.getHitbox().left, \n player.getHitbox().top, \n player.getHitbox().right, \n player.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy1.getHitbox().left, \n enemy1.getHitbox().top, \n enemy1.getHitbox().right, \n enemy1.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy2.getHitbox().left, \n enemy2.getHitbox().top, \n enemy2.getHitbox().right, \n enemy2.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy3.getHitbox().left, \n enemy3.getHitbox().top, \n enemy3.getHitbox().right, \n enemy3.getHitbox().bottom, \n paint);\n\n```"]