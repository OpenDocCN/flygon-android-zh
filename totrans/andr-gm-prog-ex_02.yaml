- en: Chapter 2. Tappy Defender – First Step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first game, which we will learn about in three chapters. In this
    chapter, we will closely examine the goals for the finished product. It helps
    a lot when building a game, if we know exactly what we are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: We can then look at the structure of our code, including an approximate design
    pattern that we will be adhering to. Then, we will put together the code skeleton
    of our first game engine. Finally, to finish the chapter, we will draw our first
    real object from the game and animate it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will then be ready for [Chapter 3](ch03.html "Chapter 3. Tappy Defender –
    Taking Flight"), *Tappy Defender – Taking Flight*, where we can make really fast
    progress before completing our first game in [Chapter 4](ch04.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the first game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will flesh out exactly what our game will be. The backstory;
    who is our hero and what are they trying to achieve? The game mechanics; what
    will the player actually do? What buttons will he press and in what way is that
    a challenge or fun thing to do? Then, we will look at the rules. What constitutes
    victory, death, and progress? Finally, we will get technical and start to examine
    how we will actually build the game.
  prefs: []
  type: TYPE_NORMAL
- en: Backstory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Valerie has been defending the far outposts of humanity since the early '80s.
    Her brave exploits were originally immortalized in the 1981 arcade classic, Defender.
    However, after over 30 years on the front line, she is retiring and it is time
    to begin the journey home. Unfortunately, in a recent skirmish, her ship's engines
    and navigation systems were severely damaged. Therefore, now she must fly all
    the way home using only her boost thruster.
  prefs: []
  type: TYPE_NORMAL
- en: This means that she must fly her ship by simultaneously thrusting up and forward,
    kind of bouncing really, while avoiding enemies who try to crash into her. In
    a recent communication with Earth, Valerie was heard to claim that it was, "Like
    trying to fly a lame bird." This is some concept art of Valerie in her damaged
    ship because it helps to visualize our game as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Backstory](img/B04322_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have learned a little bit about our hero and her predicament, we
    take a closer look at the mechanics of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mechanics are the key actions that a player must make and become good at, to
    be able to beat the game. When designing a game, you can rely on tried and tested
    ideas for mechanics or you can invent your own. In Tappy Defender, we will be
    using a mechanic where the player taps and holds the screen to boost the ship.
  prefs: []
  type: TYPE_NORMAL
- en: This boosting will raise the ship up the screen, but will also make the ship
    speed up and therefore be more vulnerable. When the player removes their finger,
    the boost engine will cut out and the ship will fall downward and decelerate,
    thus making the ship slightly less vulnerable. Therefore, a very fine and masterful
    balance of boosting and not boosting is required to survive.
  prefs: []
  type: TYPE_NORMAL
- en: Tappy Defender is of course heavily inspired by Flappy Bird and a multitude
    of similar games that followed its success.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a how-far-can-I-get scoring system like Flappy Bird, Tappy Defender
    will have a goal of reaching "home". Then, the player can replay the game multiple
    times in order to try and beat their fastest time. Of course to go faster, the
    player must boost more frequently and put Valerie in greater peril.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the unlikely event you have never played or seen Flappy Bird, it is well
    worth spending 5 minutes having a play with this type of game now. You can download
    one of the many Flappy Bird inspired apps from the Google Play store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.google.com/store/search?q=flappy%20bird&c=apps](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will define things which balance the game and make it fair and consistent
    for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: The player's ship is much tougher than the enemy ships. This is because the
    player's ship has shields. Each time the player collides with an enemy, the enemy
    is instantly destroyed, but the player loses a shield. The player has three shields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will need to fly a set number of kilometers to reach home.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player reaches home, they win the game. If their time was the
    fastest, they also get a new fastest time, like a high score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies will spawn at a random height on the far right of the screen and fly
    toward the player at a random speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player is always positioned on the far left of the screen, but boosting
    will mean the enemies approach more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a loose design pattern, where we will separate our code based on
    a control part, model part, and view. This is how we will separate our code into
    three areas.
  prefs: []
  type: TYPE_NORMAL
- en: Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the part of our code that will control all other parts. It will decide
    when to show the view, it will initialize all our game objects from the model,
    and it will prompt decisions based on the states of data to take place within
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model is our game data and logic. What do the ships look like? Where on
    the screen are our ships? How fast are they going, and so on. Furthermore, the
    model part of our code is the intelligence system for each of our game objects.
    Although our enemies in this game don't have sophisticated AI, they will know
    and decide for themselves how fast they are going, when to respawn and more.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The view is exactly what it sounds like. It is the part of our code that will
    do the actual drawing based on the state of the models. It will draw when the
    control part of our code tells it. It will not have any influence over the game
    objects. For example, the view will not decide where an object is or even what
    it looks like. It just draws and then hands control back to the control code.
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern reality check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, the separation is not as clear as the discussion suggests. In fact,
    the code for drawing and control is within the same class. However, you will see
    that the logic of drawing and controlling is separate within that class.
  prefs: []
  type: TYPE_NORMAL
- en: By separating our game into these three parts, we will see how we simplify the
    development and avoid getting tied up in messy code that constantly expands as
    we add new features to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look more closely at where this pattern fits in with our code.
  prefs: []
  type: TYPE_NORMAL
- en: The game code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we must take account of the system we are working within. In this
    case, it is the Android system. If you have been making Android apps for a while,
    you may be wondering where this pattern stuff fits in with the Android Activity
    lifecycle. If you are new to Android, you might ask what the Activity lifecycle
    is.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Activity lifecycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android Activity lifecycle is the framework we must work within to make
    any type of Android app. There is a class called `Activity` that we must derive
    from and is an entry point to our app. In addition, we need to be aware that this
    class, that our game is an object of, also has some methods we can override. These
    methods control the lifecycle of our app.
  prefs: []
  type: TYPE_NORMAL
- en: When an app is started by the user, our `Activity` object is created and a number
    of the methods that we can override are called in sequence. This is what happens.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Activity` object is created, three methods are called in sequence;
    `onCreate()`, `onStart()`, and `onResume()`. At this point, the app is now running.
    In addition, when the user quits an app or the app is interrupted, perhaps by
    a phone call, the `onPause` method is called. The user may decide, perhaps after
    completing their phone call, to return to the app. If this happens, the `onResume`
    method is called, following which the app is running again.
  prefs: []
  type: TYPE_NORMAL
- en: Should the user not return to the app or the Android system decides that it
    wants the system resources for something else, two further methods are called
    to clean up. First `onStop()`, and then `onDestroy()`. The app is now destroyed
    and any attempt to return to the game again will result in the Activity lifecycle
    starting from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do as game programmers is be aware of this lifecycle and observe
    a few rules of good housekeeping. We will implement and explain the rules of good
    housekeeping as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Android Activity lifecycle is much more complex and far more nuanced than
    I have just explained it. However, we know everything we need to get programming
    our first game. If you want to know more please have a look at this article on
    the Android developer''s web site at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have catered for the Android Activity lifecycle, the core methods of
    our class representing the control part of the pattern will be as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the state of our game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the game objects based on their state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pause to lock the frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get player input. Actually because parts 1, 2, and 3 happen in a thread, this
    part can happen at any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last bit of preparation, before we start to build our game for real.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Studio file structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android system is quite particular about where we put our class files, including
    `Activity` and where in the file hierarchy we place our assets like sound files
    and graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a really quick overview of where we will be putting everything. You
    don't need to memorize this, as we will remind ourselves of the correct folder
    while adding assets. We will step through the activity/class creation process
    the first few times we need to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a heads up, here is an annotated diagram of what your Android Studio project
    explorer will look like by the end of the Tappy Defender project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Android Studio file structure](img/B04322_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can actually start building Tappy Defender.
  prefs: []
  type: TYPE_NORMAL
- en: Building the home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have done all the planning and preparation, we can get started with
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: To use the code files, you will still need to create an Android Studio project.
    In addition, you will need to change the package name in the very first line of
    code of each of the JAVA files. Change the package name to match the package name
    of the project you created. Finally, you will need to make sure that any assets
    such as images or sound files are placed into the appropriate folder in the project.
    All the required assets for each project are supplied in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fire up Android Studio and create a new project by following these steps. All
    the files to get the project to where we will be, by the end of this chapter,
    are in the download bundle in the `Chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: On the **Welcome to Android Studio** dialog, click on **Start a new Android
    Studio project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create New Project** window shown next, we need to enter some basic
    information about our app. These bits of information will be used by Android Studio
    to determine the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following image, you can see the **Edit** link where you can customize
    the package name if required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you will be copy/pasting the supplied code into your project, then use `C1
    Tappy Defender` for the **Application name** field and `gamecodeschool.com` in
    the **Company Domain** field as shown in the following screenshot:![Creating the
    project](img/B04322_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button when you're ready. When asked to select the form
    factors, your app will run on, we can accept the default settings (**Phone and
    Tablet**). So click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Add an activity to mobile** dialog, just click on **Blank Activity**
    followed by the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Customize the Activity** dialog, again we can accept the default settings
    because `MainActivity` seems like a good name for our main Activity. So click
    on the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio has built the project and created a number of files, most of
    which we will see and edit during the course of building this game. As mentioned
    earlier, even if you are just copying and pasting the code, you need to go through
    this step because Android Studio is doing things behind the scenes to make our
    project work.
  prefs: []
  type: TYPE_NORMAL
- en: Building the home screen UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and simplest part of our Tappy Defender game is the home screen.
    All we need is a neat picture with a scene about the game, a high score, and a
    button to start the game. The finished home screen will look a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the home screen UI](img/B04322_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we built the project, Android Studio opens up two files ready for us to
    edit. You can see them as tabs in the following Android Studio UI designer. The
    files (and tabs) are `MainActivity.java` and `activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the home screen UI](img/B04322_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `MainActivity.java` file is the entry point to our game, and we will see
    this in more detail soon. The `activity_main.xml` file is the UI layout that our
    home screen will use. Now, we can go ahead and edit the `activity_main.xml` file,
    so it actually looks like our home screen should.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, your game will be played with the Android device in landscape
    mode. If we change our UI preview window to landscape, we will see your progress
    more accurately. Look for the button shown in the next image. It is just preceding
    the UI preview:![Building the home screen UI](img/B04322_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the button shown in the preceding screenshot, and your UI preview will
    switch to landscape like this:![Building the home screen UI](img/B04322_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure `activity_main.xml` is open by clicking on its tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will set in a background image. You can use your own or mine from `Chapter2/drawable/background.jpg`
    in the download bundle. Add your chosen image to the `drawable` folder of the
    project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** window of the UI designer, find and click on the **background**
    property as shown in the next image:![Building the home screen UI](img/B04322_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, in the previous image the button labelled **...** is outlined. It is just
    to the right of the **background** property. Click on that **...** button and
    browse to and select the background image file that you will be using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a **TextView** widget that we will use to display the high score.
    Note that there is already a **TextView** widget on the layout. It says **Hello
    World**. You will modify this and use it for our high score. Left click on it
    and drag the **TextView** to where you want it. You can copy me if you intend
    using the supplied background or put it where it looks best with your background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Properties** window, find and click on the **id** property. Enter
    `textHighScore`. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it, to show
    the player's fastest time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also edit the **text** property to say `High Score: 99999` or similar
    so that the **TextView** looks the part. However, this isn''t necessary because
    your Java code will take care of this later.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will drag a button from the widget palette as shown in the following
    screenshot:![Building the home screen UI](img/B04322_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it to where it looks good on your background. You can copy me if using
    the supplied background or put it where it looks best with your background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a cool background with neatly arranged widgets (a **TextView** and
    a **Button**) for your home screen. We can add functionality via Java code to
    the **Button** widget next. Revisit the **TextView** for the player's high score
    in [Chapter 4](ch04.html "Chapter 4. Tappy Defender – Going Home"), *Tappy Defender
    – Going Home*. The important point is that both the widgets have been assigned
    a unique ID that we can use to reference and manipulate in your Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have a simple layout for our game home screen. Now, we need to add the
    functionality that will allow the player to click on the **Play** button to start
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the tab for the `MainActivity.java` file. The code that was automatically
    generated for us is not exactly what we need. Therefore, we will start again as
    it is simpler and quicker than tinkering with what is already there.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the entire contents of the `MainActivity.java` file except the package
    name and enter the following code in it. Of course, your package name may be different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mentioned code is the current contents of our main `MainActivity` class
    and the entry point of our game, the `onCreate` method. The line of code that
    begins with `setContentView...` is the line that loads our UI layout from `activity_main.xml`
    to the players screen. We can run the game now and see our home screen, but let's
    make some more progress, following which we will look at how we run the game on
    a real device at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's handle the **Play** button on our home screen. Add the two highlighted
    lines of the following code into the `onCreate` method just after the call to
    `setContentView()`. The first new line creates a new `Button` object and gets
    a reference to `Button` in our UI layout. The second line is the code that listens
    for clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have a few errors in our code. We can resolve these errors by holding
    down the *Alt* keyboard key and then pressing *Enter*. This will add an import
    directive for the `Button` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have one error. We need to implement an interface so that our code
    listens to the button clicks. Modify the `MainActivity` class declaration as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we implement the `onClickListener` interface, we must also implement the
    `onClick` method. This is where we will handle what happens when a button is clicked.
    We can automatically generate the `onClick` method by right-clicking somewhere
    after the `onCreate` method, but within the `MainActivity` class, and navigating
    to **Generate** | **Implement methods** | **onClick(v:View):void. Or just add
    the given code.**
  prefs: []
  type: TYPE_NORMAL
- en: We also need to have Android Studio add another import directive for `Android.view.View`.
    Use the *Alt* | *Enter* keyboard combination again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now scroll to near the bottom of the `MainActivity` class and see that
    Android Studio has implemented an empty `onClick` method for us. We should have
    no errors in your code at this point. Here is the `onClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we only have one `Button` object and one listener, we can safely assume that
    any clicks on our home screen are the player pressing our **Play** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android uses the `Intent` class to switch between activities. As we need to
    go to a new activity when the **Play** button is clicked, we will create a new
    `Intent` object and pass in the name of our future `Activity` class, `GameActivity`
    to its constructor. We can then use the `Intent` object to switch activities.
    Add the following code to the body of the `onClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have errors in our code because we need to generate a new import
    directive, this time for the `Intent` class so use the *Alt* | *Enter* keyboard
    combination again. We still have one error in our code. This is because our `GameActivity`
    class does not exist yet. We will now solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GameActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that when the player clicks on the **Play** button, main activity
    will close and game activity will begin. Therefore, we need to create a new activity
    called `GameActivity` that will be were your game actually executes.
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, navigate to **File** | **New** | **Activity** | **Blank
    Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Customize the Activity** dialog, change the **Activity Name** field
    to `GameActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can accept all the other default settings from this dialog, so click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did with your `MainActivity` class, we will code this class from scratch.
    Therefore, delete the entire code content from `GameActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio has generated two more files for us and done some work behind
    the scenes that we will investigate soon. The new files are `GameActivity.java`
    and `activity_game.xml`. They are both automatically opened for us in two new
    tabs, in the same place as the other tabs above the UI designer.
  prefs: []
  type: TYPE_NORMAL
- en: We will never need `activity_game.xml` because we will build a dynamically generated
    game view, not a static UI. Feel free to close that now or just ignore it. We
    will come back to the `GameActivity.java` file, when we start to code our game
    for real, later in the chapter in the *Coding the game loop* section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly mentioned that when we create a new project or a new activity, Android
    Studio does more than just creating two files for us. This is why we create new
    projects/activities the way we do.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things going on behind the scenes is the creation and modification
    of the `AndroidManifest.xml` file in the `manifests` directory.
  prefs: []
  type: TYPE_NORMAL
- en: This file is required for our app to work. Also, it needs to be edited to make
    our app work the way we want it to. Android Studio has automatically configured
    the basics for us, but we will now do two more things to this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'By editing the `AndroidManifest.xml` file, we will force both of our activities
    to run with a full screen, and we will also lock them to a landscape layout. Let''s
    make these changes here:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now, and double click on the `AndroidManifest.xml`
    file to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately following it, type or copy and paste these two lines to make `MainActivity`
    run full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately following it, type or copy and paste these two lines to make `GameActivity`
    run full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have now configured both activities from our game to be full screen. This
    presents a much more pleasing appearance to our player. In addition, we have disabled
    the player's ability to affect our game by rotating their Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We said that we will not be using a UI layout for our game screen, but instead
    a dynamically drawn view. This is where the view of our pattern comes in. Let's
    create a new class to represent our view, then we will put in the fundamental
    building blocks of our Tappy Defender game.
  prefs: []
  type: TYPE_NORMAL
- en: Building the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will leave our two activity classes alone for a while so that we can take
    a look at our class that will represent the view of our game. As we discussed
    at the start of this chapter, the view and the controller aspects will be part
    of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: The Android API provides us with an ideal class for our requirements. The `android.view.SurfaceView`
    class not only provides us a view that is designed for drawing pixels, text, lines,
    and sprites onto, but also enables us to quickly handle player input as well.
  prefs: []
  type: TYPE_NORMAL
- en: As if this wasn't useful enough, we can also spawn a thread by implementing
    the runnable interface allowing our main game loop to get player input and other
    system essentials at the same time. We will deal with the general structure of
    your new `SurfaceView` implementation now, so we can fill in the details as we
    progress with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new class for the view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without further delay, we can create a new class which extends `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the folder containing our `.java` files and select **New** | **Java
    Class** then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create New Class** dialog, name the new class `TDView,` (Tappy Defender
    view). Now, click on **OK** to have Android Studio autogenerate the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new class will open in the code editor. Amend the code to have it extend
    `SurfaceView` and implement `Runnable` as discussed in the previous section. Edit
    the highlighted parts of the code that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the *Alt* | *Enter* combination to import the missing classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we still have an error in our code. This is because we must provide
    a constructor for our `SurfaceView` implementation. Right-click just below the
    `TDView` class declaration and navigate to **Generate** | **Constructor** | **SurfaceView(Context:context)**.
    Or you can just type this in as shown in the next block of code. Now click on
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a new class called `TDView`, which extends `SurfaceView` for our
    drawing requirements and implements `Runnable` for our threading needs. We have
    also generated a constructor, which we will use soon to initialize our new class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` parameter that is passed into our constructor is a reference to
    the current state of our application within the Android system that is held by
    our `GameActivity` class. This `Context` parameter is useful/essential for a number
    of things that we will be implementing throughout this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our `TDView` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Structuring the class code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have our `TDView` class extended from the `SurfaceView` class, we
    can start coding it. To control the game, we need to be able to update all the
    game data/objects. This implies an `update` method. In addition, we are obviously
    going to want to draw all our game data once every frame after they have been
    updated. Let's keep all of our drawing code together in a method called `draw`.
    Furthermore, we need to control the frequency with which this happens. Therefore,
    a `control` method seems like it should be part of the class as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also know that everything needs to happen in your thread; so to achieve this,
    we should wrap the code in the `run` method. Lastly, we need a way to control
    when the thread should and shouldn't do its work so we need an infinite loop controlled
    by a Boolean, perhaps, `playing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following code into the body of our `TDView` class to implement what
    we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the bare-bones of our game. The `run` method will execute in a thread,
    but it will only execute the game loop while the Boolean `playing` instance is
    true. Then, it will update all the game data, draw the screen based on that game
    data, and control how long it is until the `run` method is called again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can quickly build on this code. First of all, we can implement the
    three methods that we call from the `run` method. Type the following code in the
    body of our `TDView` class before the closing curly brace of the `run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to declare our playing member variable. We can do this using the
    `volatile` keyword as it will be accessed from outside the thread and from within.
    Type this code just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we know that we can control the execution of code within the run method
    with the infinite loop and the `playing` variable. We also need to start and stop
    the actual thread itself. Not just when we decide, but when the player unexpectedly
    quits the game. What if he gets a phone call or just taps the home button on his
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle these events, we need the `TDView` class and `GameActivity` to work
    together. Now, in the `TDView` class, we can implement a `pause` method and a
    `resume` method. Within them, we put the code to stop and start our thread. Implement
    these two methods within the body of the `TDView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need an instance of a `Thread` class called `gameThread`. We can declare
    it as a member variable of `TDView` just after the class declaration, right after
    our Boolean `playing` parameter. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `onPause` and `onResume` methods are public. We can now add code
    to our `GameActivity` class to call these methods at the appropriate time. Remember
    that `GameActivity` extends `Activity`. Therefore, use the overridden `Activity`
    lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: By overriding the `onPause` method, whenever the activity is paused, we can
    shut down the thread. This avoids potentially embarrassing the player and having
    to explain to his caller, why they can hear sound FX in the background.
  prefs: []
  type: TYPE_NORMAL
- en: By overriding `onResume()`, we can have our thread start up in the last phase
    of the Android lifecycle before the app is actually running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the distinction between the `pause` and `resume` methods of the `TDView`
    class and the overridden `onPause` and `onResume` methods of the `GameActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The game activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you implement/override this method, note that all they will do is call
    the parent version of their respective methods followed by the public methods
    in the `TDView` class to which they correspond.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember back to the section when we created our new `GameActivity`
    class, we deleted the entire code contents? With that in mind, here is the outline
    of the code we will need in `GameActivity.java` including the implementation of
    the overridden methods within the body of the `GameActivity` class that we discussed
    in the previous section. Type this code in `GameActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s go ahead and declare an object of the `TDView` class. Do this
    just after the `GameActivity` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the `onCreate` method, we need to instantiate your object, keeping
    in mind that your constructor in `TDView.java` takes a `Context` object as an
    argument. Then, we use the newly instantiated object in a call to `setContentView()`.
    Remember when we built our home screen, we called `setContentView()` and passed
    in our UI design. This time, we are setting the player''s view to be the object
    of our `TDView` class. Copy the following code into the `onCreate` method of the
    `GameActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can actually run our game and click on the **Play** button
    to proceed to the `GameView` activity, which will use `TDView` as its view and
    start our thread. Obviously, there is nothing to see yet, so let's work on the
    model of our design pattern and build the basic outline of our first game object.
    At the end of the chapter, we will see how to run the game on an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayerShip object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to keep the model part of our code as separate as possible from the
    rest. We can do this by creating a class for our player's spaceship. Let's call
    our new class `PlayerShip`.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add a new class to the project, and call it `PlayerShip`. Here
    are a few quick steps on how to do that. Now, right-click the folder with our
    `.java` files in it and navigate to **New** | **Java Class**, then enter `PlayerShip`
    as the name and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need our `PlayerShip` class to be able to know about itself? As
    a bare minimum it needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Know where it is on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast it is flying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These requirements suggest a few member variables we can declare. Enter the
    code just after the class declaration that we generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As usual, use the *Alt* | *Enter* keyboard combination to import any missing
    classes. In the previous block of code, we see that we have declared an object
    of type `Bitmap` that we will use to hold the graphic which represents our ship.
  prefs: []
  type: TYPE_NORMAL
- en: We have also declared three `int` type variables; `x` and `y` to hold the spaceship's
    screen coordinates and another `int` type variable, `speed` to hold a value for
    how fast our spaceship is traveling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider what our `PlayerShip` class needs to do. Again as a bare
    minimum it needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share it's state with our view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor seems to be the ideal place to prepare itself. We can initialize
    its `x` and `y` coordinate variables and set a starting speed with the `speed`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing the constructor will need to do is to load the bitmap graphic,
    which represents its appearance. To load bitmaps, we require an Android `Context`
    object. This implies that the constructor that we write will need to receive a
    `Context` object from our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, here is our `PlayerShip` constructor to implement point
    one from our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we need to import some new classes using the *Alt* | *Enter* combination.
    After importing all the new classes required by the line which initializes our
    bitmap object, we can see we still have an error; `Cannot resolve symbol ship`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect the line that loads the ship bitmap as we will be seeing this
    quite a lot throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The `BitmapFactory` class is using its static method `decodeResource()` to attempt
    to load our graphic of the player ship. It requires two parameters. The first
    is the `getResources` method supplied by the `Context` object that was passed
    from the view.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter `R.drawable.ship` is requesting a graphic called `ship`
    from the (R)esource folder named `drawable`. All we have to do to resolve this
    error is to copy our graphic, named `ship.png`, into the `drawable` folder of
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply drag and drop/copy and paste the `ship.png` graphic contained in the
    `Chapter2/drawable` folder from the download bundle into the `res/drawable` folder
    in the Android Studio project explorer window. The following is a `ship.png` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PlayerShip object](img/B04322_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Number two on our list of things that `PlayerShip` needs to do is, to update
    itself. Let''s implement a public `update` method that can be called from our
    `TDView` class. The method will simply increment the ship''s *x* value by 1 each
    time it is called. Clearly, we need to get more advanced than this. For now implement
    the method in the `PlayerShip` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Number three on the to-do list is to share its state with the view. We can
    do this by providing a bunch of getter methods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now your `TDView` class can be instantiated, and find out what it likes about
    any `PlayerShip` objects. However, only the `PlayerShip` class itself can decide
    how it should look, what properties it has, and how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how we will draw our player's ship to the screen and animate it as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will see, drawing a bitmap is really trivial. But the coordinate system
    that we use to draw our graphics onto needs a brief explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting and drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we draw a `Bitmap` object to the screen, we pass in the coordinates we
    want to draw the object at. The available coordinates of a given Android device
    depend on the resolution of its screen.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Samsung Galaxy S4 phone has a screen resolution of 1920 pixels
    (across) by 1080 pixels (down) when held in a landscape view.
  prefs: []
  type: TYPE_NORMAL
- en: The numbering system of these coordinates starts in the top-left hand corner
    at 0,0 and proceeds down and to the right until the bottom right corner is pixel
    1919, 1079\. The apparent 1 pixel disparity between 1920/ 1919 and 1080/ 1079
    is because the numbering starts at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we draw a bitmap or any other drawable to the screen, we must
    specify *x*, *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a bitmap is, of course, comprised of many pixels. So which pixel
    of a given bitmap is drawn at the *x*, *y* screen coordinate that we will be specifying?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the top-left pixel of the `Bitmap` object. Take a look at the
    next image, which should clarify the screen coordinates using the Samsung Galaxy
    S4 as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting and drawing](img/B04322_02_10b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For now, when drawing just a single ship at an arbitrary location, this information
    is of little consequence. It will become more important in the next chapter, when
    we start constraining our graphics to the visible screen and respawning them when
    they disappear.
  prefs: []
  type: TYPE_NORMAL
- en: So let's just bare this in mind and get on with drawing our ship to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing PlayerShip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know all this, we can add some code to our `TDView` class, so we
    can see our `PlayerShip` class in action. First, we need a new `PlayerShip` object
    with class scope. The following code is the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also need a bunch of objects that we haven't seen yet to help us actually
    do some drawing. We need a canvas and some paint.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas and Paint objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aptly named `Canvas` class provides just what you will expect—a virtual
    canvas to draw our graphics upon.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a virtual canvas using the `Canvas` class and project it onto our
    `SurfaceView` object which is the view of your `GameActivity` class. We can actually
    add `Bitmap` objects and even manipulate individual pixels on our `Canvas` object
    using methods from our `Paint` object. In addition, we also need an object of
    the `SurfaceHolder` class. This allows us to lock your `Canvas` object while we
    are manipulating it and unlock it when we are ready to draw the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see in more detail how these classes work as we proceed. Type this
    code immediately following the previous line of code we typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we need to use the *Alt | Enter* keyboard combination to import some
    new classes for the two lines of code that follow. From this point on, we will
    save digital link and just assume that you know to do this each time you add a
    new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up to prepare for drawing. The best place to do this is
    in the `TDView()`, constructor. Type the following code to prepare our `Paint`
    and `SurfaceHolder` objects for action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the previous line of code, we can at last call `new()` to
    initialize our `PlayerShip` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can jump to our `TDView` class''s `update` method and do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The `PlayerShip` class (part of the model) knows what to do, and
    we can add all kinds of artificial intelligence into our `PlayerShip` class. The
    `TDView` class (the controller) just says when it is time to update. You can easily
    imagine that all we need to do is create lots of different game objects with different
    properties and behaviors and call their `update` methods once per frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, jump to the `TDView` class''s `draw` method. Let''s draw our `player`
    object by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that our `SurfaceHolder` class is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the `Canvas` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the screen with a call to `drawColor()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Splash some virtual paint on it by calling `drawBitmap()` and passing in the
    `PlayerShip` bitmap and an *x*, *y* coordinate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, unlock the `Canvas` object and draw the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve these things, type this code in the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can actually run the game. If our eyesight is fast enough
    or our Android device slow enough, we will just about see our player spaceship
    fly across the screen with immense speed.
  prefs: []
  type: TYPE_NORMAL
- en: There is just one more thing to do before we deploy our game so far.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the frame rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we can barely see anything is that even though we only move our ship
    at one pixel per frame along the *x* axis (in the `PlayerShip` class's `update`
    method), our thread is calling the `run` method in an unrestricted manner. This
    is probably happening hundreds of times per second. What we need to do is control
    this rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sixty frames per second (FPS) is a reasonable goal. This goal implies the need
    for timing. The Android system measures time in milliseconds (thousandths of a
    second). Therefore, we can add the following code to the `control` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we paused the thread for 17 milliseconds (*1000(milliseconds)/60(FPS)*)
    by calling `gameThread.sleep` with `17` as the argument to the method. We wrap
    the code within a `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can run our game to see our spaceship floating through space (starting
    at 50 pixels on the *x* axis and 50 pixels on the *y* axis).
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio enables us to fairly quickly create emulators, on which we can
    test our games on a development PC. However, even the most simple of games will
    not run well on an emulator. When we start testing things like player input, the
    experience is so awful that it is best to avoid using emulators completely.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to carry out debugging on a real Android device. It is very
    easy to prepare for this.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging on an Android device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do is to visit your device manufacturer's website and obtain
    and install any drivers that are required for your device and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The next few steps will setup the Android device for debugging. Note that different
    manufacturers structure the menu options slightly differently than others. The
    following sequence is probably very close, if not exact to enable debugging on
    most devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **Settings** menu option or the **Settings** app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap **Developer** options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the checkbox for **USB Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your Android device to the USB port of your development system. The
    next image shows on the Android tab. At the bottom of the Android Studio UI, you
    can see that **Samsung GT-I9100 Android 4.1.2 (API 16)** has been detected:![Debugging
    on an Android device](img/B04322_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Play** icon from the Android Studio toolbar:![Debugging on an
    Android device](img/B04322_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, click on **OK** to run the game on your chosen device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The game will now run on the device. Any output or errors can be seen in the
    **logcat** window, also on the **Android** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging on an Android device](img/B04322_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Watch with awe as our player's spaceship moves slowly from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent a lot of time setting up the structure, game loop,
    and thread. We also spent time handling the Android Activity lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have all this in place, and we can easily start adding more game objects
    to make Tappy Defender quickly feel more like a real game in the next chapter.
  prefs: []
  type: TYPE_NORMAL
