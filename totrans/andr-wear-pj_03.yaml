- en: Let us Help Capture What is on Your Mind - Saving Data and Customizing the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building the note-taking application from scratch was a good learning experience.
    In this chapter, we will understand upgrading the same code for a new user interface
    with Wear design standards. The **Wear-note 1** app will get migrated to **Wear-note
    2** with the following update:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Realm database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating custom fonts and assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizing the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To further assist the open wear-note 1 project in your Android Studio, compile
    the project and check the project screen by screen. You will discover that the
    main functionality of the application is saving notes on Wear devices. In this
    application, we have a white color background and black color font. `SharedPreferences`
    is helping the application to persist the data.
  prefs: []
  type: TYPE_NORMAL
- en: Further recapping, we know how to work with `WearableRecyclerView`, `DelayedConfirmationView`,
    and `BoxInsetLayout` for getting the best application experience on Wear devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking it forward, let''s get started on finishing the project with the changes
    mentioned earlier. Let''s call this application wear-note-2\. Go to your `values`
    directory in the `res` directory, and in the `string.xml` file, change the application
    name to Wear-note-2, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wear-note-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start working on functionality and replacing the database with RealmDB
    in this submodule.
  prefs: []
  type: TYPE_NORMAL
- en: '**RealmDB** is creating buzz in the modern Android programming world; it is
    a simple alternative to the SQLite database, which comes built into the Android
    SDK. Realm is not using SQLite as its core engine; it has its own C++ core, exclusively
    architected for mobiles. Realm saves the data in a universal, table-based format
    with a C++ core. Realm handles a range of sophisticated queries and can allow
    data accessibility from multiple languages as well as numerous ad hoc queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Realm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Realm is 10x faster than SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well documented and excellent community support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more about Realm, there are numerous optimizations Realm does, such
    as integer packing and converting common strings into enums, which results in
    better performance than the SQLite + ORM database solutions. The traditional SQLite
    + ORM abstraction is leaky, ORM simply converts objects and their methods into
    SQL statements, which results in poor performance. On the other hand, Realm is
    an object-oriented database, which means your data is saved as objects and this
    is reflected in your database. Realm maps the whole data in the memory using B+
    trees and, whenever data is queried, Realm calculates the offset, reads from the
    memory mapped region, and returns the raw value. By doing this, Realm avoids zero-copy
    (the traditional way of reading data from a database leads to unnecessary copying
    (raw data > deserialized representation > language-level objects)).
  prefs: []
  type: TYPE_NORMAL
- en: Realm is the perfect choice whenever a developer wants to implement lazy-loading;
    because the properties are represented in columns instead of rows, it can lazy
    load the properties as necessary, and because of the column structure, reads are
    much faster, while inserts are slower. But that is a good trade-off for the context
    of a mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: Realm uses the **Multiversion Concurrency Control** (**MVCC**) model, which
    means that multiple read transactions can be done at the same time and reads can
    also be done while a write transaction is being committed.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://realm.io/news/jp-simard-realm-core-database-engine/.](https://realm.io/news/jp-simard-realm-core-database-engine/)
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of Realm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Realm has a few bottlenecks that should be considered before choosing it. Nevertheless,
    these bottlenecks can be considered for a high scaling Android app:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot import Realmdb to other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't access the objects across threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't have auto-increment of IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating Realmdb is a painful job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lacks compound primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still under active development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Wear-note-1** project, after changing its name in `string.xml` to Wear-note-2,
    we need to add the appropriate Realm dependency in the gradle-project module.
    As of the time of writing this book, the newest Realm version is 3.0.0, so let's
    discuss the dependency and code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Re-structuring the code and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Realm has a new mechanism now. It''s not just a gradle dependency, it''s a
    gradle plugin. We will learn how to add and use Realm in the project. The gradle
    plugin dependency should be added to the project scope, which is a project level
    gradle dependency. Add the following classpath and allow it to sync to your project
    through the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this dependency to the gradle project level file located as shown in the
    following screenshot. Add `classpath` to the dependency section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the class path dependency, the complete gradle file will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will apply the Realm plugin to our project to use all the Realm features
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A sample of gradle modified files have been open sourced by the Realm community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/realm/realm-java/blob/master/examples/build.gradle'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/realm/realm-java/blob/master/examples/introExample/build.gradle](https://github.com/realm/realm-java/blob/master/examples/build.gradle)
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are all set to go for replacing our `SharedPreferences` with Realm.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Android Studio and, in the model package, we have defined our `Note.java`
    POJO class with primitive data string notes and string ID. We have the getters
    and setters for these variables. Additional changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend the POJO model to `RealmObject` and create an empty constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, we will instantiate the `Realm` class globally and we will
    initiate in the `onCreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `updateAdapter()` method, we will have to add the read query from Realm,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Realm database provides numerous queries, which maps one to one and one to many
    relationships for stored data and, for this project, the preceding query does
    all the magic needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `createNote()` method, we will change the code to work with Realm instead
    of `SharedPreference`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For deleting the records, let''s create a new method and call it `deleteRecord()`.
    In this method, we will pass the ID of the note and delete that note from the
    Realm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the delete record method in the `updateData()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete `MainActivity` code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, functionally, we have Realmdb integrated to our Wear-note-2 app. Let's
    compile and see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The home screen of the Wear note-taking application looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The IMF Screen that the Wear operating system handles to get the input from
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The ''Saved animation'' through default `confirmationActivity` in the Wear
    support library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Home screen with a saved note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have replaced `Sharedpreference` with the best database of our time
    for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the Wear User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Wear-note application, we are using a white color background and a black
    color text with the default Roboto font. When preparing a good Wear application
    design, Google recommends using a dark color for the Wear application for the
    best battery efficiency. Light color schemes used in typical material designed
    mobile applications are not energy efficient in Wear devices. Light colors are
    less energy efficient in OLED displays.
  prefs: []
  type: TYPE_NORMAL
- en: Light colors need to light up the pixels with brighter intensity. White colors
    need to light up the RGB diodes in the pixels at 100%; the more white and light
    color in the application, the lesser battery efficient the application will be.
  prefs: []
  type: TYPE_NORMAL
- en: Light colors are disruptive in dark light or when using your Wear device at
    night. This scenario would probably not happen with dark colors. Unlike light
    colors, dark colors make the screen less bright when they are active and saves
    battery in OLED displays.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started working on the Wear-note-2 user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's change the application theme for adapting the standard design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the `activity_main.xml` file, we will edit the parent container's background,
    which is the `BoxInsetLayout` background `android:background="#01579B"` to cobalt
    blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `color.xml` under the `values` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the color we can use the color in our production application as
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, let''s change the color of the `EditText` hint color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `each_item.xml` layout, modify the XML code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, do the same changes in the `activity_delete.xml` layout''s container,
    change its background color and change the color of `TextView`. Changing the color
    of `DelayedConfirmationView` can be done using the `xmlns` properties, as highlighted
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Developers need not worry about changing the color of animations in `DelayedConfirmationView`,
    Wear 2.0 automatically adapts to the theme of `DelayedConfirmationView` and changes
    the primary color schemes for creating a unified experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these changes reflect in the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'IMF screen for fetching input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving the data using Realm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Deleting the note from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Better fonts for better reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of digital design, making your application's visuals easy on users'
    eyes is important. The Lora font from Google collections has well-balanced contemporary
    serifs with roots in calligraphy. It is a text typeface with moderate contrast
    well suited for body text. A paragraph set in Lora will be memorable because of
    its brushed curves in contrast with driving serifs. The overall typographic voice
    of Lora perfectly conveys the mood of a modern-day story, or an art essay. Technically,
    Lora is optimized for screen appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the custom fonts to an Android project, we need to create the `assets`
    folder in root. Check the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can directly add the `.ttf` file assets directory or we can create another
    directory and the fonts. You can download the Lora font via this URL: [https://fonts.google.com/download?family=Lora](https://fonts.google.com/download?family=Lora).'
  prefs: []
  type: TYPE_NORMAL
- en: After adding the font files to the asset folder, we need to create custom `Textview`
    and `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `utils` package, let''s create the class called `LoraWearTextView` and
    `LoraWearEditTextView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, extend `LoraWearTextView` to the `TextView` class and `LoraWearEditTextView`
    to `EditText`. Implement the constructor methods in both the classes. Create a
    new method and call it `init()`. Inside the `init` method, instantiate the `Typeface`
    class and, using the `createFromAsset` method, we can set our custom font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `init` method is the same in both the classes. Call the `init`
    method in all the different parameterised constructors of the two new custom classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete class looks as follows: `LoraWearTextView.java`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete class looks as follows: `LoraWearEditTextView.java`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding these two classes in our UI layouts, we can replace the actual
    `textview` and `edittext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After replacing `textview` and `edittext`, compile the program and let''s see
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Remove Note animation through `confirmationViewActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we have explored how to integrate the Realm popular database,
    understood the design philosophy for wear devices, and created our custom view
    components for better application user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom layouts for better UX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android offers great ways to customize the layouts that we use as containers.
    We can have compound views and customize the layout for our own purposes. Wearables
    use the same layout techniques as handheld Android devices, but need to be designed
    with specific constraints and configuration. It's not a good idea to port a functionality
    from a handheld android device component to Wear app designs. For designing a
    great Wear app, follow the Google design guidelines at [https://developer.android.com/design/wear/index.html](https://developer.android.com/design/wear/index.html).
    Let's create custom views and use them in the Wear note application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement animations in our layouts with the way we are loading the items.
    We shall have a simple slide animation and we will do that with the custom layout
    we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class file called `AnimatedLinearLayout` and extend it to `LinearLayout`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compound views are the combination of two or more views bundled as one component,
    for instance, the Checkable Relative layout. When a user clicks on the layout,
    it will highlight the layout similar to the checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need the `Animation` class from `View`. Apart from the `Animation`
    class, declare the `View` instance for a `currentChild` view. Since we are writing
    a layout and it can hold the child''s hierarchy, we need a view instance for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we extend the class to `LinearLayout`, we get a couple of constructor
    `callbacks`, which we have to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onWindowFocusChanged()` method, we can write our logic for the custom
    animation. Here, the book introduces `SlideDown`, `SlideDownMore`, `RotateClockWise`,
    `RotateAntiClockWise`, and `ZoomInAndRotateClockWise`. Now, to implement this,
    we need to check whether the view is inflated and has got the window to be displayed,
    and how many `childviews` the layout has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the child is an instance of Viewgroup; if the view is developed
    completely in any other alienated way, then this custom layout will not be able
    to help that view to animate. Using the childviews tag property, we can assign
    a string association for animations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the slide down animation, using the animation instance we created globally,
    we have to set the interpolator and decelerate the interpolation with the childviews
    height by the numeric value 2\. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we will complete other cases. Let''s work on completing the `onWindowFocusChanged()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create an `AnimationRunnable` class, which implements the `Runnable`
    interface to start the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will implement another `AnimationSetRunnable` class to the runnable interface
    for setting the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have completed our own custom layout that has a couple of animation
    methods to all our view childs in the layout. The complete class code for this
    custom layout looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after completely writing the class, it is time to use it in our project.
    We can use this classname as an XML tag and use it in the `each_item.xml` layout,
    which is the row item layout of `recyclerview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the layout code with the new `AnimatedLinearLayout`. We need to pass
    the tag in `childviews` for getting animated. The following code explains this
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This layout will draw all the views with small animations and display the list
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ZoomInAndRotateClockWise` animation and try changing the string exactly
    the same string given in the `Custom` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the importance of dark themes on Wear devices.
    We changed the custom `TextView` with font assets. We have seen how to write custom
    layouts and defined a few animations in it. In later projects, we will explore
    more of the design guidelines and components introduced exclusively in Wear 2.0
    `Wearable action drawer` and `wearable navigation drawer.`
  prefs: []
  type: TYPE_NORMAL
