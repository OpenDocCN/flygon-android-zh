- en: Chapter 5. Interfacing with High-speed Sensors Using SPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you worked with the I2C bus to communicate with an
    FRAM device that requires far more complex communications than that of the simple
    on/off digital communications used by GPIOs. I2C is very powerful and flexible,
    but it can be quite slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to write an Android app that uses the BBB''s
    SPI capabilities to retrieve environmental data from a high-speed sensor. We will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing for SPI on the BBB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing SPI devices in the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an SPI interface circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the SPI sensor example app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Serial Peripheral Interface** (**SPI**) bus is a high-speed, serial bus
    originally developed by Motorola. Its purpose is to facilitate point-to-point
    communication between a single master device and one or more slave device. The
    SPI bus is typically implemented using four signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCLK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOSI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MISO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SS`/`CS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like I2C, the master on the SPI bus sets the pace of communication between the
    master and the slave by producing a clock signal. With SPI, this clock signal
    is called the **serial clock** (`SCLK`). Unlike the bidirectional data bus of
    I2C, SPI uses dedicated outgoing and incoming data lines for each device. Using
    dedicated lines results in SPI being able to achieve communication speeds far
    higher than those of I2C. The master sends data to the slave via the **master
    out, slave in** (`MOSI`) signal, and it receives data from the slave via the **master
    in, slave out** (`MISO`) signal. The **slave select** (`SS`) signal, also called
    **chip select** (`CS`), tells the slave device whether it should be awake and
    paying attention for any clock signals on `SCLK` and data being sent to it via
    `MOSI`. There are variants on this four-wire SPI bus scheme, such as a three-wire
    scheme that omits the `SS`/`CS` signal, but the BBB uses a four-wire scheme for
    its SPI buses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding SPI](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The SPI master and slave devices on an SPI bus
  prefs: []
  type: TYPE_NORMAL
- en: The BBB can act as either an SPI master or slave, so it does not label its data
    input and output signals for SPI as `MISO` or `MOSI`. Instead, it uses the names
    `D0` and `D1` for these signals. If the BBB acts as the master on the SPI bus,
    `D0` is the `MISO` signal and `D1` is the `MOSI` signal. If the BBB acts as the
    slave on the SPI bus, these are reversed (`D1` is `MISO`, `D0` is `MOSI`). For
    this book, the BBB will always be acting as the SPI master.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How do I remember which BBB SPI signal is input and which is output?**'
  prefs: []
  type: TYPE_NORMAL
- en: It can be confusing to remember which signal is `MISO` and which is `MOSI` when
    the BBB uses the signal names `D0` and `D1`. One way to remember is to think of
    the `0` in `D0` as an *O* (for slave output) and the `1` in `D1` as an *I* (for
    slave input). If the BBB is the SPI master (which will almost always be the case),
    then `D1` is the slave input signal (`MOSI`) and `D0` is the slave output signal
    (`MISO`).
  prefs: []
  type: TYPE_NORMAL
- en: The maximum `SCLK` speed for SPI on the BBB is 48 MHz, but speeds ranging from
    1 MHz to 16 MHz are commonly used. Even at these reduced clock speeds, SPI is
    far superior to the 400 KHz clock speed of I2C buses when considering the amount
    of raw data that can be transmitted each second. Only one device can transmit
    data on an I2C bus at any time, but both the master and slave can transmit data
    simultaneously on an SPI bus because each device has a dedicated transmission
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing for SPI on the BBB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AM335X processor of the BBB provides two SPI buses: SPI0 and SPI1\. Both
    buses are accessible via the P9 header. By default, no SPI buses are muxed. The
    following figure shows each of the potential pins on the P9 header where SPI signals
    can be muxed in different pinmux modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiplexing for SPI on the BBB](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Locations of the SPI buses on the P9 header with different pinmux modes
  prefs: []
  type: TYPE_NORMAL
- en: 'When deciding how you would like your pins to be muxed using SPI in your projects,
    keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, stick with using the SPI0 bus muxed to the P9.17, P9.18, P9.21,
    and P9.22 pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SPI1 channel conflicts with the I2C bus used by the capemgr (P9.20) and
    audio output (P9.28, P9.29, P9.31). Be aware that muxing these pins to use SPI1
    can disable some other functionality that you are depending upon for a full-featured
    Android system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using other cape boards in your projects, make sure that these capes
    don't require the use of the SPI buses. Only one device can exist on each SPI
    bus unless you use a GPIO pin and extra logic circuitry to manually control each
    SPI device's chip select signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing SPI devices in the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel provides a general-purpose SPI driver named `spidev`. The `spidev`
    driver is a simple interface that abstracts many of the housekeeping details involved
    in SPI communications. The `spidev` driver is exposed via the `/dev` filesystem
    as the `/dev/spidevX.Y` file. Multiple versions of these `spidev` files can be
    present depending upon the number of SPI buses configured in the Device Tree.
    The `X` value in the `spidev` filename refers to the SPI controller number (1
    for SPI0 and 2 for SPI1), and the `Y` value refers to the SPI bus of that controller
    (0 for the first bus and 1 for the second bus). For the examples in this book,
    you will only be using the first SPI bus of the SPI0 controller, so `/dev/spidev1.0`
    is the only file with which PacktHAL will interact.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android for SPI sensor use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files to your
    Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable the `spidev` kernel device driver that
    handles SPI bus interfacing, muxes the pins to enable the SPI0 bus, and allow
    your apps to access them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as SPI is concerned, the `BB-PACKTPUB-00A0.dtbo` overlay muxes the P9.17,
    P9.18, P9.21, and P9.22 pins into the SPI `CS0`, `D1`, `D0`, and `SCLK` signals,
    respectively. In the `PacktHAL.tgz` file, the source code for the overlay is located
    in the `cape/BB-PACKTPUB-00A0.dts` file. The code responsible for muxing these
    two pins is located in the `bb_spi0_pins` node within `fragment@0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this sets up the muxing, it doesn''t assign and configure a device driver
    to these pins. The `fragment@2` node performs this kernel driver allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Without digging into the fine details, there are three settings in `fragment@2`
    that are of interest to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pinctrl-0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compatible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-max-frequency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is `pinctrl-0`, which ties this node of Device Tree to the pins muxed
    in the `bb_spi0_pins` node. The second is `compatible`, which specifies the particular
    kernel driver, `spidev`, that will handle our hardware device. The last is `spi-max-frequency`,
    which specifies the maximum allowable speed for this SPI bus (16 MHz). 16 MHz
    is the maximum frequency specified for `spidev` in the Device Tree overlays provided
    with the BBB's kernel source.
  prefs: []
  type: TYPE_NORMAL
- en: The custom `init.{ro.hardware}.rc` file that you pushed to the Android system
    doesn't have to do anything special for PacktHAL's SPI interfacing. By default,
    BBBAndroid uses `chmod` to set the permissions of the `/dev/spidev*` files to
    777 (complete access for everyone). This is not a secure practice since any process
    on the system can potentially open a `spidev` device and begin reading and writing
    to the hardware. For our purposes, though, having the `/dev/spidev*` files accessible
    to every process is necessary to allow our unprivileged example app access to
    the SPI bus.
  prefs: []
  type: TYPE_NORMAL
- en: Building an SPI interface circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an understanding of where SPI devices are connected to the
    BBB and how the Linux kernel presents an interface to these devices, it is time
    to connect an SPI device to the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction
    to Android and the BeagleBone Black"), *Introduction to Android and the BeagleBone
    Black*, you will be interfacing with a sensor in this chapter. To be specific,
    we will be using a Bosch Sensortec BMP183 digital pressure sensor. This 7-pin
    component provides pressure data samples (in 16- to 19-bit resolution) and temperature
    data samples (in 16-bit resolution) for applications used for navigation, weather
    forecasting, and to measure changes in vertical elevation and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This particular chip is only available in a **land grid array** (**LGA**), which
    is a surface mount package that can be difficult to work with when building prototype
    circuits. Luckily for us, the AdaFruit breakout board for the sensor already has
    the chip mounted, which makes prototyping simple and easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an SPI interface circuit](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sensor breakout board (source: [www.adafruit.com](http://www.adafruit.com))'
  prefs: []
  type: TYPE_NORMAL
- en: The breakout board labels the `SCLK` signal as `SCK`, `MOSI` as `SDI` (serial
    data in), `MISO` as `SDO` (serial data out), and `SS` as `CS` (chip select). To
    power the board, a +3.3 V signal is connected to `VCC` and a ground is connected
    to `GND`. The `3Vo` signal of the breakout board provides a +3.3 V signal and
    is not used in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t disassemble your circuit!**'
  prefs: []
  type: TYPE_NORMAL
- en: The sensor circuit in this chapter is part of a much larger circuit used in
    [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing
    Solution"), *Creating a Complete Interfacing Solution*. If you build the circuit
    as it is positioned in the diagram (towards the middle of the breadboard), you
    can simply leave the sensor breakout board and wires in place as you build the
    remaining circuits in this book. This way, it will already be constructed and
    working when you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution").
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following figure shows the connections between the sensor breakout board
    and the BBB. The six main SPI bus signals (+3.3 V, ground, and the SPI `SCLK`,
    `MISO`, `MOSI`, and `SS`) are made using the pins of the P9 connector, so we have
    placed the breadboard on the P9 side of the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the sensor](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The complete sensor interfacing circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect P9.1 (ground) to the vertical ground bus of the breadboard and P9.3
    (3.3 V) to the vertical VCC bus of the breadboard. These connections are identical
    to the ones made for the GPIO and I2C breadboard circuits you created in [Chapter
    3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs with GPIOs"),
    *Handling Inputs and Outputs with GPIOs* and [Chapter 4](part0029_split_000.html#page
    "Chapter 4. Storing and Retrieving Data with I2C"), *Storing and Retrieving Data
    with I2C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The four SPI bus signals, `SCLK`, `MISO` (`D0`), `MOSI` (`D1`), and `SS` are
    on the P9.22, P9.21, P9.18, and P9.17 pins, respectively. Wire the P9.22 pin to
    the pin marked SCK on the breakout board, and wire the P9.21 pin to the pin marked
    SDO. Then, wire the P9.18 pin to the pin marked SDI, and wire P9.17 to the pin
    marked CS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire the ground bus to the GND pin of the breakout board and the VCC bus to
    the VCC pin of the breakout board. Leave the 3Vo pin of the breakout board unconnected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sensor breakout board is now electrically connected to the BBB and is ready
    for your use. Double-check your wiring against the diagram of the complete sensor
    interfacing circuit to ensure that everything is connected properly.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the SPI sensor example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will examine the example Android app that performs the
    SPI bus interfacing on BBB. The purpose of this application is to demonstrate
    how to use PacktHAL to perform SPI reads and writes from within an actual app
    using a set of interfacing functions. These functions allow you to send and receive
    data between the SPI bus master (the BBB) and the SPI bus slave (the SPI sensor).
    The low-level details of the hardware interfacing are implemented in PacktHAL,
    so you can quickly and easily get your apps interacting with the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging through the SPI app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app and the precompiled `.apk` packages are located in the `chapter5.tgz`
    file, which is available for download from Packt's website. Follow the same process
    to download and add the app to your Eclipse ADT environment that was described
    in [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs* and *Chapter 4, Storing
    and Retrieving Data with I2C*.
  prefs: []
  type: TYPE_NORMAL
- en: The app's user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The app uses a very simple UI to interact with the sensor. As it is so simple,
    the only activity that the app has (by default) is `MainActivity`. The UI consists
    of only one button and two text views.
  prefs: []
  type: TYPE_NORMAL
- en: '![The app''s user interface](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sensor sample app screen prior to receiving its first set of samples from
    the sensor
  prefs: []
  type: TYPE_NORMAL
- en: The top text view has the `temperatureTextView` identifier in the `activity_main.xml`
    file, and the bottom text view has the `pressureTextView` identifier. These text
    views will display the temperature and pressure data that is retrieved from the
    sensor. The button with the **Sample** label has the `sampleButton` identifier.
    This button has an `onClick()` method called `onClickSampleButton()` that triggers
    the process of interfacing with the sensor to sample the temperature and pressure
    data and then updating the text displayed in the `temperatureTextView` and `pressureTextView`
    text views.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the PacktHAL sensor functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sensor interface functionality in PacktHAL is implemented in a variety of
    C functions in the `jni/bmp183.c` file within the `sensor` app's project. These
    functions not only interface with the sensor, but they also do a variety of conversion
    and calibration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `fram` app in the previous chapter used a specific kernel driver (the `24c256`
    EEPROM driver) to interact with the FRAM chip, so the user-space-interfacing logic
    that is implemented in PacktHAL is quite simple. PacktHAL does not use a sensor-specific
    kernel driver to communicate with the sensor, so it must use the generic `spidev`
    driver to communicate. It is up to PacktHAL to prepare, send, receive, and interpret
    the individual bytes of every SPI message that is going to or from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of functions in PacktHAL to handle these tasks, only
    four of those functions are used by outside code to interact with the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openSensor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSensorTemperature()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSensorPressure()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeSensor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `openSensor()` function initializes access to the SPI bus by opening `/dev/spidev1.0`
    and making several `ioctl()` calls to configure the SPI bus' communication parameters
    (such as the clock rate of `SCLK`).
  prefs: []
  type: TYPE_NORMAL
- en: Once this configuration is performed, all SPI communications performed inside
    of PacktHAL will use this bus. Calling the counterpart `closeSensor()` function
    closes the `/dev/spidev1.0` file, which shuts down the SPI bus and frees it for
    use by other processes on the system. The `getSensorTemperature()` and `getSensorPressure()`
    functions perform all of the preparation of the SPI messages, SPI communication,
    and sample conversion logic required to fetch and convert the samples retrieved
    from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were using a specialized kernel driver designed to talk to the specific
    sensor that we are using, then the sensor-reading logic inside the PacktHAL code
    would be very simple (only one or two `ioctl()` calls). It is always a balance
    between placing HAL code logic into the kernel versus keeping it in user space.
    The more code that you can push into the kernel, the simpler and faster the user
    space code will be. However, it can be very difficult to develop kernel code,
    so you must strike a balance between what is easiest to implement and what will
    provide you with the performance necessary for your hardware design.
  prefs: []
  type: TYPE_NORMAL
- en: The `sensor` app has several similarities to apps from previous chapters. Like
    the `fram` app from [Chapter 4](part0029_split_000.html#page "Chapter 4. Storing
    and Retrieving Data with I2C"), *Storing and Retrieving Data with I2C*, the sensor
    app uses its own class derived from `AsyncTask`, `HardwareTask`, to make JNI calls
    to the underlying sensor-interfacing functions from PacktHAL. Interfacing with
    the hardware is triggered by the `onClick()` handler of a button pressed by the
    app's user, similar to what both the `gpio` and `fram` apps do.
  prefs: []
  type: TYPE_NORMAL
- en: Much like the GPIO-interfacing functions from PacktHAL that you used in [Chapter
    3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs with GPIOs"),
    *Handling Inputs and Outputs with GPIOs* and *Chapter 4, Storing and Retrieving
    Data with I2C*, the sensor-interfacing methods in `HardwareTask` are very fast
    to execute. It is not actually necessary to execute these methods from within
    a separate thread since they are not likely to take so long to execute that they
    will trigger the ANR dialog. However, SPI can be used for a wide variety of devices,
    and it is possible to need longer periods of time to send large amounts of data,
    so better safe than sorry.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**When should I use an AsyncTask for hardware interfacing?**'
  prefs: []
  type: TYPE_NORMAL
- en: The short answer to this is "all of the time". We did not want to distract you
    with the details of the `AsyncTask` class when you were working with GPIOs in
    [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*, so the `gpio` app made
    method calls to PacktHAL functions in the `onClick()` button handlers. However,
    the general rule to follow is to always use `AsyncTask` to perform any sort of
    I/O. I/O is notoriously slow, so any I/O (networking, accessing files on disk,
    and hardware interfacing) should really take place in its own thread via `AsyncTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HardwareTask class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the `gpio` and `fram` apps, the `HardwareTask` class in the sensor app
    provides four native methods that are used to call the PacktHAL JNI functions
    related to sensor hardware interfacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the details of the SPI bus setup process are encapsulated within the PacktHAL
    functions and hidden from the app, these methods take no parameters. They simply
    call their PacktHAL counterparts via the PacktHAL JNI wrapper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the HardwareTask class](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The thread contexts in which the `HardwareTask` methods and the PacktHAL functions
    are executed
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sensor app, the `onClick()` handler for the sample button in the `MainActivity`
    class instantiates a new `HardwareTask` method. Immediately after this instantiation,
    the `pollSensor()` method of `HardwareTask` is called to request a current set
    of temperature and pressure data from the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pollSensor()` method begins the hardware-interfacing process by calling
    the `execution()` method of the base `AsyncTask` class to create a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute()` method of `AsyncTask` calls the `onPreExecute()` method that
    the `HardwareTask` uses to initialize the SPI bus via its `openSensor()` native
    method. The `sampleButton` method is also disabled for the duration of the thread
    to prevent the possibility of multiple threads trying to use the SPI bus to talk
    to the sensor simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `onPreExecute()` method finishes, the `AsyncTask` base class spins
    a new thread and executes the `doInBackground()` method within that thread. For
    the sensor app, this is the proper place to perform any SPI bus communication
    required to get the current temperature and pressure samples from the sensor.
    The `getSensorTemperature()` and `getSensorPressure()` native methods of the `HardwareTask`
    class fetch the latest samples from the sensor via the `getSensorTemperature()`
    and `getSensorPressure()` functions in PacktHAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After `doInBackground()` is complete, the `AsyncTask` thread terminates. This
    triggers the calling of `doPostExecute()` from the UI thread. Now, as the app
    has finished its SPI communication tasks and received the latest temperature and
    pressure values from the sensor, it is time to close the SPI connection. The `doPostExecute()`
    method closes the SPI bus using the `closeSensor()` native method of the `HardwareTask`
    class. The `doPostExecute()` method then alerts the `MainActivity` class of the
    new data received from the sensor via the `updateSensorData()`method, and it re-enables
    the **Sample** button of `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainActivity` class'' `updateSensorData()` method is responsible for updating
    the displayed values in the `temperatureTextView` and `pressureTextView` text
    views to reflect the newest received sensor values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, execution of the `sensor` app has returned to its idle state.
    If the user clicks on the **Sample** button once more, another `HardwareTask`
    instance is instantiated and the open-sample-close interaction cycle of the hardware
    will occur again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you ready for a challenge?**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen all of the pieces of the sensor app, why not change it
    to add some new functionality? For a challenge, try adding a counter that shows
    how many samples have been taken so far and the average temperature and pressure
    from all of the samples taken. We have provided one possible implementation of
    this in the `chapter5_challenge.tgz` file, which is available for download from
    Packt's website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the SPI bus. You constructed a circuit
    that connected an SPI pressure and temperature sensor breakout board to the BBB,
    and you learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file's
    Device Tree overlay that are responsible for configuring and making the SPI bus
    and `spidev` device driver available for your app's use. The sensor app in this
    chapter demonstrated how complex tasks in the HAL can be hidden from the app using
    a small set of functions that hide the low-level details. These simplified PacktHAL
    function calls can be made from a class derived from `AsyncTask` to perform more
    complex interfacing tasks simply from within an app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about combining GPIO, I2C, and SPI together
    into an app capable of providing a complete hardware solution that uses a long-lived
    hardware-interfacing thread.
  prefs: []
  type: TYPE_NORMAL
