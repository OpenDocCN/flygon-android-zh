- en: Measuring Your Wellness and Syncing Collected Sensor Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a Wear app that reminds us to drink water,
    and has the ability to check step counts and heart pulse rate through embedded
    Wear sensors. The ideology of Wear and mobile applications is to have better glanceability
    and never miss anything important, and project Upbeat seems, with few functionalities,
    to have a strong place in a user's wrist and pocket. The current functionality
    of the upbeat Wear app is limited to displaying the data received from the sensors.
    In this chapter, we are going to sweeten the app with interoperability with Wear
    and mobile apps. We will persist all transmitted data through `RealmDB`. We will
    fire a notification from a mobile to Wear to start the app for checking the pulse
    rate. We will have a list of health tips and food calorie cards in the Wear application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting Wear sensor's data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing received data to find calories and distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WearableListenerService` and Messaging API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a Wear app from the mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RealmDB` integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WearableRecyclerview` with `CardView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting Wear sensors' data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting sensor data from Wear devices needs a communication mechanism, and
    the Wearable DataLayer API, which is part of the Google Play services, plays a
    major role in the communication process. We will deeply explore the communication
    process in later lessons but in this chapter, we need to receive the sensor data
    in the mobile app. We have created the project, which already has a mobile module
    and the simple plain old Hello World boilerplate code. We will work on the mobile
    module once we set our data sending mechanism from the Wear app. Let's start with
    the step count sensor in the services package of the Wear module and go to the
    `WearStepService` class. We have built this service to fire a notification and
    listen to the step counter data. Now, with the help of `GoogleApiClient` and the
    Wear Messaging API, we need to send the data to the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WearStepService` class, instantiate `GoogleApiClient` in the global
    scope of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In `onStartCommand`, call a method that initializes `mGoogleApiClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For initializing `GoogleClient`, we will utilize the builder pattern of the
    `GoogleClient` and we need to add `Wearable.API`. Later, we can connect `GoogleClient`
    using the `connect()` method followed by the `build()` method of the builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `WearStepService` class, we shall override the `onBind` method that
    belongs to the `IBinder` interface. We can use it for client interactions through
    the remote service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are returning null, since after sending data, we don''t want anything to
    return. If we want certain information to be returned, then we can return the
    `IBinder` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To be able to send data to mobile devices, we need two DataLayer API mechanisms,
    which are Wearable Node and Message API. We will get the connected nodes using
    Node API. Using the Messaging API, we will fire the data to a particular path,
    and on the receiver end, we should listen to that path for fetching the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Node API, we will have the `Resultcallback` class, which returns a list
    of `ConnectedNodes`, and we have to implement the `onResult` method that has the
    ability to return the list of connected nodes. We can fire the message to all
    the connected nodes or for one that is connected. We can get the connected node''s
    name using `getDisplayname` of the node class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we will use the Node and Message API and send the data to the connected
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous method, we will use the `PendingResults` class to retreive the
    connected node's results. After we receive the list of connected nodes, we can
    fire Messages using the `wearableMessageApi` class. Do not forget to send and
    receive the data to the same path.
  prefs: []
  type: TYPE_NORMAL
- en: Completed WearStepService class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete `WearStepService` class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are successfully firing a message to the mentioned path. Now, let's see how
    to retrieve the message from the Wear device. Inside the mobile module, create
    the additional package for code readability. We are going to name the packages
    models, services, and utils.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create a class that extends to `WearableListenerService` with
    the override method `onMessageReceived`. Create a class called `StepListener`
    and extend it to `WearableListenerService`; the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Registering the earlier service class in the manifest with the same path that
    the data sent over, the following code illustrates Wearable `DATA_CHANGED` and
    `MESSAGE_RECEIVED` actions with the data path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Steplistner` class is completed; we can use this class to process the
    data further. In the `steplistener` class, we are registering the `localbroadcast`
    receiver class to send the received data across the scope of the broadcast receiver.
    Before we build a UI, we shall receive all the data in the mobile app in `MainActivity`.
    Write an inner class to read through the steps received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the class in the `oncreate` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are successfully collecting the step counter data. Let's do the same process
    to collect the pulse rate. We will persist the step counts and, later, we will
    have a live stream of the heart pulse rate transmitting over the connected nodes
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Switching back to the Wear module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switch the project scope to the Wear module and select `HeartRateFragment`
    to instantiate a `GoogleClient` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `GoogleClient` instance within the `oncreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a method that sends the pulse rate count to the connected nodes, as we
    did earlier for the step counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the method inside the `onSensorchanged` callback with the BPM count received
    from the sensor event trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the mobile project scope. We need one more `WearableListenerService`
    class to talk with the heart rate data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a `localbroadcast` event inside the `onMessageReceived` callback to
    receive the data in activities. The complete listener class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the `service` class in Manifest as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, we shall write another Broadcast receiver. Let''s call it
    `HeartRateReceiver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Register `BroadcastReceiver` in the `oncreate` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are successfully receiving heart rate data directly from `HeartListener`
    to `broadcastreceiver`. Now, let's work on the User Interface for a Mobile project.
    We need to keep the UI comprehensively simple and powerful; the following design
    talks about interoperability with the Wear app and distance and calorie burn prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptualizing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The upbeat mobile application should display the steps and pulse rate. Upbeat
    needs to send a pulse rate request to the Wear app. History shows the distance
    and calories burned from the database. Reset will clear the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Landing screen: when the user opens the app, he or she will see something similar
    to the following design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we start working on the design, we need to be sure of a couple of things,
    such as the colors, backgrounds, and so on. Inside the `res/values` directory,
    open the `colors.xml` file and add the following color values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `drawable` resource file, call it `button_bg.xml`, and add the following
    selector code for the background selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `activity_main.xml`, we need three buttons for the planned functionality
    as per the design and three textviews. We will use a relative layout as the root
    container and the following code explains how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To display heart rate, we have `LinearLayour` with `Imageview` and `Textview`,
    where `imageview` is going to be static. Instead, replace `imageview` with `HeartBeatView`
    we created in the Wear module for heart custom animation. Let's create it one
    last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `res/values` folder, add the `heartbeatview_attrs.xml` file and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside drawables, create a vector graphic XML file and add the following code
    inside for achieving the heart shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a class called `HeartBearView` inside the utils package and add
    the following code for all the animations and custom view logic. For more details
    on the implementation, you can refer to the Wear module `HeartBeatView` class
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `activity_main.xml` file, instead of `ImageView`, replace the code
    with a custom view created in the mobile project scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that our landing page user interface is ready, we can get started by working
    on `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity`, let''s instantiate all the UI components we used in the
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Map the components with its ID using the `findviewbyid` method inside the `oncreate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `HeartRateReceiver` class, fetch the data, convert the data into
    integers, and show it in the UI. The following code illustrates activating `HeartBeatAnimation`
    with data received from the Wear app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In `StepReceiver`, we shall set the data to the step count `textview` labelled
    as `mSteps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have completed receiving the pulse count and step count and showing it in
    the phone's UI. Now, we need to show the calories burned for those steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the calories burned from the step count can be achieved by a number
    of different methods based on your body mass index and so on. Research on this
    pedometer steps to calories have introduced a conversion factor, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Conversion factor = 99.75 calories per mile / 2,200 steps per mile = 0.045
    calories per step*'
  prefs: []
  type: TYPE_NORMAL
- en: So using this value, we can determine the calories by simply multiplying this
    value with the steps count.
  prefs: []
  type: TYPE_NORMAL
- en: '*Calories burned = 7,000 steps x 0.045 calories per step = 318 calories*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `StepReceiver` class, inside the `onReceive` method, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The calorie burn and pulse rate checking from the phone is completed. We still
    have more work in `MainActivity`. We need to persist the data of the step counter
    to show the history of calories and distance. Let's use `RealmDB`, which we tried
    in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following classpath to the project level gradle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous plugin in the gradle mobile module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Realm is ready in the project. Now, we need setters and getters for the step
    data. Add the following class to the models package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, instantiate the Realm and initialize it in the `onCreate`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the step count is received, add the data to `RealmDB`. Add the following
    code inside the `onRecieve` method of the `StepReciever` inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the last value in the UI, add the following code to the `onCreate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the buttons, now attach the click listeners to the `oncreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another Activity and call it `HistoryActivity`, which will show
    the list of data received. In the `activity_history.xml` file, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need `row_layout` for each item in `recyclerview` and the layout is
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, before using `cardview` and `recyclerview`, we need to add the support
    dependencies to our gradle module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile ''com.android.support:cardview-v7:25.1.1''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile ''com.android.support:recyclerview-v7:25.1.1''`'
  prefs: []
  type: TYPE_NORMAL
- en: Recyclerview Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have to create an `adapter` class that fetches data from the Realm
    and adapts to `row_layout` that is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In adapter, we are showing calories burned with the conversion factor value.
    For finding a generic distance, we have another value and we need to multiply
    the steps to it, as shown in the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `HistoryActivity`, in the class global scope, declare the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `oncreate` method of the `HistoryActivity` class, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Completed HistoryActivity Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete class would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, start `historyActivity` when the `mHistory` button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to send the data from the mobile to wear using the same method
    that we used in Wear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a class that extends `Thread` and, using Node and Message API,
    we will send the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `mHeartPulse` button click listener, and start the `SendToDataLayerThread`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, switch back to the Wear project scope and add a new class that extends
    to `WearableListenerService`. When it receives a message from the mobile app,
    then fire a notification to start the application. The complete class code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, register the previously mentioned service in the manifest with the correct
    path mobile app using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s switch back to the mobile project scope and finish the reset button
    click event. We will write a method that flushes the `RealmDB` data and recreates
    the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the click listener, add the following methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Switch to Wear project scope and create a new Activity for health tips, and
    we will call the activity `HealthTipsActivity`. Here, on this screen, we will
    list a few good health tips and suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `activity_health_tips.xml`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add one more layout for the row item for the tips activity. We will
    call this layout `health_tips_row.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a model that contains the required fields. We shall create setters and
    getters with a full parameterized constructor for all the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall have another data class that will keep all the health tips:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we shall create an adapter to work with the list of health advice. The
    following code takes the data and loads it in `wearablerecyclerview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the global scope of the activity, declare the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `oncreate` method, we can complete the app by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Let's create another Activity for a generic calories chart from an international
    food list and call the activity `CalorychartActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CaloryChartActivity` layout file, we will add the `WearableRecyclerView`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another layout for each calorie chart item and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall create the `model` class for the calories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall create another adapter for the calorie chart. The adapter is similar
    to the `HealthTips` adapter. Create a file `RecyclerViewCaloryAdapter` and add
    the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CaloryChartActivity` global scope of the project, add the following
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code within the `oncreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The following screens show the complete mobile and Wear app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the active screen that listens to the steps
    and pulse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image illustrates the healthy food tips screen in the Wear app.
    It is designed with `WearableRecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The calorie chart for learning the calories available in different food items
    is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the fundamentals of working with Wear and mobile
    applications. We have explored the API support for sending and receiving data
    from Wear to mobile and vice versa. Now, integrating `RealmDB` for any Wear projects
    will be easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a Google Maps application for Wear devices
    and we will persist the location data, understanding different map types and controls
    for Wear devices.
  prefs: []
  type: TYPE_NORMAL
