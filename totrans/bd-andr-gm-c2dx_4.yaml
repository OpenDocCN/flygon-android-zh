- en: Chapter 4. User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have added the graphics that move around the screen and collide
    with each other, but it is not fun yet, since the player cannot control our main
    character and it would not be a game unless our user can interact with it. In
    this chapter we will add user interaction to our game. The following topics will
    be covered within this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Event Dispatcher mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the touch event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the accelerometer events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the screen alive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the Android back key pressed event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Event Dispatcher mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event handling is now different from how it was in the previous version (version
    2) of Cocos2d-x. From version 3.0 onwards, we now have a unified event dispatching
    mechanism, called Event Dispatcher, that handles all sorts of user input events,
    which may happen during the game.
  prefs: []
  type: TYPE_NORMAL
- en: We can handle many kinds of user input events, such as touches, keyboard key
    press, acceleration, and mouse motion. In the following sections we will cover
    how to handle the user input events that relate to mobile games, such as touch,
    and accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: There are many classes that allow us to listen for each of the previously mentioned
    events; once we have instantiated any of these classes, we need to add them to
    the event dispatcher so, when a user event is triggered, it will call the method
    defined by its corresponding listener.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the event dispatcher either by the `_eventDispatcher` instance
    attribute inherited from the `Node` class, or by calling the `getEventDispatcher`
    static method located in the Cocos2d-x API `Director` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cocos2d-x Event Dispatcher mechanism uses the observer design pattern, which
    is the pattern used for handling the user input events on the Android native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the touch event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to create interaction between games and users is through
    touch events. Handling the touch event is very straightforward in Cocos2d-x.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will allow the user to move our player sprite by touching
    it and moving it to the desired position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we will do is create the `initTouch`, `movePlayerByTouch`,
    and `movePlayerIfPossible` methods in the `HelloWorldScene.h` class header file,
    as we can see in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now let us add the initialization code to the `initTouch` method in the implementation
    file `HelloWorldScene.cpp`. In this simple game, we are going to use a single
    touch that is going to be used to move around our bunny character, no multi-touch
    handling is required.
  prefs: []
  type: TYPE_NORMAL
- en: In order to handle the single touch, we will create a new instance of the `EventListenerTouchOneByOne`
    class, then we are going to specify what our game should do when the touch event
    begins, when the touch is moving, and when the touch event ends. In the following
    code listing, after instantiating the `EventListenerTouchOneByOne` class, we will
    specify the methods that should be called when the events `onTouchBegan`, `onTouchMoved`,
    and `onTouchEnded` are triggered. For the purpose of the current game, we are
    only going to be using the `onTouchMoved` event. For this we are going to create
    a callback to our method, `movePlayerByTouch`, for the other two methods we are
    going to create empty structures through the lambda functions. You can learn more
    about the C++ lambda functions from the link [http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, all the C++ member variables are named with an underscore prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have encapsulated all the touch listener initialization codes into
    one method, let us call it our `init` method by adding the following line at the
    end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will now create the `movePlayerIfPossible` method. This will move the player
    sprite only if the new requested position on the horizontal axis is not out of
    the screen limits, as we can see in the illustration. This method will be used
    to move our player sprite with the touch input event, and it is also going to
    be used in the next section where we are going to move our player sprite by using
    the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Handling the touch event](img/B04193_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this method, we have used the "Tell, Don't Ask" design principle by making
    the validation in the method that verifies whether the player goes out of the
    screen in the method. This has saved us from repeating the logic of validating
    if the player sprite is out of the screen in the touch and accelerometer event
    handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will now create the `movePlayerByTouch` method, which will be called
    by the event dispatcher as soon as a touch event is triggered. In this method,
    we are going to evaluate the location on the screen, and whether the place where
    the user has touched the screen intersects the sprite''s bounding rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Handling multi-touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we enabled the touch event required for this game,
    which is a single touch; nevertheless, Cocos2d-x also handles the multi-touch
    capability, which we will cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our game does not require the multi-touch feature, we will create
    a test code so that we can move our player sprite and our bomb simultaneously.
    In order to do this, we are going to add the methods, `initMultiTouch` and `moveByMultitouch`,
    at the end of our `HelloWorldScene.h` header file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us add its implementation to the `HelloWorldScene.cpp` implementation
    file. We will begin by the `initMultiTouch` initialization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we can find similarities with the previous single-touch initialization
    method, but there are many differences, the most notorious one is that we are
    now instantiating the `EventListenerTouchAllAtOnce` class, instead of instantiating
    the `EventListenerTouchOneByOne` class as we had previously done. Although its
    event properties are named like its single-touch version, you may notice that
    they are now written in the plural, so that it is now referring to the touches
    instead of the touch, for example, `onTouchesBegan`. Now, it will also expect
    a different set of parameters, since we will now work with multiple touches, the
    event methods will now receive a `std::vector` parameter, where it will receive
    the collection of the touches that have occurred simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the previous code, we are going to call our `moveByMultiTouch`
    method every time our player moves the touches around, so we are now showing the
    implementation code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous code we are now handling multiple touches,
    and in the `moveByMultiTouch` method we are iterating through all the touches,
    and for each one, we are verifying if it is touching either our bomb or our bunny
    player sprite, and if it does so, then it will move the touched sprite to the
    touched location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us call the `initMultiTouch` initialization method at the end
    of our `init` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As previously mentioned, the objective of this section is to show you how simple
    it is to handle the multi-touch events; nevertheless, since we are not going to
    use it in our game, you may remove the call to the `initMultiTouch` method that
    we have just added to our `init` method, as soon as you finish testing the multi-touch
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Handling accelerometer events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common way of interacting between the game and the player is the accelerometer,
    which allows us to have hours of fun by moving our phone around in order to move
    our character and achieve the game's objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add the accelerometer support to our game, we are first going to
    add the following method declaration to our `HelloWorldScene.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create the code to our `HelloWorld.cpp` implementation file that
    corresponds to our accelerometer initialization. The first thing that we are going
    to do is enable the accelerometer sensor on the device, by calling the static
    method `setAccelerometerEnabled` located on the `Device` class, then we are going
    to create the event listener that will listen to the accelerometer''s events and
    finally, we will add it to the event dispatcher, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common way to add an event listener to the dispatcher is through the
    `addEventListenerWithSceneGraphPriority` method, which will assign the *z* order
    of the node sent as the second parameter as its priority. This is useful when
    we have many listeners that are triggered at the same time and we want to specify
    which code should run first.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have initialized the accelerometer, and we have created in
    the previous section, the `movePlayerIfPossible` method that will move the player
    sprite and make sure that it will not go out of the screen limits. Now we are
    going to create the implementation code for the `movePlayerByAccelerometer` method,
    which is going to be called as soon as an accelerometer event is triggered. Since
    the acceleration value that we get is very low, we multiply it by ten so that
    our player sprite moves faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let us call our accelerometer initialization code at the end of our
    `init` method from the `HelloWorldScene.cpp` implementation file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keeping the screen alive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we added the accelerometer interaction to our game,
    which means that our player is controlling the main character by moving the phone
    rather than by touching the screen, this will cause many android devices to turn
    off the screen after a period of inactivity (not touching the screen). Of course,
    no one would like that our Android device's screen suddenly goes black; in order
    to prevent this from happening, we will call the `setKeepScreenOnJni` method,
    introduced in the previous version 3.3 of the framework. Prior to this version,
    this annoying situation was considered a framework flaw, and now it has finally
    been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to include the helper in our `HelloWorldScene.cpp` header file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we are going to add the following line at the end of our `init` method
    in the `HelloWorldScene.cpp` implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Handling the Android back key pressed event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common mistake that I have seen in many games developed by using Cocos2d-x
    is that the game does nothing when the back button is pressed. Android users are
    used to pressing the back button whenever they want to go back to the previous
    activity. If the application does nothing when the back button is pressed, then
    it would confuse the user because it would not be an expected behavior, less experienced
    users may even have a hard time trying to exit the game.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily trigger a custom code any time the user presses the back button
    by adding an `EventListenerKeyboard` method to our event dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we are going to add the `initBackButtonListener` and `onKeyPressed` method
    declarations in our `HelloWorldScene.h` header file, as shown in the following
    code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us add the implementation code for our `initBackButtonListener` in
    our `HelloWorldScene.cpp` implementation file. We are first going to instantiate
    the `EventListenerKeyboard` class, then we are required to specify the methods
    that are going to be called on the `onKeyPressed` event and the `onKeyReleased`
    event or we will get a runtime error. We are going to create an empty method implementation
    and assign it to the `onKeyPressed` property through the C++11 lambda expressions,
    and then we are going to add a callback to our `onKeyPressed` method for the listener''s
    `onkeyRelease` property. Then, as we had done previously, we will add this listener
    to the event dispatcher mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to implement the code for our `onKeyPressed` method. This
    will tell the `Director` to end the game, if the key pressed is the back button
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will call the `initBackButtonListener` method at the end of the
    `init` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that you should add the `EventListenerKeyboard` listener to the event
    dispatcher in each scene where you want to catch the back button pressed event.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all the codes that we have added during this chapter, now, our `HelloWorldScene.h`
    header file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `HelloWorldScene.cpp` implementation file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will try to move the player, so that it does not go outside the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following two methods, `initTouch` and `initAccelerometer`,
    we have created functions for each initializing task. This will allow us to simplify
    our code, and make it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will initialize physics. To do this, we will call the initPhysics()
    method from within init():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the following image, we finally got our bunny to move around
    the screen and leave its initial central position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting everything together](img/B04193_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that in the previous code listing we have omitted the segments of
    the code that are not relevant to this chapter. If you want to see how the complete
    code listing looks at this point, then you can find it in the resource materials
    bundled with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we allowed the user to control our game by using two different
    input mechanisms, that is, touching the screen and moving the phone around in
    order to use the accelerometer sensor; we have also made our game stop whenever
    the back button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the different ways of adding text to our
    games.
  prefs: []
  type: TYPE_NORMAL
