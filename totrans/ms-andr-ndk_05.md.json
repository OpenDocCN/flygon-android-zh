["```java\nclSoundThread g_Sound;\nclPtr<clFileSystem> g_FS;\nint main()\n{\n  g_FS = make_intrusive<clFileSystem>();\n  g_FS->Mount( \".\" );\n  g_Sound.Start();\n  g_Sound.Exit( true );\n  return 0;\n}\n```", "```java\nclass clSoundThread: public iThread\n{\n  ALCdevice* FDevice;\n  ALCcontext* FContext;\n  ALuint FSourceID;\n  ALuint FBufferID;\n```", "```java\n  virtual void Run()\n  {\n```", "```java\n    LoadAL();\n```", "```java\n    FDevice = alcOpenDevice( nullptr );\n    FContext = alcCreateContext( FDevice, nullptr );\n    alcMakeContextCurrent( FContext );\n```", "```java\n    alGenSources( 1, &FSourceID );\n    alSourcef( FSourceID, AL_GAIN, 1.0 );\n```", "```java\n    auto data = LoadFileAsBlob( g_FS, \"test.wav\" );\n```", "```java\n    const sWAVHeader* Header = ( const sWAVHeader* )Blob->GetData();\n```", "```java\n    const unsigned char* WaveData = ( const unsigned char* )Blob->GetData() +\n      sizeof( sWAVHeader );\n    PlayBuffer( WaveData, Header->DataSize,\n      Header->SampleRate );\n```", "```java\n    while ( IsPlaying() ) {}\n```", "```java\n    alSourceStop( FSourceID );\n    alDeleteSources( 1, &FSourceID );\n    alDeleteBuffers( 1, &FBufferID );\n    alcDestroyContext( FContext );\n    alcCloseDevice( FDevice );\n    UnloadAL();\n  }\n```", "```java\n  bool IsPlaying() const\n  {\n    int State;\n    alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n    return State == AL_PLAYING;\n  }\n```", "```java\n  void PlayBuffer( const unsigned char* Data, int DataSize, int SampleRate )\n  {\n    alBufferData( FBufferID, AL_FORMAT_MONO16,\n      Data, DataSize, SampleRate );\n    alSourcei( FSourceID, AL_BUFFER, FBufferID );\n    alSourcei( FSourceID, AL_LOOPING, AL_FALSE );\n    alSourcef( FSourceID, AL_GAIN, 1.0f );\n    alSourcePlay( FSourceID );\n  }\n```", "```java\n  void Env_Sleep( int Milliseconds )\n  {\n    #if defined(_WIN32)\n      Sleep( Milliseconds );\n    #elif defined(ANDROID)\n      std::this_thread::sleep_for(\n        std::chrono::milliseconds( Milliseconds ) );\n    #else\n      usleep( static_cast<useconds_t>( Milliseconds ) * 1000 );\n    #endif\n  }\n```", "```java\n  clPtr<clBlob> LoadFileAsBlob( const clPtr<clFileSystem>& FileSystem, const std::string& Name )\n  {\n    auto Input = FileSystem->CreateReader( Name );\n    auto Res = make_intrusive<clBlob>();\n    Res->AppendBytes( Input->MapStream(), Input->GetSize() );\n    return Res;\n  }\n```", "```java\n  class clAudioThread: public iThread\n  {\n  public:\n    clAudioThread()\n    : FDevice( nullptr )\n    , FContext( nullptr )\n    , FInitialized( false )\n    {}\n    virtual void Run()\n    {\n      if ( !LoadAL() ) { return; }\n      FDevice = alcOpenDevice( nullptr );\n      FContext = alcCreateContext( FDevice, nullptr );\n      alcMakeContextCurrent( FContext );\n      FInitialized = true;\n      while ( !IsPendingExit() ) { Env_Sleep( 100 ); }\n      alcDestroyContext( FContext );\n      alcCloseDevice( FDevice );\n      UnloadAL();\n    }\n```", "```java\n    virtual void WaitForInitialization() const\n    {\n      while ( !FInitialized ) {}\n    }\n  private:\n    std::atomic<bool> FInitialized;\n    ALCdevice* FDevice;\n    ALCcontext* FContext;\n  };\n```", "```java\n  class iWaveDataProvider: public iIntrusiveCounter\n  {\n  public:\n```", "```java\n    int FChannels;\n    int FSamplesPerSec;\n    int FBitsPerSample;\n    iWaveDataProvider()\n    : FChannels( 0 )\n    , FSamplesPerSec( 0 )\n    , FBitsPerSample( 0 ) {}\n```", "```java\n    virtual unsigned char* GetWaveData() = 0;\n    virtual size_t GetWaveDataSize() const = 0;\n```", "```java\n    virtual bool IsStreaming() const { return false; }\n    virtual int StreamWaveData( int Size ) { return 0; }\n```", "```java\n    ALuint GetALFormat() const\n    {\n      if ( FBitsPerSample == 8 )\n        return ( FChannels == 2 ) ?\n          AL_FORMAT_STEREO8 : AL_FORMAT_MONO8;\n      if ( FBitsPerSample == 16 )\n        return ( FChannels == 2 ) ?\n          AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n      return AL_FORMAT_MONO8;\n    }\n  };\n```", "```java\n  class clStreamingWaveDataProvider: public iWaveDataProvider\n  {\n  public:\n    clStreamingWaveDataProvider()\n    : FBufferUsed( 0 )\n    {}\n    virtual bool IsStreaming() const override\n    { return true; }\n    virtual unsigned char* GetWaveData() override\n    { return ( unsigned char* )&FBuffer[0]; }\n    virtual size_t GetWaveDataSize() const override\n    { return FBufferUsed; }\n    std::vector<char> FBuffer;\n    size_t FBufferUsed;\n  };\n```", "```java\n  class clAudioSource: public iIntrusiveCounter\n  {\n  public:\n    clAudioSource()\n    : FWaveDataProvider( nullptr )\n    , FBuffersCount( 0 )\n    {\n      alGenSources( 1, &FSourceID );\n      alSourcef( FSourceID, AL_GAIN, 1.0 );\n      alSourcei( FSourceID, AL_LOOPING, AL_FALSE );\n    }\n```", "```java\n    void Play()\n    {\n      if ( IsPlaying() ) { return; }\n      if ( !FWaveDataProvider ) { return; }\n      int State;\n      alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n      if ( State != AL_PAUSED && FWaveDataProvider->IsStreaming() )\n      {\n        UnqueueAll();\n        StreamBuffer( FBufferID[0], BUFFER_SIZE );\n        StreamBuffer( FBufferID[1], BUFFER_SIZE );\n        alSourceQueueBuffers( FSourceID, 2, &FBufferID[0] );\n      }\n      alSourcePlay( FSourceID );\n    }\n```", "```java\n    void Stop()\n    {\n      alSourceStop( FSourceID );\n    }\n    void Pause()\n    {\n      alSourcePause( FSourceID );\n      UnqueueAll();\n    }\n```", "```java\n    void LoopSound( bool Loop )\n    {\n    alSourcei( FSourceID, AL_LOOPING, Loop ? 1 : 0 );\n    }\n    void SetVolume( float Volume )\n    {\n      alSourcef( FSourceID, AL_GAIN, Volume );\n    }\n```", "```java\n    bool IsPlaying() const\n    {\n      int State;\n      alGetSourcei( FSourceID, AL_SOURCE_STATE, &State );\n      return State == AL_PLAYING;\n    }\n```", "```java\n    int StreamBuffer( unsigned int BufferID, int Size )\n    {\n      int ActualSize = FWaveDataProvider->StreamWaveData( Size );\n      alBufferData( BufferID,\n        FWaveDataProvider->GetALFormat(),\n        FWaveDataProvider->GetWaveData(),\n        ( int )FWaveDataProvider->GetWaveDataSize(),\n        FWaveDataProvider->FSamplesPerSec );\n      return ActualSize;\n    }\n```", "```java\n    void Update( float DeltaSeconds )\n    {\n      if ( !FWaveDataProvider ) { return; }\n      if ( !IsPlaying() ) { return; }\n      if ( FWaveDataProvider->IsStreaming() )\n      {\n```", "```java\n      int Processed;\n      alGetSourcei( FSourceID, AL_BUFFERS_PROCESSED, &Processed );\n```", "```java\n      while ( Processed-- )\n      {\n        unsigned int BufID;\n        alSourceUnqueueBuffers( FSourceID, 1, &BufID );\n        StreamBuffer( BufID, BUFFER_SIZE );\n        alSourceQueueBuffers( FSourceID, 1, &BufID );\n      }\n    }\n  }\n```", "```java\n  virtual ~clAudioSource()\n  {\n    Stop();\n    alDeleteSources( 1, &FSourceID );\n    alDeleteBuffers( FBuffersCount, &FBufferID[0] );\n  }\n```", "```java\n  void BindWaveform( clPtr<iWaveDataProvider> Wave )\n  {\n    FWaveDataProvider = Wave;\n    if ( !Wave ) { return; }\n```", "```java\n    if ( FWaveDataProvider->IsStreaming() )\n    {\n      FBuffersCount = 2;\n      alGenBuffers( FBuffersCount, &FBufferID[0] );\n    }\n    else\n```", "```java\n    {\n      FBuffersCount = 1;\n      alGenBuffers( FBuffersCount, &FBufferID[0] );\n      alBufferData( FBufferID[0],\n        FWaveDataProvider->GetALFormat(),\n        FWaveDataProvider->GetWaveData(),\n        ( int )FWaveDataProvider->GetWaveDataSize(),\n        FWaveDataProvider->FSamplesPerSec );\n      alSourcei( FSourceID, AL_BUFFER, FBufferID[0] );\n    }\n  }\n```", "```java\nprivate:\n  void UnqueueAll()\n  {\n    int Queued;\n    alGetSourcei( FSourceID, AL_BUFFERS_QUEUED, &Queued );\n    if ( Queued > 0 )\n    {\n      alSourceUnqueueBuffers( FSourceID, Queued, &FBufferID[0] );\n    }\n  }\n```", "```java\n  clPtr<iWaveDataProvider> FWaveDataProvider;\n  unsigned int FSourceID;\n  unsigned int FBufferID[2];\n  int FBuffersCount;\n};\n```", "```java\nclass clSoundThread: public iThread\n{\n  virtual void Run()\n  {\n    g_Audio.WaitForInitialization();\n    auto Src = make_intrusive<clAudioSource>();\n    Src->BindWaveform( make_intrusive<clToneGenerator>() );\n    Src->Play();\n    double Seconds = Env_GetSeconds();\n    while ( !IsPendingExit() )\n    {\n      float DeltaSeconds = static_cast<float>( Env_GetSeconds() - Seconds );\n      Src->Update( DeltaSeconds );\n      Seconds = Env_GetSeconds();\n    }\n  }\n};\n```", "```java\nclass clToneGenerator : public clStreamingWaveDataProvider\n{\npublic:\n  clToneGenerator()\n  : FFrequency( 440.0f )\n  , FAmplitude( 350.0f )\n  , FLastOffset( 0 )\n  {\n    FBufferUsed = 100000;\n    FBuffer.resize( 100000 );\n    FChannels = 2;\n    FSamplesPerSec = 44100;\n    FBitsPerSample = 16;\n  }\n```", "```java\n  virtual int StreamWaveData( int Size )\n  {\n    if ( Size > static_cast<int>( FBuffer.size() ) )\n    {\n      FBuffer.resize( Size );\n      LastOffset = 0;\n    }\n```", "```java\n    const float TwoPI = 2.0f * 3.141592654f;\n    float Freq = TwoPI * FFrequency /\n      static_cast<float>( FSamplesPerSec );\n```", "```java\n    for ( int i = 0 ; i < Size / 4 ; i++ )\n    {\n      float t = Freq * static_cast<float>( i + LastOffset );\n      float val = FAmplitude * std::sin( t );\n```", "```java\n      short V = static_cast<short>( val );\n      FBuffer[i * 4 + 0] = V & 0xFF;\n      FBuffer[i * 4 + 1] = V >> 8;\n      FBuffer[i * 4 + 2] = V & 0xFF;\n      FBuffer[i * 4 + 3] = V >> 8;\n    }\n```", "```java\n    LastOffset += Size / 4;\n    LastOffset %= FSamplesPerSec;\n    return ( FBufferUsed = Size );\n  }\n  float FFrequency;\n  float FAmplitude;\nprivate:\n  int LastOffset;\n};\n```", "```java\nclass clGString\n{\npublic:\n  void GenerateSound()\n  {\n    // 4 seconds, 1 channel, 16 bit\n    FSoundLen  = 44100 * 4 * 2;\n    FStringLen = 200;\n```", "```java\n    float Frc = 0.5f;\n    InitString( Frc );\n    FSamples.resize( FsoundLen );\n    FSound.resize( FsoundLen );\n    float MaxS = 0;\n```", "```java\n    for ( int i = 0; i < FSoundLen; i++ )\n    {\n      FSamples[i] = Step();\n```", "```java\n      if ( MaxS < fabs(FSamples[i]) )\n      MaxS = fabs( FSamples[i] );\n    }\n```", "```java\n    const float SignedShortMax = 32767.0f;\n    float k = SignedShortMax / MaxS;\n    for ( int i = 0; i < FSoundLen; i++ )\n    {\n      FSound [i] = FSamples [i] * k;\n    }\n  }\n  std::vector<short int> FSound;\nprivate:\n  int FPickPos;\n  int FSoundLen;\n  std::vector<float> FSamples;\n  std::vector<float> FForce;\n  std::vector<float> FVel;\n  std::vector<float> FPos;\n  float k1, k2;\n  int FStringLen;\n  void InitString(float Freq)\n  {\n    FPos.resize(FStringLen);\n    FVel.resize(FStringLen);\n    FForce.resize(FStringLen);\n    const float Damping = 1.0f / 512.0f;\n    k1 = 1 - Damping;\n    k2 = Damping / 2.0f;\n```", "```java\n    FPickPos = FStringLen * 5 / 100;\n    for ( int i = 0 ; i < FStringLen ; i++ )\n    {\n      FVel[i] = FPos[i] = 0;\n    }\n```", "```java\n    for ( int i = 1 ; i < FStringLen - 1 ; i++ )\n    {\n      float m = 1.0f + 0.5f * (frand() - 0.5f);\n      FForce[i] = Freq / m;\n    }\n```", "```java\n    for ( int i = FStringLen/2; i < FStringLen - 1; i++ )\n    {\n      FVel[i] = 1;\n    }\n  }\n```", "```java\n  inline float frand()\n  {\n    return static_cast<float>( rand() ) / static_cast<float>( RAND_MAX );\n  }\n```", "```java\n  std::random_device rd;\n  std::mt19937 gen( rd() );\n  std::uniform_real_distribution<> dis( 0.0, 1.0 );\n  float frand()\n  {\n    return static_cast<float>( dis( gen ) );\n  }\n```", "```java\n  float Step()\n  {\n```", "```java\n    FPos[0] = FPos[FStringLen - 1] = 0;\n    FVel[0] = FVel[FStringLen - 1] = 0;\n```", "```java\n    for ( int i = 1 ; i < FStringLen - 1 ; i++ )\n    {\n      float d = (FPos[i - 1] + FPos[i + 1]) * 0.5f - FPos[i];\n      FVel[i] += d * FForce[i];\n    }\n```", "```java\n    for ( int i = 1 ; i < FStringLen - 1 ; i++ )\n    {\n      FVel[i] = FVel[i] * k1 +\n        (FVel[i - 1] + FVel[i + 1]) * k2;\n    }\n```", "```java\n    for ( int i = 1 ; i < FStringLen ; i++ )\n    {\n      FPos[i] += FVel[i];\n    }\n```", "```java\n    return FPos[FPickPos];\n    }\n  };\n```", "```java\n  clGString String;\n  String.GenerateSound();\n  const unsigned char* Data = (const unsigned char*)&String.FSound[0];\n  PlayBuffer( Data, (int)String.FSound.size() );\n```", "```java\n  class iDecodingProvider: public StreamingWaveDataProvider\n  {\n  protected:\n    virtual int ReadFromFile( int Size, int BytesRead ) = 0;\n    clPtr<clBlob> FRawData;\n  public:\n    bool FLoop;\n    bool FEof;\n    iDecodingProvider( const clPtr<clBlob>& Blob )\n    : FRawData( Blob )\n    , FLoop( false )\n    , FEof( false )\n    {}\n    virtual bool IsEOF() const { return FEof; }\n```", "```java\n    virtual int StreamWaveData( int Size ) override\n    {\n      int OldSize = ( int )FBuffer.size();\n      if ( Size > OldSize )\n      {\n```", "```java\n        FBuffer.resize( Size, 0 );\n      }\n      if ( FEof ) { return 0; }\n```", "```java\n      int BytesRead = 0;\n      while ( BytesRead < Size )\n      {\n        int Ret = ReadFromFile( Size, BytesRead );\n        if ( Ret > 0 ) BytesRead += Ret;\n\n```", "```java\n        else if ( Ret == 0 )\n        {\n          FEof = true;\n```", "```java\n          if ( FLoop )\n          {\n            Seek( 0 );\n            FEof = false;\n            continue;\n          }\n          break;\n        }\n```", "```java\n        else\n        {\n          Seek( 0 );\n          FEof = true;\n          break;\n        }\n      }\n      return ( FBufferUsed = BytesRead );\n    }\n  };\n```", "```java\n  class clModPlugProvider: public iDecodingProvider\n  {\n  private:\n    ModPlugFile* FModFile;\n  public:\n    ModPlugProvider( const clPtr<clBlob>& Blob ):\n    {\n      DecodingProvider( Blob )\n      FChannels = 2;\n      FSamplesPerSec = 44100;\n      FBitsPerSample = 16;\n      FModFile = ModPlug_Load_P(\n        ( const void* ) FRawData->GetDataConst(), ( int )FRawData->GetSize()\n      );\n    }\n```", "```java\n    virtual ~ModPlugProvider() { ModPlug_Unload_P( FModFile ); }\n```", "```java\n    virtual int ReadFromFile( int Size, int BytesRead )\n    {\n      return ModPlug_Read_P( FModFile,\n        &FBuffer[0] + BytesRead, Size - BytesRead );\n    }\n```", "```java\n    virtual void Seek( float Time )\n    {\n      FEof = false;\n      ModPlug_Seek_P( FModFile, ( int )( Time * 1000.0f ) );\n    }\n  };\n```", "```java\n  Src->BindWaveform( make_intrusive<clModPlugProvider>( LoadFileAsBlob( g_FS, \"augmented_emotions.xm\" ) \n    )\n   );\n```", "```java\n  class clMP3Provider: public iDecodingProvider\n  {\n  public:\n    clMP3Provider( const clPtr<clBlob>& Blob )\n    : iDecodingProvider( Blob )\n    {\n      FBuffer.resize(MP3_MAX_SAMPLES_PER_FRAME * 8);\n      FBufferUsed = 0;\n      FBitsPerSample = 16;\n      mp3 = mp3_create();\n      bytes_left = ( int )FRawData->GetSize();\n```", "```java\n      stream_pos = 0;\n      byte_count = mp3_decode((mp3_decoder_t*)mp3,\n        ( void* )FRawData->GetData(), bytes_left,\n        (signed short*)&FBuffer[0], &info);\n      bytes_left -= byte_count;\n```", "```java\n      FSamplesPerSec = info.sample_rate;\n      FChannels = info.channels;\n    }\n```", "```java\n    virtual ~MP3Provider()\n    {\n      mp3_done( &mp3 );\n    }\n```", "```java\n    virtual int ReadFromFile( int Size, int BytesRead )\n    {\n      byte_count = mp3_decode( (mp3_decoder_t*)mp3, (( char* )FRawData->GetData()) + stream_pos, bytes_left, (signed short *)(&FBuffer[0] + BytesRead), &info);\n      bytes_left -= byte_count;\n      stream_pos += byte_count;\n      return info.audio_bytes;\n    }\n```", "```java\n    virtual void Seek( float Time ) override\n    {\n      FEof = false;\n    }\n  private:\n    mp3_decoder_t mp3;\n    mp3_info_t info;\n    int stream_pos;\n    int bytes_left;\n    int byte_count;\n  };\n```", "```java\n  Src->BindWaveform( make_intrusive<clMP3Provider>( LoadFileAsBlob( g_FS, \"test.mp3\" ) ) );\n```", "```java\n  static size_t OGG_ReadFunc( void* Ptr, size_t Size, size_t NMemB, void* DataSource )\n  {\n    clOggProvider* OGG = static_cast<clOggProvider*>( DataSource );\n    size_t DataSize = OGG->FRawData->GetSize();\n    ogg_int64_t BytesRead = DataSize - OGG->FOGGRawPosition;\n    ogg_int64_t BytesSize = Size * NMemB;\n    if ( BytesSize < BytesRead ) { BytesRead = BytesSize; }\n```", "```java\n    memcpy(Ptr, ( unsigned char* )OGG->FRawData->GetDataConst() +\n      OGG->FOGGRawPosition, ( size_t )BytesRead );\n    OGG->FOGGRawPosition += BytesRead;\n    return ( size_t )BytesRead;\n  }\n```", "```java\n  static int OGG_SeekFunc( void* DataSource, ogg_int64_t Offset, int Whence )\n  {\n    clOggProvider* OGG = static_cast<clOggProvider*>( DataSource );\n    size_t DataSize = OGG->FRawData->GetSize();\n    if ( Whence == SEEK_SET )\n    {\n      OGG->FOGGRawPosition = Offset;\n    }\n    else if ( Whence == SEEK_CUR )\n    {\n      OGG->FOGGRawPosition += Offset;\n    }\n    else if ( Whence == SEEK_END )\n    {\n      OGG->FOGGRawPosition = DataSize + Offset;\n    }\n    if ( OGG->FOGGRawPosition > ( ogg_int64_t )DataSize )\n    {\n      OGG->FOGGRawPosition = ( ogg_int64_t )DataSize;\n    }\n    return static_cast<int>( OGG->FOGGRawPosition );\n  }\n```", "```java\n  static int OGG_CloseFunc( void* DataSource )\n  {\n    return 0;\n  }\n   static long OGG_TellFunc( void* DataSource )\n  {\n   return static_cast<int>(\n     (( clOggProvider* )DataSource )->FOGGRawPosition );\n  }\n```", "```java\n  clOggProvider( const clPtr<clBlob>& Blob )\n  : iDecodingProvider( Blob )\n  , FOGGRawPosition( 0 )\n  {\n    ov_callbacks Callbacks;\n    Callbacks.read_func  = OGG_ReadFunc;\n    Callbacks.seek_func  = OGG_SeekFunc;\n    Callbacks.close_func = OGG_CloseFunc;\n    Callbacks.tell_func  = OGG_TellFunc;\n    OGG_ov_open_callbacks( this, &FVorbisFile, nullptr, -1, Callbacks );\n```", "```java\n    vorbis_info* VorbisInfo = OGG_ov_info ( &FVorbisFile, -1 );\n    FChannels = VorbisInfo->channels;\n    FSamplesPerSec = VorbisInfo->rate;\n    FBitsPerSample = 16;\n  }\n```", "```java\n  virtual ~clOggProvider()\n  {\n    OGG_ov_clear( &FVorbisFile );\n  }\n```", "```java\n  virtual int ReadFromFile( int Size, int BytesRead ) override\n  {\n    return ( int )OGG_ov_read( &FVorbisFile, &FBuffer[0] + BytesRead, Size - BytesRead, 0, FBitsPerSample / 8, 1, &FOGGCurrentSection );\n  }\n  virtual void Seek( float Time ) override\n  {\n    FEof = false;\n    OGG_ov_time_seek( &FVorbisFile, Time );\n  }\nprivate:\n```", "```java\n  #include \"OGG_Callbacks.inc\"\n  OggVorbis_File FVorbisFile;\n  ogg_int64_t FOGGRawPosition;\n  int FOGGCurrentSection;\n};\n```", "```java\n>ndk-build\n>ant debug\n>adb install -r bin/App1-debug.apk\n\n```"]