- en: Ways to Get Around Anywhere - WearMap and the GoogleAPIclient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Map is a visual representation of an area or a part of an area.
  prefs: []
  type: TYPE_NORMAL
- en: We humans travel to different cities; they could be domestic or international
    cities. How about tracking the places you visit? We all use maps for different
    reasons, but in most cases, we use maps to plan a particular activity, such as
    outdoor tours, cycling, and other similar activities. Maps influence human intelligence
    to find the fastest route from the source location to the destination. In this
    project, we will build a Wear application that works with the Google Maps service.
  prefs: []
  type: TYPE_NORMAL
- en: For record, Google Maps started as a C++ desktop program in October, 2004\.
    Google Maps officially released in February, 2005\. Google Maps offers an API
    that allows maps to be embedded in third-party applications; Google Maps offers
    aerial and satellite views of many places. Google Maps is the best compared to
    other map services; maps are optimize and its accuracy rate is very good.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, let''s build a standalone Wear map application. When a user
    clicks on the map, we shall allow the user to write a story about the location
    and save it in the SQLite database as a marker. When a user clicks on the marker,
    we should show the user what is saved. In this chapter, we will understand the
    following important concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in the developer API console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the Maps API key with the help of the SHA1 fingerprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google API Client and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoCoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started with creating WearMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to create a standalone application. In case if you are following
    this project directly without following Wear-note application which is covered
    in [Chapter 2](part0041.html#173720-4c29edad0fa44cd98c59653fa3b7fce0), *Let us
    Help Capture What is on Your Mind - WearRecyclerView and More* and [Chapter 3](part0061.html#1Q5IA0-4c29edad0fa44cd98c59653fa3b7fce0),
    *Let us Help Capture What is on Your Mind - Saving Data and Customizing the UI*.
    Please do follow the Wear-note application to learn more about standalone applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call this project **WearMapDiary**, since we store the locations and
    details about the location. The project package address up to the developer; in
    this project, the package address is `com.packt.wearmapdiary` and the API level
    25 Nougat. In the activity template, select the Google Maps Wear Activity, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select Google Maps Wear Activity template from the activity chooser
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is created, we will see the necessary configuration for the
    project, which includes the map fragment already being added; it would have set
    the `DismissOverlays` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sample code configured for working with the Wear map activity will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the Maps API key to the project in the `res/values` directory
    `google_maps_api.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Google API console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google API console is a web portal that allows developers to manage Google
    services for their project development and it can be accessed at [https://console.developers.google.com](https://console.developers.google.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the developer console with your Google account. Create a project `packt-wear`
    or something that is convenient for developers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the project successfully, go to the API Manager | Library section
    and enable the Google Maps Android API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Enable button for enabling Maps for Android:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After enabling the API in the console facility, we need to create the API key
    with the development machine''s SHA1 fingerprint and the project''s package address,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get your machine''s SHA1 fingerprint, open Android Studio. On the right-hand
    side of Android Studio, you will see the Gradle project menu. Then, follow these
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Gradle (on the right-hand side panel, you will see the Gradle Bar)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Refresh (click on Refresh; on the Gradle Bar, you will see a List of
    Gradle scripts for your project)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Your Project (your Project Name from **List** (root))
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Tasks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Android
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on signingReport (you will get SHA1 and MD5 in Run Bar):'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy your SHA1 fingerprint, paste it in the Google API console, and save:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, copy the API key from the console and paste it in the project''s `google_maps_api.xml`
    file, as follows:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, switch your Gradle scope to app and compile the project in the Wear emulator
    or your Wear device:'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If your Google Play services is not updated in your emulator, Wear throws an
    error screen to update Play services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you have the actual Wear device, the Wear operating system will take care
    of downloading the latest Google Play services update when its available. For
    the emulator, we need to connect it to the actual device to add the account. First,
    connect the Android phone through **adb** and start the Wear emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Install the Android Wear companion app from the Play store [https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en](https://play.google.com/store/apps/details?id=com.google.android.wearable.app&hl=en).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the android Wear application, select emulator, and in the Android Studio
    terminal, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the emulator connects to your actual phone, you can add the account that
    is synced to your phone already or you can add a new account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the Wear account''s sync screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After successfully adding the account, start updating your Google Play services:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, after all this configuration, compile the program in Android Studio and
    see the map on the Wear device:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Google API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GoogleApiClient` extends the **Object** class. The Google API Client provides
    a common entry point to all the Google Play services and manages the network connection
    between the user''s device and each Google service. Google recommends to use `GoogleApiClient`
    to get the user''s location programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Create `GoogleApiClient` on each thread. `GoogleApiClient` service connections
    are cached internally. `GoogleApiClient` instances are not thread-safe, so creating
    multiple instances is fast. `GoogleApiClient` is used with a variety of static
    methods. Some of these methods require that `GoogleApiClient` be connected; some
    will queue up calls before `GoogleApiClient` is connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that creates a `GoogleApiClient` instance that connects
    with the Google `LocationServices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the project for functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know the importance of creating packages for better code management and maintaining
    code in the future. Let's create a package for the project with four different
    names, which are adapter, model, util, and view.
  prefs: []
  type: TYPE_NORMAL
- en: We write our plain old Java objects inside the model package. We will configure
    all the database-related classes in the util package and the custom views, such
    as dialog fragments, `TextView`, and so on, in the view package. For the custom
    `infoWindow`, we have to create a `infoWindowAdapter` inside the `adapter` package.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to fetch the location information using `GoogleApiClient`.
    Now that we have configured the Wear map activity and the map is drawn with the
    API key that we added, it is time to work on getting location details with the
    help of `GoogleApiClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting users' location information with the help of GoogleApiClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in the `MapActivity` class, we need to implement the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GoogleApiClient.ConnectionCallback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GoogleApiClient.OnConnectionFailedListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And, we need to override three methods from these two interfaces, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void onConnected(..){}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void onConnectionSuspended(..){}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void onConnectionFailed(..){}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `onConnected` method, we can instantiate the location service using
    the `GoogleApiClient` instance. First, let''s add the `GoogleApiClient` to the
    project. Create an instance of `GoogleApiClient` in the `MapActivity` global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a void method named `addGoogleAPIClient(){ }` for retrieving the location
    services API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To have the google play services to do the location related jobs, please add
    the following dependency in the gradle wear module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile ''com.google.android.gms:play-services-location:11.0.2''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `onConnected` method, attach the `mGoogleApiClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Locationservice` needs a permission check before requesting the location.
    Let's add the permission in manifest and in Activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following permissions to Manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a method in the `MapActivity.java` class for checking the permission
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the method `onRequestPermissionsResult(..){}` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the permission check method; handle it in the `onConnected` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a method to check whether the GPS is available `onboard` on Wear
    devices. Using the `packagemanager` class, we can retrieve the available hardware
    in a Wear device. Let''s write a method called `hasGps()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this method in the `onCreate()` method if you want your users to know about
    whether their device has a GPS device or you just want to log it for development
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If your wearable app records data using the built-in GPS, you may want to synchronize
    the location data with the handset using the `LocationListner` interface by implementing
    the `onLocationChanged()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To make your application location-aware, use `GoogleAPIclient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow this link for understanding more about permission: [https://developer.android.com/training/articles/wear-permissions.html](https://developer.android.com/training/articles/wear-permissions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s work with the `onMapclick` method for handling the process of adding
    the marker on maps. To do this, implement `GoogleMap.OnMapClickListener` in your
    activity and implement its callback method, which will give you the `onmapclick`
    with latlong. Add the click context to your `onMapReady` callback, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onMapClick` method, we can add the following marker using `latLng`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a marker in the `onMapclick` method uses `MarkerOptions()`. For custom
    markers designed by Google, we will use the `addmarker` method from maps and add
    the new `MarkerOptions` with position, title, and snippet, which is minimal description
    below the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the marker with `infowindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have the map and we are adding the marker to the map, but we need to
    work with geocoding for fetching the address name of the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: GeoSpatial data using GeoCoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetch the address using coordinates using the `GeoCoder` class. Geocoding, usually,
    is a process of transforming a street address or other description of a location
    into a (latitude, longitude) coordinate. Reverse geocoding is the process of transforming
    a (latitude, longitude) coordinate into a (partial) address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnMapClick` method, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet adds the marker to the map with the location name
    in the info window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The pop-up view on clicking the map is called `infowindow` in Android. It is
    a similar component to ToolTip in web development. In this project, we need to
    save the data wherever users click on the map; we need to show a custom map marker
    with the help of `infowindow`. We need to write an adapter implementing `GoogleMap.InfoWindowAdapter`
    with a custom layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Infowindow adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following implementation explains how to write our custom `infowindow`
    adapter for the map marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `windowadapter` class implements `GoogleMap.InfoWindowAdapter` with two
    callback methods `getInfoWindow(..){}` and `getInfoContents(..){}`. We can inflate
    our custom layout `getInfoContent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add the preceding adapter class to the adapter package for better code access
    and maintenance. `InfoWindowAdapter` does not use any data to populate the view;
    we populate the view with whatever data is associated with the marker. If we want
    to add anything beyond the title and the snippet, we have no way of doing it in
    the adapter itself. We need to create a mechanism for achieving this programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Memory` class in the model package. The `Memory` class is a place
    where users choose to add the marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have our memory and the custom `infowindow` adapter is ready for working
    with the `onMapclick` implementation. For each marker, we shall add a memory class
    association. To save all our memory temporarily, let''s use `HashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add our marker to `HashMap` for access to `Marker` properties, such
    as `Marker` ID and so on. The complete code for the adapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnMapClick` method, add the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the new `Marker` to the maps with the following code in the `onMapready`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the program. You should be able to see the updated `infoWindow`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom DialogFragment for taking notes about the location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DialogFragment` is a dialog window that floats in activity. On Wear devices
    it will not float but it gives the Wear optimized design. Check the following
    code for implementing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving forward, implement the Memory class to a serializable interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following layout file to the layout directory and call the layout file
    as `memory_dialog_fragment.xml`. After creating the file, add the following code
    inside the layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After creating the layout file, let's work on the Java code for creating the
    custom dialog. Create a class called `MemoryDialogFragment` and extend it to `DialogFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface for handling the `SaveClicked` and `cancelClicked` buttons
    of `DialogFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following instances to the `MemoryDialogFragment` global scope.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, work on inflating the layout with the right data in the right field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will fetch the serialized data from `Memory` in the `oncreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for the `MemoryDialogFragment` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `OnMapClick` method, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the program. You will see the following screen on `mapclick`.
    The user can input his or her thoughts about the map location in the edittext
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have added the dialog for taking the input, let's work on saving
    the data to SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SQLite and saving the markers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persisting all the necessary data is the fundamental use case for any good software.
    Android SDK provides an SQLite storage solution built in. It has a very small
    footprint and is very fast. If a programmer is familiar with SQL queries and operations,
    SQLite is going to be easy and delightful to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Schema and contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Essentially, for a database, we need to create a data schema, which is a formal
    declaration of how the database is organized. The schema is reflected in the SQLite
    query statements. A contract class is a container for constants that define names
    for URIs, tables, and columns. The contract class allows the use of the same constants
    across all the other classes in the same package.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the scope of `WearMapDiary`, we will create all the instances in the `DBHelper`
    class. Now, let''s create the `DBhelper` class, which opens and connects the application
    to SQLite and processes the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a `Datasource` for managing all the queries, and reading
    and writing the data to SQLite. Here, in this class, we will create multiple methods
    for creating data, reading the data, updating the data, and deleting the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For executing all these queries in the background using `cursorLoader`, we
    will write another class and we will call this class `DBCurserLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another class for loading all the memories from `memoryDatasource` and
    extend it to `DBCursorLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the SQLite configuration working fine. Lets work with `MapActivity`
    to save the data inside SQLite `onMapclick`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data in SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect SQLite to the activity and to save the data in SQLite, implement
    the activity `LoaderManager.LoaderCallbacks<Cursor>` and instatiate the datasource
    in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the callback methods for the `LoaderManager.LoaderCallbacks<Cursor>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, refactor the `addingMarker` code in a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to work with dragging the marker for future implementation. Let''s
    make the draggable property true. Now, in the `OnMapClick` method, call the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s refactor the `UpdateMemoryPosition` method, which fetches the address
    from `latlng` and adds it to `Memory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are saving the data inside SQLite. When we close and open the map,
    we are not reading and adding the marker data to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's read the SQLite data and add it to the maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onCreateLoader` callback method from the `LoaderManager` class adds the
    data through the `Datasource` instance to `MemoryLoader` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onLoadFinished` method, fetch the data from the cursor and add it to
    the maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the marker to map from fetched data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a functional Wear app called `WearMapDiary`, which finds the address
    and saves quick notes about the location in the map. It adds the marker to the
    SQLite database and attaches the marker to the map when we open the application
    in a Wear device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Retrieved notes and location information from the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this dialog, users can type in the data he or she wants to save in the current
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have explored how to integrate maps to Wear devices and had a clear
    understanding of getting the Maps API key. We are using `GoogleApiclient` for
    fetching the location service. We are checking for GPS hardware availability:'
  prefs: []
  type: TYPE_NORMAL
- en: Following steps briefly, explains how to write the custom marker.
  prefs: []
  type: TYPE_NORMAL
- en: Explored the custom `InfoWindow` adapter by implementing `GoogleMap.InfoWindowAdapter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a custom `dialogFragment` for Wear compatibility using `boxinsetlayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Geocoder` class fetching the `GeoSpatial` data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite and its integration for map data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to understand more about maps on Wear devices.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between a standalone map and mobile-synced map application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A watch application that is target at the Wear 2.0 platform can connect to Wi-Fi
    through the onboard Wi-Fi transceiver. We can cache the maps and a lot more, but
    it still lacks the comforts that a mobile map application gives. Generally, for
    standalone Wear applications, the target API level is 25 and comes with runtime
    permissions for security operations. In this chapter, we have added the code for
    handling runtime permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the app as standalone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wear 2.0 requires a new metadata element in the Android `Manifest` file of
    watch apps, as a child of the `<application>` element. The name of the new metadata
    element is `com.google.android.wearable.standalone` and the value must be true
    or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since standalone apps are independent or semi-independent, it can be installed
    by an iPhone user and Android phone that lacks the Play store (BlackBerry android
    forked OS and Nokia custom Android phones).
  prefs: []
  type: TYPE_NORMAL
- en: If a watch app depends on a phone app, set the value of the previous metadata
    element to false.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the value is false, the watch app can be installed before the corresponding
    phone app is installed. Therefore, if a watch app detects that a companion phone
    lacks a necessary phone app, the watch app should prompt the user to install the
    phone app.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between a Wear app and phone app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data can be shared between a Wear application and a phone application or data
    that is specific to an application. You can use standard Android storage APIs
    to store data locally. For example, you can use [SharedPreferences APIs](https://developer.android.com/reference/android/content/SharedPreferences.html),
    SQLite, or internal storage (as you would in the case of a phone). The Messaging
    API Wear app can communicate with the corresponding phone application.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting your application from another device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In **CapabilityAPI**, your Wear application can detect the corresponding mobile
    application for a Wear application. Wear devices can advertise their events to
    the paired device spontaneously and statically as well. For checking the advertised
    capabilities of paired Wear devices, check this link for more information: [https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities](https://developer.android.com/training/wearables/data-layer/messages.html#AdvertiseCapabilities).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that not all the phones support the Play store (such as iPhones, and so
    on). This section describes the best practices for these scenarios: your standalone
    watch app needs your phone app and your phone app needs your standalone watch
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying capability names to detect your apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the app corresponding to each device type (watch or phone), specify a unique
    string for the capability name in the `res/values/wear.xml` file. For example,
    in your mobile module, the `wear.xml` file could include the following code in
    Wear and mobile modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Detecting and guiding the user to install a corresponding phone app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wear 2.0 introduces standalone applications. Wear apps are capable enough to
    function without the support of a mobile app. In a critical situation, when a
    mobile app is a must, a Wear app can guide the user to install the mobile support
    app and the Wear correspondent app with the following set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `CapabilityApi` to check whether your phone app is installed on the paired
    phone. For more information, check this sample by Google: [https://github.com/googlesamples/android-WearVerifyRemoteApp.](https://github.com/googlesamples/android-WearVerifyRemoteApp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your phone app isn't installed on the phone, use `PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`
    to check what type of phone it is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE` is returned `true`
    which addresses that Playstore is installed in the phone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `RemoteIntent.startRemoteActivity()` on the Wear device to open the Play
    Store on the phone using the market URI ([market://details?id=com.example.android.wearable.wear.finddevices](http://use%20a%20market%20URI%20such%20as:%20market://details?id=com.example.android.wearable.wear.finddevices)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE` is returned, it
    means that the phone is likely an iOS phone (with no Play Store available). Open
    the App Store on the iPhone by calling `RemoteIntent.startRemoteActivity()` on
    the Wear device with this URI: [https://itunes.apple.com/us/app/yourappname](https://itunes.apple.com/us/app/yourappname).
    Also, see opening a URL from a watch. On an iPhone, from Android Wear, you cannot
    programmatically determine if your phone app is installed. As a best practice,
    provide a mechanism to the user (for example, a button) to manually trigger the
    opening of the App Store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more detailed understanding about standalone applications, do check out
    the following link: [https://developer.android.com/wear/preview/features/standalone-apps.html.](https://developer.android.com/wear/preview/features/standalone-apps.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your application active on a Wear device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write an application for different contexts, we need to do certain alternatives.
    We know that when not using the application, we should make that app to sleep
    in Wear devices for better battery performance, but when we are building an application
    for maps, it is necessary that maps be visible and active for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a simple configuration for this: a method with few lines that activates
    the ambient mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts the ambient mode on the map. The API swaps to a non-interactive
    and low-color rendering of the map when the user is no longer actively using the
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code exits the ambient mode on the WearMap. The API swaps to
    the normal rendering of the map when the user starts actively using the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Configuring WAKE_LOCK for your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Few Wear applications are very useful when they are constantly visible. Making
    an app constantly visible has an impact on battery life, so you should carefully
    consider that impact when adding this feature to your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `WAKE_LOCK` permission to manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the Input method framework for reading the input, users can
    also use the voice input, which requires active internet on your Wear device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Understanding fully interactive mode and lite mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Maps android API can serve static images as light mode maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Lite mode to Android Maps is similar to configuring the normal maps,
    because it will use the same classes and interfaces. We can set Google Maps to
    the Lite mode in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As an XML attribute to your `MapView` or `MapFrgament`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `GoogleMapOptions` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using the `GoogleMapOptions` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Interactive mode allows the application to use all the lifecycle methods, including
    `onCreate()`, `onDestroy()`, `onResume()`, and `onPause()`, and all the Google
    API features to make the application fully interactive. As a cost, there will
    be a network dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Interactive and Lite mode, check the following link:
    [https://developers.google.com/maps/documentation/android-api/lite.](https://developers.google.com/maps/documentation/android-api/lite)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are at the chapter's end, looking forward to what improvements we can
    do in the WearMapDiary app. Now, we know about creating a `MapsActivity`, setting
    up the maps and Google API key, configuring Google Play services in a Wear emulator,
    runtime permissions check, checking for the GPS hardware, and fetching the location
    name using the `geocoder` class. We have understood the concept of the interactive
    mode and Lite mode for maps. In the next chapter, let's understand more Wear and
    map UI controls and other Google Map technologies, such as streetview, changing
    the map types, and so on.
  prefs: []
  type: TYPE_NORMAL
