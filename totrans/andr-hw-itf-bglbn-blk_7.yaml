- en: Chapter 7. Where to Go from Here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we examined how an Android app can interface with GPIO,
    I2C, and SPI at the same time to provide a complete hardware-interfacing solution.
    While you might think that this covers most of the problems of hardware interfacing
    under Android, there are still many other factors to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating your solution into Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining your hardware with other hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the BBB's other interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating your solution with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BBB offers a wide variety of hardware features, and the particular features
    that you use in your projects will vary as you change the capes and overlays used
    within your system. While this gives you a lot of flexibility during prototyping,
    you might eventually reach a point where you will finalize your custom hardware
    design to a single, static configuration and decide to make it a permanent Android-based
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this book make the design decision of having apps directly access
    the hardware of the BBB. While this approach makes creating hardware-interfacing
    Android apps simple, it is not an ideal approach. Once you have a hardware design
    that you like and software that properly interfaces with the hardware, it is time
    to fully integrate your solution with Android. Depending upon just how complex
    your hardware solution is, you might end up creating custom kernel device drivers,
    or even modifying the managers within the Android OS framework!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom kernel and Device Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to creating a permanent Android solution is to ensure that everything
    on the Linux side of the system is as it should be. This means that all hardware
    support (such as Linux kernel drivers needed for your project) should be enabled
    in the kernel and configured and allocated within the kernel's Device Tree (for
    pin muxing and resource allocation). Ideally, everything that you need will be
    statically built directly into the kernel and Device Tree. This eliminates the
    need to load overlays and kernel modules for your solution via explicit commands
    executed from within the `init.{ro.hardware}.rc` file.
  prefs: []
  type: TYPE_NORMAL
- en: Our advice for preparing the kernel space aspects of your project is to develop
    these items from within Linux. The Linux environment provides far more tools for
    kernel driver development and debugging, and you'll be able to quickly and easily
    build standalone user space binaries that interact with custom and existing kernel
    drivers via the `open()`, `read()`, `write()`, and `ioctl()` function calls. The
    code-compile-test-debug cycle of Linux user space binaries can be performed very
    quickly because a full development toolchain, including compilers and debuggers,
    are available under Linux. Under Android, you must build such test binaries using
    the Android NDK on your development machine and then use `adb` to push them to
    an Android system for test. This makes the development cycle much slower and more
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a static Device Tree for your solution requires a similar process.
    The Device Tree and its overlays are compiled using the `dtc` tool, which is available
    under Linux, but not Android. Using standard Linux kernel debugging techniques,
    you can develop and troubleshoot an overlay that muxes the pins for your project
    and allocates the necessary kernel drivers to these pins. Once your overlay is
    working properly, you can integrate the overlay into the Device Tree permanently.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where can I learn more about Linux development for the BBB?**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many tutorials and resources available on the web to help you learn
    about developing Linux software and Device Tree overlays for the BBB. The best
    resource that we can recommend to you is the series of BeagleBone video tutorials
    created by Derek Molloy. These tutorials cover topics such as the setup and configuration
    of a C/C++ development environment, debugging, Device Tree overlay creation, and
    troubleshooting. They also have a variety of code and circuit examples to help
    get you started. You can watch these tutorials from the BeagleBone section of
    Derek's website at [http://derekmolloy.ie/beaglebone](http://derekmolloy.ie/beaglebone).
  prefs: []
  type: TYPE_NORMAL
- en: Adding hardware communication into the kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While interfacing directly with GPIOs and the I2C and SPI buses is convenient,
    it is not the most efficient way to interface with hardware. The I2C FRAM example
    in [Chapter 4](part0029_split_000.html#page "Chapter 4. Storing and Retrieving
    Data with I2C"), *Storing and Retrieving Data with I2C*, uses the 24c256 kernel
    driver to handle low-level details of communication with the FRAM chip. Can you
    imagine how difficult it would be to implement every single detail needed to directly
    interface with the FRAM chip? Aside from having to know every detail of the communication
    protocol between the BBB and the FRAM chip, such protocols can also require strict
    timing guarantees that are difficult or impossible to meet from user space.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where user space interfacing with hardware is infeasible, using a kernel
    driver is necessary. Kernel drivers encapsulate the details of communicating with
    a specific piece of hardware. This simplifies your interfacing apps by keeping
    these details outside your app's implementation. Kernel drivers also provide much
    stricter timing guarantees when communicating with hardware. This is because the
    kernel has a much deeper understanding of scheduling kernel driver communication
    events to meet the necessary deadlines. In user space, a process can be suspended
    at any time if the kernel's task scheduler has decided to give another process
    an opportunity to execute. Even if a user space process priority is greatly increased,
    it will still always have a lower scheduling priority when compared to the priority
    of kernel-based activities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a kernel driver can be quite complex, and it is an activity that is
    far outside the scope of this book. However, if you find yourself trying to meet
    very tight timing restrictions when communicating with a piece of hardware, you
    might eventually need to explore the details of kernel device driver development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where can I learn more about developing kernel drivers?**'
  prefs: []
  type: TYPE_NORMAL
- en: The best place to start learning about kernel driver development is the book
    *Linux Device Drivers* by Corbet, Rubini, and Kroah-Hartman. This book provides
    comprehensive instructions that walk you through the development process. Even
    better, the third edition of this book is freely available for download at [http://lwn.net/Kernel/LDD3](http://lwn.net/Kernel/LDD3).
    The third edition was originally published in 2005, so it is a bit dated, but
    the central concepts presented in the book are still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating into existing managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 5](part0035_split_000.html#page "Chapter 5. Interfacing with High-speed
    Sensors Using SPI"), *Interfacing with High-speed Sensors Using SPI*, you interfaced
    with an SPI-based temperature and pressure sensor. While you communicated with
    the sensor using the `spidev` kernel driver from a single app, it is far cleaner
    to have a manager communicate with the sensor instead. This way, all apps can
    request access to the sensor data by communicating with the manager, rather than
    having to understand the many details of SPI communications and coordinating access
    among themselves. It also restricts which apps have permission to interact with
    the `spidev` driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Android already has a manager, `Android.SensorManager`, that is designed
    to talk with hardware sensor resources that are commonly found in phones and tablets.
    Apps communicate with the manager by requesting an instance of the manager and
    then requesting an object that represents a particular type of sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If `SensorManager` was extended to interface with the SPI sensor that you used
    in [Chapter 5](part0035_split_000.html#page "Chapter 5. Interfacing with High-speed
    Sensors Using SPI"), *Interfacing with High-speed Sensors Using SPI*, your app
    could have communicated with the sensor via `SensorManager` with only a few lines
    of Java code! Even better, the file system permissions of the `spidev` device
    would not have to be set to such an insecure state for apps to communicate with
    the sensor. Unfortunately, it can be quite difficult to integrate new hardware
    functionality into an existing manager for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You must rebuild the appropriate pieces of Android, which typically requires
    you to build the complete Android source code base at least once. This is a time-consuming
    (and often quite confusing) process for the inexperienced. The Android Open Source
    Project provides instructions on how to build Android from source at [https://source.android.com/source](https://source.android.com/source).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The additional interface logic for your new hardware must be added into the
    HAL of the manager that you are integrating with. While this is often fairly straightforward,
    the pieces of the manager's HAL might be scattered throughout the Android code
    base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new hardware must comply with the framework's API methods that are provided
    by the manager. Unless you are willing to break API compatibility to add additional
    attributes and methods to a particular manager's class, you must ensure that your
    hardware fits the existing interfaces that the manager provides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this integration can be difficult, it is often very straightforward. As
    Android is designed with tablets and phones in mind, any hardware that can potentially
    be part of a mobile device platform probably already has an Android manager designed
    to interface with it. `SensorManager` is a good example of this. It is designed
    to provide sensor information from a variety of different types of sensor hardware.
    While you will need to integrate some native code into the `SensorManager` HAL
    to speak with your particular sensor, the communication between the HAL and the
    `SensorManager` API methods is a fairly simple process.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where can I find examples of integrating custom hardware into a manager**?'
  prefs: []
  type: TYPE_NORMAL
- en: Texas Instruments provides a number of **evaluation modules** (**EVMs**) for
    the various processors that they produce and sell. As many commercial products
    are based upon these processors, TI freely provides documentation and guidance
    on how to create custom HAL code that integrates common hardware into Android
    managers. The best place to begin looking for these details is the documentation
    of TI's Sitara Android SDK. The SDK's web page is located at [http://www.ti.com/tool/androidsdk-sitara](http://www.ti.com/tool/androidsdk-sitara).
  prefs: []
  type: TYPE_NORMAL
- en: Creating new managers for custom hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are integrating a unique piece of hardware into Android, such as the
    environment sampler you created in [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution"), *Creating a Complete Interfacing Solution*,
    there will probably not be any standard Android manager that provides the necessary
    API methods for apps to properly communicate with the hardware. In this case,
    you might consider creating a new type of manager that specifically deals with
    the unique hardware.
  prefs: []
  type: TYPE_NORMAL
- en: A new manager can be tailored specifically to the hardware that it interacts
    with. For example, the BBB offers specialized hardware that allows software to
    communicate with the computers inside most modern vehicles. Such functionality
    is not available in standard Android mobile devices, so no exists to handle such
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new manager to handle the specific details of using this interface
    and providing a custom API to use this manager frees apps from having to know
    the details of such communication. However, this should be considered as a last
    resort for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no existing manager code to build upon. At best, you might find a simple
    manager from which to copy the code as a starting point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android build process must be modified to include building the new manager
    code. This requires adding the source files for the new manager to the Android
    makefiles and then verifying that the Android framework is not broken. Building
    Android is a large and complex task, so making any changes to the process should
    not be undertaken lightly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must design a proper API to interface with the new manager. As this new
    interface addition is not part of the standard Android API, apps will be unable
    to include these API calls unless you specifically add them to your Eclipse ADT
    installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must also augment `android.Manifest.permission` to include one or more new
    permission settings that allow an app to access the functionality of the new manager.
    As an alternative, you can piggyback on an existing permission or choose to forego
    using permissions entirely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall, building a custom manager is a lot of work and not for the fainthearted.
    The process touches many different pieces of the Android framework and requires
    expertise in the functionality of all of those pieces. If you find yourself in
    a position where you think you absolutely need to create a new manager to handle
    your hardware properly via the Android framework, you should consider skipping
    the manager and using an approach similar to the examples in this book: have your
    app communicate directly with your hardware using JNI.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining your project with other hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have considered how to best modify the software side of your Android
    system to fully integrate your custom hardware project, let's look at the hardware
    side of things. Breadboards do a great job of allowing you to rapidly create and
    change your hardware project designs. Hardware and software co-design is an iterative
    process, so you might find yourself changing your hardware designs as you develop
    interfacing software. However, carrying around a breadboard to show off your hardware
    projects is far from ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing your own prototype capes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why not create your own custom cape board project? If you have developed the
    perfect hardware project for your Android system, you should consider making it
    a stand-alone cape board. Putting your project into a cape form factor makes it
    easy to integrate it with other cape boards. It also allows you to move your project
    from place to place without worrying about disturbing the circuit or accidentally
    disconnecting any breadboard wires.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a professionally laid-out PCB for a custom cape is a very difficult
    task for the inexperienced. However, you can still construct your own cape board
    with a little soldering and planning. Adafruit's Proto Cape Kit (product ID 572)
    is a great place to start. Proto Cape is little more than a generic PCB to hold
    components that are soldered into semipermanent circuits. If you purchased the
    BeagleBone Black Starter Pack (product ID 703) that we mentioned in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Introduction to Android and the BeagleBone Black"), *Introduction
    to Android and the BeagleBone Black*, you already have Proto Cape, as it is included
    in that kit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing your own prototype capes](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Proto Cape Kit for constructing semipermanent cape circuits (source: [www.adafruit.com](http://www.adafruit.com))'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proto Cape also offers the important advantage of removing the breadboard wires
    that block the openings of the P8/P9 connectors. Up to four capes can be connected
    simultaneously by *stacking* the capes (plugging one cape into another via pass-through
    P8/P9 connectors on each cape). This provides the opportunity to combine different
    combinations of capes to create a custom Android system that makes the most out
    of the custom hardware that you have designed. If breadboard wires are blocking
    the P8/P9 connections, other capes can no longer be inserted into the connectors
    and stacked on top of the BBB. This makes it impossible to use a breadboard design
    if the top-most cape in the stack doesn't have a pass-through P8/P9 connector
    (like most LCD capes).
  prefs: []
  type: TYPE_NORMAL
- en: Commercial capes that interface with Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of premade BBB capes that are available for purchase and
    will work well with Android. 4D Systems ([http://www.4dsystems.com.au/](http://www.4dsystems.com.au/))
    provides several different reasonably priced LCD capes of various sizes and resolutions
    that are available in both touchscreen and non-touchscreen models. BeagleBoard
    Toys ([http://www.beagleboardtoys.com/](http://www.beagleboardtoys.com/)) also
    provides a wide variety of capes, such as LCD, audio, and battery capes. By combining
    a variety of different capes with your BBB, you can turn your Android system into
    a portable Android device!
  prefs: []
  type: TYPE_NORMAL
- en: '![Commercial capes that interface with Android](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The 4DCAPE-70T (800 x 480 pixels, left) and 4DCAPE-43T (480 x 272 pixels, right)
    4D Systems touchscreen LCD capes (source: [www.4dsystems.com.au](http://www.4dsystems.com.au))'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What about USB devices?**'
  prefs: []
  type: TYPE_NORMAL
- en: Other hardware components to consider are USB devices such as audio devices,
    mice, keyboards, Wi-Fi adapters, Bluetooth adapters, gamepads, and webcams. As
    the Linux kernel contains drivers for all of these devices, you can easily experiment
    with them to extend your Android platform and develop a variety of creative apps.
    The BBB only has a single USB port, though you can connect a USB hub to that port
    to support using multiple USB devices simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you can create an Android-based hand-held gaming console with GPIO controller
    inputs and an SPI- or I2C-based accelerometer. Or you can design a custom automotive
    control console with a touchscreen LCD that gathers real-time data from your vehicle.
    You have control of both the hardware and software of the entire platform, and
    the Android app development tools are excellent for creating UIs quickly and easily.
    The possibilities are endless!
  prefs: []
  type: TYPE_NORMAL
- en: '![Commercial capes that interface with Android](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The 5VDC battery (left) and audio CODEC (right) CircuitCo capes (source: [www.beagleboardtoys.com](http://www.beagleboardtoys.com))'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the BBB's other interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the BBB's GPIO, SPI, and I2C functionality for our interfacing.
    These are not the only interfacing options that the BBB offers, though. The following
    are a few other interfaces that you should keep in mind as you consider Android
    projects on the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: Programmable real-time units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded within the BBB's AM335X processor are a pair of programmable real-time
    units (PRUs). These units are clocked at 200 MHz, so they execute programs at
    the rate of a single instruction every 5 ns. The kernel loads programs into a
    PRU and then instructs the PRU to begin execution. Communication between the PRU
    and the kernel occurs via shared memory. The execution of PRUs is completely separate
    from that of the main processor, so pushing the PRUs to their limit will not have
    a performance impact on the main processor unless some coordination between the
    processor and a PRU is required.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of GPIO pins that can be muxed so that they fall under the
    direct control of a PRU. The PRU can check or set the value of these GPIOs on
    each instruction, meaning that PRU-controlled GPIOs can toggle fast enough to
    "bit-bang" implementations of complex digital interfaces (such as SPI and I2C).
    If you have a custom piece of hardware and need to implement a high-speed interface
    to it, using one or both of the PRUs is an option.
  prefs: []
  type: TYPE_NORMAL
- en: Serial communications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BBB offers five serial communication UARTs that can be muxed to the pins
    of the P8 and P9 connectors. There is also a sixth UART (UART0) that provides
    the serial debug output via the FTDI cable. If you are using the BBB to control
    a large number of serial-controlled devices, these UARTs are a very useful resource.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, several of these UARTs (UARTs 3, 4, and 5) conflict with pins
    that are in use by the LCD interface bus that provides video data to LCD capes
    and the internal HDMI cape. As much of Android's strength comes from its user
    interface, disabling the LCD interface to receive more UARTs is usually a very
    poor trade-off. If you find that you absolutely need these UARTs under Android,
    all of the UARTs can be accessed using the standard Linux kernel serial driver
    and existing NDK libraries that access the `/dev/TTYS*` files in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Controller area network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two **controller area network** (**CAN**) buses on the BBB. CAN is
    a serial protocol that forms one of the five protocols used in the **on-board
    diagnostics** (**OBD**) standard for vehicle interfacing. Vehicle diagnostics
    hardware and software use CAN to communicate with the host controller of most
    modern automobiles. The CAN driver in the Linux kernel exposes each CAN bus as
    a network interface that can be communicated with via network socket programming.
    If you are interested in creating an Android device capable of communicating with
    your vehicle, such as a status display in your car or a hand-held diagnostic unit,
    the CAN bus is exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: The CAN0 bus is muxed to the P9.19 and P9.20 pins, which are the same pins used
    by the I2C2 bus used by the capemgr to discover the identity of any connected
    capes. Muxing the CAN1 bus to the P9.24 and P9.26 pins can conflict with I2C1
    depending upon how you have muxed your I2C channels. In general, you won't be
    able to use SPI, I2C, and CAN at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The analog-to-digital converter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The BBB isn't limited to only digital communications. It also provides an 8-channel,
    12-bit **analog-to-digital converter** (**ADC**) that allows the BBB to receive
    analog voltage levels between 0 and 1.8 V. This is useful when interacting with
    real-world sensors as well as many touchscreen displays. However, you must be
    very careful to ensure that the voltage applied to these pins never exceeds 1.8
    volts or you will damage the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: Pins P9.32 through P9.40 are permanently muxed with ADC, so you are free to
    use them for your own projects. The CircuitCo and 4D Systems LCD capes with touchscreen
    support presently use ADC channels 4-7 for the touchscreen, leaving channels 0-3
    available for your use.
  prefs: []
  type: TYPE_NORMAL
- en: Pulse width modulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AM3359 processor on the BBB has a **Pulse Width Modulation** (**PWM**) subsystem
    that is used for the precise control of electric motors. PWM sets the period and
    duty cycle where voltage is supplied to a motor to control its rotation speed.
    The PWM subsystem contains three **Enhanced High Resolution Pulse Width Modulator**
    (**eHRPWM**) modules and an **Enhanced Quadrature Encoder Pulse** (**eQEP**) module.
    Altogether, these four modules provide eight PWM channels for driving motors.
  prefs: []
  type: TYPE_NORMAL
- en: While PWM is often seen in control of industrial manufacturing equipment, robotic
    servo motors, and various other mechanical systems, it can also be used to control
    the brightness of lighting and other tasks that can make use of the variable duty
    cycle of PWM to emulate power/brightness/speed levels between off and on at full
    intensity. If you are interested in controlling mechanical systems with the Android
    OS, PWM is definitely a feature of the BBB that you should explore further.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to fully integrate your custom hardware projects
    into Android on the BBB. We discussed how your custom device drivers should be
    built directly into your Linux kernel and how your custom Device Tree overlays
    should be compiled directly into the main Device Tree. This avoids having to include
    a special module and an overlay that loads commands in your `init.{ro.hardware}.rc`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored how to customize the standard Android software framework to
    include support for your custom hardware projects. Existing Android managers can
    be extended to support custom hardware.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at making your custom hardware design semipermanent using Proto Cape.
    This allows you to avoid accidentally disconnecting breadboard wires when moving
    your project around. It also allows for easier integration with commercially available
    BBB capes by avoiding the problem of blocking the P8/P9 connectors with breadboard
    wires. We also mentioned that there are many types of USB devices that are also
    supported by Android and are worth exploring when considering new projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored some of the other BBB interfaces that were not covered
    by the examples in the earlier chapters of this book. The BBB's PRUs, serial UARTs,
    CAN buses, ADCs, and PWM subsystems all offer additional functionality to interface
    with the outside world.
  prefs: []
  type: TYPE_NORMAL
