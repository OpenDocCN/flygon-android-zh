["```java\nclass iBehaviour: public iIntrusiveCounter\n{\npublic:\n  virtual vec2 GetControl( float dt, clBoid* Boid ) = 0;\n};\n```", "```java\nclass clBoid: public iActor\n{\npublic:\n  vec2 m_Pos;\n  vec2 m_Vel;\n```", "```java\n  float m_Angle;\n  float m_MaxVel;\n```", "```java\n  clPtr<iBehaviour> m_Behaviour;\n```", "```java\n  clSwarm* m_Swarm;\n```", "```java\npublic:\n  clBoid():\n  m_Pos(), m_Vel(),\n  m_Angle(0.0f), m_MaxVel(1.0f),\n  m_Behaviour(), m_Swarm(nullptr)\n  {}\n```", "```java\n  virtual void Update( float dt ) override\n  {\n    if ( m_Behaviour )\n    {\n      vec2 Force = m_Behaviour->GetControl( dt, this );\n```", "```java\n      const float Mass = 1.0f;\n      vec2 Accel = Force / Mass;\n      m_Vel += Accel * dt;\n    }\n```", "```java\n    m_Vel = ClampVec2( m_Vel, m_MaxVel );\n```", "```java\n    m_Pos += m_Vel * dt;\n```", "```java\n    if ( m_Vel.SqrLength() > 0.0f )\n    {\n      m_Angle = atan2( m_Vel.y, m_Vel.x );\n    }\n  }\n};\n```", "```java\nclass clWanderBehaviour: public iBehaviour\n{\npublic:\n  virtual vec2 GetControl( float dt, clBoid* Boid ) override\n  {\n    return vec2( RandomFloat() * 2.0f - 1.0f, RandomFloat() * 2.0f - 1.0f );\n  }\n};\n```", "```java\nclass clGoToBehaviour: public iBehaviour\n{\npublic:\n```", "```java\n  vec2 m_Target;\n  float m_TargetRadius;\n```", "```java\n  float m_VelGain;\n  float m_PosGain;\n```", "```java\n  clGoToBehaviour():\n  m_Target(),\n  m_TargetRadius(0.1f),\n  m_VelGain(0.05f),\n  m_PosGain(1.0f)\n  {}\n```", "```java\n  virtual vec2 GetControl( float dt, clBoid* Boid ) override\n  {\n    auto Delta = m_Target - Boid->m_Pos;\n```", "```java\n    if ( Delta.Length() < m_TargetRadius )\n    {\n      return vec2();\n    }\n```", "```java\n    return Delta * m_PosGain;\n  }\n};\n```", "```java\ninline vec2 ClampVec2(const vec2& V, float MaxValue)\n{\n  float L = V.Length();\n  return (L > MaxValue) ? V.GetNormalized() * MaxValue : V;\n}\n```", "```java\nstd::random_device rd;\nstd::mt19937 gen( rd() );\nstd::uniform_real_distribution<> dis( 0.0, 1.0 );\nfloat RandomFloat()\n{\n  return static_cast<float>( dis( gen ) );\n}\n```", "```java\nvec2 RandomVec2Range( const vec2& Min, const vec2& Max )\n{\n  return Min + vec2( RandomFloat() * ( Max - Min ).x,\n    RandomFloat() * ( Max - Min ).y );\n}\n```", "```java\nclass clSwarm: public iIntrusiveCounter\n{\npublic:\n  std::vector< clPtr<clBoid> > m_Boids;\n  clSwarm() {}\n```", "```java\n  void GenerateRandom( size_t N )\n  {\n    m_Boids.reserve( N );\n    for ( size_t i = 0; i != N; i++ )\n    {\n      m_Boids.emplace_back( make_intrusive<clBoid>() );\n```", "```java\n      m_Boids.back()->m_Behaviour = make_intrusive<clWanderBehaviour>();\n      m_Boids.back()->m_Swarm = this;\n```", "```java\n      m_Boids.back()->m_Pos = RandomVec2Range( vec2(-1, -1), vec2(1, 1) );\n    }\n  }\n```", "```java\n  void Update( float dt )\n  {\n    for ( auto& i : m_Boids )\n    {\n      i->Update( dt );\n    }\n  }\n```", "```java\n  vec2 CalculateSeparation( clBoid* B, float SafeDistance )\n  {\n    vec2 Control;\n    for ( auto& i : m_Boids)\n    {\n      if ( i.GetInternalPtr() != B )\n      {\n```", "```java\n        auto Delta = i->m_Pos - B->m_Pos;\n```", "```java\n        if ( Delta.Length() < SafeDistance )\n        {\n          Control += Delta;\n        }\n      }\n    }\n    return Control;\n  }\n```", "```java\n  vec2 CalculateAverageNeighboursPosition( clBoid* B )\n  {\n    int N = static_cast<int>( m_Boids.size() );\n```", "```java\n    if ( N > 1 )\n    {\n      vec2 Avg(0, 0);\n```", "```java\n      for ( auto& i : m_Boids )\n      {\n        if ( i.GetInternalPtr() != B )\n        {\n          Avg += i->m_Pos;\n        }\n      }\n      Avg *= 1.0f / (float)(N - 1);\n      return Avg;\n    }\n```", "```java\n    return B->m_Pos;\n  }\n```", "```java\n  vec2 CalculateAverageNeighboursVelocity( clBoid* B )\n  {\n    int N = (int)m_Boids.size();\n    if (N > 1)\n    {\n      vec2 Avg(0, 0);\n      for ( auto& i : m_Boids )\n        if ( i.GetInternalPtr() != B )\n          Avg += i->m_Vel;\n          Avg *= 1.0f / (float)(N - 1);\n      return Avg;\n    }\n    return B->m_Vel;\n  }\n```", "```java\n  void SetSingleBehaviour( const clPtr<iBehaviour>& B )\n  {\n    for ( auto& i : m_Boids )\n    {\n      i->m_Behaviour = B;\n    }\n  }\n};\n```", "```java\nclass clFlockingBehaviour : public iBehaviour\n{\n```", "```java\npublic:\n  clFlockingBehaviour():\n  m_AlignmentGain(0.1f),\n  m_AvoidanceGain(2.0f),\n  m_CohesionGain(0.1f),\n  m_SafeDistance(0.5f),\n  m_MaxValue(1.0f)\n  {}\n```", "```java\n  float m_SafeDistance;\n```", "```java\n  float m_AvoidanceGain;\n  float m_AlignmentGain;\n  float m_CohesionGain;\n  virtual vec2 GetControl(float dt, clBoid* Boid) override\n  {\n    auto Swarm = Boid->m_Swarm;\n```", "```java\n    vec2 Sep = m_AvoidanceGain * Swarm->CalculateSeparation(Boid, m_SafeDistance);\n```", "```java\n    auto AvgPos = Swarm->CalculateAverageNeighboursPosition(Boid);\n    vec2 Alignment = m_AlignmentGain * (AvgPos - Boid->m_Pos);\n```", "```java\n    auto AvgVel = Swarm->CalculateAverageNeighboursVelocity(Boid);\n    vec2 Cohesion = m_CohesionGain * (AvgVel - Boid->m_Vel);\n```", "```java\n    return ClampVec2( Sep + Alignment + Cohesion, m_MaxValue );\n  }\n};\n```", "```java\nclass clMixedBehaviour : public iBehaviour\n{\npublic:\n  std::vector< clPtr<iBehaviour> > m_Behaviours;\n  std::vector<float> m_Weights;\n```", "```java\n  void AddBehaviour( float Weight, const clPtr<iBehaviour>& B )\n  {\n    m_Weights.push_back( Weight );\n    m_Behaviours.push_back( B );\n  }\n```", "```java\n  virtual vec2 GetControl(float dt, clBoid* Boid) override\n  {\n    vec2 Control;\n    for ( size_t i = 0; i < m_Behaviours.size(); i++)\n    {\n      Control += m_Weights[i] * m_Behaviours[i]->GetControl(dt, Boid);\n    }\n    return Control;\n  }\n};\n```", "```java\nclass clSwarmRenderer\n{\nprivate:\n```", "```java\n  clPtr<clSceneNode> m_Root;\n```", "```java\n  clPtr<clSwarm> m_Swarm;\n```", "```java\n  std::vector< clPtr<clSceneNode> > m_Boids;\n```", "```java\npublic:\n  explicit clSwarmRenderer( const clPtr<clSwarm> Swarm )\n  : m_Root( make_intrusive<clSceneNode>() )\n  , m_Swarm( Swarm )\n  {\n    m_Boids.reserve( Swarm->m_Boids.size() );\n    const float Size = 0.05f;\n    for ( const auto& i : Swarm->m_Boids )\n    {\n      m_Boids.emplace_back( make_intrusive<clSceneNode>() );\n```", "```java\n      auto VA = clGeomServ::CreateTriangle( -0.5f * Size, Size, Size, 0.0f );\n      auto GeometryNode = make_intrusive<clGeometryNode>( );\n      GeometryNode->SetVertexAttribs( VA );\n      m_Boids.back()->Add( GeometryNode );\n```", "```java\n      m_Root->Add( m_Boids.back() );\n    }\n    Update();\n  }\n```", "```java\n  void Update()\n  {\n    for ( size_t i = 0; i != m_Boids.size(); i++ )\n    {\n      float Angle = m_Swarm->m_Boids[i]->m_Angle;\n      mat4 T = mat4::GetTranslateMatrix( vec3( m_Swarm->m_Boids[i]->m_Pos ) );\n      mat4 R = mat4::GetRotateMatrixAxis( Angle,vec3( 0, 0, 1 ) );\n      m_Boids[i]->SetLocalTransform( R * T );\n    }\n  }\n  clPtr<clSceneNode> GetRootNode() const { return m_Root; }\n};\n```", "```java\nauto Swarm = make_intrusive<clSwarm>();\nSwarm->GenerateRandom( 10 );\n```", "```java\nauto MixedControl = make_intrusive<clMixedBehaviour>();\nMixedControl->AddBehaviour(0.5f, make_intrusive<clFlockingBehaviour>());\nMixedControl->AddBehaviour(0.5f, g_Behaviour);\nSwarm->SetSingleBehaviour(MixedControl);\n```", "```java\ng_Behaviour->m_TargetRadius = 0.1f;\ng_Behaviour->m_Target = vec2( 1.0f );\ng_Behaviour->m_PosGain = 0.1f;\n```", "```java\nclSwarmRenderer SwarmRenderer( Swarm );\n```", "```java\nvoid OnTouch( int X, int Y, bool Touch )\n{\n  g_MouseState.FPos = g_Window->GetNormalizedPoint( X, Y );\n  g_MouseState.FPressed = Touch;\n  if ( !Touch )\n  {\n```", "```java\n    vec3 Pos = Math::UnProjectPoint( vec3( g_MouseState.FPos ), Math::Perspective( 45.0f, g_Window->GetAspect(), 0.4f, 2000.0f ), g_Camera.GetViewMatrix() );\n```", "```java\n    mat4 CamRotation;\n    vec3 CamPosition;\n    DecomposeCameraTransformation( g_Camera.GetViewMatrix(), CamPosition, CamRotation );\n    vec3 isect;\n    bool R = IntersectRayToPlane( CamPosition, Pos - CamPosition, vec3( 0, 0, 1 ), 0, isect );\n```", "```java\n    g_Behaviour->m_Target = isect.ToVector2();\n  }\n}\n```", "```java\nclass clGUIPage: public clUIView\n{\npublic:\n```", "```java\n  clPtr<clGUIPage> FFallbackPage;\n```", "```java\n  clGUI* FGUI;\npublic:\n  clGUIPage(): FFallbackPage( nullptr ) {}\n  virtual ~clGUIPage() {}\n  virtual void Update( float DeltaTime ) {}\n  virtual bool OnTouch( int x, int y, bool Pressed );\n  virtual void Update( double Delta );\n  virtual void SetActive();\n```", "```java\n  virtual void OnActivation() {}\n  virtual void OnDeactivation() {}\npublic:\n  virtual bool OnKey( int Key, bool KeyState );\n};\n```", "```java\nclass clGUI: public iObject\n{\npublic:\n  clGUI(): FActivePage( NULL ), FPages() {}\n  virtual ~clGUI() {}\n```", "```java\n  void AddPage( const clPtr<clGUIPage>& P )\n  {\n    P->FGUI = this;\n    FPages.push_back( P );\n  }\n```", "```java\n  void SetActivePage( const clPtr<clGUIPage>& Page )\n  {\n    if ( Page == FActivePage ) { return; }\n```", "```java\n    if ( FActivePage )\n    {\n      FActivePage->OnDeactivation();\n    }\n```", "```java\n    if ( Page )\n    {\n      Page->OnActivation();\n    }\n    FActivePage = Page;\n  }\n```", "```java\n  void Update( float DeltaTime )\n  {\n    if ( FActivePage )\n    {\n      FActivePage->Update( DeltaTime );\n    }\n  }\n  void Render()\n  {\n    if ( FActivePage )\n    {\n      FActivePage->Render();\n    }\n  }\n  void OnKey( vec2 MousePos, int Key, bool KeyState )\n  {\n    FMousePosition = MousePos;\n    if ( FActivePage )\n    {\n      FActivePage->OnKey( Key, KeyState );\n    }\n  }\n  void OnTouch( const LVector2& Pos, bool TouchState )\n  {\n    if ( FActivePage )\n    {\n      FActivePage->OnTouch( Pos, TouchState );\n    }\n  }\nprivate:\n  vec2 FMousePosition;\n  clPtr<clGUIPage> FActivePage;\n  std::vector< clPtr<clGUIPage> > FPages;\n};\n```", "```java\nbool clGUIPage::OnKey( int Key, bool KeyState )\n{\n  if ( !KeyState && Key == LK_ESCAPE )\n  {\n```", "```java\n    if ( FFallbackPage )\n    {\n      FGUI->SetActivePage( FFallbackPage );\n      return true;\n    }\n  }\n  return false;\n}\n```", "```java\nvoid clGUIPage::SetActive()\n{\n  FGUI->SetActivePage( this );\n}\n```"]