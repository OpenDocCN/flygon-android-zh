["```java\nCFLAGS = -O2 -I src\n```", "```java\n<SourceFileName>.o:\ngcc $(CFLAGS) –c <SourceFile>.cpp –o <SourceFile>.o\n```", "```java\nObjectFiles = <SourceFile1>.o <SourceFile2>.o\n```", "```java\n<LibraryName>:\nar –rvs <LibraryName>.a $(ObjectList)\n```", "```java\n>make <LibraryName>.a\n\n```", "```java\nObjectFileList = FileName1.o \\\n                 ... \\\n                 FileNameN.o\n```", "```java\nAPP_OPTIM := release\nAPP_PLATFORM := android-19\nAPP_STL := gnustl_static\nAPP_CPPFLAGS += -frtti\nAPP_CPPFLAGS += -fexceptions\nAPP_CPPFLAGS += -DANDROID\nAPP_ABI := armeabi-v7a-hard\nAPP_MODULES := Theora\nNDK_TOOLCHAIN_VERSION := clang\n```", "```java\nTARGET_PLATFORM := android-19\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_ARM_MODE := arm\nLOCAL_MODULE := OpenAL\nLOCAL_C_INCLUDES += src\nLOCAL_SRC_FILES += <ListOfSourceFiles>\n```", "```java\nCOMMON_CFLAGS := -Werror -DANDROID\n```", "```java\nifeq ($(TARGET_ARCH),x86)\n  LOCAL_CFLAGS := $(COMMON_CFLAGS)\nelse\n  LOCAL_CFLAGS := -mfpu=vfp -mfloat-abi=hard -mhard-float -fno-short-enums -D_NDK_MATH_NO_SOFTFP=1 $(COMMON_CFLAGS)\nendif\n```", "```java\ninclude $(BUILD_STATIC_LIBRARY)\n```", "```java\ntypedef FIMEMORY* ( DLL_CALLCONV* PFNFreeImage_OpenMemory )\n  ( void*, unsigned int );\nPFNFreeImage_OpenMemory  FI_OpenMemory = nullptr;\n```", "```java\nFI_OpenMemory = (PFNFreeImage_OpenMemory)\n  GetProcAddress (hFreeImageDLL,\"FreeImage_OpenMemory\");\n```", "```java\nFI_OpenMemory = &FreeImage_OpenMemory;\n```", "```java\n--host=arm-linux CC=arm-eabi-gcc\n\n```", "```java\nCPPFLAGS=\"-I D:/NDK/system/core/include\"\n\n```", "```java\n>configure CC=arm-eabi-gcc --host=arm-linux --disable-tftp --disable-sspi --disable-ipv6 --disable-ldaps --disable-ldap --disable-telnet --disable-pop3 --disable-ftp --without-ssl --disable-imap --disable-smtp --disable-pop3 --disable-rtsp --disable-ares --without-ca-bundle --disable-warnings --disable-manual --without-nss --enable-shared --without-zlib --without-random --enable-threaded-resolver --with-ssl\n\n```", "```java\n#define CURL_CA_BUNDLE \"/etc/ssl/certs/ca-certificates.crt\"\n\n```", "```java\nCURL* Curl = curl_easy_init();\ncurl_easy_setopt( Curl, CURLOPT_URL, \"http://www.google.com\" );\ncurl_easy_setopt( Curl, CURLOPT_FOLLOWLOCATION, 1 );\ncurl_easy_setopt( Curl, CURLOPT_FAILONERROR, true );\ncurl_easy_setopt( Curl, CURLOPT_WRITEFUNCTION, &MemoryCallback );\ncurl_easy_setopt( Curl, CURLOPT_WRITEDATA, 0 );\ncurl_easy_perform( Curl );\ncurl_easy_cleanup( Curl );\n```", "```java\nsize_t MemoryCallback( void* P, size_t Size, size_t Num, void* )\n{\n  if ( !P ) return 0;\n  printf( \"%s\\n\", P );\n}\n```", "```java\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := libCurl\nLOCAL_SRC_FILES := ../../../Libs.Android/libcurl.$(TARGET_ARCH_ABI).a\ninclude $(PREBUILT_STATIC_LIBRARY)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := libCrypto\nLOCAL_SRC_FILES := ../../../Libs.Android/libCrypto.$(TARGET_ARCH_ABI).a\ninclude $(PREBUILT_STATIC_LIBRARY)\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := libSSL\nLOCAL_SRC_FILES := ../../../Libs.Android/libSSL.$(TARGET_ARCH_ABI).a\ninclude $(PREBUILT_STATIC_LIBRARY)\n```", "```java\nLOCAL_STATIC_LIBRARIES += libCurl\nLOCAL_STATIC_LIBRARIES += libSSL\nLOCAL_STATIC_LIBRARIES += libCrypto\n```", "```java\nAPP_MODULES := FreeImage\n```", "```java\nGLOBAL_CFLAGS   := -O3 -DHAVE_CONFIG_H=1 -DFREEIMAGE_LIB -DDISABLE_PERF_MEASUREMENT\n```", "```java\nbool FreeImage_LoadFromStream( void* Data,unsigned int Size,\n  std::vector<ubyte>& OutData,int& W,\n  int& H,int& BitsPerPixel,bool DoFlipV )\n{\n```", "```java\n  FIMEMORY* Mem = FI_OpenMemory(( unsigned char* )Data,\n    static_cast<unsigned int>( Size ) \n  );\n```", "```java\n  FREE_IMAGE_FORMAT FIF = FI_GetFileTypeFromMemory( Mem, 0 );\n```", "```java\n  FIBITMAP* Bitmap = FI_LoadFromMemory( FIF, Mem, 0 );\n  FI_CloseMemory( Mem );\n  FIBITMAP* ConvBitmap;\n```", "```java\n  bool FloatFormat = FI_GetBPP( Bitmap ) > 32;\n  if ( FloatFormat )\n  {\n```", "```java\n    ConvBitmap = FI_ConvertToRGBF( Bitmap );\n  }\n  else\n  {\n```", "```java\n    ConvBitmap = FI_IsTransparent( Bitmap ) ? FI_ConvertTo32Bits( Bitmap ) : FI_ConvertTo24Bits( Bitmap );\n  }\n  FI_Unload( Bitmap );\n  Bitmap = ConvBitmap;\n```", "```java\n  if ( DoFlipV ) FI_FlipVertical( Bitmap );\n```", "```java\n  W = FI_GetWidth( Bitmap );\n  H = FI_GetHeight( Bitmap );\n  BitsPP = FI_GetBPP( Bitmap );\n```", "```java\n  OutData.resize( W * H * ( BitsPerPixel / 8 ) );\n```", "```java\n  FI_ConvertToRawBits( &OutData[0],Bitmap, W * BitsPP / 8, BitsPP, 0, 1, 2, false );\n```", "```java\n  FI_Unload( Bitmap );\n  return true;\n}\n```", "```java\nbool FreeImage_SaveToMemory( const std::string& Ext,ubyte* RawBGRImage,int Width,int Height,int BitsPP,std::vector<ubyte>& OutData )\n{\n  FIBITMAP* Bitmap = FI_Allocate(Width, Height, BitsPP, 0, 0, 0);\n```", "```java\n  memcpy( FI_GetBits( Bitmap ), RawBGRImage, Width * Height * BitsPP / 8 );\n```", "```java\n  FI_FlipVertical( Bitmap );\n```", "```java\n  int OutSubFormat;\n  FREE_IMAGE_FORMAT OutFormat;\n  FileExtToFreeImageFormats( Ext, OutSubFormat, OutFormat );\n```", "```java\n  FIMEMORY* Mem = FI_OpenMemory( nullptr, 0);\n```", "```java\n  if ( !FI_SaveToMemory( OutFormat,Bitmap, Mem, OutSubFormat ) )\n  {\n    return false;\n  }\n```", "```java\n  ubyte* Data = NULL;\n  uint32_t Size = 0;\n  FI_AcquireMemory( Mem, &Data, &Size );\n```", "```java\n  OutData.resize( Size );\n  memcpy( &OutData[0], Data, Size );\n```", "```java\n  FI_CloseMemory( Mem );\n  FI_Unload( Bitmap );\n  return true;\n}\n```", "```java\nstatic void FileExtToFreeImageFormats( std::string Ext,int& OutSubFormat, FREE_IMAGE_FORMAT& OutFormat )\n{\n  OutSubFormat = TIFF_LZW;\n  OutFormat = FIF_TIFF; std::for_each( Ext.begin(), Ext.end(),[]( char& in )\n  { \n    in = ::toupper( in );\n  } \n  );\n  if ( Ext == \".PNG\" )\n  {\n    OutFormat = FIF_PNG;\n    OutSubFormat = PNG_DEFAULT;\n  }\n  else if ( Ext == \".BMP\" )\n  {\n    OutFormat = FIF_BMP;\n    OutSubFormat = BMP_DEFAULT;\n  }\n  else if ( Ext == \".JPG\" )\n  {\n    OutFormat = FIF_JPEG;\n    OutSubFormat = JPEG_QUALITYSUPERB | JPEG_BASELINE |JPEG_PROGRESSIVE | JPEG_OPTIMIZE;\n  }\n  else if ( Ext == \".EXR\" )\n  {\n    OutFormat = FIF_EXR;\n    OutSubFormat = EXR_FLOAT;\n  }\n}\n```", "```java\nbool FreeImage_LoadBitmapFromFile( const std::string& FileName, std::vector<ubyte>& OutData, int& W, int& H, int& BitsPP )\n{\n  std::ifstream InFile( FileName.c_str(),\n  std::ios::in | std::ifstream::binary );\n  std::vector<char> Data(\n    ( std::istreambuf_iterator<char>( InFile ) ), std::istreambuf_iterator<char>() );\n  return FreeImage_LoadFromStream(\n    ( ubyte* )&Data[0], ( int )data.size(),\n    OutData, W, H, BitsPP, true );\n}\n```", "```java\nstd::string ExtractExtension( const std::string& FileName )\n{\n  size_t pos = FileName.find_last_of( '.' );\n  return ( pos == std::string::npos ) ?\n    FileName : FileName.substr( pos );\n}\n```", "```java\nbool FreeImage_SaveBitmapToFile( const std::string& FileName, ubyte* ImageData, int W, int H, int BitsPP )\n{\n  std::string Ext = ExtractExtension( FileName );\n  std::vector<ubyte> OutData;\n  if ( !FreeImage_SaveToMemory( Ext, ImageData, W, H, BitsPP, OutData ) )\n  {\n    return false;\n  }\n  std::ofstream OutFile( FileName.c_str(),\n  std::ios::out | std::ofstream::binary );\n  std::copy( OutData.begin(), OutData.end(), std::ostreambuf_iterator<char>( OutFile ) );\n  return true;\n}\n```", "```java\nvoid RenderStr( const std::string& Str, int x, int y )\n{\n  for ( auto c: Str )\n  {\n    RenderChar( c, x, y );\n    x += CharW;\n  }\n}\n```", "```java\nvoid RenderChar( char c, int x, int y )\n{\n  int u = ( c % 16 ) * SlotW;\n  int v = ( c / 16 ) * SlotH;\n  for ( int y1 = 0 ; y1 < CharH ; y1++ )\n    for ( int x1 = 0 ; x1 <= CharW ; x1++ )\n      PutPixel( g_OutBitmap, W, H,\n        x + x1, y + y1,\n        GetPixel( Font, FontW, FontH,\n          x1 + u + CharW, y1 + v)\n      );\n}\n```", "```java\nint GetPixel( const std::vector<unsigned char>& Bitmap, int W, int H, int x, int y )\n{\n  if ( y >= H || x >= W || y < 0 || x < 0 ) { return 0; }\n```", "```java\n  int Ofs = ( y * W + x ) * 3;\n```", "```java\n  return (Bitmap[Ofs+0] << 16) +\n    (Bitmap[Ofs+1] <<  8) +\n    (Bitmap[Ofs+2]);\n}\n```", "```java\nvoid PutPixel( std::vector<unsigned char>& Bitmap,int W, int H, int x, int y, int Color )\n{\n  if ( y < 0 || x < 0 || y > H - 1 || x > W - 1 ) { return; }\n  int Ofs = ( y * W + x ) * 3;\n```", "```java\n  buffer[Ofs + 0] = ( Color ) & 0xFF;\n  buffer[Ofs + 1] = ( Color >> 8 ) & 0xFF;\n  buffer[Ofs + 2] = ( Color >> 16 ) & 0xFF;\n}\n```", "```java\ninline int Greyscale( unsigned char c )\n{\n  return ( (255-c) << 16 ) + ( (255-c) << 8 ) + (255-c);\n}\n```", "```java\n/// Horizontal size of the character\nconst int CharW = 32;\nconst int CharH = 64;\n/// Horizontal size of the character slot\nconst int SlotW = CharW * 2;\nconst int SlotH = CharH;\nconst int FontW = 16 * SlotW;\nconst int FontH = 16 * SlotH;\nstd::vector<unsigned char> g_FontBitmap;\n```", "```java\nvoid TestFontRendering( const std::vector<char>& Data )\n{\n  LoadFreeImage();\n  LoadFreeType();\n  FT_Library Library;\n  FT_Init_FreeTypePTR( &Library );\n  FT_Face Face;\n  FT_New_Memory_FacePTR( Library,\n    (const FT_Byte*)Data.data(),\n    (int)Data.size(), 0, &face );\n```", "```java\n  FT_Set_Char_SizePTR( Face, CharW * 64, 0, 100, 0 );\n  g_FontBitmap.resize( FontW * FontH * 3 );\n  std::fill( std::begin(g_FontBitmap), std::end(g_FontBitmap), 0xFF );\n```", "```java\n  for ( int n = 0; n < 256; n++ )\n  {\n```", "```java\n    if ( FT_Load_CharPTR( Face, n , FT_LOAD_RENDER ) )\n      continue;\n    FT_GlyphSlot Slot = Face->glyph;\n    FT_Bitmap Bitmap = Slot->bitmap;\n```", "```java\n    int x = (n % 16) * SlotW + CharW + Slot->bitmap_left;\n    int y = (n / 16) * SlotH - Slot->bitmap_top + 3*CharH/4;\n```", "```java\n    for ( int i = 0 ; i < ( int )Bitmap.width; i++ )\n    for ( int j = 0 ; j < ( int )Bitmap.rows; j++ )\n    PutPixel( g_FontBitmap, FontW, FontH,i + x, j + y,\n      Greyscale( Bitmap.buffer[j * Bitmap.width + i])\n    );\n  }\n```", "```java\n  FreeImage_SaveBitmapToFile( \"test_font.png\",\n    g_FontBitmap.data(), FontW, FontH, 24 );\n```", "```java\n  FT_Done_FacePTR    ( Face );\n  FT_Done_FreeTypePTR( Library );\n```", "```java\n  std::string Str = \"Test string\";\n  W = Str.length() * CharW;\n  H = CharH;\n  g_OutBitmap.resize( W * H * 3 );\n  std::fill( std::begin(g_OutBitmap), std::end(g_OutBitmap), 0xFF );\n```", "```java\n  RenderStr( Str, 0, 0 );\n```", "```java\n  FreeImage_SaveBitmapToFile( \"test_str.png\",\n    g_OutBitmap.data(), W, H, 24 );\n}\n```", "```java\nstd::ifstream Input( \"test.ogv\", std::ios::binary );\n```", "```java\nint Stream_Read( char* OutBuffer, int Size )\n{\n  Input.read( OutBuffer, Size );\n  return Input.gcount();\n}\n```", "```java\nint Stream_Seek( int Offset )\n{\n  Input.seekg( Offset );\n  return (int)Input.tellg();\n}\n```", "```java\nint Stream_Size()\n{\n  Input.seekg (0, input.end);\n  int Length = Input.tellg();\n  Input.seekg( 0, Input.beg );\n  return Length;\n}\n```", "```java\nogg_sync_state   OggSyncState;\nogg_page         OggPage;\nogg_stream_state VorbisStreamState;\nogg_stream_state TheoraStreamState;\n```", "```java\nth_info          TheoraInfo;\nth_comment       TheoraComment;\nth_setup_info*   TheoraSetup;\nth_dec_ctx*      TheoraDecoder;\n```", "```java\nvorbis_info      VorbisInfo;\nvorbis_dsp_state VorbisDSPState;\nvorbis_comment   VorbisComment;\nvorbis_block     VorbisBlock;\n```", "```java\nbool Theora_Load()\n{\n  Stream_Seek( 0 );\n```", "```java\n  ogg_packet TempOggPacket;\n```", "```java\n  memset( &VorbisStreamState, 0, sizeof( ogg_stream_state ) );\n  memset( &TheoraStreamState, 0, sizeof( ogg_stream_state ) );\n  memset( &OggSyncState,   0, sizeof( ogg_sync_state ) );\n  memset( &OggPage,        0, sizeof( ogg_page ) );\n  memset( &TheoraInfo,     0, sizeof( th_info ) );\n  memset( &TheoraComment,  0, sizeof( th_comment ) );\n  memset( &VorbisInfo,     0, sizeof( vorbis_info ) );\n  memset( &VorbisDSPState, 0, sizeof( vorbis_dsp_state ) );\n  memset( &VorbisBlock,    0, sizeof( vorbis_block ) );\n  memset( &VorbisComment,  0, sizeof( vorbis_comment ) );\n  OGG_sync_init   ( &OggSyncState );\n  TH_comment_init ( &TheoraComment );\n  TH_info_init    ( &TheoraInfo );\n  VORBIS_info_init( &VorbisInfo );\n  VORBIS_comment_init( &VorbisComment );\n```", "```java\n  bool Done = false;\n  while ( !Done )\n  {\n    char* Buffer = OGG_sync_buffer( &OggSyncState, 4096 );\n    int BytesRead = ( int )Stream_Read( Buffer, 4096 );\n    OGG_sync_wrote( &OggSyncState, BytesRead );\n    if ( BytesRead == 0 )\n    {\n      break;\n    }\n    while (OGG_sync_pageout( &OggSyncState, &OggPage ) > 0)\n    {\n```", "```java\n      ogg_stream_state OggStateTest;\n      if ( !OGG_page_bos( &OggPage ) )\n      {\n        if ( NumTheoraStreams > 0 )\n        {\n          OGG_stream_pagein( &TheoraStreamState, &OggPage );\n        }\n        if ( NumVorbisStreams > 0 )\n          {\n            OGG_stream_pagein( VorbisStreamState, &OggPage );\n          }\n          Done = true;\n          break;\n        }\n        OGG_stream_init( &OggStateTest,\n        OGG_page_serialno( &OggPage ) );\n        OGG_stream_pagein( &OggStateTest, &OggPage );\n        OGG_stream_packetout( &OggStateTest, &TempOggPacket );\n```", "```java\n        if ( NumTheoraStreams == 0 )\n        {\n          int Ret = TH_decode_headerin( &TheoraInfo, &TheoraComment, &TheoraSetup, &TempOggPacket );\n          if ( Ret > 0 )\n          {\n```", "```java\n            memcpy( &TheoraStreamState, &OggStateTest, sizeof( OggStateTest ) );\n            NumTheoraStreams = 1;\n            continue;\n          }\n        }\n        if ( NumVorbisStreams == 0 )\n        {\n          int Ret = VORBIS_synthesis_headerin( &VorbisInfo, &VorbisComment, &TempOggPacket );\n          if ( Ret >= 0 )\n          {\n```", "```java\n            memcpy( &VorbisStreamState, &OggStateTest, sizeof( OggStateTest ) );\n            NumVorbisStreams = 1;\n            continue;\n          }\n        }\n```", "```java\n        OGG_stream_clear( &OggStateTest );\n      }\n    }\n```", "```java\n    while((( NumTheoraStreams > 0 ) && ( NumTheoraStreams < 3 )) || (( NumVorbisStreams > 0 ) && ( NumVorbisStreams < 3 )))\n    {\n      int Success = 0;\n```", "```java\n      while (( NumTheoraStreams > 0 ) &&\n        ( NumTheoraStreams < 3 ) &&\n        ( Success = OGG_stream_packetout( &TheoraStreamState, &TempOggPacket ) ) )\n      {\n        if ( Success < 0 ) return false;\n        if ( !TH_decode_headerin( &TheoraInfo, &TheoraComment, &TheoraSetup, &TempOggPacket ) ) return false;\n        ++NumTheoraStreams;\n      }\n```", "```java\n      while ( NumVorbisStreams < 3 && ( Success = OGG_stream_packetout( &VorbisStreamState, &TempOggPacket ) ) )\n      {\n        if ( Success < 0 ) return false;\n        if ( VORBIS_synthesis_headerin( &VorbisInfo, &VorbisComment, &TempOggPacket ) )\n        return false;\n        ++NumVorbisStreams;\n      }\n```", "```java\n      if ( OGG_sync_pageout( &OggSyncState, &OggPage ) > 0 )\n      {\n        if ( NumTheoraStreams > 0 )\n        {\n          OGG_stream_pagein( &TheoraStreamState, &OggPage );\n        }\n        if ( NumVorbisStreams > 0 )\n        {\n          OGG_stream_pagein( &VorbisStreamState, &OggPage );\n        }\n      }\n      else\n      {\n        char* Buffer = OGG_sync_buffer( &OggSyncState, 4096 );\n        int BytesRead = (int)Stream_Read( Buffer, 4096 );\n        OGG_sync_wrote( &OggSyncState, BytesRead );\n        if ( BytesRead == 0 ) return false;\n      }\n    }\n```", "```java\n    TheoraDecoder = TH_decode_alloc( &TheoraInfo, TheoraSetup );\n    Width  = TheoraInfo.frame_width;\n    Height = TheoraInfo.frame_height;\n    return true;\n  }\n```", "```java\n  void Theora_Cleanup()\n  {\n    if ( TheoraDecoder )\n    {\n      TH_decode_free( TheoraDecoder );\n      TH_setup_free( TheoraSetup );\n      VORBIS_dsp_clear( &VorbisDSPState );\n      VORBIS_block_clear( &VorbisBlock );\n      OGG_stream_clear( &TheoraStreamState );\n      TH_comment_clear( &TheoraComment );\n      TH_info_clear( &TheoraInfo );\n      OGG_stream_clear( &VorbisStreamState );\n      VORBIS_comment_clear( &VorbisComment );\n      VORBIS_info_clear( &VorbisInfo );\n      OGG_sync_clear( &OggSyncState );\n    }\n  }\n```", "```java\nTARGET_PLATFORM := android-19\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\nLOCAL_ARM_MODE := arm\nLOCAL_MODULE := OpenAL\nLOCAL_C_INCLUDES := $(LOCAL_PATH) $(LOCAL_PATH)/../include $(LOCAL_PATH)/../OpenAL32/Include\nLOCAL_SRC_FILES  := ../OpenAL32/alAuxEffectSlot.c \\\n                    ../OpenAL32/alBuffer.c \\\n                    ../OpenAL32/alDatabuffer.c \\\n                    ../OpenAL32/alEffect.c \\\n                    ../OpenAL32/alError.c \\\n                    ../OpenAL32/alExtension.c \\\n                    ../OpenAL32/alFilter.c \\\n                    ../OpenAL32/alListener.c \\\n                    ../OpenAL32/alSource.c \\\n                    ../OpenAL32/alState.c \\\n                    ../OpenAL32/alThunk.c \\\n                    ../Alc/ALc.c \\\n                    ../Alc/alcConfig.c \\\n                    ../Alc/alcEcho.c \\\n                    ../Alc/alcModulator.c \\\n                    ../Alc/alcReverb.c \\\n                    ../Alc/alcRing.c \\\n                    ../Alc/alcThread.c \\\n                    ../Alc/ALu.c \\\n                    ../Alc/android.c \\\n                    ../Alc/bs2b.c \\\n                    ../Alc/null.c\n```", "```java\nGLOBAL_CFLAGS := -O3 -DAL_BUILD_LIBRARY -DAL_ALEXT_PROTOTYPES -DHAVE_ANDROID=1\n```", "```java\nifeq ($(TARGET_ARCH),x86)\n  LOCAL_CFLAGS := $(GLOBAL_CFLAGS)\nelse\n  LOCAL_CFLAGS := -mfpu=vfp -mfloat-abi=hard -mhard-float -fno-short-enums -D_NDK_MATH_NO_SOFTFP=1 $(GLOBAL_CFLAGS)\nendif\ninclude $(BUILD_STATIC_LIBRARY)\n```", "```java\nAPP_OPTIM := release\nAPP_PLATFORM := android-19\nAPP_STL := gnustl_static\nAPP_CPPFLAGS += -frtti\nAPP_CPPFLAGS += -fexceptions\nAPP_CPPFLAGS += -DANDROID\nAPP_MODULES := OpenAL\nAPP_ABI := armeabi-v7a-hard x86\nNDK_TOOLCHAIN_VERSION := clang\n```", "```java\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := libFreeImage\nLOCAL_SRC_FILES :=../../../Libs.Android/libFreeImage.$(TARGET_ARCH_ABI).a\ninclude $(PREBUILT_STATIC_LIBRARY)\n```", "```java\nLOCAL_STATIC_LIBRARIES += FreeImage\ninclude $(BUILD_SHARED_LIBRARY)\n```"]