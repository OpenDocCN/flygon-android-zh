- en: Chapter 2. Native Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to build popular C/C++ libraries and link
    them against your applications using Android NDK. These libraries are building
    blocks to implement feature-rich applications with images, videos, sounds, physical
    simulations, and networking entirely in C++. We will provide minimal samples to
    demonstrate the functionality of each library. Audio and networking libraries
    are discussed in greater detail in the subsequent chapters. We will show you how
    to compile libraries and, of course, give some short samples and hints on how
    to start using them.
  prefs: []
  type: TYPE_NORMAL
- en: Typical caveats for porting libraries across different processors and operating
    systems are memory access (structure alignment and padding), byte order (endianness),
    calling conventions, and floating-point issues. All the libraries described in
    the preceding sections address these issues quite well, and even if some of them
    do not officially support Android NDK, fixing this is just a matter of a few compiler
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: To build the mentioned libraries, we need to create makefiles for Windows, Linux,
    and OS X and a pair of the `Android.mk/Application.mk` files for the NDK. The
    source files of the library are compiled to object files. A collection of object
    files is combined into an archive, which is also called a static library. Later,
    this static library can be passed as an input to the linker. We start with the
    desktop versions, first for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: To build the Windows-specific version of libraries, we need a C++ compiler.
    We will use the command line compiler from MinGW with the GCC toolchain described
    in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Using Command-line Tools"),
    *Using Command-line Tools*. For each library, we have a collection of source code
    files, and we need to get the static library, a file with the `.a` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with precompiled static libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s put the source code of a library we need to build for different platforms
    into the `src` directory. The Makefile script should start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This line defines a variable `CFLAGS` with a list of compiler command-line
    parameters. In our case, we instruct the compiler to search the `src` directory
    for header files. If the library source code spans across multiple directories,
    we need to add the `–I` switch for each of the directories. The `-O2` switch tells
    the compiler to enable level 2 optimizations. Next, we add the following lines
    for each source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The string `<SourceFileName>` should be replaced with the actual name of the
    `.cpp` source file, and these lines should be written for each of the source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we add the list of object files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will write the target for our library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Every line in the Makefile script except the empty lines and the names of the
    targets should start with a tabulation character. To build the library, invoke
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When using the library in our programs, we pass the `LibraryName.a` file as
    a parameter to `gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: Makefiles consist of targets similar to subroutines in programming languages,
    and usually each target results in an object file being generated. For example,
    we have seen that each source file of the library gets compiled into the corresponding
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: Target names may include the filename pattern to avoid copying and pasting,
    but in the simplest case, we just list all the source files and duplicate those
    lines replacing the `SourceFileName` strings by the appropriate file names. The
    `–c` switch after the `gcc` command is the option to compile the source file,
    and `–o` specifies the name of the output object file. The `$(CFLAGS)` symbol
    denotes the substitution of the value of the `CFLAGS` variable into the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The GCC toolchain for Windows includes the `ar` tool, which is an abbreviation
    for an archiver. Makefiles for our libraries invoke this tool to create a static
    version of the library. This is done in the last lines of the Makefile script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a line with a list of object files becomes too long, it can be split into
    multiple lines using the backslash symbol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no spaces after the backslash, since it is a limitation of
    the `make` tool. The `make` tool is portable, hence the same rules apply exactly
    to all desktop operating systems we use: Windows, Linux, and OS X.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are able to build most of the libraries using Makefiles and the command
    line. Let''s build them for Android. First, create a folder named `jni` and create
    the `jni/Application.mk` file with the appropriate compiler switches and set the
    name of the library accordingly. For example, one for the Theora library should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will use `armeabi-v7a-hard` as one of the most widely supported modern
    ABIs. The Android NDK supports many other architectures and CPUs. Refer to the
    NDK Programmer's Guide for a complete up-to-date list.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will use the latest version of the Clang compiler available in the installed
    NDK. The `jni/Android.mk` file is similar to the one we wrote in the previous
    chapter for the `3_NDK` sample application, yet with a few exceptions. At the
    top of the file, some required variables must be defined. Let''s see how the `Android.mk`
    file for the OpenAL-Soft library might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define some common compiler options: treat all warnings as errors (`-Werror`),
    the `ANDROID` preprocessing symbol is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation flags are defined according to the selected CPU architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In all our examples, we will use the hardware floating point ABI `armeabi-v7a-hard`,
    so let's build the libraries accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The major difference between armeabi-v7a-hard and armeabi-v7a is that the hardware
    floating point ABI does passing of the floating point function arguments inside
    FPU registers. In floating point heavy applications, this can drastically increase
    the performance of the code where floating point values are passed to and from
    different functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are building a static library, we need the following line at the end
    of `Android.mk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Building the static library now requires a single call to the `ndk-build` script.
    Let's proceed to the compilation of actual libraries after a small remark on dynamic
    linking and Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic linking on Windows platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libraries considered in this chapter can be built for Windows as dynamic
    link libraries. We do not provide recipes for doing this because each project
    already contains all the necessary instructions, and Windows development is not
    the focus of this book. The only exception is the libcurl and OpenSSL libraries.
    We recommend that you download the prebuilt DLL files from the official library
    site.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code for FreeImage, FreeType, and Theora, we use function pointers,
    which are initialized using the `GetProcAddress()` and `LoadLibrary()` functions
    from WinAPI. The same function pointers are used on Android, but in this case,
    they point to appropriate functions from a static library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the function `FreeImage_OpenMemory()` is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, we initialize the pointer with the `GetProcAddress()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On Android, OSX, and Linux, it is a redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The example code only refers to `FI_OpenMemory()`, and thus, is the same for
    both Android and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Curl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libcurl library [http://curl.haxx.se/libcurl](http://curl.haxx.se/libcurl)
    is a free and easy to use client-side URL transfer library. It is a de facto standard
    for native applications, which deal with numerous networking protocols. Linux
    and OS X users enjoy having the library on their system, and a possibility to
    link against it using the `-lcurl` switch. Compilation of libcurl for Android
    on a Windows host requires some additional steps to be done. We explain them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The libcurl library build process is based on `autoconf`; we will need to generate
    the `curl_config.h` file before actually building the library. Run the configure
    script from the folder containing the unpacked libcurl distribution package. Cross-compilation
    command-line flags should be set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-I` parameter of the `CPPFLAGS` variable should point to the `/system/core/include`
    subfolder of your NDK folder, in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The libcurl library can be customized in many ways. We use this set of parameters
    (disable all protocols except HTTP and HTTPS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--with-ssl` parameter enables the usage of OpenSSL library to provide
    secure HTTPS transfers. This library will be discussed further in this chapter.
    However, in order to work with SSL-encrypted connections, we need to tell libcurl
    where our system certificates are located. This can be done with `CURL_CA_BUNDLE`
    defined in the beginning of the `curl_config.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The configure script will generate a valid `curl_config.h` header file. You
    may find it in the book''s source code bundle. Compilation of an Android static
    library requires a usual set of `Android.mk` and `Application.mk` files, which
    is also within the `1_Curl` example. In the next chapter, we will learn how to
    use the libcurl library to download the actual content from Internet over HTTPS.
    However, here is a simplistic usage example to retrieve a HTTP page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `MemoryCallback()` is a function that handles the received data. It can
    be as tiny as the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The retrieved data will be printed on the screen in your desktop application.
    The same code will work like a dummy in Android, without producing any visible
    side effects, since the `printf()` function is just a dummy there.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSSL is an open source library implementing the Secure Sockets Layer (SSL
    v2/v3) and Transport Layer Security (TLS) protocols as well as a full-strength
    general purpose cryptography library. It can be found at [https://www.openssl.org](https://www.openssl.org).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will build the OpenSSL Version 1.0.1j, which contains a fix for the
    Heartbleed Bug([http://heartbleed.com](http://heartbleed.com)).
  prefs: []
  type: TYPE_NORMAL
- en: The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic
    software library. This weakness allows stealing the information that is protected,
    under normal conditions, by the SSL/TLS encryption used to secure the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to statically link your application against an old version of OpenSSL
    and then publish it on Google Play, you may see the following security alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenSSL](img/image00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is possible that by the time this book is published, even the version 1.0.0j
    of OpenSSL will be outdated. Hence, it would be a great exercise for you to download
    the most recent source code and update NDK Makefiles accordingly. Here is a brief
    glimpse of how you can do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSL is compiled as two interoperating static libraries: `libssl` and `libcrypto`.
    Check out the source code bundle and look into the folders `2_OpenSSL/lib/crypto/jni`
    and `2_OpenSSL/ssl/jni`. Both libraries should be linked against your application
    which uses SSL-enabled version of libcurl.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical `Android.mk` for this can start as in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this file, just link all the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is it, you can now deal with SSL connections.
  prefs: []
  type: TYPE_NORMAL
- en: FreeImage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FreeImage is a popular library for bitmap manipulation, Unity gaming engine
    is among the users of this library ([http://freeimage.sourceforge.net/users.html](http://freeimage.sourceforge.net/users.html)).
    The library is an all-in-one wrapper on top of `libpng`, `libjpeg`, `libtiff,`
    and many others, providing fast image loading routines without falling back to
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'FreeImage includes a complete set of Makefiles for different platforms. The
    compilation of the library for Android is straightforward with the instructions
    from *Dealing with precompiled static libraries* section. The `Application.mk`
    file differs from the same file for Curl in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Android.mk` file, we will change the C compilation flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the following sample, we will implement two simple routines to load and save
    images in various file formats to and from memory blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `FreeImage_LoadFromMemory()` routine, which takes the `Data`
    array and its `Size` as input parameters and decodes this array into a `std::vector<char>`
    containing bitmap''s pixels. Dimensions information, width and height, is stored
    in the `W` and `H` parameters. Color depth information is put into the `BitsPerPixel`
    parameter. An optional `DoFlipV` parameter instructs the code to flip the loaded
    image vertically, this can be required when dealing with images storing conventions
    in different graphics APIs, top-down or bottom-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the internal memory block, which can be read by FreeImage routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Before reading the bitmap, we will detect its format (for example, `.jpg`,
    `.bmp`, `.png`, and others) in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the decoded bitmap is read into the temporary `FIBITMAP` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the total number of bits is more than 32, for example, each color channel
    occupies more than 8 bits, we most likely have the floating-point image, which
    will require some additional processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Floating point images are not used throughout this book, but it is useful to
    know FreeImage supports high dynamic range images in the OpenEXR format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenEXR format is notable for supporting 16-bit-per-channel floating point values
    and can be used in games to store textures for different HDR effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A transparency information is used to convert the image. If the image is not
    transparent, the alpha channel is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If necessary, we do the vertical flipping of the image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The image dimensions and color information are extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know the dimensions, we can resize the output buffer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, we can fetch the raw unaligned bitmap data to our `OutData` vector.
    The size of a single tightly packed scanline is `W*BitsPP/8` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The temporary bitmap object is deleted and function returns gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The bitmap saving routine can be implemented in a similar way. First, we allocate
    the FIBITMAP structure to represent our image within the FreeImage library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Raw bitmap data is copied into the FIBITMAP structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'FreeImage uses the inverted vertical scanline order, so we should flip the
    image vertically before saving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use the user-specified file extension to detect the format of
    the output image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the image, we will allocate a dynamic memory block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FI_SaveToMemory()` call encodes our raw bitmap into the compressed representation
    according to the selected format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After encoding, we will get direct access to the FreeImage memory block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will copy bytes to our `OutData` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Some cleanup is required. We delete the memory block and the FIBITMAP structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The auxiliary `FileExtToFreeImageFormats()` function converts the file extension
    to the internal FreeImage format specifier and provides a number of options. The
    code is straightforward. We will compare the provided file extension to a number
    of predefined values and fill the `FIF_FORMAT` and `SAVE_OPTIONS` structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This can be extended and customized further in your own way.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and saving images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the preceding code usable, we add two more routines that save and load
    images from disk files. The first one, `FreeImage_LoadBitmapFromFile()`, loads
    the bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a simple function to extract the file extension, which serves as a file
    type tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FreeImage_SaveBitmapToFile()` function saves the file using the standard
    `std::ofstream` stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This code is enough to cover all the basic use cases of the image loading library.
  prefs: []
  type: TYPE_NORMAL
- en: FreeType
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FreeType library is a de facto standard to render high-quality text using
    TrueType fonts. Since text output is almost inevitable in any graphical program,
    we give an example how to render a text string using a fixed-size font generated
    from the monospace TrueType file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the fixed-size font in the `16x16` grid. The source font for this
    demo application is named `Receptional Receipt` and was downloaded from [http://1001freefonts.com](http://1001freefonts.com).
    Four lines of the resulting `16x16` grid are shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FreeType](img/image00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A single character occupies a rectangular region, which we will call a *slot*.
    The coordinates of the character''s rectangle are calculated using the character''s
    ASCII code. Each slot in a grid occupies the `SlotW x SlotH` pixels, and the character
    itself is centered and has the size of `CharW x CharH` pixels. For demonstration
    purposes, we simply assume `SlotW` is two times the size of `CharW`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FreeType](img/image00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We limit ourselves to the simplest possible usage scenario: 8-bit ASCII characters,
    fixed-size character glyphs. To render the string, we will iterate its characters
    and call the yet-to-be-written function `RenderChar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The character rendering routine is a simple double loop copying the glyph pixels
    into the output image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PutPixel()` and `GetPixel()` routines set and get the pixel in the bitmap
    respectively. Each pixel is in the 24-bit RGB format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a scanline width is assumed to be equal to the image width, and the number
    of color components in the RGB triplet is 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use bitwise shifts to construct the resulting RGB value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Bitwise shifts and masks do the extraction job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another auxiliary function `Greyscale()`, which calculates the RGB
    gray color for a given intensity using bitwise shifts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding code, we do not require FreeType. We really need the library
    only to generate the font. We will load the font data file, render its glyphs
    for the first 256 characters, and then use the resulting font bitmap to render
    the text string. The first part of the code generates a font. We will use a few
    of the variables to store the dimensions of the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the font in a standard vector, which we can pass to the `TestFontRendering()`
    routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Fix the character size at 100 dpi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will render 256 ASCII characters one by one in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the glyph image into the slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The coordinates of the top left corner of the rectangle for each character
    are calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The glyph of the character is copied to the `g_FontBitmap` bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We save the resulting `Font` bitmap to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of font bitmap generation, we will clear everything associated with
    the FreeType library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize our monospace font, we will declare the string, calculate its width
    in screen pixels, and allocate the output bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The end of the `TestFontRendering()` routine just calls `RenderStr()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It then saves the resulting image to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FreeType](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Usually when it comes to bitmap font rendering, you don't want to write the
    code for bitmap generation yourself. It is advised that you use third-party tools
    to do it. One of such free tools is AngelCode, which can be found at [http://www.angelcode.com/products/bmfont](http://www.angelcode.com/products/bmfont).
    It can pack the glyphs inside the bitmap in an optimal way and produce the required
    data to handle the generated bitmap properly.
  prefs: []
  type: TYPE_NORMAL
- en: Theora
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Theora is a free and open video compression format from the Xiph.Org Foundation.
    Like all our multimedia technology, it can be used to distribute movies and video
    online and on-disc without the licensing and royalty fees or any other vendor
    lock-ins associated with many other video formats. It is available at [http://www.theora.org](http://www.theora.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid confusion, we will introduce some nomenclature. By **bitstream**,
    we assume some sequence of bytes. Logical bitstream is some representation of
    video or audio data. **Codec**, or COder-DECoder, is a set of functions that encodes
    and decodes logical bitstreams into a set of compact representations named packed
    bitstreams. Since usual multimedia data consists of multiple logical bitstreams,
    the compact representation must be split into small chunks, which are called packets.
    Each **packet** has a specific size, a timestamp and a checksum associated with
    it to guarantee the packet integrity. The scheme for bitstreams and packets is
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theora](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Packets for logical and packed bitstreams are intermixed to form a linear sequence
    maintaining the order of packets for each individual bitstream. This is called
    multiplexing. The Ogg library reads the `.ogg` file and splits it into packed
    bitstreams. Each of bitstreams can be decoded using Theora, Vorbis, or other decoders.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our previous book, *Android NDK Game Development Cookbook*, *Packt Publishing*
    ([https://www.packtpub.com/game-development/android-ndk-game-development-cookbook](https://www.packtpub.com/game-development/android-ndk-game-development-cookbook)),
    we taught by example how to decode Ogg Vorbis audio streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we address only the simplest problem of extracting media information
    from the file. The code for even this simple operation may seem long and complicated.
    However, it can be described in less than ten steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the OGG stream reader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a packet building loop: read a bunch of bytes from the source file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if there is enough data to emit another logical packet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the new packet is formed, check whether it is a `BoS` (Beginning of Stream)
    packet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to initialize the Theora or Vorbis decoder with the `BoS` packet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we don't have enough audio and video streams to decode, go to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we don't have enough stream information, continue reading secondary stream
    packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the Theora decoder and extract video frame information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another level of complexity in Ogg streams, because packets are grouped
    to form logical pages. In the preceding pseudocode, we refer to packets that are
    actually pages. Nevertheless, the scheme remains the same: read bytes until there
    is enough data for the decoder to emit another video frame or, in our case, to
    read the video information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use standard C++ I/O streams and implement three simple functions: `Stream_Read()`,
    `Stream_Seek()`, and `Stream_Size()`. Later in the [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual Filesystem*,
    we will reimplement these methods using our own I/O abstraction layer. Let''s
    open the file stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a function to read the specified number of bytes from the input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Seek to the desired position using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the file size use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, some variables should be declared to store the state of the
    decoding process, a synchronization object, the current page, and audio and video
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The Theora decoder state :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vorbis decoder state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `Theora_Load()` reads the file header and extracts video frame
    information from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The current Ogg packet will be read into the structure `TempOggPacket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Some simple yet necessary initialization of the state variables has to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We start reading the file and use the `Done` flag to terminate if the file
    has ended or we have enough data to get the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When we finally encounter a complete packet, we will check whether it is a
    `BOS` marker, and output the data to one of the decoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use two variables, `NumTheoraStreams` and `NumVorbisStreams`, to count
    video and audio streams, respectively. In the following lines, we will feed the
    Ogg packet to both decoders and see if the decoders do not complain about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here goes the Theora header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the Vorbis header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need just the Theora stream information, ignore other codecs and drop
    the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code basically just counts the number of streams, and we should
    be done by now. If there is still not enough streams, we will continue reading
    and checking secondary stream headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We will read all available packets and check if it is the beginning of a new
    Theora stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same manner, we will look for the beginning of the next Vorbis stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of the long `while (!Done)` loop is to check for packets with
    the actual frame data, or to read more bytes from the stream if the next packet
    is not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have found all stream headers and we are ready to initialize the
    Theora decoder. After doing so, we fetch the frame width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we clear internal structures of the codec to avoid memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This is it, we have read video parameters. We will return to audio and video
    decoding and playback in the following chapters, once we have some basic graphics
    and audio rendering capabilities in place.
  prefs: []
  type: TYPE_NORMAL
- en: The code more complex but similar to our example is heavily used inside the
    `LibTheoraPlayer` library source code available at [http://libtheoraplayer.cateia.com](http://libtheoraplayer.cateia.com).
  prefs: []
  type: TYPE_NORMAL
- en: In the example for this chapter, we will use capitalized function names to distinguish
    dynamic library usage and static linking. If you want to link the `ogg`, `vorbis`,
    and `theora` libraries statically, you may do so by renaming each `OGG` function
    prefix to `ogg`. That is it; just replace uppercase letters by lowercase ones.
  prefs: []
  type: TYPE_NORMAL
- en: For sample Theora video content, we will refer to the official website, [http://www.theora.org/content](http://www.theora.org/content),
    where you can download `.ogv` files.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenAL is a cross-platform audio API. It is designed for efficient rendering
    of multichannel three-dimensional positional audio and is widely used on desktop
    platforms in numerous gaming engines and applications. Many mobile platforms provide
    different audio APIs, for example, OpenSL ES is a strong player. However, when
    portability is at stake, we should select an API capable of running on all platforms
    required. OpenAL is implemented on Windows, Linux, OS X, Android, iOS, BlackBerry
    10 and on many other platforms. On all these operating systems, except Windows
    and Android, OpenAL is a first person citizen with all libraries available in
    the system. On Windows, there is an implementation from Creative. On Android,
    we need to build the library ourself. We will use the Martins Mozeiko port [http://pielot.org/2010/12/14/openal-on-android/](http://pielot.org/2010/12/14/openal-on-android/).
    This library can be compiled for Android with minor tweaking of `Android.mk` and
    `Application.mk` files. Here is the `Android.mk` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-D` definition are required for correct compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'And this `if`-block is a way to separate ARM and x86 compiler switches when
    you want to build an x86 version of the library for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Application.mk` file is standard and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: For your convenience, we have all the source code and configuration files in
    the `6_OpenAL` example. Furthermore, all the libraries we use in this book are
    precompiled for Android, you can find them in the `Libs.Android` folder within
    the book's source code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the libraries to your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one more thing left to discuss in this chapter before we proceed to
    further topics. Indeed, we learned how to build the libraries, but not how to
    link your Android application against them. For this purpose, we need to modify
    the `Android.mk` file of your application. Let''s take a look at the `3_FreeImage_Example`
    sample and its `Application.mk`. It starts with the declaration of the prebuilt
    static library pointing to a binary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `$(TARGET_ARCH_ABI)` variable in the path to transparently
    handle `armeabi-v7a-hard` and `x86` versions of the libraries. You can add yet
    more architectures with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the library is declared, let''s link the application against it. Take
    a look at the bottom of `Application.mk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `LOCAL_STATIC_LIBRARIES` variable contains all the required libraries. The
    prefix `lib` can be omitted for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deal with precompiled static libraries on
    Android, same also applies to OS X and Linux, and how to do dynamic linking on
    Windows without breaking multiplatform capabilities of our code. We learned how
    to build `libcurl` and `OpenSSL`, so you can access SSL connections from your
    C++ code. A couple of examples for FreeImage and FreeType shows how to load and
    save images with raster fonts. The example with libtheora was quite comprehensive;
    however, the result was modest, we just read meta-information from a video file.
    OpenAL will be used as a backbone of our audio subsystem.
  prefs: []
  type: TYPE_NORMAL
