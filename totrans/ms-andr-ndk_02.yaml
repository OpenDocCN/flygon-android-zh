- en: Chapter 2. Native Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.本地库
- en: In this chapter, you will learn how to build popular C/C++ libraries and link
    them against your applications using Android NDK. These libraries are building
    blocks to implement feature-rich applications with images, videos, sounds, physical
    simulations, and networking entirely in C++. We will provide minimal samples to
    demonstrate the functionality of each library. Audio and networking libraries
    are discussed in greater detail in the subsequent chapters. We will show you how
    to compile libraries and, of course, give some short samples and hints on how
    to start using them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Android NDK构建流行的C/C++库，并将它们链接到你的应用程序中。这些库是实现图像、视频、声音、物理模拟和完全在C++中网络功能的丰富功能应用程序的构建块。我们将提供最小示例来演示每个库的功能。音频和网络库将在后续章节中详细讨论。我们将向你展示如何编译库，当然也会提供一些简短的示例和如何开始使用它们的提示。
- en: Typical caveats for porting libraries across different processors and operating
    systems are memory access (structure alignment and padding), byte order (endianness),
    calling conventions, and floating-point issues. All the libraries described in
    the preceding sections address these issues quite well, and even if some of them
    do not officially support Android NDK, fixing this is just a matter of a few compiler
    switches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同处理器和操作系统间移植库的典型陷阱包括内存访问（结构对齐和填充）、字节序（大小端）、调用约定和浮点问题。前面章节中描述的所有库都很好地解决了这些问题，即使其中一些库没有正式支持Android
    NDK，修复这些问题也只是几个编译器开关的问题。
- en: To build the mentioned libraries, we need to create makefiles for Windows, Linux,
    and OS X and a pair of the `Android.mk/Application.mk` files for the NDK. The
    source files of the library are compiled to object files. A collection of object
    files is combined into an archive, which is also called a static library. Later,
    this static library can be passed as an input to the linker. We start with the
    desktop versions, first for Windows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建上述库，我们需要为Windows、Linux和OS X创建makefile，并为NDK创建一对`Android.mk/Application.mk`文件。库的源文件被编译成目标文件。一系列目标文件组合成一个档案，这也称为静态库。之后，这个静态库可以作为链接器的输入。我们从桌面版本开始，首先为Windows。
- en: To build the Windows-specific version of libraries, we need a C++ compiler.
    We will use the command line compiler from MinGW with the GCC toolchain described
    in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Using Command-line Tools"),
    *Using Command-line Tools*. For each library, we have a collection of source code
    files, and we need to get the static library, a file with the `.a` extension.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建特定于Windows的库版本，我们需要一个C++编译器。我们将使用来自MinGW的GCC工具链，该工具链在[第一章](part0014.xhtml#aid-DB7S1
    "第一章.使用命令行工具")，*使用命令行工具*中描述。对于每个库，我们有一系列源代码文件，我们需要得到静态库，一个带有`.a`扩展名的文件。
- en: Dealing with precompiled static libraries
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理预编译的静态库
- en: 'Let''s put the source code of a library we need to build for different platforms
    into the `src` directory. The Makefile script should start as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们需要的库在不同平台构建的源代码放入`src`目录中。Makefile脚本应该如下开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line defines a variable `CFLAGS` with a list of compiler command-line
    parameters. In our case, we instruct the compiler to search the `src` directory
    for header files. If the library source code spans across multiple directories,
    we need to add the `–I` switch for each of the directories. The `-O2` switch tells
    the compiler to enable level 2 optimizations. Next, we add the following lines
    for each source file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这行定义了一个变量`CFLAGS`，其中包含编译器命令行参数的列表。在我们的例子中，我们指示编译器在`src`目录中查找头文件。如果库源代码跨越多个目录，我们需要为每个目录添加`–I`开关。`-O2`开关告诉编译器启用2级优化。接下来，我们为每个源文件添加以下行：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The string `<SourceFileName>` should be replaced with the actual name of the
    `.cpp` source file, and these lines should be written for each of the source files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`<SourceFileName>`应该被替换为实际的`.cpp`源文件名，并且这些行应该针对每个源文件编写。
- en: 'Now, we add the list of object files:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加目标文件列表：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we will write the target for our library:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写我们库的目标：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Every line in the Makefile script except the empty lines and the names of the
    targets should start with a tabulation character. To build the library, invoke
    the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile脚本中除了空行和目标名称以外的每一行都应该以制表符开头。要构建库，请调用以下命令：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When using the library in our programs, we pass the `LibraryName.a` file as
    a parameter to `gcc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当在我们的程序中使用库时，我们将`LibraryName.a`文件作为参数传递给`gcc`。
- en: Makefiles consist of targets similar to subroutines in programming languages,
    and usually each target results in an object file being generated. For example,
    we have seen that each source file of the library gets compiled into the corresponding
    object file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile由类似于编程语言中子例程的目标组成，通常每个目标都会生成一个目标文件。例如，我们已经看到，库的每个源文件都编译成相应的目标文件。
- en: Target names may include the filename pattern to avoid copying and pasting,
    but in the simplest case, we just list all the source files and duplicate those
    lines replacing the `SourceFileName` strings by the appropriate file names. The
    `–c` switch after the `gcc` command is the option to compile the source file,
    and `–o` specifies the name of the output object file. The `$(CFLAGS)` symbol
    denotes the substitution of the value of the `CFLAGS` variable into the command
    line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称可能包括文件名模式以避免复制粘贴，但在最简单的情况下，我们只需列出所有源文件，并复制这些行，将`SourceFileName`字符串替换为适当的文件名。`gcc`命令后的`–c`开关是编译源文件的选项，而`–o`指定输出目标文件的名字。`$(CFLAGS)`符号表示将`CFLAGS`变量的值代入命令行。
- en: The GCC toolchain for Windows includes the `ar` tool, which is an abbreviation
    for an archiver. Makefiles for our libraries invoke this tool to create a static
    version of the library. This is done in the last lines of the Makefile script.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的GCC工具链包括`ar`工具，它是归档器的缩写。我们库的Makefile调用此工具来创建库的静态版本。这将在Makefile脚本的最后几行完成。
- en: 'When a line with a list of object files becomes too long, it can be split into
    multiple lines using the backslash symbol as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当带有目标文件列表的一行变得过长时，可以使用反斜杠符号将其分成多行，如下所示：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There should be no spaces after the backslash, since it is a limitation of
    the `make` tool. The `make` tool is portable, hence the same rules apply exactly
    to all desktop operating systems we use: Windows, Linux, and OS X.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠后面不应该有空白，因为这是`make`工具的限制。`make`工具是可移植的，因此同样的规则精确适用于我们使用的所有桌面操作系统：Windows、Linux和OS
    X。
- en: 'Now, we are able to build most of the libraries using Makefiles and the command
    line. Let''s build them for Android. First, create a folder named `jni` and create
    the `jni/Application.mk` file with the appropriate compiler switches and set the
    name of the library accordingly. For example, one for the Theora library should
    look like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够使用Makefiles和命令行构建大多数库。让我们为Android构建它们。首先，创建一个名为`jni`的文件夹，并创建一个`jni/Application.mk`文件，其中包含适当的编译器开关并相应地设置库的名称。例如，Theora库的一个应该如下所示：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we will use `armeabi-v7a-hard` as one of the most widely supported modern
    ABIs. The Android NDK supports many other architectures and CPUs. Refer to the
    NDK Programmer's Guide for a complete up-to-date list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`armeabi-v7a-hard`作为支持最广泛的现代ABI之一。Android NDK支持许多其他架构和CPU。请参考NDK程序员指南以获取完整且最新的列表。
- en: 'It will use the latest version of the Clang compiler available in the installed
    NDK. The `jni/Android.mk` file is similar to the one we wrote in the previous
    chapter for the `3_NDK` sample application, yet with a few exceptions. At the
    top of the file, some required variables must be defined. Let''s see how the `Android.mk`
    file for the OpenAL-Soft library might look:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用安装的NDK中可用的最新版本的Clang编译器。`jni/Android.mk`文件与我们之前章节为`3_NDK`示例应用程序编写的文件类似，但有一些例外。在文件顶部，必须定义一些必要的变量。让我们看看OpenAL-Soft库的`Android.mk`文件可能的样子：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define some common compiler options: treat all warnings as errors (`-Werror`),
    the `ANDROID` preprocessing symbol is defined:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一些常见的编译器选项：将所有警告视为错误（`-Werror`），定义`ANDROID`预处理符号：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The compilation flags are defined according to the selected CPU architecture:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编译标志根据选定的CPU架构定义：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In all our examples, we will use the hardware floating point ABI `armeabi-v7a-hard`,
    so let's build the libraries accordingly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的示例中，我们将使用硬件浮点ABI `armeabi-v7a-hard`，因此让我们相应地构建库。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The major difference between armeabi-v7a-hard and armeabi-v7a is that the hardware
    floating point ABI does passing of the floating point function arguments inside
    FPU registers. In floating point heavy applications, this can drastically increase
    the performance of the code where floating point values are passed to and from
    different functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: armeabi-v7a-hard和armeabi-v7a之间的主要区别在于，硬件浮点ABI在FPU寄存器内部传递浮点函数参数。在浮点密集型应用程序中，这可以显著提高代码的性能，其中浮点值在不同的函数之间传递。
- en: 'Since we are building a static library, we need the following line at the end
    of `Android.mk`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建静态库，我们需要在`Android.mk`文件末尾添加以下行：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Building the static library now requires a single call to the `ndk-build` script.
    Let's proceed to the compilation of actual libraries after a small remark on dynamic
    linking and Windows platform.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建静态库只需调用一次`ndk-build`脚本。在对动态链接和Windows平台做一点简短的说明之后，我们继续编译实际的库。
- en: Dynamic linking on Windows platform
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows平台上的动态链接
- en: The libraries considered in this chapter can be built for Windows as dynamic
    link libraries. We do not provide recipes for doing this because each project
    already contains all the necessary instructions, and Windows development is not
    the focus of this book. The only exception is the libcurl and OpenSSL libraries.
    We recommend that you download the prebuilt DLL files from the official library
    site.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章考虑的库可以作为Windows的动态链接库进行构建。我们不提供这样做的方法，因为每个项目已经包含了所有必要的说明，而且Windows开发不是本书的重点。唯一的例外是libcurl和OpenSSL库。我们建议您从官方库网站下载预构建的DLL文件。
- en: In the example code for FreeImage, FreeType, and Theora, we use function pointers,
    which are initialized using the `GetProcAddress()` and `LoadLibrary()` functions
    from WinAPI. The same function pointers are used on Android, but in this case,
    they point to appropriate functions from a static library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeImage、FreeType和Theora的示例代码中，我们使用函数指针，这些指针使用WinAPI的`GetProcAddress()`和`LoadLibrary()`函数进行初始化。在Android上使用相同的函数指针，但在这种情况下，它们指向静态库中的相应函数。
- en: 'For example, the function `FreeImage_OpenMemory()` is declared as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数`FreeImage_OpenMemory()`声明如下：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On Windows, we initialize the pointer with the `GetProcAddress()` call:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们使用`GetProcAddress()`调用来初始化指针：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Android, OSX, and Linux, it is a redirection:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android、OSX和Linux上，这是一个重定向：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The example code only refers to `FI_OpenMemory()`, and thus, is the same for
    both Android and Windows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码仅引用了`FI_OpenMemory()`，因此对于Android和Windows来说是一样的。
- en: Curl
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Curl
- en: The libcurl library [http://curl.haxx.se/libcurl](http://curl.haxx.se/libcurl)
    is a free and easy to use client-side URL transfer library. It is a de facto standard
    for native applications, which deal with numerous networking protocols. Linux
    and OS X users enjoy having the library on their system, and a possibility to
    link against it using the `-lcurl` switch. Compilation of libcurl for Android
    on a Windows host requires some additional steps to be done. We explain them here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl库[http://curl.haxx.se/libcurl](http://curl.haxx.se/libcurl)是一个免费且易于使用的客户端URL传输库。它是处理众多网络协议的本机应用程序的实际标准。Linux和OS
    X用户可以在他们的系统上享受这个库，并且可以使用`-lcurl`开关与之链接。在Windows主机上为Android编译libcurl需要执行一些额外的步骤，我们在这里解释这些步骤。
- en: 'The libcurl library build process is based on `autoconf`; we will need to generate
    the `curl_config.h` file before actually building the library. Run the configure
    script from the folder containing the unpacked libcurl distribution package. Cross-compilation
    command-line flags should be set to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl库的构建过程基于`autoconf`；在实际构建库之前，我们需要生成`curl_config.h`文件。从包含未打包的libcurl发行包的文件夹中运行配置脚本。交叉编译命令行标志应设置为：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `-I` parameter of the `CPPFLAGS` variable should point to the `/system/core/include`
    subfolder of your NDK folder, in our case:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CPPFLAGS`变量的`-I`参数应指向NDK文件夹中的`/system/core/include`子文件夹，在我们的例子中：'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The libcurl library can be customized in many ways. We use this set of parameters
    (disable all protocols except HTTP and HTTPS):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl库可以通过多种方式进行定制。我们使用以下这组参数（除了HTTP和HTTPS之外禁用所有协议）：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `--with-ssl` parameter enables the usage of OpenSSL library to provide
    secure HTTPS transfers. This library will be discussed further in this chapter.
    However, in order to work with SSL-encrypted connections, we need to tell libcurl
    where our system certificates are located. This can be done with `CURL_CA_BUNDLE`
    defined in the beginning of the `curl_config.h` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`--with-ssl`参数允许使用OpenSSL库来提供安全的HTTPS传输。这个库将在本章进一步讨论。然而，为了处理SSL加密连接，我们需要告诉libcurl我们的系统证书位于何处。这可以在`curl_config.h`文件开头通过定义`CURL_CA_BUNDLE`来完成：'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The configure script will generate a valid `curl_config.h` header file. You
    may find it in the book''s source code bundle. Compilation of an Android static
    library requires a usual set of `Android.mk` and `Application.mk` files, which
    is also within the `1_Curl` example. In the next chapter, we will learn how to
    use the libcurl library to download the actual content from Internet over HTTPS.
    However, here is a simplistic usage example to retrieve a HTTP page:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本将生成一个有效的`curl_config.h`头文件。你可以在书的源代码包中找到它。编译Android静态库需要一个通常的`Android.mk`和`Application.mk`文件集，这也包含在`1_Curl`示例中。在下一章，我们将学习如何使用libcurl库通过HTTPS从互联网下载实际内容。然而，以下是一个简化使用示例来检索HTTP页面：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here `MemoryCallback()` is a function that handles the received data. It can
    be as tiny as the following code fragment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`MemoryCallback()`是一个处理接收到的数据的函数。它可以小到像下面的代码片段：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The retrieved data will be printed on the screen in your desktop application.
    The same code will work like a dummy in Android, without producing any visible
    side effects, since the `printf()` function is just a dummy there.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 检索到的数据将在你的桌面应用程序上显示在屏幕上。同样的代码在Android中会像哑巴一样工作，不会产生任何可见的副作用，因为`printf()`函数在那里只是一个占位符。
- en: OpenSSL
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL
- en: OpenSSL is an open source library implementing the Secure Sockets Layer (SSL
    v2/v3) and Transport Layer Security (TLS) protocols as well as a full-strength
    general purpose cryptography library. It can be found at [https://www.openssl.org](https://www.openssl.org).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL是一个开源库，实现了安全套接字层（SSL v2/v3）和传输层安全（TLS）协议，以及一个功能强大的通用加密库。可以在[https://www.openssl.org](https://www.openssl.org)找到它。
- en: Here, we will build the OpenSSL Version 1.0.1j, which contains a fix for the
    Heartbleed Bug([http://heartbleed.com](http://heartbleed.com)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将构建OpenSSL版本1.0.1j，其中包含对Heartbleed漏洞的修复([http://heartbleed.com](http://heartbleed.com))。
- en: The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic
    software library. This weakness allows stealing the information that is protected,
    under normal conditions, by the SSL/TLS encryption used to secure the Internet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed漏洞是流行的OpenSSL加密软件库中一个严重的安全漏洞。这个弱点使得在正常情况下受SSL/TLS加密保护的信息可以被窃取，而这种加密被用于确保互联网的安全。
- en: 'If you try to statically link your application against an old version of OpenSSL
    and then publish it on Google Play, you may see the following security alert:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将应用程序静态链接到一个旧版本的OpenSSL，并在Google Play上发布，你可能会看到以下安全警报：
- en: '![OpenSSL](img/image00216.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![OpenSSL](img/image00216.jpeg)'
- en: It is possible that by the time this book is published, even the version 1.0.0j
    of OpenSSL will be outdated. Hence, it would be a great exercise for you to download
    the most recent source code and update NDK Makefiles accordingly. Here is a brief
    glimpse of how you can do it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书出版时，即使是OpenSSL的1.0.0j版本也可能已经过时了。因此，下载最新的源代码并相应地更新NDK Makefile对你来说将是一个很好的练习。以下是如何进行的一个简要概述。
- en: 'OpenSSL is compiled as two interoperating static libraries: `libssl` and `libcrypto`.
    Check out the source code bundle and look into the folders `2_OpenSSL/lib/crypto/jni`
    and `2_OpenSSL/ssl/jni`. Both libraries should be linked against your application
    which uses SSL-enabled version of libcurl.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL被编译为两个相互协作的静态库：`libssl`和`libcrypto`。查看源代码包，并查看文件夹`2_OpenSSL/lib/crypto/jni`和`2_OpenSSL/ssl/jni`。这两个库都应该被链接到使用带有SSL功能的libcurl版本的应用程序中。
- en: 'Typical `Android.mk` for this can start as in the following listing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为此准备的`Android.mk`文件可以像下面的列表这样开始：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the end of this file, just link all the libraries:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件的最后，只需链接所有的库：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is it, you can now deal with SSL connections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你现在可以处理SSL连接了。
- en: FreeImage
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeImage
- en: FreeImage is a popular library for bitmap manipulation, Unity gaming engine
    is among the users of this library ([http://freeimage.sourceforge.net/users.html](http://freeimage.sourceforge.net/users.html)).
    The library is an all-in-one wrapper on top of `libpng`, `libjpeg`, `libtiff,`
    and many others, providing fast image loading routines without falling back to
    Java code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: FreeImage 是一个流行的位图操作库，Unity 游戏引擎是该库的用户之一（[http://freeimage.sourceforge.net/users.html](http://freeimage.sourceforge.net/users.html)）。该库是
    `libpng`、`libjpeg`、`libtiff` 等之上的全功能封装，提供了快速图像加载例程，无需回退到 Java 代码。
- en: 'FreeImage includes a complete set of Makefiles for different platforms. The
    compilation of the library for Android is straightforward with the instructions
    from *Dealing with precompiled static libraries* section. The `Application.mk`
    file differs from the same file for Curl in one line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: FreeImage 包含一套完整的 Makefiles，适用于不同的平台。按照 *处理预编译静态库* 部分的说明，编译 Android 的库非常直接。`Application.mk`
    文件与 Curl 的同名文件在一行上有所不同：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `Android.mk` file, we will change the C compilation flags:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Android.mk` 文件中，我们将更改 C 编译标志：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the following sample, we will implement two simple routines to load and save
    images in various file formats to and from memory blocks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将实现两个简单的例程，以在各种文件格式中从内存块加载和保存图像。
- en: 'We start with the `FreeImage_LoadFromMemory()` routine, which takes the `Data`
    array and its `Size` as input parameters and decodes this array into a `std::vector<char>`
    containing bitmap''s pixels. Dimensions information, width and height, is stored
    in the `W` and `H` parameters. Color depth information is put into the `BitsPerPixel`
    parameter. An optional `DoFlipV` parameter instructs the code to flip the loaded
    image vertically, this can be required when dealing with images storing conventions
    in different graphics APIs, top-down or bottom-up:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `FreeImage_LoadFromMemory()` 例程开始，它接收 `Data` 数组和其 `Size` 作为输入参数，并将这个数组解码成一个包含位图像素的
    `std::vector<char>`。尺寸信息，宽度和高度，存储在 `W` 和 `H` 参数中。颜色深度信息被放入 `BitsPerPixel` 参数中。可选的
    `DoFlipV` 参数指示代码垂直翻转加载的图像，这在与不同图形 API 的图像存储约定（从上到下或从下到上）打交道时可能需要：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create the internal memory block, which can be read by FreeImage routines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建内部内存块，它可以被 FreeImage 例程读取。
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before reading the bitmap, we will detect its format (for example, `.jpg`,
    `.bmp`, `.png`, and others) in the following way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取位图之前，我们将以以下方式检测其格式（例如，`.jpg`、`.bmp`、`.png` 等）：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the decoded bitmap is read into the temporary `FIBITMAP` structure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，解码后的位图被读取到临时的 `FIBITMAP` 结构中：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the total number of bits is more than 32, for example, each color channel
    occupies more than 8 bits, we most likely have the floating-point image, which
    will require some additional processing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总位数超过32位，例如，每个颜色通道占用超过8位，我们很可能处理的是浮点数图像，这将需要一些额外的处理：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Floating point images are not used throughout this book, but it is useful to
    know FreeImage supports high dynamic range images in the OpenEXR format.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并未广泛使用浮点数图像，但了解 FreeImage 支持 OpenEXR 格式下的高动态范围图像是有用的。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenEXR format is notable for supporting 16-bit-per-channel floating point values
    and can be used in games to store textures for different HDR effect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEXR 格式以支持每个通道16位的浮点数值而著称，并可用于游戏中存储不同 HDR 效果的纹理。
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A transparency information is used to convert the image. If the image is not
    transparent, the alpha channel is ignored:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用透明度信息来转换图像。如果图像不是透明的，则忽略 alpha 通道：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If necessary, we do the vertical flipping of the image, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，我们以下列方式对图像进行垂直翻转：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The image dimensions and color information are extracted:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提取图像尺寸和颜色信息：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we know the dimensions, we can resize the output buffer, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道尺寸，我们可以调整输出缓冲区的大小，如下所示：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At last, we can fetch the raw unaligned bitmap data to our `OutData` vector.
    The size of a single tightly packed scanline is `W*BitsPP/8` bytes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将原始未对齐的位图数据提取到我们的 `OutData` 向量中。每行紧密排列的数据大小为 `W*BitsPP/8` 字节：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The temporary bitmap object is deleted and function returns gracefully:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 临时位图对象被删除，函数优雅地返回：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The bitmap saving routine can be implemented in a similar way. First, we allocate
    the FIBITMAP structure to represent our image within the FreeImage library:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 位图保存例程可以以类似的方式实现。首先，我们在 FreeImage 库中分配 FIBITMAP 结构来表示我们的图像：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Raw bitmap data is copied into the FIBITMAP structure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 原始位图数据被复制到 FIBITMAP 结构中：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'FreeImage uses the inverted vertical scanline order, so we should flip the
    image vertically before saving:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: FreeImage使用倒置的垂直扫描线顺序，因此在保存之前我们应该垂直翻转图像：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we will use the user-specified file extension to detect the format of
    the output image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用用户指定的文件扩展名来检测输出图像的格式：
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To save the image, we will allocate a dynamic memory block:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存图像，我们将分配一个动态内存块：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `FI_SaveToMemory()` call encodes our raw bitmap into the compressed representation
    according to the selected format:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FI_SaveToMemory()`调用根据选定的格式将我们的原始位图编码成压缩表示形式：'
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After encoding, we will get direct access to the FreeImage memory block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编码后，我们将直接访问FreeImage内存块：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we will copy bytes to our `OutData` vector:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将字节复制到我们的`OutData`向量中：
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Some cleanup is required. We delete the memory block and the FIBITMAP structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行一些清理。我们删除内存块和FIBITMAP结构：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The auxiliary `FileExtToFreeImageFormats()` function converts the file extension
    to the internal FreeImage format specifier and provides a number of options. The
    code is straightforward. We will compare the provided file extension to a number
    of predefined values and fill the `FIF_FORMAT` and `SAVE_OPTIONS` structures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助的`FileExtToFreeImageFormats()`函数将文件扩展名转换为内部的FreeImage格式说明符，并提供多个选项。代码很直观。我们将提供的文件扩展名与多个预定义值进行比较，并填充`FIF_FORMAT`和`SAVE_OPTIONS`结构：
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This can be extended and customized further in your own way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以根据您的需要进行扩展和自定义。
- en: Loading and saving images
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存图像
- en: 'To make the preceding code usable, we add two more routines that save and load
    images from disk files. The first one, `FreeImage_LoadBitmapFromFile()`, loads
    the bitmap:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码可用，我们添加了两个更多例程，它们从磁盘文件中保存和加载图像。第一个，`FreeImage_LoadBitmapFromFile()`，加载位图：
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We use a simple function to extract the file extension, which serves as a file
    type tag:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个简单的函数来提取文件扩展名，它作为文件类型标签：
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `FreeImage_SaveBitmapToFile()` function saves the file using the standard
    `std::ofstream` stream:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`FreeImage_SaveBitmapToFile()`函数使用标准的`std::ofstream`流保存文件：'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code is enough to cover all the basic use cases of the image loading library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码足以涵盖图像加载库的所有基本使用情况。
- en: FreeType
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeType
- en: The FreeType library is a de facto standard to render high-quality text using
    TrueType fonts. Since text output is almost inevitable in any graphical program,
    we give an example how to render a text string using a fixed-size font generated
    from the monospace TrueType file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: FreeType库是一个事实上的标准，用于使用TrueType字体渲染高质量文本。由于在几乎任何图形程序中输出文本都是不可避免的，我们给出一个如何使用从等宽TrueType文件生成的固定大小字体来渲染文本字符串的例子。
- en: 'We store the fixed-size font in the `16x16` grid. The source font for this
    demo application is named `Receptional Receipt` and was downloaded from [http://1001freefonts.com](http://1001freefonts.com).
    Four lines of the resulting `16x16` grid are shown in the following image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将固定大小字体存储在`16x16`网格中。此演示应用程序的源字体名为`Receptional Receipt`，从[http://1001freefonts.com](http://1001freefonts.com)下载。以下图像显示了结果`16x16`网格的四行：
- en: '![FreeType](img/image00217.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![FreeType](img/image00217.jpeg)'
- en: 'A single character occupies a rectangular region, which we will call a *slot*.
    The coordinates of the character''s rectangle are calculated using the character''s
    ASCII code. Each slot in a grid occupies the `SlotW x SlotH` pixels, and the character
    itself is centered and has the size of `CharW x CharH` pixels. For demonstration
    purposes, we simply assume `SlotW` is two times the size of `CharW`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单个字符占用一个矩形区域，我们将这个区域称为*槽*。字符矩形的坐标是使用字符的ASCII码计算的。网格中的每个槽占用`SlotW x SlotH`像素，字符本身居中，大小为`CharW
    x CharH`像素。为了演示，我们简单假设`SlotW`是`CharW`大小的两倍：
- en: '![FreeType](img/image00218.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![FreeType](img/image00218.jpeg)'
- en: 'We limit ourselves to the simplest possible usage scenario: 8-bit ASCII characters,
    fixed-size character glyphs. To render the string, we will iterate its characters
    and call the yet-to-be-written function `RenderChar()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们限制自己使用最简单的可能使用场景：8位ASCII字符，固定大小的字符字形。为了渲染字符串，我们将遍历其字符并调用尚未编写的`RenderChar()`函数：
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The character rendering routine is a simple double loop copying the glyph pixels
    into the output image:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字符渲染例程是一个简单的双循环，将字形像素复制到输出图像中：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `PutPixel()` and `GetPixel()` routines set and get the pixel in the bitmap
    respectively. Each pixel is in the 24-bit RGB format:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`PutPixel()`和`GetPixel()`例程分别设置和获取位图中的像素。每个像素都是24位RGB格式：'
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, a scanline width is assumed to be equal to the image width, and the number
    of color components in the RGB triplet is 3:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，假设扫描线的宽度等于图像宽度，RGB三元组的颜色分量数量为3：
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use bitwise shifts to construct the resulting RGB value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位运算移位来构建结果的RGB值：
- en: '[PRE53]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Bitwise shifts and masks do the extraction job:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算移位和掩码完成了提取工作：
- en: '[PRE55]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There is another auxiliary function `Greyscale()`, which calculates the RGB
    gray color for a given intensity using bitwise shifts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个辅助函数`Greyscale()`，它使用位运算移位为给定的强度计算RGB灰度颜色：
- en: '[PRE56]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For the preceding code, we do not require FreeType. We really need the library
    only to generate the font. We will load the font data file, render its glyphs
    for the first 256 characters, and then use the resulting font bitmap to render
    the text string. The first part of the code generates a font. We will use a few
    of the variables to store the dimensions of the font:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的代码，我们并不需要FreeType。我们真正只需要该库来生成字体。我们将加载字体数据文件，为其前256个字符渲染字形，然后使用生成的字体位图来渲染文本字符串。代码的第一部分生成字体。我们将使用几个变量来存储字体的尺寸：
- en: '[PRE57]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We store the font in a standard vector, which we can pass to the `TestFontRendering()`
    routine:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字体存储在一个标准向量中，可以传递给`TestFontRendering()`例程：
- en: '[PRE58]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Fix the character size at 100 dpi:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符大小固定在100 dpi：
- en: '[PRE59]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will render 256 ASCII characters one by one in a loop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在循环中逐个渲染256个ASCII字符：
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Load the glyph image into the slot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将字形图像加载到槽中：
- en: '[PRE61]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The coordinates of the top left corner of the rectangle for each character
    are calculated:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个字符的矩形左上角的坐标：
- en: '[PRE62]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The glyph of the character is copied to the `g_FontBitmap` bitmap:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 字符的笔形被复制到`g_FontBitmap`位图中：
- en: '[PRE63]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We save the resulting `Font` bitmap to a file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成的`Font`位图保存到文件中：
- en: '[PRE64]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At the end of font bitmap generation, we will clear everything associated with
    the FreeType library:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在字体位图生成结束时，我们将清除与FreeType库相关的所有内容：
- en: '[PRE65]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To utilize our monospace font, we will declare the string, calculate its width
    in screen pixels, and allocate the output bitmap:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的等宽字体，我们将声明字符串，计算其在屏幕像素中的宽度，并分配输出位图：
- en: '[PRE66]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The end of the `TestFontRendering()` routine just calls `RenderStr()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestFontRendering()`例程的末尾只是调用了`RenderStr()`：'
- en: '[PRE67]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It then saves the resulting image to a file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将生成的图像保存到文件中：
- en: '[PRE68]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The result should look as in the following image:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下图像：
- en: '![FreeType](img/image00219.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![FreeType](img/image00219.jpeg)'
- en: Usually when it comes to bitmap font rendering, you don't want to write the
    code for bitmap generation yourself. It is advised that you use third-party tools
    to do it. One of such free tools is AngelCode, which can be found at [http://www.angelcode.com/products/bmfont](http://www.angelcode.com/products/bmfont).
    It can pack the glyphs inside the bitmap in an optimal way and produce the required
    data to handle the generated bitmap properly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在位图字体渲染方面，你不想自己编写位图生成的代码。建议您使用第三方工具来完成这项工作。这样一款免费工具是AngelCode，可以在[http://www.angelcode.com/products/bmfont](http://www.angelcode.com/products/bmfont)找到。它可以以最优的方式将字形打包到位图中，并生成处理生成的位图所需的数据。
- en: Theora
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Theora（注：此处Theora为一种视频压缩格式的名称，不翻译）
- en: Theora is a free and open video compression format from the Xiph.Org Foundation.
    Like all our multimedia technology, it can be used to distribute movies and video
    online and on-disc without the licensing and royalty fees or any other vendor
    lock-ins associated with many other video formats. It is available at [http://www.theora.org](http://www.theora.org).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Theora是来自Xiph.Org基金会的一个免费且开源的视频压缩格式。与我们的所有多媒体技术一样，它可以用来在线和光盘上分发电影和视频，而无需像许多其他视频格式那样支付许可和版税费用，或受到任何其他供应商的锁定。它可以在[http://www.theora.org](http://www.theora.org)获取。
- en: 'To avoid confusion, we will introduce some nomenclature. By **bitstream**,
    we assume some sequence of bytes. Logical bitstream is some representation of
    video or audio data. **Codec**, or COder-DECoder, is a set of functions that encodes
    and decodes logical bitstreams into a set of compact representations named packed
    bitstreams. Since usual multimedia data consists of multiple logical bitstreams,
    the compact representation must be split into small chunks, which are called packets.
    Each **packet** has a specific size, a timestamp and a checksum associated with
    it to guarantee the packet integrity. The scheme for bitstreams and packets is
    shown in the following image:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们将介绍一些术语。我们所说的**比特流**是指一些字节的序列。逻辑比特流是对视频或音频数据的某种表示。**编解码器**，或编码器-解码器，是一组将逻辑比特流编码和解码成一组名为打包比特流的紧凑表示的函数。由于通常的多媒体数据包含多个逻辑比特流，紧凑表示必须被分割成小块，这些小块被称为包。每个**包**都有一个特定的尺寸、时间戳和与之相关的校验和，以保证包的完整性。比特流和包的方案在以下图像中显示：
- en: '![Theora](img/image00220.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Theora](img/image00220.jpeg)'
- en: Packets for logical and packed bitstreams are intermixed to form a linear sequence
    maintaining the order of packets for each individual bitstream. This is called
    multiplexing. The Ogg library reads the `.ogg` file and splits it into packed
    bitstreams. Each of bitstreams can be decoded using Theora, Vorbis, or other decoders.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑包和打包比特流的包相互混合，形成一个线性序列，保持每个独立比特流的包的顺序。这称为复用。Ogg库读取`.ogg`文件并将其分割成打包比特流。每个比特流都可以使用Theora、Vorbis或其他解码器进行解码。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our previous book, *Android NDK Game Development Cookbook*, *Packt Publishing*
    ([https://www.packtpub.com/game-development/android-ndk-game-development-cookbook](https://www.packtpub.com/game-development/android-ndk-game-development-cookbook)),
    we taught by example how to decode Ogg Vorbis audio streams.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的书籍中，*Android NDK Game Development Cookbook*，*Packt Publishing* ([https://www.packtpub.com/game-development/android-ndk-game-development-cookbook](https://www.packtpub.com/game-development/android-ndk-game-development-cookbook))，我们通过示例教大家如何解码Ogg
    Vorbis音频流。
- en: 'In this chapter, we address only the simplest problem of extracting media information
    from the file. The code for even this simple operation may seem long and complicated.
    However, it can be described in less than ten steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只解决了从文件中提取媒体信息的最简单问题。即使这个简单的操作的代码可能看起来又长又复杂。然而，它可以用不到十个步骤来描述：
- en: Initialize the OGG stream reader.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化OGG流读取器。
- en: 'Start a packet building loop: read a bunch of bytes from the source file.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个包构建循环：从源文件中读取一堆字节。
- en: Check if there is enough data to emit another logical packet.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有足够的数据来生成另一个逻辑包。
- en: If the new packet is formed, check whether it is a `BoS` (Beginning of Stream)
    packet.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果形成了新的包，检查它是否是`BoS`（流开始）包。
- en: Try to initialize the Theora or Vorbis decoder with the `BoS` packet.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`BoS`包初始化Theora或Vorbis解码器。
- en: If we don't have enough audio and video streams to decode, go to step 2.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有足够的音频和视频流来解码，请转到步骤2。
- en: If we don't have enough stream information, continue reading secondary stream
    packets.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有足够的流信息，继续读取次要流包。
- en: Initialize the Theora decoder and extract video frame information.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化Theora解码器并提取视频帧信息。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is another level of complexity in Ogg streams, because packets are grouped
    to form logical pages. In the preceding pseudocode, we refer to packets that are
    actually pages. Nevertheless, the scheme remains the same: read bytes until there
    is enough data for the decoder to emit another video frame or, in our case, to
    read the video information.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ogg流还有一个复杂性级别，因为包被分组形成逻辑页。在前面的伪代码中，我们指的是实际上是页面的包。尽管如此，方案保持不变：读取字节，直到有足够的数据让解码器生成另一个视频帧，或者在我们的情况下，读取视频信息。
- en: 'We use standard C++ I/O streams and implement three simple functions: `Stream_Read()`,
    `Stream_Seek()`, and `Stream_Size()`. Later in the [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual Filesystem*,
    we will reimplement these methods using our own I/O abstraction layer. Let''s
    open the file stream:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标准的C++ I/O流并实现了三个简单的函数：`Stream_Read()`、`Stream_Seek()`和`Stream_Size()`。在后面的[第4章](part0043.xhtml#aid-190861
    "第4章. 组织虚拟文件系统")，*组织虚拟文件系统*中，我们将使用自己的I/O抽象层重新实现这些方法。让我们打开文件流：
- en: '[PRE69]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here is a function to read the specified number of bytes from the input stream:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从输入流中读取指定字节数的函数：
- en: '[PRE70]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Seek to the desired position using the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码寻找指定位置：
- en: '[PRE71]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To determine the file size use the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定文件大小，请使用以下代码：
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'At the beginning, some variables should be declared to store the state of the
    decoding process, a synchronization object, the current page, and audio and video
    streams:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该声明一些变量来存储解码过程的状态、同步对象、当前页面以及音频和视频流：
- en: '[PRE73]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The Theora decoder state :'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Theora解码器状态：
- en: '[PRE74]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The Vorbis decoder state:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Vorbis解码器状态：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The function `Theora_Load()` reads the file header and extracts video frame
    information from it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`Theora_Load()`读取文件头并从中提取视频帧信息：
- en: '[PRE76]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The current Ogg packet will be read into the structure `TempOggPacket`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Ogg包将被读取到`TempOggPacket`结构中：
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Some simple yet necessary initialization of the state variables has to be done:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对一些简单但必要的状态变量进行初始化：
- en: '[PRE78]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We start reading the file and use the `Done` flag to terminate if the file
    has ended or we have enough data to get the information:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始读取文件，并使用`Done`标志在文件结束或我们有足够的数据获取信息时终止：
- en: '[PRE79]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When we finally encounter a complete packet, we will check whether it is a
    `BOS` marker, and output the data to one of the decoders:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终遇到一个完整的包时，我们将检查它是否是`BOS`标记，并将数据输出到其中一个解码器：
- en: '[PRE80]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We will use two variables, `NumTheoraStreams` and `NumVorbisStreams`, to count
    video and audio streams, respectively. In the following lines, we will feed the
    Ogg packet to both decoders and see if the decoders do not complain about it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个变量`NumTheoraStreams`和`NumVorbisStreams`分别计算视频和音频流的数量。在以下几行中，我们将Ogg包提供给两个解码器，并查看解码器是否对此有异议：
- en: '[PRE81]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here goes the Theora header:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Theora头信息：
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is the Vorbis header:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Vorbis头：
- en: '[PRE83]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Since we need just the Theora stream information, ignore other codecs and drop
    the header:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只需要Theora流信息，所以忽略其他编解码器并丢弃头信息：
- en: '[PRE84]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding code basically just counts the number of streams, and we should
    be done by now. If there is still not enough streams, we will continue reading
    and checking secondary stream headers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码基本上只是计算了流的数量，现在我们应该已经完成了。如果流的数量仍然不足，我们将继续读取并检查次级流头：
- en: '[PRE85]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We will read all available packets and check if it is the beginning of a new
    Theora stream:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取所有可用的包，并检查它是否是一个新的Theora流的开始：
- en: '[PRE86]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the same manner, we will look for the beginning of the next Vorbis stream:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法，我们将寻找下一个Vorbis流的开始：
- en: '[PRE87]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The final part of the long `while (!Done)` loop is to check for packets with
    the actual frame data, or to read more bytes from the stream if the next packet
    is not available:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`while (!Done)`循环的最后一步是检查具有实际帧数据的包，或者如果下一个包不可用，从流中读取更多字节：'
- en: '[PRE88]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'So far, we have found all stream headers and we are ready to initialize the
    Theora decoder. After doing so, we fetch the frame width and height:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经找到了所有的流头，并准备好初始化Theora解码器。初始化后，我们获取帧宽和帧高：
- en: '[PRE89]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the end, we clear internal structures of the codec to avoid memory leaks:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清除编解码器的内部结构以避免内存泄漏：
- en: '[PRE90]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is it, we have read video parameters. We will return to audio and video
    decoding and playback in the following chapters, once we have some basic graphics
    and audio rendering capabilities in place.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经读取了视频参数。在接下来的章节中，一旦我们有了基本的图形和音频渲染能力，我们将回到音频和视频的解码和播放。
- en: The code more complex but similar to our example is heavily used inside the
    `LibTheoraPlayer` library source code available at [http://libtheoraplayer.cateia.com](http://libtheoraplayer.cateia.com).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更为复杂，但与我们的示例非常相似，它被广泛用于`LibTheoraPlayer`库源代码中，该代码可在[http://libtheoraplayer.cateia.com](http://libtheoraplayer.cateia.com)获取。
- en: In the example for this chapter, we will use capitalized function names to distinguish
    dynamic library usage and static linking. If you want to link the `ogg`, `vorbis`,
    and `theora` libraries statically, you may do so by renaming each `OGG` function
    prefix to `ogg`. That is it; just replace uppercase letters by lowercase ones.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将使用大写的函数名称来区分动态库使用和静态链接。如果您想静态链接`ogg`、`vorbis`和`theora`库，可以通过将每个`OGG`函数前缀重命名为`ogg`来实现。就是这样，只需将大写字母替换为小写字母。
- en: For sample Theora video content, we will refer to the official website, [http://www.theora.org/content](http://www.theora.org/content),
    where you can download `.ogv` files.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于示例Theora视频内容，我们将参考官方网站，[http://www.theora.org/content](http://www.theora.org/content)，您可以在那里下载`.ogv`文件。
- en: OpenAL
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAL
- en: 'OpenAL is a cross-platform audio API. It is designed for efficient rendering
    of multichannel three-dimensional positional audio and is widely used on desktop
    platforms in numerous gaming engines and applications. Many mobile platforms provide
    different audio APIs, for example, OpenSL ES is a strong player. However, when
    portability is at stake, we should select an API capable of running on all platforms
    required. OpenAL is implemented on Windows, Linux, OS X, Android, iOS, BlackBerry
    10 and on many other platforms. On all these operating systems, except Windows
    and Android, OpenAL is a first person citizen with all libraries available in
    the system. On Windows, there is an implementation from Creative. On Android,
    we need to build the library ourself. We will use the Martins Mozeiko port [http://pielot.org/2010/12/14/openal-on-android/](http://pielot.org/2010/12/14/openal-on-android/).
    This library can be compiled for Android with minor tweaking of `Android.mk` and
    `Application.mk` files. Here is the `Android.mk` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAL是一个跨平台的音频API。它旨在高效地渲染多通道三维定位音频，并在许多桌面平台的众多游戏引擎和应用程序中广泛使用。许多移动平台提供了不同的音频API，例如，OpenSL
    ES是一个强有力的竞争者。但是，当可移植性受到威胁时，我们应该选择一个能够在所有所需平台上运行的API。OpenAL在Windows、Linux、OS X、Android、iOS、BlackBerry
    10以及许多其他平台上都有实现。在所有这些操作系统中，除了Windows和Android，OpenAL都是一等公民，所有库在系统中都可用。在Windows上，有一个来自Creative的实现。在Android上，我们需要自己构建库。我们将使用
    Martins Mozeiko 的移植版本[http://pielot.org/2010/12/14/openal-on-android/](http://pielot.org/2010/12/14/openal-on-android/)。这个库可以通过对`Android.mk`和`Application.mk`文件进行少量调整来编译为Android版本。以下是`Android.mk`文件：
- en: '[PRE91]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `-D` definition are required for correct compilation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D`定义是正确编译所需的：'
- en: '[PRE92]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'And this `if`-block is a way to separate ARM and x86 compiler switches when
    you want to build an x86 version of the library for Android:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此`if`块是一种在您想要为Android构建x86版本的库时，区分ARM和x86编译器开关的方法：
- en: '[PRE93]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `Application.mk` file is standard and looks as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.mk`文件是标准的，如下所示：'
- en: '[PRE94]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: For your convenience, we have all the source code and configuration files in
    the `6_OpenAL` example. Furthermore, all the libraries we use in this book are
    precompiled for Android, you can find them in the `Libs.Android` folder within
    the book's source code bundle.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便您，我们在`6_OpenAL`示例中提供了所有的源代码和配置文件。此外，本书中使用的所有库都已为Android预编译，您可以在本书源代码包中的`Libs.Android`文件夹中找到它们。
- en: Linking the libraries to your application
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将库链接到您的应用程序
- en: 'There is one more thing left to discuss in this chapter before we proceed to
    further topics. Indeed, we learned how to build the libraries, but not how to
    link your Android application against them. For this purpose, we need to modify
    the `Android.mk` file of your application. Let''s take a look at the `3_FreeImage_Example`
    sample and its `Application.mk`. It starts with the declaration of the prebuilt
    static library pointing to a binary file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论更多主题之前，本章还有一件事需要讨论。实际上，我们学习了如何构建库，但还没学习如何将您的Android应用程序与它们链接。为此，我们需要修改您的应用程序的`Android.mk`文件。让我们看看`3_FreeImage_Example`示例及其`Application.mk`。它以声明预构建的静态库指向二进制文件的声明开始：
- en: '[PRE95]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, we use the `$(TARGET_ARCH_ABI)` variable in the path to transparently
    handle `armeabi-v7a-hard` and `x86` versions of the libraries. You can add yet
    more architectures with ease.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在路径中使用`$(TARGET_ARCH_ABI)`变量，以透明地处理`armeabi-v7a-hard`和`x86`版本的库。您可以轻松地添加更多架构。
- en: 'Once the library is declared, let''s link the application against it. Take
    a look at the bottom of `Application.mk`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了库，让我们将应用程序与其链接。看看`Application.mk`的底部：
- en: '[PRE96]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `LOCAL_STATIC_LIBRARIES` variable contains all the required libraries. The
    prefix `lib` can be omitted for your convenience.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCAL_STATIC_LIBRARIES`变量包含了所有必要的库。为了方便起见，您可以省略前缀`lib`。'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概括
- en: In this chapter, we learned how to deal with precompiled static libraries on
    Android, same also applies to OS X and Linux, and how to do dynamic linking on
    Windows without breaking multiplatform capabilities of our code. We learned how
    to build `libcurl` and `OpenSSL`, so you can access SSL connections from your
    C++ code. A couple of examples for FreeImage and FreeType shows how to load and
    save images with raster fonts. The example with libtheora was quite comprehensive;
    however, the result was modest, we just read meta-information from a video file.
    OpenAL will be used as a backbone of our audio subsystem.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Android 上处理预编译的静态库，同样的方法也适用于 OS X 和 Linux，以及如何在 Windows 上进行动态链接，同时不破坏代码的多平台功能。我们学习了如何构建
    `libcurl` 和 `OpenSSL`，这样你就可以从 C++ 代码中访问 SSL 连接。FreeImage 和 FreeType 的几个示例展示了如何加载和保存光栅字体图像。使用
    libtheora 的示例相当全面；然而，结果却很谦虚，我们只是从视频文件中读取元信息。OpenAL 将作为我们音频子系统的基础框架。
