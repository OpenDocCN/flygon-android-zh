- en: Chapter 6. Rendering Graphics with OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Let''s face the fact that one of the main interests of Android NDK is to write
    multimedia applications and games. Indeed, these programs consume lots of resources
    and need responsiveness. That is why one of the first available APIs (and almost
    the only one until recently) in Android NDK is an API for graphics: the **Open
    Graphics Library for Embedded Systems** (abbreviated as **OpenGL ES**).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*OpenGL is a standard API created by Silicon Graphics and is now managed by
    the Khronos Group (see [http://www.khronos.org/](http://www.khronos.org/)). OpenGL
    provides a common interface for all standard **GPU**s (**Graphics Processing Unit**
    like your graphics card, and so on) on desktops. OpenGL ES is a derivative API
    available on many embedded platforms, such as Android or iOS. It is your best
    hope to write portable and efficient graphics code. OpenGL can render both 2D
    and 3D graphics.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are three main releases of OpenGL ES currently supported by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 1.0 and 1.1 are supported on all Android devices (except 1.1, which
    is supported on a few very old devices). It offers an old school graphic API with
    a **fixed pipeline** (that is, a fixed set of configurable operations to transform
    and render geometry). Specification is not completely implemented, but most features
    are available. This could still be a good choice for simple 2D or 3D graphics
    or to port legacy OpenGL code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 2 is supported on almost all phones nowadays, even older ones, starting
    from API Level 8\. It replaces the fixed pipeline with a modern programmable pipeline
    with **Vertex** and **Fragment Shaders**. It is a bit more complex but also more
    powerful. It is a good choice for the more complex 2D or 3D games, while still
    maintaining a very good compatibility. Note that OpenGL ES 1.X is frequently emulated
    by an OpenGL 2 implementation behind the scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 is available on modern devices starting from API Level 18, and
    OpenGL ES 3.1 is available starting from API Level 21 (not all devices at these
    API level may support it though). They bring a set of new improvements to GLES
    2 (**Texture Compression** as a standard feature, **Occlusion Queries, Instanced
    Rendering**, and others for 3.0, **Compute Shaders**, **Indirect Draw** commands,
    and others for 3.1) and a better compatibility with the desktop version of OpenGL.
    It is backward compatible with OpenGL ES 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter teaches you how to create some basic 2D graphics using OpenGL
    ES 2\. More specifically, you are going to discover how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize OpenGL ES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load a texture from a PNG file packaged in the assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw sprites using vertex and fragment shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render a particle effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapt graphics to various resolutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With OpenGL ES, and graphics in general, being a wide subject, this chapter
    covers only the basics to being with.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to create awesome 2D and 3D graphics is to initialize OpenGL
    ES. Although not terribly complex, this task requires some boilerplate code to
    bind a rendering context to an Android window. These pieces are glued together
    with the help of the **Embedded-System Graphics Library** (**EGL**), a companion
    API of OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: For this first section, we are going to replace the raw drawing system implemented
    in the previous chapter with OpenGL ES. A black to white fading effect will demonstrate
    that the EGL initialization works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part5`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initializing OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `GraphicsManager` to initialize an OpenGL ES context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `jni/GraphicsManager.hpp` by performing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `EGL/egl.h` to bind OpenGL ES to the Android platform and `GLES2/gl2.h`
    to render graphics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a method `stop()` to unbind the OpenGL rendering context and free graphics
    resources when you're leaving the activity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define `EGLDisplay`, `EGLSurface`, and `EGLContext` member variables, which
    represent handles to system resources, as shown here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Reimplement `jni/GraphicsManager.cpp` by replacing the previous code based
    on Android raw graphics API with OpenGL-based code. Start by adding new members
    to the constructor initialization list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The hard work must be done in the method `start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, declare some variables. Note how EGL defines its own types and re-declares
    primitive types `EGLint` and `EGLBoolean` to favor platform independence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, define the needed OpenGL configuration in constant attribute lists. Here,
    we want OpenGL ES 2 and a 16 bit surface (5 bits for red, 6 bits for green, and
    5 bits for blue). We could also choose a 32 bit surface for better color fidelity
    (but less performance on some devices). The attribute lists are terminated by
    `EGL_NONE` sentinel:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect to the default **display**, that is, the Android main window, with
    `eglGetDisplay()` and `eglInitialize()`. Then, find an appropriate **framebuffer**
    (An OpenGL term referring to the rendering surface, and possibly additional buffers,
    such as **Z-buffer** or **Stencil** buffer) configuration with `eglChooseConfig()`
    as the display. Configurations are selected according to the requested attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reconfigure the Android window with the selected configuration (retrieved with
    `eglGetConfigAttrib()`). This operation is Android-specific and performed with
    the Android `ANativeWindow` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, create the display surface and the OpenGL context using the display
    and configuration selected previously. A context contains all data related to
    OpenGL state (enabled settings, disabled settings, and so on):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate the created rendering context with `eglMakeCurrent()`. Finally, define
    the display viewport according to the surface attributes retrieved with `eglQuerySurface()`.
    The Z-buffer is not needed and can be disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the application stops running, unbind the application from the Android
    window and release the EGL resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have initialized and connected both OpenGL ES and the Android native window
    system together with EGL. Thanks to this API, we have queried a display configuration
    that matches our expectations and creates a framebuffer to render our scene on.
    EGL is a standard API specified by the Khronos group (like OpenGL). Platforms
    often implement their own variant (haphazardly, EAGL on iOS and so on) so that
    the display window initialization remains OS-specific. Thus, portability is quite
    limited in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This initialization process results in the creation of an OpenGL context, which
    is the first step to enable the OpenGL graphics pipeline. Special care should
    be taken with OpenGL contexts, which are frequently lost on Android: when you''re
    leaving or going back to the home screen, when a call is received, when devices
    go to sleep, when you''re switching to another application, and so on. As a lost
    context becomes unusable, it is important to release graphics resources as soon
    as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OpenGL ES specification supports the creation of multiple contexts for one
    display surface. This allows dividing rendering operations among threads or rendering
    to several windows. However, it is not well supported on Android hardware and
    should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES is now initialized but nothing will show up unless we start rendering
    some graphics on the display screen.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – clearing and swapping buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s clear the display buffers with a color fading from black to white:'
  prefs: []
  type: TYPE_NORMAL
- en: While still being in `jni/GraphicsManager.cpp`, refresh the screen during each
    update step with `eglSwapBuffers()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have a visual feedback, change the display background color gradually with
    the help of `glClearColor()` before erasing the Framebuffer with `glClear()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `Android.mk` file to link `the EGL` and `GLESv2` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the application. If everything works fine, your device screen will progressively
    fade from black to white. Instead of clearing the display with a raw `memset()`,
    or setting pixels one by one as seen in the previous chapter, we invoke efficient
    OpenGL ES drawing primitives. Note that the effect appears only the first time
    the application starts because the clear color is stored in a static variable.
    To make it appear again, kill the application and relaunch it.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a scene requires clearing the framebuffer and swapping the display
    buffer. The latter operation is triggered when `eglSwapBuffers()` is invoked.
    Swapping on Android is synchronized with the screen refresh rate to avoid image
    **Tearing**; this is a **VSync**. The refresh rate is variable depending on the
    device. A common value is 60 Hz but some devices have different refresh rates.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, rendering is performed on a back buffer which is swapped with the
    front buffer shown to the user. The front buffer becomes the back buffer and vice
    versa (the pointers are switched). This technique is more commonly referred to
    as **page flipping**. According to the driver implementation, the swapping chain
    can be extended with a third buffer. In this situation, we talk about **Triple
    Buffering**.
  prefs: []
  type: TYPE_NORMAL
- en: Our OpenGL pipeline is now properly initialized and able to display graphics
    on the screen. However, you may still find this concept of "pipeline" a bit nebulous.
    Let's see what is hidden behind it.
  prefs: []
  type: TYPE_NORMAL
- en: An insight into the OpenGL pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talk about pipeline because the graphics data goes through a series of steps
    in which it is transformed. The following diagram shows a simplified representation
    of the OpenGL ES 2 pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An insight into the OpenGL pipeline](img/9645OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Vertex Processing**: An input mesh of vertices, given as a **vertex buffer
    object** or a **vertex array**, is transformed vertex by vertex in a vertex shader.
    The vertex shader can, for example, move or rotate single vertices, project them
    onto the screen, adapt texture coordinates, compute lighting, and so on. It generates
    an output vertex that can be processed further in the pipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive Assembly**: Individual vertices are connected together into triangles,
    points, lines, and so on. More connection information is specified by the client
    code when the draw call is sent. It can take the form of an index buffer (each
    index points to a vertex through its rank) or a predefined rule, such as stripping
    or fanning. Transformations such as **back face culling** or **clipping** are
    done at this stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rasterization**: Primitives are interpolated into fragments, which is a term
    covering all the data associated with one pixel to render (such as color, normals,
    and so on). One fragment is related to one pixel. These fragments feed the fragment
    shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment Processing**: The fragment shader is a program which processes each
    fragment to compute the pixel to display. This is the stage where texture mapping,
    using the coordinates computed by the vertex shader and interpolated by the rasterizer,
    is applied. Different shading algorithms can be computed to render specific effects
    (for example, **Toon shading**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel Processing**: The fragment shader outputs pixels which have to be merged
    in the existing framebuffer (the rendering surface), where some pixels may be
    already drawn. Transparency effects or blending is applied at this stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vertex and fragment shaders are programmable in the **GL Shading Language**
    (**GLSL**). They are available only in OpenGL ES 2 and 3\. OpenGL ES 1 provides
    a fixed function pipeline with a predefined set of possible transformations.
  prefs: []
  type: TYPE_NORMAL
- en: This is only a brief overview of all the processing done by the OpenGL rendering
    pipeline. To find more information about it, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview).
  prefs: []
  type: TYPE_NORMAL
- en: Loading textures using the Asset manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I guess you need something more consistent than just changing the screen color!
    But before showing awesome graphics in our application, we need to load some external
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this second part, we are going to load a texture into OpenGL ES thanks to
    the Android Asset manager, an API provided since NDK R5\. It allows programmers
    to access any resources stored in the `assets` folder in their project. Assets
    stored there are then packaged into the final APK archive during application compilation.
    Asset resources are considered as raw binary files that your application needs
    to interpret and access using their filename relative to the `assets` folder (a
    file `assets/mydir/myfile` can be accessed with `mydir/myfile` path). Files are
    available in the read-only mode and might be compressed.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already written some Java Android application, then you know that
    Android also provides resources accessible through compile-time generated IDs
    inside the res project folder. This is not directly available on the Android NDK.
    Unless you are ready to use a JNI bridge, assets are the only way to package resources
    in your APK.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to load a texture encoded in one of the most popular picture
    formats used nowadays, the **Portable Network Graphics** (**PNG**). For this,
    we are going to integrate **libpng** in a NDK module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part6`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – reading assets with the Asset manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a class to read the Android asset files:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `jni/Resource.hpp` to encapsulate the access to asset files. We are going
    to use the `AAsset` API defined in `android/asset_manager.hpp` (which is already
    included in `android_native_app_glue.h`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the three main operations: `open()`, `close()`, and `read()`. We also
    need to retrieve the resource''s path in `getPath()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Android Asset management API entry point is an `AAsetManager` opaque structure.
    We can access asset files, represented by a second opaque structure `AAsset`,
    from it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the class `Resource` in `jni/Resource.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Asset manager is provided by the **Native App Glue** module in its `android_app->activity`
    structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Asset manager opens assets with `AassetManager_open()`. This is the sole
    responsibility of this method, apart from listing folders. We use the default
    open mode `AASSET_MODE_UNKNOWN` (more about this soon):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like files in classic applications, an opened asset must be closed when finished
    with `AAsset_close()` so that any resource allocated by the system is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the code operates on asset files with `AAsset_read()` to read data.
    This is quite similar to what you can find with the standard Posix file API. Here,
    we try to read the `pCount` data in a memory buffer and retrieve the amount of
    data that was effectively read (in case we reach the end of the asset):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to call the Android Asset API to read a file stored in the
    `assets` directory. Android assets are read-only and should be used to hold static
    assets only. The Android Asset API is defined in the `android/assert_manager.h`
    including file.
  prefs: []
  type: TYPE_NORMAL
- en: More about the Asset Manager API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Android Asset manager provides a small set of method to access directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AAssetManager_openDir()` gives the possibility to explore an asset directory.
    Use it in conjunction with `AAssetDir_getNextFileName()` and `AAssetDir_rewind()`.
    An opened directory must be closed with `AAssetDir_close()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAssetDir_getNextFileName()` lists all the files available in the specified
    asset directory. One filename is returned each time you call it, or `NULL` is
    returned when all files have been listed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAssetDir_rewind()` gives the possibility to restart the file iteration process
    with `AAssetDir_getNextFileName()` from the beginning of the process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAssetDir_close()` frees all the resources allocated when the directory has
    been opened. This method must be called in pair with `AAssetManager_openDir()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Files can be opened with an API similar to the POSIX file API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AAssetManager_open()` opens an asset file to read its content, retrieve its
    content as a buffer, or access its file descriptor. An opened asset must be closed
    with `AAsset_close()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_read()` attempts to read the requested number of bytes in the provided
    buffer. The number of bytes actually read is returned or a negative value is returned
    in case an error occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_seek()` moves directly to the specified offset in the file, ignoring
    the previous data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_close()` closes the asset and frees all the resources allocated when
    the file has been opened. This method must be called in pair with `AAssetManager_open()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_getBuffer()` returns a pointer to a memory buffer containing the whole
    asset content or `NULL` if a problem occurs. The buffer might be memory mapped.
    Beware, as Android compresses some assets (depending on their extension) so that
    the buffer might not be directly readable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_getLength()` gives the total asset size in bytes. This method might
    be useful to preallocate a buffer of the right size before reading an asset:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Aasset_getRemainingLength()` is similar to `AAsset_getLength()` except that
    it does take into account the bytes already read:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_openFileDescriptor()` returns a raw Unix file descriptor. This is used
    in OpenSL to read a music file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AAsset_isAllocated()` indicates if the buffer returned by the asset is memory
    mapped:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will see more about these methods in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modes available to open asset files are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AASSET_MODE_BUFFER`: This helps to perform fast small reads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AASSET_MODE_RANDOM`: This helps to read chunks of data forward and backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AASSET_MODE_STREAMING`: This helps to read data sequentially with occasional
    forward seeks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AASSET_MODE_UNKNOWN`: This helps to keep the system default settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time `AASSET_MODE_UNKNOWN` will be the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing, large APK can be problematic even when they are deployed on an SD
    card (see the `installLocation` option in the Android manifest). Thus, a good
    strategy to deal with tons of megabytes of assets is to keep only the essential
    ones in your APK. Download the remaining files to the SD card at runtime or package
    them within a second APK.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the PNG asset files to read, let's load them using `libpng`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – compiling and embedding libpng module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's load an OpenGL texture from a PNG file in DroidBlaster.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the website [http://www.libpng.org/pub/png/libpng.html](http://www.libpng.org/pub/png/libpng.html)
    and download the `libpng` source package (which is Version 1.6.10 in this book).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The original `libpng` 1.6.10 archive is provided with this book in the `Libraries/libpng`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a folder named `libpng` inside `$ANDROID_NDK/sources/`. Move all files
    from the `libpng` package into this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the file `libpng/scripts/pnglibconf.h.prebuilt` into the root folder `libpng`
    with other source files. Rename it as `pnglibconf.h`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The folder `$ANDROID_NDK/sources` is a special folder considered as a module
    folder by default. It contains reusable libraries. See [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*, for
    more information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the `$ANDROID_NDK/sources/libpng/Android.mk` file with the content given
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open `jni/Android.mk` in the `DroidBlaster` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link and import `libpng` with the help of the `LOCAL_STATIC_LIBRARIES` and
    `import-module` directives. This is similar to what we have done with the Native
    App Glue module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we embedded the existing Native App Glue module to
    create a fully native application. This time we have created our first native
    reusable module to integrate `libpng`. Ensure that it works by compiling `DroidBlaster`.
    If you look at the **Console** view of the `libpng` source files, it should get
    compiled for each target platform. Note that NDK provides incremental compilation
    and will not recompile the already compiled sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A native library module (here, `libpng`) is defined in a Makefile located at
    the root of its own directory. It is then referenced from another Makefile module,
    typically the application module (here `Droidblaster`).
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `libpng` library Makefile selects all the C files with the help of
    a custom macro `LS_C`. This macro is invoked from the `LOCAL_SRC_FILES` directive.
    We exclude `example.c` and `pngtest.c`, which are just test files, using the standard
    "Make" function `filter-out()`.
  prefs: []
  type: TYPE_NORMAL
- en: All the prerequisites include files that are made available to client modules
    with the directive `LOCAL_EXPORT_C_INCLUDES`, which refers to the source directory
    `LOCAL_PATH` here. The prerequisite libraries like `libzip` (option `-lz`) are
    also provided to the client modules using the `LOCAL_EXPORT_LDLIBS` directive
    this time. All directives containing the `_EXPORT_` term exports directives that
    are appended to the client module's own directives.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Makefiles, directives, and standard functions, have
    a look at [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – loading a PNG image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that `libpng` is compiled, let''s read a real PNG file with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit `jni/GraphicsManager.hpp` and include the `Resource` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new structure named `TextureProperties` containing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A resource representing the texture asset
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An OpenGL texture identifier (which is a kind of handle)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A width and a height
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Append a method `loadTexture()` to the `GraphicsManager` to read a PNG and load
    it into an OpenGL texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Textures are saved in an `mTextures` array to cache and finalize them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `jni/GraphicsManager.cpp` to include a new header named `png.h` and update
    the constructor initialization list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Free the texture-related resources when `GraphicsManager` stops using `glDeleteTetxures()`.
    This function can delete several textures at once, which explains why this method
    expects an ordinal and an array. But we will not use this possibility here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To be fully independent from the data source, `libpng` provides a mechanism
    to integrate custom-read operations. This takes the form of a callback and reads
    the requested quantity of data into a buffer provided by `libpng`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement this callback in conjunction with the Android Asset API to access
    the read data from application assets. The asset file is read through a `Resource`
    instance given by `png_get_io_ptr()` as an untyped pointer. This pointer is going
    to be provided by us while setting up the callback function (using `png_set_read_fn()`).
    We will see how this is done in the next steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `loadTexture()`. First, look for the `texture` in the cache. Textures
    are expensive in terms of memory and performance and should be managed with care
    (like all OpenGL resources in general):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you could not find the texture in the cache, let's read it. Define a few
    variables needed to read the PNG file first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open the image using the `AAsset` API and check the image signature (the
    first 8 bytes of the file) to ensure that the file is a PNG (note that it might
    still be corrupted):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Allocate all the structures necessary to read a PNG image. After that, prepare
    reading operations by passing our `callback_readPng()`, implemented earlier in
    this tutorial, to `libpng`, along with our `Resource` reader. `Resource` pointer
    is the one retrieved in the callback with `png_get_io_ptr()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, set up error management with `setjmp()`. This mechanism allows jumping
    in code like a `goto` but through the call stack. If an error occurs, the control
    flow comes back at the point where `setjmp()` has been called first but enters
    the `if` block instead (here `goto ERROR`). This is the moment where we can provide
    the following script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ignore the first 8 bytes from the signature, which have already been read,
    for file signatures with `png_set_sig_bytes()` and `png_read_info()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start reading the PNG file header with `png_get_IHDR()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The PNG files can be encoded in several formats: RGB, RGBA, 256 colors with
    a palette, grayscale, and so on. R, G, and B color channels can be encoded up
    to 16 bits. Hopefully, `libpng` provides transformation functions to decode unusual
    formats and transforms them into more classical RGB and luminance formats (with
    8 bits per channel, with or without an alpha channel).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the right transformation using `png_set` functions. Transformations are
    validated with `png_read_update_info()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the same time, select the corresponding OpenGL texture format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Allocate the necessary temporary buffer to hold image data and a second one
    with the address of each output image row for `libpng`. Note that the row order
    is inverted because OpenGL uses a different coordinate system (the first pixel
    is at bottom-left) than PNG (first pixel at top-left).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, start reading the image content with `png_read_image()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, when it''s finished, release all temporary resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, when it''s finished, release all temporary resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining our native library module `libpng` with the Asset manager API gives
    us the power to load PNG files packaged in the assets directory. PNG is a relatively
    simple image format that is rather easy to integrate. In addition, it supports
    compression, which is good to limit the size of your APKs. Please note that once
    loaded, the PNG image buffer is uncompressed and can consume a lot of memory.
    So, release them as soon as you can. For detailed information about the PNG format,
    see [http://www.w3.org/TR/PNG/](http://www.w3.org/TR/PNG/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that our PNG image is loaded, we can generate an OpenGL texture from it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – generating an OpenGL texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `image` buffer filled by `libpng` now contains raw texture data. The next
    step is to generate a texture from it:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue our previous method `which is GraphicsManager::loadTexture()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a new texture identifier with `glGenTextures()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Indicate that we are working on a texture with `glBindTexture()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure texture parameters with `glTexParameteri()` to specify the way a
    texture is filtered and wrapped. Use `GL_NEAREST`, as smoothing is not essential
    for a 2D game without zoom effects. Texture repetition is also not necessary and
    can be prevented with `GL_CLAMP_TO_EDGE`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Push the image data into OpenGL texture with `glTexImage2D()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This unbinds the texture to put OpenGL pipeline back in its previous state.
    This is not strictly necessary, but it helps to avoid configuration mistakes in
    future draw calls (that is, drawing with an unwanted texture).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, do not forget to free the temporary image buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can check that the texture has been created properly with `glGetError()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, cache the `texture` before returning it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/DroidBlaster.hpp`, include the `Resource` header and define two resources,
    of which one is for the ship and another is for the asteroids:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `jni/DroidBlaster.cpp` and initialize the `texture` resources in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure that the code is working, load textures in `onActivate()`. The textures
    can be loaded only after OpenGL is initialized by `GraphicsManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before running `DroidBlaster`, add `asteroid.png` and `ship.png` into the `droidblaster/assets`
    directory (create it if it's necessary).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PNG files are provided with this book in the `DroidBlaster_Part6/assets`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the application and you should not see much difference. Indeed, we have
    loaded two PNG textures, but we are not actually rendering them. However, if you
    check the logs, you should see traces showing that the textures are properly loaded
    and retrieved from the cache, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Textures in OpenGL are objects (in the OpenGL way) which are in the form of
    an array of memory allocated on the **Graphical Processing Unit** (**GPU**) to
    store specific data. Storing graphics data in the GPU memory provides faster memory
    access than if it was stored in the main memory, which is a bit like a cache on
    a CPU. This efficiency comes at a price: texture loading is costly and must be
    performed as much as possible during startup.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pixels of a texture are named **Texels**. Texel is the contraction of "**Texture
    Pixel**". Textures, and thus Texels, are projected on 3D objects during scene
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: More about textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important requirement to remember while dealing with textures is their dimensions;
    OpenGL textures must have a power of two dimensions (for example, 128 or 256 pixels).
    Other dimensions will fail on most devices. These dimensions ease a technique
    called **MIPmapping** (**Multum In Parvo** (**MIP**), which mean much in little).
    MIPmaps are smaller versions of the same texture (see the following figure) applied
    selectively depending on the rendered object distance. They increase performance
    and reduce aliasing artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: '![More about textures](img/9645OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The texture configuration is set with `glTexParameteri()`. They need to be
    specified at the texture creation time only. The following two main kinds of parameters
    can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture Filtering** with `GL_TEXTURE_MAG_FILTER` and `GL_TEXTURE_MIN_FILTER`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These parameters control the way texture magnification and minification are
    performed, that is, the processing applied when texture is respectively smaller
    or bigger than the rasterized primitive. Two values are possible in this, as shown
    in the next figure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GL_LINEAR` interpolates textures drawn onscreen based on the closest texel
    colors (also known as Bilinear filtering). This calculation results in a smooth
    effect.`GL_NEAREST` displays the closest texel color without any interpolation.
    This value gives slightly better performance than `GL_LINEAR`.![More about textures](img/9645OS_06_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There exist variants that can be used in conjunction with MIPmaps to indicate
    how to apply minification; some of these variants are `GL_NEAREST_MIPMAP_NEAREST`,
    `GL_LINEAR_MIPMAP_NEAREST`, `GL_NEAREST_MIPMAP_LINEAR` and `GL_LINEAR_MIPMAP_LINEAR`
    (this one is better known as **Trilinear filtering**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Texture Wrapping** with `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These parameters control the way textures are repeated when texture coordinates
    go outside the range [0.0, 1.0]. S represents the X axis and T, the Y axis. Their
    different naming is used to avoid any confusion with position coordinates. They
    are often referred to as U and V. The following figure shows some of the possible
    values and their effect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![More about textures](img/9645OS_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'A few good practices to remember while dealing with textures are:'
  prefs: []
  type: TYPE_NORMAL
- en: Switching textures is an expensive operation, so avoid OpenGL pipeline state
    changes as much as possible (binding a new texture and changing an option with
    `glEnable()` are examples of state changes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textures are probably the most memory and bandwidth consuming resources. Consider
    using **compressed** texture formats to greatly improve performances. Sadly, texture
    compression algorithms are rather tied to the hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create big textures to pack, as much data as you can, even from multiple objects.
    This is known as **Texture Atlas**. For example, if you look at the ship and asteroid
    texture, you will find that several sprite images are packed in them (we could
    even pack more):![More about textures](img/9645OS_06_09.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This introduction to textures gives a slight overview of what OpenGL ES can
    achieve. For more information about texturing, have a look at the OpenGL.org wiki
    at [http://www.opengl.org/wiki/Texture](http://www.opengl.org/wiki/Texture).
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 2D sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2D games are based on **sprites**, which are pieces of images composited onscreen.
    They can represent an object, a character, a static, or an animated element. Sprites
    can be displayed with a transparency effect using the alpha channel of an image.
    Typically, an image will contain several frames for a sprite, each frame representing
    a different animation step or different objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a powerful multiplatform image editor, consider using **GNU Image
    Manipulation Program** (**GIMP**). This program is available on Windows, Linux,
    and Mac OS X, and is a powerful and open source. You can download it from [http://www.gimp.org/](http://www.gimp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Several techniques exist to draw sprites using OpenGL. One of these is called
    **Sprite Batch**. This is one of the most efficient ways to create 2D games with
    OpenGL ES 2\. It is based on a vertex array (stored in main memory) that is regenerated
    during each frame with all the sprites to render. Rendering is performed with
    the help of a simple vertex shader that projects 2D coordinates onto the screen
    and a fragment shader that outputs the raw sprite texture color.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to implement a sprite batch to render the ship and multiple
    asteroids onscreen in `DroidBlaster`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part7`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initializing OpenGL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how to implement a sprite batch in DroidBlaster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `jni/GraphicsManager.hpp`. Create the class `GraphicsComponent`, which
    defines a common interface for all rendering techniques starting with sprite batches.
    Define a few new methods such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerComponent()` which records a list of `GraphicsComponent` to initialize
    and render'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, declare a few new member variables such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a few new methods in `GraphicsManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getProjectionMatrix()` which provides an OpenGL matrix to project 2D graphics
    on screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadShaderProgram()` to load a vertex and fragment shader and link them together
    into an OpenGL program'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerComponent()` which records a list of GraphicsComponent to initialize
    and render'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `RenderVertex` private structure representing the structure of an
    individual sprite vertex.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, declare a few new member variables such as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mProjectionMatrix` to store an orthographic projection (as opposed to a perspective
    projection used in 3D games)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mShaders`, `mShaderCount`, `mComponents`, and `mComponentCount` to keep trace
    of all resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, get rid of all the `GraphicsElement` stuff used in the previous chapter
    to render raw graphics:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `jni/GraphicsManager.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the constructor initialization list and the destructor. Again, get rid
    of everything related to `GraphicsElement`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also implement `registerComponent()` in place of `registerElement()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Amend `onStart()` to initialize the **Orthographic** projection matrix array
    with display dimensions (we will see how to compute matrices more easily using
    GLM in [Chapter 9](ch09.html "Chapter 9. Porting Existing Libraries to Android"),
    *Porting Existing Libraries to Android*) and load components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A projection matrix is a mathematical way to project 3D objects composing a
    scene into a 2D plane, which is the screen. In orthographic projection, a projection
    is perpendicular to the display surface. That means that an object has exactly
    the same size whether it is close or far away from the point of view. Orthographic
    projection is appropriate for 2D games. **Perspective** projection, in which objects
    look smaller the farther they are, is rather used for 3D games.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information, have a look at [http://en.wikipedia.org/wiki/Graphical_projection](http://en.wikipedia.org/wiki/Graphical_projection).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Free any resources loaded with `loadShaderProgram()` in `stop()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render any registered components in `update()` after the display is cleared
    but before it is refreshed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the new method `loadShader()`. Its role is to compile and load the given
    shaders passed as a human-readable GLSL program. To do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a new vertex shader with `glCreateShader()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the vertex shader source into OpenGL with `glShaderSource()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the shader with `glCompileShader()` and check the compilation status
    with `glGetShaderiv()`. The compilation errors can be read with `glGetShaderInfoLog()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repeat the operation for the given fragment shader:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once compiled, link the compiled vertex and fragment shaders together. To do
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a program object with `glCreateProgram()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the shaders to use `glAttachShader()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link them together with `glLinkProgram()` to create the final program. Shader
    consistencies and compatibility with the hardware is checked at that point. The
    result can be checked with `glGetProgramiv()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, get rid of the shaders as they are useless once linked in a program.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create `jni/Sprite.hpp`, which defines a class with all the necessary data to
    animate and draw a single sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Vertex` structure which defines the content of a sprite vertex. We
    need a 2D position and texture coordinates which delimit the sprite picture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, define a few methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sprite animation can be updated and retrieved with `setAnimation()` and `animationEnded()`.
    Location is publicly available for simplicity purposes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Give privileged access to a component that we are going to define later, named
    `SpriteBatch`. It can `load()` and `draw()` sprites.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, define a few properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A texture containing the sprite sheet and its corresponding resource
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sprite frame data**: `mWidth` and `mHeight`, horizontal, vertical, and total
    number of frames in `mFrameXCount`, `mFrameYCount`, and `mFrameCount`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation data**: first and total number of frames of an animation in `mAnimStartFrame`
    and `mAnimFrameCount`, animation speed in `mAnimSpeed`, the currently shown frame
    in `mAnimFrame`, and a looping indicator in `mAnimLoop`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the `jni/Sprite.cpp` constructor and initialize the members to default
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Frame information (horizontal, vertical, and total number of frames) needs
    to be recomputed in `load()` as texture dimensions are known only at load time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An animation starts from a given in the sprite sheet and ends after a certain
    amount of frames, whose number changes according to speed. An animation can loop
    to restart from the beginning when it is over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `draw()`, first update the frame to draw according to the sprite animation
    and the time spent since the last frame. What we need is the indices of the frame
    in the spritesheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sprite is composed of four vertices drawn in an output array, `pVertices`.
    Each of these vertices is composed of a sprite position (`posX1`, `posY1`, `posX2`,
    `posY2`) and texture coordinates (`u1`, `u2`, `v1`, `v2`). Compute and generate
    these vertices dynamically in the memory buffer, `pVertices`, provided in the
    parameter. This memory buffer will be given later to OpenGL to render the sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify `jni/SpriteBatch.hpp` with methods such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`registerSprite()` to add a new sprite to draw'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load()` to initialize all the registered sprites'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draw()` to effectively render all the registered sprites'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to need member variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A set of sprites to draw in `mSprites` and `mSpriteCount`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mVertices`, `mVertexCount`, `mIndexes`, and `mIndexCount`, which define a
    vertex and an index buffer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A shader program identified by `mShaderProgram`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The vertex and fragment shader parameters are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`aPosition`, which is one of the sprite corner positions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aTexture`, which is the sprite corner texture coordinate. It defines the sprite
    to display in the sprite sheet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uProjection`, is the orthographic projection matrix.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uTexture`, contains the sprite picture.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `jni/SpriteBach.cpp` constructor to initialize the default values.
    The component must register with `GraphicsManager` to be loaded and rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the destructor, the allocated sprites must be freed when the component is
    destroyed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The index buffer is rather static. We can precompute its content when a sprite
    is registered. Each index points to a vertex in the vertex buffer (0 representing
    the very first vertex, 1 the 2nd, and so on). As a sprite is represented by 2
    triangles of 3 vertices (to form a quad), we need 6 indexes per sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write the GLSL vertex and fragment shaders as constant strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The shader code is written inside a `main()` function similar to what can be
    coded in C. As any normal computer program, shaders require variables to process
    data: attributes (per-vertex data like the position), uniforms (global parameters
    per draw call), and varying (values interpolated per fragment like the texture
    coordinates).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, texture coordinates are passed to the fragment shader in `vTexture`.
    The vertex position is transformed from a 2D vector to a 4D vector into a predefined
    GLSL variable `gl_Position`. The fragment shader retrieves interpolated texture
    coordinates in `vTexture`. This information is used as an index in the predefined
    function `texture2D()` to access the texture color. Color is saved in the predefined
    output variable `gl_FragColor`, which represents the final pixel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the shader program and retrieve the shader attributes and uniform identifiers
    in `load()`. Then, initialize sprites, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write `draw()`, which executes the OpenGL sprite rendering logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, select the sprite shader and pass its parameters: the matrix and the
    texture uniforms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, indicate to OpenGL how the position and UV coordinates are stored in
    the vertex buffer with `glEnableVertexAttribArray()` and `glVertexAttribPointer()`.
    These calls basically describe the `mVertices` structure. Note how vertex data
    is linked to shader attributes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate transparency using a blending function to draw sprites over the background,
    or other sprites:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the blending modes provided by OpenGL, have a look
    at [https://www.opengl.org/wiki/Blending](https://www.opengl.org/wiki/Blending).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now start the rendering loop to render all sprites in a batch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first outer loop basically iterates over textures. Indeed, the pipeline
    state changes in OpenGL are costly. Methods like `glBindTexture()` should be called
    as little as possible to guarantee performance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The inner loop generates vertices for all sprites with the same texture:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each time the texture changes, render the bunch of sprites with `glDrawElements()`.
    The vertex buffer specified earlier is combined with the index buffer given here
    to render the right sprites with the right texture. At this point, draw calls
    are sent to OpenGL, which executes the shader program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When all sprites are rendered, restore the OpenGL state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `jni/Ship.hpp` with the new sprite system. You can remove the previous
    `GraphicsElement` stuff:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The file `jni/Ship.cpp` does not change much apart from the `Sprite` type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the new `SpriteBatch` component in `jni/DroidBlaster.hpp`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `jni/DroidBlaster.cpp`, define some new constants with animation properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, use the `SpriteBatch` component to register the ship and asteroids graphics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the previous stuff related to `GraphicsElement` again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We do not need to load textures manually in `onActivate()` anymore. Sprites
    will handle this for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, release the graphic resources in `onDeactivate()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Launch DroidBlaster. You should now see an animated ship surrounded by frightening
    rotating asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this part, we have seen how to draw a sprite efficiently with the help of
    the Sprite Batch technique. Indeed, a common cause of bad performance in OpenGL
    programs lies in state changes. Changing the OpenGL device state (for example,
    binding a new buffer or texture, changing an option with `glEnable()`, and so
    on) is a costly operation and should be avoided as much as possible. Thus, a good
    practice to maximize OpenGL performance is to order draw calls and change only
    the needed states.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best OpenGL ES documentation is available from the Apple developer
    site at [https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/](https://developer.apple.com/library/IOS/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/).
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's see more about the way OpenGL stores vertices in memory and
    the basics of OpenGL ES shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Arrays versus Vertex Buffer Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Vertex** **Arrays** (**VA**) and **Vertex Buffer Objects** (**VBO**) are
    the two main ways to manage vertices in OpenGL ES. Like with textures, multiple
    VAs/VBOs can be bound simultaneously to one vertex shader.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to manage vertices in OpenGL ES:'
  prefs: []
  type: TYPE_NORMAL
- en: In main memory (that is, in RAM), we talk about Vertex Arrays (abbreviated VA).
    Vertex arrays are transmitted from the CPU to the GPU for each draw call. As a
    consequence, they are slower to render, but also much easier to update. Thus,
    they are appropriate when a mesh of vertices is changing frequently. This explains
    the decision to use a vertex array to implement sprite batches; each sprite is
    updated each time a new frame is rendered (position, as well as texture coordinates,
    to switch to a new frame).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In driver memory (generally in GPU memory or **VRAM**), we talk about **Vertex
    Buffers Objects**. Vertex buffers are faster to draw but more expensive to update.
    Thus, they are often used to render static data that never changes. You can still
    transform it with vertex shaders, which we are going to see in the next part.
    Note that some hints can be provided to the driver during initialization (`GL_DYNAMIC_DRAW`)
    to allow fast updates but at the price of more complex buffer management (that
    is, multiple buffering).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After transformation, the vertices are connected together during the primitive
    assembly stage. They can be assembled in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As lists 3 by 3 (which can lead to vertex duplication), in fans, in strips,
    and so on; in which case, we use `glDrawArrays()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an index buffers which specifies 3 by 3, where vertices are connected
    together. Index buffers are often the best way to achieve better performance.
    Indices need to be sorted to favor caching. Indices are drawn with their associated
    VBO or VA using `glDrawElements()`.![Vertex Arrays versus Vertex Buffer Object](img/9645OS_06_10.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some good practices to remember when you''re dealing with vertices are:'
  prefs: []
  type: TYPE_NORMAL
- en: Pack as many vertices in each buffer as you can, even from multiple meshes.
    Indeed, switching from one set of vertices to another, either a VA or a VBO, is
    slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid updating static vertex buffers at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make vertex structure the size of a power of 2 (in bytes) to favor data alignment.
    It is often preferred to pad data rather than to transmit unaligned data because
    of the way GPU processes it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about vertex management, have a look at the OpenGL.org
    wiki at [http://www.opengl.org/wiki/Vertex_Specification](http://www.opengl.org/wiki/Vertex_Specification)
    and [http://www.opengl.org/wiki/Vertex_Specification_Best_Practices](http://www.opengl.org/wiki/Vertex_Specification_Best_Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering particle effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DroidBlaster needs a background to make it more pleasant-looking. As the action
    is located in space, what about a falling star to give an impression of speed?
  prefs: []
  type: TYPE_NORMAL
- en: Such an effect can be simulated in several ways. One possible choice consists
    of showing a particle effect, where each particle corresponds to a star. OpenGL
    provides such a feature through **Point** **Sprites**. A point sprite is a special
    kind of element that requires only one vertex to draw a sprite. Combined with
    a whole vertex buffer, many sprites can be drawn at the same time efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Point sprites are usable with vertex and fragment shaders. To be even more efficient,
    we can use their power to process particle movement directly inside the shaders.
    Thus, we will not need to regenerate the vertex buffer each time a particle changes,
    like we have to do with sprite batches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part8`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – rendering a star field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how to apply this particle effect in `DroidBlaster`:'
  prefs: []
  type: TYPE_NORMAL
- en: In `jni/GraphicsManager.hpp`, define a new method to load a vertex buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an array to store vertex buffer resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/GraphicsManager.cpp`, update the constructor initialization list and
    free vertex buffer resources in `stop()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the new method `loadVertexBuffer()` to upload the data from the given
    memory location into an OpenGL vertex buffer. As opposed to the SpriteBatch example,
    which uses a dynamic vertex buffer in computer memory, the following vertex buffer
    is static and located in GPU memory. This makes it faster but quite inflexible
    too. To do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a buffer identifier with `glGenBuffers()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicate that we are working on a vertex buffer with `glBindBuffer()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Push the vertex data from the given memory location into OpenGL vertex buffer
    with `glBufferData()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbind the vertex buffer to put OpenGL back in its previous state. This is not
    strictly necessary, like for textures, but it helps avoiding configuration mistakes
    in future draw calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check that the vertex buffer has been created properly with `glGetError()`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Define the new `StarField` component in `jni/StarField.hpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `the GraphicsComponent` methods, as done previously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define a specific `Vertex` structure with 3 coordinates `x`, `y`, and `z`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A star field is characterized by the number of stars in `mStarCount` and a texture
    that represents a single one in `mTextureResource`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need some OpenGL resources: a vertex buffer, a texture, and a shader
    program with its variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`aPosition`, which is the star position.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uProjection`, which is the orthographic projection matrix.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uTime`, which is the total elapsed time given by `TimeManager`. This is necessary
    to simulate the movement of stars.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uHeight`, which is the height of the display. The stars are going to be recycled
    when they reach the screen boundaries.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uTexture`, which contains the star picture.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `jni/StarField.cpp` and implement its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The star field logic is mostly implemented in the vertex shader. Each star,
    represented by a single vertex, is moved from top to bottom according to time,
    speed (which is constant), and star distance. The farther it is (distance being
    determined by the `z` vertex component), the slower it scrolls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GLSL function `mod`, which stands for modulo, resets the star position when
    it has reached the bottom of the screen. The final star position is saved in the
    predefined variable `gl_Position`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The star size on screen is also a function of its distance. The size is saved
    in the predefined variable `gl_PointSize` in pixel units:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fragment shader is much simpler and only draws the star texture onscreen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `load()` function, generate the vertex buffer with the help of the `loadVertexBuffer()`
    method implemented in `GraphicsManager`. Each star is represented by a single
    vertex. The position on screen and depth are generated randomly. Depth is determined
    on a [0.0, 1.0] scale. Once this is done, release the temporary memory buffer
    holding the star field data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, load the `star` texture and generate the program from the shaders defined
    above. Retrieve their attribute and uniform identifiers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, render the `star` field by sending the static vertex buffer, the texture,
    and the shader program together in one draw call. To do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable blending, that is, the management of transparency. Indeed, the star
    "particles" are small, sparse, and drawn over a black background.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the vertex buffer first with `glBindBuffer()`. This call is necessary
    when a static vertex buffer has been generated at load time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicate how vertex data is structured with `glVertexAttribPointer()`, and to
    which shader attributes it relates with `glEnableVertexAttribArray()`. Note that
    the last parameter of `glVertexAttribPointer()` is not a pointer to a buffer this
    time but an index within the vertex buffer. Indeed, the vertex buffer is static,
    and in GPU memory, so we do not know its address.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the texture to draw with `glActiveTexture()` and `glBindTexture()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the shader program with `glUseProgram()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bind the program parameters with `glUniform` function variants.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, send the draw call to OpenGL with `glDrawArrays()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then restore the OpenGL pipeline state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `jni/DroidBlaster.hpp`, define the new `StarField` component along with
    a new texture resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate it in the `jni/DroidBlaster.cpp` constructor with `50` stars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before running `DroidBlaster`, add `droidblaster/star.png` into the assets directory.
    These files are provided with this book in the `DroidBlaster_Part8/assets` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run `DroidBlaster`. The star field should look as shown in the following screenshot,
    when scrolling through the screen at a random pace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All of these stars are rendered as point sprites, where each point represents
    a quad determined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A position on screen**: The position represents the center of the point sprite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A point size**: The size defines implicitly the point sprite quad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Point sprites are an interesting way to create particle effects, but, they
    have a few drawbacks, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Their possible size is more or less limited depending on the hardware capabilities.
    You can find the maximum size by querying `GL_ALIASED_POINT_SIZE_RANGE` with `glGetFloatv()`;
    look at the following example for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you draw bigger point sprites, you will notice that the particles are clipped
    (that is, masked) at their center and the whole sprite boundaries don't get out
    of screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, depending on your needs, it might be more appropriate to use classic vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about vertices, you may have noticed that we have not created a vertex
    array but a vertex buffer object. Indeed, point sprites are evaluated completely
    in the vertex shader. This optimization allows us to use a static geometry (`glBufferData()`
    with the hint `GL_STATIC_DRAW`) which can be managed efficiently by the driver.
    Note that vertex buffer objects can also be marked as being subject to updates
    using the hint `GL_DYNAMIC_DRAW` (which means buffer will change frequently) or
    `GL_STREAM_DRAW` (which means buffer will be used once and thrown). The process
    of creating a VBO is similar to the process of creating any other kind of object
    in OpenGL, and involves generating a new identifier, selecting it, and finally
    uploading data in driver memory. If you understand this process, you understand
    the way OpenGL works.
  prefs: []
  type: TYPE_NORMAL
- en: Programming shaders with GLSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shaders are written in GLSL, a (relatively) high-level programming language
    which allows defining functions (with in, out, and inout parameters), conditionals,
    loops, variables, arrays, structures, arithmetic operators, and so on. It abstracts
    as much as possible hardware specificities. GLSL allows the following kind of
    variables to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **attributes** | These contain per-vertex data, such as vertex position or
    texture coordinates. Only one vertex is processed each time the shader executes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **const** | It represents compile-time constants or read-only function parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **uniforms** | These are a kind of global parameter that can be changed per
    primitive (that is, per draw call). It has the same value for a whole mesh. An
    example of this could be a model-view matrix (for a vertex shader) or a texture
    (for a fragment shader). |'
  prefs: []
  type: TYPE_TB
- en: '| **varying** | These are per-pixel interpolated values computed according
    to the vertex shader output. They are an output parameter in vertex shaders and
    an input parameter in fragment shaders. In OpenGL ES 3, the "varying" parameters
    have a new syntax: `out` in a vertex shader and `in` in a pixel shader. |'
  prefs: []
  type: TYPE_TB
- en: 'The main types of parameters allowed to declare such variables are shown in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **void** | This is for function result only. |'
  prefs: []
  type: TYPE_TB
- en: '| **bool** | This is a boolean value. |'
  prefs: []
  type: TYPE_TB
- en: '| **float** | This is a floating point value. |'
  prefs: []
  type: TYPE_TB
- en: '| **int** | This is a signed integer value. |'
  prefs: []
  type: TYPE_TB
- en: '| **vec2, vec3, vec4** | This is a floating point vector. Vectors exist for
    other types such as `bvec` for booleans or `ivec` for signed integer. |'
  prefs: []
  type: TYPE_TB
- en: '| **mat2, mat3, mat4** | These are 2x2, 3x3, and 4x4 floating point matrices.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **sampler2D** | This gives access to 2D texture texels. |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the GLSL specification provides some predefined variables, such as
    the ones shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **highp vec4 gl_Position** | Vertex shader Output | This is the transformed
    vertex position. |'
  prefs: []
  type: TYPE_TB
- en: '| **mediump float gl_PointSize** | Vertex shader Output | This is the size
    of a point sprite in pixels (more about this will be discussed in the next part).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **mediump vec4 gl_FragCoord** | Fragment shader Input | These are the coordinates
    of the fragment within framebuffer. |'
  prefs: []
  type: TYPE_TB
- en: '| **mediump vec4****gl_FragColor** | Fragment shader Output | This is the color
    to display for the fragment. |'
  prefs: []
  type: TYPE_TB
- en: Numerous functions, mostly arithmetic, are also provided, such as `sin()`, `cos()`,
    `tan()`, `radians()`, `degrees()`, `mod()`, `abs()`, `floor()`, `ceil()`, `dot()`,
    `cross()`, `normalize()`, `texture2D()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the best practices to remember while dealing with shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not compile or link shaders at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beware of different hardware that has different capabilities and, more specifically,
    a limited number of variables allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a good trade-off between performance and accuracy while defining precision
    specifiers (for example, `highp`, `medium`, or `lowp`). Do not hesitate to redefine
    them to get consistent behavior. Note that a `float` precision specifier should
    be defined in the GLES fragment shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid conditional branches as much as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, have a look at OpenGL.org wiki at [http://www.opengl.org/wiki/OpenGL_Shading_Language](http://www.opengl.org/wiki/OpenGL_Shading_Language),
    [http://www.opengl.org/wiki/Vertex_Shader](http://www.opengl.org/wiki/Vertex_Shader)
    and [http://www.opengl.org/wiki/Fragment_Shader](http://www.opengl.org/wiki/Fragment_Shader).
  prefs: []
  type: TYPE_NORMAL
- en: Beware, as the content of these pages is applicable to OpenGL but not necessarily
    to GLES.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting graphics to various resolutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A complex subject to handle while writing a game is the Android screen size
    fragmentation. Low-end phones have resolutions of a few hundred pixels, whereas
    some high-end devices provide resolutions of more than two thousand.
  prefs: []
  type: TYPE_NORMAL
- en: There exist several ways to handle various screen sizes. We can adapt graphic
    resources, use black bands around the screen, or apply and adapt responsive designs
    to games.
  prefs: []
  type: TYPE_NORMAL
- en: Another simple solution consists of rendering the game scene off-screen with
    a fixed size. The off-screen framebuffer is then copied onto the screen and scaled
    to an appropriate size. This *one size fits all* technique does not provide the
    best quality and might be a bit slow on low-end devices (especially if they have
    a lower resolution than the off-screen framebuffer). However, it is quite simple
    to apply.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part9`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adapting resolution with off-screen rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s render the game scene off-screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `jni/GraphicsManager.hpp`, followed by these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define new getter methods for the screen width and height with their corresponding
    member variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new function `initializeRenderBuffer()`, which creates an off-screen
    buffer to render the scene:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'While still being in the same file, follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a new `RenderVertex` structure with four components - `x`, `y`, `u`,
    and `v`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the OpenGL resources necessary for the framebuffer, namely, the texture,
    the vertex buffer, the shader program, and its variables:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `jni/GraphicsManager.cpp` constructor initialization list to initialize
    default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change `start()` method to save the display surface width and height respectively
    in `mScreenWidth` and `mScreenHeight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, call `initializeRenderBuffer()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a vertex and fragment shader for off-screen rendering. This is similar
    to what we have seen until now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `initializeRenderBuffer()`, create a predefined array of a vertex that is
    going to be loaded into OpenGL. It represents a single quad with a full texture
    rendered on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the new render height based on a fixed target width of `600` pixels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the current screen framebuffer from the location where the final scene
    is rendered using `glGetIntegerv()` and the special value `GL_FRAMEBUFFER_BINDING`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a texture for off-screen rendering, like we have seen previously. In
    `glTexImage2D()`, pass a `NULL` value as the last parameter to create only the
    surface without initializing its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create an off-screen framebuffer with `glGenFramebuffers()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the previous texture to it with `glBindFramebuffer()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Terminate by restoring the device state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the shader program used to render texture to screen and retrieve its
    attributes and uniforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not forget to release allocated resources in `stop()` when the activity
    finishes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, use the new off-screen framebuffer to render the scene. To do so,
    you need to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the framebuffer with `glBindFramebuffer()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Specify the rendering viewport, which has to match the off-screen framebuffer
    dimensions, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once it's rendered, restore the normal screen framebuffer and the correct viewport
    dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select as a source the following parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The off-screen texture which is attached to the off-screen framebuffer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The shader program, which does basically nothing apart from projecting vertices
    and scaling texture, on the screen framebuffer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The vertex buffer, which contains a single quad with texture coordinates, as
    shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Terminate by rendering the off-screen buffer into the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can then restore the device state again, like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the application on several devices. Every device should display a proportionally
    similar scene. Indeed, graphics are now rendered to an off-screen framebuffer
    attached to a texture. The result is then scaled according to the target screen
    resolution to provide the same experience across different devices. This simple
    and cheap solution comes with a price, which is that the low-end devices might
    suffer depending on the chosen fixed resolution, whereas high-end devices will
    look blurry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handling various screen resolutions is one thing. Managing their various aspect
    ratios is another. Several solutions exist for this problem, such as using black
    stripes, stretching the screen, or defining a minimum and maximum displayable
    area with only the first one containing important information.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, the rendering of a scene off-screen is often referred to as
    **Render to Texture**. This technique is commonly used to implement shadows, reflection,
    or postprocessing effects. Mastering this technique is a key in implementing high
    quality games.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL, and graphics in general, is a complex and highly technical API. One
    book is not enough to cover it entirely, but drawing 2D graphics with textures
    and buffer objects opens the door to much more advanced stuff!
  prefs: []
  type: TYPE_NORMAL
- en: In more detail, you have learned how to initialize an OpenGL ES context and
    bind it to an Android window. Then, you have seen how to turn libpng into a module
    and load a texture from a PNG asset. We have used this texture and then combined
    it with vertex buffers and shaders to render sprites and particles. Finally, we
    have found a solution to the Android resolution fragmentation issue with a simple
    off-screen and scaling rendering technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL ES is a complex API that requires an in-depth understanding to get the
    best performance and quality. This is even true with OpenGL ES 3, which we have
    not covered here, that is available since Android KitKat. Do not hesitate to have
    a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: The Openg ES and GLSL specification at [http://www.khronos.org/registry/gles/](http://www.khronos.org/registry/gles/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Developer website at [http://developer.android.com/guide/topics/graphics/opengl.html](http://developer.android.com/guide/topics/graphics/opengl.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the knowledge acquired here, the road to OpenGL ES 2 or 3 is at a perfectly
    walkable distance! So now, let's discover how to reach the fourth dimension, the
    musical one, with OpenSL ES in our next chapter.
  prefs: []
  type: TYPE_NORMAL
