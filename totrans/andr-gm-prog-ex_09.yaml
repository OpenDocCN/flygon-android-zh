- en: Chapter 9. Asteroids at 60 FPS with OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the final project. Over the course of the next three chapters, we
    will build an Asteroids-like game using the OpenGL ES 2 graphics API. If you are
    wondering exactly what OpenGL ES 2 is, then we will discuss the details later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a very simple but fun and challenging game, where we can draw
    and animate hundreds of objects at a time, even on quite old Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: With OpenGL, we will take our drawing efficiency to a much higher level, and
    with some not-too-tricky math, our movement and collision detection will be greatly
    enhanced compared to our previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a basic working OpenGL ES 2 engine
    drawing our simple but temporarily static spaceship to the screen; at 60 FPS or
    higher.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have never seen or played the '80s arcade hit (released in November 1979)
    Asteroids, why not go and check out a clone of it or a video now?
  prefs: []
  type: TYPE_NORMAL
- en: Free web game at [http://www.freeasteroids.org/](http://www.freeasteroids.org/).
  prefs: []
  type: TYPE_NORMAL
- en: On YouTube at [https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo).
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss exactly what we intend to build.
  prefs: []
  type: TYPE_NORMAL
- en: Asteroids simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game will be set in a four directional scrolling world that the player will
    be able to traverse while hunting for asteroids. The world will be enclosed in
    a rectangular border to keep the asteroids from drifting off too far, and the
    border will also serve as another hazard for the player to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: The game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse our `InputController` class with a few simple modifications and
    can even keep the same button layout. As we will see, however, we will draw the
    buttons on screen in a very different manner to our retro platformer. Also, instead
    of walking left and right, the player will rotate the ship left and right through
    360 degrees. The jump button will become a thrust toggle switch to turn on and
    off forward motion, and the shoot button will remain just that. We will also have
    the pause button in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an asteroid hits the border, it will bounce back into the game world. If
    the player hits the border, a life will be lost and the ship will respawn in the
    center of the screen. If an asteroid hits the ship this will be fatal too.
  prefs: []
  type: TYPE_NORMAL
- en: The player will start with three lives and must clear the asteroids simulator
    of all asteroids. The HUD will show a tally of the remaining asteroids and lives.
    If the player clears all the asteroids, then the next wave will start with more
    than the last. They will also move a little faster. Each wave cleared will be
    rewarded with an extra life.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement these rules as we proceed through the project.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES 2 is the second major version of the **Open Graphics Library** (**OpenGL**)
    for embedded systems. It is the mobile incarnation of OpenGL for desktop systems.
  prefs: []
  type: TYPE_NORMAL
- en: Why use it and how does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL runs as a native process, not on the Dalvik virtual machine like the
    rest of our Java. This is one of the reasons it is super fast. The OpenGL ES API
    takes away all of the complexity of interacting with native code, and OpenGL itself
    also provides very efficient and fast algorithms within its native code base.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of OpenGL was completed in 1992\. The point is that even back
    then OpenGL used arguably the most efficient code and algorithms to draw graphics.
    Now, more than 20 years on, it has been continually refined and improved as well
    as adapted to work with the latest graphics hardware, both mobile and desktop.
    All the mobile GPU manufacturers specifically design their hardware to be compatible
    with the latest version of OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to improve on OpenGL ES is, therefore, probably a fool's errand.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another viable Graphics API option when developing exclusively for
    Windows devices called DirectX.
  prefs: []
  type: TYPE_NORMAL
- en: What is neat about Version 2?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first version of OpenGL ES certainly impressed at the time. I remember almost
    falling off my chair when I first played a 3D shooter on a phone! Now this is
    of course commonplace. However, compared to the desktop version of OpenGL, OpenGL
    ES 1 had a major drawback.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 1 had, what is known as, a fixed function pipeline. The geometry to
    draw went into the GPU and it was drawn, but any further manipulation of individual
    pixels needed to take place before OpenGL ES took over the drawing of a frame
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with OpenGL ES 2, we have access to what is called a programmable pipeline.
    That is, we can send our graphics off to be drawn, but we can also write code
    that runs on the GPU that is capable of manipulating each and every pixel independently.
    This is a very powerful feature, although we will not get to explore it in much
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: This extra code that runs on the GPU is called a **shader** program. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually called a **fragment shader**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actually, we can do better than even pixel manipulation. A fragment is not
    necessarily a pixel. It depends on the hardware and the specific nature of the
    graphics being processed. It can be more than one pixel or a sub-pixel: one light
    of several that makes up a pixel in the screen hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of OpenGL ES 2 for simple games like this is that you must
    provide at least one vertex and one fragment shader, even if you are not going
    to do a whole lot with them. As we will see, however, this is not very difficult.
    Although we will not be exploring shaders in any depth, we will write some shader
    code using **GL Shader Language** (**GLSL**) and get a glimpse at the possibilities
    they offer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the power of programmable graphics pipelines and shaders is just too exciting
    to leave for another day, then I can highly recommend *GLSL Essentials* by Jacobo
    Rodríguez.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
  prefs: []
  type: TYPE_NORMAL
- en: The book explores OpenGL shaders on the desktop and is highly accessible to
    any reader with basic programming knowledge and a willingness to learn a different
    language (GLSL), yet one with some syntax similarities to Java.
  prefs: []
  type: TYPE_NORMAL
- en: How will we be using OpenGL ES 2?
  prefs: []
  type: TYPE_NORMAL
- en: How we will use OpenGL ES 2?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and also combine these elements
    to make the complex graphics that we see in today's modern mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of each type of element (points, lines, and triangles) that
    are collectively referred to as primitives.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be using textures on this project. Fortunately, the appearance of
    untextured primitives is appropriate for building our Asteroids-like game.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to primitives, Open GL uses matrices. **Matrices** are a method
    and structure for performing arithmetic. This arithmetic can range from extremely
    simple high-school level calculations to move (translate) a coordinate or it can
    be quite complex to perform more advanced mathematics to convert our game world
    coordinates into OpenGL screen coordinates that the GPU can use.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that both the matrices and methods to use them are entirely provided
    by the OpenGL API. This means that we just have to learn what methods do which
    graphical manipulation and do not have to concern ourselves with the potentially
    complex math that goes on behind the scenes (on the GPU).
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn about shaders, primitives, and matrices in OpenGL is to
    go ahead and start using them.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we start off with our `Activity` class, which as before is the entry point
    into our game. Create a new project and in the **Application Name** field enter
    `C9 Asteroids`. Choose **Phones and tablets**, then **Blank Activity** when prompted.
    In the **Activity Name** field type `AsteroidsActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously you don't have to follow my exact naming choices but just remember
    to make the minor alterations in code to reflect your own naming choices.
  prefs: []
  type: TYPE_NORMAL
- en: You can delete `activity_asteroids.xml` from the `layout` folder. You can also
    delete all the code within the `AsteroidsActivity.java` file. Just leave the package
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the layout to landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we did for the previous two projects, we will make sure the game runs
    in landscape mode only. We will make our `AndroidManifest.xml` file, force our
    `AsteroidsActivity` class to run with a full screen, and lock it to a landscape
    orientation. Let''s make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately, type or copy and paste these two lines to make `PlatformActivity`
    run in full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can move on to implementing our Asteroids simulator game with OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we have our familiar `Activity` class. The only thing that is
    new here is the type of our view class. We declare a member called `asteroidsView`
    of type `GLSurfaceView`. This is the class that will provide us with easy access
    to OpenGL. We will see exactly how very soon. Note that all we do is initialize
    `GLSurfaceView` by passing in the `Activity` context and the screen resolution
    that we obtain in the usual manner. Implement the `AsteroidsActivity` class as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will get to see some OpenGL code.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will implement the `GLSurfaceView` class. Actually, this isn't where
    the real action will take place but it does allow us to attach an OpenGL renderer.
    This is a class that implements the `Renderer` interface. As well as in this critical
    `Renderer`, the `GLSurfaceView` class enables us to override the `onTouchListener`
    method that will allow us to detect player input in the same way that `SurfaceView`
    did in the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio does not auto-import or even suggest all of the OpenGL imports
    required. Therefore, I included all of the imports for some classes in the code
    listings. In addition, you will note that sometimes we use static imports. This
    will make the code more readable too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code that follows, we declare and initialize a new object of type `GameManager`
    that we will implement soon. We set the OpenGL version to two by calling `setEGLContextClientVersion(2)`,
    and we set our vital renderer object by calling `setRenderer()` and passing in
    our `GameManager` object. Create a new class called `AsteroidsView` and implement
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can take a look at what is involved in our `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: A class to manage our game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class will control things like the level the player is on, the number of
    lives, as well as things like the overall size of the game world. It will evolve
    a little as the project progresses, but it will remain quite simple in comparison
    to the combined depth of the LevelManager and PlayerState classes from the previous
    project, although it effectively replaces both.
  prefs: []
  type: TYPE_NORMAL
- en: In the code that follows, we declare `int` members to hold the width and height
    of the game world; we can make this much bigger or smaller as we see fit. We keep
    track of the games status with the Boolean `playing`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GameManager` class also needs to know the height and width of the screen
    in pixels, and this information is passed in to the constructor when the object
    is initialized back in the `AsteroidsView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the `metresToShowX` and `metresToShowY` member variables. These probably
    sound familiar from our `Viewport` class from the last project. These variables
    will be used for exactly the same thing: defining the current viewable area of
    the game world. This time, however, OpenGL will take care of what objects to clip
    before drawing (using a matrix). We will soon see where this happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that although OpenGL takes care of clipping and scaling the area of the
    game world that we want to show, it doesn't have any effect on which objects are
    updated each frame. As we will see, however, this is just what we want for this
    game because we want all our objects to update themselves each frame, even when
    they are offscreen. Therefore, no `Viewport` class is necessary for this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we want a convenient way to pause and unpause the game, and we provide
    this functionality with the `switchPlayingStatus` method. Create a new class called
    `GameManager` and implement it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can now take our first look at these all powerful shaders and how we will
    manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing simple shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An application can have many shaders. We can then attach different shaders to
    different game objects to create the desired effects.
  prefs: []
  type: TYPE_NORMAL
- en: We will only have one vertex and one fragment shader in this game. However,
    when you see how to attach a shader to primitives, it will be plain that it is
    simple to have more shaders.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need the code for the shader that will be executed in the GPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we need to compile that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to link together the two compiled shaders into a GL program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we implement this next simple class, we will see how we can bundle up this
    functionality into a single method call, which can be made by an object from our
    game and have the ready-to-run GL program returned to the game object. When we
    build our `GameObject` class later in the chapter, we will see how we use this
    GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement the necessary three steps in a new class. Create
    a new class and call it `GLManager`. Add the static imports as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add some public static final member variables that we can use
    in our `GameObject` class later in the chapter. Although we will see exactly how
    they work when we get around to using them, here is a quick preliminary explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '`COPONENTS_PER_VERTEX` is the number of values that will be used to represent
    a single vertex (point) in our primitives that will make up our game objects.
    As you can see, we initialize this to three coordinates: *x*, *y*, and *z*.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have `FLOAT_SIZE`, which is initialized to `4`. This is the number of
    bytes in a Java float. As we will see soon, OpenGL likes all its primitives passed
    into it in the form of a `ByteBuffer`. We need to make sure we are precise about
    where in the `ByteBuffer` each piece of information is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare `STRIDE` and initialize it to `COMPONENTS_PER_VERTEX * FLOAT_SIZE`.
    As OpenGL uses the float type to hold virtually all of the data it works with,
    `STRIDE` now equals the size in bytes of the data that represents a single vertex
    of an object. Go ahead and add these members at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be utilized. Here, we declare and initialize some strings that
    we can use to refer to these variables more cleanly in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion of these types is beyond the scope of this book, but simply explained
    they will represent a matrix (`u_matrix`), a location (`a_position`), and a color
    (`u_Color`). We will see examples of the actual GLSL types these variables are
    in our shader code very soon.
  prefs: []
  type: TYPE_NORMAL
- en: After the strings, we declare three `int` types. These three public static (but
    not final) members will be used to store the location of there namesake types
    within our shaders. This allows us to manipulate the values within the shader
    program before we give OpenGL the final instruction to draw our primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At last, we come to our GLSL code that is a vertex shader packed up in a string.
    Note that we declare a variable called `u_Matrix` of type uniform `mat4` and `a_Position`
    of type attribute `vec4`. We will see in our `GameObject` class later how to get
    the locations of these variables to enable us to pass in values for them from
    our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line in the code that starts with `void main()` is were the actual shader
    code executes from. Note that `gl_position` is assigned the value of the product
    of the two variables we just declared. Also `gl_PointSize` is assigned the value
    of `3.0`. This will be the size we draw all our point primitives. Enter the code
    for the vertex shader right after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will implement the fragment shader. A few things are happening here.
    First, the line precision `mediump` float tells OpenGL to draw with medium precision
    and therefore medium speed. Then we can see our variable `u_Color` being declared
    to type uniform `vec4`. We will see how we can pass a `color` value to this variable
    in the `GameObject` class soon.
  prefs: []
  type: TYPE_NORMAL
- en: When execution begins at `void main()`, we simply assign `u_Color` to `gl_FragColor`.
    So, whatever color is assigned to `u_Colour`, all the fragments will be that color.
    Just after the fragment shader, we declare an `int` called `program` that will
    act as a handle to our GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the fragment shader right after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a getter method that returns a handle to the GL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This next method may look complex, but all it does is return a compiled and
    linked program to the caller. It does so by calling the OpenGL's `linkProgram`
    method with `compileVertexShader()` and `compileFragmentShader()` as arguments.
    Next, we see these two new methods and that all they need to do is call our method
    `compileShader()` with the OpenGL constant representing the type of shader and
    the appropriate string that holds the matching shader GLSL code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the three methods that we have just discussed into the `GLManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see what happens when our methods called `compileShader()`. First, we
    create a handle to a shader based on the `type` parameter. Then, we pass in that
    handle and the code to `glShaderSource()`. Finally, we compile the shader with
    `glCompileShader()` and return a handle to the calling method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the final step in the process. We create an empty program with
    `glCreateProgram()`. Then we attach each of the compiled shaders in turn with
    `glAttachShader()`, and finally link them into a program we can actually use with
    `glLinkProgram()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that we created a program and we have access to it via its handle and the
    `getProgram` method. We also have access to all those public static members we
    created, so we will be able to tinker with the variables in the shader programs
    from our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The game's main loop – the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will see where the real meat of our code will go. Create a new class
    and call it `AsteroidsRenderer`. This is the class that we attached as our renderer
    to the `GLSurfaceView`. Add the import statements as follows, noting that some
    of them are static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we will build the class. The first thing to note that we have mentioned
    before is that the class implements `Renderer`, so we need to override three methods.
    They are `onSurfaceCreated()`, `onSurfaceChanged()`, and `onDrawFrame()`. Also,
    into this class, we will initially add a constructor to get everything set up,
    a `createObjects` method where we will eventually initialize all our game objects,
    an `update` method were we will update all our objects each frame, and a `draw`
    method were we will draw all our objects each frame.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore and explain each method as we implement it, and we will also
    see how our methods fit in to the OpenGL renderer system, which dictates the flow
    of this class.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we have some member variables that are worth looking at quite
    closely.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean debugging will be used to toggle output to the console on and off.
    The `frameCounter`, `averageFPS`, and `fps` variables will not only be used for
    checking what frame rates we are reaching but also for passing to our game objects
    that will update themselves based on the elapsed time each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Our first really interesting variable is the float array `viewportMatrix`. As
    the name suggests, it will hold a matrix that OpenGL can use to calculate the
    viewport into our game world.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `GameManager` to hold a reference to the `GameManager` object, that
    `AsteroidsView` passed into this class's constructor. Finally, we have two `PointF`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will initialize the `PointF` objects in the constructor and use them for
    a few different things to avoid dereferencing any objects in the main game loop.
    When the garbage collector starts cleaning up discarded objects, even OpenGL will
    slow down. Avoiding summoning the garbage collector will be a goal for the entire
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the member variables at the top of the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our constructor, where we initialize our `GameManager` reference from
    the parameter and create our two handy `PointF` objects ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the first overridden method. It is called every time a `GLSurfaceView`
    class with attached renderer is created. We call `glClearColor()` to set which
    color OpenGL will use each time it clears the screen. We then build our shader
    program using our `GLManager.buildProgram()` method and call our `createObjects`
    method that we will code soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This next overridden method is called once after `onSurfaceCreated()` and any
    time the screen orientation changes. Here, we call the `glViewport()` method to
    tell OpenGL the pixel coordinates to map the OpenGL coordinate system onto.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL coordinate system is very different from the pixel coordinates we
    are used to deal with in the previous two projects. The center of the screen is
    0,0, the left and bottom are -1, and the top and right are 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![The game''s main loop – the renderer](img/B04322_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding situation is further complicated by the fact that most screens
    are not square, yet the range -1 to 1 must represent both *x* and *y* axes. Fortunately,
    our `glViewport()` has dealt with this for us.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we see in this method is calling the `orthoM` method with our
    `viewportMatrix` as the first parameter. OpenGL will now prepare `viewportMatrix`
    for use within OpenGL itself. The method `orthoM()` creates a matrix to convert
    coordinates into an orthographic view. If our coordinates are three-dimensional,
    it will have the effect of making all the objects appear the same distance away.
    As we are making a two-dimensional game, this is also suitable for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the `onSurfaceChanged` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `createObjects` method and, as you can see, we create an object
    of type `SpaceShip` and pass in the map height and width to the constructor. We
    will build the `SpaceShip` class and its parent class `GameObject` later in this
    chapter. Enter the `createObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the overridden `onDrawFrame` method. It is called continuously by the
    system. We can control when this is called by setting a render mode when we attach
    the `AsteroidsRenderer` to the view but the default OpenGL controlled continuous
    calling is exactly what we need.
  prefs: []
  type: TYPE_NORMAL
- en: We set `startFrameTime` to whatever the current system time is. Then, if `isPlaying()`
    returns `true`, we call our soon-to-be-implemented `update` method. Then, we call
    `draw()`, which will tell all of our objects to draw themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We then update `timeThisFrame` and `fps` optionally outputting the average frames
    per second, every 100 frames, if we are debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that OpenGL will call `onDrawFrame()` up to hundreds of times per
    second. We will conditionally call our `update` method each time as well as call
    our `draw` method. We have effectively implemented our game loop apart from the
    actual `draw` and update methods themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `onDrawFrame` method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `update` method, leave an empty body for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we come to our `draw` method, which is called once per frame from the `onDrawFrame`
    method. Here, we load up the ships current location into one of our handy `PointF`
    objects. Clearly, as we haven't implemented our `SpaceShip` class yet, this method
    call will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do in `draw()` is quite interesting. We modify our `viewportMatrix`
    based on the current location in the game world and the values assigned to `metresToShowX`
    and `metresToShowY`. Simply, we are centering on wherever the ship is and extending
    out by half the distance we wish to show in all four directions. Remember that,
    this happens in every frame, so our viewport will constantly follow the player
    ship.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `glClear()` to clear the screen with the color we set in `onSurfaceCreated()`.
    The last thing we do in `draw()` is call a `draw` method on our `SpaceShip` object.
    This implies quite a fundamental design change from both of our previous games.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned this already, but here we can see it in action: each object will
    draw itself. Also, notice that we pass in our newly configured `viewportMatrix`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can build our `GameObject` super class, closely followed by its first
    child, `SpaceShip`. We will see how these objects will manage to use OpenGL to
    draw themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Building an OpenGL-friendly, GameObject super class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive straight into the code. As we will see, this `GameObject` will have
    a lot in common with the `GameObject` class from the previous project. The most
    significant difference will be that this latest `GameObject` will of course draw
    itself using a handle to the GL program, primitive (vertex) data from a child
    class, and the viewport matrix contained in `viewportMatrix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `GameObject`, and enter these import statements,
    noting again that that some of them are static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of member variables, many are self-explanatory and commented
    just to refresh our memories, but there are some totally new ones as well.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have an `enum` to represent each type of `GameObject` we will
    create. The reason for this is we will draw some objects as points, some as lines,
    and one as a triangle. The way that we use OpenGL is consistent between different
    types of primitive; hence, it is why we have bundled the code into this parent
    class. However, the final call to draw the primitive varies dependent on the type
    of primitive. We can use the `type` variable in a `switch` statement to execute
    the correct type of a `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an `int numElements` and `numVertices` that holds the number of
    points that make up any given `GameObject`. These will be set from the child class
    as we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: We have another float array called `modelVertices`, which will hold all the
    vertices that make up a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the first batch of member variables in the `GameObject` class and take
    a look at the comments to refresh your memory or make clear what the various members
    will eventually be used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add another batch of member variables. First, and most notably,
    we have a `FloatBuffer` called `vertices`. As we know, OpenGL executes in native
    code and `FloatBuffers` are how it likes to consume its data. We will see how
    we pack all our vertices into this `FloatBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use all the public static members from our `GLManager` class to
    help us get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the second most interesting new member where OpenGL is concerned is
    we have another three float arrays called `modelMatrix`, `viewportModelMatrix`,
    and `rotateViewportModelMatrix`. These will be instrumental in helping OpenGL
    to draw the `GameObject` class exactly as required. We will examine exactly how
    they are initialized and used when we get to the `draw` method of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a bunch of members that hold different angles and rotation rates.
    How we use and update these in order to inform OpenGL of the orientation of our
    objects, we will see soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We now implement the constructor. First, we check if we have previously compiled
    the shaders, because we only need to do it once. If we haven't, this is what happens
    inside the `if(glProgarm == -1)` block.
  prefs: []
  type: TYPE_NORMAL
- en: We call `setGLProgram()` followed by `glUseProgram()` with `glProgram` as the
    argument. That is all we have to do, `GLManager` does the rest and our OpenGL
    program is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on, however, we save the locations of our key shader variables
    by calling the respective methods (`glGetUniformLocation()` and `glGetAttrtibuteLocation`)
    to get their locations within our GL program. We will see in the `draw` method
    of this class how we use those locations to manipulate values within the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we set `isActive` to `true`. Enter this method into the `GameObject`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a few getters and setters including `getWorldLocation()`, which
    we called from the `draw` method in `AsteroidsRenderer` and `setGLProgram()`.
    This uses the `GLManager` class's static method `getGLProgram()` to get the handle
    to our GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter all these methods into the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The next method, `setVertices()` is a vital step in preparing an object to be
    drawn by OpenGL. In each of our child classes, we will build an array of float
    types to represent the vertices that make up the shape of the game object. Each
    game object will obviously be different in shape, but the `setVertices` method
    does not need to appreciate the difference, it just needs the data.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the next block of code, the method receives a float array as
    a parameter. It then stores the number of elements that is equal to the length
    of the array in `numElements`. Note that the number of elements is different from
    the number of vertices the elements represent. It takes three elements (*x*, *y*,
    and *z*) to make one vertex. Therefore, we can store into `numVertices` the correct
    value by dividing `numElements` by `ELEMENTS_PER_VERTEX`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can actually initialize up our `ByteBuffer` by calling `allocateDirect()`
    and passing in our newly initialized variables along with `FLOAT_SIZE`. The `ByteOrder.nativeOrder`
    method simply detects if the particular system's endianness, and `asFloatBuffer()`
    tells `ByteBuffer` the type of data that will stored. We can now store our array
    of vertices into our vertices `ByteBuffer` by calling `vertices.put(modelVertices)`.
    This data is now ready to be passed to OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn more about endianness, take a look at this Wikipedia article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Endianness](http://en.wikipedia.org/wiki/Endianness)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `setVertices` method into the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we get to see how we actually draw the contents of our `ByteBuffer`. At
    a glance, the following code may look complex, but when we discuss the nature
    of the data in our `ByteBuffer` and the steps that OpenGL goes through to draw
    this data, we will see that it is actually quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: As we have not written the code for our first `GameObject` child class, there
    is one key thing to point out. The vertices that represent the shape of a game
    object are zero based on its own center.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenGL coordinate system has **0,0** as its center but, to make it clear,
    this is not related. This is called model space. The next image is a representation
    of our spaceship, in model space, that we will soon create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an OpenGL-friendly, GameObject super class](img/B04322_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is this data that is contained within our `ByteBuffer`. This data takes no
    account of orientation (is the ship or asteroid rotated), it takes no account
    of its position in the game world and, as a reminder, it is totally unrelated
    to the OpenGL coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, before we draw our `ByteBuffer`, we need to convert this data, or,
    more accurately, we need to prepare an appropriate matrix, which we will pass
    into OpenGL with the data so that OpenGL will know how to use or convert the data.
  prefs: []
  type: TYPE_NORMAL
- en: I have split the `draw` method up into six chunks to talk about how we do this.
    Note that our `viewPort` matrix is prepared in our `AsteroidsRenderer` class's
    `draw` method, which is centered upon the location of the ship and based around
    the proportion of game world we want to show and is passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we call `glUseProgram()` and pass in the handle to our program. Then
    we set the internal pointer of our `ByteBuffer` to the start with `vertices.position(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `glVertexAttributePointer` method uses our `aPositionLocation` variable
    along with our `GLManager` static constants and of course the `vertices` `ByteBuffer`
    to associate our vertices with the `aPosition` variable in the vertex shader.
    Finally, for this chunk of code, we tell OpenGL to enable the attribute array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we put our matrices to work. We create an identity matrix out of our `modelMatrix`
    array by calling `setIndentityM()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will see, we are going to be using and combining quite a lot of matrices.
    An identity matrix acts as a starting point or container on which we can build
    a matrix, which combines all the transformations that we need to occur. A very
    simple but not entirely accurate way of thinking about an identity matrix is that
    it is like the number 1\. When you multiply by an identity matrix, it doesn't
    cause any alteration to the other part of the sum. However, the answer is correct
    for moving on to the next part of the equation. If this is annoying you and you
    want to know more, take a look at these really quick tutorials on matrices and
    the identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pass our new `modelMatrix` into the `translateM` method. Translate
    is math speak for move. Look closely at the arguments passed into `translateM()`.
    We are passing in the *x* any *y* world locations of the object. This is how OpenGL
    knows where the object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We know that OpenGL has a matrix to translate our object to its world location.
    It also has a `ByteBuffer` class with the model space coordinates, but how does
    it convert translated model space coordinates to our viewport drawn using OpenGL
    coordinate system?
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the viewport matrix, which is modified by each frame and passed into
    this method. All we need to do is multiply `viewportMatrix` and the recently translated
    `modelMatrix` together using `multiplyMM()`. This method creates the combined
    or multiplied matrix and stores the result in `viewportModelMatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done creating our matrix. The only other possible distortion that
    OpenGL will need to make to the vertices in the `ByteBuffer` is to rotate them
    to the `facingAngle` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a rotation matrix appropriate to the current object's facing
    angle and storing the result back in `modelMatrix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we combine or multiply the newly rotated `modelMatrix` with our `viewportModelMatrix`
    and store the result in `rotateViewportModelMatrix`. This is our final matrix
    that we will pass into the OpenGL system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we pass in the matrix using the `glUniformMatrix4fv()` method and use the
    `uMatrixLocation` variable (which is the location of the matrix-related variable
    in the vertex shader) and our final matrix in the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We also choose the color by calling `glUniform4f()` with the `uColorLocation`
    and an RGBT (Red, Green, Blue, Transparency) value. All values are set to 1.0,
    so the fragment shader will draw white.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we switch based on the object type and draw either points, lines,
    or triangle primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the fundamentals of our `GameObject` class, we can make a class
    to represent our spaceship and draw it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class is nice and simple, although it will evolve with the project. The
    constructor receives the starting location within the game world. We set the ship's
    type and world location using the methods from the `GameObject` class, and we
    set a width and height.
  prefs: []
  type: TYPE_NORMAL
- en: We declare and initialize some variables to simplify the initialization of the
    model space coordinates, and then we go ahead and initialize a float array with
    three vertices that represent the triangle that is our ship. Note that the values
    are based around a center of *x = 0* and *y = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we do next is, call `setVertices()`, and `GameObject` will prepare the
    `ByteBuffer` ready for OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can see the fruits of our labor.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing at 60 + FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In three simple steps, we will be able to glimpse our spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `SpaceShip` object to the `GameManager` member variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a call to the new `SpaceShip()` to the `createObjects` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the call to draw the spaceship in each frame in the `draw` method of `AsteroidsRenderer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the game and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing at 60 + FPS](img/B04322_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not exactly impressive visuals, but it is running between 67 and 212 frames
    per second in debug mode while outputting to the console on an ageing Samsung
    Galaxy S2 phone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing at 60 + FPS](img/B04322_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will be our aim throughout the project to add hundreds of objects and keep
    the frames per second over 60.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the book's reviewers reported frame rates in excess of 1000 per second
    on a Nexus 5! It will therefore be worth considering a maximum frame rate locking
    strategy to save battery life if you were planning to release this to the Google
    Play store.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a drawing system was a little bit long-winded. However, now that
    it is done, we can churn out new objects much more easily. All we have to do is
    define the type and the vertices, then we can draw them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: It is because of this ground work that the next chapter will be much more visually
    rewarding. Next, we will create blinking stars, a game world border, spinning
    and moving asteroids, whizzing bullets, and a HUD, as well as add full controls
    and motion to the spaceship.
  prefs: []
  type: TYPE_NORMAL
