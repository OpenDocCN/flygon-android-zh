["```java\nclass iIntrusiveCounter\n{\nprivate:\n  std::atomic<long> m_RefCounter;\npublic:\n  iIntrusiveCounter( ) : m_RefCounter( 0 ) {}\n  virtual ~iIntrusiveCounter( ) {}\n  long GetReferenceCounter( ) const volatile \n  { return m_RefCounter; }\n```", "```java\n  void IncRefCount( )\n  {\n    m_RefCounter.fetch_add( 1, std::memory_order_relaxed );\n  }\n```", "```java\n  void DecRefCount()\n  {\n    if ( m_RefCounter.fetch_sub( 1, std::memory_order_release ) == 1 )\n    {\n```", "```java\n      std::atomic_thread_fence( std::memory_order_acquire );\n```", "```java\n      delete this;\n    }\n  }\n};\n```", "```java\ntemplate <class T> class clPtr\n{\npublic:\n  /// default constructor\n  clPtr(): FObject( 0 ) {}\n  /// copy constructor\n  clPtr( const clPtr& Ptr ): FObject( Ptr.FObject )\n  {\n    LPtr::IncRef( FObject );\n  }\n```", "```java\n  /// move constructor\n  clPtr( clPtr&& Ptr :): FObject( Ptr.FObject )\n  {\n    Ptr.FObject = nullptr;\n  }\n  template <typename U> clPtr( const clPtr<U>& Ptr )): FObject( Ptr.GetInternalPtr() )\n  {\n    LPtr::IncRef( FObject );\n  }\n```", "```java\n  clPtr( T* const Object ): FObject( Object )\n  {\n    LPtr::IncRef( FObject );\n  }\n```", "```java\n  ~clPtr()\n  {\n    LPtr::DecRef( FObject );\n  }\n```", "```java\n  /// check consistency\n  inline bool IsValid() const\n  {\n    return FObject != nullptr;\n  }\n  inline bool IsNull() const\n  {\n    return FObject == nullptr;\n  }\n```", "```java\n  /// assignment of clPtr\n  clPtr& operator = ( const clPtr& Ptr )\n  {\n    T* Temp = FObject;\n    FObject = Ptr.FObject;\n    LPtr::IncRef( Ptr.FObject );\n    LPtr::DecRef( Temp );\n    return *this;\n  }\n```", "```java\n  clPtr& operator = ( clPtr&& Ptr )\n  {\n    FObject = Ptr.FObject;\n    Ptr.FObject = nullptr;\n    return *this;\n  }\n```", "```java\n  inline T* operator -> () const\n  {\n    return FObject;\n  }\n```", "```java\n  inline operator clProtector* () const\n  {\n    if ( !FObject ) return nullptr;\n    static clProtector Protector;\n    return &Protector;\n  }\n```", "```java\nprivate:\n  class clProtector\n  {\nprivate:\n    void operator delete( void* ) = delete;\n  };\n```", "```java\npublic:\n  /// cast\n  template <typename U> inline clPtr<U> DynamicCast() const\n  {\n    return clPtr<U>( dynamic_cast<U*>( FObject ) );\n  }\n```", "```java\n  template <typename U> inline bool operator == ( const clPtr<U>&Ptr1 ) const\n  {\n    return FObject == Ptr1.GetInternalPtr();\n  }\n  template <typename U> inline bool operator == ( const U* Ptr1 )const\n  {\n    return FObject == Ptr1;\n  }\n  template <typename U> inline bool operator != ( const clPtr<U>&Ptr1 ) const\n  {\n    return FObject != Ptr1.GetInternalPtr();\n  }\n```", "```java\n  inline T* GetInternalPtr() const\n  {\n    return FObject;\n  }\n```", "```java\n  inline void Drop()\n  {\n    FObject = nullptr;\n  }\n```", "```java\n  inline void Clear()\n  {\n    *this = clPtr<T>();\n  }\n```", "```java\nprivate:\n  T* FObject;\n};\n```", "```java\nauto p = new clSomeObject( a, b, c );\n```", "```java\nauto p = std::make_shared<clSomeObject>( a, b, c );\n```", "```java\ntemplate< class T, class... Args > clPtr<T> make_intrusive( Args&&... args )\n{\n  return clPtr<T>( new T( std::forward<Args>( args )... ) );\n}\n```", "```java\nauto p = make_intrusive<clSomeObject>( a, b, c );\n```", "```java\nclass iThread\n{\n```", "```java\npublic:\n  enum LPriority\n  {\n    Priority_Idle         = 0,\n    Priority_Lowest       = 1,\n    Priority_Low          = 2,\n    Priority_Normal       = 3,\n    Priority_High         = 4,\n    Priority_Highest      = 5,\n    Priority_TimeCritical = 6\n  };\n```", "```java\n  iThread(): FThreadHandle( 0 ), FPendingExit( false )\n  {}\n  virtual ~iThread()\n  {}\n```", "```java\n  void Start()\n  {\n    void* ThreadParam = reinterpret_cast<void*>( this );\n    #ifdef _WIN32\n      unsigned int ThreadID = 0;\n      FThreadHandle = ( uintptr_t )_beginthreadex( nullptr, 0, &EntryPoint, ThreadParam, 0, &ThreadID );\n    #else\n      pthread_create( &FThreadHandle, nullptr, EntryPoint, ThreadParam );\n      pthread_detach( FThreadHandle );\n    #endif\n  }\n```", "```java\nprivate:\n  thread_handle_t FThreadHandle;\n  std::atomic<bool> FpendingExit;\n```", "```java\n  #ifdef _WIN32\n    #define THREAD_CALL unsigned int __stdcall\n  #else\n    #define THREAD_CALL void*\n  #endif\n    static THREAD_CALL EntryPoint( void* Ptr );\n```", "```java\nprotected:\n  virtual void Run() = 0;\n  virtual void NotifyExit() {};\n  thread_handle_t GetHandle() { return FThreadHandle; }\n```", "```java\n  void Exit( bool Wait )\n  {\n    FPendingExit = true;\n    NotifyExit();\n    if ( !Wait ) { return; }\n```", "```java\n    if ( GetCurrentThread() != FThreadHandle )\n    {\n```", "```java\n      #ifdef _WIN32\n        WaitForSingleObject(( HANDLE )FThreadHandle, INFINITE );\n        CloseHandle( ( HANDLE )FThreadHandle );\n      #else\n        pthread_join( FThreadHandle, nullptr );\n      #endif\n    }\n  }\n```", "```java\n  native_thread_handle_t iThread::GetCurrentThread()\n  {\n    #if defined( _WIN32)\n      return GetCurrentThreadId();\n    #elif defined( ANDROID )\n      return gettid();\n    #else\n      return pthread_self();\n    #endif\n  }\n```", "```java\n  THREAD_CALL iThread::EntryPoint( void* Ptr )\n  {\n    iThread* Thread = reinterpret_cast<iThread*>( Ptr );\n    if ( Thread )\n    {\n      Thread->Run();\n    }\n    #ifdef _WIN32\n      _endthreadex( 0 );\n      return 0;\n    #else\n      pthread_exit( 0 );\n    return nullptr;\n    #endif\n  }\n```", "```java\n  void iThread::SetPriority( LPriority Priority )\n  {\n    #ifdef _WIN32\n      int P = THREAD_PRIORITY_IDLE;\n      switch(Priority)\n      {\n        case Priority_Lowest:\n          P = THREAD_PRIORITY_LOWEST; break;\n        case Priority_Low:\n          P = THREAD_PRIORITY_BELOW_NORMAL; break;\n        case Priority_Normal:\n          P = THREAD_PRIORITY_NORMAL; break;\n        case Priority_High:\n          P = THREAD_PRIORITY_ABOVE_NORMAL; break;\n        case Priority_Highest:\n          P = THREAD_PRIORITY_HIGHEST; break;\n        case Priority_TimeCritical:\n          P = THREAD_PRIORITY_TIME_CRITICAL; break;\n      }\n      SetThreadPriority( ( HANDLE )FThreadHandle, P );\n    #else\n```", "```java\n      int SchedPolicy = SCHED_OTHER;\n      int MaxP = sched_get_priority_max( SchedPolicy );\n      int MinP = sched_get_priority_min( SchedPolicy );\n      sched_param SchedParam;\n      SchedParam.sched_priority = MinP + (MaxP - MinP) / (Priority_TimeCritical - Priority + 1);\n      pthread_setschedparam( FThreadHandle, SchedPolicy, &SchedParam );\n    #endif\n  }\n```", "```java\n  class iTask: public iIntrusiveCounter\n  {\n  public:\n    iTask()\n    : FIsPendingExit( false )\n    , FTaskID( 0 )\n    , FPriority( 0 )\n    {};\n```", "```java\n    virtual void Run() = 0;\n```", "```java\n    virtual void Exit()\n    {\n      FIsPendingExit = true;\n    }\n    virtual bool IsPendingExit() const volatile\n    {\n      return FIsPendingExit;\n    }\n```", "```java\n    virtual void SetTaskID( size_t ID )\n    { FTaskID = ID; };\n    virtual size_t GetTaskID() const\n    { return FTaskID; };\n```", "```java\n    virtual void SetPriority( int P )\n    {\n      FPriority = P;\n    };\n    virtual int GetPriority() const\n    {\n      return FPriority;\n    };\n```", "```java\n  private:\n    std::atomic<bool> FIsPendingExit;\n    size_t FTaskID;\n    int FPriority;\n  };\n```", "```java\n  class clWorkerThread: public iThread\n  {\n  private:\n    std::list< clPtr<iTask> >   FPendingTasks;\n    clPtr<iTask>                FCurrentTask;\n    mutable tthread::mutex      FTasksMutex;\n    tthread::condition_variable FCondition;\n```", "```java\n    virtual void   AddTask( const clPtr<iTask>& Task )\n    {\n      tthread::lock_guard<tthread::mutex> Lock( FTasksMutex );\n      FPendingTasks.push_back( Task );\n      FCondition.notify_all();\n    }\n```", "```java\n    virtual size_t GetQueueSize() const\n    {\n      tthread::lock_guard<tthread::mutex> Lock( FTasksMutex );\n      return FPendingTasks.size() + ( FCurrentTask ? 1 : 0 );\n    }\n```", "```java\n    virtual bool   CancelTask( size_t ID )\n    {\n      if ( !ID ) { return false; }\n      tthread::lock_guard<tthread::mutex> Lock( FTasksMutex );\n```", "```java\n      if ( FCurrentTask && FCurrentTask->GetTaskID() == ID )\n        FCurrentTask->Exit();\n```", "```java\n      FPendingTasks.remove_if(\n        [ID]( const clPtr<iTask> T )\n        {\n          if ( T->GetTaskID() == ID )\n          {\n            T->Exit();\n            return true;\n          }\n          return false;\n        }\n      );\n```", "```java\n      FCondition.notify_all();\n      return true;\n    }\n```", "```java\n    virtual void CancelAll()\n    {\n      tthread::lock_guard<tthread::mutex> Lock( FTasksMutex );\n      if ( FcurrentTask )\n      {\n        FcurrentTask->Exit();\n      }\n      for ( auto& Task: FpendingTasks )\n      {\n        Task->Exit();\n      }\n      FpendingTasks.clear();\n      Fcondition.notify_all();\n    }\n```", "```java\n    virtual void Run()\n    {\n```", "```java\n    while ( !IsPendingExit() )\n    {\n```", "```java\n      FCurrentTask = ExtractTask();\n```", "```java\n      if ( FCurrentTask &&\n        !FCurrentTask->IsPendingExit())\n      FCurrentTask->Run();\n```", "```java\n      FCurrentTask = nullptr;\n    }\n  }\n```", "```java\n  clPtr<iTask> ExtractTask()\n  {\n    tthread::lock_guard<tthread::mutex> Lock( FTasksMutex );\n```", "```java\n    while ( FPendingTasks.empty() && !IsPendingExit() )\n      FCondition.wait( FTasksMutex );\n```", "```java\n    if ( FPendingTasks.empty() )\n      return clPtr<iTask>();\n```", "```java\n    auto Best = FPendingTasks.begin();\n```", "```java\n    for ( auto& Task : FPendingTasks )\n    {\n      if ( Task->GetPriority() >\n        ( *Best )->GetPriority() ) *Best = Task;\n    }\n```", "```java\n    clPtr<iTask> Result = *Best;\n    FPendingTasks.erase( Best );\n    Return Result;\n  }\n```", "```java\n  class iAsyncCapsule: public iIntrusiveCounter\n  {\n  public:\n    virtual void Invoke() = 0;\n  };\n```", "```java\n  class clAsyncQueue\n  {\n  private:\n    using CallQueue = std::vector< clPtr<iAsyncCapsule> >;\n    size_t FCurrentQueue;\n    std::array<CallQueue, 2> FAsyncQueues;\n    /// switched for shared non-locked access\n    CallQueue* FAsyncQueue;\n    tthread::mutex FDemultiplexerMutex;\n```", "```java\n  public:\n    clAsyncQueue()\n    : FDemultiplexerMutex()\n    , FCurrentQueue( 0 )\n    , FAsyncQueues()\n    , FAsyncQueue( &FAsyncQueues[0] )\n    {}\n```", "```java\n    virtual void EnqueueCapsule(\n      const clPtr<iAsyncCapsule>& Capsule )\n    {\n      tthread::lock_guard<tthread::mutex>\n        Lock( FDemultiplexerMutex );\n      FAsyncQueue->push_back( Capsule );\n    }\n```", "```java\n    virtual void DemultiplexEvents()\n    {\n```", "```java\n      CallQueue& LocalQueue = FAsyncQueues[ FCurrentQueue ];\n```", "```java\n      {\n        tthread::lock_guard<tthread::mutex>\n          Lock( FDemultiplexerMutex );\n        FCurrentQueue = ( FCurrentQueue + 1 ) % 2;\n        FAsyncQueue = &FAsyncQueues[ FCurrentQueue ];\n      }\n```", "```java\n      for ( auto& i: LocalQueue ) i->Invoke();\n      LocalQueue.clear();\n    }\n  };\n```", "```java\n  class clResponseThread: public iThread, public clAsyncQueue\n  {\n  public:\n    virtual void Run()\n    {\n      for (;;) DemultiplexEvents();\n    }\n  };\n```", "```java\n  class clRequestThread: public iThread\n  {\n  public:\n    explicit clRequestThread( clAsyncQueue* Target )\n    : FTarget(Target)\n    {}\n    virtual void Run()\n    {\n      int id = 0;\n      for (;;)\n      {\n        FTarget->EnqueueCapsule( make_intrusive<clTestCall>( id++ ) );\n        OS_Sleep( 500 );\n      }\n    }\n  private:\n    clAsyncQueue* FTarget;\n  };\n```", "```java\n  class clTestCall: public iAsyncCapsule\n  {\n  private:\n    int id;\n  public:\n    explicit clTestCall( int i ): id(i) {}\n    virtual void Invoke()\n    {\n      std::cout \"Test \" << id << std::endl;\n    }\n  };\n```", "```java\n  clResponseThread Responder;\n  clRequestThread Requester( &Responder );\n  Responder.Start();\n  Requester.Start();\n  for (;;) {}\n```", "```java\n  class clDownloadTask: public iTask\n  {\n  public:\n```", "```java\n    clDownloadTask( const std::string& URL,\n      size_t TaskID, \n      const clPtr<clDownloadCompleteCallback>& CB,\n      clDownloader* Downloader );\n```", "```java\n    virtual void Run() override;\n  private:\n    void Progress( double TotalToDownload,\n      double NowDownloaded,\n      double TotalToUpload,\n      double NowUploaded );\n    void InvokeCallback();\n  };\n```", "```java\n  void clDownloadTask::Run()\n  {\n```", "```java\n    clPtr<clDownloadTask> Guard( this );\n    CURL* Curl = curl_easy_init_P();\n```", "```java\n    curl_easy_setopt_P( Curl, CURLOPT_URL, FURL.c_str() );\n    curl_easy_setopt_P( Curl, CURLOPT_FOLLOWLOCATION, 1 );\n    curl_easy_setopt_P( Curl, CURLOPT_NOPROGRESS, false );\n    curl_easy_setopt_P( Curl, CURLOPT_FAILONERROR, true );\n    curl_easy_setopt_P( Curl, CURLOPT_MAXCONNECTS, 10 );\n    curl_easy_setopt_P( Curl, CURLOPT_MAXFILESIZE, DownloadSizeLimit );\n    curl_easy_setopt_P( Curl, CURLOPT_WRITEFUNCTION,\n      &MemoryCallback );\n    curl_easy_setopt_P( Curl, CURLOPT_WRITEDATA, this );\n    curl_easy_setopt_P( Curl, CURLOPT_PROGRESSFUNCTION, &ProgressCallback );\n    curl_easy_setopt_P( Curl, CURLOPT_PROGRESSDATA, this );\n```", "```java\n    curl_easy_setopt_P( Curl, CURLOPT_CONNECTTIMEOUT, 30 );\n```", "```java\n    curl_easy_setopt_P( Curl, CURLOPT_TIMEOUT, 600 );\n```", "```java\n    curl_easy_setopt_P( Curl, CURLOPT_SSL_VERIFYPEER, 0 );\n    curl_easy_setopt_P( Curl, CURLOPT_SSL_VERIFYHOST, 0 );\n    curl_easy_setopt_P( Curl, CURLOPT_HTTPGET, 1 );\n```", "```java\n    FCurlCode = curl_easy_perform_P( Curl );\n    curl_easy_getinfo_P( Curl, CURLINFO_RESPONSE_CODE, &FRespCode );\n    curl_easy_cleanup_P( Curl );\n```", "```java\n    if ( FDownloader ) { FDownloader->CompleteTask( this ); }\n  }\n```", "```java\n  void clDownloadTask::InvokeCallback()\n  {\n    tthread::lock_guard<tthread::mutex> Lock( FExitingMutex );\n```", "```java\n    if ( !IsPendingExit() )\n    {\n      if ( FCurlCode != 0 )\n      {\n        FResult = nullptr;\n      }\n```", "```java\n      if ( FCallback )\n      {\n        FCallback->FTaskID = GetTaskID();\n        FCallback->FResult = FResult;\n        FCallback->FTask = clPtr<clDownloadTask>( this );\n        FCallback->FCurlCode = FCurlCode;\n        FCallback->Invoke();\n        FCallback = nullptr;\n      }\n    }\n  }\n```", "```java\n  class clDownloader: public iIntrusiveCounter\n  {\n  public:\n    explicit clDownloader( const clPtr<clAsyncQueue>& Queue );\n    virtual ~clDownloader();\n```", "```java\n    virtual clPtr<clDownloadTask> DownloadURL(\n      const std::string& URL, size_t TaskID,\n      const clPtr<clDownloadCompleteCallback>& CB );\n    virtual bool CancelLoad( size_t TaskID );\n    virtual void CancelAll();\n    virtual size_t GetNumDownloads() const;\n```", "```java\n  private:\n    void CompleteTask( clPtr<clDownloadTask> Task );\n    friend class clDownloadTask;\n```", "```java\n    clPtr<clWorkerThread> FDownloadThread;\n```", "```java\n    clPtr<clAsyncQueue> FEventQueue;\n  };\n```", "```java\n  clPtr<clDownloadTask> DownloadURL( const std::string& URL,size_t TaskID,const clPtr<clDownloadCompleteCallback>& CB )\n  {\n    if ( !TaskID || !CB ) { return clPtr<clDownloadTask>(); }\n    auto Task = make_intrusive<clDownloadTask>(URL, TaskID, CB, this );\n    FDownloadThread->AddTask( Task );\n    return Task;\n  }\n```", "```java\n  void clDownloader::CompleteTask( clPtr<clDownloadTask> Task )\n  {\n    if ( !Task->IsPendingExit() )\n    {\n      if ( FEventQueue )\n      {\n```", "```java\n        FEventQueue->EnqueueCapsule(\n          make_intrusive<clCallbackWrapper>(Task) );\n      }\n    }\n  }\n```", "```java\n  class clCallbackWrapper: public iAsyncCapsule\n  {\n  public:\n    explicit clCallbackWrapper(\n      const clPtr<clDownloadTask> T ):FTask(T) {}\n    virtual void Invoke() override\n    {\n      FTask->InvokeCallback();\n    }\n  private:\n    clPtr<clDownloadTask> FTask;\n  };\n```", "```java\n  int main()\n  {\n    Curl_Load();\n```", "```java\n    auto Events = make_intrusive<clAsyncQueue>();\n    auto Downloader = make_intrusive<clDownloader>( Events );\n    clPtr<clDownloadTask> Task = Downloader->DownloadURL(\n      http://downloads.sourceforge.net/freeimage/FreeImage3160.zip,\n      1, make_intrusive<clTestCallback>() );\n    while ( !g_ShouldExit ) { Events->DemultiplexEvents(); }\n    return 0;\n  }\n```", "```java\n  constexpr int LICENSED = 0x0100;\n  constexpr int NOT_LICENSED = 0x0231;\n  constexpr int RETRY = 0x0123;\n  constexpr int ERROR_INVALID_PACKAGE_NAME = 1;\n  constexpr int ERROR_NON_MATCHING_UID = 2;\n  constexpr int ERROR_NOT_MARKET_MANAGED = 3;\n  constexpr int ERROR_CHECK_IN_PROGRESS = 4;\n  constexpr int ERROR_INVALID_PUBLIC_KEY = 5;\n  constexpr int ERROR_MISSING_PERMISSION = 6;\n```", "```java\n  void OnStart();\n  void OnLicensed( int Reason );\n  void OnLicenseError( int ErrorCode );\n```", "```java\n  #include <stdlib.h>\n  #include \"Callbacks.h\"\n  #include \"License.h\"\n  #include \"Log.h\"\n  void OnStart()\n  {\n    LOGI( \"Hello Android NDK!\" );\n  }\n  void OnLicensed( int Reason )\n  {\n    LOGI( \"OnLicensed: %i\", Reason );\n```", "```java\n    if ( Reason == NOT_LICENSED )\n    {\n      exit( 255 );\n    }\n  }\n  void OnLicenseError( int ErrorCode )\n  {\n    LOGI( \"ApplicationError: %i\", ErrorCode );\n  }\n```", "```java\n  extern \"C\"\n  {\n    JNIEXPORT void JNICALL Java_com_packtpub_ndkmastering_AppActivity_Allow(\n      JNIEnv* env, jobject obj, int Reason )\n    {\n      OnLicensed( Reason );\n    }\n    JNIEXPORT void JNICALL Java_com_packtpub_ndkmastering_AppActivity_DontAllow(\n      JNIEnv* env, jobject obj, int Reason )\n    {\n      OnLicensed( Reason );\n    }\n    JNIEXPORT void JNICALL Java_com_packtpub_ndkmastering_AppActivity_ApplicationError(\n      JNIEnv* env, jobject obj, int ErrorCode )\n    {\n      OnLicenseError( ErrorCode );\n    } \n  }\n```", "```java\n  public void CheckLicense( String BASE64_PUBLIC_KEY,\n    byte[] SALT )\n  {\n    String deviceId = Secure.getString( getContentResolver(), Secure.ANDROID_ID );\n```", "```java\n    m_LicenseCheckerCallback = new AppLicenseChecker();\n```", "```java\n    m_Checker = new LicenseChecker( this,\n      new ServerManagedPolicy(this,\n        new AESObfuscator( SALT,\n        getPackageName(), deviceId) ),\n      BASE64_PUBLIC_KEY);\n    m_Checker.checkAccess( m_LicenseCheckerCallback );\n  }\n```", "```java\n  public static native void Allow( int reason );\n  public static native void DontAllow( int reason );\n  public static native void ApplicationError( int errorCode );\n```", "```java\n>ndk-build\n>ant debug\n\n```", "```java\n  void OnStart()\n  {\n    TrackEvent( \"FlurryTestEvent\" );\n  }\n```", "```java\n  extern \"C\"\n  {\n    void Android_TrackEvent( const char* EventID );\n  };\n  void TrackEvent( const char* EventID )\n  {\n    #if defined(ANDROID)\n      Android_TrackEvent( EventID );\n    #else\n      printf( \"TrackEvent: %s\\n\", EventID );\n    #endif\n  }\n```", "```java\n  void Android_TrackEvent( const char* EventID )\n  {\n    JAVA_ENTER();\n    jstring jstr = (*env)->NewStringUTF( env, EventID );\n    FindJavaStaticMethod( env, &Class, &Method,\n      \"com/packtpub/ndkmastering/AppActivity\",\n      \"Callback_TrackEvent\", \"(Ljava/lang/String;)V\" );\n    (*env)->CallStaticVoidMethod( env, Class, Method, jstr );\n    JAVA_LEAVE();\n  }\n```", "```java\n  public static void Callback_TrackEvent( String EventID )\n  {\n    if ( m_Activity == null ) return;\n    m_Activity.TrackEvent( EventID );\n  }\n  public void TrackEvent( String EventID )\n  {\n    FlurryAgent.logEvent( EventID );\n  }\n```"]