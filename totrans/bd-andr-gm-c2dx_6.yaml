- en: Chapter 6. Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cocos2d-x framework comes with an audio engine called `CocosDenshion`, which
    has been inherited from Cocos2d for iPhone. This engine encapsulates all the complexity
    of playing sound effects and background music. Now, Cocos2d-x has another audio
    engine that was built from scratch with the aim of providing more flexibility
    than the `CocosDenshion` library. Be aware that there is no plan to eliminate
    the `CocosDenshion` audio engine from the Cocos2d-x framework, it is now common
    in Cocos2d-x to have redundant components so that programmers can pick whatever
    fits their needs better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered within this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing background music and sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the audio properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling audio when leaving the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new audio engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing background music and sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to add the background music to our game by using the `CocosDenshion`
    audio engine, the first step is to add the following file inclusion to our `HelloWorldScene.cpp`
    implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this header file, within the private member segment, we will also add the
    declaration of our new `initAudio` method, which we are going to use for starting
    our background music and for preloading the audio effect that is going to be played
    each time a bomb crashes into our `player` sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `HelloWorld.cpp` implementation file, we are going to use the `CocosDenshion`
    namespace so that we don''t have to implicitly refer to this namespace each time
    that we access the audio engine singleton instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now in the same implementation file, we are going to write the body of the `initAudio`
    method, which as we have previously mentioned will start playing a looped music
    background. We are providing this along with the source code of this chapter,
    and we are going to preload the audio effect that is going to be played each time
    our player loses. The second parameter of the `playBackgroundMusic` method is
    a Boolean, which determines whether or not we would like our background music
    to repeat forever.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a folder called `sounds` in our `Resources` directory, so that
    we can add all our sound files there in an organized way. After doing this, we
    will need to add the following line to our `AppDelegate.cpp` implementation file
    after the instantiation of `searchPaths std::vector` for adding the `sounds` directory
    to the search path so that the audio engine can find our files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We encourage you to organize your `Resources` folder, create a folder for sounds
    with subfolders for audio and music, so that we don't have everything in the root
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go to the `onCollision` method that is called each time two physics
    bodies collide. If the player sprite''s physics body is involved in a crash, then
    we are going to stop the background music and play the `uh.wav` sound effect before
    changing to the game over scene by adding the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to add a call for our `initAudio` method at the end of
    the `init` method in the `HelloWorld.cpp` implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Modifying audio properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily modify the background music and the basic audio properties of
    the sound effect by calling the `setBackgroundMusicVolume` method and the `setEffectsVolume`
    method. Both receive a `float` value as a parameter, where `0.0` means mute and
    `1.0` means maximum volume, as the following code listing shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Handling audio when leaving the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the game activity is no longer active, the background music and the sound
    effects will not stop automatically, they should be stopped manually by removing
    the following comment block from the `applicationDidEnterBackgound` method in
    the `AppDelegate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make this new line of code work, we need to add the same line that
    we have added to the `HelloWorld.cpp` implementation file in order to use the
    `CocosDenshion` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Your game will stop all the current sounds when the user switches to another
    application. We need to resume the music as soon as the user returns to our game.
    We can do that in the same way as we did before, but now, we will remove the following
    comment block from the `applicationWillEnterForeground` method in the `AppDelegate`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new audio engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d-x 3.4 in its experimental phase had a new audio engine built from scratch
    in order to add more functionalities and flexibility. The new audio engine of
    Cocos2d-x is now available for the Android, iOS, the Mac OS, and the win-32 platforms.
    It is able to reproduce up to 24 simultaneous sounds on the Android platform;
    this number may change depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the tests bundled with the Cocos2d-x framework, then you can test
    both of the audio engines. At runtime, they may sound without any apparent difference
    but they are internally very different.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `CocosDenshion` engine, there is no distinction between the sound
    effect and the background music in this new engine. Therefore, the framework has
    only one `setVolume` method in contrast to `CocosDenshion`, which has two methods—`setBackgroundMusicVolume`
    and the `setEffectsVolume`. Later on in this section, we will show you how to
    adjust the volume of each played audio regardless of whether or not it is a sound
    effect of the background music.
  prefs: []
  type: TYPE_NORMAL
- en: Let us add a new method declaration to our `HelloWorldScene.h` header file named
    `initAudioNewEngine`, which as its name suggests will initialize the audio capabilities
    of our game, but it will now use the new audio engine for the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the new engine header in our `HelloWorldScene.h` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us include the following line of code in our `HelloWorld.cpp` implementation
    file, so that we can invoke the `AudioEngine` class directly without referring
    to its namespace each time we want to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us write our code for the `initAudioNewEngine` method inour implementation
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to `CocosDenshion`, which uses a singleton instance, the new audio
    engine has all of its methods declared static.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the previous code listing, we are calling the `lazyInit`
    method before calling the `play2d` method. Despite the fact that `play2d` calls
    the `lazyInit` method internally, we want to know as soon as possible whether
    or not our Android system is going to be able to reproduce the audio and take
    actions. Be aware that you also need to find out whether something is wrong with
    the audio initialization when the `play2d` method returns the `AudioEngine::INVALID_AUDIO_ID`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Each time that we play any given sound by calling the `play2d` method, it will
    return a unique incremental `audioID` zero-basedindex, which we will store, so
    that we can refer to that specific audio instance each time that we want to perform
    a particular action on it, such as change volume, move to a specific position,
    stop, pause, or resume.
  prefs: []
  type: TYPE_NORMAL
- en: 'One disadvantage of the new audio engine is that it still has a limited amount
    of supported audio formats. It does not currently support the `.wav` files. So
    in order to play the `uh.wav` sound, we will convert it to mp3 and then we will
    play it in the `onCollision` method by invoking `play2d` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have included the new `uh.mp3` audio file in the code resources archive provided
    with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For our game, we are going to implement both; the traditional `CocosDenshion`
    engine, which is the most mature audio engine that provides us with the basic
    features that we need, such as playing the sound effects and the background music;
    and the same audio functionalities in the new engine.
  prefs: []
  type: TYPE_NORMAL
- en: New features included in the new audio engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `play2d` method is overloaded so that we can specify whether we want to
    loop the sound, the initial volume, and the audio profile that we would like to
    apply to it. The `AudioProfile` class is a part of the Cocos2d-x framework, it
    has only three properties: `name`, which cannot be empty; `maxInstances`, which
    will define how many sounds will be played simultaneously; and `minDelay`, which
    is a `double` data type that will specify what the minimum delay between the sounds
    is going to be.'
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that the new audio engine has is the ability to play an audio
    from a custom position by calling the `setCurrentTime` method and passing the
    `audioID` method and the custom position in seconds, which are represented by
    a `float`.
  prefs: []
  type: TYPE_NORMAL
- en: In the new audio engine, you can specify that you would like to invoke a function
    when a given audio instance has completed playing. This can be done by calling
    the `setFinishCallback` method.
  prefs: []
  type: TYPE_NORMAL
- en: Each time an audio is played, it is cached so that it is not necessary to read
    it again from the filesystem. If we would like to free some resources, then we
    could call the `uncacheAll` method to remove all the buffer that is used internally
    by the audio engine for playing back the audio, or you could remove any specific
    audio from the cache by calling the `uncache` method and specifying the path of
    the file of the filesystem that you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this section was to make you aware of another audio engine that
    is in an experimental phase, and if there is any audio feature that you would
    like to add to your game, which `CocosDenshion` does not have, then you should
    check the other audio engine to see whether it has what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new audio engine can play up to 32 sounds simultaneously on the Mac OS,
    iOS, and the win-32 platforms, but it can only play up to 24 simultaneous sounds
    on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a mute button to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ending this chapter, we are going to add a mute button to our game so
    that we can simply set our sound effects and our background music volume to zero
    in a single touch.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, we are going to add two methods to the `HelloWorld`
    class; one for initializing the buttons and the other for actually muting all
    the sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, we are going to add the following lines to our `HelloWorldScene.h`
    header file under the private section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to add the `initMuteButton` implementation code to the `HelloWorldScene.cpp`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see we have just created a new menu, where we have added two buttons,
    one for muting our game and the other invisible for unmuting it. We have stored
    each of these in the member variables, so that we can access them by the `muteCallback`
    method, which we have declared in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are basically just asking whether or not the `_muteItem` menu item
    is visible. If it is visible, then set the volume to zero by using `CocosDenshion`,
    the new audio engine, else set the volume to its maximum value, that is, one.
    In either case, change the actual visibility value in both mute and unmute menu
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the final result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a mute button to our game](img/B04193_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how our `applicationDidFinishLaunching` method from our `AppDelegate.cpp`
    implementation file looks after we have added the line for including the `sounds`
    folder in the `resources` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code listing shows how our `HelloWorldScene.h` header file looks
    after the changes we have made during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, after adding the audio management code, this is how our `HelloWorldScene.cpp`
    implementation file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, we will initialize the audio by using the new audio
    engine. Notice that we will store the ID that corresponds to the background music
    of the audio instance in the `_musicId` integer member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are performing the same initialization job that we did in the previous
    method, but now we are doing so by using the `CocosDenshion` audio engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, we are creating a simple menu for presenting the options
    for muting and unmuting the game. Here we are storing the mute and the unmute
    sprites in their corresponding member variables, so that we can later access them
    within the `muteCallback` method for manipulating their `visibility` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method will be called each time the mute or the unmute menu item
    is pressed, in this method we just set the volume to zero and show the mute or
    unmute button depending on the option that was touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The single modification that we made to the `init` method was to add the call
    to the `initMuteButton();` method at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, despite the fact that we have used the new audio engine for
    playing sounds, we have shown all the code that is required for using the traditional
    `CocosDenshion` audio engine. To enable the `CocosDenshion` implementation, you
    would only need to call the `initAudio` method at the bottom of the `init` method
    of the `HelloWorld.cpp` file, instead of calling the `initAudioNewEngine` method,
    and finally, you will need to remove the comment slashes for the `CocosDenshion`
    implementation code in the `onCollision` method and comment the new audio engine
    playback code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have added the background music and the sound effects to
    our game in a very simple way by using the two audio engines bundled with the
    Cocos2d-x framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to add particle systems to our games
    in order to simulate more realistic explosions each time a bomb hits our `player`
    sprite.
  prefs: []
  type: TYPE_NORMAL
