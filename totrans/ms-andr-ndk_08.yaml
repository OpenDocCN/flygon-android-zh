- en: Chapter 8. Writing a Rendering Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In one of the previous chapters, we learned how to organize a thin abstraction
    layer on top of mobile and desktop OpenGL. Now, we can move into actual rendering
    territory and use this layer to implement a 3D rendering framework capable of
    rendering geometry loaded from files using materials, lights, and shadows.
  prefs: []
  type: TYPE_NORMAL
- en: The scene graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scene graph is a data structure commonly used to construct hierarchical representations
    of spatial graphical scenes. The main limitation of the classes introduced in
    [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. OpenGL ES 3.1 and Cross-platform
    Rendering"), *OpenGL ES 3.1 and Cross-platform Rendering* is that they lack information
    on the scene as a whole. Users of these classes have to do ad hoc bookkeeping
    of transformations, state changes and dependencies, making implementation and
    support of any somewhat complex scenes a very challenging task. Furthermore, a
    lot of rendering optimizations cannot be done unless the whole scene information
    for the current frame is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: In our current low-level implementation, we describe all visible entities using
    the `clVertexArray` class and render them using a shader program accessible via
    the `clGLSLShaderProgram` class with an ugly manual binding of matrices and shader
    parameters. Let's learn how to put all these properties together into a higher
    level data structure. First, we will start with a scene graph node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clSceneNode` class contains local and global transformations and a vector
    of child nodes. These fields are protected, and we access them using setters and
    getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need hierarchy, we have to distinguish global and local transformation
    of the node. The local transformation is easy to understand from a user''s point
    of view. This defines the position and orientation of a node relative to its parent
    node in a hierarchical spatial structure. The global transformation is used to
    render the geometry. *Per se*, it transforms the geometry from the model coordinate
    system into the world coordinate system. Local transformations can be intuitively
    modified by hand and global transformations should be subsequently reevaluated.
    The constructor of `clSceneNode` sets default transformation values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clSceneNode` class contains setters and getters to access and modify transformation
    matrices. The implementation is simple. However, it is quite cumbersome, so only
    the methods for the local transformation matrix are cited here. Check out the
    source code `1_SceneGraphRenderer` for the complete picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this, we need a method to add a child node to this scene node. Our
    current implementation is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, this method can be extended in the future to allow certain optimizations.
    For example, we can mark certain parts of a scene graph as dirty once we add new
    nodes. This will allow us to preserve inter-frame rendering queues constructed
    from the scene graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is required that you set the global transformation matrix directly.
    For example, if you want to use a physics simulation library in your 3D application.
    Once done, local transformations should be recomputed. The `RecalculateLocalFromGlobal()`
    method calculates relative local transformations for each node in the hierarchy.
    For the root node, local and global transformations coincide. For the children,
    each global transformation matrix must be multiplied by the inverse global transformation
    of its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We multiply the parent''s node global inverse transformation by the global
    transformation of the current node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The process is repeated down the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more interesting thing left in the declaration of `clSceneNode`.
    This is the pure virtual method `AcceptTraverser()`. To render a scene graph,
    a technique known as the *visitor design pattern* is used ([https://en.wikipedia.org/?title=Visitor_pattern](https://en.wikipedia.org/?title=Visitor_pattern)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iSceneTraverser` interface is used to define different operations on a
    scene graph. Since the number of different types of scene graph nodes is limited
    and constant, we can add new operations simply by implementing the `iSceneTraverser`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface is declared as a friend of all descendants of `clSceneNode` to
    allow direct access to the fields of these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `Traverse()` is shared between all traversers. It resets
    the traverser and calls the virtual method `clSceneNode::AcceptTraverser()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the declaration of `iSceneTraverser`, you can see two additional types of
    scene nodes. A tree of `clSceneNode` objects can hold a hierarchy of spatial transformations.
    Obviously, this is not enough to render anything yet. To do this, we need at least
    geometry data and a material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare two more classes for this purpose: `clMaterialNode` and `clGeometryNode`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first example of this chapter, a material will contain only ambient
    and diffuse colors ([https://en.wikipedia.org/wiki/Phong_shading](https://en.wikipedia.org/wiki/Phong_shading)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The field `m_MaterialClass` contains a material identifier, which can be used
    to distinguish special materials, for example, enable alpha transparency, for
    particle rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a material scene node can be declared. It is a simple data container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `AcceptTraverser()` method implementation. It is
    very simple and pretty efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Geometry nodes are a bit more complex. This is because the API-independent
    geometry data representation in `clVertexAttribs` should be fed into the instance
    of `clGLVertexArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we feed the geometry data into OpenGL in a lazy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `AcceptTraverser()` is very similar to the one inside
    `clMaterialNode`. Just take a look into the bundled source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the whole bunch of scene node classes is nothing but a simple
    data container. Actual operations happen in the traverser classes. The first implementation
    of `iSceneTraverser` is the `clTransformUpdateTraverser` class, which updates
    the global—which means relative to the root of the graph—transformation of each
    scene node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The private field `m_ModelView` contains a stack of matrices implemented as
    `std::vector`. The top element of this stack is the current global transformation
    of the node. The `Reset()` method clears the stack and pushes the identity matrix
    on the stack, which is later used as the global transformation of the root scene
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PreAcceptSceneNode()` method pushes a new value of the current global
    transformation onto the `m_ModelView` stack, and then uses it as the global transformation
    of incoming nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostAcceptSceneNode()` method pops the topmost, now unused, matrix from
    the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This traverser is used in the beginning of every frame before any geometry
    is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now almost ready to proceed with the actual rendering. To do this, we
    need to linearize the scene graph into a vector of rendering operations. Let''s
    take a look into the `ROP.h` file. Each rendering operation is a freestanding
    piece of geometry, a material, and a bunch of transformation matrices. The required
    matrices are stored within the `sMatrices` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The projection, view, and model matrices are set explicitly from the external
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Other matrices that are necessary for lighting and shading are updated using
    the `UpdateMatrices()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This structure can be easily extended with additional matrices on an as-needed
    basis. Furthermore, it is very convenient to pack the values of this structure
    into a Uniform Buffer Object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our rendering operation can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A minimalistic implementation of `clRenderOp::Render()` can be found in `ROP.cpp`.
    There are two shaders defined there. First, a generic vertex shader to transform
    normals into the world space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a fragment shader that does simple per-pixel lighting using a single
    directional light source pointing in the same direction as the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The camera is statically positioned and lighting is done in the world space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A static global variable holds a shader program linked using the shaders mentioned
    in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual rendering code updates all the matrices, sets parameters of the
    shader program and renders the geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code will become a bottleneck once the number of rendering
    operations and uniforms increases. It can be improved using precached uniform
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s convert a scene graph into a vector of rendering operations, so we can
    see the actual rendered image. This is done by the `clROPsTraverser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear everything before constructing the new queue of rendering operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a reference to the most recently constructed queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we implement the `iSceneTraverser` interface. Most of the methods here
    will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next geometry node comes in, use the topmost material from the materials
    stack and create a new rendering operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The materials stack is updated on every incoming `clMaterialNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this framework can now be used to render the actual 3D graphics. The
    example scene is created in `1_SceneGraphRenderer/main.cpp`. First, the root of
    our scene is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A red material is created and binded to a material scene node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a cube centered in the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And add it in to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering is straightforward and very generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotate the cube around its diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Update global transformations of the nodes and construct a rendering queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the matrices. The camera has only a dummy implementation, which currently
    returns an identity view matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the screen before the frame will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the rendering queue and render everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting image will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The scene graph](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now extend our scene graph rendering example with lights and shadows,
    and make sure everything works on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To render lights and shadows, we need to extend the approach shown in the previous
    paragraphs. The next code example we will discuss is `2_ShadowMaps`. Shadow mapping
    will be done using projected shadow maps ([https://en.wikipedia.org/wiki/Shadow_mapping](https://en.wikipedia.org/wiki/Shadow_mapping)).
    This way a scene is rendered into an off-screen depth buffer from the light's
    point of view. Next, the scene is rendered as usual and every fragment is projected
    onto the lights shadow map and the depth value relative to the light is compared
    to the value in the constructed shadow map. The fragment is in shadow if the depth
    value is larger than the corresponding depth value from the shadow map. To do
    an off-screen rendering, we need to revisit our OpenGL wrapper introduced in [Chapter
    6](part0057.xhtml#aid-1MBG21 "Chapter 6. OpenGL ES 3.1 and Cross-platform Rendering"),
    *OpenGL ES 3.1 and Cross-platform Rendering*, and add a framebuffer abstraction
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clGLFrameBuffer` class is declared in `GLFrameBuffer.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `InitRenderTargetV()` accepts a vector containing integer values
    of width, height, and bits per channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This method provides access to the private data members, those are width, height,
    and bits per channel, which were passed into `InitRenderTargetV()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important ability of a framebuffer is being able to provide its content
    as textures—a color texture and a depth texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bind()` method sets this framebuffer as the current OpenGL framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The protected method `CheckFrameBuffer()` is used to check the completeness
    of the frame buffer according to the OpenGL specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The private section of the class contains an OpenGL buffer identifier, two
    `clGLTexture` objects for color and depth textures, respectively, and two fields
    containing framebuffer parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Correct construction of a framebuffer for Android and other platforms requires
    some work and careful selection of parameters. Let''s take a look at the implementation
    of the `InitRenderTargetV()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, we store framebuffer''s parameters in private data members. These
    values are used later for viewport aspect computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will call the OpenGL function to create a framebuffer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the framebuffer object is created, we can bind it as the current framebuffer
    to set up its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and attach a color texture to the framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here between Android and desktop implementations is the
    selection of buffer data formats. OpenGL 4 Core Profile requires the number of
    bits in the internal format and depth format to be specified explicitly while
    OpenGL ES 3 wants generic `GL_RGBA` and `GL_DEPTH_COMPONENT` respectively. We
    declare two constants in a platform-specific way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will call the `SetFormat()` method of `clGLTexture` to set up the format
    of the color texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AttachToCurrentFB()` methods attaches the created color texture to the
    currently binded framebuffer. The value of `GL_COLOR_ATTACHMENT0` specifies an
    OpenGL attachment point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A shadow map contains depth buffer values, so we create a depth texture the
    following way on an as-needed basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The depth buffer should have the same dimensions as the color buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The setup of the depth buffer is similar to that of the color buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure correct operation, we will check the error code and unbind the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CheckFrameBuffer()` member function uses OpenGL calls to check the current
    state of a framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert an error code into a string and print it into the system log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenGL ES is missing some of the capabilities of OpenGL. Here, we omit them
    to make the code portable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, nothing is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let's proceed further so that we can make use of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Lights and light nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is very convenient to represent a light source as a part of a 3D scene.
    When we write "a 3D scene", we mean a scene graph. In order to attach a light
    source to a scene graph, we need a special node for it. Here is the `clLightNode`
    class that holds a pointer to `iLight` with all light properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AcceptTraverser()` method is similar to those in `clGeometryNode` and
    `clMaterialNode`. But this time, we will call the `PreAcceptLightNode()` and `PostAcceptLightNode()`
    methods of `iSceneTraverser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This new scene node type forces us to extend the interface of `iSceneTraverser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Traversers can now handle light nodes in a special way. We will use this ability
    to maintain a list of active lights within the scene on a per-frame basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iLight` class encapsulates light parameters. It calculates the required
    projection and view matrices of a light source, passes them into a shader program
    and holds a shadow map. We should note that holding an initialized shadow map
    for possible unused light source is certainly non-optimal. The least we can do
    in our minimalistic example is to postpone the creation of a shadow map to the
    moment when it is really needed. In our example, we will deal only with spotlights.
    However, this approach can be easily extended with directional and point lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you want to implement multiple types of lights, it is advisable to
    push this field down to a class representing a spot light. Since our example has
    only lights of a single type, putting this value here is a reasonable compromise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UpdateROPUniforms()` method updates all the uniforms within a shader program
    required for shadow map rendering. The `clMaterialSystem` class is described in
    details after we finish with `iLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the scene from the light''s point of view, we need to calculate two
    matrices. The first one is the standard *look-at* matrix defining the light''s
    view matrix and the second one is a perspective projection matrix defining the
    light''s frustum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetShadowMap()` function returns a lazy-initialized shadow map buffer
    attached to this light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of the light source include its diffuse and ambient colors used
    in a simple lighting model, position, and direction for viewing matrix calculation
    and the spot light cone angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we declare a framebuffer holding a shadow map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how uniforms of a shader program are updated. This happens in the
    `UpdateROPUniforms()`, which is called for every render operation before each
    shadow map is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetProjScaleBiasMat()` helper routine returns a scaling matrix, which
    maps [-1..1] normalized device coordinates to the [0..1] range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `clMaterialSystem` class mentioned in this code requires some additional
    explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Material system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous example, `1_SceneGraphRenderer`, we used a single shader program
    to render all objects in the scene. Now, our renderer will become multipass. We
    need to create shadow maps, and then render shadowed objects and calculate lighting.
    This is done using three different shader programs in three different rendering
    passes. To distinguish between passes, we define the `ePass` enum as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle different shader programs based on passes and material properties,
    we implement the `clMaterialSystem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetShaderProgramForPass()` method returns the shader program for the specified
    pass stored in `std::map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of this class creates each shader program required for rendering
    and inserts it into the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, a map can be replaced with a simple C-style array. However,
    later on, we will use different material types with different shader programs,
    so a map would fit just right.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, the source code of each shader is stored in a static
    string variable. This time, the code is a bit more complicated. The vertex shader
    source code is shared between the ambient and per-light passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The same function was used in the C++ code to transform values from the [-1..1]
    to [0..1] range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Values are passed to the subsequent fragment shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the fragment shader for the ambient pass. Just output the ambient color
    to the framebuffer, and we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader for per-light passes computes the actual lighting and shading
    based on light''s parameters and the shadow map. This is why it is so long compared
    to all of our previous shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Shadows are computed using the technique called *percentage closer filtering*.
    If we use a naïve shadow mapping approach, the resulting shadows will have a lot
    of aliasing. The idea of **percentage closer filtering** (**PCF**) is to sample
    from the shadow map around the current pixel and compare its depth to all the
    samples. By averaging the results of comparison (not the results on the sampling),
    we can get smoother edges between light and shadow. Our example uses a 5 X 5 PCF
    filter with 26 taps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the function to evaluate whether a given fragment is in shadow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a perspective division to project the shadow map onto the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DepthBias` coefficient is used to prevent shadow acne. Here are two renderings
    of the same scene with the zero `DepthBias` (left) and `-0.0002` (right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Material system](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In general, it requires manual tweaking and should be a part of light''s parameters.
    Take a look at the following link for more ideas on how to improve shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v=vs.85).aspx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, multiply the coefficients and return the resulting value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can compute a simple lighting model based on the actual light direction
    and its shadow map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct a shadow map used in the previous shader, we need an additional
    rendering pass. For each light, the following vertex and fragment shaders are
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now we can render a nicer image with all shadows and much more accurate lighting.
    Let's take a look at the `2_ShadowMaps/main.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Demo application and a rendering technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important part of the new code is in the `OnDrawFrame()` method. It
    uses the `clForwardRenderingTechnique` class to render the scene. Let's take a
    look at `Technique.cpp.`
  prefs: []
  type: TYPE_NORMAL
- en: 'A helper function `RenderROPs()` is used to render a vector of rendering operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the passes can be described in terms of this function. Take a look
    at the function `clForwardRenderingTechnique::Render()`. First, let''s construct
    two rendering queues, for opaque and transparent objects. Transparent objects
    are those with the string `Particle` as their material class. We will make use
    of transparent objects in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare matrices for shaders and clear OpenGL buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, render all the objects with their ambient color. This is it, the ambient
    pass does not require any lights. As a by-product, we will have a Z-buffer filled
    with values, so we can disable depth writes in the subsequent passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'For the subsequent per-light passes, we need a vector of lights from the scene.
    Get it from the traverser and update all the shadow maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UpdateShadowMaps()` function iterates over a vector of light nodes and
    renders shadow casters into the corresponding shadow maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind and clear the shadow map framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The light knows its projection and view matrices. This code is quite generic
    to be extended for use with light types, including lights with multiple viewing
    frustums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Update uniforms within the shader program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Render into the shadow map and unbind the framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'All the shadow maps are now ready to be used in the rendering code. Let''s
    continue with the `OnDrawFrame()` function. Per-light passes accumulate lighting
    from all light sources and look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not the least, render the ambient lighting for transparent objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to reset the OpenGL state. A good idea to extend the renderer
    would be to encapsulate states such as depth test, depth mask, blending mode,
    and others into a pipeline state object and update pipeline states only once they
    are changed. If you want to extend the examples into a full-scale rendering code,
    this improvement is a must-have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We covered all the low-level rendering code. Let's go one level higher and see
    how a scene can be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Scene construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our test scene is constructed in `main()` and the process looks the following
    way. First, global objects are instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, materials and material nodes are set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create geometry of the scene using a bunch of boxes and a 3D model
    of Deimos ([https://en.wikipedia.org/wiki/Deimos_(moon)](https://en.wikipedia.org/wiki/Deimos_(moon)))
    loaded from an `.obj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be found in the `Loader_OBJ.cpp` file and does parsing of
    Wavefront OBJ file format ([https://en.wikipedia.org/wiki/Wavefront_.obj_file](https://en.wikipedia.org/wiki/Wavefront_.obj_file)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'And last but not least, we will add two lights to the scene, which will produce
    two distinct shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Assemble it all together and proceed to the application main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting application renders the following image with a rotating cube
    and shadows from two light sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scene construction](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The demo application is runnable on Android as well. Just go and try it!
  prefs: []
  type: TYPE_NORMAL
- en: User interaction with 3D scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We hope that you tried to run the `2_ShadowMaps` example. As you may have noticed,
    the 3D scene can be rotated with a gesture on a touch screen or using mouse on
    a desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is done using the `clVirtualTrackball` class, which emulates a virtual trackball
    by calculating a view matrix based on the provided touch points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the view matrix, corresponding to the new touch point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are not touching the screen, return an identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Project the touch point onto the virtual trackball sphere and find the distance
    between the current and the previous projection points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'If the distance is non-zero, calculate and return a rotation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the state of the trackball when a user touches the screen for the first
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Projection math goes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert normalized point coordinated to the `-1.0...1.0` range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is used in the `UpdateTrackball()` function, which is called from
    `OnDrawFrame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This class enables you to rotate a 3D scene on a touchscreen and serves the
    purpose of debugging the scene on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build higher level scene graph abstractions
    on top of our platform-independent OpenGL wrapper. We can create scene objects
    with materials and light sources and render the scene with lighting and shading.
    In the next chapter, we will step away from rendering for a while—well, not entirely—and
    learn how to implement a game logic in C++.
  prefs: []
  type: TYPE_NORMAL
