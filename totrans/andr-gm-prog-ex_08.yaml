- en: Chapter 8. Platformer – Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we will make the bullets do some damage. The ricochet sound is very
    satisfying when the bullets energy is absorbed by a clump of grass. We will add
    an abundance of new platform types and inanimate scenery objects to make our levels
    more interesting. We will provide a real sense of motion and immersion by implementing
    multiple scrolling parallax backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add an animated fire tile for the player to avoid, and in addition,
    a special `Teleport` class to link levels together into one playable game. Then,
    we will use all of our game objects and backgrounds to create four, linked, and
    fully playable levels.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will add a HUD to keep track of pickups and lives. Finally, we will
    discuss some of the neat things that couldn't be fitted into this project in just
    four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Bullet collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting bullet collisions is fairly straightforward. We loop through all the
    existing `Bullet` objects held by our `MachineGun` object. Next, we convert the
    points of each bullet into a `RectHitBox` object and test it using `intersects()`
    against each object in our viewport.
  prefs: []
  type: TYPE_NORMAL
- en: If we get a hit, we check to see what type of object it has hit. We then switch
    to handle each type of object that we care about. If it is a `Guard` object, we
    knock it back a bit, if it is a `Drone` object, we destroy it, and if it is anything
    else, we just make the bullet disappear and play a kind of thudding/ricochet sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply place this logic we discussed after our `switch` block that handles
    collisions with the player, but before, we call `update()` on all our unclipped
    objects as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Try it out, it is really satisfying, especially with a high rate of fire.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some fire tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These new `GameObject` derived objects will mean instant death to Bob. They
    won't move, but they will be animated. We will see we can achieve this just by
    setting the already existing properties of `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding this feature into our game is simple because we have already implemented
    all the features we need. We already have a way to locate and add new tiles, a
    way to detect and respond to a collision, sprite sheet animation, and so on. Let's
    do it step-by-step, then we can add these dangerous and life-threatening elements
    into our world.
  prefs: []
  type: TYPE_NORMAL
- en: We can put the entire functionality of the class into its constructor. All we
    do is configure the object much like we did our `Grass` object, but in addition,
    we configure it with all the animation settings, like we did to the `Player` and
    `Guard` objects. The `fire.png` sprite sheet has three frames of animation that
    we want to play over the course of one second.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some fire tiles](img/B04322_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new class, call it `Fire`, and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, of course, we need to add the `fire.png` sprite sheet from `Chapter8/drawable`
    in the download bundle to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add to our `LevelManager` class, in the usual three ways that we have
    done for all our new `GameObject` derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getBitmap` method, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getBitmapIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loadMapData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add to our collision detection `switch` block to handle the consequences
    of touching this terrible tile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Why not add a few `f` tiles to `LevelCave` and experiment with what the player
    is able to jump over. It will help us design some challenging levels later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some fire tiles](img/B04322_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We don't want our player to be walking on the grass the whole time, so let's
    add some more variety.
  prefs: []
  type: TYPE_NORMAL
- en: Eye candy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next three sections in this chapter will be purely aesthetic. We will add
    a whole bunch of different tile graphics with matching classes so that we can
    use a whole lot more artistic license to make our levels more interesting. The
    difference between the tiles will be purely visual, but it will be fairly simple
    to make them more functional than that.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can easily detect collision with a snow tile and have the player
    keep moving briefly after stopping to simulate skidding, or perhaps; the concrete
    tile can allow the player to move faster and therefore change the way we design
    big jumps and so on. The point is that you don't have to just copy paste the classes
    as they will be presented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add some completely aesthetic props: mine carts, boulders, stalactites,
    and more. There will be no collision detection for these objects. They will allow
    the level designer to make the levels more visually interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be simple to make these aesthetics more functional. Just add a hitbox
    and a case in the collision detection switch block to handle the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the most visually significant improvement we add, will be scrolling
    backgrounds. We will add some classes to allow the level designer to add multiple
    different scrolling backgrounds to a level design.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why not add all the graphics from the `Chapter8/drawable` folder of the download
    bundle to the `drawable` folder of your project. Then, you will have all the graphics
    ready and in place, for this and the next two sections as well.
  prefs: []
  type: TYPE_NORMAL
- en: The new platform tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, add all these classes with the filenames as shown. I have removed all
    comments from the code because they are all functionally the same as the `Grass`
    class. Create each of the following classes with the name shown and enter the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Brick` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Coal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the `Concrete` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the `Scorched` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Snow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the `Stone` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, as we are getting used to, we need to add them all into our `LevelManager`
    in the usual three places.
  prefs: []
  type: TYPE_NORMAL
- en: In `getBitmap()`, we simply add them in as normal. Note that although the values
    are arbitrary, we will use numbers for the type 2,3,4, and so on. This makes it
    easy to remember, while designing levels, that all our actual platforms are numbers.
    The actual index numbers are unimportant to us, as long as they are the same as
    in the `getBitmapIndex` method. Also, remember that we have a list of types in
    our `LevelData` class's comments, for easy reference when designing levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In `getBitmapIndex()`, we do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In `loadMapData()`, we just call `new()` on our new `GameObjects` to add them
    to our `gameObjects` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go wild adding different terrains to the `LevelCave` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new platform tiles](img/B04322_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to add some scenery objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new scenery objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will add some objects that don't do anything but look pretty. We will
    let the game engine know by simply not adding a hitbox and setting them randomly
    to either z layer -1, or 1\. Then the player can appear either in front or behind
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first add all the classes, and then update `LevelManager` in the usual
    three places. Create each of the new classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Boulders` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From now on, I removed all the comments to save digital ink. The class functionality
    is the same as it is in `Boulders`, just the attributes vary a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Lampost` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Stalagmite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `Stalactite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the `Tree2` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's all the new classes for the scenery objects. Now, we can update the `getBitmap`
    method with the seven new types in the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `getBitmapIndex` method in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make sure our new scenery items are added to our `gameObjects` array
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can design levels with scenery. Note the slight difference in appearance
    when an object is drawn on layer zero compared to layer one and how the player
    character passes either in front or behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new scenery objects](img/B04322_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, if you want to bump into lamposts, get skewered by stalagmites, or
    jump on top of mine carts, then just give them a hitbox.
  prefs: []
  type: TYPE_NORMAL
- en: We have one more way to beautify our game world.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling parallax backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parallax backgrounds are scrolling backgrounds, where we scroll them slower
    the farther away they are. So, if we have a grass verge at the player's feet,
    we will scroll it quickly. However, if we have a mountain range in the distance,
    we will scroll it slowly. This effect can give the sense of motion to the player.
  prefs: []
  type: TYPE_NORMAL
- en: To implement them, we will first add a data structure to represent the parameters
    of a background. We will call this class `BackgroundData`, we will then implement
    a `Background` class, which has the functionality necessary to control the scrolling
    and then we will see how to position and define backgrounds in our level design.
    Finally, we will write a `drawBackground` method that we will call from our regular
    `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you added all the graphics from the `Chapter8/drawable` folder of
    the download bundle to the `drawable` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's build a simple class to hold the data structure which will define
    our backgrounds. As we can see in the next block of code, we have quite a large
    number of parameters and member variables. We will need to know which bitmap will
    represent a background, which layer on the *z* axis to draw it (in front on 1
    or behind on -1), where in the world on the *y* axis it starts and finishes, how
    fast the background will scroll, and how high the background will be.
  prefs: []
  type: TYPE_NORMAL
- en: The `isParallax` Boolean is intended to give the option to have a background
    which is static, but we will not be implementing this feature. When you see the
    code for the background class, you will see it is simple to add this functionality
    if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `BackgroundData`, then implement it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add an `ArrayList` of our new type to the `LevelData` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create the `Background` class itself. Create a new class and name
    it `Background`. First, we set up a bunch of variables to hold a copy of the background
    image along with a reversed copy. We will make the backgrounds seem *endless*
    by putting the images back to back alternating between the regular image and a
    reversed image. We will see how to achieve this further on in the code.
  prefs: []
  type: TYPE_NORMAL
- en: We also have variables for the width and height of the image in pixels. The
    `reversedFirst` Boolean will determine which copy of the image is currently drawn
    on the left-hand side of the screen (first) and will change as the player moves
    and the image scrolls. The `xClip` variable will hold the precise pixel of the
    *x* axis (of the image), where we will cut the image and start to draw it from
    the left hand edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `y`, `endY`, `z`, and `speed` member variables are to hold the related
    values passed in as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the constructor, we create an Android resource ID from the name of the
    graphic file passed in as a parameter. Then, create the actual bitmap by calling
    `BitmapFactory.decodeResource()`. We set `reversedFirst` to `false`, so we will
    start with the regular (non-reversed) copy of the image on the left-hand side
    of the screen. We initialize our member variables and then scale the bitmap we
    just created by calling `Bitmap.createScaledBitmap()` and passing in bitmap, the
    width of the screen and the height (in the game world) of our background multiplied
    by the `pixelsPerMetre`, making the bitmap exactly the right size for the current
    devices screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we must choose appropriate heights for our background designs or they
    will appear stretched.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in the constructor is create a `Matrix` object and send
    it to the `createScaledBitmap` method along with the bitmap, so we now have a
    reversed copy of our background image stored in the `bitmapReversed Bitmap` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add two backgrounds to our level design. We fill out the required parameters
    that we have already discussed. Note that the "grass" background on layer 1 scrolls
    much faster than the "skyline" background on layer -1\. This will create the desired
    parallax effect. Add this code right at the end of the `LevelCave` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is certainly true that most caves do not have grass and a skyline. This is
    just a demonstration and to get the code working. We will redesign `LevelCave`
    and design some more appropriate levels a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load them with our `LevelManager` class by declaring a new `Arraylist`
    object as a member of our `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a new method in `LevelManager` to load the background data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the new method in the `LevelManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And, not for the last time, we will upgrade our `Viewport` class to enable our
    `PlatformView` methods to get the information they need, to draw the parallax
    backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will add a method which actually does the drawing in the `PlatformView`
    class. We will call this method from `onDraw()`, in just the right places, next.
    Note that we are using the new methods that we just added to the `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define four `Rect` objects that we will use to hold the start and
    end points of `bitmap` and `reversedBitmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the first part of the `drawBackground` method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we simply loop through all our backgrounds using the `start` and `stop`
    parameters to decide which backgrounds have a *z* layer that we are currently
    interested in drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we send the world coordinates of the background to the `Viewport` class
    for clipping. If it isn't clipped (and should be drawn), we get the starting pixel
    coordinates, and ending pixel coordinates on the *y* axis with the help of the
    new methods we added to our `Viewport` class previously. Note that we cast the
    results to `int` variables ready to be drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This next block of code is where the real action takes place. We initialize
    the four `Rect` objects with the starting and ending coordinates of the first
    and second of our two `Bitmap` objects. Note that the point (or pixel) that is
    calculated, is determined by `xClip`, which is initially zero. So, to start with,
    we will simply see `background` (if it is not clipped) stretched across the width
    of the screen. Soon, we will see that we modify `xClip` based on Bob''s velocity
    and cause different regions from each bitmap to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, we determine which background (regular or reversed) is currently being
    drawn first, and then draw that one first followed by the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can scroll along based on the speed and direction of Bob, `lv.player.getxVelocity()`
    and if `xClip` has reached the end of the current first background, `if (bg.xClip
    >= bg.width)`, simply set `xClip` to zero and change which bitmap we show first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, we add a call to `drawBackground()` just before our game objects for backgrounds
    with a *z* layer less than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Just after the bullets are drawn, but before the debugging text for those backgrounds
    with a *z* order more than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can really start to get creative with our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrolling parallax backgrounds](img/B04322_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Very soon, we will make some real playable levels that use all the features
    we have implemented over the last four chapters. Before we do that, let's have
    a bit of fun with the `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: It will be really useful for the player to scan around a level and plan a route.
    Equally, it will be helpful when designing levels, to zoom around the level to
    see how a particular part of the level looks without having to get the player
    character to that part in order to see it on the screen. So, let's make the pause
    screen into a moveable viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Pause menu with moveable viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is nice and quick. We will just add a bunch of new methods to our `Viewport`
    class to change the center of focus. Then, we will call them from `InputController`.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember when we implemented the `InputController` class back in [Chapter
    6](ch06.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob,
    Beeps and Bumps*, we wrapped all the control logic in an `if(playing)` test. We
    also implemented the pause button already in the `else` clause. All we will do
    is use the left, right, jump, and shoot buttons as left, right, up, and down,
    respectively, for moving the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add these methods to the `Viewport` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, add these calls to the methods from the `else` clause of the `if` condition
    in the `InputController` class that we were just discussing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: On the pause screen, the player can look around and plan their route when they
    are on more complicated levels. They are probably going to need to.
  prefs: []
  type: TYPE_NORMAL
- en: Levels and game rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented so many features, but we still don't have a way to put them
    altogether into a playable game. We need to be able to travel between levels,
    and have the player state persist when we do.
  prefs: []
  type: TYPE_NORMAL
- en: Traveling between levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are going to design four levels, we want the player to be able to travel
    between them. First, let''s add code to the `switch` statement at the start of
    the `LevelManager` constructor to include all four levels that we are about to
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, we start the game by calling `loadLevel()` from the `PlatformView`
    constructor. The arguments include the name of the level and the coordinates to
    spawn the player. If you are designing your own levels, then you need to decide
    which level and coordinates to start with. If you will be following along with
    the levels I have provided, set the call to `loadLevel()` in the constructor of
    `PlatformView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `if(lm.isPlaying())` block, in the `update` method, where we set the
    viewport to center on the player each frame; add the following code to detect
    (and brutally kill) the player if he falls out of the map as well as cause the
    game to restart with three lives, zero money, and no upgrades should he run out
    of lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create a special `GameObject` class that when touched sends the
    player to a predetermined level and location. We can then strategically add these
    objects to our level designs, and they will act as the link between our levels.
    Create a new class and call it `Teleport`. If you haven't already done so, add
    the `door.png` file from `Chapter8/drawable` to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our `Teleport` object will appear in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traveling between levels](img/B04322_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make a simple class to hold the data that each `Teleport` object will
    need. Create a new class called `Location` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The actual `Teleport` class looks just like any other `GameObject` class, but
    note that it also has a member `Location` variable. We will see how the level
    design will hold the destination of the `Teleport`, the `LevelManager` class will
    initialize it, and then when the player collides with it, we can load the new
    location, sending the player off to his destination.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `Teleport` class work in a way that lets the level designer decide
    what it will do exactly, we need to add to our `LevelData` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to add a `t` to the level design wherever we want our teleport/door,
    and an entry like the next line of code, within the constructor of the class of
    the level we are designing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can have as many `Teleport` objects as you like in a map, as
    long as the order they are defined in code matches the order they appear in the
    design. We will see exactly how this works when we look at our actual level designs
    in a minute, but the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we need to update the `LevelManager` class to load and locate our
    teleport(s). Here is the new code for `getBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'New code for `getBitmapIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to keep track of our `Teleport` objects during the loading phase
    in case there is more than one. So, add a new local variable as shown in the `loadMapData`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally for the `LevelManager` class, we initialize all the teleport data from
    the level design, tuck it away in the object and add it to our `gameObject ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are really close to being able to teleport all over the place. We need to
    detect a collision with a teleport, and then load a new level with the player
    at the desired location. This code will go in our collision detection switch block
    in the `PlatformView` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new level is loaded, the `Player`, `MachineGun`, and `Bullet` objects
    are all created from scratch. Therefore, we need to add a line to our `loadLevel`
    method to reload the current machine gun fire rate from the `PlayerState` class
    into the `MachineGun` class. Add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can work on the level designs for real.
  prefs: []
  type: TYPE_NORMAL
- en: The level designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can just copy and paste four classes from the `Chapter8/java` folder into
    your project and start playing, or you can start from the beginning and design
    your own. The levels are quite large, intricate, and tough to beat. It is not
    physically possible to print the level designs in a book or e-book in any meaningful
    way, so you will need to open up the `LevelCave`, `LevelCity`, `LevelForest`,
    and `LevelMountain` design files in order to see the detail of the four levels.
  prefs: []
  type: TYPE_NORMAL
- en: However, a brief discussion of the levels, pictures, and some screenshots, but
    not actual code from the four designs follows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the following screenshots feature the new HUD that is the last thing
    we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The cave
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cave level is where the whole thing starts. It not only features modestly
    frustrating jumps, but also plenty of fire making a fall potentially deadly.
  prefs: []
  type: TYPE_NORMAL
- en: '![The cave](img/B04322_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the player starts with a puny machine gun, only a few drones are present
    in the level. But there are two awkward guards that will require vaulting.
  prefs: []
  type: TYPE_NORMAL
- en: '![The cave](img/B04322_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The city
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The city holds vast rewards, especially in the bottom left-hand corner for coins
    and the top-left for machine gun upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: '![The city](img/B04322_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, there is a very awkward-to-jump guard on the bottom level should the
    player want to get all those stray coins and not opt for leaving them behind.
    The near vertical ascent that must be traversed up the left-hand side is likely
    to frustrate and if the player opts not to go for the machine gun upgrades, he
    will probably struggle with the double-guard just outside the door to the next
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '![The city](img/B04322_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The forest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The forest may be the overall toughest level of them all with a brutally long
    run of jumps, which are very easy to over or under jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![The forest](img/B04322_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And with in excess of a dozen drones waiting to swoop on Bob, as his pixels
    hang precariously off a platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![The forest](img/B04322_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mountains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fresh mountain air means Bob has almost made it. Not a guard or a drone
    in sight.
  prefs: []
  type: TYPE_NORMAL
- en: '![The mountains](img/B04322_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, look at that winding path of jumps, most of which will see Bob thrown
    right back to the bottom if he puts a pixel out of place.
  prefs: []
  type: TYPE_NORMAL
- en: '![The mountains](img/B04322_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to try out each of the levels without completing the grueling level(s)
    that precede it, you can of course, just start at the level and location of your
    choice. To do this, just change the call to `loadLevel()` in the `PlatformView`
    constructor to one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The HUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finishing touch is to add a HUD. This code in the `draw` method of `PlatformView`
    uses the graphics from some of the existing game objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code after the last call to `drawBackground()` and before the debugging
    text is drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I think we are done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We finished the platform game because that is all there is space for. Why not
    try to implement some or all of the following improvements and features?
  prefs: []
  type: TYPE_NORMAL
- en: Change the code in the `Player` class to make Bob gradually accelerate and decelerate
    instead of always running at full speed. Simply increment the velocity for each
    frame that the player is holding down left or right, and decrement it for each
    frame they are not.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have achieved this, add the preceding code to the collision detection
    `switch` block in the `update` method to make the player skid on snow, speed up
    on concrete, and have a different walking/landing sound effect for each tile type.
  prefs: []
  type: TYPE_NORMAL
- en: Draw a gun on Bob, and adjust the height that the `Bullet` object is spawned
    at to appear as if it is coming from the barrel of his machine gun.
  prefs: []
  type: TYPE_NORMAL
- en: Make some objects pushable. Add an `isPushable` member to `GameObject` and make
    the collision detection simply knock the object back a little. Perhaps, Bob could
    push mine carts into fire to jump over extra wide fire pits. Note that pushing
    objects that fall down to another level will be more complicated than pushing
    objects that remain at the same *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Destructible tiles sound like fun. Give them a strength variable that decrements
    when hit by a bullet and is removed from `gameObjects` when it reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: Moving platforms are a staple of great platformers. Simply add waypoints to
    a tile object and add the move code to the `update` method. The challenge will
    be assigning the waypoints. You can either have them all move a set number of
    spaces left and right or up and down, or do some kind of `setTileWaypoint` method
    similar to how we scripted the `Guard` object.
  prefs: []
  type: TYPE_NORMAL
- en: Make the game more persistent by saving the total number of coins collected
    ever, remembering which levels are unlocked, and offering access to replay any
    unlocked levels from the menu screen.
  prefs: []
  type: TYPE_NORMAL
- en: Make the game easier with teleports used as waypoints. Adjust the viewport zoom
    for different screen sizes. The current zoom can be a little too low for some
    small phones.
  prefs: []
  type: TYPE_NORMAL
- en: Add timed runs for high scores, leaderboards, and achievements, and add more
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a much smaller project, but still an interesting
    one, as we will be using OpenGL ES for super-fast, smooth drawing.
  prefs: []
  type: TYPE_NORMAL
