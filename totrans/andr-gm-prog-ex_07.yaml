- en: Chapter 7. Platformer – Guns, Life, Money, and the Enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will do many things. First, we will build a machine gun
    with a variable rate of fire and have it shoot bullets. Then, we will introduce
    pickups or collectibles. These give the player something to scavenge for while
    trying to escape into the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Then, just as Bob was beginning to think that his life was a blissful one of
    grass and collectibles, we will build two adversaries for him to outsmart or kill.
    A homing drone and a patrolling guard. We will easily be able to add all these
    things into our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: Ready aim fire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can give our hero a gun, and later, we can give him enemies to shoot
    at. We will create a `MachineGun` class to do all the work and a `Bullet` class
    to represent the projectiles that it fires. The `Player` class will control the
    `MachineGun` class, and the `MachineGun` class will control and keep track of
    all the `Bullet` objects that it fires.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `Bullet`. Bullets are not complicated. Ours
    will need a *x* and *y* location, a horizontal velocity, and a direction to help
    calculate the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implies the following simple class, constructor, and a bunch of getters
    and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now let's implement the `MachineGun` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `MachineGun`. First, we add some members.
    The `maxBullets` variable is not the amount of shots a player has, that is unlimited,
    it is the number of bullet objects the `MachineGun` class can have. Ten is sufficient
    for a very fast firing gun, as we will see. The members `numBullets` and `nextBullet`
    help the class to keep track of its 10 bullets. The `rateOfFire` variable controls
    how fast the player will be able to tap the fire button, and `lastShotTime` will
    help enforce the `rateOfFire` by keeping track of the system time that the last
    bullet was fired. It is the rate of fire that will be the upgradeable aspect of
    the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code that we discussed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For functional purposes, we can think of the `CopyOnWriteArrayList` `bullets`,
    which stores our bullets, as a plain old `ArrayList` object. We use this more
    complex and slightly slower class because it is thread safe and bullets can be
    accessed potentially simultaneously from the UI thread, when the player taps the
    fire button as well as from our own thread. This article explains `CopyOnWriteArrayList`,
    if you want to know more, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the constructor that just initializes bullets, `lastShotTime`, and
    `nextBullet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we update all the `Bullet` objects controlled by the gun by calling the
    `bullet.update` method for each bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have some getters that will let us find out things about our gun and
    its bullets, to do things like collision detection, and drawing bullets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We also have a quick helper method for when we want to stop drawing a bullet.
    We hide it away until it is ready to be reassigned in our `shoot` method shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A getter that returns the direction of travel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we add a more comprehensive method that actually shoots a bullet. The method
    compares the time of the last fired shot against the current `rateOfFire`. It
    then proceeds to increment `nextBullet` and create a new `Bullet` object if permitted.
    The bullet is sent speeding off in the same direction as Bob is facing. Note that
    the method returns `true` if a bullet was successfully fired. This is so that
    the `InputController` class can play a sound effect to correspond with the player's
    button press.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have a method to call when the player finds a machine gun upgrade
    pickup. We will see more of them later in the chapter. Here, we simply increase
    `rateOfFire`, which enables the player to tap the fire button more furiously and
    still get results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will modify the `Player` class to carry a `MachineGun`. Give `Player`
    a member variable that is a `MachineGun`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in the `Player` constructor, add a line of code to initialize our new
    `MachineGun` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Player` class''s `update` method, add a call to the `MachineGun` class''s
    `update` method just before we call `move()` for the player. As highlighted next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Add a method to the `Player` class, so our `InputController` can access the
    virtual trigger. As we saw, the method returns `true` if a shot was successful
    so that the `InputController` class knows whether to play a shot sound or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make some minor additions to our `InputController` class so that
    the player can fire a shot. The code to add is shown highlighted amongst the existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Not forgetting the way that our new control system works, we also need to add
    the same piece of extra code further down the `InputController` class in the `MotionEvent.ACTION_POINTER_DOWN`
    case as well. As usual, here is the code highlighted and with plenty of context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a gun, it's loaded, and we know how to pull the trigger. We just
    need to draw the bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new code in the `draw` method, just before we draw the debugging text,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will now fire some bullets. Note that the rate of fire is unsatisfying and
    slow. We will add some pickups, which the player can get to increase the rate
    of fire of his gun.
  prefs: []
  type: TYPE_NORMAL
- en: Pickups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pickups are game objects that can be collected by the player. They include things
    like upgrades, extra lives, money, and so on. We will now implement one of each
    of those collectibles. As our game engine is setup the way it is, this will be
    surprisingly easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is create a class to hold the state of the current
    player. We want to monitor the money collected, power of machine gun, and lives
    remaining. Let's call it `PlayerState`. Create a new Java class and name it `PlayerState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the variables, we have just talked about, we also want the `PlayerState`
    class to remember an *x* and *y* location to respawn at, when the player loses
    a life. Enter these member variables and the simple constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a method that we can call to initialize the respawn location.
    We will use this later when we call this method. Also, we need a method to reload
    the location. These are our next two methods for the `PlayerState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need a whole bunch of getters and setters to give us access to the
    members of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare an object of the `PlayerState` type as a member of the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the `PlatformView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now in the `loadLevel` method, create a `RectF` object, store the players starting
    location, and pass it in to the `PlayerState` object, `ps`, for safe keeping.
    Each time the player dies, he can be respawned using this location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create three classes, one for each of our pickups. These classes
    are very simple. They extend `GameObject`, set a bitmap, have a hitbox, and a
    location in the world. Also note that they all receive a type in the constructor
    and use `setType()` to store this value. We will soon see how to use their type
    to handle what happens when the player "picks them up". Create three new Java
    classes: `Coin`, `ExtraLife`, and `MachineGunUpgrade`. Note that the pickups are
    a little smaller than a platform, perhaps as we may expect. Enter the code for
    each of them in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `Coin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for `ExtraLife`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `MachineGunUpgrade` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `LevelManager` class to expect these three new objects in our
    level designs and add them to `ArrayList` of `GameObjects`. To do this, we need
    to update the `LevelManager` class in three places: `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. Here are each of these minor updates, with the new code highlighted
    amongst the existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following additions to `getBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Make identical additions, but this time to `getBitmapIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the final changes within `LevelManager` with the following additions to
    `loadMapData()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add the three appropriately named graphics to the drawable folder
    and start adding them to our `LevelCave` design. Go ahead and copy `clip.png`,
    `coin.png`, and `life.png` from the `Chapter7/drawables` folder in the download
    bundle to the `drawable` folder of your Android Studio project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a handy list of comments that identify all the types of game object. We
    will add these over the course of this project and the alpha-numeric code that
    will represent them on our level designs. Add the following comments to the `LevelData`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we enhance our `LevelCave` class to use our new objects, we want to
    detect when the player collects them or collides with them and take appropriate
    action. We will first add a quick helper method to the `Player` class. The reason
    for this is because when the player collides with another object, the default
    action in the `Player` class''s `checkCollisions` method is to stop the character
    moving. We don''t want this to happen for pickups because it will be irritating
    for the player. Therefore, we will quickly add a `restorePreviousVelocity` method
    to the `Player` class that we can call whenever we don''t want this default action
    to occur. Add this method to the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can handle the collisions for each of our pickups in turn. Add these
    cases to handle our three pickups within the switch block that handles our collisions
    in the `update` method of the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add the new objects to our `LevelCave` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippet, I suggest, is for a simple new layout that demonstrates
    our new objects, but your layout can be as big or elaborate as you like. We will
    do something more elaborate in the next chapter when we design and link some levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into `LevelCave` or elaborate with your own design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the simple layout will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pickups](img/B04322_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try collecting the pickups, and you will hear the pleasing sound effects. In
    addition, each time we collect a pickup, the `PlayerState` class stores an update.
    This will be useful when we build a HUD in the next chapter. Most fun of all;
    if you collect the machine gun upgrades, then try shooting your gun, you will
    find it much more satisfying to wield.
  prefs: []
  type: TYPE_NORMAL
- en: We better make those bullets do something. However, before we do that, let's
    give the player a bit more cannon fodder in the form of a couple of enemies.
  prefs: []
  type: TYPE_NORMAL
- en: The drone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The drone is a simple but evil enemy. It will detect the player when it is within
    the viewport and fly straight at him. If the drone touches the player, death is
    immediate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a `Drone` class. Create a new Java class and call it `Drone`. We
    need member variables to remember when we set the last waypoint. This will restrict
    the frequency with which the drone will get a navigation update of Bob's coordinates.
    This stops the drone from being too deadly accurate. It needs a waypoint/target
    coordinate and also needs to know the speed limit via `MAX_X_VELOCITY` and `MAX_Y_VELOCITY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now in the `Drone` constructor, initialize the usual `GameObject` members and
    specifically, the `Drone` class ones such as `currentWaypoint`. Not forgetting,
    that if we are going to shoot the drone, it will need a hitbox and we call `setRectHitBox()`
    after we have called `setWorldLocation()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here is the implementation of the `update` method, which compares the drone's
    coordinates with its `currentWaypoint` variable and changes its velocity accordingly.
    Then, we end `update()` by calling `move()` then `setRectHitbox()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In our last method for the `Drone` class, update the `currentWaypoint` variable
    by passing in Bob's coordinates as a parameter. Note that we check if enough time
    has elapsed for an update to make sure our drone is not too accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Add the drone graphic `drone.png` from `Chapter7/drawable` into the `drawable`
    folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add drones to our `LevelManager` class in the usual three places,
    just as we did for each of our pickups. Now, add code to `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. These are the three minor code additions in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code in the `getBitmap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the highlighted code in the `getBitmapIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the highlighted code in the `loadMapData` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The burning question is; how does the drone know where to go? In each frame,
    if there is a drone within the viewport, we can send the coordinates of the player.
    Do what is shown in this next code block within the `update` method of the `PlatformView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the new code is shown highlighted and in the context of the existing
    code. If you remember the `setWaypoint()` code from the `Drone` class, it only
    accepts updates every 2 seconds. This stops the drone from being too accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, these evil drones can be strategically placed around the level, and they
    will home in on the player. The last thing we need to do to make the drones fully
    operational is to detect when they actually collide with the player. This is nice
    and easy. Just add a case for drones in our collision detection `switch` block
    in the `update` method of the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and add a whole bunch of drones to `LevelCave` and watch them fly at
    the player. Note that if a drone catches the player, he dies and respawns.
  prefs: []
  type: TYPE_NORMAL
- en: '![The drone](img/B04322_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as if the world wasn't a dangerous enough place with all those enemy drones,
    let's add another type of enemy.
  prefs: []
  type: TYPE_NORMAL
- en: The guard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The guard enemy will be an exercise in scripting. We will have our `LevelManager`
    class automatically generate a simple script, which generates a route for our
    guard to patrol.
  prefs: []
  type: TYPE_NORMAL
- en: The route will be the simplest one possible; it will be just two waypoints that
    the guard will walk between continuously. It will be much quicker and simpler
    to preprogram our guards with two predetermined waypoints. However, by taking
    the time to have it automatically generated, we can place guards wherever we like
    (within certain parameters) on any level we design, and the behavior will be taken
    care of for us.
  prefs: []
  type: TYPE_NORMAL
- en: Our guard will be animated, so we will be using a sprite sheet and configuring
    the animation details in the constructor; just as we did for the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `Guard`. First, handle the member variables.
    Our `Guard` class will not only need two waypoints, but also a variable to indicate
    which one the current waypoint is. Like other moving objects, it will need velocity.
    Here is the class declaration and member variables to start coding your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We need to set up our guards via the constructor. First, setup our animation
    variables, bitmap, and sizes. Then as usual, set the guard's position in the level,
    its hitbox, and the way that it is facing. However, in the last line of the constructor
    we set `currentWaypoint` to `1`; this is new. We will see how this informs our
    guard's behavior in this class's `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a method that our `LevelManager` class will use to let the `Guard`
    class know what its two waypoints are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will code the "brains" of our `Guard` class, that is, its `update` method.
    You can basically break this method into two main parts. First, `if(currentWaypoint
    == 1)` and secondly, `if(currentWaypoint == 2)`. Inside each of these `if` blocks,
    simply check if the guard has reached or passed the appropriate waypoint. If it
    has, switch waypoints, reverse the velocity, and make the guard face the other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call `move()` then `setRectHitbox()` to update the hitbox to the new
    location of the guard. Add the code for the `update` method and then we will see
    how to put it to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add `guard.png` from the `Chapter7/drawables` folder of the download
    bundle to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can make the usual three additions to the `LevelManager` class to load
    any guards that may be found in our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `getBitmap()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In `getBitmapIndex()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In `loadMapData()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We will soon add something totally new to `LevelManager`. That is a method that
    will create the script (set two waypoints to patrol). For this new method to work,
    it needs to know if the tile is suitable for walking on. We will add a new property,
    a getter, and a setter to `GameObject` so that this is easily discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this new member to the `GameObject` class right after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these two methods to the `GameObject` class to get and set this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `Grass` class constructor, add a call to `setTraversable()`. We
    must remember to do this for all future `GameObject` derived classes that we design,
    if we want our guards to be able to patrol on them. In `Grass`, add this line
    at the top of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at the new `setWaypoints` method for our `LevelManager` class.
    It needs to examine the level design and calculate two waypoints for any `Guard`
    objects present in that level.
  prefs: []
  type: TYPE_NORMAL
- en: We will break this method into a few parts, so we can see what's happening at
    each stage.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to loop through all the `gameObjects` classes looking for the
    `Guard` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If we reach this point in the code, it means we have found a guard who will
    need two waypoints to be set. First, we need to find the tile which the guard
    is "standing on". Then, we calculate the coordinate of the last traversable tile
    on either side, but with a maximum range of five tiles each way. These will be
    the two waypoints. Here, is the code to add to the `setWaypoints` method. It is
    heavily commented to make clear what is going on without interrupting the flow
    by stopping to talk about it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call our new `setWaypoints` method as the last thing to do in the
    `LevelManager` constructor. We need to call this method after the `GameObject`
    class''s `ArrayList` has been populated or there will be no guards in it. Add
    the call to `setWaypoints()` as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Next, add this code to the collision detection switch block in the `update`
    method of the `PlatformView` class, so we can bump into the guards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add some `g` letters to the `LevelCave` class. Make sure to place
    them with one space above the platform, because they are 2 meters high as in this
    pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![The guard](img/B04322_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implemented guns, pickups, drones, and guards. This means we now have plenty
    of dangers, but have a machine gun that can't do any damage. We will change that
    first thing in the next chapter, by implementing collision detection for our bullets.
    However, we will go slightly further than merely having them hit our enemies.
  prefs: []
  type: TYPE_NORMAL
