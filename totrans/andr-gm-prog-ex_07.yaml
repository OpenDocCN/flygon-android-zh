- en: Chapter 7. Platformer – Guns, Life, Money, and the Enemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will do many things. First, we will build a machine gun
    with a variable rate of fire and have it shoot bullets. Then, we will introduce
    pickups or collectibles. These give the player something to scavenge for while
    trying to escape into the next level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Then, just as Bob was beginning to think that his life was a blissful one of
    grass and collectibles, we will build two adversaries for him to outsmart or kill.
    A homing drone and a patrolling guard. We will easily be able to add all these
    things into our level designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Ready aim fire
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can give our hero a gun, and later, we can give him enemies to shoot
    at. We will create a `MachineGun` class to do all the work and a `Bullet` class
    to represent the projectiles that it fires. The `Player` class will control the
    `MachineGun` class, and the `MachineGun` class will control and keep track of
    all the `Bullet` objects that it fires.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `Bullet`. Bullets are not complicated. Ours
    will need a *x* and *y* location, a horizontal velocity, and a direction to help
    calculate the velocity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This implies the following simple class, constructor, and a bunch of getters
    and setters:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now let's implement the `MachineGun` class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `MachineGun`. First, we add some members.
    The `maxBullets` variable is not the amount of shots a player has, that is unlimited,
    it is the number of bullet objects the `MachineGun` class can have. Ten is sufficient
    for a very fast firing gun, as we will see. The members `numBullets` and `nextBullet`
    help the class to keep track of its 10 bullets. The `rateOfFire` variable controls
    how fast the player will be able to tap the fire button, and `lastShotTime` will
    help enforce the `rateOfFire` by keeping track of the system time that the last
    bullet was fired. It is the rate of fire that will be the upgradeable aspect of
    the weapon.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code that we discussed as follows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For functional purposes, we can think of the `CopyOnWriteArrayList` `bullets`,
    which stores our bullets, as a plain old `ArrayList` object. We use this more
    complex and slightly slower class because it is thread safe and bullets can be
    accessed potentially simultaneously from the UI thread, when the player taps the
    fire button as well as from our own thread. This article explains `CopyOnWriteArrayList`,
    if you want to know more, visit:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the constructor that just initializes bullets, `lastShotTime`, and
    `nextBullet`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we update all the `Bullet` objects controlled by the gun by calling the
    `bullet.update` method for each bullet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we have some getters that will let us find out things about our gun and
    its bullets, to do things like collision detection, and drawing bullets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also have a quick helper method for when we want to stop drawing a bullet.
    We hide it away until it is ready to be reassigned in our `shoot` method shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A getter that returns the direction of travel:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we add a more comprehensive method that actually shoots a bullet. The method
    compares the time of the last fired shot against the current `rateOfFire`. It
    then proceeds to increment `nextBullet` and create a new `Bullet` object if permitted.
    The bullet is sent speeding off in the same direction as Bob is facing. Note that
    the method returns `true` if a bullet was successfully fired. This is so that
    the `InputController` class can play a sound effect to correspond with the player's
    button press.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we have a method to call when the player finds a machine gun upgrade
    pickup. We will see more of them later in the chapter. Here, we simply increase
    `rateOfFire`, which enables the player to tap the fire button more furiously and
    still get results.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we will modify the `Player` class to carry a `MachineGun`. Give `Player`
    a member variable that is a `MachineGun`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next in the `Player` constructor, add a line of code to initialize our new
    `MachineGun` object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `Player` class''s `update` method, add a call to the `MachineGun` class''s
    `update` method just before we call `move()` for the player. As highlighted next:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Add a method to the `Player` class, so our `InputController` can access the
    virtual trigger. As we saw, the method returns `true` if a shot was successful
    so that the `InputController` class knows whether to play a shot sound or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can make some minor additions to our `InputController` class so that
    the player can fire a shot. The code to add is shown highlighted amongst the existing
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Not forgetting the way that our new control system works, we also need to add
    the same piece of extra code further down the `InputController` class in the `MotionEvent.ACTION_POINTER_DOWN`
    case as well. As usual, here is the code highlighted and with plenty of context:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have a gun, it's loaded, and we know how to pull the trigger. We just
    need to draw the bullets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new code in the `draw` method, just before we draw the debugging text,
    as shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will now fire some bullets. Note that the rate of fire is unsatisfying and
    slow. We will add some pickups, which the player can get to increase the rate
    of fire of his gun.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Pickups
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pickups are game objects that can be collected by the player. They include things
    like upgrades, extra lives, money, and so on. We will now implement one of each
    of those collectibles. As our game engine is setup the way it is, this will be
    surprisingly easy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is create a class to hold the state of the current
    player. We want to monitor the money collected, power of machine gun, and lives
    remaining. Let's call it `PlayerState`. Create a new Java class and name it `PlayerState`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the variables, we have just talked about, we also want the `PlayerState`
    class to remember an *x* and *y* location to respawn at, when the player loses
    a life. Enter these member variables and the simple constructor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need a method that we can call to initialize the respawn location.
    We will use this later when we call this method. Also, we need a method to reload
    the location. These are our next two methods for the `PlayerState` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We just need a whole bunch of getters and setters to give us access to the
    members of this class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, declare an object of the `PlayerState` type as a member of the `PlatformView`
    class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize it in the `PlatformView` constructor:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now in the `loadLevel` method, create a `RectF` object, store the players starting
    location, and pass it in to the `PlayerState` object, `ps`, for safe keeping.
    Each time the player dies, he can be respawned using this location.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we will create three classes, one for each of our pickups. These classes
    are very simple. They extend `GameObject`, set a bitmap, have a hitbox, and a
    location in the world. Also note that they all receive a type in the constructor
    and use `setType()` to store this value. We will soon see how to use their type
    to handle what happens when the player "picks them up". Create three new Java
    classes: `Coin`, `ExtraLife`, and `MachineGunUpgrade`. Note that the pickups are
    a little smaller than a platform, perhaps as we may expect. Enter the code for
    each of them in turn.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `Coin`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, for `ExtraLife`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the `MachineGunUpgrade` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, update the `LevelManager` class to expect these three new objects in our
    level designs and add them to `ArrayList` of `GameObjects`. To do this, we need
    to update the `LevelManager` class in three places: `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. Here are each of these minor updates, with the new code highlighted
    amongst the existing code.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following additions to `getBitmap()`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make identical additions, but this time to `getBitmapIndex()`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make the final changes within `LevelManager` with the following additions to
    `loadMapData()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we can add the three appropriately named graphics to the drawable folder
    and start adding them to our `LevelCave` design. Go ahead and copy `clip.png`,
    `coin.png`, and `life.png` from the `Chapter7/drawables` folder in the download
    bundle to the `drawable` folder of your Android Studio project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a handy list of comments that identify all the types of game object. We
    will add these over the course of this project and the alpha-numeric code that
    will represent them on our level designs. Add the following comments to the `LevelData`
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before we enhance our `LevelCave` class to use our new objects, we want to
    detect when the player collects them or collides with them and take appropriate
    action. We will first add a quick helper method to the `Player` class. The reason
    for this is because when the player collides with another object, the default
    action in the `Player` class''s `checkCollisions` method is to stop the character
    moving. We don''t want this to happen for pickups because it will be irritating
    for the player. Therefore, we will quickly add a `restorePreviousVelocity` method
    to the `Player` class that we can call whenever we don''t want this default action
    to occur. Add this method to the `Player` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can handle the collisions for each of our pickups in turn. Add these
    cases to handle our three pickups within the switch block that handles our collisions
    in the `update` method of the `PlatformView` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, add the new objects to our `LevelCave` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippet, I suggest, is for a simple new layout that demonstrates
    our new objects, but your layout can be as big or elaborate as you like. We will
    do something more elaborate in the next chapter when we design and link some levels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into `LevelCave` or elaborate with your own design:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is what the simple layout will look like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Pickups](img/B04322_07_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Try collecting the pickups, and you will hear the pleasing sound effects. In
    addition, each time we collect a pickup, the `PlayerState` class stores an update.
    This will be useful when we build a HUD in the next chapter. Most fun of all;
    if you collect the machine gun upgrades, then try shooting your gun, you will
    find it much more satisfying to wield.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We better make those bullets do something. However, before we do that, let's
    give the player a bit more cannon fodder in the form of a couple of enemies.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The drone
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The drone is a simple but evil enemy. It will detect the player when it is within
    the viewport and fly straight at him. If the drone touches the player, death is
    immediate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a `Drone` class. Create a new Java class and call it `Drone`. We
    need member variables to remember when we set the last waypoint. This will restrict
    the frequency with which the drone will get a navigation update of Bob's coordinates.
    This stops the drone from being too deadly accurate. It needs a waypoint/target
    coordinate and also needs to know the speed limit via `MAX_X_VELOCITY` and `MAX_Y_VELOCITY`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now in the `Drone` constructor, initialize the usual `GameObject` members and
    specifically, the `Drone` class ones such as `currentWaypoint`. Not forgetting,
    that if we are going to shoot the drone, it will need a hitbox and we call `setRectHitBox()`
    after we have called `setWorldLocation()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here is the implementation of the `update` method, which compares the drone's
    coordinates with its `currentWaypoint` variable and changes its velocity accordingly.
    Then, we end `update()` by calling `move()` then `setRectHitbox()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In our last method for the `Drone` class, update the `currentWaypoint` variable
    by passing in Bob's coordinates as a parameter. Note that we check if enough time
    has elapsed for an update to make sure our drone is not too accurate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add the drone graphic `drone.png` from `Chapter7/drawable` into the `drawable`
    folder of your project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add drones to our `LevelManager` class in the usual three places,
    just as we did for each of our pickups. Now, add code to `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. These are the three minor code additions in order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code in the `getBitmap` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the highlighted code in the `getBitmapIndex` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the highlighted code in the `loadMapData` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The burning question is; how does the drone know where to go? In each frame,
    if there is a drone within the viewport, we can send the coordinates of the player.
    Do what is shown in this next code block within the `update` method of the `PlatformView`
    class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the new code is shown highlighted and in the context of the existing
    code. If you remember the `setWaypoint()` code from the `Drone` class, it only
    accepts updates every 2 seconds. This stops the drone from being too accurate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, these evil drones can be strategically placed around the level, and they
    will home in on the player. The last thing we need to do to make the drones fully
    operational is to detect when they actually collide with the player. This is nice
    and easy. Just add a case for drones in our collision detection `switch` block
    in the `update` method of the `PlatformView` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Go ahead and add a whole bunch of drones to `LevelCave` and watch them fly at
    the player. Note that if a drone catches the player, he dies and respawns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![The drone](img/B04322_07_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Now, as if the world wasn't a dangerous enough place with all those enemy drones,
    let's add another type of enemy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The guard
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The guard enemy will be an exercise in scripting. We will have our `LevelManager`
    class automatically generate a simple script, which generates a route for our
    guard to patrol.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The route will be the simplest one possible; it will be just two waypoints that
    the guard will walk between continuously. It will be much quicker and simpler
    to preprogram our guards with two predetermined waypoints. However, by taking
    the time to have it automatically generated, we can place guards wherever we like
    (within certain parameters) on any level we design, and the behavior will be taken
    care of for us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Our guard will be animated, so we will be using a sprite sheet and configuring
    the animation details in the constructor; just as we did for the `Player` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `Guard`. First, handle the member variables.
    Our `Guard` class will not only need two waypoints, but also a variable to indicate
    which one the current waypoint is. Like other moving objects, it will need velocity.
    Here is the class declaration and member variables to start coding your class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We need to set up our guards via the constructor. First, setup our animation
    variables, bitmap, and sizes. Then as usual, set the guard's position in the level,
    its hitbox, and the way that it is facing. However, in the last line of the constructor
    we set `currentWaypoint` to `1`; this is new. We will see how this informs our
    guard's behavior in this class's `update` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, add a method that our `LevelManager` class will use to let the `Guard`
    class know what its two waypoints are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we will code the "brains" of our `Guard` class, that is, its `update` method.
    You can basically break this method into two main parts. First, `if(currentWaypoint
    == 1)` and secondly, `if(currentWaypoint == 2)`. Inside each of these `if` blocks,
    simply check if the guard has reached or passed the appropriate waypoint. If it
    has, switch waypoints, reverse the velocity, and make the guard face the other
    way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call `move()` then `setRectHitbox()` to update the hitbox to the new
    location of the guard. Add the code for the `update` method and then we will see
    how to put it to work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Remember to add `guard.png` from the `Chapter7/drawables` folder of the download
    bundle to the `drawable` folder of the project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can make the usual three additions to the `LevelManager` class to load
    any guards that may be found in our level designs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'In `getBitmap()`, add the highlighted code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `getBitmapIndex()`, add the highlighted code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `loadMapData()`, add the highlighted code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We will soon add something totally new to `LevelManager`. That is a method that
    will create the script (set two waypoints to patrol). For this new method to work,
    it needs to know if the tile is suitable for walking on. We will add a new property,
    a getter, and a setter to `GameObject` so that this is easily discoverable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this new member to the `GameObject` class right after the class declaration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add these two methods to the `GameObject` class to get and set this variable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now in the `Grass` class constructor, add a call to `setTraversable()`. We
    must remember to do this for all future `GameObject` derived classes that we design,
    if we want our guards to be able to patrol on them. In `Grass`, add this line
    at the top of the constructor:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, we will look at the new `setWaypoints` method for our `LevelManager` class.
    It needs to examine the level design and calculate two waypoints for any `Guard`
    objects present in that level.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We will break this method into a few parts, so we can see what's happening at
    each stage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to loop through all the `gameObjects` classes looking for the
    `Guard` objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we reach this point in the code, it means we have found a guard who will
    need two waypoints to be set. First, we need to find the tile which the guard
    is "standing on". Then, we calculate the coordinate of the last traversable tile
    on either side, but with a maximum range of five tiles each way. These will be
    the two waypoints. Here, is the code to add to the `setWaypoints` method. It is
    heavily commented to make clear what is going on without interrupting the flow
    by stopping to talk about it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达代码的这一部分，这意味着我们已经找到了一个需要设置两个航点的守卫。首先，我们需要找到守卫“站立”的瓷砖。然后，我们计算每侧最后一个可通行的瓷砖的坐标，但最大范围是每个方向五个瓷砖。这两个点将作为两个航点。以下是添加到`setWaypoints`方法中的代码。它包含大量注释，以清晰说明情况而不中断流程。
- en: '[PRE52]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can call our new `setWaypoints` method as the last thing to do in the
    `LevelManager` constructor. We need to call this method after the `GameObject`
    class''s `ArrayList` has been populated or there will be no guards in it. Add
    the call to `setWaypoints()` as highlighted:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`LevelManager`构造函数的最后调用我们新的`setWaypoints`方法。我们需要在`GameObject`类的`ArrayList`填充完毕后调用此方法，否则其中将没有守卫。像这样突出显示添加对`setWaypoints()`的调用：
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, add this code to the collision detection switch block in the `update`
    method of the `PlatformView` class, so we can bump into the guards.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将这段代码添加到`PlatformView`类的`update`方法中的碰撞检测开关块中，以便我们可以与守卫相撞。
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, add some `g` letters to the `LevelCave` class. Make sure to place
    them with one space above the platform, because they are 2 meters high as in this
    pseudo code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向`LevelCave`类中添加一些`g`字母。确保将它们放置在平台上方一个空格的位置，因为它们的高度是2米，如下面的伪代码所示：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![The guard](img/B04322_07_03.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![守卫](img/B04322_07_03.jpg)'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We implemented guns, pickups, drones, and guards. This means we now have plenty
    of dangers, but have a machine gun that can't do any damage. We will change that
    first thing in the next chapter, by implementing collision detection for our bullets.
    However, we will go slightly further than merely having them hit our enemies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了枪支、拾取物、无人机和守卫。这意味着我们现在有很多危险，但拥有一把无法造成伤害的机枪。我们将在下一章首先解决这个问题，为我们的子弹实现碰撞检测。然而，我们的目标不仅仅是让子弹击中敌人。
