["```java\npackage com.gamecodeschool.c5platformgame;\n```", "```java\nimport android.app.Activity;\nimport android.graphics.Point;\nimport android.os.Bundle;\nimport android.view.Display;\n\npublic class PlatformActivity extends Activity {\n\n    // Our object to handle the View\n    private PlatformView platformView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // Get a Display object to access screen details\n        Display display = getWindowManager().getDefaultDisplay();\n\n        // Load the resolution into a Point object\n        Point resolution = new Point();\n        display.getSize(resolution);\n\n        // And finally set the view for our game\n        // Also passing in the screen resolution\n        platformView = new PlatformView\n        (this, resolution.x, resolution.y);\n\n        // Make our platformView the view for the Activity\n        setContentView(platformView);\n\n    }\n\n    // If the Activity is paused make sure to pause our thread\n    @Override\n    protected void onPause() {\n        super.onPause();\n        platformView.pause();\n    }\n\n    // If the Activity is resumed make sure to resume our thread\n    @Override\n    protected void onResume() {\n        super.onResume();\n        platformView.resume();\n    }\n}\n```", "```java\n    android:name=\".PlatformActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\npublic class PlatformView extends SurfaceView \n  implements Runnable {\n\n  private boolean debugging = true;\n  private volatile boolean running;\n  private Thread gameThread = null;\n\n  // For drawing\n  private Paint paint;\n  // Canvas could initially be local.\n  // But later we will use it outside of draw()\n  private Canvas canvas;\n  private SurfaceHolder ourHolder;\n\n  Context context;\n  long startFrameTime;\n  long timeThisFrame;\n  long fps;\n\n   // Our new engine classes\n   private LevelManager lm;\n   private Viewport vp;\n   InputController ic;\n```", "```java\nPlatformView(Context context, int screenWidth, \n    int screenHeight) {\n\n    super(context);\n    this.context = context;\n\n    // Initialize our drawing objects\n    ourHolder = getHolder();\n    paint = new Paint();\n}\n```", "```java\n@Override\npublic void run() {\n\n  while (running) {\n       startFrameTime = System.currentTimeMillis();\n\n       update();\n       draw();\n\n      // Calculate the fps this frame\n      // We can then use the result to\n      // time animations and movement.\n      timeThisFrame = System.currentTimeMillis() - startFrameTime;\n            if (timeThisFrame >= 1) {\n                fps = 1000 / timeThisFrame;\n            }\n     }\n}\n```", "```java\nprivate void update() {\n  // Our new update() code will go here\n}\n```", "```java\nprivate void draw() {\n\n     if (ourHolder.getSurface().isValid()){\n      //First we lock the area of memory we will be drawing to\n      canvas = ourHolder.lockCanvas();\n\n      // Rub out the last frame with arbitrary color\n      paint.setColor(Color.argb(255, 0, 0, 255));\n      canvas.drawColor(Color.argb(255, 0, 0, 255));\n\n      // New drawing code will go here\n\n      // Unlock and draw the scene\n      ourHolder.unlockCanvasAndPost(canvas);\n  }\n}\n```", "```java\n// Clean up our thread if the game is interrupted    \npublic void pause() {\n  running = false;\n   try {\n       gameThread.join();\n   } catch (InterruptedException e) {\n       Log.e(\"error\", \"failed to pause thread\");\n   }\n}\n\n// Make a new thread and start it\n// Execution moves to our run method\npublic void resume() {\n   running = true;\n   gameThread = new Thread(this);\n   gameThread.start();\n\n}\n\n}// End of PlatformView\n```", "```java\npublic class Vector2Point5D {\n\n    float x;\n    float y;\n    int z;\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\n```", "```java\npublic abstract class GameObject {\n\n    private Vector2Point5D worldLocation;\n    private float width;\n    private float height;\n\n    private boolean active = true;\n    private boolean visible = true;\n    private int animFrameCount = 1;\n    private char type;\n\n    private String bitmapName;\n\n```", "```java\npublic abstract void update(long fps, float gravity);\n```", "```java\npublic String getBitmapName() {\n        return bitmapName;\n}\n\npublic Bitmap prepareBitmap(Context context, \n    String bitmapName, \n    int pixelsPerMetre) {\n\n   // Make a resource id from the bitmapName\n   int resID = context.getResources().\n        getIdentifier(bitmapName,\n        \"drawable\", context.getPackageName());\n\n    // Create the bitmap\n    Bitmap bitmap = BitmapFactory.\n        decodeResource(context.getResources(),\n        resID);\n\n    // Scale the bitmap based on the number of pixels per metre\n    // Multiply by the number of frames in the image\n    // Default 1 frame\n    bitmap = Bitmap.createScaledBitmap(bitmap,\n                (int) (width * animFrameCount * pixelsPerMetre),\n                (int) (height * pixelsPerMetre),\n                false);\n\n    return bitmap;\n}\n```", "```java\n    public Vector2Point5D getWorldLocation() {\n        return worldLocation;\n    }\n\n    public void setWorldLocation(float x, float y, int z) {\n        this.worldLocation = new Vector2Point5D();\n        this.worldLocation.x = x;\n        this.worldLocation.y = y;\n        this.worldLocation.z = z;\n    }\n```", "```java\n    public void setBitmapName(String bitmapName){\n        this.bitmapName = bitmapName;\n    }\n\n    public float getWidth() {\n        return width;\n    }\n\n    public void setWidth(float width) {\n        this.width = width;\n    }\n\n    public float getHeight() {\n        return height;\n    }\n\n    public void setHeight(float height) {\n        this.height = height;\n    }\n```", "```java\n    public boolean isActive() {\n        return active;\n    }\n\n    public boolean isVisible() {\n        return visible;\n    }\n\n    public void setVisible(boolean visible) {\n        this.visible = visible;\n    }\n```", "```java\n    public char getType() {\n        return type;\n    }\n\n    public void setType(char type) {\n        this.type = type;\n    }\n\n}// End of GameObject\n```", "```java\npublic class Grass extends GameObject {\n\n    Grass(float worldStartX, float worldStartY, char type) {\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 1 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType(type);\n\n        // Choose a Bitmap\n        setBitmapName(\"turf\");\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n    }\n\n    public void update(long fps, float gravity) {}\n}\n```", "```java\nimport android.content.Context;\n\npublic class Player extends GameObject {\n\n    Player(Context context, float worldStartX, \n        float worldStartY, int pixelsPerMetre) {\n\n        final float HEIGHT = 2;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 2 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType('p');\n\n        // Choose a Bitmap\n        // This is a sprite sheet with multiple frames\n        // of animation. So it will look silly until we animate it\n        // In chapter 6.\n\n        setBitmapName(\"player\");\n\n        // X and y locations from constructor parameters\n\n        setWorldLocation(worldStartX, worldStartY, 0);\n\n    }\n\n    public void update(long fps, float gravity) {\n\n    }\n}\n```", "```java\nimport android.graphics.Rect;\n\npublic class Viewport {\n    private Vector2Point5D currentViewportWorldCentre;\n    private Rect convertedRect;\n    private int pixelsPerMetreX;\n    private int pixelsPerMetreY;\n    private int screenXResolution;\n    private int screenYResolution;\n    private int screenCentreX;\n    private int screenCentreY;\n    private int metresToShowX;\n    private int metresToShowY;\n    private int numClipped;\n```", "```java\n Viewport(int x, int y){\n\n        screenXResolution = x;\n        screenYResolution = y;\n\n        screenCentreX = screenXResolution / 2;\n        screenCentreY = screenYResolution / 2;\n\n        pixelsPerMetreX = screenXResolution / 32;\n        pixelsPerMetreY = screenYResolution / 18;\n\n        metresToShowX = 34;\n        metresToShowY = 20;\n\n        convertedRect = new Rect();\n        currentViewportWorldCentre = new Vector2Point5D();\n\n}\n```", "```java\nvoid setWorldCentre(float x, float y){\n  currentViewportWorldCentre.x  = x;\n  currentViewportWorldCentre.y  = y;\n}\n```", "```java\npublic int getScreenWidth(){\n  return  screenXResolution;\n}\n\npublic int getScreenHeight(){\n  return  screenYResolution;\n}\n\npublic int getPixelsPerMetreX(){\n  return  pixelsPerMetreX;\n}\n```", "```java\n\npublic Rect worldToScreen(\n  float objectX, \n  float objectY, \n  float objectWidth, \n  float objectHeight){\n\n   int left = (int) (screenCentreX -               \n    ((currentViewportWorldCentre.x - objectX) \n    * pixelsPerMetreX));\n\n    int top =  (int) (screenCentreY -         \n    ((currentViewportWorldCentre.y - objectY) \n    * pixelsPerMetreY));\n\n   int right = (int) (left + \n    (objectWidth * \n    pixelsPerMetreX));\n\n  int bottom = (int) (top + \n    (objectHeight * \n    pixelsPerMetreY));\n\n  convertedRect.set(left, top, right, bottom);\n\n  return convertedRect;\n}\n```", "```java\n\npublic boolean clipObjects(float objectX, \n  float objectY, \n  float objectWidth, \n  float objectHeight) {\n\n  boolean clipped = true;\n\n   if (objectX - objectWidth < \n    currentViewportWorldCentre.x + (metresToShowX / 2)) {\n\n    if (objectX + objectWidth > \n      currentViewportWorldCentre.x - (metresToShowX / 2)) {\n\n      if (objectY - objectHeight <           \n        currentViewportWorldCentre.y + \n        (metresToShowY / 2)) {\n\n        if (objectY + objectHeight >       \n          currentViewportWorldCentre.y - \n          (metresToShowY / 2)){\n\n                 clipped = false;\n        }     \n      }\n\n    }\n\n  }\n\n   // For debugging\n   if(clipped){\n       numClipped++;\n   }\n\n   return clipped;\n}\n```", "```java\npublic int getNumClipped(){\n  return numClipped;    \n}\n\npublic void resetNumClipped(){\n  numClipped = 0;\n}\n\n}// End of Viewport\n```", "```java\n  // Initialize our drawing objects\n  ourHolder = getHolder();\n  paint = new Paint();\n\n // Initialize the viewport\n vp = new Viewport(screenWidth, screenHeight);\n\n}// End of constructor\n```", "```java\npublic class InputController {\n    InputController(int screenWidth, int screenHeight) {\n    }\n}\n```", "```java\nimport java.util.ArrayList;\n\npublic class LevelData {\n    ArrayList<String> tiles;\n\n    // This class will evolve along with the project\n\n    // Tile types\n    // . = no tile\n    // 1 = Grass\n\n}\n```", "```java\nimport java.util.ArrayList;\n\npublic class LevelCave extends LevelData{\n    LevelCave() {\n    tiles = new ArrayList<String>();\n    this.tiles.add(\"p.............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\".....................111111...................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"............111111............................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\".........1111111..............................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................11111111........\");\n    this.tiles.add(\"..............................................\");\n    }\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Rect;\nimport java.util.ArrayList;\n```", "```java\npublic class LevelManager {\n\n    private String level;\n    int mapWidth;\n    int mapHeight;\n\n    Player player;\n    int playerIndex;\n\n    private boolean playing;\n    float gravity;\n\n    LevelData levelData;\n    ArrayList<GameObject> gameObjects;\n\n    ArrayList<Rect> currentButtons;\n    Bitmap[] bitmapsArray;\n```", "```java\npublic LevelManager(Context context, \n    int pixelsPerMetre, int screenWidth, \n    InputController ic, \n    String level, \n    float px, float py) {\n\n    this.level = level;\n\n    switch (level) {\n        case \"LevelCave\":\n        levelData = new LevelCave();\n        break;\n\n        // We can add extra levels here\n\n    }\n\n    // To hold all our GameObjects\n    gameObjects = new ArrayList<>();\n\n    // To hold 1 of every Bitmap\n    bitmapsArray = new Bitmap[25];\n\n    // Load all the GameObjects and Bitmaps\n    loadMapData(context, pixelsPerMetre, px, py);\n\n    // Ready to play\n    playing = true;\n}\n\npublic boolean isPlaying() {\n    return playing;\n}\n```", "```java\n    // Each index Corresponds to a bitmap\n    public Bitmap getBitmap(char blockType) {\n\n        int index;\n        switch (blockType) {\n            case '.':\n                index = 0;\n                break;\n\n            case '1':\n                index = 1;\n                break;\n\n            case 'p':\n                index = 2;\n                break;\n\n            default:\n                index = 0;\n                break;\n        }// End switch\n\n        return bitmapsArray[index];\n\n }// End getBitmap\n```", "```java\n// This method allows each GameObject which 'knows'\n// its type to get the correct index to its Bitmap\n// in the Bitmap array.\npublic int getBitmapIndex(char blockType) {\n\n    int index;\n        switch (blockType) {\n            case '.':\n                index = 0;\n                break;\n\n            case '1':\n                index = 1;\n                break;\n\n            case 'p':\n                index = 2;\n                break;\n\n            default:\n                index = 0;\n                break;\n\n        }// End switch\n\n        return index;\n    }// End getBitmapIndex()\n```", "```java\n// For now we just load all the grass tiles\n// and the player. Soon we will have many GameObjects\nprivate void loadMapData(Context context, \n  int pixelsPerMetre, \n  float px, float py) {\n\n   char c;\n\n   //Keep track of where we load our game objects\n   int currentIndex = -1;\n\n   // how wide and high is the map? Viewport needs to know\n   mapHeight = levelData.tiles.size();\n   mapWidth = levelData.tiles.get(0).length();\n```", "```java\nfor (int i = 0; i < levelData.tiles.size(); i++) {\n            for (int j = 0; j < \n                    levelData.tiles.get(i).length(); j++) {\n\n                c = levelData.tiles.get(i).charAt(j);\n\n                    // Don't want to load the empty spaces\n                    if (c != '.'){ \n                      currentIndex++;\n                      switch (c) {\n\n                        case '1':\n                            // Add grass to the gameObjects\n                            gameObjects.add(new Grass(j, i, c));\n                            break;\n\n                        case 'p':\n                            // Add a player to the gameObjects\n                            gameObjects.add(new Player\n                                (context, px, py, \n                                 pixelsPerMetre));\n\n                            // We want the index of the player\n                            playerIndex = currentIndex;\n                            // We want a reference to the player\n                            player = (Player)           \n                            gameObjects.get(playerIndex);\n\n                            break;\n\n            }// End switch\n```", "```java\n// If the bitmap isn't prepared yet\nif (bitmapsArray[getBitmapIndex(c)] == null) {\n\n    // Prepare it now and put it in the bitmapsArrayList\n    bitmapsArray[getBitmapIndex(c)] =\n        gameObjects.get(currentIndex).\n        prepareBitmap(context,                                                \n        gameObjects.get(currentIndex).                                                        \n        getBitmapName(),                                     \n        pixelsPerMetre);\n\n}// End if\n\n}// End if (c != '.'){ \n\n}// End for j\n\n}// End for i\n\n}// End loadMapData()\n\n}// End LevelManager\n```", "```java\n  // Initialize the viewport\n  vp = new Viewport(screenWidth, screenHeight);\n\n // Load the first level\n loadLevel(\"LevelCave\", 15, 2);\n\n}\n```", "```java\npublic void loadLevel(String level, float px, float py) {\n\n    lm = null;\n\n    // Create a new LevelManager\n    // Pass in a Context, screen details, level name \n    // and player location\n    lm = new LevelManager(context, \n        vp.getPixelsPerMetreX(), \n        vp.getScreenWidth(), \n        ic, level, px, py);\n\n    ic = new InputController(vp.getScreenWidth(),       \n        vp.getScreenHeight());\n\n    // Set the players location as the world centre     \n    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().x,\n        lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().y);\n    }\n```", "```java\nfor (GameObject go : lm.gameObjects) {\n        if (go.isActive()) {\n            // Clip anything off-screen\n            if (!vp.clipObjects(go.getWorldLocation().x,                                \n                go.getWorldLocation().y, \n                go.getWidth(), \n                go.getHeight())) {\n\n                // Set visible flag to true\n                go.setVisible(true);\n\n            } else {\n                // Set visible flag to false\n                go.setVisible(false);\n                // Now draw() can ignore them\n\n            }\n        }\n\n    }\n}\n```", "```java\nprivate void draw() {\n\n    if (ourHolder.getSurface().isValid()) {\n        //First we lock the area of memory we will be drawing to\n        canvas = ourHolder.lockCanvas();\n\n        // Rub out the last frame with arbitrary color\n        paint.setColor(Color.argb(255, 0, 0, 255));\n        canvas.drawColor(Color.argb(255, 0, 0, 255));\n // Draw all the GameObjects\n Rect toScreen2d = new Rect();\n\n // Draw a layer at a time\n for (int layer = -1; layer <= 1; layer++){\n for (GameObject go : lm.gameObjects) {\n //Only draw if visible and this layer\n if (go.isVisible() && go.getWorldLocation().z \n == layer) { \n\n toScreen2d.set(vp.worldToScreen\n (go.getWorldLocation().x,\n go.getWorldLocation().y,\n go.getWidth(),\n go.getHeight()));\n\n // Draw the appropriate bitmap\n canvas.drawBitmap(\n lm.bitmapsArray\n [lm.getBitmapIndex(go.getType())],\n toScreen2d.left,\n toScreen2d.top, paint);\n }\n }\n}\n\n```", "```java\n// Text for debugging\nif (debugging) {\n paint.setTextSize(16);\n paint.setTextAlign(Paint.Align.LEFT);\n paint.setColor(Color.argb(255, 255, 255, 255));\n canvas.drawText(\"fps:\" + fps, 10, 60, paint);\n\n canvas.drawText(\"num objects:\" + \n lm.gameObjects.size(), 10, 80, paint);\n\n canvas.drawText(\"num clipped:\" + \n vp.getNumClipped(), 10, 100, paint);\n\n canvas.drawText(\"playerX:\" + \n lm.gameObjects.get(lm.playerIndex).\n getWorldLocation().x,\n 10, 120, paint);\n\n canvas.drawText(\"playerY:\" + \n lm.gameObjects.get(lm.playerIndex).\n getWorldLocation().y, \n 10, 140, paint);\n\n //for reset the number of clipped objects each frame\n vp.resetNumClipped();\n\n}// End if(debugging)\n\n// Unlock and draw the scene\nourHolder.unlockCanvasAndPost(canvas);\n\n}// End (ourHolder.getSurface().isValid())\n}// End draw()\n```"]