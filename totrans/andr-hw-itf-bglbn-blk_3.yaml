- en: Chapter 3. Handling Inputs and Outputs with GPIOs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 使用GPIO处理输入和输出
- en: In the last chapter, you prepared your development PC and BBBAndroid system
    for the development of hardware-interfacing Android apps. Now that your development
    environment is set up and ready to go, you will begin exploring your very first
    app that is capable of direct communication with hardware connected to the BBB.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章节中，你已经为开发硬件接口的Android应用准备好了开发PC和BBBAndroid系统。现在，你的开发环境已经搭建好并准备就绪，你将开始探索你的第一个能够与连接到BBB的硬件直接通信的应用。
- en: '**General**-**Purpose Input/Output** (**GPIO**) is one of the most basic interfaces
    in digital electronics. In the examples within this chapter, you will be working
    with GPIOs to receive digital input signals from the outside world and send digital
    output signals back in response. While this is a small start, it is the first
    step in developing and understanding hardware-interfacing apps that are much more
    complex. GPIOs can be used to implement complex and powerful interfacing logic.
    We will discuss both the hardware and software sides of GPIO interfacing and explain
    how calling Java methods in Android apps can interface with low-level hardware-interfacing
    code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用输入/输出**（**GPIO**）是数字电子学中最基本的接口之一。在本章的示例中，你将使用GPIO接收来自外部世界的数字输入信号，并发送数字输出信号作为响应。虽然这是一个小的开始，但这是发展和理解更复杂的硬件接口应用的第一步。GPIO可以用来实现复杂且强大的接口逻辑。我们将讨论GPIO接口的硬件和软件方面，并解释如何在Android应用中调用Java方法以与低级硬件接口代码交互。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节，我们将涵盖以下主题：
- en: Understanding GPIOs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解GPIO
- en: Building a GPIO interface circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建GPIO接口电路
- en: Including PacktHAL within your apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用中包含PacktHAL
- en: Exploring the GPIO example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索GPIO示例应用
- en: Understanding GPIOs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解GPIO
- en: At its most basic level, communication between two pieces of hardware requires
    the transmission of data back and forth between them. In computer systems, this
    data is represented as voltage levels sent over a wire that connects the devices
    together. The patterns and levels of voltage back and forth form a communication
    protocol that the devices use to transmit data between each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，两块硬件之间的通信需要在它们之间来回传输数据。在计算机系统中，这些数据被表现为通过连接设备的电线发送的电压级别。电压来回的模式和级别形成了一种通信协议，设备使用该协议在彼此之间传输数据。
- en: GPIO is the most basic interfacing option offered by microcontrollers and microprocessors.
    Some pins of the BBB's processor are allocated as GPIOs that act as an *input*
    (monitoring voltage on the wire to receive data) or an *output* (placing a particular
    voltage on the wire to send data). The BBB has dozens of available GPIO pins,
    which makes GPIO a flexible and simple way for Android apps to interact with the
    outside world without requiring fancy device drivers or extra interfacing hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO是微控制器和微处理器提供的最基本的接口选项。BBB处理器的某些引脚被分配为GPIO，可以作为*输入*（监测线上的电压以接收数据）或*输出*（在线上放置特定电压以发送数据）。BBB有数十个可用的GPIO引脚，这使得GPIO成为Android应用与外部世界交互的一种灵活且简单的方式，无需复杂的设备驱动程序或额外的接口硬件。
- en: Nuts and bolts of GPIO
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO的细节
- en: Digital logic operates on the concept that there are two discrete voltage levels
    that represent an *on/high* state and an *off/low* state. By toggling between
    these two states, binary bits of data are transmitted between devices. The BBB
    uses the voltage of 3.3 V for its high level and a voltage of 0 V (connected to
    a ground) for the low level. This voltage scheme is known as a *3.3 V logic level*,
    and it is commonly used for single-board computers such as the BeagleBoard and
    Raspberry Pi. Many microcontrollers (many Arduinos, for example) use a 5 V logic
    level instead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数字逻辑基于这样的概念：有两个离散的电压级别，分别代表*开启/高电平*和*关闭/低电平*状态。通过在这两个状态之间切换，可以在设备之间传输二进制位数据。BBB（BeagleBone
    Black）使用3.3 V的电压代表高电平，0 V（接地）的电压代表低电平。这种电压方案称为*3.3 V逻辑电平*，它通常用于像BeagleBoard和Raspberry
    Pi这样的单板计算机。许多微控制器（例如，许多Arduino板）则使用5 V逻辑电平。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Never apply more than 3.3 V to any BBB pin!**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**切勿对任何BBB引脚施加超过3.3 V的电压！**'
- en: Applying greater than 3.3 V to a BBB GPIO can fry the BBB's processor, so always
    make sure that you only work with a maximum of 3.3 V when designing the GPIO interface
    circuitry for the BBB. Pins P9.3/4 supply 3.3 V, and pins P9.5/6 supply 5 V. It
    is very simple to accidentally connect a breadboard wire to the pins supplying
    5 V when you intended to use the 3.3 V pins. To help avoid this mistake, try covering
    the P9.5/6 pins with a piece of tape. This prevents you from accidentally inserting
    a breadboard wire into these pins.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 向BBB GPIO施加超过3.3V的电压可能会烧毁BBB的处理器，因此在设计BBB的GPIO接口电路时，请务必确保你只使用最多3.3V的电压。P9.3/4引脚提供3.3V，而P9.5/6引脚提供5V。当你打算使用3.3V引脚时，很容易不小心将面包板线连接到提供5V的引脚上。为了避免这个错误，可以尝试用一块胶带覆盖P9.5/6引脚。
- en: The BBB's processor has four banks of GPIOs, with 32 individual GPIOs in each
    bank. With only 92 pins available on the P8/9 connectors, it is not possible to
    give every GPIO access to the outside world. In fact, the BBB's System Reference
    Manual shows that it is only possible to mux about 65 unique GPIOs to P8/P9 at
    the same time, even if every other feature being muxed to P8/9 was disabled. There
    are a few other GPIOs that are used internally for tasks such as lighting and
    blinking the BBB's LEDs, but you should consider yourself restricted to only using
    the GPIOs that are accessible via P8/P9 and that do not conflict with any of the
    standard BBB features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的处理器有四个GPIO组，每组有32个单独的GPIO。在P8/9连接器上只有92个引脚可用，不可能让每个GPIO都对外界开放。实际上，BBB的系统参考手册显示，即使禁用了所有其他被复用到P8/9的功能，同时最多也只能将大约65个独特的GPIO复用到P8/P9。还有一些其他的GPIO内部用于诸如点亮和闪烁BBB的LED等任务，但你应该认为只能使用通过P8/P9访问且不与任何标准的BBB功能冲突的GPIO。
- en: GPIO access methods under Android
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android下的GPIO访问方法
- en: 'There are two basic approaches to interacting with GPIOs on the BBB: **file
    I/O** and **memory-mapping**. With the file I/O, you pass GPIO requests through
    a kernel driver by reading and writing to GPIO files in the filesystem. With memory-mapping,
    you map the GPIO control resistors into memory and then read and write these mapped
    memory locations to directly manipulate the control resistors. As both of these
    methods are made possible by the Linux kernel, they will both work just as well
    under Android as they do under Linux.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与BBB上的GPIO交互有两种基本方法：**文件I/O**和**内存映射**。使用文件I/O，你通过读取和写入文件系统中的GPIO文件，通过内核驱动程序传递GPIO请求。使用内存映射，你将GPIO控制电阻映射到内存中，然后读取和写入这些映射的内存位置，直接操纵控制电阻。由于这两种方法都是由Linux内核实现的，它们在Android下的工作效果和在Linux下一样好。
- en: Pros and cons of the file I/O method
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件I/O方法的优缺点
- en: The file I/O method can be performed by any process that has the proper permissions
    to read/write the GPIO device files. However, like any file I/O operation, this
    can be quite slow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O方法可以由任何拥有适当权限来读写GPIO设备文件的过程执行。然而，像任何文件I/O操作一样，这可能会相当慢。
- en: Pros and cons of the memory-mapping method
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存映射方法的优缺点
- en: The memory-mapping method allows you to directly access the resistors that control
    the GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!),
    but only processes with root permissions can use it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射方法允许你直接访问控制GPIO的电阻。内存映射非常快（大约是文件I/O的1000倍！），但只有具有root权限的进程才能使用它。
- en: As your apps are unable to execute with root permissions without some serious
    permission changes, you will be unable to use memory-mapping to access GPIOs.
    This effectively restricts you to only using file I/O for your apps.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的应用程序在未进行一些重要的权限更改的情况下无法以root权限执行，因此你将无法使用内存映射来访问GPIO。这实际上限制了你只能在应用程序中使用文件I/O。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PacktHAL implements both memory-mapping and file I/O for GPIO access. If you
    are interested in the low-level details of how both of these approaches work,
    examine the `jni/gpio.c` file in `PacktHAL.tgz`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL为GPIO访问实现了内存映射和文件I/O。如果你对这两种方法的底层细节感兴趣，请检查`PacktHAL.tgz`中的`jni/gpio.c`文件。
- en: Preparing Android for GPIO use
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为GPIO使用准备Android
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files from PacktHAL
    to your Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable specific GPIOs and allow your apps to
    access them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "Chapter 2. Interfacing with Android")《与Android接口》中，你使用`adb`将两个预构建的文件从PacktHAL推送到你的Android系统中。这两个文件，`BB-PACKTPUB-00A0.dtbo`和`init.{ro.hardware}.rc`，配置了你的Android系统以启用特定的GPIO，并允许你的应用访问它们。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that when we talk about the `init.{ro.hardware}.rc` file, we are referring
    to the `init.genericam33xx(flatteneddevice.tr` file in the root directory of the
    Android filesystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们提到`init.{ro.hardware}.rc`文件时，我们指的是Android文件系统的根目录中的`init.genericam33xx(flatteneddevice.tr`文件。
- en: 'The `BB-PACKTPUB-00A0.dtbo` file is a Device Tree overlay that muxes the BBB
    to support all of the examples in this book. As far as GPIOs are concerned, this
    overlay muxes the P9.11 and P9.13 pins into GPIOs. In the `PacktHAL.tgz` file,
    the source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts`
    file. The code responsible for muxing the two GPIOs is located in the `bb_gpio_pins`
    node within `fragment@0`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BB-PACKTPUB-00A0.dtbo`文件是一个设备树覆盖（Device Tree overlay），它将BBB复用到以支持本书中的所有示例。就GPIO而言，这个覆盖将P9.11和P9.13引脚复用到GPIO。在`PacktHAL.tgz`文件中，覆盖的源代码位于`cape/BB-PACKTPUB-00A0.dts`文件中。负责复用这两个GPIO的代码位于`fragment@0`中的`bb_gpio_pins`节点内。'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The details of the hex values used in the `bb_gpio_pins` node are beyond the
    scope of this book. However, the general idea is that they specify which pin is
    of interest, which mode the pin should be muxed to, a few details about pull-up/pull-down
    resistors, whether it is an input or an output pin, and whether any skewing adjustments
    should be made to the signal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`bb_gpio_pins`节点中使用的十六进制值的细节超出了本书的讨论范围。然而，大致的想法是它们指定了哪个引脚是感兴趣的，应该将引脚复用到哪种模式，关于上拉/下拉电阻的一些细节，它是输入引脚还是输出引脚，以及是否应该对信号进行偏斜调整。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The details of what skew is and how to adjust for it are beyond the scope of
    this book. If you would like to learn more about skewing, we suggest the Wikipedia
    page on the subject as a good starting point ([http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于偏斜（skew）的细节以及如何进行调整超出了本书的讨论范围。如果你想了解更多关于偏斜的信息，我们建议从维基百科的相关页面开始了解（[http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)）。
- en: At boot, this overlay is loaded by the `init.{ro.hardware}.rc` file. The kernel
    then knows which pins are treated as GPIOs. After loading the overlay, the `init.{ro.hardware}.rc`
    file then executes a few commands that explicitly "unlock" these GPIO files for
    use by apps by *exporting* them. Exporting a GPIO pin creates a series of files
    in the `/sys` filesystem that can be read and written to interact with that GPIO
    pin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '在启动时，这个覆盖通过`init.{ro.hardware}.rc`文件加载。然后内核知道哪些引脚被视为GPIO。加载覆盖后，`init.{ro.hardware}.rc`文件执行一些命令，明确地“解锁”这些GPIO文件，通过*导出*使应用可以使用它们。导出一个GPIO引脚会在`/sys`文件系统中创建一系列文件，这些文件可以被读取和写入以与该GPIO引脚进行交互。 '
- en: 'By exporting a GPIO pin and then changing the permissions of the proper files
    in the `/sys` filesystem via `chmod`, any process can read from or write to GPIOs.
    This is exactly what the commands in the `init.{ro.hardware}.rc` file do to allow
    Android apps to interface with GPIOs. The following portion of the `init.{ro.hardware}.rc`
    file performs the export and `chmod` operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出一个GPIO引脚，然后通过`chmod`更改`/sys`文件系统中相应文件的权限，任何进程都可以读取或写入GPIO。这正是`init.{ro.hardware}.rc`文件中的命令所做的，允许Android应用与GPIO接口。`init.{ro.hardware}.rc`文件的以下部分执行了导出和`chmod`操作：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each GPIO has a specific integer identifier that is determined by the bank the
    GPIO belongs to and its position within that bank. In our case, the GPIO muxed
    to P9.11 is the 30th GPIO in bank 0, and P9.13 is the 31st GPIO in bank 0\. This
    makes their integer identifiers 30 and 31, respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO都有一个特定的整型标识符，由GPIO所属的银行（bank）及其在该银行中的位置决定。在我们的案例中，复用到P9.11的GPIO是银行0中的第30个GPIO，而P9.13是银行0中的第31个GPIO。这使得它们的整型标识符分别是30和31。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GPIO pins 30 and 31 are only available via the `/sys` filesystem because
    they were explicitly exported via the `write` commands in the `init.{ro.hardware}.rc`
    file. Other GPIO pins will not be available via the filesystem unless they are
    also explicitly exported in the same fashion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚30和31只能通过`/sys`文件系统使用，因为它们在`init.{ro.hardware}.rc`文件中通过`write`命令明确导出。除非其他GPIO引脚也以同样的方式明确导出，否则它们将无法通过文件系统使用。
- en: This is a very insecure way of allowing GPIO access because it opens up the
    GPIOs for use by processes that we might not want to have direct access to them.
    For experimentation and prototyping, this is not a problem. However, you certainly
    should not do this in a commercial system. Unless you develop a proper, privileged
    Android manager to handle the GPIO resources, you must allow *all* processes to
    access the GPIO files unless you tailor the permissions to only be usable by apps
    belonging to a specific user or group. As each app is assigned its own user, you
    would have to chown the GPIOs to the proper user and group after you install the
    app's `.apk` file onto the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种允许GPIO访问的方式非常不安全，因为它会打开GPIO供我们可能不希望直接访问它们的过程使用。对于实验和原型设计，这不是问题。然而，在商业系统中你绝对不应该这样做。除非你开发了一个合适的、有特权的Android管理器来处理GPIO资源，否则你必须允许*所有*进程访问GPIO文件，除非你定制权限，使其只能被属于特定用户或组的app使用。由于每个app都分配有自己的用户，你需要在将app的`.apk`文件安装到系统上后，将GPIO的所有者更改为正确的用户和组。
- en: Building a GPIO-interfacing circuit
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个GPIO接口电路
- en: Before you begin developing software that communicates using GPIOs, you must
    first construct a hardware circuit for the GPIOs to interface with. For this chapter,
    you will build a simple circuit that consists of a 1k ohm resistor, an LED, and
    a pushbutton switch. Part numbers and suppliers for these components were listed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction to Android
    and the BeagleBone Black"), *Introduction to Android and the BeagleBone Black*.
    Before getting started, be sure that you have all of the proper parts and remove
    all power sources from your BBB (unplug the power supply and USB cables) prior
    to connecting anything to the BBB's P8/P9 connector.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发使用GPIO通信的软件之前，你首先需要构建一个GPIO接口的硬件电路。对于本章，你将构建一个简单的电路，包括1k欧姆电阻、LED和按钮开关。这些部件的零件编号和供应商在[第1章](part0014_split_000.html#page
    "Chapter 1. Introduction to Android and the BeagleBone Black")中列出，*Android和BeagleBone
    Black的介绍*。在开始之前，请确保你有所有适当的部件，并在连接到BBB的P8/P9连接器之前，从BBB上移除所有电源（拔掉电源和USB电缆）。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t disassemble your circuit!**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要拆开你的电路！**'
- en: The GPIO circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as it is
    positioned in the following diagram (towards the top of the breadboard), you can
    simply leave the GPIO components and wires in place as you build the remaining
    circuits in this book. This way, it will already be constructed and working when
    you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete
    Interfacing Solution").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中的GPIO电路是[第6章](part0041_split_000.html#page "Chapter 6. Creating a Complete
    Interfacing Solution")中更大电路的一部分，*创建一个完整的接口解决方案*。如果你按照下面示意图中的位置（在面包板的顶部）构建电路，那么在构建本书其余电路时，你可以简单地将GPIO组件和电线留在原位。这样，当你到达[第6章](part0041_split_000.html#page
    "Chapter 6. Creating a Complete Interfacing Solution")时，它就已经构建好并可以工作了。
- en: Constructing the circuit
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'The circuit that you will build interfaces with the following four BBB''s pins:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建的电路与以下四个BBB引脚接口：
- en: P9.1 (ground)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.1（接地）
- en: P9.3 (3.3 V)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.3（3.3 V）
- en: P9.11 (GPIO)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.11（GPIO）
- en: P9.13 (GPIO)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.13（GPIO）
- en: The P9.11 pin is configured as an output GPIO, and it drives the LED. The P9.13
    pin is configured as an input GPIO, and it sets its state depending upon the input
    voltage that is applied to it. Both GPIO pins are configured by the `BB-PACKTPUB-00A0.dtbo`
    overlay to use an internal pull-up resistor. If you are not familiar with what
    a pull-up resistor is, don't worry. For the purposes of these examples, it simply
    means that the logic level of the GPIOs will not "float" between on and off if
    nothing is attached to the GPIO pins. Instead, the logic level will be "pulled-up"
    to the on state.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: P9.11引脚被配置为输出GPIO，它驱动LED。P9.13引脚被配置为输入GPIO，它根据施加在它上面的输入电压来设置其状态。这两个GPIO引脚都通过`BB-PACKTPUB-00A0.dtbo`覆盖层配置为使用内部上拉电阻。如果你不熟悉上拉电阻是什么，别担心。对于这些示例来说，它仅仅意味着如果GPIO引脚上没有连接任何东西，GPIO的逻辑电平不会在开和关之间“浮动”。相反，逻辑电平会被“上拉”到开启状态。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested in learning more about what a pull-up resistor is and how it works?
    We suggest that you check out this online tutorial on pull-up and pull-down resistors,
    available at [http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于上拉电阻是什么以及它是如何工作的吗？我们建议你查看这个关于上拉和下拉电阻的在线教程，教程地址为[http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor)。
- en: Breadboards typically have two vertical buses on either side that run almost
    the entire length of the breadboard. These buses are used to provide convenient
    access to power and ground signals for any components inserted into the breadboard.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板通常在两侧各有一个几乎贯穿整个面包板长度的垂直总线。这些总线用于为插入面包板的任何组件提供方便的电源和地线接入。
- en: '![Constructing the circuit](img/00010.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![构建电路](img/00010.jpeg)'
- en: The complete GPIO-interfacing circuit
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的GPIO接口电路
- en: 'Now we can start constructing our circuit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始构建我们的电路了：
- en: Connect the BBB's ground (P9.1) and 3.3 V (P9.3) signals to the two vertical
    buses on the breadboard. The ground bus is the vertical bus towards the center
    of the breadboard. The 3.3 V bus is the vertical bus towards the edge of the breadboard.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BBB的地线（P9.1）和3.3V（P9.3）信号连接到面包板上的两个垂直总线上。地线总线是靠近面包板中心的垂直总线。3.3V总线是靠近面包板边缘的垂直总线。
- en: Next, connect the anode, or the positive lead, of the LED to P9.11\. LEDs have
    a polarity, so current will only flow through them in one direction. Current flows
    from the longer lead (the anode) of the LED to the shorter lead (the cathode).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将LED的阳极（或正极引脚）连接到P9.11。LED具有极性，因此电流只能在一个方向上通过它们流动。电流从LED较长的引脚（阳极）流向较短的引脚（阴极）。
- en: If the LED's leads have been cut to the same length and you are unable to tell
    which lead is which, feel around the edge of the LED's plastic casing. The edge
    of the casing is flat on the cathode side and rounded on the anode side. As long
    as the cathode is connected to the ground and the anode is connected to the GPIO
    pin, the LED will work properly.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果LED的引脚被剪成了相同的长度，你无法分辨哪个是哪个，可以摸一下LED塑料外壳的边缘。外壳边缘在阴极侧是平的，在阳极侧是圆的。只要阴极连接到地线，阳极连接到GPIO引脚，LED就能正常工作。
- en: You must limit the current drawn by the LED to ensure that you do not damage
    the GPIO pin, so place a 1K ohm resistor between the LED's cathode lead and the
    ground signal. Resistors do not have a polarity like LEDs do, so the direction
    that you connect it to the breadboard will not matter.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须限制LED的电流，以确保不会损坏GPIO引脚，因此在LED的阴极引脚和地线之间需要放置一个1K欧姆的电阻。电阻没有像LED那样的极性，所以你将其连接到面包板的方向并不重要。
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to learn more about using a current-limiting resistor with an LED,
    such as selecting the right resistor for the task, we suggest that you read the
    tutorial from SparkFun, available at [https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219).
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你希望了解更多关于使用限流电阻与LED配合的信息，例如选择合适的电阻进行任务，我们建议你阅读SparkFun的教程，教程地址为[https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219)。
- en: Now that the LED and resistor have been connected to the BBB, you must connect
    the pushbutton switch. Different switches have different numbers of leads, but
    the switch that we suggested for your use has a total of four leads. These leads
    form two pairs of two leads each. The two leads in each pair are always electrically
    connected to each other, but one pair will only be electrically connected to the
    other pair when the button is being pressed. Two sides of the switch are smooth,
    and the other two sides have two protruding leads on each side. The two protruding
    leads on a single side of the switch belong to different pairs of leads. Pick
    one side of the switch with two leads on it and connect one lead to P9.13 and
    the other lead to the breadboard's ground bus.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然LED和电阻已经连接到BBB，你必须连接按钮开关。不同的开关具有不同数量的引脚，但我们为你推荐的开关总共有四个引脚。这些引脚形成两对，每对两个引脚。每对中的两个引脚始终是电气连接的，但当按下按钮时，一对才会与另一对电气连接。开关的两边是平滑的，另外两边每边有两个突出的引脚。单边开关上的两个突出引脚属于不同对的引脚。选择带有两个引脚的一边开关，将一个引脚连接到P9.13，另一个引脚连接到面包板的接地总线。
- en: Your circuit is now complete. Double-check your wiring against the diagram of
    the complete GPIO-interfacing circuit to ensure that everything is connected properly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电路现在完成了。再次检查你的接线与完整的GPIO接口电路图对照，以确保一切连接正确。
- en: Checking your wiring
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查你的接线
- en: Once you have completed the wiring of the GPIO circuit, you should test it to
    ensure that it works properly. Luckily, you can do this easily by shelling into
    the BBB and working with the exported GPIO pin files. We will assume that you
    are using `adb` to shell into the Android system, but using the FTDI to access
    the console shell will work in exactly the same way.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成GPIO电路的接线后，你应该测试它以确保它正常工作。幸运的是，你可以通过shell进入BBB并处理导出的GPIO针脚文件来轻松完成这个测试。我们将假设你正在使用`adb`进入Android系统，但使用FTDI访问控制台shell的方法完全相同。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How do I use the FTDI cable?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何使用FTDI电缆？**'
- en: If you have never used an FTDI cable to communicate with your BBB, there is
    a page on the [www.elinux.org](http://www.elinux.org) wiki (maintained by the
    BeagleBoard.org staff) that can help you get started, which is [http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未使用过FTDI电缆与BBB通信，有一个由BeagleBoard.org团队维护的[www.elinux.org](http://www.elinux.org)维基页面可以帮助你开始，它是[http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells)。
- en: In this book, we will only be using the USB cable and ADB shell to access the
    BBB. However, learning how to use the FTDI to monitor and troubleshoot your BBB
    can really come in handy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只会使用USB电缆和ADB shell来访问BBB。但是，学习如何使用FTDI来监控和排查BBB问题确实非常有用。
- en: 'Connect power to your BBB and then use the USB cable to connect the BBB to
    your development system. After shelling into the BBB, begin testing your GPIO
    circuit using the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的BBB供电，然后使用USB电缆将BBB连接到你的开发系统。在shell进入BBB后，使用以下步骤开始测试你的GPIO电路：
- en: 'Change into the directory for the GPIO pin muxed to P9.11 (GPIO pin 30):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到与P9.11（GPIO针脚30）复用的GPIO目录：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `echo` command to turn the LED on by forcing the state of this GPIO
    to 1:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`echo`命令通过将此GPIO的状态强制为1来打开LED：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The LED will now be turned on. Use the `echo` command to turn the LED off by
    forcing the state of this GPIO to 0:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在LED将会打开。使用`echo`命令通过将此GPIO的状态强制为0来关闭LED：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The LED will now be turned off. Change into the directory for the GPIO pin
    muxed to P9.13 (the GPIO pin 31):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在LED将会熄灭。切换到与P9.13（GPIO针脚31）复用的GPIO目录：
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the `cat` command to check the current state of the pushbutton switch.
    When executing this command, make sure that you are not pushing the button:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令检查按钮开关的当前状态。在执行此命令时，请确保你没有按下按钮：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, execute the following `cat` command while holding down the button. You
    should type the entire command, press the button, and then hit the *Enter* key
    to enter the command while still holding the button down:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在按住按钮的同时执行以下`cat`命令。你应该输入整个命令，按下按钮，然后按*Enter*键在按住按钮的同时输入命令：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pushbutton values look reversed because of how the circuit is wired. The
    pull-up resistor on P9.13 will pull the value of the GPIO to `1` when the button
    is not pressed. When the button is pressed, the P9.13 pin becomes connected to
    the ground signal and changes the GPIO to `0`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于电路的连线方式，按钮的值看起来是反的。当按钮未被按下时，P9.13上的上拉电阻会将GPIO的值拉至`1`。当按钮被按下时，P9.13引脚连接到地线信号，并将GPIO改变为`0`。
- en: If you saw the LED turn on and off and the correct values were returned when
    the switch was pressed and released, you have correctly wired the circuit. If
    the LED did not light up, make sure that you have not accidentally swapped the
    anode and cathode leads of the LED. If the switch always returns a value of 0,
    make sure that you have connected the correct pair of leads on the switch to the
    ground signal bus and P9.13.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到LED灯在开关按下和释放时点亮和熄灭，并且返回了正确的值，说明你已经正确地连好了电路。如果LED灯没有点亮，请确保你没有意外地交换了LED的阳极和阴极引脚。如果开关总是返回0值，请确保你已经将开关上的正确引脚对连接到地线总线和P9.13。
- en: Including PacktHAL within your apps
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的应用中包含PacktHAL
- en: Before diving into using PacktHAL to interface with GPIOs, you must understand
    how to include PacktHAL support in your apps. We will walk you through the process
    of adding the PacktHAL code into your app and then building it. PacktHAL will
    be packaged with your app in the`.apk` app as a shared library. The source code
    for the library exists within the app's project directory, but it is built separately
    from the Java code of the app. You must manually build the PacktHAL shared library
    before your app can include it within the `.apk` app and use it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PacktHAL与GPIO接口之前，你必须了解如何在你的应用中包含PacktHAL支持。我们将指导你如何将PacktHAL代码添加到你的应用中，并构建它。PacktHAL将与你的应用一起打包在`.apk`文件中，作为一个共享库。该库的源代码位于应用项目目录中，但它与应用的Java代码分开构建。在应用可以在`.apk`文件中包含并使用它之前，你必须手动构建PacktHAL共享库。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We include a prebuilt version of the PacktHAL library in each of the example
    app projects included with this book, so you can jump into building and running
    the example apps right away without worrying about the details of building PacktHAL.
    Once you begin creating your own custom apps and modifying PacktHAL for your own
    hardware projects, you will need to understand how to build PacktHAL from source.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在随书提供的每个示例应用项目中包含了一个预构建的PacktHAL库，这样你就可以立即开始构建和运行示例应用，而无需担心构建PacktHAL的细节。一旦你开始创建自己的自定义应用并修改PacktHAL以适应你的硬件项目时，你将需要了解如何从源代码构建PacktHAL。
- en: Understanding the Java Native Interface
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Java 本地接口（JNI）
- en: Android apps are written in Java, but the functions in PacktHAL are written
    in C native code. Native code is the code that is compiled into a native binary,
    such as a shared library or executable, and then executed directly by the Android
    OS. Native code is built using the compiler toolchain supplied within the Android
    NDK. Native binaries are not as portable as the "build once, run anywhere" bytecode
    of Android apps, but they can be used for low-level interfacing in ways that Java
    code cannot. Unlike Java bytecode, which is executable on any platform that has
    a proper virtual machine, native code is compiled for one specific hardware architecture
    (such as ARM, x86, or PowerPC) and can be executed only on that architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用是用Java编写的，但PacktHAL中的函数是用C本地代码编写的。本地代码是编译成本地二进制文件（如共享库或可执行文件）的代码，然后由安卓操作系统直接执行。本地代码使用安卓NDK提供的编译器工具链构建。本地二进制文件不像安卓应用的“一次构建，到处运行”的字节码那样可移植，但它们可以用Java代码无法实现的方式进行低级接口。与在任何拥有适当虚拟机的平台上可执行的Java字节码不同，本地代码是为特定的硬件架构（如ARM、x86或PowerPC）编译的，并且只能在该架构上执行。
- en: Functions implemented in native code are called from an app's Java code via
    the **Java Native Interface** (**JNI**). JNI is a popular interfacing mechanism
    that Java applications use to interact with native C/C++ code. Among other features,
    JNI is used to *translate* Java datatypes into C datatypes and vice versa.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地代码中实现的功能是通过应用的Java代码通过**Java本地接口**（**JNI**）调用的。JNI是Java应用程序用来与本地C/C++代码交互的一种流行的接口机制。除了其他特性之外，JNI用于将Java数据类型*转换*为C数据类型，反之亦然。
- en: For example, consider the Java `String` type. While Java has a `String` implementation,
    there is no equivalent type in C. The string must be suitably converted to a compatible
    type before it can be used by the C code. Each Java type is represented in C by
    a series of equivalent types, such as `jint`, `jstring`, and `jboolean`, which
    are defined in the standard `jni.h` header file that is supplied by the Android
    NDK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 Java `String`类型。虽然 Java 有一个`String`实现，但 C 中没有等效类型。字符串必须适当地转换为一个兼容的类型，然后才能被
    C 代码使用。每个 Java 类型在 C 中都由一系列等效类型表示，如`jint`、`jstring`和`jboolean`，这些类型在 Android NDK
    提供的标准`jni.h`头文件中定义。
- en: Creating a new app project that uses PacktHAL
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个使用 PacktHAL 的新应用项目
- en: 'The following steps demonstrate how you can create a new custom app that includes
    PacktHAL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将演示如何创建一个包含 PacktHAL 的新自定义应用：
- en: Launch the Eclipse ADT and select the menu option **File**, then **New**, then
    **Android Application Project**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse ADT，选择菜单选项**文件**，然后**新建**，接着**Android 应用项目**。
- en: 'In the **New Android Application** dialog, enter `myapp` into the **Application
    Name** field. This will automatically populate the **Project Name** and **Application
    Name** fields. Change the **Minimum Required SDK**, **Target SDK**, and **Compile
    With** fields to **API 19: Android 4.4**. The theme field can be left alone or
    changed to whichever theme you would like for your app. When finished, click on
    the **Next** button.![Creating a new app project that uses PacktHAL](img/00011.jpeg)'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在**新建 Android 应用**对话框中，将`myapp`输入到**应用名称**字段。这将自动填充**项目名称**和**应用名称**字段。将**最低要求的
    SDK**、**目标 SDK**和**编译使用**字段更改为**API 19: Android 4.4**。主题字段可以保持原样，或者根据你希望应用使用的主题进行更改。完成后，点击**下一步**按钮。[创建一个使用
    PacktHAL 的新应用项目](img/00011.jpeg)'
- en: The New Android Application screen
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新 Android 应用界面
- en: Proceed through the successive dialog screens, retaining the default settings
    for each screen, until you click on the **Finish** button on the final screen.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照后续对话框屏幕操作，保留每个屏幕的默认设置，直到在最后一个屏幕上点击**完成**按钮。
- en: 'The name of the default activity created for your new app is `MainActivity`.
    After creating the new project, the folder structure of your new `myapp` project
    will reside in the `myapp` (`$PROJECT`) directory and have a directory structure
    similar to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的新应用创建的默认活动名称为`MainActivity`。创建新项目后，新的`myapp`项目的文件夹结构将位于`myapp`（`$PROJECT`）目录中，并具有以下类似的目录结构：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After creating the app for the first time, several new folders will be created
    to hold the various intermediary files created during the build process. Once
    you have created your app, you must add the PacktHAL code to it and compile it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首次创建应用后，将创建几个新文件夹以保存构建过程中生成的各种中间文件。创建应用后，你必须向其中添加 PacktHAL 代码并编译它。
- en: Building PacktHAL under Windows
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 下构建 PacktHAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in `c:\`, you can copy the PacktHAL code into your app''s
    project directory (`$PROJECT`) using the following process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL 必须构建成一个库，并包含在你的应用项目代码库中，以便你的应用使用。假设你将`PacktHAL.tgz`文件解压缩并解压在`c:\`中，你可以使用以下过程将
    PacktHAL 代码复制到你的应用项目目录（`$PROJECT`）中：
- en: Open a file explorer window and browse to the `$PROJECT` directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文件资源管理器窗口，浏览到`$PROJECT`目录。
- en: Open a second file explorer window and browse to `c:\PacktHAL`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个文件资源管理器窗口，浏览到`c:\PacktHAL`。
- en: Right-click on the `jni` directory in the `c:\PacktHAL` directory and select
    **Copy** from the context menu.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`c:\PacktHAL`目录中的`jni`目录上右键单击，然后从上下文菜单中选择**复制**。
- en: Right-click anywhere convenient on white space within the `$PROJECT` directory
    window and then select **Paste** from the context menu.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`$PROJECT`目录窗口内的空白处右键单击，然后从上下文菜单中选择**粘贴**。
- en: 'Now that the `jni\` directory exists in your `$PROJECT` directory, you can
    build PacktHAL using the Android NDK. Assuming that you installed the Android
    NDK in `c:\android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然`jni\`目录已经存在于你的`$PROJECT`目录中，你可以使用 Android NDK 构建 PacktHAL。假设你将 Android NDK
    安装在`c:\android-ndk`中，你可以使用以下过程构建 PacktHAL：
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$PROJECT` directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`cmd.exe`以获取命令提示窗口。使用命令提示符，切换到`$PROJECT`目录：
- en: '[PRE9]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Android NDK 构建 PacktHAL 库：
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The PacktHAL library is now built and present in your project as the file `$PROJECT\libs\armeabi\libpacktHAL.so`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PacktHAL库已经构建完成，并作为文件`$PROJECT\libs\armeabi\libpacktHAL.so`存在于你的项目中。
- en: Building PacktHAL under Linux
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux下构建PacktHAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in your `$HOME` directory, you can copy the PacktHAL code
    into your app''s project directory (`$PROJECT`) using the following commands:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 PacktHAL，必须将其构建成库并包含在你的应用程序项目代码库中。假设你在`$HOME`目录下解压并解包了`PacktHAL.tgz`文件，你可以使用以下命令将PacktHAL代码复制到你的应用程序项目目录（`$PROJECT`）中：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the `jni` directory exists in your `$PROJECT` directory, you can build
    PacktHAL using the Android NDK. Assuming that you installed the Android NDK in
    `$HOME/android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你的`$PROJECT`目录中已经存在了`jni`目录，你可以使用Android NDK构建PacktHAL。假设你在`$HOME/android-ndk`中安装了Android
    NDK，你可以使用以下过程构建PacktHAL：
- en: 'Change into the `$PROJECT/jni` directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`$PROJECT/jni`目录：
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android NDK构建PacktHAL库：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The PacktHAL library is now built and present in your project as the `$PROJECT/libs/armeabi/libpacktHAL.so`
    file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PacktHAL库已经构建完成，并作为`$PROJECT/libs/armeabi/libpacktHAL.so`文件存在于你的项目中。
- en: Exploring the GPIO example app
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GPIO示例应用程序
- en: In this section, you will examine the example Android app that performs GPIO
    interfacing on BBB. The purpose of this application is to demonstrate how to use
    PacktHAL to perform GPIO read and write processes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with GPIOs from
    within your Android apps. These functions allow you to read the values of input
    GPIOs and set the values of output GPIOs. The low-level details of the hardware
    interfacing are implemented in PacktHAL, so you can quickly and easily get your
    apps interacting with GPIOs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将研究一个在BBB上进行GPIO接口的Android示例应用程序。该应用程序的目的是演示如何在实际应用程序中使用PacktHAL执行GPIO读写过程。PacktHAL提供了一系列接口函数，你可以使用这些函数在Android应用程序中处理GPIO。这些函数允许你读取输入GPIO的值并设置输出GPIO的值。硬件接口的低级细节在PacktHAL中实现，因此你可以快速轻松地让你的应用程序与GPIO交互。
- en: Before digging through the GPIO app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app, as well as a precompiled `.apk` package, are located in the `chapter3.tgz`
    file, which is available for download from the book's website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨GPIO应用程序的代码之前，你必须将代码安装到你的开发系统中，并将应用程序安装到你的Android系统中。该应用程序的源代码以及预编译的`.apk`包位于`chapter3.tgz`文件中，该文件可在本书的网站下载。
- en: Installing the app and source under Windows
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下安装应用程序和源代码
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to the root directory of
    `c:\` after downloading it and will decompress it from there. We will refer to
    your workspace directory as `$WORKSPACE`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`chapter3.tgz`文件后，你必须解压并解包它。我们将假设你在下载后将`chapter3.tgz`复制到`c:\`的根目录，并从那里开始解压。我们将你的工作空间目录称为`$WORKSPACE`。
- en: 'We will assume that your `adb.exe` binary is in your current path. If it is
    not, call `adb` by using the full path to the `adb.exe` binary:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设你的`adb.exe`二进制文件在当前路径中。如果不是，通过使用`adb.exe`二进制文件的完整路径来调用`adb`：
- en: Open a file explorer window and navigate to the directory.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文件浏览器窗口并导航到该目录。
- en: Right-click on the `chapter3.tgz` file in file explorer and select **Extract
    Here**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件浏览器中右键点击`chapter3.tgz`文件并选择**在此处解压**。
- en: 'A directory named `c:\gpio` now exists, and it contains all of the files for
    the GPIO example app. You must import this project into your Eclipse ADT workspace:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存在一个名为`c:\gpio`的目录，其中包含了GPIO示例应用程序的所有文件。你必须将此项目导入到你的Eclipse ADT工作空间中：
- en: Launch Eclipse ADT.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse ADT。
- en: Open the **File** menu and select **Import**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**文件**菜单并选择**导入**。
- en: On the **Import** dialog, expand the **Android** folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入**对话框中，展开**Android**文件夹并突出显示**将现有Android代码导入工作空间**。对话框底部的**下一步**按钮将变为激活状态。点击它以继续。
- en: On the **Import Projects** dialog, type `c:\gpio` in the **Root Directory**
    text field. Then, click on the **Refresh** button. The **gpio** project will appear
    on the list of projects to import.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入项目**对话框中，在**根目录**文本字段中输入`c:\gpio`。然后，点击**刷新**按钮。`gpio`项目将出现在要导入的项目列表中。
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全选**按钮，然后勾选**将项目复制到工作空间**的复选框。
- en: Click on the **Finish** button to import the `gpio` app project into your workspace
    and copy the `c:\gpio` directory into your `$WORKSPACE` directory.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**按钮，将`gpio`应用程序项目导入你的工作空间，并将`c:\gpio`目录复制到你的`$WORKSPACE`目录中。
- en: 'All of the project files for the GPIO app are now located in that `gpio` directory.
    A prebuilt `.apk` package for the app is provided in the `$WORKSPACE\gpio\bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GPIO应用程序的所有项目文件都位于那个`gpio`目录中。在`$WORKSPACE\gpio\bin`目录中提供了一个预构建的`.apk`软件包。你可以使用`adb`直接将这个`.apk`软件包安装到你的Android系统中：
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$WORKSPACE\gpio\bin` directory:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`cmd.exe`以获取命令提示窗口。使用命令提示符，切换到`$WORKSPACE\gpio\bin`目录：
- en: '[PRE14]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`adb devices`命令验证`adb`是否可以看到你的BBB：
- en: '[PRE15]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`adb`中的`install`命令将`gpio.apk`安装到你的Android系统中：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经安装过一次`gpio.apk`应用程序，并且现在收到`INSTALL_FAILED_ALREADY_EXISTS`的错误信息，请使用`adb`重新安装`gpio.apk`：
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`gpio.apk`应用程序已安装在你的Android系统上，并且应用程序的源代码已安装在Eclipse ADT工作空间中。
- en: Installing the app and source under Linux
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下安装应用程序和源代码
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to your `$HOME` directory
    after downloading it and will decompress it from there. We will refer to your
    workspace directory as `$WORKSPACE`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`chapter3.tgz`文件后，你必须解压缩并展开它。我们将假设你在下载后已将`chapter3.tgz`复制到你的`$HOME`目录，并从那里开始解压缩。我们将你的工作空间目录称为`$WORKSPACE`。
- en: 'Use the Linux `tar` command to decompress and untar the `chapter3.tgz` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux的`tar`命令来解压缩和展开`chapter3.tgz`文件：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A directory named `gpio` now exists in your `$HOME` directory, and it contains
    all of the files for the gpio example app. You must import this project into your
    Eclipse ADT workspace as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的`$HOME`目录中存在一个名为`gpio`的目录，其中包含了gpio示例应用程序的所有文件。你必须按照以下步骤将其导入到你的Eclipse
    ADT工作空间中：
- en: Launch Eclipse ADT.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse ADT。
- en: Open the **File** menu and select **Import**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**文件**菜单，选择**导入**。
- en: On the **Import** dialog, expand the `Android` folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入**对话框中，展开`Android`文件夹并选中**将现有Android代码导入工作空间**。对话框底部的**下一步**按钮将变为可用。点击它以继续。
- en: On the **Import Projects** dialog, type `$HOME/gpio` (substituting in the full
    path for `$HOME`) in the **Root Directory** text field. Then, click on the **Refresh**
    button. The **gpio** project will appear on the list of projects to import.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入项目**对话框中，在**根目录**文本字段中输入`$HOME/gpio`（将`$HOME`替换为完整路径）。然后，点击**刷新**按钮。`gpio`项目将出现在要导入的项目列表中。
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全选**按钮，然后勾选**将项目复制到工作空间**的复选框。
- en: Click on the **Finish** button to import the gpio app project into your workspace
    and copy the `$HOME/gpio` directory into your `$WORKSPACE` directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**按钮，将gpio应用程序项目导入你的工作空间，并将`$HOME/gpio`目录复制到你的`$WORKSPACE`目录中。
- en: 'All of the project files for the app are now located in the `$WORKSPACE/gpio`
    directory. A prebuilt `.apk` package for the gpio project is provided in the `gpio/bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序的所有项目文件都位于`$WORKSPACE/gpio`目录中。在`gpio/bin`目录中提供了一个为gpio项目预构建的`.apk`软件包。你可以使用`adb`直接将这个`.apk`软件包安装到你的Android系统中：
- en: 'Change into the `bin` directory of the `gpio` project:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`gpio`项目的`bin`目录：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`adb devices`命令验证`adb`是否可以看到你的BBB：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`adb`中的`install`命令将`gpio.apk`安装到您的Android系统上：
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经安装过一次`gpio.apk`应用程序，现在收到`INSTALL_FAILED_ALREADY_EXISTS`的错误消息，请使用`adb`重新安装`gpio.apk`：
- en: '[PRE22]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio.apk`应用程序现在已安装在您的Android系统上，应用程序的源代码现在也安装在了您的Eclipse ADT工作空间中。'
- en: The app's user interface
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的用户界面
- en: Launch the `gpio` app on the Android system to see the app's (UI). If you are
    using a touchscreen cape, you can simply touch the gpio app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the gpio
    app icon to launch the app.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统上启动`gpio`应用程序以查看应用程序的用户界面(UI)。如果您使用的是触摸屏保护盖，只需在屏幕上触摸gpio应用图标即可启动应用程序并与其UI交互。如果您使用HDMI进行视频输出，请将USB鼠标连接到BBB的USB端口，并使用鼠标点击gpio应用图标以启动应用程序。
- en: The app uses a very simple UI to interact with the GPIOs. As it is so simple,
    the only activity that the app has is default `MainActivity`. The UI consists
    of only three buttons and text view.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用一个非常简单的UI与GPIOs交互。由于它非常简单，因此应用程序只有一个默认的`MainActivity`。UI仅由三个按钮和文本视图组成。
- en: '![The app''s user interface](img/00012.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的用户界面](img/00012.jpeg)'
- en: The GPIO sample app screen
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO示例应用程序屏幕
- en: The **Poll Button State** button checks the current state of the pushbutton
    switch and updates the value of the **Button State** text view to report that
    state. The switch state will be reported as **UNKNOWN** until the **Poll Button
    State** button is pressed for the first time. The **Turn light on** button will
    turn on the LED if it is not already on, and the **Turn light off** button will
    turn the LED off.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询按钮状态**按钮检查按钮开关的当前状态，并更新**按钮状态**文本视图的值以报告该状态。在第一次按下**轮询按钮状态**按钮之前，开关状态将报告为**未知**。**打开灯光**按钮将在灯光未打开的情况下打开LED，而**关闭灯光**按钮将关闭LED。'
- en: 'The text view has an ID associated with it in `res/layout/activity_main.xml`
    so that the app can update the text view''s value programmatically:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文本视图在`res/layout/activity_main.xml`中有一个与之关联的ID，这样应用程序就可以编程更新文本视图的值：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of the three buttons have an `onClick()` handler defined:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 三个按钮中的每一个都有一个定义的`onClick()`处理程序：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each `onClick()` handler will trigger one of the PacktHAL GPIO functions to
    read the state of a GPIO or write a new state to a GPIO.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮的`onClick()`处理程序将触发PacktHAL GPIO函数之一，以读取GPIO的状态或将新状态写入GPIO。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a refresher on the fine details of the various Android UI elements,
    there are several resources available online that can help you. We recommend that
    you start with the official Android Developer website at [http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要刷新关于各种Android UI元素的详细信息，网上有许多资源可以帮助您。我们建议您从官方Android开发者网站开始，网址是[http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html)。
- en: Calling the PacktHAL functions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用PacktHAL函数
- en: 'The GPIO interface functionality in PacktHAL is implemented in four C functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL中的GPIO接口功能是通过四个C函数实现的：
- en: '`openGPIO()`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openGPIO()`'
- en: '`readGPIO()`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readGPIO()`'
- en: '`writeGPIO()`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeGPIO()`'
- en: '`closeGPIO()`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeGPIO()`'
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的原型位于应用程序项目中的`jni/PacktHAL.h`头文件中：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ideally, you would load the PacktHAL shared library into your app and then simply
    call the library functions directly to control the GPIOs. The example app actually
    *does* load the PacktHAL library via a `System.loadLibrary()` call, but then things
    become less straightforward because these C functions cannot be called directly.
    You must specify Java methods that, when called, actually call the C functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该将PacktHAL共享库加载到您的应用程序中，然后直接调用库函数来控制GPIOs。示例应用程序实际上通过`System.loadLibrary()`调用来加载PacktHAL库，但随后事情变得不那么直接了，因为这些C函数不能直接调用。您必须指定Java方法，当调用这些方法时，实际上会调用C函数。
- en: 'The `MainActivity` class specifies four methods with the `native` keyword to
    call the PacktHAL C functions in `MainActivity.java`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类指定了四个带有`native`关键字的方法，用于在`MainActivity.java`中调用PacktHAL C函数：'
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These four Java methods specified in `MainActivity` are not actually a direct
    mapping to the C functions of the same name in PacktHAL. Notice that the GPIO
    methods in `MainActivity` are all `private native` within the scope of the class.
    Any method defined with the `native` keyword will attempt to call a native *JNI
    wrapper function* when it is invoked. However, the naming of the invoked JNI wrapper
    function follows some very specific rules that represent the scope of its Java-side
    method. The following figure shows how these JNI wrapper functions finally call
    the GPIO-interfacing functions inside of PacktHAL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`中指定的这四个Java方法实际上并不是直接映射到PacktHAL中同名的C函数。注意，`MainActivity`中的GPIO方法是类范围内所有`private
    native`的。任何使用`native`关键字定义的方法在被调用时都会尝试调用一个本地的*JNI封装函数*。然而，被调用的JNI封装函数的命名遵循一些非常特定的规则，这些规则代表了它Java端方法的范围。下图展示了这些JNI封装函数最终是如何调用PacktHAL内部的GPIO接口函数的：'
- en: '![Calling the PacktHAL functions](img/00013.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![调用PacktHAL函数](img/00013.jpeg)'
- en: The MainActivity methods and the PacktHAL GPIO-interfacing functions that they
    call
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`中的方法以及它们调用的PacktHAL GPIO接口函数'
- en: Each `native` method in the `MainActivity` class with the name `name()` will
    use JNI to call a JNI wrapper function with the name `Java_com_packt_gpio_MainActivity_name()`.
    The name of this wrapper function is determined by replacing each `.` in the fully
    qualified name of the app with an underscore. The `Java_` prefix of the function
    name tells Android that the function is being called via a method in a Java class.
    There are a few exceptions to this JNI naming convention, but this general rule
    will get you through most cases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类中名为`name()`的每个`native`方法将使用JNI来调用名为`Java_com_packt_gpio_MainActivity_name()`的JNI封装函数。这个封装函数的名字是通过将应用全限定名中的每个`.`替换为下划线来确定的。函数名中的`Java_`前缀告诉Android该函数是通过Java类中的方法调用的。关于JNI的命名约定有一些例外，但这个通用规则可以解决大多数情况。'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Do I need to know all about JNI to make my own Android interfacing projects?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**我需要了解所有关于JNI的知识才能进行自己的Android接口项目吗？**'
- en: Not really. Using JNI can be quite confusing, and many, many books and tutorials
    have been dedicated to describing it in great detail. For now, don't worry about
    not knowing everything that there is to know about JNI. When you have spent some
    time experimenting with hardware interfacing under Android, you can revisit this
    topic and learn more of the fine details of how JNI works. In this book, we will
    focus on showing you just enough information about JNI to get you started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定。使用JNI可能会相当混乱，许多书籍和教程都详细描述了它。现在，不必担心关于JNI的一切都不了解。当你花时间在Android下进行硬件接口实验后，可以重新审视这个主题，了解更多关于JNI工作原理的细节。在本书中，我们将专注于提供足够的关于JNI的信息，以帮助你开始。
- en: 'As an example, our Java `openGPIO()` method in the `MainActivity` class for
    the `com.packtpub.gpio` example app uses JNI to call the wrapper C function `Java_com_packtpub_gpio_MainActivity_openGPIO()`.
    This is a little confusing, but still very manageable. PacktHAL implements these
    JNI wrapper C functions in the `jni/packt_native_gpio.c` file. Looking at this
    source file, you can see where the `Java_com_packtpub_gpio_MainActivity_openGPIO()`
    function in PacktHAL calls the `openGPIO()` C function in PacktHAL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，在我们的`com.packtpub.gpio`示例应用中，`MainActivity`类里的Java `openGPIO()`方法使用了JNI来调用封装的C函数`Java_com_packtpub_gpio_MainActivity_openGPIO()`。这可能有些令人困惑，但仍然是可以管理的。PacktHAL在`jni/packt_native_gpio.c`文件中实现了这些JNI封装的C函数。查看这个源文件，你可以看到PacktHAL中的`Java_com_packtub_gpio_MainActivity_openGPIO()`函数是如何调用PacktHAL中的`openGPIO()`
    C函数的：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Why not just do away with the separate `openGPIO()` C function and place all
    of the hardware interface code inside `Java_com_packt_gpio_MainActivity_openGPIO()`?
    Functions such as `openGPIO()` in PacktHAL will usually not change once you have
    them working properly, and you can use these same functions under both Linux and
    Android. Wrapper functions such as `Java_com_packt_gpio_MainActivity_openGPIO()`
    will change their name and implementation details based upon how and where they
    are invoked from an app's Java code. It is better to isolate functionality that
    will not change in its own function. This avoids your accidentally breaking something
    when customizing or renaming the functions invoked via JNI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不干脆取消单独的 `openGPIO()` C 函数，并将所有硬件接口代码放入 `Java_com_packt_gpio_MainActivity_openGPIO()`
    中呢？一旦你让它们正常工作，PacktHAL 中的函数如 `openGPIO()` 通常不会改变，而且你可以在 Linux 和 Android 下使用这些相同的函数。像
    `Java_com_packt_gpio_MainActivity_openGPIO()` 这样的包装函数会根据它们如何以及从应用的 Java 代码何处被调用而改变其名称和实现细节。将不会改变的功能隔离在其自己的函数中是更好的选择。这样可以避免在自定义或重命名通过
    JNI 调用的函数时意外破坏某些东西。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just remember that a Java method in your app, such as `openGPIO()` in the `MainActivity`
    class, makes a JNI call to invoke a PacktHAL C function with a long, mangled name
    like `Java_com_packt_gpio_MainActivity_openGPIO()`. The JNI wrapper function will
    then call one of the PacktHAL C functions, for example, `openGPIO()`, that actually
    controls the hardware. From the app developer's point of view, once you sort out
    the JNI wrapper function details, it is almost like calling the C function that
    controls the hardware directly from the Java app code!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你的应用中的 Java 方法（如 `MainActivity` 类中的 `openGPIO()`）会进行 JNI 调用，以调用具有长且复杂名称的
    PacktHAL C 函数，如 `Java_com_packt_gpio_MainActivity_openGPIO()`。JNI 包装函数然后将调用 PacktHAL
    C 函数之一，例如 `openGPIO()`，实际控制硬件。从应用开发者的角度来看，一旦你弄清楚 JNI 包装函数的细节，几乎就像直接从 Java 应用代码调用控制硬件的
    C 函数一样！
- en: Using the PacktHAL GPIO functions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PacktHAL GPIO 函数
- en: Now that you have seen how the PacktHAL GPIO functions are called from Java,
    you will see what each of these functions does and how you can use them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何从 Java 调用 PacktHAL GPIO 函数，接下来你将了解这些函数各自的作用以及如何使用它们。
- en: The `openGPIO()` function initializes your app's access to GPIOs. This function
    offers you two different methods for GPIO interfacing, of which you select one
    method using `openGPIO()` function's `useMmap` parameter. The two methods are
    file I/O (by setting `useMmap` to 0) and memory-mapping (by setting `useMmap`
    to any non-zero number). To change from one interfacing method to the other, you
    must call `closeGPIO()` to shut down the GPIO portion of PacktHAL and then call
    `openGPIO()` again with a different value for `useMmap`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`openGPIO()` 函数初始化应用对 GPIO 的访问。这个函数为你提供了两种不同的 GPIO 接口方法，你可以使用 `openGPIO()`
    函数的 `useMmap` 参数选择其中一种方法。这两种方法是文件 I/O（通过将 `useMmap` 设置为 0）和内存映射（通过将 `useMmap`
    设置为非零数字）。要从一种接口方法更改为另一种，你必须调用 `closeGPIO()` 来关闭 PacktHAL 的 GPIO 部分，然后再次调用 `openGPIO()`，并为
    `useMmap` 提供不同的值。'
- en: Processes must run as `root` to use memory- mapping to directly access the GPIO
    control resistors. As apps cannot run as root, the JNI wrapper function always
    passes `0` as the `useMmap` argument to `openGPIO()` to force the use of file
    I/O to interact with GPIOs. The `openGPIO()` method in the `MainActivity` class
    does not accept any arguments because of this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 进程必须以 `root` 身份运行，以使用内存映射直接访问 GPIO 控制电阻。由于应用不能以 root 身份运行，JNI 包装函数总是将 `0` 作为
    `useMmap` 参数传递给 `openGPIO()`，以强制使用文件 I/O 与 GPIO 交互。由于这个原因，`MainActivity` 类中的 `openGPIO()`
    方法不接受任何参数。
- en: 'The example app calls the `openGPIO()` method from the `onCreate()` method
    of the `MainActivity` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用从 `MainActivity` 类的 `onCreate()` 方法中调用 `openGPIO()` 方法：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The complementary call to the `closeGPIO()` method is made by the `onDestroy()`
    method of the `MainActivity` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `closeGPIO()` 方法的补充调用是由 `MainActivity` 类的 `onDestroy()` 方法完成的：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `readGPIO()` method reads the state of a particular input GPIO. Both the
    PacktHAL `readGPIO()` function and the `readGPIO()` method in `MainActivity` take
    the same two parameters. The first parameter is a connector number on the BBB
    (8 or 9), and the second parameter is a pin location on that connector (1 through
    42). The `readGPIO()` method is called from within the `onClick()` handler of
    the `PollStatus` button:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`readGPIO()` 方法读取特定输入 GPIO 的状态。PacktHAL 的 `readGPIO()` 函数和 `MainActivity` 中的
    `readGPIO()` 方法接受相同的两个参数。第一个参数是 BBB 上的连接器编号（8 或 9），第二个参数是该连接器上的引脚位置（1 到 42）。`readGPIO()`
    方法在 `PollStatus` 按钮的 `onClick()` 处理程序内被调用：'
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In `onClickPollStatus()`, the `readGPIO()` method call is reading the state
    of the GPIO pin P9.13\. This is the GPIO pin that you connected to the pushbutton
    switch. If the switch is pressed when the `readGPIO()` method is called, `true`
    is returned. Otherwise, `false` is returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClickPollStatus()`中，`readGPIO()`方法的调用是读取GPIO引脚P9.13的状态。这是你连接到按钮开关的GPIO引脚。如果当调用`readGPIO()`方法时开关被按下，将返回`true`。否则，返回`false`。
- en: 'The `writeGPIO()` method is used to set the state of an output GPIO. Both the
    PacktHAL `writeGPIO()` function and the `writeGPIO()` method in `MainActivity`
    take three parameters. The first parameter is the connector number on the BBB
    (8 or 9), the second parameter is a pin location on that connector (1 through
    42), and the third parameter is the value to set (0 or 1). The `writeGPIO()` method
    is called from within the `onClick` handlers of the `LightOn` and `LightOff` buttons:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeGPIO()`方法用于设置输出GPIO的状态。PacktHAL的`writeGPIO()`函数和`MainActivity`中的`writeGPIO()`方法都接受三个参数。第一个参数是BBB上的连接器编号（8或9），第二个参数是连接器上的引脚位置（1到42），第三个参数是要设置的值（0或1）。`writeGPIO()`方法在`LightOn`和`LightOff`按钮的`onClick`处理程序内部被调用：'
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In both of these `onClick()` handlers, the GPIO being set is P9.11\. This is
    the GPIO pin that you connected to the LED. The `onClickButtonLightOn()` method
    sets the GPIO to 1, turning the LED on. Likewise, the `onClickButtonLightOff()`
    method sets the GPIO to 0, turning the LED off.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个`onClick()`处理程序中，设置的GPIO是P9.11。这是你连接到LED的GPIO引脚。`onClickButtonLightOn()`方法将GPIO设置为1，打开LED。同样，`onClickButtonLightOff()`方法将GPIO设置为0，关闭LED。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you ready for a challenge?**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**你准备好迎接挑战了吗？**'
- en: Now that you have seen all of the pieces of the gpio app, why not change it
    to add new functionality? For a challenge, try changing the app to use only a
    single button that toggles the state of the LED. If the LED is currently off,
    pressing the button will turn it on and vice versa. We have provided one possible
    implementation of this in the `chapter3_challenge.tgz` file, which is available
    for download from the book's website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了gpio应用的各个部分，为什么不尝试改变它以添加新功能呢？作为一个挑战，尝试将应用改为仅使用一个按钮来切换LED的状态。如果LED当前是关闭的，按下按钮将会打开它，反之亦然。我们在`chapter3_challenge.tgz`文件中提供了一个可能的实现，你可以在本书的网站上下载。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to GPIOs and how they work. You constructed
    a circuit that uses GPIOs for both input and output, and then you did some basic
    testing on the circuit to ensure that the circuit was constructed properly and
    that the kernel is able to interact with the circuit via the filesystem. You also
    learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file and `BB-PACKTPUB-00A0.dtbo`
    Device Tree overlay that are responsible for configuring GPIOs and making them
    available for your app's use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你介绍了GPIO以及它们的工作原理。你构建了一个使用GPIO进行输入和输出的电路，并对电路进行了基本测试，以确保电路构建正确并且内核能够通过文件系统与电路交互。你还了解了PacktHAL的`init.{ro.hardware}.rc`文件和`BB-PACKTPUB-00A0.dtbo`设备树覆盖部分，它们负责配置GPIO并使它们可供你的应用使用。
- en: We showed you how to add PacktHAL into a newly created app project and how to
    build PacktHAL using the Android NDK. Then, you learned how JNI integrates PacktHAL
    into your Java app via JNI wrapper functions and explored how each GPIO function
    of PacktHAL is called and used from within an app.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向你展示了如何将PacktHAL添加到新创建的应用项目中，以及如何使用Android NDK构建PacktHAL。然后，你学习了JNI如何通过JNI包装函数将PacktHAL集成到你的Java应用中，并探索了如何在应用内部调用并使用PacktHAL的每个GPIO功能。
- en: In the next chapter, you will learn how to integrate I2C bus devices into your
    apps and begin interacting with hardware that is much more sophisticated than
    the basic on/off logic of GPIOs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将I2C总线设备集成到你的应用中，并开始与比GPIO的基本开关逻辑复杂得多的硬件进行交互。
