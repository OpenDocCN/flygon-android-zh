- en: Chapter 3. Fragment Lifecycle and Specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses the relationship of the lifecycle of fragments to that
    of activities, and demonstrates the appropriate programming actions at the various
    points in the lifecycle. The special purpose fragment classes `ListFragment` and
    `DialogFragment` are introduced with coverage of their use and how their behavior
    in the activity lifecycle differs from that of standard fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Fragment setup/display event sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragment teardown/hide event sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `ListFragment` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `DialogFragment` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with a `DialogFragment` class as a traditional `Dialog` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping an existing `Dialog` class in a `DialogFragment` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to coordinate the setup and teardown
    of fragments within their host activities, and be able to effectively utilize
    the `ListFragment` and `DialogFragment` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fragment lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges of developing Android applications is assuring that our
    applications effectively handle the lifecycle of the application's activities.
    During the lifetime of an application, a given activity may be created, destroyed,
    and recreated many times. A simple action such as a user rotating a device from
    a portrait to landscape orientation, or vice-versa, normally causes the visible
    activity to be completely destroyed and recreated using the appropriate resources
    for the new orientation. Applications that do not cooperate effectively with this
    natural lifecycle will often crash or behave in some other undesirable manner.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, each fragment instance exists within a single activity; therefore,
    that fragment must cooperate in some way with the activity lifecycle. In fact,
    not only do fragments cooperate with the activity lifecycle but also they are
    intimately connected.
  prefs: []
  type: TYPE_NORMAL
- en: In both the setup and display phase and hide and teardown phase, fragments provide
    many of the same lifecycle-related callback methods as activities. In addition,
    fragments provide additional lifecycle-related callback methods that relate to
    the fragment's relationship to the containing activity.
  prefs: []
  type: TYPE_NORMAL
- en: As our applications become more sophisticated and we work with more specialized
    implementations of the fragment class, understanding the fragment class' lifecycle
    and the relationship to the activity lifecycle is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are unfamiliar with the basics of Android's activity lifecycle callback
    methods, please see the *Activity Lifecycle* section of the *Android Activity*
    documentation at [http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle](http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fragment setup and display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fragment setup and display is a multiphase process involving the fragment's
    association with an activity, the fragments' creation, and the standard lifecycle
    events of moving the activity into the running state (also known as the resumed
    or active state). Understanding the behavior of the lifecycle events and the associated
    callback methods is essential for using fragments effectively. Once we have an
    understanding of the lifecycle events and the callback methods, we'll look at
    just how the event callback methods are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the sequence of lifecycle-related callback method
    calls that occur on fragments and activities during setup and display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding fragment setup and display](img/3095OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you might expect, in most cases, the first step in the setup and display
    of a fragment occurs in the activity's `onCreate` method. In most cases, the activity
    calls the `setContentView` method from within the activity's `onCreate` callback
    method, which then loads the layout resource and triggers the activity's association
    with the contained fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Notice what happens next. Before the fragment is ever created, the fragment
    is attached to the activity. The fragment is first notified of the attachment
    and receives a reference to the activity through the `onAttach` callback method.
    The activity is then notified and receives a reference to the fragment through
    the `onAttachFragment` callback method.
  prefs: []
  type: TYPE_NORMAL
- en: Although attaching the fragment to the activity prior to creating the fragment
    may seem unexpected, doing so is useful. In many cases, the fragment needs access
    to the activity during the creation process, because the activity often contains
    information that the fragment will display or that is otherwise important to the
    fragment creation process.
  prefs: []
  type: TYPE_NORMAL
- en: With the fragment attached to the activity, the fragment then performs general
    creation work in the `onCreate` method and then constructs the contained view
    hierarchy in the `onCreateView` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an activity contains multiple fragments, Android calls the four methods:
    `Fragment.onAttach`, `Activity.onAttachFragment`, `Fragment.onCreate`, and `Fragment.onCreateView`
    in succession for one fragment before making any calls to these methods for the
    next fragment. This allows each fragment to complete the process of attachment
    and creation before the next fragment begins that process.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the sequence of calling these four methods completes for all the fragments,
    the remaining setup and display callback methods are called individually in succession
    for each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: After the activity completes execution of its `onCreate` method, Android then
    calls each fragment's `onActivityCreated` method. The `onActivityCreated` method
    indicates that all views and fragments created by the activity's layout resource
    are now fully constructed and can be safely accessed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the fragment receives the standard lifecycle callbacks on the
    `onStart` and `onResume` methods, just after the activity methods of the same
    name are each called. Any work performed in the fragment's `onStart` and `onResume`
    methods is very much like the work performed in the corresponding methods within
    an activity.
  prefs: []
  type: TYPE_NORMAL
- en: For many fragments, the only methods in this part of their lifecycle that are
    overridden are the `onCreate` and `onCreateView` methods, as we saw in the examples
    in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding method name confusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The activity and fragment classes have a number of commonly named callback methods,
    and most of these commonly named methods have a common purpose. One important
    exception is the `onCreateView` method. The purpose of this method is very different
    for each class.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Android calls the `Fragment` class' `onCreateView`
    method to give the fragment an opportunity to create and return the fragment's
    contained view hierarchy. This method is commonly overridden within a fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The method of the same name in the `Activity` class is called repeatedly by
    the `LayoutInflater` class during the process of inflating a layout resource.
    Most activity implementations do not override this method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fragment hide and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as fragments behave in a similar way to activities during setup and display,
    they also behave in a similar way during hide and teardown, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding fragment hide and teardown](img/3095OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initially during hide and teardown, fragments behave just as activities. When
    the user switches to another activity, each fragment's `onPause`, `onSaveInstanceState`,
    and `onStop` methods are called. For each method, the fragment implementation
    is called first, followed by the activity implementation.
  prefs: []
  type: TYPE_NORMAL
- en: After the `onStop` method is called, fragments begin to behave a little differently
    than activities. Consistent with the separation of fragment creation from fragment
    view hierarchy creation, fragment view hierarchy destruction is separate from
    fragment destruction. Following the call to the activity's `onStop` method, the
    fragment's `onDestroyView` method is called indicating that the view hierarchy
    returned by the fragment's `onCreateView` method is being destroyed. The fragment's
    `onDestroy` method is then called followed by the fragment's `onDetach` method.
    At this point, the fragment has no association with an activity and any calls
    to the `getActivity` method will return null.
  prefs: []
  type: TYPE_NORMAL
- en: For activities containing multiple fragments, Android calls the sequence of
    the three methods, `onDestroyView`, `onDestroy`, and `onDetach`, for an individual
    fragment, before beginning the sequence of calling these three methods for the
    next fragment. This groups the process of destroying and detaching each fragment
    similar to the way Android groups the process of attaching and creating each fragment.
    Once this sequence completes for all fragments, Android then calls the activity's
    `onDestroy` method.
  prefs: []
  type: TYPE_NORMAL
- en: Maximizing available resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the most part, lifecycle management for a fragment is very much like that
    of an activity. There is, however, one important exception: the two-phase nature
    of fragment creation and destruction. Fragments separate the creation and destruction
    of the fragment from the fragment''s contained view hierarchy. This is because
    fragments have the ability to exist and be associated with an activity in the
    absence of the fragment''s view hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many scenarios where an activity may contain multiple fragments, but
    have only a subset of those fragments visible at any point in time. In such a
    case, the contained fragments can all have their `onAttach` and `onCreate` methods
    called. But the call to each fragment's `onCreateView` method is delayed until
    the time comes for the app to make the contents of that fragment visible. Similarly,
    when the time comes to hide the contents of a fragment, only the fragment's `onDestroyView`
    method is called, not the `onDestroy` and `onDetach` methods.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior comes into play when fragments are dynamically managed within
    an activity. This behavior allows the overhead of associating a fragment with
    an activity and initializing the fragment's state to occur only once while being
    able to easily change the visibility of the fragment's view hierarchy. This is
    important when we explicitly manage the visibility of fragments using the `FragmentTransaction`
    class, and in certain action bar features that manage fragments. We'll talk about
    these issues in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a fragment state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For many fragment implementations, the most important callback method in the
    lifecycle sequence is the `onSaveInstanceState` method. Just as with an activity,
    this callback method provides the fragment with an opportunity to persist any
    state before the fragment is destroyed, such as when the user moves to another
    activity or when the user rotates the device to a different orientation. In both
    of these cases, the activity and contained fragments may be completely torn down
    and recreated. By persisting the fragment state in the `onSaveInstanceState` method,
    that state is latter passed back to the fragment in both the `onCreate` and `onCreateView`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: When managing the state of a fragment, you want to be sure to separate work
    that is general to the fragment's overall existence from work specific to setting
    up the view hierarchy. Any expensive initialization work that's general to the
    fragment's existence such as connecting to a data source, complex calculations,
    or resource allocations should occur in the `onCreate` method rather than the
    `onCreateView` method. This way, if only the fragment's view hierarchy is destroyed
    and the fragment remains intact, you avoid unnecessarily repeating expensive initialization
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Special purpose fragment classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the lifecycle of fragments, we can look at some of the
    specialized versions of the `Fragment` class. As we go through each of these specialized
    classes, remember they all ultimately inherit from the `Fragment` class and therefore
    experience the same lifecycle behavior. Many of these specialized classes have
    an impact on what operations are safe to perform at the various points in the
    lifecycle, and some of these classes even add their own lifecycle methods. Understanding
    each of these classes and their interaction with the fragment lifecycle is essential
    for using the classes effectively.
  prefs: []
  type: TYPE_NORMAL
- en: ListFragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest fragment-derived classes to use and yet one of the most
    helpful is the `ListFragment` class. The `ListFragment` class provides a fragment
    that encapsulates a `ListView` and, as the name implies, is useful for displaying
    lists of data.
  prefs: []
  type: TYPE_NORMAL
- en: Associating data with the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the base `Fragment` class, we're not required to override the `onCreateView`
    callback method for the `ListFragment` class. The `ListFragment` class provides
    a standard appearance and only requires that we associate some data. The `ListFragment`
    class does all the work of creating the view hierarchy and displaying that data.
  prefs: []
  type: TYPE_NORMAL
- en: We associate data with the `ListFragment` class by calling the `ListFragment`
    class' `setListAdapter` method and passing a reference to an object that implements
    the `ListAdapter` interface. Android provides a number of classes that implement
    this interface such as `ArrayAdapter`, `SimpleAdapter`, and `SimpleCursorAdapter`.
    The specific class you use will depend on how your source data is stored. If none
    of the standard Android classes meet your specific requirements, you can create
    a custom implementation reasonably easy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a discussion about creating a custom list adapter, see the Android tutorial
    *Displaying the Quick Contact Badge* at [http://developer.android.com/training/contacts-provider/display-contact-badge.html](http://developer.android.com/training/contacts-provider/display-contact-badge.html).
  prefs: []
  type: TYPE_NORMAL
- en: The call to `setListAdapter` requires that the view hierarchy for the `ListFragment`
    be completely constructed. As a result, we normally do not call the `setListAdapter`
    method any earlier than the `onActivityCreated` callback method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListFragment` class wraps an instance of the `ListView` class, which is
    accessible through the `getListView` method. In most scenarios, we can feel free
    to interact with the contained `ListView` instance directly and take advantage
    of any features offered by the `ListView` class. The one very important exception
    is when we set the `ListAdapter` instance. Both the `ListFragment` and `ListView`
    classes expose a `setListAdapter` method, but we must be sure to use the `ListFragment`
    version of the method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListFragment` class relies on certain initialization behaviors that occur
    within the `ListFragment.setListAdapter` method; therefore, the process of calling
    the `setListAdapter` method directly on the contained `ListView` instance bypasses
    this initialization behavior and may cause the application to become unstable.
  prefs: []
  type: TYPE_NORMAL
- en: Separating data from display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until now, our application has used a fixed layout of several `RadioButton`
    views to display the list of books. Using a fixed layout to display such options
    is not generally a good choice, because any changes to the book list require that
    we go in and directly modify the fragment layout. In practice, we would prefer
    to have a layout that is independent of the specific titles. We could write code
    to dynamically generate the `RadioButton` views, but there is an easier way. We
    can instead use the `ListFragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: By switching our application to use the `ListFragment` class, we can simply
    store the list of book titles in an array resource and associate the contents
    of that array resource with the `ListFragment` instance. In the event of adding
    more titles or needing to change one of the titles, we simply modify the array
    resource file. There is no need for us to make any changes to the actual fragment
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Our application already has all the book titles stored as individual string
    resources, so we just need to add an array resource for them. We'll add the book
    titles array to the `arrays.xml` resource file within the `values` resource folder
    where we currently have an array resource defined to hold the list of book descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `resources` root element of the `arrays.xml` resource file, add
    a `string-array` element that includes a `name` attribute with a value of `bookTitles`.
    Within the `string-array` element, add an `item` for each book title that references
    the string resource for each title. We want to be sure that we list the book title
    array entries in the same order as the `bookDescription` array entries because
    we use the array index as the ID value for each book when we notify the activity
    of the user''s book selection. The array resource entries for the book title and
    description arrays appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the titles stored as an array resource, we can now easily create a `ListFragment`
    derived class to display the book titles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ListFragment derived class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step is to add a new class to our project. To do this, we''ll create
    a new class named `BookListFragment2` that extends the `ListFragment` class as
    shown in the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we override the `onActivityCreated` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `onActivityCreated` method, we first call the base class implementation
    that is required by all classes that extend `ListFragment`. We then load the `bookTitles`
    array resource and associate it with an instance of the `ArrayAdapter` class named
    `bookTitlesAdapter`. The array adapter takes the context as the first parameter,
    which we get by accessing the activity, and takes the array as the third parameter.
    The second parameter is the ID of the resource to use to lay out each entry in
    the list. This resource can be a custom resource or one of the built-in Android
    resources. In our case, we're using the built-in Android layout resource `android.R.layout.simple_list_item_1`,
    which displays a single string value for each row within the `ListView`. The last
    step is to call the `setListAdapter` method and pass the `bookTitlesAdapter` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a custom layout resource for the `ListFragment` class is just like
    doing so for the `ListView` class, and is discussed in detail in the Android developer
    documentation: [http://developer.android.com/reference/android/app/ListFragment.html.](http://developer.android.com/reference/android/app/ListFragment.html.)'
  prefs: []
  type: TYPE_NORMAL
- en: Handling ListFragment item selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our application to work correctly, we need to inform the activity each time
    the user selects one of the titles. Because we use an interface to loosely couple
    our fragment with the activity, this turns out to be a pretty simple task.
  prefs: []
  type: TYPE_NORMAL
- en: We first override the `ListFragment` class' `onListItemClick` method. The `ListFragment`
    class calls the `onListItemClick` method when the user selects an entry within
    the `ListFragment` instance. The `onListItemClick` method receives several selection-related
    parameters including the zero-based position of the selection. Our `ListFragment`
    is loaded from an array, so this position value corresponds to the selected title's
    array index.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `position` parameter value corresponding directly to the array index,
    all we have to do to inform the activity of the user selection is get a reference
    to the activity, cast it to our `OnSelectionChangeListener` interface, and call
    the interface''s `onSelectedBookChanged` method, passing the `position` parameter
    value as shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All the activity classes in our application that will use our `BookListFragment2`
    class already implement the `OnSelectionChangeListener` interface, so there is
    no change required to the activity classes.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the layout resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We now update the `activity_main.xml` resource file to use the `BookListFragment2`
    class instead of the original `BookListFragment` class as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need to make the same change in the `activity_main_wide.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our program is now fully functional using the `ListFragment` class and appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the layout resources](img/3095_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any changes that we need to make to the titles can now all be made in the resources
    file and require no changes to the user interface code.
  prefs: []
  type: TYPE_NORMAL
- en: DialogFragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now we've been looking at fragments as a new way to divide our application's
    user interface into subsections of the available display area. Although fragments
    are new, the concept of having an aspect of our application user interface as
    a subsection of the available display area is not new. Any time an application
    displays a dialog, the application is doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the challenge of working with dialogs is that even though they
    are conceptually just another window within an application, we must handle many
    of the tasks related to dialogs differently than other aspects of our application
    user interface. Doing something as simple as handling a button click requires
    a dialog-specific interface, `DialogInterface.OnClickListener`, rather than the
    `View.OnClickListener` interface that we use when handling a `click` event from
    non-dialog related parts of our user interface code. An even more complicated
    issue is that of orientation changes. Dialogs automatically close in response
    to an orientation change and therefore can create inconsistent application behavior
    if a user changes device orientation while a dialog is visible.
  prefs: []
  type: TYPE_NORMAL
- en: The `DialogFragment` class eliminates much of the special handling related to
    dialogs. With the `DialogFragment` class, displaying and managing a dialog becomes
    much more consistent with other aspects of our application user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an application displays an instance of the `DialogFragment` class, the
    window for the `DialogFragment` instance has up to three parts to it: layout area,
    title, and frame. A `DialogFragment` instance always contains the layout area,
    but we can control whether it includes the title and frame by setting the `DialogFragment`
    class'' style using the `setStyle` method. The `DialogFragment` class supports
    four styles with an instance of the `DialogFragment` class having exactly one
    style applied. The following table shows the four available styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Style | Has Title | Has Frame | Accepts Input |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `STYLE_NORMAL` | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `STYLE_NO_TITLE` | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `STYLE_NO_FRAME` | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `STYLE_NO_INPUT` | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: Notice that the styles remove features cumulatively. For example, `STYLE_NO_TITLE`
    indicates no title whereas `STYLE_NO_FRAME` indicates no frame and no title. If
    we do not call the `setStyle` method, Android creates the `DialogFragment` instance
    with the style set to `STYLE_NORMAL`.
  prefs: []
  type: TYPE_NORMAL
- en: The style affects the remainder of the behavior of the `DialogFragment` class
    and therefore must be set in the `onCreate` callback method. An attempt to set
    the `DialogFragment` class' style any later in the lifecycle is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to provide the dialog with a special theme, the theme''s resource
    ID can also be passed to the `setStyle` method. To allow Android to select an
    appropriate theme based on the style, simply pass 0 as the theme resource ID.
    The following code sets the `DialogFragment` instance to have no title and use
    the Android-selected theme for that style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Populating the layout of an instance of the `DialogFragment` class is just like
    that of a standard fragment derived class. We simply override the `onCreateView`
    method and inflate the layout resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a layout resource for use with a `DialogFragment` derived class works
    exactly as creating a layout resource for any other fragment derived class. To
    have our `DialogFragment` instance display a line of text and two buttons, we
    define the `fragment_my_dialog.xml` layout resource as shown in the following
    XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: DialogFragment display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Displaying our `DialogFragment` derived class is largely just a matter of creating
    the class instance and calling the `show` method. We need to keep in mind though
    that although our `DialogFragment` instance appears as a standard dialog when
    it displays, it is actually a fragment. Like all fragments, it is managed by the
    containing activity''s `FragmentManager` instance. As a result, we need to pass
    a reference to the activity''s `FragmentManager` instance as part of the call
    to the `DialogFragment` class `show` method as we do in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With our `DialogFragment` derived class'' style set to `STYLE_NO_TITLE` and
    using the `fragment_my_dialog.xml` layout resource file shown earlier, the previous
    code displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DialogFragment display](img/3095_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Event handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key values of the `DialogFragment` class is that it provides greater
    consistency in our code than is available when using the traditional `Dialog`
    class. Most aspects of working with the `DialogFragment` class are the same as
    when working with other fragments. No longer does displaying a dialog have to
    be handled so much differently than other aspects of our application user interface.
    For example, no special handling is required to deal with orientation changes.
    Another place where this greater consistency is evident is in event handling,
    because our button click event handling can use the standard view class event
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the button clicks, our `DialogFragment` derived class simply implements
    the `View.OnClickListener` interface. The following code shows setting the yes
    and no button click events to call back to our `DialogFragment` derived class
    in our class'' `onCreateView` callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're setting up the button click handling just as we would if we
    were working within any other fragment or even directly within the activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also handle notifying the activity of the user''s interaction with the
    `DialogFragment` derived class consistently with the way we do with other fragments.
    Just as we did in the previous chapter, our `DialogFragment` derived class simply
    provides an interface for notifying the activity which of the available buttons
    the user selects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As long as the activity implements the interface, our `DialogFragment` derived
    class can notify the activity of which button the user clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the handler for our button click events, we''ll follow the same pattern
    we did in the previous chapter. We access the containing activity, cast it to
    the expected interface, and call the interface method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is one bit of special handling in the previous method. Just
    as with the traditional `Dialog` class, we must call the `dismiss` method on the
    `DialogFragment` derived class when we no longer wish to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we treat our `DialogFragment` derived class as just another fragment,
    it still has a part of its identity that is tied to the traditional `Dialog` class.
    In fact, Android actually wraps our `DialogFragment` derived class within a traditional
    `Dialog` instance. This occurs in a callback method, specific to the `DialogFragment`
    class, named `onCreateDialog` that Android calls just prior to calling the `onCreateView`
    callback method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dialog` instance that the `onCreateDialog` method returns is the window
    that is ultimately displayed to the user. The layout we create within our `DialogFragment`
    derived class is simply wrapped within the `Dialog` window. We can access that
    `Dialog` instance later in the lifecycle to access `Dialog` related behavior or
    even override the method to provide our own `Dialog` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Dialog related behavior
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Accessing the `Dialog` related behavior of our `DialogFragment` derived class
    requires a reference to the `Dialog` instance created in the `onCreateDialog`
    method. We retrieve that reference by calling the `getDialog` method. Once we
    have the reference to the `Dialog` instance, we can access aspects of the class'
    dialog identity that are not otherwise available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a `DialogFragment` derived class with the style set to `STYLE_NORMAL`,
    the displayed dialog includes a title area above the layout area. The value of
    the title can only be set by calling the `setTitle` method on the `Dialog` instance
    that wraps our `DialogFragment` instance. A similar issue comes up in dealing
    with the dialog cancellation behavior. By default, the user can cancel a dialog
    by tapping on the activity behind the dialog. In many cases, this may be unacceptable
    as we want to require the user to acknowledge one of the choices within the dialog.
    The following code sets these `Dialog` related behaviors after the button click
    handling is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code first sets the dialog title and then sets the option to prevent the
    user from closing the dialog by tapping on the activity window. For the call to
    the `setTitle` method to work, we will need to change the call to the `setStyle`
    method in the `onCreate` callback method to set the style to `STYLE_NORMAL` so
    that the dialog will have a title area.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping an existing dialog in a fragment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There may be times where we like the programming consistency that the `DialogFragment`
    class offers, but want to take advantage of the features provided by a class that
    derives from the traditional `Dialog` class. By overriding the `DialogFragment`
    class' `onCreateDialog` method, we can do exactly that. Overriding the `onCreateDialog`
    method allows us to replace the `DialogFragment` class' default `Dialog` instance
    with one we create. A great example of when this is useful is in leveraging the
    Android `AlertDialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AlertDialog` class provides a variety of default behaviors and allows
    us to display text, an icon, and buttons all without having to create a layout
    resource. There is something we must keep in mind when we''re leveraging a class
    that inherits from the traditional `Dialog` class. Although outside interaction
    with our class will be consistent with other `DialogFragment` derived classes,
    any interactions with the traditional `Dialog` class that occur within our `DialogFragment`
    derived class will be done in the traditional `Dialog` class way. For example,
    to create a `DialogFragment` derived class that utilizes the `AlertDialog` class
    requires that our class implements the `Dialog` class way of handling click events
    that is to implement the `DialogInterface.OnClickListener` interface as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our class'' `onCreateDialog` method, we create the `AlertDialog` instance
    using the `AlertDialog.Builder` class just as if we were going to display the
    `AlertDialog` instance directly. Within the `onCreateDialog` method we set all
    the options on the `AlertDialog.Builder` instance, including the title, message,
    icon, and buttons. Notice, though, that we never call the `AlertDialog.Builder`
    class'' `show` method, but instead call its `create` method. We then take the
    reference to the newly created `AlertDialog` instance and return it from the `onCreateDialog`
    method. All of these steps are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Dialog` instance we create is now managed as a part of the `DialogFragment`
    instance. Everything else we do with our `AlertDialogFragment` class will be just
    as it is with the other `DialogFragment` derived classes we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'When our app shows our `AlertDialogFragment` class, it appears as the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping an existing dialog in a fragment](img/3095_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we didn't need to override the `onCreateView` callback method, because
    the `Dialog` instance we create in the `onCreateDialog` callback method provides
    the desired display characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the `DialogFragment` class' `onCreateDialog` callback method is a
    powerful technique that allows us to enjoy the benefits of the `DialogFragment`
    class while still leveraging existing investment we may have in traditional `Dialog`
    classes, whether they be a built-in class such as the `AlertDialog` class or some
    custom `Dialog` class we may have as part of our own code library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the fragment lifecycle empowers us to leverage the phases of creation
    and destruction of fragments to more efficiently manage fragments and the data
    associated with them. By working with this natural lifecycle, we can take advantage
    of the specialized fragment classes to create a rich user experience, while following
    a more consistent programming model than was previously available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we build on our understanding of the fragment lifecycle
    to take more direct control of fragments to dynamically add and remove them within
    individual activities.
  prefs: []
  type: TYPE_NORMAL
