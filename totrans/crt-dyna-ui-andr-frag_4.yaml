- en: Chapter 4. Working with Fragment Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 使用片段事务
- en: This chapter covers dynamically managing fragments within an activity, implementing
    back button behavior, and monitoring user interaction with the back button.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何在活动中动态管理片段，实现返回按钮的行为，以及监控用户与返回按钮的交互。
- en: 'Let''s have a look at the topics covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涵盖的主题：
- en: Understanding `FragmentTransactions`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`FragmentTransactions`
- en: Dynamically adding and removing fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态添加和移除片段
- en: Managing fragment UI separate from activity relationship
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理与活动关系独立的片段UI
- en: Adding back button support to `FragmentTransactions`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`FragmentTransactions`添加返回按钮支持
- en: By the end of this chapter, we will be able to create interactive UIs that use
    fragments to dynamically change the appearance of the screen in response to user
    actions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将能够创建使用片段来动态响应用户操作改变屏幕外观的交互式UI。
- en: Intentional screen management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意进行屏幕管理
- en: Until now, we've considered each activity to always correspond to a single screen
    in our application. We've used fragments only to represent subsections within
    each screen. As an example, let's think back to the way we've constructed our
    book-browsing application. In the case of a wide-display device, our application
    uses a single activity containing two fragments. One fragment displays the list
    of book titles, and the other fragment displays the description of the currently
    selected book. Because both of these fragments appear on the screen at the same
    time, we display and manage them from a single activity. In the case of a portrait-oriented
    handset, we chose to display the book list and the book description on separate
    screens. Because the two fragments do not appear on the screen at the same time,
    we manage them in separate activities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们认为每个活动总是对应于我们应用程序中的一个单独屏幕。我们只使用片段来表示每个屏幕内的子部分。例如，回想一下我们构建书籍浏览应用程序的方式。在宽屏设备的情况下，我们的应用程序使用一个包含两个片段的单个活动。一个片段显示书籍标题列表，另一个片段显示当前选定书籍的描述。因为这两个片段同时出现在屏幕上，所以我们从单个活动中显示和管理它们。在竖屏手机的情况下，我们选择在单独的屏幕上显示书籍列表和书籍描述。因为这两个片段不会同时出现在屏幕上，所以我们分别在单独的活动中进行管理。
- en: An interesting thing is that the tasks our application performs are identical
    in both cases. The only difference is how much information we're able to display
    on the screen at one time. That one detail causes us to add an extra activity
    to our application. We also increase the complexity of our application because
    the code to launch a new activity is more involved than the code we use to simply
    update a fragment within the same activity. And we have duplicated code in the
    activities because they both interact with the book description fragment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们的应用程序在两种情况下执行的任务是相同的。唯一的区别是我们能够在屏幕上一次显示多少信息。这个细节让我们不得不在应用程序中添加一个额外的活动。我们还增加了应用程序的复杂性，因为启动新活动的代码比我们在同一活动中简单更新片段的代码要复杂得多。而且，我们的活动中有重复的代码，因为它们都与书籍描述片段交互。
- en: As you'll recall, when we started talking about fragments in [Chapter 1](ch01.html
    "Chapter 1. Fragments and UI Modularization"), *Fragments and UI Modularization*,
    we mentioned that one of the key values of fragments is that they help reduce
    unnecessary complications, activity proliferation, and logic duplication. Yet
    as the application is currently written, we're experiencing all of those things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所忆，当我们开始在[第一章](ch01.html "第一章. 片段和UI模块化")，*片段和UI模块化*中讨论片段时，我们提到片段的一个关键价值是它们有助于减少不必要的复杂性、活动的扩散和逻辑的重复。然而，按照目前编写的应用程序来看，我们正在经历所有这些问题。
- en: We need to evolve our thinking about UI design a little further. Rather than
    having activities within our application that simply react to what information
    happens to fit on the device's physical display, we instead need to focus on intentionally
    managing the relationship between the screens in our application and the corresponding
    activities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进一步发展关于UI设计的思路。我们的应用程序中的活动不应只是对恰好适合设备物理显示的信息做出反应，而应该专注于有意管理应用程序中的屏幕与相应活动之间的关系。
- en: To the user, the experience of moving to a new screen simply means that the
    view layout they are looking at is replaced with a different view layout. Historically,
    we've tended to design our applications so that each activity has a relatively
    fixed layout. As a result, moving the user to a new screen has required displaying
    a new activity, but fragments give us another option.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户来说，进入新屏幕的体验仅仅意味着他们正在查看的视图布局被另一个不同的视图布局所替换。从历史上看，我们倾向于设计我们的应用程序，使得每个活动都有相对固定的布局。因此，将用户移动到新屏幕需要显示一个新活动，但片段为我们提供了另一种选择。
- en: Rather than simply using fragments to manage logical subsections of the screen,
    we can also use them to manage logical groupings of an entire screen. We can then
    dynamically manage the fragments within an activity to change from one fragment
    to another. This gives the user the experience of moving from one screen to the
    next while giving us the convenience of managing common user interface elements
    within a single activity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用片段来管理屏幕的逻辑子部分，我们还可以使用它们来管理整个屏幕的逻辑分组。然后我们可以动态管理活动内的片段，以从一个片段更改为另一个片段。这给用户带来了从一个屏幕移动到下一个屏幕的体验，同时也为我们提供了在单个活动中管理通用用户界面元素的便利。
- en: Dynamically managing fragments
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态管理片段
- en: The process of dynamically managing fragments commonly involves multiple steps.
    The steps may be simple like removing one fragment and adding another, or they
    may be more complex, involving the removal and addition of multiple fragments.
    In any case, we need to be certain that all dynamic changes to the fragments within
    an activity that constitute a shift from one application screen to the next occur
    together as a single unit of work. Android does this by grouping the steps into
    transactions using the `FragmentTransaction` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 动态管理片段的过程通常涉及多个步骤。这些步骤可能很简单，比如移除一个片段并添加另一个，或者可能更复杂，涉及移除和添加多个片段。在任何情况下，我们需要确保在活动中对片段的所有动态更改，这些更改构成了从应用程序的一个屏幕切换到下一个屏幕，作为一个工作单元一起发生。Android
    通过使用`FragmentTransaction`类将步骤分组到事务中来实现这一点。
- en: 'Conceptually, the `FragmentTransaction` class behaves in a manner consistent
    with other transaction models: start the transaction, identify the desired changes,
    and commit the transaction once all changes within that unit of work are identified.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，`FragmentTransaction`类与其他事务模型的行为一致：开始事务，确定所需的更改，并在识别出该工作单元内的所有更改后提交事务。
- en: When we're ready to make changes, we start a new `FragmentTransaction` instance
    by calling the `beginTransaction` method on the activity's `FragmentManager` instance,
    which returns back a reference to a `FragmentTransaction` instance. We then use
    the new `FragmentTransaction` instance to identify the desired changes to the
    list of displayed fragments within the activity. While we're in the transaction,
    these changes are queued up but not yet applied. Finally, when we've identified
    all the desired changes, we call the `FragmentTransaction` class' `commit` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备进行更改时，通过在活动的`FragmentManager`实例上调用`beginTransaction`方法来启动新的`FragmentTransaction`实例，该方法返回对`FragmentTransaction`实例的引用。然后我们使用新的`FragmentTransaction`实例来确定活动内显示的片段列表所需的更改。在我们处于事务中时，这些更改会被排队但尚未应用。最后，当我们确定了所有所需的更改后，我们调用`FragmentTransaction`类的`commit`方法。
- en: Once all the changes in the transaction are applied, our application display
    is updated to reflect those changes, giving the user the feel of moving to a new
    screen of our application. Although a number of steps have occurred within our
    application, from the user's perspective everything behaves just as if we had
    displayed a new activity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事务中的所有更改被应用，我们的应用程序显示就会更新以反映这些更改，给用户一种进入应用程序新屏幕的感觉。尽管在我们的应用程序中发生了许多步骤，但从用户的角度来看，一切就像我们显示了一个新的活动一样。
- en: Deferred execution of transaction changes
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟执行事务变更
- en: The call to the `commit` method does not apply the changes immediately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`commit`方法并不会立即应用更改。
- en: When we work with the `FragmentTransaction` class, we are not doing any direct
    work on the application user interface. Instead, we're building a To-Do list of
    work to be done to the user interface in the future. Each method that we call
    on a `FragmentTransaction` instance adds another To-Do item to the list. When
    we're done adding to the To-Do list and we call the `commit` method, those instructions
    get packaged up and sent to the main UI thread's message queue. The UI thread
    then walks through the list, performing the actual user interface work on behalf
    of the `FragmentTransaction` instance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`FragmentTransaction`类时，我们并不是直接在应用程序用户界面上操作。相反，我们正在构建一个待办事项列表，以在将来对用户界面进行操作。我们在`FragmentTransaction`实例上调用的每个方法都会向列表中添加另一个待办事项。当我们完成待办事项的添加并调用`commit`方法时，这些指令会被打包并发送到主UI线程的消息队列中。UI线程然后遍历这个列表，代表`FragmentTransaction`实例执行实际的用户界面工作。
- en: The deferred execution of the work performed within a `FragmentTransaction`
    instance works well in most cases. It can, however, create problems if our application
    code needs to find a fragment or interact with a view that is added by a fragment
    immediately following the call to the `commit` method. Although such a requirement
    is not normally the case, it does sometimes come up.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`FragmentTransaction`实例内的工作延迟执行是有效的。然而，如果我们的应用程序代码需要立即在调用`commit`方法后找到一个片段或与由片段添加的视图进行交互，它可能会造成问题。尽管这样的需求通常不是必须的，但有时确实会出现。
- en: If we do have such a requirement, we can force the `FragmentTransaction` instance's
    work to be executed immediately by calling the `FragmentManager` class' `executePendingTransactions`
    method after the call to the `FragmentTransaction` instance's `commit` method.
    When a call to the `executePendingTransactions` method returns, we know that all
    the committed `FragmentTransaction` work has been performed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这样的需求，可以在调用`FragmentTransaction`实例的`commit`方法之后，通过调用`FragmentManager`类的`executePendingTransactions`方法，立即执行`FragmentTransaction`实例的工作。当调用`executePendingTransactions`方法返回时，我们知道所有提交的`FragmentTransaction`工作都已完成。
- en: We need to be careful by only calling the `executePendingTransactions` method
    on the main UI thread; this method causes the pending user interface work to execute,
    and therefore triggers direct interaction with the user interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心，只在主UI线程上调用`executePendingTransactions`方法；这个方法会导致挂起的前端工作被执行，从而触发与用户界面的直接交互。
- en: Adding and removing fragments
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和移除片段
- en: There are a number of methods available on the `FragmentTransaction` class to
    manipulate the fragments within an activity, but the most fundamental are the
    `add` and `remove` methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentTransaction`类上有许多方法可用于操作活动内的片段，但最基本的是`add`和`remove`方法。'
- en: 'The `add` method allows us to place a newly created fragment instance within
    a specific view group of our activity as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法允许我们将新创建的片段实例放置在活动的特定视图组中，如下所示：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first create a new `FragmentTransaction` instance using the activity's `FragmentManager`
    instance. We then create a new instance of our `BookListFragment2` class and attach
    it to the activity as a child of the `LinearLayout` view group identified by the
    `R.id.layoutRoot` ID value. Finally, we commit the `FragmentTransaction` instance
    indicating that we're done making changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用活动的`FragmentManager`实例创建一个新的`FragmentTransaction`实例。然后创建`BookListFragment2`类的新实例，并将其作为`LinearLayout`视图组的子项附加到活动中，该视图组由`R.id.layoutRoot`
    ID值标识。最后，我们提交`FragmentTransaction`实例，表示我们已经完成更改。
- en: The string value, `"bookList"`, that we pass as the third parameter to the `add`
    method is simply a tag value. We can use the tag value to later locate the fragment
    instance in much the same way as we might use the id value. When adding fragments
    dynamically, we use tags as identifiers rather than id values simply because there
    is no way to associate an id value with a dynamically added fragment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`add`方法的第三个参数，字符串值`"bookList"`，仅仅是一个标签值。我们可以使用这个标签值，在之后定位片段实例，这与我们使用id值的方式类似。当动态添加片段时，我们使用标签作为标识符，而不是id值，因为无法将id值与动态添加的片段相关联。
- en: 'The tag value comes in handy when we''re ready to display a different fragment
    because we need to have a reference to the existing fragment to pass to the `remove`
    method so that we can remove it before adding a new fragment. The following code
    shows how we can update the display to show the `BookDescFragment` class in place
    of the `BookListFragment2` class we added in the previous code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备显示不同的片段时，标签值就派上用场了，因为我们需要有对现有片段的引用，以便传递给`remove`方法，这样我们可以在添加新片段之前移除它。以下代码展示了我们如何更新显示，用`BookDescFragment`类替换之前代码中添加的`BookListFragment2`类：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We begin by using the tag value to find our existing `BookListFragment2` instance
    using the `FragmentManager` class' `findFragmentByTag` method. We then create
    an instance of the new fragment we wish to add. Now that we have references to
    the fragment we want to remove and the one we want to add, we begin fragment transaction.
    Within the transaction, we remove the `BookListFragment2` instance by passing
    the reference to the `FragmentTransaction` class' `remove` method and then add
    the new fragment using the `add` method just as we did earlier. Finally, we call
    the `commit` method to allow the changes to be made.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用标签值通过`FragmentManager`类的`findFragmentByTag`方法找到现有的`BookListFragment2`实例。然后我们创建我们想要添加的新片段的实例。现在我们有了要移除的片段和要添加的片段的引用，我们开始片段事务。在事务中，我们通过将引用传递给`FragmentTransaction`类的`remove`方法来移除`BookListFragment2`实例，然后使用`add`方法添加新片段，就像我们之前所做的那样。最后，我们调用`commit`方法以允许进行更改。
- en: 'This process of removing the fragment instance under a particular view group
    and adding another in its place occurs frequently enough that the `FragmentTransaction`
    class includes a convenient method named `replace`. The `replace` method allows
    us to simply identify the information for the fragment we wish to add. It takes
    care of the details of removing any other fragments that may exist within the
    target view group. Using the `replace` method, the code to remove the `BookListFragment2`
    instance and add the `BookDescFragment` instance can be written as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在特定视图组下移除片段实例并添加另一个来替代的过程经常发生，以至于`FragmentTransaction`类包含了一个名为`replace`的便捷方法。`replace`方法允许我们简单地标识我们想要添加的片段的信息。它处理了移除目标视图组中可能存在的任何其他片段的细节。使用`replace`方法，移除`BookListFragment2`实例并添加`BookDescFragment`实例的代码可以如下编写：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that this code, with the exception of the method name, is identical to
    the case of simply adding a fragment. We create our fragment instance, and then
    within the `FragmentTransaction` call, the `replace` method passes the id of the
    target view group, fragment instance, and tag. The `replace` method handles the
    details of removing any fragment that may currently be within the `R.id.layoutRoot`
    view group. It then adds the `BookDescFragment` instance to the view group.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码除了方法名之外，与简单添加一个片段的情况完全相同。我们创建自己的片段实例，然后在`FragmentTransaction`调用中，`replace`方法传递目标视图组的id、片段实例和标签。`replace`方法处理了移除当前可能在`R.id.layoutRoot`视图组中的任何片段的细节。然后它将`BookDescFragment`实例添加到视图组中。
- en: Supporting the back button
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持后退按钮
- en: As we move to this model of managing our application screens as fragments, we
    need to be sure that we're providing the user with an experience consistent with
    their expectations. An area that requires special attention is our application's
    handling of the back button.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向这种将应用屏幕作为片段来管理的模型时，我们需要确保我们为用户提供的是符合他们预期的体验。需要特别关注的一个区域是应用对后退按钮的处理。
- en: When a user interacts with the applications on their device, they naturally
    move forward through various application screens. The normal behavior is that
    a user can move back to a previous screen at any time by tapping the back button.
    This works because each time an application displays a new activity, Android automatically
    adds that activity to the Android back stack. This results in the expected behavior
    of the user moving to the previous activity with each tap of the back button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与设备上的应用进行交互时，他们会自然地通过不同的应用屏幕向前移动。正常的行为是用户可以通过点击后退按钮随时返回到上一个屏幕。这之所以有效，是因为每次应用显示新的活动时，Android都会自动将这个活动添加到Android后退栈中。这就导致了用户每次点击后退按钮都会返回到上一个活动的预期行为。
- en: This behavior is based on the assumption that one activity equals one application
    screen; an assumption that is no longer correct. When we transition the user from
    one application screen to another using the `FragmentTransaction` class, the application
    continues to display the same activity, leaving the back stack with no awareness
    of our application's new screen. This results in the application appearing to
    jump back multiple screens in response to the user tapping the back button because
    the back stack returns the user directly to the previous activity ignoring any
    intermediate changes made to the current activity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为基于一个假设：一个活动等于一个应用程序屏幕；这个假设已不再正确。当我们使用 `FragmentTransaction` 类将用户从一应用程序屏幕过渡到另一屏幕时，应用程序继续显示同一活动，而后退栈对我们的应用程序新屏幕一无所知。这导致应用程序在用户点击后退按钮时似乎会跳过多个屏幕，因为后退栈直接将用户返回到上一个活动，忽略了当前活动所做的任何中间更改。
- en: 'The following figure demonstrates the issue:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下图演示了这个问题：
- en: '![Supporting the back button](img/3095OS_04_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![支持后退按钮](img/3095OS_04_01.jpg)'
- en: An application initially calls the `startActivity` method to display an instance
    of `Activity1`. `Activity1` is automatically added to the back stack and is currently
    at the top of the stack.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序最初调用 `startActivity` 方法以显示 `Activity1` 的实例。`Activity1` 会被自动添加到后退栈，并且当前位于栈顶。
- en: '`Activity1` then calls the `startActivity` method to display `Activity2,` which
    uses the `FragmentTransaction.add` method to add `FragmentA`. `Activity2` is automatically
    added to the top of the back stack.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Activity1` 通过调用 `startActivity` 方法来展示 `Activity2`，后者使用 `FragmentTransaction.add`
    方法添加 `FragmentA`。`Activity2` 会被自动添加到后退栈的顶部。'
- en: Next, `Activity2` uses the `FragmentTransaction.replace` method to display `FragmentB`
    in place of `FragmentA`. As far as the user is concerned, the application is displaying
    a new screen showing the contents of `FragmentB`. The problem is that the back
    stack is unchanged.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`Activity2` 使用 `FragmentTransaction.replace` 方法将 `FragmentB` 替换 `FragmentA`
    进行展示。对用户来说，应用程序正在显示一个新屏幕，显示 `FragmentB` 的内容。问题是后退栈保持不变。
- en: When the user now taps the back button, his/her expectation is that the app
    should display the previous screen, `FragmentA`, but instead when Android pops
    the back stack, the next screen it encounters is `Activity1`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户现在点击后退按钮时，他的预期是应用程序应该显示上一个屏幕 `FragmentA`，但相反，当 Android 弹出后退栈时，它遇到的下一个屏幕是
    `Activity1`。
- en: We resolve this issue by calling the `FragmentTransaction` class' `addToBackStack`
    method within the `FragmentTransaction` instance that displays `FragmentB`. The
    `addToBackStack` method adds the changes within the transaction to the top of
    the back stack. This allows the user to use the back button to move through the
    application screens created within the `FragmentTransaction` instance just as
    one does with screens created by showing an activity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在显示 `FragmentB` 的 `FragmentTransaction` 实例中调用 `FragmentTransaction` 类的 `addToBackStack`
    方法来解决此问题。`addToBackStack` 方法会将事务内的更改添加到后退栈的顶部。这使得用户可以使用后退按钮通过 `FragmentTransaction`
    实例创建的应用程序屏幕，就像使用活动显示的屏幕一样。
- en: We can call the `addToBackStack` method at any point during the transaction
    prior to calling the `commit` method. The `addToBackStack` method optionally accepts
    a string parameter that can be used to name the location in the back stack. This
    is useful if you wish to programmatically manipulate the back stack later, but
    in most cases this parameter value can be passed as null. We'll see the `addToBackStack`
    method in action shortly as we modify our application to use a more adaptive layout.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调用 `commit` 方法之前的事务过程中的任何时间点调用 `addToBackStack` 方法。`addToBackStack` 方法可选地接受一个字符串参数，可用于命名后退栈中的位置。如果你希望稍后以编程方式操作后退栈，这很有用，但在大多数情况下，此参数值可以传递为
    null。我们很快就会看到 `addToBackStack` 方法的实际应用，因为我们将修改我们的应用程序以使用更自适应的布局。
- en: Creating an adaptive application layout
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自适应应用程序布局
- en: 'Let''s put our discussion of dynamic fragment management into practice by updating
    our application to work with just a single activity. This one activity will handle
    both scenarios: wide-display devices where both fragments appear side-by-side
    and portrait-oriented handsets where the fragments appear as two separate screens.
    As a reminder, the application appears as shown in the following screenshot in
    each scenario:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新应用程序使其只使用一个活动来实践动态片段管理讨论。这个单一活动将处理两种场景：宽屏设备上两个片段并排显示，以及竖屏手机上片段显示为两个独立屏幕。提醒一下，在每种场景中，应用程序的外观如下面的屏幕截图所示：
- en: '![Creating an adaptive application layout](img/3095_04_02_NEW.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建自适应应用布局](img/3095_04_02_NEW.jpg)'
- en: In our application, we'll leave the wide-display aspect of the program alone
    because static layout management is working fine there. Our work is on the portrait-oriented
    handset aspect of the application. For these devices, we'll update the application's
    main activity to dynamically switch between displaying the fragment containing
    the list of books and the fragment displaying the selected book description.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将保留宽屏方面的程序不变，因为静态布局管理在那里工作得很好。我们的工作是在应用程序的竖屏手机方面。对于这些设备，我们将更新应用程序的主活动，以动态切换显示包含书籍列表的片段和显示选定书籍描述的片段。
- en: Updating the layout to support dynamic fragments
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新布局以支持动态片段
- en: 'Before we write any code to dynamically manage the fragments within our application,
    we first need to modify the activity layout resource for portrait-oriented handset
    devices. That resource is contained in the `activity_main.xml` layout resource
    file and currently appears as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码来动态管理应用程序中的片段之前，我们首先需要修改针对竖屏手机设备的活动布局资源。该资源包含在`activity_main.xml`布局资源文件中，目前如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to make two changes to the layout resource. The first is to add an
    id attribute to the `LinearLayout` view group so that we can easily locate it
    in code. The other change is to completely remove the `fragment` element. The
    updated layout resource now contains only the `LinearLayout` view group, which
    includes an id attribute value of `@+id/layoutRoot`. The layout resource now appears
    as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对布局资源进行两项更改。第一项是向`LinearLayout`视图组添加一个id属性，这样我们可以在代码中轻松找到它。另一个更改是完全移除`fragment`元素。更新后的布局资源现在只包含带有id属性值`@+id/layoutRoot`的`LinearLayout`视图组。布局资源现在如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We still want our application to initially display the book list fragment, so
    removing the `fragment` element may seem like a strange change, but doing so is
    essential as we move our application to dynamically manage the fragments. We will
    eventually need to remove the book list fragment to replace it with the book description
    fragment. If we were to leave the book list fragment in the layout resource, our
    attempt to dynamically remove it later would silently fail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望应用程序最初显示书籍列表片段，因此移除`fragment`元素可能看起来很奇怪，但这样做对于我们动态管理片段是必要的。最终，我们需要移除书籍列表片段以替换为书籍描述片段。如果我们留下书籍列表片段在布局资源中，我们之后尝试动态移除它会默默失败。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only dynamically added fragments can be dynamically removed. Attempting to dynamically
    remove a fragment that was statically added with the `fragment` element in a layout
    resource will silently fail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只有动态添加的片段才能被动态移除。尝试动态移除使用布局资源中的`fragment`元素静态添加的片段将会默默失败。
- en: Adapting to device differences
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应设备差异
- en: When our application is running on a portrait-oriented handset device, the activity
    needs to programmatically load the fragment containing the book list. This is
    the same `Fragment` class, `BookListFragment2`, we were previously loading with
    the `fragment` element in the `activity_main.xml` layout resource file. Before
    we load the book list fragment, we first need to determine whether we're running
    on a device that requires dynamic fragment management. Remember that for the wide-display
    devices, we're going to leave the static fragment management in place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序在竖屏手机设备上运行时，活动需要以编程方式加载包含书籍列表的片段。这是我们之前使用`activity_main.xml`布局资源文件中的`fragment`元素加载的同一`Fragment`类，`BookListFragment2`。在我们加载书籍列表片段之前，我们首先需要确定是否正在运行需要动态片段管理的设备上。记住，对于宽屏设备，我们将保留静态片段管理。
- en: There'll be a couple of places in our code where we'll need to take different
    logic paths depending on which layout we're using, so we'll need to add a `boolean`
    class-level field to the activity where we can store whether we're using dynamic
    or static fragment management.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中有几个地方，根据我们使用的布局，我们需要采取不同的逻辑路径，因此我们需要在活动中添加一个`boolean`类级别字段，以便我们可以存储我们是使用动态还是静态片段管理。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We could interrogate the device for its specific characteristics such as screen
    size and orientation. But remember that much of our previous work was to configure
    our application to take advantage of the Android resource system to automatically
    load the appropriate layout resources based on the device characteristics. Rather
    than repeating those characteristics checks in code, we can instead simply include
    the code to determine which layout resource was loaded. The layout resource for
    wide-display devices we created earlier, `activity_main_wide.xml`, statically
    loads both the book list fragment and the book description fragment. We can include
    in our activity''s `onCreate` method code to determine if the loaded layout resource
    includes one of those fragments as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查询设备的特定特性，如屏幕大小和方向。但请记住，我们之前的大部分工作是为了配置我们的应用程序，利用Android资源系统根据设备特性自动加载适当的布局资源。与其在代码中重复这些特性检查，我们反而可以简单地包含确定已加载哪个布局资源的代码。我们之前为宽显示设备创建的布局资源`activity_main_wide.xml`静态加载了书籍列表片段和书籍描述片段。我们可以在活动的`onCreate`方法中包含以下代码，以确定已加载的布局资源是否包含这些片段之一：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the call to the `setContentView` method returns, we know that the appropriate
    layout resource for the current device has been loaded. We then use the `FragmentManager`
    instance to search for the fragment with an id value of `R.id.fragmentDescription`
    that is included in the layout resource for wide-display devices but not the layout
    resource for portrait-oriented handsets. A return value of `null` indicates that
    the fragment was not loaded and we are, therefore, on a device that requires us
    to dynamically manage the fragments. In addition to the test for null, we also
    include the call to the `isInLayout` method to protect against one special case
    scenario.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当`setContentView`方法的调用返回时，我们知道当前设备已加载了适当的布局资源。然后我们使用`FragmentManager`实例查找包含在宽显示设备布局资源中但不在竖屏手机布局资源中的id值为`R.id.fragmentDescription`的片段。返回值为`null`表示片段未被加载，因此我们处于需要动态管理片段的设备上。除了对null的测试，我们还包含了对`isInLayout`方法的调用，以防止一种特殊情况的发生。
- en: In the scenario where the device is in a landscape layout and then rotated to
    portrait, a cached instance to the fragment identified by `R.id.fragmentDescription`
    may still exist even though in the current orientation the activity is not using
    the fragment. By calling the `isInLayout` method, we're able to determine whether
    the returned reference is part of the currently loaded layout. With this, our
    test to set the `mIsDynamic` member variable effectively says that we'll set `mIsDynamic`
    to true when the `R.id.fragmentDescription` fragment is not found (equals `null`)
    or it's found but not part of the currently loaded layout (`!bookDescFragment.isInLayout`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备从横屏布局旋转到竖屏的情况下，即使当前方向的活动没有使用片段，标识为`R.id.fragmentDescription`的片段的缓存实例可能仍然存在。通过调用`isInLayout`方法，我们可以确定返回的引用是否是当前加载布局的一部分。这样，我们设置`mIsDynamic`成员变量的测试有效地表明，当找不到（等于`null`）`R.id.fragmentDescription`片段或找到了但不是当前加载布局的一部分（`!bookDescFragment.isInLayout`）时，我们将`mIsDynamic`设置为true。
- en: Dynamically loading a fragment at startup
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态加载启动时的片段
- en: 'Now that we''re able to determine whether dynamically loading the book list
    fragment is necessary, we add the code to do so to our `onCreate` method as shown
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '既然我们能够确定是否需要动态加载书籍列表片段，我们就可以将相应代码添加到我们的`onCreate`方法中，如下所示： '
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Following the check to determine if we're on a device that requires dynamic
    fragment management, we include `FragmentTransaction` to add an instance of the
    `BookListFragment2` class to the activity as a child of the `LinearLayout` view
    group identified by the id value `R.id.layoutRoot`. This code capitalizes on the
    changes we made to the `activity_main.xml` resource file of removing the `fragment`
    element and including an id value on the `LinearLayout` view group.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查是否处于需要动态管理片段的设备之后，我们包含`FragmentTransaction`，将`BookListFragment2`类的一个实例添加到由id值`R.id.layoutRoot`标识的`LinearLayout`视图组中的活动作为子项。这段代码利用了我们之前对`activity_main.xml`资源文件所做的更改，即移除了`fragment`元素并在`LinearLayout`视图组上包含了id值。
- en: Now that we're dynamically loading the book list, we're ready to get rid of
    that other activity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经动态加载了书籍列表，我们就可以准备删除其他活动了。
- en: Transitioning between fragments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在片段之间进行转换
- en: 'As you''ll recall, whenever the user selects a book title within the `BookListFragment2`
    class, the fragment notifies the main activity by calling the `onSelectedBookChanged`
    method by passing the index of the selected book. The `onSelectedBookChanged`
    method currently appears as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当用户在`BookListFragment2`类中选择书名时，片段通过传递所选书籍的索引来调用`onSelectedBookChanged`方法，通知主活动。当前的`onSelectedBookChanged`方法如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the current implementation, we use a technique similar to what we did in
    the `onCreate` method to determine which layout is loaded; we try to find the
    book description fragment within the currently loaded layout. If we find it, we
    know the current layout includes the fragment and so we go ahead and set the book
    description directly on the fragment. If we don't find it, we call the `startActivity`
    method to display the activity that does contain the book description fragment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，我们使用与在`onCreate`方法中确定加载哪个布局的类似技术；我们尝试在当前已加载的布局中查找书籍描述片段。如果我们找到了，我们就知道当前布局包括该片段，因此可以直接在片段上设置书籍描述。如果我们没有找到，我们就调用`startActivity`方法来显示包含书籍描述片段的活动。
- en: In this scenario, handing off to the other activity isn't too bad because we
    only pass a simple integer value to the other activity. In practice though, the
    need to pass data over to another activity can be complicated. This is especially
    true if there are a large number of values or if some of those values are object
    types that cannot be directly passed in an `Intent` instance without additional
    coding. As we already have all the necessary handling to interact with the fragment
    in the current activity, we'd prefer to handle it consistently in all cases.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，将操作转交给另一个活动并不算太糟糕，因为我们只传递了一个简单的整数值给另一个活动。然而实际上，需要将数据传递给另一个活动的需求可能会变得复杂。特别是如果有一大堆值，或者其中一些值是对象类型，没有额外的编码就不能直接在`Intent`实例中传递。既然我们已经有了在当前活动中与片段交互所需的所有处理，我们更愿意在所有情况下都一致地处理它。
- en: Eliminating redundant handling
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消除冗余处理
- en: 'To get started, we can strip any code in the current implementation that deals
    with starting an activity. We can also avoid repeating the check for the book
    description fragment because we performed that check earlier in the `onCreate`
    method. Instead, we can now check the `mIsDynamic` class-level field to determine
    the proper handling. With that in mind, we can initially modify the `onSelectedBookChanged`
    method to now look like the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们可以删除当前实现中处理启动活动的任何代码。我们还可以避免重复检查书籍描述片段，因为我们在`onCreate`方法中已经执行了该检查。相反，我们现在可以检查`mIsDynamic`类级字段以确定适当的处理。考虑到这一点，我们可以最初修改`onSelectedBookChanged`方法，使其现在看起来如下代码所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now check the `mIsDynamic` member field to determine the appropriate code
    path. We still have some work to do if it turns out to be true, but in the case
    of it being false, we can simply get a reference to the book description fragment
    that we know is contained within the current layout and set the book index on
    it much like we were doing before.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在检查`mIsDynamic`成员字段以确定适当的代码路径。如果它为真，我们还有一些工作要做，但如果为假，我们可以简单地获取对当前布局中包含的书籍描述片段的引用，并在其上设置书籍索引，就像我们之前所做的那样。
- en: Creating the fragment on-the-fly
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态创建片段
- en: 'In the case of the `mIsDynamic` field being true, we can display the book description
    fragment by simply replacing the book list fragment we added in the `onCreate`
    method with the book description fragment using the code shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mIsDynamic`字段为真时，我们可以通过简单地用书籍描述片段替换我们在`onCreate`方法中添加的书籍列表片段来显示书籍描述片段，代码如下所示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Within `FragmentTransaction` we create an instance of the `BookDescFragment`
    class and call the `replace` method passing the id of the same view group that
    contains the `BookListFragment2` instance that we added in the `onCreate` method.
    We include a call to the `addToBackStack` method so that the back button functions
    correctly, allowing the user to tap the back button to return to the book list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FragmentTransaction`中，我们创建了一个`BookDescFragment`类的实例，并调用了`replace`方法，传递了包含我们在`onCreate`方法中添加的`BookListFragment2`实例的同一视图组的id。我们包含了对`addToBackStack`方法的调用，以便后退按钮可以正确工作，允许用户点击后退按钮返回到书籍列表。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code includes a call to the `FragmentTransaction` class' `setCustomAnimations`
    method that creates a fade effect when the user switches from one fragment to
    the other.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含了对`FragmentTransaction`类的`setCustomAnimations`方法的调用，该方法在用户从一个片段切换到另一个片段时创建了一个淡入淡出效果。
- en: Managing asynchronous creation
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理异步创建
- en: 'We have one final challenge, that is, setting the book index on the dynamically
    added book description fragment. Our initial thought might be to simply call the
    `BookDescFragment` class'' `setBook` method after we create the `BookDescFragment`
    instance, but let''s first take a look at the current implementation of the `setBook`
    method that appears as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个最后的挑战，即设置动态添加的书籍描述片段上的书籍索引。我们最初的想法可能是在创建`BookDescFragment`实例后简单地调用`BookDescFragment`类的`setBook`方法，但首先让我们看一下下面出现的当前`setBook`方法的实现：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last line of the method attempts to set the value of `mBookDescriptionTextView`
    within the fragment, which is a problem. Remember that the work we do within a
    `FragmentTransaction` class is not immediately applied to the user interface,
    but is instead performed only after we call the `commit` method. As a result,
    the `BookDescFragment` instance's `onCreate` and `onCreateView` methods have not
    yet been called. Therefore, any views associated with the `BookDescFragment` instance
    have not yet been created. An attempt to call the `setText` method on the `mBookDescriptionTextView`
    instance would result in a null reference exception.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的最后一行试图在片段内设置`mBookDescriptionTextView`的值，这是一个问题。记住，我们在`FragmentTransaction`类中所做的工作并不会立即应用到用户界面，而是要在我们调用`commit`方法之后才会执行。因此，`BookDescFragment`实例的`onCreate`和`onCreateView`方法尚未被调用。所以，与`BookDescFragment`实例关联的任何视图都尚未创建。尝试在`mBookDescriptionTextView`实例上调用`setText`方法将导致空引用异常。
- en: One possible solution would be to modify the `setBook` method to be aware of
    the current state of the fragment. In that scenario, the `setBook` method would
    check whether the `BookDescFragment` instance had been fully created. If not,
    it would store the book index value in the class-level field and later automatically
    set the `mBookDescriptionTextView` value as part of the creation process. Although
    there may be some scenarios that warrant such a complicated solution, fragments
    give us an easier one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将`setBook`方法修改为能够识别片段的当前状态。在这种情况下，`setBook`方法将检查`BookDescFragment`实例是否已完全创建。如果没有，它将在类级别字段中存储书籍索引值，并在创建过程中稍后自动设置`mBookDescriptionTextView`的值。尽管可能有一些情况需要这种复杂的解决方案，但片段为我们提供了更简单的选择。
- en: 'The `Fragment` base class includes a method called `setArguments`. With the
    `setArguments` method, we can attach data values, otherwise known as arguments,
    to the fragment that can then be accessed later in the fragment lifecycle using
    the `getArguments` method. Much like we do when associating extras with an `Intent`
    instance, a good practice is to define constants on the target class to name the
    argument values. It is also a good programming practice to provide a constant
    for an argument default value in the case of non-nullable types such as integers
    as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment`基类中包含一个名为`setArguments`的方法。通过`setArguments`方法，我们可以将数据值（也称为参数）附加到片段上，稍后可以在片段的生命周期中使用`getArguments`方法访问这些值。类似于我们将额外数据与`Intent`实例关联时，一个好的实践是在目标类上定义常量来命名参数值。对于非空类型（如整数）的参数默认值，提供常量也是一个好的编程实践，如下所示：'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll use the `BOOK_INDEX` constant to get and set the book index value and
    the `BOOK_INDEX_NOT_SET` constant to indicate whether the book index argument
    has been set.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`BOOK_INDEX`常量来获取和设置书籍索引值，以及使用`BOOK_INDEX_NOT_SET`常量来指示是否已设置书籍索引参数。
- en: 'We can now update the `BookDescFragment` class'' `onCreateView` method to look
    for arguments that might be attached to the fragment. Before we make any changes
    to the `onCreateView` method, let''s look at the current implementation that follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新`BookDescFragment`类的`onCreateView`方法，以查找可能附加到片段的参数。在我们对`onCreateView`方法进行任何更改之前，先来看看当前的实现方式：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As the `onCreateView` method is currently implemented, it simply inflates the
    layout resource, loads the array containing the book descriptions, and caches
    a reference to the `TextView` instance where the book description is loaded.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onCreateView`方法当前的实现，它只是简单地充气布局资源，加载包含书籍描述的数组，并缓存对加载书籍描述的`TextView`实例的引用。
- en: 'We can now update the method to look for and use a book index that might be
    attached as an argument. The updated method appears as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新该方法，以查找并使用可能作为参数附加的书籍索引。更新后的方法如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Just before we return the fragment's view hierarchy, we call the `getArguments`
    method to retrieve any arguments that might be attached. The arguments are returned
    as an instance of the `Bundle` class. If the `Bundle` instance is non-null, we
    call the `Bundle` class' `getInt` method to retrieve the book index and assign
    it the `bookIndex` local variable. The second parameter to the `getInt` method,
    `BOOK_INDEX_NOT_SET`, is returned if the fragment happens to have arguments attached
    that do not include the book index. Although this should not normally be the case,
    being prepared for any such unexpected circumstance is a good idea. Finally, we
    check the value of the `bookIndex` variable. If it contains a book index, we call
    the fragment's `setBook` method to display it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们返回片段的视图层次结构之前，我们调用`getArguments`方法以检索可能附加的任何参数。参数作为`Bundle`类的一个实例返回。如果`Bundle`实例非空，我们调用`Bundle`类的`getInt`方法来检索书籍索引并将其分配给`bookIndex`局部变量。`getInt`方法的第二个参数`BOOK_INDEX_NOT_SET`将在片段恰好有附加的参数但不包括书籍索引时返回。虽然这通常不应该发生，但为任何此类意外情况做好准备是个好主意。最后，我们检查`bookIndex`变量的值。如果它包含一个书籍索引，我们调用片段的`setBook`方法来显示它。
- en: Putting it all together
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将其全部放在一起
- en: 'With the `BookDescFragment` class now including support for attaching the book
    index as an argument, we''re ready to fully implement the main activity''s `onSelectedBookChanged`
    method to include switching to the `BookDescFragment` instance and attaching the
    book index as an argument. The method now appears as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`BookDescFragment`类现在包括支持将书籍索引作为参数附加，我们现在准备完全实现主活动的`onSelectedBookChanged`方法，以包括切换到`BookDescFragment`实例并将书籍索引作为参数附加。现在的方法如下所示：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just as before, we start with the check to see if we're doing dynamic fragment
    management. Once we determine we are, we start the `FragmentTransaction` instance
    and create the `BookDescFragment` instance. We then create a new `Bundle` instance,
    store the book index into it, and then attach the `Bundle` instance to the `BookDescFragment`
    instance with the `setArguments` method. Finally, we put the `BookDescFragment`
    instance into place as the current fragment, take care of the back stack, enable
    animation, and complete the transaction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们从检查是否进行动态片段管理开始。一旦确定我们在进行，就开始`FragmentTransaction`实例并创建`BookDescFragment`实例。然后我们创建一个新的`Bundle`实例，将书籍索引存储到其中，并使用`setArguments`方法将其附加到`BookDescFragment`实例。最后，我们将`BookDescFragment`实例作为当前片段放置到位，处理回退栈，启用动画，并完成交易。
- en: Everything is now complete. When the user selects a book title from the list,
    the `onSelectedBookChanged` method gets called. The `onSelectedBookChanged` method
    then creates and displays the `BookDescFragment` instance with the appropriate
    book index attached as an argument. When the `BookDescFragment` instance is ultimately
    created, its `onCreateView` method will then retrieve the book index from the
    arguments and display the appropriate description.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切就绪。当用户从列表中选择书名时，将调用`onSelectedBookChanged`方法。`onSelectedBookChanged`方法然后创建并显示带有适当书籍索引作为参数的`BookDescFragment`实例。当最终创建`BookDescFragment`实例时，其`onCreateView`方法将然后从参数中检索书籍索引并显示适当的描述。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Intentional screen management frees us from the burden of tying each application
    screen to an individual activity. Using the `FragmentTransaction` class, we're
    able to dynamically switch between individual fragments within an activity, eliminating
    the need to create a separate activity class for each screen in our application.
    This helps to prevent the proliferation of unnecessary activity classes, better
    organize our applications, and avoid the associated increase in complexity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有意识地管理屏幕，使我们摆脱了将每个应用屏幕绑定到单个活动的负担。使用`FragmentTransaction`类，我们能够在活动内动态地在各个片段之间切换，无需为应用中的每个屏幕创建单独的活动类。这有助于防止不必要活动类的增多，更好地组织我们的应用程序，并避免由此产生的复杂性增加。
- en: We'll see in the next chapter that this ability to dynamically manage multiple
    screens within a single activity opens us up to greater flexibility and an increased
    richness in the appearance and navigation behavior of our Android applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章看到，这种在一个活动中动态管理多个屏幕的能力，为我们的Android应用程序在界面外观和导航行为上提供了更大的灵活性和丰富性。
