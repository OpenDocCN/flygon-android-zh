- en: Chapter 4. Working with Fragment Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers dynamically managing fragments within an activity, implementing
    back button behavior, and monitoring user interaction with the back button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the topics covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `FragmentTransactions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically adding and removing fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing fragment UI separate from activity relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding back button support to `FragmentTransactions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to create interactive UIs that use
    fragments to dynamically change the appearance of the screen in response to user
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: Intentional screen management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've considered each activity to always correspond to a single screen
    in our application. We've used fragments only to represent subsections within
    each screen. As an example, let's think back to the way we've constructed our
    book-browsing application. In the case of a wide-display device, our application
    uses a single activity containing two fragments. One fragment displays the list
    of book titles, and the other fragment displays the description of the currently
    selected book. Because both of these fragments appear on the screen at the same
    time, we display and manage them from a single activity. In the case of a portrait-oriented
    handset, we chose to display the book list and the book description on separate
    screens. Because the two fragments do not appear on the screen at the same time,
    we manage them in separate activities.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing is that the tasks our application performs are identical
    in both cases. The only difference is how much information we're able to display
    on the screen at one time. That one detail causes us to add an extra activity
    to our application. We also increase the complexity of our application because
    the code to launch a new activity is more involved than the code we use to simply
    update a fragment within the same activity. And we have duplicated code in the
    activities because they both interact with the book description fragment.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll recall, when we started talking about fragments in [Chapter 1](ch01.html
    "Chapter 1. Fragments and UI Modularization"), *Fragments and UI Modularization*,
    we mentioned that one of the key values of fragments is that they help reduce
    unnecessary complications, activity proliferation, and logic duplication. Yet
    as the application is currently written, we're experiencing all of those things.
  prefs: []
  type: TYPE_NORMAL
- en: We need to evolve our thinking about UI design a little further. Rather than
    having activities within our application that simply react to what information
    happens to fit on the device's physical display, we instead need to focus on intentionally
    managing the relationship between the screens in our application and the corresponding
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: To the user, the experience of moving to a new screen simply means that the
    view layout they are looking at is replaced with a different view layout. Historically,
    we've tended to design our applications so that each activity has a relatively
    fixed layout. As a result, moving the user to a new screen has required displaying
    a new activity, but fragments give us another option.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than simply using fragments to manage logical subsections of the screen,
    we can also use them to manage logical groupings of an entire screen. We can then
    dynamically manage the fragments within an activity to change from one fragment
    to another. This gives the user the experience of moving from one screen to the
    next while giving us the convenience of managing common user interface elements
    within a single activity.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically managing fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of dynamically managing fragments commonly involves multiple steps.
    The steps may be simple like removing one fragment and adding another, or they
    may be more complex, involving the removal and addition of multiple fragments.
    In any case, we need to be certain that all dynamic changes to the fragments within
    an activity that constitute a shift from one application screen to the next occur
    together as a single unit of work. Android does this by grouping the steps into
    transactions using the `FragmentTransaction` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, the `FragmentTransaction` class behaves in a manner consistent
    with other transaction models: start the transaction, identify the desired changes,
    and commit the transaction once all changes within that unit of work are identified.'
  prefs: []
  type: TYPE_NORMAL
- en: When we're ready to make changes, we start a new `FragmentTransaction` instance
    by calling the `beginTransaction` method on the activity's `FragmentManager` instance,
    which returns back a reference to a `FragmentTransaction` instance. We then use
    the new `FragmentTransaction` instance to identify the desired changes to the
    list of displayed fragments within the activity. While we're in the transaction,
    these changes are queued up but not yet applied. Finally, when we've identified
    all the desired changes, we call the `FragmentTransaction` class' `commit` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the changes in the transaction are applied, our application display
    is updated to reflect those changes, giving the user the feel of moving to a new
    screen of our application. Although a number of steps have occurred within our
    application, from the user's perspective everything behaves just as if we had
    displayed a new activity.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred execution of transaction changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The call to the `commit` method does not apply the changes immediately.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with the `FragmentTransaction` class, we are not doing any direct
    work on the application user interface. Instead, we're building a To-Do list of
    work to be done to the user interface in the future. Each method that we call
    on a `FragmentTransaction` instance adds another To-Do item to the list. When
    we're done adding to the To-Do list and we call the `commit` method, those instructions
    get packaged up and sent to the main UI thread's message queue. The UI thread
    then walks through the list, performing the actual user interface work on behalf
    of the `FragmentTransaction` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The deferred execution of the work performed within a `FragmentTransaction`
    instance works well in most cases. It can, however, create problems if our application
    code needs to find a fragment or interact with a view that is added by a fragment
    immediately following the call to the `commit` method. Although such a requirement
    is not normally the case, it does sometimes come up.
  prefs: []
  type: TYPE_NORMAL
- en: If we do have such a requirement, we can force the `FragmentTransaction` instance's
    work to be executed immediately by calling the `FragmentManager` class' `executePendingTransactions`
    method after the call to the `FragmentTransaction` instance's `commit` method.
    When a call to the `executePendingTransactions` method returns, we know that all
    the committed `FragmentTransaction` work has been performed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful by only calling the `executePendingTransactions` method
    on the main UI thread; this method causes the pending user interface work to execute,
    and therefore triggers direct interaction with the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of methods available on the `FragmentTransaction` class to
    manipulate the fragments within an activity, but the most fundamental are the
    `add` and `remove` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` method allows us to place a newly created fragment instance within
    a specific view group of our activity as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first create a new `FragmentTransaction` instance using the activity's `FragmentManager`
    instance. We then create a new instance of our `BookListFragment2` class and attach
    it to the activity as a child of the `LinearLayout` view group identified by the
    `R.id.layoutRoot` ID value. Finally, we commit the `FragmentTransaction` instance
    indicating that we're done making changes.
  prefs: []
  type: TYPE_NORMAL
- en: The string value, `"bookList"`, that we pass as the third parameter to the `add`
    method is simply a tag value. We can use the tag value to later locate the fragment
    instance in much the same way as we might use the id value. When adding fragments
    dynamically, we use tags as identifiers rather than id values simply because there
    is no way to associate an id value with a dynamically added fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tag value comes in handy when we''re ready to display a different fragment
    because we need to have a reference to the existing fragment to pass to the `remove`
    method so that we can remove it before adding a new fragment. The following code
    shows how we can update the display to show the `BookDescFragment` class in place
    of the `BookListFragment2` class we added in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We begin by using the tag value to find our existing `BookListFragment2` instance
    using the `FragmentManager` class' `findFragmentByTag` method. We then create
    an instance of the new fragment we wish to add. Now that we have references to
    the fragment we want to remove and the one we want to add, we begin fragment transaction.
    Within the transaction, we remove the `BookListFragment2` instance by passing
    the reference to the `FragmentTransaction` class' `remove` method and then add
    the new fragment using the `add` method just as we did earlier. Finally, we call
    the `commit` method to allow the changes to be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of removing the fragment instance under a particular view group
    and adding another in its place occurs frequently enough that the `FragmentTransaction`
    class includes a convenient method named `replace`. The `replace` method allows
    us to simply identify the information for the fragment we wish to add. It takes
    care of the details of removing any other fragments that may exist within the
    target view group. Using the `replace` method, the code to remove the `BookListFragment2`
    instance and add the `BookDescFragment` instance can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this code, with the exception of the method name, is identical to
    the case of simply adding a fragment. We create our fragment instance, and then
    within the `FragmentTransaction` call, the `replace` method passes the id of the
    target view group, fragment instance, and tag. The `replace` method handles the
    details of removing any fragment that may currently be within the `R.id.layoutRoot`
    view group. It then adds the `BookDescFragment` instance to the view group.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the back button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we move to this model of managing our application screens as fragments, we
    need to be sure that we're providing the user with an experience consistent with
    their expectations. An area that requires special attention is our application's
    handling of the back button.
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with the applications on their device, they naturally
    move forward through various application screens. The normal behavior is that
    a user can move back to a previous screen at any time by tapping the back button.
    This works because each time an application displays a new activity, Android automatically
    adds that activity to the Android back stack. This results in the expected behavior
    of the user moving to the previous activity with each tap of the back button.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is based on the assumption that one activity equals one application
    screen; an assumption that is no longer correct. When we transition the user from
    one application screen to another using the `FragmentTransaction` class, the application
    continues to display the same activity, leaving the back stack with no awareness
    of our application's new screen. This results in the application appearing to
    jump back multiple screens in response to the user tapping the back button because
    the back stack returns the user directly to the previous activity ignoring any
    intermediate changes made to the current activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting the back button](img/3095OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An application initially calls the `startActivity` method to display an instance
    of `Activity1`. `Activity1` is automatically added to the back stack and is currently
    at the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Activity1` then calls the `startActivity` method to display `Activity2,` which
    uses the `FragmentTransaction.add` method to add `FragmentA`. `Activity2` is automatically
    added to the top of the back stack.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, `Activity2` uses the `FragmentTransaction.replace` method to display `FragmentB`
    in place of `FragmentA`. As far as the user is concerned, the application is displaying
    a new screen showing the contents of `FragmentB`. The problem is that the back
    stack is unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user now taps the back button, his/her expectation is that the app
    should display the previous screen, `FragmentA`, but instead when Android pops
    the back stack, the next screen it encounters is `Activity1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We resolve this issue by calling the `FragmentTransaction` class' `addToBackStack`
    method within the `FragmentTransaction` instance that displays `FragmentB`. The
    `addToBackStack` method adds the changes within the transaction to the top of
    the back stack. This allows the user to use the back button to move through the
    application screens created within the `FragmentTransaction` instance just as
    one does with screens created by showing an activity.
  prefs: []
  type: TYPE_NORMAL
- en: We can call the `addToBackStack` method at any point during the transaction
    prior to calling the `commit` method. The `addToBackStack` method optionally accepts
    a string parameter that can be used to name the location in the back stack. This
    is useful if you wish to programmatically manipulate the back stack later, but
    in most cases this parameter value can be passed as null. We'll see the `addToBackStack`
    method in action shortly as we modify our application to use a more adaptive layout.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an adaptive application layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s put our discussion of dynamic fragment management into practice by updating
    our application to work with just a single activity. This one activity will handle
    both scenarios: wide-display devices where both fragments appear side-by-side
    and portrait-oriented handsets where the fragments appear as two separate screens.
    As a reminder, the application appears as shown in the following screenshot in
    each scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an adaptive application layout](img/3095_04_02_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our application, we'll leave the wide-display aspect of the program alone
    because static layout management is working fine there. Our work is on the portrait-oriented
    handset aspect of the application. For these devices, we'll update the application's
    main activity to dynamically switch between displaying the fragment containing
    the list of books and the fragment displaying the selected book description.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the layout to support dynamic fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we write any code to dynamically manage the fragments within our application,
    we first need to modify the activity layout resource for portrait-oriented handset
    devices. That resource is contained in the `activity_main.xml` layout resource
    file and currently appears as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make two changes to the layout resource. The first is to add an
    id attribute to the `LinearLayout` view group so that we can easily locate it
    in code. The other change is to completely remove the `fragment` element. The
    updated layout resource now contains only the `LinearLayout` view group, which
    includes an id attribute value of `@+id/layoutRoot`. The layout resource now appears
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We still want our application to initially display the book list fragment, so
    removing the `fragment` element may seem like a strange change, but doing so is
    essential as we move our application to dynamically manage the fragments. We will
    eventually need to remove the book list fragment to replace it with the book description
    fragment. If we were to leave the book list fragment in the layout resource, our
    attempt to dynamically remove it later would silently fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only dynamically added fragments can be dynamically removed. Attempting to dynamically
    remove a fragment that was statically added with the `fragment` element in a layout
    resource will silently fail.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to device differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our application is running on a portrait-oriented handset device, the activity
    needs to programmatically load the fragment containing the book list. This is
    the same `Fragment` class, `BookListFragment2`, we were previously loading with
    the `fragment` element in the `activity_main.xml` layout resource file. Before
    we load the book list fragment, we first need to determine whether we're running
    on a device that requires dynamic fragment management. Remember that for the wide-display
    devices, we're going to leave the static fragment management in place.
  prefs: []
  type: TYPE_NORMAL
- en: There'll be a couple of places in our code where we'll need to take different
    logic paths depending on which layout we're using, so we'll need to add a `boolean`
    class-level field to the activity where we can store whether we're using dynamic
    or static fragment management.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We could interrogate the device for its specific characteristics such as screen
    size and orientation. But remember that much of our previous work was to configure
    our application to take advantage of the Android resource system to automatically
    load the appropriate layout resources based on the device characteristics. Rather
    than repeating those characteristics checks in code, we can instead simply include
    the code to determine which layout resource was loaded. The layout resource for
    wide-display devices we created earlier, `activity_main_wide.xml`, statically
    loads both the book list fragment and the book description fragment. We can include
    in our activity''s `onCreate` method code to determine if the loaded layout resource
    includes one of those fragments as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the call to the `setContentView` method returns, we know that the appropriate
    layout resource for the current device has been loaded. We then use the `FragmentManager`
    instance to search for the fragment with an id value of `R.id.fragmentDescription`
    that is included in the layout resource for wide-display devices but not the layout
    resource for portrait-oriented handsets. A return value of `null` indicates that
    the fragment was not loaded and we are, therefore, on a device that requires us
    to dynamically manage the fragments. In addition to the test for null, we also
    include the call to the `isInLayout` method to protect against one special case
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario where the device is in a landscape layout and then rotated to
    portrait, a cached instance to the fragment identified by `R.id.fragmentDescription`
    may still exist even though in the current orientation the activity is not using
    the fragment. By calling the `isInLayout` method, we're able to determine whether
    the returned reference is part of the currently loaded layout. With this, our
    test to set the `mIsDynamic` member variable effectively says that we'll set `mIsDynamic`
    to true when the `R.id.fragmentDescription` fragment is not found (equals `null`)
    or it's found but not part of the currently loaded layout (`!bookDescFragment.isInLayout`).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading a fragment at startup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''re able to determine whether dynamically loading the book list
    fragment is necessary, we add the code to do so to our `onCreate` method as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Following the check to determine if we're on a device that requires dynamic
    fragment management, we include `FragmentTransaction` to add an instance of the
    `BookListFragment2` class to the activity as a child of the `LinearLayout` view
    group identified by the id value `R.id.layoutRoot`. This code capitalizes on the
    changes we made to the `activity_main.xml` resource file of removing the `fragment`
    element and including an id value on the `LinearLayout` view group.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're dynamically loading the book list, we're ready to get rid of
    that other activity.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you''ll recall, whenever the user selects a book title within the `BookListFragment2`
    class, the fragment notifies the main activity by calling the `onSelectedBookChanged`
    method by passing the index of the selected book. The `onSelectedBookChanged`
    method currently appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the current implementation, we use a technique similar to what we did in
    the `onCreate` method to determine which layout is loaded; we try to find the
    book description fragment within the currently loaded layout. If we find it, we
    know the current layout includes the fragment and so we go ahead and set the book
    description directly on the fragment. If we don't find it, we call the `startActivity`
    method to display the activity that does contain the book description fragment.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, handing off to the other activity isn't too bad because we
    only pass a simple integer value to the other activity. In practice though, the
    need to pass data over to another activity can be complicated. This is especially
    true if there are a large number of values or if some of those values are object
    types that cannot be directly passed in an `Intent` instance without additional
    coding. As we already have all the necessary handling to interact with the fragment
    in the current activity, we'd prefer to handle it consistently in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating redundant handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, we can strip any code in the current implementation that deals
    with starting an activity. We can also avoid repeating the check for the book
    description fragment because we performed that check earlier in the `onCreate`
    method. Instead, we can now check the `mIsDynamic` class-level field to determine
    the proper handling. With that in mind, we can initially modify the `onSelectedBookChanged`
    method to now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We now check the `mIsDynamic` member field to determine the appropriate code
    path. We still have some work to do if it turns out to be true, but in the case
    of it being false, we can simply get a reference to the book description fragment
    that we know is contained within the current layout and set the book index on
    it much like we were doing before.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the fragment on-the-fly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the case of the `mIsDynamic` field being true, we can display the book description
    fragment by simply replacing the book list fragment we added in the `onCreate`
    method with the book description fragment using the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Within `FragmentTransaction` we create an instance of the `BookDescFragment`
    class and call the `replace` method passing the id of the same view group that
    contains the `BookListFragment2` instance that we added in the `onCreate` method.
    We include a call to the `addToBackStack` method so that the back button functions
    correctly, allowing the user to tap the back button to return to the book list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code includes a call to the `FragmentTransaction` class' `setCustomAnimations`
    method that creates a fade effect when the user switches from one fragment to
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: Managing asynchronous creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have one final challenge, that is, setting the book index on the dynamically
    added book description fragment. Our initial thought might be to simply call the
    `BookDescFragment` class'' `setBook` method after we create the `BookDescFragment`
    instance, but let''s first take a look at the current implementation of the `setBook`
    method that appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the method attempts to set the value of `mBookDescriptionTextView`
    within the fragment, which is a problem. Remember that the work we do within a
    `FragmentTransaction` class is not immediately applied to the user interface,
    but is instead performed only after we call the `commit` method. As a result,
    the `BookDescFragment` instance's `onCreate` and `onCreateView` methods have not
    yet been called. Therefore, any views associated with the `BookDescFragment` instance
    have not yet been created. An attempt to call the `setText` method on the `mBookDescriptionTextView`
    instance would result in a null reference exception.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be to modify the `setBook` method to be aware of
    the current state of the fragment. In that scenario, the `setBook` method would
    check whether the `BookDescFragment` instance had been fully created. If not,
    it would store the book index value in the class-level field and later automatically
    set the `mBookDescriptionTextView` value as part of the creation process. Although
    there may be some scenarios that warrant such a complicated solution, fragments
    give us an easier one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Fragment` base class includes a method called `setArguments`. With the
    `setArguments` method, we can attach data values, otherwise known as arguments,
    to the fragment that can then be accessed later in the fragment lifecycle using
    the `getArguments` method. Much like we do when associating extras with an `Intent`
    instance, a good practice is to define constants on the target class to name the
    argument values. It is also a good programming practice to provide a constant
    for an argument default value in the case of non-nullable types such as integers
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `BOOK_INDEX` constant to get and set the book index value and
    the `BOOK_INDEX_NOT_SET` constant to indicate whether the book index argument
    has been set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the `BookDescFragment` class'' `onCreateView` method to look
    for arguments that might be attached to the fragment. Before we make any changes
    to the `onCreateView` method, let''s look at the current implementation that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As the `onCreateView` method is currently implemented, it simply inflates the
    layout resource, loads the array containing the book descriptions, and caches
    a reference to the `TextView` instance where the book description is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the method to look for and use a book index that might be
    attached as an argument. The updated method appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Just before we return the fragment's view hierarchy, we call the `getArguments`
    method to retrieve any arguments that might be attached. The arguments are returned
    as an instance of the `Bundle` class. If the `Bundle` instance is non-null, we
    call the `Bundle` class' `getInt` method to retrieve the book index and assign
    it the `bookIndex` local variable. The second parameter to the `getInt` method,
    `BOOK_INDEX_NOT_SET`, is returned if the fragment happens to have arguments attached
    that do not include the book index. Although this should not normally be the case,
    being prepared for any such unexpected circumstance is a good idea. Finally, we
    check the value of the `bookIndex` variable. If it contains a book index, we call
    the fragment's `setBook` method to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `BookDescFragment` class now including support for attaching the book
    index as an argument, we''re ready to fully implement the main activity''s `onSelectedBookChanged`
    method to include switching to the `BookDescFragment` instance and attaching the
    book index as an argument. The method now appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, we start with the check to see if we're doing dynamic fragment
    management. Once we determine we are, we start the `FragmentTransaction` instance
    and create the `BookDescFragment` instance. We then create a new `Bundle` instance,
    store the book index into it, and then attach the `Bundle` instance to the `BookDescFragment`
    instance with the `setArguments` method. Finally, we put the `BookDescFragment`
    instance into place as the current fragment, take care of the back stack, enable
    animation, and complete the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is now complete. When the user selects a book title from the list,
    the `onSelectedBookChanged` method gets called. The `onSelectedBookChanged` method
    then creates and displays the `BookDescFragment` instance with the appropriate
    book index attached as an argument. When the `BookDescFragment` instance is ultimately
    created, its `onCreateView` method will then retrieve the book index from the
    arguments and display the appropriate description.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intentional screen management frees us from the burden of tying each application
    screen to an individual activity. Using the `FragmentTransaction` class, we're
    able to dynamically switch between individual fragments within an activity, eliminating
    the need to create a separate activity class for each screen in our application.
    This helps to prevent the proliferation of unnecessary activity classes, better
    organize our applications, and avoid the associated increase in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see in the next chapter that this ability to dynamically manage multiple
    screens within a single activity opens us up to greater flexibility and an increased
    richness in the appearance and navigation behavior of our Android applications.
  prefs: []
  type: TYPE_NORMAL
