- en: Chapter 1. Saying Hello to Unity and Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the wonderful world of mobile game development. Whether you are still
    looking for the right development kit or have already chosen one, this chapter
    will be very important. In this chapter, we explore the various features that
    come with choosing **Unity** as your development environment and **Android** as
    the target platform. Through comparison with major competitors, it is discovered
    why Unity and Android stand at the top of the pile. Following this, we will examine
    how Unity and Android work together. Finally, the development environment will
    be set up and we will create a simple Hello World application to test whether
    everything is set up correctly. For the purposes of this book, it is assumed that
    you are working in a Windows-based environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Major Unity features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major Android features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity licensing options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Android software development kit (SDK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Unity 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Unity Remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what makes Unity great
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the greatest feature of Unity is how open-ended it is. Nearly all game
    engines currently on the market are limited in what one can build with them. It
    makes perfect sense but it can limit the capabilities of a team. The average game
    engine has been highly optimized for creating a specific game type. This is great
    if all you plan on making is the same game again and again. It can be quite frustrating
    when one is struck with inspiration for the next great hit, only to find that
    the game engine can't handle it and everyone has to retrain in a new engine or
    double the development time to make the game engine capable. Unity does not suffer
    from this problem. The developers of Unity have worked very hard to optimize every
    aspect of the engine, without limiting what types of games can be made using it.
    Everything ranging from simple 2D platformers to massive online role-playing games
    are possible in Unity. A development team that just finished an ultrarealistic
    first-person shooter can turn right around and make 2D fighting games without
    having to learn an entirely new system.
  prefs: []
  type: TYPE_NORMAL
- en: Being so open-ended does, however, bring a drawback. There are no default tools
    that are optimized for building the perfect game. To combat this, Unity grants
    the ability to create any tool one can imagine, using the same scripting that
    creates the game. On top of that, there is a strong community of users that have
    supplied a wide selection of tools and pieces, both free and paid, that can be
    quickly plugged in and used. This results in a large selection of available content
    that is ready to jump-start you on your way to the next great game.
  prefs: []
  type: TYPE_NORMAL
- en: When many prospective users look at Unity, they think that, because it is so
    cheap, it is not as good as an expensive AAA game engine. This is simply not true.
    Throwing more money at the game engine is not going to make a game any better.
    Unity supports all of the fancy shaders, normal maps, and particle effects that
    you could want. The best part is that nearly all of the fancy features that you
    could want are included in the free version of Unity, and 90 percent of the time
    beyond that, you do not even need to use the Pro-only features.
  prefs: []
  type: TYPE_NORMAL
- en: One of the greatest concerns when selecting a game engine, especially for the
    mobile market, is how much girth it will add to the final build size. Most game
    engines are quite hefty. With Unity's code stripping, the final build size of
    the project becomes quite small. Code stripping is the process by which Unity
    removes every extra little bit of code from the compiled libraries. A blank project
    compiled for Android that utilizes full code stripping ends up being around 7
    megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps one of the coolest features of Unity is its multi-platform compatibility.
    With a single project, one can build for several different platforms. This includes
    the ability to simultaneously target mobiles, PCs, and consoles. This allows you
    to focus on real issues, such as handling inputs, resolution, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, if a company desired to deploy their product on more than one platform,
    they had to nearly double the development costs in order to essentially reprogram
    the game. Every platform did, and still does, run by its own logic and language.
    Thanks to Unity, game development has never been simpler. We can develop games
    using simple and fast scripting, letting Unity handle the complex translation
    to each platform.
  prefs: []
  type: TYPE_NORMAL
- en: Unity – the best among the rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are of course several other options for game engines. Two major ones that
    come to mind are **cocos2d** and **Unreal Engine**. While both are excellent choices,
    you will find them to be a little lacking in certain respects.
  prefs: []
  type: TYPE_NORMAL
- en: The engine of Angry Birds, cocos2d, could be a great choice for your next mobile
    hit. However, as the name suggests, it is pretty much limited to 2D games. A game
    can look great in it, but if you ever want that third dimension, it can be tricky
    to add it to cocos2d; you may need to select a new game engine. A second major
    problem with cocos2d is how bare bones it is. Any tool for building or importing
    assets needs to be created from scratch, or it needs to be found. Unless you have
    the time and experience, this can seriously slow down development.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the staple of major game development, Unreal Engine. This game
    engine has been used successfully by developers for many years, bringing great
    games to the world Unreal Tournament and Gears of War not the least among them.
    These are both, however, console and computer games, which is the fundamental
    problem with the engine. Unreal is a very large and powerful engine. Only so much
    optimization can be done on it for mobile platforms. It has always had the same
    problem; it adds a lot of girth to a project and its final build. The other major
    issue with Unreal is its rigidity in being a first-person shooter engine. While
    it is technically possible to create other types of games in it, such tasks are
    long and complex. A strong working knowledge of the underlying system is a must
    before achieving such a feat.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, Unity definitely stands strong amidst game engines. Perhaps, you
    have already discovered this and that is why you are reading this book. But these
    are still great reasons for choosing Unity for game development. Unity projects
    can look just as great as AAA titles. The overhead and girth in the final build
    are small and this is very important when working on mobile platforms. The system's
    potential is open enough to allow you to create any type of game that you might
    want, where other engines tend to be limited to a single type of game. In addition,
    should your needs change at any point in the project's life cycle, it is very
    easy to add, remove, or change your choice of target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what makes Android great
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With over 30 million devices in the hands of users, why would you not choose
    the Android platform for your next mobile hit? Apple may have been the first one
    out of the gate with their iPhone sensation, but Android is definitely a step
    ahead when it comes to smartphone technology. One of its best features is its
    blatant ability to be opened up so that you can take a look at how the phone works,
    both physically and technically. One can swap out the battery and upgrade the
    micro SD card on nearly all Android devices, should the need arise. Plugging the
    phone into a computer does not have to be a huge ordeal; it can simply function
    as a removable storage media.
  prefs: []
  type: TYPE_NORMAL
- en: From the point of view of the cost of development as well, the Android market
    is superior. Other mobile app stores require an annual registration fee of about
    100 dollars. Some also have a limit on the number of devices that can be registered
    for development at one time. The Google Play market has a one-time registration
    fee of 25 dollars, and there is no concern about how many Android devices or what
    type of Android devices you are using for development.
  prefs: []
  type: TYPE_NORMAL
- en: One of the drawbacks of some of the other mobile development kits is that you
    have to pay an annual registration fee before you have access to the SDK. With
    some, registration and payment are required before you can view their documentation.
    Android is much more open and accessible. Anybody can download the Android SDK
    for free. The documentation and forums are completely viewable without having
    to pay any fee. This means development for Android can start earlier, with device
    testing being a part of it from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Unity and Android work together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Unity handles projects and assets in a generic way, there is no need to create
    multiple projects for multiple target platforms. This means that you could easily
    start development with the free version of Unity and target personal computers.
    Then, at a later date, you can switch targets to the Android platform with the
    click of a button. Perhaps, shortly after your game is launched, it takes the
    market by storm and there is a great call to bring it to other mobile platforms.
    With just another click of the button, you can easily target iOS without changing
    anything in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Most systems require a long and complex set of steps to get your project running
    on a device. For the first application in this book, we will be going through
    that process because it is important to know about it. However, once your device
    is set up and recognized by the Android SDK, a single button click will allow
    Unity to build your application, push it to a device, and start running it. There
    is nothing that has caused more headaches for some developers than trying to get
    an application on a device. Unity makes this simple.
  prefs: []
  type: TYPE_NORMAL
- en: With the addition of a free Android application, **Unity Remote**, it is simple
    and easy to test mobile inputs without going through the whole build process.
    While developing, there is nothing more annoying than waiting for 5 minutes for
    a build every time you need to test a minor tweak, especially in the controls
    and interface. After the first dozen little tweaks, the build time starts to add
    up. Unity Remote makes it simple and easy to test everything without ever having
    to hit the **Build** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the big three reasons why Unity works well with Android:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A one-click build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity Remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could, of course, come up with several more great ways in which Unity and
    Android can work together. However, these three are the major time and money savers.
    You could have the greatest game in the world, but if it takes 10 times longer
    to build and test, what is the point?
  prefs: []
  type: TYPE_NORMAL
- en: Differences between the Pro and Basic versions of Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity comes with two licensing options, Pro and Basic, which can be found at
    [https://store.unity3d.com](https://store.unity3d.com). In order to follow the
    bulk of this book, Unity Basic is all that is required. However, real-time shadows
    in [Chapter 4](ch04.html "Chapter 4. Setting the Stage – Camera Effects and Lighting"),
    *Setting the Stage* – *Camera Effects and Lighting*, and some of the optimization
    features discussed in [Chapter 9](ch09.html "Chapter 9. Optimization"), *Optimization*,
    will require Unity Pro. If you are not quite ready to spend the 3,000 dollars
    that is required to purchase a full Unity Pro license with the Android add-on,
    there are other options. Unity Basic is free and comes with a 30-day free trial
    of Unity Pro. This trial is full and complete, as if you have purchased Unity
    Pro, the only downside being a watermark in the bottom-right corner of your game
    stating **Demo Use Only**. It is also possible to upgrade your license at a later
    date. Where Unity Basic comes with mobile options for free, Unity Pro requires
    the purchase of Pro add-ons for each of the mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of license comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'License comparisons can be found at [http://unity3d.com/unity/licenses](http://unity3d.com/unity/licenses).
    This section will cover the specific differences between Unity Android Pro and
    Unity Android Basic. We will explore what the features are and how useful each
    one is in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: NavMeshes, pathfinding, and crowd simulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This feature is Unity's built-in pathfinding system. It allows characters to
    find their way from a point to another around your game. Just bake your navigation
    data in the editor and let Unity take over at runtime. Until recently, this was
    a Unity Pro only feature. Now the only part of it that is limited in Unity Basic
    is the use of off-mesh links. The only time you are going to need them is when
    you want your AI characters to be able to jump across and otherwise navigate around
    gaps.
  prefs: []
  type: TYPE_NORMAL
- en: LOD support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LOD** (short for **level of detail**) lets you control how complex a mesh
    is, based on its distance from the camera. When the camera is close to an object,
    you can render a complex mesh with a bunch of detail in it. When the camera is
    far from that object, you can render a simple mesh because all that detail is
    not going to be seen anyway. Unity Pro provides a built-in system to manage this.
    However, this is another system that could be created in Unity Basic. Whether
    or not you are using the Pro version, this is an important feature for game efficiency.
    By rendering less complex meshes at a distance, everything can be rendered faster,
    leaving more room for awesome gameplay.'
  prefs: []
  type: TYPE_NORMAL
- en: The audio filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Audio filters allow you to add effects to audio clips at runtime. Perhaps you
    created gravel footstep sounds for your character. Your character is running and
    we can hear the footsteps just fine, when suddenly they enter a tunnel and a solar
    flare hits, causing a time warp and slowing everything down. Audio filters would
    allow us to warp the gravel footstep sounds to sound as if they were coming from
    within a tunnel and were slowed by a time warp. Of course, you could also just
    have the audio guy create a new set of tunnel gravel footsteps in the time warp
    sounds, although this might double the amount of audio in your game and limit
    how dynamic we can be with it at runtime. We either are or are not playing the
    time warp footsteps. Audio filters would allow us to control how much time warp
    is affecting our sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Video playback and streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with complex or high-definition cut scenes, being able to play
    videos becomes very important. Including them in a build, especially with a mobile
    target, can require a lot of space. This is where the streaming part of this feature
    comes in. This feature not only lets us play videos but also lets us stream a
    video from the Internet. There is, however, a drawback to this feature. On mobile
    platforms, the video has to go through the device's built-in video-playing system.
    This means that the video can only be played in fullscreen and cannot be used
    as a texture for effects such as moving pictures on a TV model. Theoretically,
    you could break your video into individual pictures for each frame and flip through
    them at runtime, but this is not recommended for build size and video quality
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Fully-fledged streaming with asset bundles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asset bundles are a great feature provided by Unity Pro. They allow you to create
    extra content and stream it to users without ever requiring an update to the game.
    You could add new characters, levels, or just about any other content you can
    think of. Their only drawback is that you cannot add more code. The functionality
    cannot change, but the content can. This is one of the best features of Unity
    Pro.
  prefs: []
  type: TYPE_NORMAL
- en: The 100,000 dollar turnover
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This one isn't so much a feature as it is a guideline. According to Unity's
    End User License Agreement, the basic version of Unity cannot be licensed by any
    group or individual who made $100,000 in the previous fiscal year. This basically
    means that if you make a bunch of money, you have to buy Unity Pro. Of course,
    if you are making that much money, you can probably afford it without an issue.
    This is the view of Unity at least and the reason why there is a 100,000 dollar
    turnover.
  prefs: []
  type: TYPE_NORMAL
- en: Mecanim – IK Rigs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity's new animation system, **Mecanim**, supports many exciting new features,
    one of which is **IK** (short form for **Inverse Kinematics**). If you are unfamiliar
    with the term, IK allows one to define the target point of an animation and let
    the system figure out how to get there. Imagine you have a cup sitting on a table
    and a character that wants to pick it up. You could animate the character to bend
    over and pick it up; but, what if the character is slightly to the side? Or any
    number of other slight offsets that a player could cause, completely throwing
    off your animation? It is simply impractical to animate for every possibility.
    With IK, it hardly matters that the character is slightly off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just define the goal point for the hand and leave the animation of the arm
    to the IK system. It calculates how the arm needs to move in order to get the
    hand to the cup. Another fun use is making characters look at interesting things
    as they walk around a room: a guard could track the nearest person, the player''s
    character could look at things that they can interact with, or a tentacle monster
    could lash out at the player without all the complex animation. This will be an
    exciting one to play with.'
  prefs: []
  type: TYPE_NORMAL
- en: Mecanim – sync layers and additional curves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sync layers, inside Mecanim, allow us to keep multiple sets of animation states
    in time with each other. Say you have a soldier that you want to animate differently
    based on how much health he has. When he is at full health, he walks around briskly.
    After a little damage to his health, the walk becomes more of a trudge. If his
    health is below half, a limp is introduced into his walk, and when he is almost
    dead he crawls along the ground. With sync layers, we can create one animation
    state machine and duplicate it to multiple layers. By changing the animations
    and syncing the layers, we can easily transition between the different animations
    while maintaining the state machine.
  prefs: []
  type: TYPE_NORMAL
- en: The additional curves feature is simply the ability to add curves to your animation.
    This means we can control various values with the animation. For example, in the
    game world, when a character picks up its feet for a jump, gravity will pull them
    down almost immediately. By adding an extra curve to that animation, in Unity,
    we can control how much gravity is affecting the character, allowing them to actually
    be in the air when jumping. This is a useful feature for controlling such values
    alongside the animations, but you could just as easily create a script that holds
    and controls the curves.
  prefs: []
  type: TYPE_NORMAL
- en: The custom splash screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though pretty self-explanatory, it is perhaps not immediately evident why this
    feature is specified, unless you have worked with Unity before. When an application
    that is built in Unity initializes on any platform, it displays a splash screen.
    In Unity Basic, this will always be the Unity logo. By purchasing Unity Pro, you
    can substitute for the Unity logo with any image you want.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time spot/point and soft shadows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lights and shadows add a lot to the mood of a scene. This feature allows us
    to go beyond blob shadows and use realistic-looking shadows. This is all well
    and good if you have the processing space for it. However, most mobile devices
    do not. This feature should also never be used for static scenery; instead, use
    static lightmaps, which is what they are for.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you can find a good balance between simple needs and quality, this
    could be the feature that creates the difference between an alright and an awesome
    game. If you absolutely must have real-time shadows, the directional light supports
    them and is the fastest of the lights to calculate. It is also the only type of
    light available to Unity Basic that supports real-time shadows.
  prefs: []
  type: TYPE_NORMAL
- en: HDR and tone mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**HDR** (short for **high dynamic range**) and tone mapping allow us to create
    more realistic lighting effects. Standard rendering uses values from zero to one
    to represent how much of each color in a pixel is on. This does not allow for
    a full spectrum of lighting options to be explored. HDR lets the system use values
    beyond this range and processes them using tone mapping to create better effects,
    such as a bright morning room or the bloom from a car window reflecting the sun.
    The downside of this feature is in the processor. The device can still only handle
    values between zero and one, so converting them takes time. Additionally, the
    more complex the effect, the more time it takes to render it. It would be surprising
    to see this used well on handheld devices, even in a simple game. Maybe the modern
    tablets could handle it.'
  prefs: []
  type: TYPE_NORMAL
- en: Light probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Light probes are an interesting little feature. When placed in the world, light
    probes figure out how an object should be lit. Then, as a character walks around,
    they tell it how to be shaded. The character is, of course, lit by the lights
    in the scene, but there are limits on how many lights can shade an object at once.
    Light probes do all the complex calculations beforehand, allowing for better shading
    at runtime. Again, however, there are concerns about processing power. Too little
    power and you won't get a good effect; too much and there will be no processing
    power left for playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmapping with global illumination and area lights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All versions of Unity support lightmaps, allowing for the baking of complex
    static shadows and lighting effects. With the addition of global illumination
    and area lights, you can add another touch of realism to your scenes. However,
    every version of Unity also lets you import your own lightmaps. This means that
    you could use some other program to render the lightmaps and import them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Static batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This feature speeds up the rendering process. Instead of spending time grouping
    objects for faster rendering on each frame , this allows the system to save the
    groups generated beforehand. Reducing the number of draw calls is a powerful step
    towards making a game run faster. That is exactly what this feature does.
  prefs: []
  type: TYPE_NORMAL
- en: Render-to-texture effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a fun feature, but of limited use. It allows you to use the output from
    a camera in your game as a texture. This texture could then, in its most simple
    form, be put onto a mesh and act as a surveillance camera. You could also do some
    custom post processing, such as removing the color from the world as the player
    loses their health. However, this option could become very processor-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Fullscreen post-processing effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another processor-intensive feature that probably will not make it into
    your mobile game. However, you can add some very cool effects to your scene, such
    as adding motion blur when the player is moving really fast or a vortex effect
    to warp the scene as the ship passes through a warped section of space. One of
    the best effects is using the bloom effect to give things a neon-like glow.
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion culling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another great optimization feature. The standard camera system renders
    everything that is within the camera's view frustum, the view space. Occlusion
    culling lets us set up volumes in the space our camera can enter. These volumes
    are used to calculate what the camera can actually see from those locations. If
    there is a wall in the way, what is the point of rendering everything behind it?
    Occlusion culling calculates this and stops the camera from rendering anything
    behind that wall.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you desire the best looking game possible, with highly detailed lighting
    and shadows, this is a feature of interest for you. Deferred rendering is a multi-pass
    process for calculating your game's light and shadow detail. This is, however,
    an expensive process and requires a decent graphics card to fully maximize its
    use. Unfortunately, this makes it a little outside of our use for mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Stencil buffer access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom shaders can use the stencil buffer to create special effects by selectively
    rendering over specific pixels. It is similar to how one might use an alpha channel
    to selectively render parts of a texture.
  prefs: []
  type: TYPE_NORMAL
- en: GPU skinning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a processing and rendering method by which the calculations for how
    a character or object appears, when using a skeleton rig, is given to the graphics
    card rather than getting it done by the central processor. It is significantly
    faster to render objects in this way. However, this is only supported on DirectX
    11 and OpenGL ES 3.0, leaving it a bit out of reach for our mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Navmesh – dynamic obstacles and priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This feature works in conjunction with the pathfinding system. In scripts, we
    can dynamically set obstacles, and characters will find their way around them.
    Being able to set priorities means that different types of characters can take
    different types of objects into consideration when finding their way around. For
    example, a soldier must go around the barricades to reach his target. The tank,
    however, could just crash through, should the player desire.
  prefs: []
  type: TYPE_NORMAL
- en: Native code plugins' support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a custom set of code in the form of a **Dynamic Link Library** (**DLL**),
    this is the Unity Pro feature you need access to. Otherwise, the native plugins
    cannot be accessed by Unity for use with your game.
  prefs: []
  type: TYPE_NORMAL
- en: Profiler and GPU profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a very useful feature. The profiler provides tons of information about
    how much load your game puts on the processor. With this information, we can get
    right down into the nitty-gritties and determine exactly how long a script takes
    to process. Towards the end of the book, though, we will also create a tool to
    determine how long specific parts of your code take to process.
  prefs: []
  type: TYPE_NORMAL
- en: Script access to the asset pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an alright feature. With full access to the pipeline, there is a lot
    of custom processing that can be done on assets and builds. The full range of
    possibilities is beyond the scope of this book. However, you can think of it as
    something that can make tint all of the imported textures slightly blue.
  prefs: []
  type: TYPE_NORMAL
- en: Dark skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is entirely a cosmetic feature. Its point and purpose are questionable.
    However, if a smooth, dark-skinned look is what you desire, this is the feature
    that you want. There is an option in the editor to change it to the color scheme
    used in Unity Basic. For this feature, whatever floats your boat goes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can create the next great game for Android, we need to install a few
    programs. In order to make the Android SDK work, we will first install the **Java
    Development Kit** (**JDK**). Then we will install the Android SDK. After that,
    we will install Unity. We then have to install an optional code editor. To make
    sure everything is set up correctly, we will connect to our devices and take a
    look at some special strategies if the device is a tricky one. Finally, we will
    install Unity Remote, a program that will become invaluable in your mobile development.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android''s development language of choice is Java; so, to develop for it, we
    need a copy of the **Java SE Development Kit** on our computer. The process of
    installing the JDK is given in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of the JDK can be downloaded from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    So open the site in a web browser, and you will be able to see the screen showed
    in the following screenshot:![Installing the JDK](img/4691OT_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Java Platform (JDK)** from the available versions and you will be brought
    to a page that contains the license agreement and allows you to select the type
    of file you wish to download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license agreement and select your appropriate Windows version from
    the list at the bottom. If you are unsure about which version to choose, then
    **Windows x86** is usually a safe choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the download is completed, run the new installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a system scan, click on **Next** two times, the JDK will initialize, and
    then click on the **Next** button one more time to install the JDK to the default
    location. It is as good there as anywhere else, so once it is installed, hit the
    **Close** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just finished installing the **JDK**. We need this so that our Android
    development kit will work. Luckily, the installation process for this keystone
    is short and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Android SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to actually develop and connect to our devices, we need to have installed
    the Android SDK. Having the SDK installed fulfills two primary requirements. First,
    it makes sure that we have the bulk of the latest drivers for recognizing devices.
    Second, we are able to use the **Android Debug Bridge** (**ADB**). ADB is the
    system used for actually connecting to and interacting with a device. The process
    of installing the Android SDK is given in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of the Android SDK can be found at [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html),
    so open a web browser and go to the given site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once there, scroll to the bottom and find the **SDK Tools Only** section. This
    is where we can get just the SDK, which we need to make Android games with Unity,
    without dealing with the fancy fluff of the Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to select the `.exe` package with **(Recommended)** underneath it (as
    shown in the following screenshot):![Installing the Android SDK](img/4691OT_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then be sent to a **Terms and Conditions** page. Read it if you prefer,
    but agree to it to continue. Then hit the **Download** button to start downloading
    the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it has finished downloading, start it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the first **Next** button and the installer will try to find an appropriate
    version of the JDK. You will come to a page that will notify you about not finding
    the JDK if you do not have it installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you skipped ahead and do not have the JDK installed, hit the **Visit java.oracle.com**
    button in the middle of the page and go back to the previous section for guidance
    on installing it. If you do have it, continue with the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hitting **Next** again will bring you to a page that will ask you about the
    person for whom you are installing the SDK .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Install for anyone using this computer** because the default install
    location is easier to get to for later purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit **Next** twice, followed by **Install** to install the SDK to the default
    location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this is done, hit **Next** and **Finish** to complete the installation
    of the Android SDK Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If Android SDK Manager does not start right away, start it up. Either way, give
    it a moment to initialize. The SDK Manager makes sure that we have the latest
    drivers, systems, and tools for developing with the Android platform. However,
    we have to actually install them first (which can be done from the following screen):![Installing
    the Android SDK](img/4691OT_01_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the SDK manager should select a number of options to install. If
    not, select the latest Android API (Android L (API 20) as of the time of writing
    this book), **Android Support Library** and **Google USB Driver** found in **Extras**.
    Be absolutely sure that **Android SDK Platform-tools** is selected. This will
    be very important later. It actually includes the tools that we need to connect
    to our device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once everything is selected, hit **Install packages** at the bottom-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen is another set of license agreements. Every time a component
    is installed or updated through the SDK manager, you have to agree to the license
    terms before it gets installed. Accept all of the licenses and hit **Install**
    to start the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now sit back and relax. It takes a while for the components to be downloaded
    and installed. Once this is all done, you can close it out. We have completed
    the process, but you should occasionally come back to it. Periodically checking
    the SDK manager for updates will make sure that you are using the latest tools
    and APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installation of the **Android SDK** is now finished. Without it, we would
    be completely unable to do anything on the Android platform. Aside from the long
    wait to download and install components, this was a pretty easy installation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Unity 3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the most important part of this whole book, without which none of the
    rest has meaning, is installing Unity. Perform the following steps to install
    Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of Unity can be found at [http://www.unity3d.com/unity/download](http://www.unity3d.com/unity/download).
    As of the time of writing this book, the current version is 5.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it is downloaded, launch the installer and click on **Next** until you
    reach the **Choose Components** page, as shown in the following screenshot:![Installing
    Unity 3D](img/4691OT_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we are able to select the features of Unity installation. None of these
    options are actually necessary for following the rest of this book, but they warrant
    a look since Unity will ask for the components you wish to install every time
    you update or reinstall it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Example Project**: This is the current project built by Unity to show off
    some of its latest features. If you want to jump in early and take a look at what
    a complete Unity game can look like, leave this checked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity Development Web Player**: This is required if you plan on developing
    browser applications with Unity. As this book is focused on Android development,
    it is entirely optional. It is, however, a good one to check. You never know when
    you may need a web demo and since it is entirely free to develop for the web using
    Unity, there is no harm in having it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MonoDevelop**: It is a wise choice to leave this option unchecked. There
    is more detail in the next section, but it will suffice for now to say that it
    just adds an extra program for script editing that is not nearly as useful as
    it should be.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have selected or deselected your desired options, hit **Next**. If
    you wish to follow the book exactly, note that we will uncheck **MonoDevelop**
    and leave the rest checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is the location of installation. The default location works well, so hit
    **Install** and wait. This will take a couple of minutes, so sit back, relax,
    and enjoy your favorite beverage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation is complete, the option to run Unity will be displayed.
    Leave it checked and hit **Finish**. If you have never installed Unity before,
    you will be presented with a license activation page (as shown in the following
    screenshot):![Installing Unity 3D](img/4691OT_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While Unity does provide a feature-rich, free version, in order to follow the
    entirety of this book, one is required to make use of some of the Unity Pro features.
    At [https://store.unity3d.com](https://store.unity3d.com), you have the ability
    to buy a variety of licenses. To follow the whole book, you will at least need
    to purchase Unity Pro and Android Pro licenses. Once they are purchased, you will
    receive an e-mail containing your new license key. Enter that in the provided
    text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are not ready to make a purchase, you have two alternatives. We will
    go over how to reset your license in the *Building a simple application* section
    later in the chapter. The alternatives are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first alternative is that you can check the **Activate the free version
    of Unity** checkbox. This will allow you to use the free version of Unity. As
    discussed earlier, there are many reasons to choose this option. The most notable
    at the moment is cost.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can select the **Activate a free 30-day trial of Unity Pro**
    option. Unity offers a fully functional, one-time installation and a free 30-day
    trial of Unity Pro. This trial also includes the Android Pro add-on. Anything
    produced during the 30 days is completely yours, as if you had purchased a full
    Unity Pro license. They want you to see how great it is, so you will come back
    and make a purchase. The downside is that the **Trial Version** watermark will
    be constantly displayed at the corner of the game. After the 30 days, Unity will
    revert to the free version. This is a great option, should you choose to wait
    before making a purchase.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever your choice is, hit **OK** once you have made it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next page simply asks you to log in with your Unity account. This will be
    the same account that you used to make your purchase. Just fill out the fields
    and hit **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not yet made a purchase, you can hit **Create Account** and have
    it ready for when you do make a purchase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next page is a short survey on your development interests. Fill it out and
    hit **OK** or scroll straight to the bottom and hit **Not right now**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, there is a thank you page. Hit **Start using Unity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a short initialization, the project wizard will open and we can start
    creating the next great game. However, there is still a bunch of work to do to
    connect the development device. So for now, hit the **X** button in the top-right
    corner to close the project wizard. We will cover how to create a new project
    in the *Building a simple application* section later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just completed installing Unity 3D. The whole book relies on this step. We
    also had to make a choice about licenses. If you chose to purchase the Pro version,
    you will be able to follow everything in this book without problems. The alternatives,
    though, will have a few shortcomings. You will either not have full access to
    all of the features or be limited to the length of the trial period while making
    due with a watermark in your games.
  prefs: []
  type: TYPE_NORMAL
- en: The optional code editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now a choice has to be made about code editors. Unity comes with a system called
    **MonoDevelop**. It is similar in many respects to **Visual Studio**. And like
    Visual Studio, it adds many extra files and much girth to a project, all of which
    it needs to operate. All this extra girth makes it take an annoying amount of
    time to start up, before one can actually get to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you can get away with a plain text editor, as Unity doesn't really
    care. This book recommends using Notepad++, which is found at [http://notepad-plus-plus.org/download](http://notepad-plus-plus.org/download).
    It is free to use and it is essentially Notepad with code highlighting. There
    are several fancy widgets and add-ons for Notepad++ that add even greater functionality
    to it, but they are not necessary for following this book. If you choose this
    alternative, installing Notepad++ to the default location will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most annoying step in working with Android devices is setting up
    the connection to your computer. Since there are so many different kinds of devices,
    it can get a little tricky at times just to have the device recognized by your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: A simple device connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple device connection method involves changing a few settings and a
    little work in the command prompt. It may seem a little scary, but if all goes
    well you will be connected to your device shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do is turn on the phone's **Developer options**.
    In the latest version of Android, these have been hidden. Go to your phone's settings
    page and find the **About phone** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you need to find the **Build number** information slot and tap it several
    times. At first, it will appear to do nothing, but it will shortly display that
    you need to press the button a few more times to activate the **Developer options**.
    The Android team did this so that the average user does not accidentally make
    changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go back to your settings page and there should be a new **Developer options**
    page; select it now. This page controls all of the settings you might need to
    change while developing your applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only checkbox we are really concerned with checking right now is **USB debugging**.
    This allows us to actually detect our device from the development environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Kindle, be sure to go into **Security** and turn on **Enable
    ADB** as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several warning pop-ups that are associated with turning on these
    various options. They essentially amount to the same malicious software warnings
    associated with your computer. Applications with immoral intentions can mess with
    your system and get to your private information. All these settings need to be
    turned on if your device is only going to be used for development. However, as
    the warnings suggest, if malicious applications are a concern, turn them off when
    you are not developing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, open a command prompt on your computer. This can be done most easily by
    hitting your Windows key, typing `cmd.exe`, and then hitting *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to navigate to the ADB commands. If you did not install the SDK
    to the default location, replace the path in the following commands with the path
    where you installed it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are running a 32-bit version of Windows and installed the SDK to the
    default location, type the following in the command prompt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are running a 64-bit version, type the following in the command prompt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, connect your device to your computer, preferably using the USB cable that
    came with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for your computer to finish recognizing the device. There should be a **Device
    drivers installed** type of message pop-up when it is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command lets us see which devices are currently connected and
    recognized by the ADB system. Emulated devices will show up as well. Type the
    following in the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a short pause for processing, the command prompt will display a list of
    attached devices along with the unique IDs of all the attached devices. If this
    list now contains your device, congratulations! You have a developer-friendly
    device. If it is not completely developer-friendly, there is one more thing that
    you can try before things get tricky.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the top of your device and open your system notifications. There should
    be one that looks like the USB symbol. Selecting it will open the connection settings.
    There are a few options here and by default Android selects to connect the Android
    device as a **Media Device**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to connect our device as a **Camera**. The reason is the connection
    method used. Usually, this will allow your computer to connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have completed our first attempt at connecting to our Android devices. For
    most, this should be all that you need to connect to your device. For some, this
    process is not quite enough. The next little section covers solutions to resolve
    the issue for connecting trickier devices.
  prefs: []
  type: TYPE_NORMAL
- en: For trickier devices, there are a few general things that we can try; if these
    steps fail to connect your device, you may need to do some special research.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by typing the following commands. These will restart the connection system
    and display the list of devices again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are still not having any luck, try the following commands. These commands
    force an update and restart the connection system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your device is still not showing up, you have one of the most annoying and
    tricky devices. Check the manufacturer's website for data syncing and management
    programs. If you have had your device for quite some time, you have probably been
    prompted to install this more than once. If you have not already done so, install
    the latest version even if you never plan on using it. The point is to obtain
    the latest drivers for your device, and this is the easiest way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the connection system again using the first set of commands and cross
    your fingers!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are still unable to connect, the best, professional recommendation that
    can be made is to google for the solution to your problem. Conducting a search
    for your device's brand with `adb` at the end should turn up a step-by-step tutorial
    that is specific to your device in the first couple of results. Another excellent
    resource for finding out all about the nitty-gritties of Android devices can be
    found at[http://www.xda-developers.com/](http://www.xda-developers.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of the devices that you will encounter while developing will not connect
    easily. We just covered some quick steps and managed to connect these devices.
    If we could have covered the processes for every device, we would have. However,
    the variety of devices is just too large and the manufacturers keep making more.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity Remote is a great application created by the Unity team. It allows developers
    to connect their Android-powered devices to the Unity Editor and provide mobile
    inputs for testing. This is a definite must for any aspiring Unity and Android
    developer. If you are using a non-Amazon device, acquiring Unity Remote is quite
    easy. At the time of writing this book, it could be found on Google Play at [https://play.google.com/store/apps/details?id=com.unity3d.genericremote](https://play.google.com/store/apps/details?id=com.unity3d.genericremote).
    It is free and does nothing but connects your Android device to the Unity Editor,
    so the app permissions are negligible. In fact, there are currently two versions
    of Unity Remote. To connect to Unity 4.5 and later versions, we must use Unity
    Remote 4.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you like the ever-growing Amazon market or seek to target Amazon's
    line of Android devices, adding Unity Remote will become a little trickier. First,
    you need to download a special Unity Package from the Unity Asset Store. It can
    be found at [https://www.assetstore.unity3d.com/en/#!/content/18106](https://www.assetstore.unity3d.com/en/#!/content/18106).
    You will need to import the package into a fresh project and build it from there.
    Import the package by going to the top of Unity, navigate to **Assets** | **Import
    Package** | **Custom Package**, and then navigate to where you saved it. In the
    next section, we will build a simple application and put it on our device. After
    you have imported the package, follow along from the step where we open the **Build
    Settings** window, replacing the simple application with the created APK.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to create a simple Hello World application. This will familiarize
    you with the Unity interface and how to actually put an application on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure everything is set up properly, we need a simple application to
    test with and what better to do that with than a Hello World application? To build
    the application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is pretty straightforward and simple: start Unity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have been following along so far, once this is done you should see a
    screen resembling the next screenshot. As the tab might suggest, this is the screen
    through which we open our various projects. Right now, though, we are interested
    in creating one; so, select **New Project** from the top-right corner and we will
    do just that:![Hello World](img/4691OT_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Project name*** field to give your project a name; `Ch1_HelloWorld`
    fits well for a project name. Then use the three dots to the right of the **Location***
    field to choose a place on your computer to put the new project. Unity will create
    a new folder in this location, based on the project name, to store your project
    and all of its related files:![Hello World](img/4691OT_01_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we can ignore the **3D** and **2D** buttons. These let us determine
    the defaults that Unity will use when creating a new scene and importing new assets.
    We can also ignore the **Asset packages** button. This lets you select from the
    bits of assets and functionality that is provided by Unity. They are free for
    you to use in your projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Create Project** button, and Unity will create a brand-new project
    for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the windows of the Unity Editor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Hello World](img/4691OT_01_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The default layout of Unity contains a decent spread of windows that are needed
    to create a game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting from the left-hand side, **Hierarchy** contains a list of all the objects
    that currently exist in our scene. They are organized alphabetically and are grouped
    under parent objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next to this is the **Scene** view. This window allows us to edit and arrange
    objects in the 3D space. In the top left-hand side, there are two groups of buttons.
    These affect how you can interact with the **Scene** view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The button on the far left that looks like a hand lets you pan around when you
    click and drag with the mouse.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next button, the crossed arrows, lets you move objects around. Its behavior
    and the gizmo it provides will be familiar if you have made use of any modeling
    programs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third button changes the gizmo to rotation. It allows you to rotate objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth button is for scale. It changes the gizmo as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth button lets you adjust the position and the scale based on the bounding
    box of the object and its orientation relative to how you are viewing it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second to last button toggles between **Pivot** and **Center**. This will
    change the position of the gizmo used by the last three buttons to be either at
    the pivot point of the selected object, or at the average position point of all
    the selected objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last button toggles between **Local** and **Global**. This changes whether
    the gizmo is orientated parallel with the world origin or rotated with the selected
    object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the **Scene** view is the **Game** view. This is what is currently
    being rendered by any cameras in the scene. This is what the player will see when
    playing the game and is used for testing your game. There are three buttons that
    control the playback of the **Game** view in the upper-middle section of the window.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is the **Play** button. It toggles the running of the game. If you
    want to test your game, press this button.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the **Pause** button. While playing, pressing this button will
    pause the whole game, allowing you to take a look at the game's current state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third is the **Step** button. When paused, this button will let you progress
    through your game one frame at a time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On the right-hand side is the **Inspector** window. This displays information
    about any object that is currently selected.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the bottom left-hand side is the **Project** window. This displays all of
    the assets that are currently stored in the project.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Behind this is **Console**. It will display debug messages, compile errors,
    warnings, and runtime errors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the top, underneath **Help**, is an option called **Manage License...**.
    By selecting this, we are given options to control the license. The button descriptions
    cover what they do pretty well, so we will not cover them in more detail at this
    point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we need to do is connect our optional code editor. At the top,
    go to **Edit** and then click on **Preferences...**, which will open the following
    window:![Hello World](img/4691OT_01_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By selecting **External Tools** on the left-hand side, we can select other software
    to manage asset editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you do not want to use MonoDevelop, select the drop-down list to the right
    of **External Script Editor** and navigate to the executable of **Notepad++**,
    or any other code editor of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your **Image application** option can also be changed here to **Adobe Photoshop**
    or any other image-editing program that you prefer, in the same way as the script
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you installed the Android SDK to the default location, do not worry about
    it. Otherwise, click on **Browse...** and find the `android-sdk` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, for the actual creation of this application, right-click inside your **Project**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the new window that pops up, select **Create** and **C# Script** from the
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in a name for the new script (`HelloWorld` will work well) and hit *Enter*
    twice: once to confirm the name and once to open it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this is the first chapter, this will be a simple Hello World application.
    Unity supports C#, JavaScript, and Boo as scripting languages. For consistency,
    this book will be using C#. If you, instead, wish to use JavaScript for your scripts,
    copies of all of the projects can be found with the other resources for this book,
    under a `_JS` suffix for JavaScript.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every script that is going to attach to an object extends the functionality
    of the `MonoBehaviour` class. JavaScript does this automatically, but C# scripts
    must define it explicitly. However, as you can see from the default code in the
    script, we do not have to worry about setting this up initially; it is done automatically.
    Extending the `MonoBehaviour` class lets our scripts access various values of
    the game object, such as the position, and lets the system automatically call
    certain functions during specific events in the game, such as the Update cycle
    and the GUI rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, we will delete the `Start` and `Update` functions that Unity insists
    on including in every new script. Replace them with a bit of code that simply
    renders the words **Hello World** in the top-left corner of the screen; you can
    now close the script and return to Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Drag the `HelloWorld` script from the **Project** window and drop it on the
    **Main Camera** object in the **Hierarchy** window. Congratulations! You have
    just added your first bit of functionality to an object in Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you select **Main Camera** in **Hierarchy**, then **Inspector** will display
    all of the components attached to it. At the bottom of the list is your brand-new
    `HelloWorld` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can test it, we need to save the scene. To do this, go to **File**
    at the top and select **Save Scene**. Give it the name `HelloWorld` and hit **Save**.
    A new icon will appear in your **Project** window, indicating that you have saved
    the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now free to hit the **Play** button in the upper-middle section of the
    editor and witness the magic of Hello World.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now get to build the application. At the top, select **File** and then click
    on **Build Settings...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the target platform is **PC**. Under **Platform**, select **Android**
    and hit **Switch Platform** in the bottom-left corner of the **Build Settings**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **Scenes In Build** box, there is a button labeled **Add Current**.
    Click on it to add our currently opened scene to the build. Only scenes that are
    in this list and checked will be added to the final build of your game. The scene
    with the number zero next to it will be the first scene that is loaded when the
    game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one last group of things to change before we can hit the **Build**
    button. Select **Player Settings...** at the bottom of the **Build Settings**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Inspector** window will open **Player Settings** (shown in the following
    screenshot) for the application. From here, we can change the splash screen, icon,
    screen orientation, and a handful of other technical options:![Hello World](img/4691OT_01_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, there are only a few options that we care about. At the top,
    **Company Name** is the name that will appear under the information about the
    application. **Product Name** is the name that will appear underneath the icon
    on your Android device. You can largely set these to anything you want, but they
    do need to be set immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The important setting is **Bundle Identifier**, underneath **Other Settings**
    and **Identification**. This is the unique identifier that singles out your application
    from all other applications on the device. The format is `com.CompanyName.ProductName`,
    and it is a good practice to use the same company name across all of your products.
    For this book, we will be using `com.TomPacktAndBegin.Ch1.HelloWorld` for **Bundle
    Identifier** and opt to use an extra dot (period) for the organization.![Hello
    World](img/4691OT_01_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **File** and then click on **Save** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can hit the **Build** button in the **Build Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a location to save the file, and a file name ( `Ch1_HelloWorld.apk` works
    well). Be sure to remember where it is and hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If during the build process Unity complains about where the Android SDK is,
    select the `android-sdk` folder inside the location where it was installed. The
    default would be `C:\Program Files\Android\android-sdk` for a 32-bit Windows system
    and `C:\Program Files (x86)\Android\android-sdk` for a 64-bit Windows system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once loading is done, which should not be very long, your APK will have been
    made and we are ready to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are through with Unity for this chapter. You can close it down and open a
    command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just as we did when we were connecting our devices, we need to navigate to
    the `platform-tools` folder in order to connect to our device. If you installed
    the SDK to the default location, use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a 32-bit Windows system:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'For a 64-bit Windows system:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Double-check to make sure that the device is connected and recognized by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will install the application. This command tells the system to install
    an application on the connected device. The `-r` indicates that it should override
    if an application is found with the same **Bundle Identifier** as the application
    we are trying to install. This way you can just update your game as you develop,
    rather than uninstalling before installing the new version each time you need
    to make an update. The path to the `.apk` file that you wish to install is shown
    in quotes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adb install -r "c:\users\tom\desktop\packt\book\ch1_helloworld.apk"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Replace it with the path to your APK file; capital letters do not matter, but
    be sure to have all the correct spacing and punctuations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all goes well, the console will display an upload speed when it has finished
    pushing your application to the device and a success message when it has finished
    the installation. The most common causes for errors at this stage are not being
    in the `platform-tools` folder when issuing commands and not having the correct
    path to the `.apk` file, surrounded by quotes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have received your success message, find the application on your phone
    and start it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, gaze in wonder at your ability to create Android applications with the
    power of Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created our very first Unity and Android application. Admittedly, it
    was just a simple Hello World application, but that is how it always starts. This
    served very well for double-checking the device connection and for learning about
    the build process without all the clutter from a game.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a further challenge, try changing the icon for the application.
    It is a fairly simple procedure that you will undoubtedly want to perform as your
    game develops. How to do this was mentioned earlier in this section, but, as a
    reminder, take a look at **Player Settings**. Also, you will need to import an
    image. Take a look under **Assets**, in the menu bar, to know how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There were a lot of technical things in this chapter. First, we discussed the
    benefits and possibilities when using Unity and Android. That was followed by
    a whole lot of installation; the JDK, the Android SDK, Unity 3D, and Unity Remote.
    We then figured out how to connect to our devices through the command prompt.
    Our first application was quick and simple to make. We built it and put it on
    a device.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a game, Tic-tac-toe, that is significantly
    more interactive. We will explore the wonderful world of graphical user interfaces.
    So not only will we make the game, but we will make it look good too.
  prefs: []
  type: TYPE_NORMAL
