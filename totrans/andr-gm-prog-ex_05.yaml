- en: Chapter 5. Platformer – Upgrading the Game Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the second project of this book. Here, we will build a really tough
    retro platform game. It is not tough to build, but tough to beat when you play
    it. At the end of the project, we will also discuss ways to make the game play
    a little less punishing should you wish.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus entirely on our game engine and essentially lead to
    an upgraded version of the Tappy Defender code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will discuss what we want to achieve with this game: the backstory,
    game mechanics, and rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will quickly create an activity that instantiates a view that will
    do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will flesh out the basic structure of our `PlatformView` class,
    which will have some subtle, but important differences to our `TDView` class.
    Most notably, `PlatformView` will have a simple but effective way of managing
    the timing of all the events of our game.
  prefs: []
  type: TYPE_NORMAL
- en: We will then start the iterative process of building our `GameObject` class,
    from which almost every entity of the game world will be derived.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the concept of a viewport through which the game world
    is viewed by the player. We will no longer be designing our game objects to operate
    at the level of the screen resolution, but they will now exist in a world with
    their own *x* and *y* coordinates that we can think of as virtual meters. There
    is also a simple system of depth on the *z* axis as well. This will be handled
    by our new `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will look at how we design and layout the content of our game.
    This is done via a class that is used as a level designer and can be used in a
    nonprogrammatic way to map out the jumps, enemies, rewards, and goals that constitute
    the layout of a level.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the level designs and load them into our game engine, we will need
    another class. We will call it `LevelManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally in this chapter, we will look at our enhanced `update` and `draw` methods
    within the `PlatformView` class so that we can actually run our new game and see
    the first output on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With so much to do, we better get started.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game we will build is based on the game play of some of the brutally hard
    platform games of the '80s, such as Bounty Bob Strikes Back and Impossible Mission.
    These games featured difficult jumps and required insanely precise timing at the
    same time as giving the player an unforgiving number of lives/chances. This style
    of game works well for us because we can actually build a multilevel playable
    game in just four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the classes will make it really easy for you to add your own extra
    features, and game objects or make it slightly less challenging to play should
    you want to.
  prefs: []
  type: TYPE_NORMAL
- en: The backstory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our hero Bob, having just returned from a secret mission to destroy an evil
    scientist at the center of the Earth, finds he is deep underground. Worse, it
    seems that although he has defeated the evil scientist, it was not in time to
    save the planet from the powerful guards and deadly flying robot drones that he
    unleashed.
  prefs: []
  type: TYPE_NORMAL
- en: Bob must make his way from the deep underground fiery cave, through the heavily
    guarded city, and forest, high in the mountains, where he hopes to live, free
    from the terrifying new order that has taken over the planet.
  prefs: []
  type: TYPE_NORMAL
- en: On his journey through these four levels, he must avoid guards, destroy drones,
    collect lots of money, and upgrade his initially puny machine gun.
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game will be about executing precise jumps, planning the best route through
    a level to collect the loot and escape. Bob will be able to stand precariously
    on ledges with whole pixels of his feet overhanging, to be able to make seemingly
    impossible jumps. Bob will be able to control the distance he travels while jumping,
    meaning that sometimes he will often need to make sure he doesn't over jump.
  prefs: []
  type: TYPE_NORMAL
- en: Bob will need to collect machine gun upgrades before attempting to escape via
    heavily guarded areas.
  prefs: []
  type: TYPE_NORMAL
- en: Bob will only have three lives, but may be able to find some more on his journey.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Bob loses a life by being caught by a drone/guard, touching fire, or falling
    out of the game world, he will respawn at the start of the current level. Drones
    can fly, and will home in on Bob as soon as he comes into view. Bob will need
    to make sure he has enough firepower to handle the drones. Guards will patrol
    predetermined parts of the level, but they are tough and can only be knocked back
    by Bob's machine gun. Usually, Bob will need to execute a precisely timed jump
    to progress past a guard.
  prefs: []
  type: TYPE_NORMAL
- en: The environment will also be tough. Bob will need to completely master each
    level, as one wrong jump will send him plummeting back to the start, straight
    into the clutches of an enemy or even to his fiery death.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the talk of guards, drones, fire, collectibles, guns, and the implied much
    larger game world suggests a much more complex system to manage. One of the goals
    of our game engine will be to make this complexity easily manageable. The other
    goal will be to separate the level design from the coding. When our game is done,
    you will be able to sit back and design the most evil, yet rewarding levels, in
    multiple different environments without touching the code.
  prefs: []
  type: TYPE_NORMAL
- en: The platform activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we start off with our `Activity` class, which is the entry point into
    our game. There is not much new here, so let's go ahead and get it built quickly.
    Create a new project, and in the **Application Name** field, enter `C5 Platform
    Game`. Choose **Phones and tablets**, then **Blank Activity** when prompted. In
    the **Activity Name** field, type `PlatformActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously you don't have to follow my exact naming choices, but just remember
    to make minor alterations in the code to reflect your own naming choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can delete `activity_platform.xml` from the `layout` folder. You can also
    delete all the code within the `PlatformActivity.java` file. Just leave the package
    declaration. Now, we have an entirely blank canvas ready for us to start coding.
    Here is the entirety of our project so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's start building our engine. Just like in our Tappy Defender project, we
    will build a class to handle the view aspect of our game. Perhaps unsurprisingly,
    we will call the class `PlatformView`. Therefore, our `PlatformActivity` class
    needs to instantiate a `PlatformView` object and set it as the main view of the
    app, just like in the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: We will be making some significant upgrades to our engine, but this will mainly
    happen in the view. In the code for the `PlatformActivity` class that we will
    look at next, we do much the same as in the previous project. First, declare the
    `PlatformView` object and set it as the main view in the overridden `onCreate`
    method; however, before we do this, we also capture and pass in the resolution
    of the device's screen.
  prefs: []
  type: TYPE_NORMAL
- en: We do this using the `Display` class and chaining the `getWindowManager()` and
    `getDefaultDisplay()` methods to get the properties of the physical display hardware
    that our game will be running on. Then, we create an object of type `Point` called
    resolution and store the resolution of the display into our `Point` object by
    calling `display.getSize(size)`.
  prefs: []
  type: TYPE_NORMAL
- en: This stores the horizontal and vertical number of pixels of the screen into
    `size.x` and `size.y`, respectively. We can then go ahead and instantiate a new
    `PlatformView` object by calling its constructor and passing in the values stored
    in `size.x` and `size.y`. As before, we also pass in the application, `Context`
    object (`this`) that like in the previous project, we will find many uses for.
  prefs: []
  type: TYPE_NORMAL
- en: We can then set `platformView` as the view by calling `setContentView()` in
    the usual way. As earlier, we override the `Activity` class's lifecycle methods
    `onPause()` and `onResume()` to have them call their respective methods in our
    soon-to-be-written `PlatformView` class. These two methods can then start and
    stop our `Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the entirety of the code for the `PlatformActivity` class that we have
    just discussed, with no significant new aspects. Type or copy and paste the code
    into your project. The code for this chapter can be found within the download
    bundle from the book's page on the Packt Publishing website. All the code and
    assets from this chapter can be found in the `Chapter5` folder. This file is called
    `PlatformActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to import all the new classes when prompted to do so, or by pressing
    the *Alt* | *Enter* keyboard combination while hovering the cursor over the error
    when a missing class causes this error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, until we create our `PlatformView` class, there will be errors in
    our `PlatformActivity` class's code.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the layout to landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we did for the last project, we will make sure the game runs in the
    landscape mode only. We will make our `AndroidManifest.xml` file force our `PlatformActivity`
    class to run with a full screen, and we will also lock it to a landscape layout.
    Let''s make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Immediately after it, type or copy and paste these two lines to make `PlatformActivity`
    run full screen and lock it in the landscape orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can move on to the real guts of our game and see how we can implement
    all these improvements we talked about.
  prefs: []
  type: TYPE_NORMAL
- en: The PlatformView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class, by the time it is completed, will be dependent on many other classes.
    I don't want to just present each class in turn, as this would be quite hard to
    follow and exactly what code implements which feature will become confusing. Instead,
    we will look at, and code, each feature in turn, as we require them, and then
    revisit many of the classes multiple times to add more features. This will keep
    the focus on the specific purpose of each part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Having said this, great care has been taken so that although we will revisit
    many of these classes multiple times, we won't be constantly deleting code, just
    adding to it. When we add to it, the code will be presented in its proper context
    with the new parts highlighted among the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to the structure of the classes, they are designed to be as minimal
    as possible, while at the same time, not restricting your potential to easily
    add features and extend the code.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a lesson in game engine design, but more a lesson in seeing how
    many different features we can learn to implement and cram into four chapters,
    without the code becoming unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to build very large-scale games, especially when working as a team,
    then a more robust design will be necessary. This more robust design will also
    mean a whole lot of extra classes, interfaces, packages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this type of discussion interests you, I highly recommend the book, *Beginning
    Android Games* by Mario Zechner, published by APRESS. Mario is the founder/creator
    of the LibGDX cross-platform game library, and his book goes into great detail
    about the design patterns required to build a highly extensible and reusable code
    base for games. The only downside to the great design detail that this book has,
    is that it would take around 600 pages to build a simple retro Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create the class. Right-click on the package name in the Android
    Studio project explorer and navigate to **New** | **Java Class**. Call the new
    class `PlatformView`. Delete the autogenerated contents of the class, as we will
    add our own code soon.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to add code to this class over the entirety of the project.
    The full extent of the code that we add to the class in this chapter can be found
    in the download bundle at `Chapter5/PlatformView.java`.
  prefs: []
  type: TYPE_NORMAL
- en: We need a class that can manage our level. Let's call it `LevelManager`.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a class that can hold the data for our level, as we can then extend
    it each time we create a new/different level design. Let's call the parent class
    `LevelData`, and our first real level for Bob to escape from, `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as this game is going to have many enemies, props, and terrain
    types, we are going to need a cleaner system of managing them all. We need a fairly
    generic `GameObject` class, which all the different game objects can extend. We
    can then manage them really easily in our `update` and `draw` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will also, as a matter of necessity, build a slightly more complicated method
    of detecting the players input. We will create an `InputController` class to delegate
    all of the code from `PlatformView`. However, the details of this class we will
    not see, until we have fully fleshed out our `Player` object to represent the
    player in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can quickly code our basic `PlatformView` class with very similar code to
    the first project, but with a few notable exceptions that we will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of PlatformView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are the necessary imports and our member variables to get us started. We
    will add to these a fair bit as the project continues.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also declare three new object types, `lm` that will be our `LevelManager`
    class, `vp` that will be our `Viewport` class, and `ic` that is our `InputController`
    class. We will begin working on some of these in this chapter. These declarations
    will of course show an error until we implement their respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have our `PlatformView` constructor. At this stage, it does nothing
    new, in fact, it has less code than our `TDView` constructor but it will soon
    be enhanced. For now, enter the code as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our thread''s `run` method. Note that before the call to `update()`,
    we get the current time in milliseconds and put it in the `startFrameTime` long
    variable. Then after `draw()` has completed, we make another call to get the system
    time and measure how many milliseconds have elapsed since the frame started. We
    then carry out the calculation `fps = 1000 / thisFrameTime`, which gives us the
    number of frames per second our game ran at, in that last frame. This value is
    stored in the `fps` variable. We will be using this all over the place as we proceed
    with the game. Code the `run` method that we have just discussed, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in the chapter, we will see how we manage the extra complexity of multiple
    object types and update them when necessary. For now, just add an empty `update`
    method to the `PlatformView` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the familiar parts of our `draw` method. Later in this chapter,
    we will see some of the new code. For now, add the basics of the `draw` method
    as shown next as this will remain unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last parts of the first phase of putting together our view is the `pause`
    and `resume` methods, which are called by `PlatformActivity` when the corresponding
    Activity lifecycle methods are called by the operating system. They are unchanged
    from the previous project, but here they are again for the sake of completeness
    and being able to follow along easily. Add these methods to the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the basic outline of our view coded and ready. Let's take our first
    look at the `GameObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that we need a parent class to hold the vast majority of our game objects
    as we want to improve on the inflexibility and code duplication of the last project.
    From the previous project, we also know many of the properties and methods it
    will require.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a simple class to represent the world location of all our future
    `GameObject` classes. This class will hold a detailed location on both the *x*
    and *y* axis. Note that these are totally independent to the coordinates of the
    pixels of the device on which our game will run. We can think of the *z* coordinate
    as a layer number. The lower numbers get drawn first. Therefore, create a new
    Java class, call it `Vector2Point5D`, and enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's have a look at, and code the basic working outline of, the `GameObject`
    class, and then throughout the project, we can come back and add extra features.
    Create a new Java class and call it `GameObject`. Let's look at the code we need
    to start to make this class useful. First, we import the classes we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we code `GameObject` itself, note that the class does not provide a constructor
    as this will be handled differently, depending on the specific `GameObject` that
    we are implementing.
  prefs: []
  type: TYPE_NORMAL
- en: The first variable you will notice in the code is `worldLocation`, which, as
    you may expect, is of type `Vector2Point5D`. We then have two float members, which
    will hold the width and height of the `GameObject` class. Next up, we have the
    Boolean variables `active` and `visible` which will be used, perhaps to label
    an object when it is active, visible, or otherwise. We will begin to see later
    in the chapter how this is of benefit.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to know how many frames of internal animation any given object
    has. The default will be `1`, so `animFrameCount` is initialized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have a `char` class called `type`. This `type` variable will determine
    exactly what any particular `GameObject` might be. It will be used extensively.
    The last member variable for now is `bitmapName`. We will see that it will become
    useful to know the name of the graphic, which represents the appearance of each
    of our individual objects. Add the member variables we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can look at the first part of the functionality of `GameObject`. We
    have the abstract method `update()`. The plan was that all objects will need to
    update themselves. Turns out that this was over ambitious in just four chapters,
    and some of our objects (mainly the platforms and scenery) will just provide an
    empty `update()` implementation. However, there is nothing to stop you making
    the scenery more interactive than we have time for now, or make the platforms
    more dynamic and adventurous once we see how things work. Add the abstract `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We handle our methods that manage our graphics. We have a getter to retrieve
    `bitmapName`. Then, we have `prepareBitmap()`, which uses the string `bitmapName`
    to make an Android resource ID from a `.png` image file. This file must be present
    in the `drawable` folder of the project. A bitmap is created as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Now our `prepareBitmap` method does something new. It uses the `createScaledBitmap`
    method to change the size of the bitmap we just created. It not only uses the
    `animFrameCount`, which we already discussed, but also the `pixelsPerMetre` variable,
    which is a parameter of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea being, that each device has a `pixelsPerMetre` value that is appropriate
    for the device, which will help us create an identical view of the game across
    devices with different resolutions. We will see exactly where we get this `pixelsPerMetre`
    value from, when we discuss the `Viewport` class. Enter the following methods
    in the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also want to be able to know where in the world each `GameObject` is and,
    of course, to set where in the world it is. Here are a getter and a setter, which
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We also want to be able to both, get and set many of the member variables we
    have already discussed. These getters and setters will do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we will want to check and change the status of our active and visible
    variables as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Set and get `type` of each `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create our first of many child classes from `GameObject`. Right-click
    on the package name in the Android Studio explorer and create a class called `Grass`.
    This will be our first basic tile type that the player can walk about on.
  prefs: []
  type: TYPE_NORMAL
- en: This straightforward code uses the constructor to initialize height, width,
    type, and its location in the game world. Note that all this information is passed
    in as parameters to the constructor. The only thing the `Grass` class "knows",
    and one of the few things that will differentiate it from some of the other simple
    `GameObject` child classes, is the value used for `bitmapName`, which in this
    case is `turf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously, we also provide an empty implementation of the `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, add the `turf.png` graphic from the `Chapter5/drawable` folder in the download
    bundle to the `drawable` folder in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will do an absolute barebones implementation of our `Player` class
    that will also extend `GameObject`. We will not be putting any functionality into
    this class just an *x* and *y* world location. This is so that the `Viewport`
    class, which we will implement next, knows where to focus.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the `Player` class, which will represent Bob our hero. The class at
    this stage is as simple and straightforward as, and nearly identical to the `Grass`
    class. This will change and evolve substantially as we progress. Note that we
    set the type to `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Add the `player.png` graphic from the `drawable` folder in the download bundle
    to the `drawable` folder in Android Studio. The graphic is a multiframe sprite
    sheet, so it won't display nicely until we animate it in [Chapter 6](ch06.html
    "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob, Beeps, and
    Bumps* , but it will serve its purpose as a placeholder for now.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see next, the view of the game world that the player sees, will focus
    on Bob, as you will probably expect.
  prefs: []
  type: TYPE_NORMAL
- en: The view through a viewport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A viewport can be thought of as the movie camera that follows the action of
    our game. It defines the area of the game world that is to be shown to the player.
    Typically, it will center on Bob.
  prefs: []
  type: TYPE_NORMAL
- en: It also serves the combined function of making our draw method more efficient
    by determining which objects are inside and outside the player's field of vision.
    There is no point drawing or processing a bunch of enemies, if they are not relevant
    at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: This will significantly speed up tasks like collision detection by implementing
    a first phase of detection by removing objects off screen from the list of objects
    to check for collisions, and it is surprisingly simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our `Viewport` class will have the task of translating game world
    coordinates into appropriate pixel coordinates for drawing on the screen. We will
    also see how this class calculates the `pixelsPerMetre` value that our `GameObject`
    class used in the `prepareBitmap` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Viewport` class really is an all singing and dancing thing. So let's get
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will declare a whole bunch of useful variables. We have another `Vector2Point5D`,
    which will just be used to represent whatever point in the world is currently
    the central focus in the viewport. Then, we have separate integer values for `pixelsPerMetreX`
    and `pixelsPerMetreY`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, in this implementation, there is no distinction between `pixelsPerMetrX`
    and `pixelsPerMetreY`. However, the `Viewport` class can be upgraded to take into
    account different ratios of width to height of the device, based on screen size,
    rather than just resolution. We don't do so in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply have the resolution of the screen in both axes: `screenXResolution`
    and `screenYResolution`. We then have `screenCentreX` and `screenCentreY`, which
    are basically the two previous variables divided by two to find the middle.'
  prefs: []
  type: TYPE_NORMAL
- en: In our list of declared variables, we have `metresToShowX` and `metresToShowY`
    that will be the number of meters we will squash into our viewport. Changing these
    values will show more or less of the game world on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The last member, we will declare at this point, is the `int numClipped`. This
    we will use to output debugging text to see what effect our `Viewport` class is
    having with regard to making drawing, updates, and multiphase collision detection,
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Viewport` and declare the variables we have just
    discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the constructor. The constructor just needs to know the resolution
    of the screen. This is obtained in parameters *x* and *y*, which, of course, we
    assign to `screenXResolution` and `screenYResolution`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Then, as previously suggested, we divide those two previous variables by two
    and assign the results to `screenCentreX` and `screenCentreY`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `pixelsPerMetreX` and `pixelsPerMetreY` are calculated by dividing by 32
    and 18 (again, respectively), so a device with a resolution of 840 x 400 pixels
    will have pixels per meter *x/y* of 32/22\. Now, we have variables that refer
    to the number of pixels of screen real estate on the current device that represents
    a meter of our game world. We will see a number of times in our code, where this
    will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: We will actually draw a slightly wider area than this, to make sure we don't
    have any unsightly gaps/lines around the edge of the screen and assign 34 to `metresToShowX`
    and 20 to `metresToShowY`. Now, we have variables that refer to the amount of
    our game world that we will draw each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have some screen output, you can experiment with these values to create
    a more or less zoomed-in or zoomed-out experience for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Nearing the end of the constructor, we create a new `Rect` object called `convertedRect`
    that we will see in action soon. We call `new()` on `currentViewportWorldCentre`,
    so it is ready for action shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If some of the screenshots throughout this project look slightly different to
    the results you get, it is because some images have been taken using different
    viewport settings to highlight different aspects of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The first method we write for the `Viewport` class is `setWorldCentre()`. It
    receives an *x* and a *y* parameter, which is promptly assigned as the `currentWorldCentre`.
    We need this method because of course the player will be moving around in the
    world, and we need to let the `Viewport` class know where Bob is. Also, as we
    will see in [Chapter 8](ch08.html "Chapter 8. Platformer – Putting It All Together"),
    *Putting It All together*, we will also have a situation where we don't want Bob
    as the center of attention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, a few simple getters and setters that will be useful to us as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We fulfil one of the primary roles of the `Viewport` class with the `worldToScreen()`
    method. As the name suggests, this is the method that converts the locations of
    all the objects currently in the visible viewport from world coordinates to pixel
    coordinates that can actually be drawn to the screen. It returns our previously
    prepared `rectToDraw` object as the result.
  prefs: []
  type: TYPE_NORMAL
- en: This is how `worldToScreen()` works. It receives the *x* and *y* world locations
    of an object along with that object's width and height. With these values, each
    in turn, subtracts the objects world coordinate multiplied by the pixels per meter
    for the current screen, from the appropriate current world viewport center (*x*
    or *y*). Then, for the left and top coordinates of the object, the result is subtracted
    from the pixel screen center value and for the bottom and right coordinates, it
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values are then packed into the left, top, right, and bottom values of
    `convertedRect` and returned to the `draw` method of `PlatformView`. Add the `worldToScreen`
    method to the `Viewport` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we implement the second primary function of the `Viewport` class, removing
    objects that are currently of no interest to us. We call this clipping, and the
    method we will call; `clipObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we receive as parameters the `x`, `y`, `width`, and `height` of
    an object. The test starts by assuming that we want to clip the current object
    and we assign `true` to clipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the four nested `if` statements test whether each and every point of
    the object is within the bounds of the related side of the viewport. If it is,
    we set `clipped` to `false`. Some of the levels we will design have in excess
    of a thousand objects, but we will see that we rarely need to process (update,
    collision detection, and draw) more than a quarter of them in any given frame.
    Enter the code for the `clipObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we provide access to the `numClipped` variable so that it can be read and
    reset to zero each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare and initialize our `Viewport` object. Add this code right after
    we initialize our `Paint` object in the `PlatformView` constructor. The new code
    is shown highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can now describe and position objects in our game world and focus on the
    precise parts of the world we are interested in. Let's see how we will actually
    get our objects into that world, so we can then update and draw them as we have
    done before. We will also look at the concept of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will see how to build our `LevelManager`, `LevelData`, and our first
    real level, `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LevelManager` class will eventually need a copy of our `InputController`
    class. Therefore, in order to try and keep to our intentions of not having to
    delete any code, we will include a parameter for `InputController` in our `LevelManager`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly create a blank template for our `InputController` class. Create
    a new class in the usual way and call it `InputController`. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at our, initially, very simple `LevelData` class. Create a new
    class, call it `LevelData`, and add this code. At this stage, it holds just an
    `ArrayList` object for `Strings`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can start on what will eventually become our first playable level.
    Create a new class, call it `LevelCave`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The position of `p` for player in the `LevelCave` file is arbitrary. As long
    as it is on there, the `Player` object will be initialized. The actual spawn location
    of the player character is determined by the call to a `loadLevel` method, as
    we will soon see. I usually put the `p` for player as the first element on the
    first line of the map, then it is less likely to be forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about how this level design is going to work. We will enter
    alpha-numeric characters in the `LevelCave` class within the `tiles.add("..."`
    parts of the code. We will enter a different alpha-numeric character depending
    on which `GameObject` we want to place into the level. At the moment, we just
    have `p` to represent the `Player` object, a `1` to represent a `Grass` object,
    and a period (`.`) to represent an empty space of one game world meter square.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This implies that the positioning of the `Grass` objects with the `1` character
    in the previous block of code can be arranged exactly how you like. This is the
    case, and whenever we look at the code for our `LevelCave` class please feel free
    to improvise and experiment as you like.
  prefs: []
  type: TYPE_NORMAL
- en: As the project continues, we will add more than twenty different `GameObject`
    child classes. Some will be inanimate like `Grass`, others will be thinking, aggressive
    enemies. All will be placeable within our level design.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can implement the class to manage our levels. Create a new Java class
    and call it `LevelManager`. Enter the code for the `LevelManager` class as we
    go through, and discuss it a block at a time.
  prefs: []
  type: TYPE_NORMAL
- en: First, a few import directives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, the constructor is where we have a `String` `level` to hold the name of
    the level, `mapWidth` and `mapHeight` to store the width and height in game world
    meters of the current level, a `Player` object because we know we will always
    have one of them, and an `int` type called `playerIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will have an `ArrayList` object of many `GameObject` classes, and it
    will be handy to always have the index of the `Player` object.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we have the Boolean `playing` because we will need to know when the
    game is being played or being paused and a float called `gravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of this project, gravity will not be used to its full potential,
    but it can easily be manipulated so that different levels have a different gravity.
    This is why it is in the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare an object of type `LevelData`, an `ArrayList` object to
    hold all our `GameObject` objects, an `ArrayList` object to hold representations
    of the players control buttons and a regular array to hold the majority of all
    the `Bitmap` objects we will need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the constructor, we examine the signature and see that it receives
    a `Context` object, `pixelsPerMetre` that will have been determined when the `Viewport`
    class was constructed, `screenWidth` again direct from the `Viewport` class, a
    copy of our `InputController` class, and then the name of the level to load. The
    `int` parameters, `px` and `py`, are the starting coordinates for the player.
  prefs: []
  type: TYPE_NORMAL
- en: We assign the level parameter to our member level, then we switch to determine
    which class will be our current level. Of course, at the moment, we only have
    `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we initialize our `gameObject ArrayList` and our `bitmapsArray`. We then
    call `loadMapData()`, which is a method we will write shortly. After this, we
    set `playing` to `true`, and finally we have a getter method to find out what
    the state of `playing` is. Enter the code we have just discussed in the `LevelManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a really simple method which will enable us to get any `Bitmap`
    object based on the type of `GameObject` we are currently dealing with. This way,
    each `GameObject` does not have to hold its own `Bitmap` object. For example,
    we can design a level with hundreds of `Grass` objects. This can easily use up
    the memory of even a modern tablet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getBitmap` method takes an `int` value as an index and returns a `Bitmap`
    object. We will see how we access the appropriate value for `index` in the next
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This next method will enable us to get the `index` with which to call the `getBitmap`
    method. As long as the `char` cases correspond with the `type` values held by
    the various `GameObject` child classes we create, and the index returned by this
    method matches the index of the appropriate `Bitmap` held in the `bitmapsArray`,
    we will only ever need one copy of each `Bitmap` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, we do the real work with the `LevelManager` class, and load our level from
    our design. The method needs the `pixelsPerMetre` and the `Player` objects coordinates
    in order to do its work. As this is a large method, the explanations and the code
    have been split into a few sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this first part, we simply declare an `int` type called `index` and set it
    to `-1`. As we loop through our level design, it will help us keep track of where
    we are up to.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculate the height and width of the map using the size of `ArrayList`
    and the length of the first element of `ArrayList`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We enter a nested `for` loop starting with the first element of the first string
    in our `ArrayList` object. We work from left to right across the first string
    before moving on to the second string.
  prefs: []
  type: TYPE_NORMAL
- en: We check to see if an object other than an empty space (.) is present at the
    current location, and if it is, we enter a switch block to create the appropriate
    object at the designated location.
  prefs: []
  type: TYPE_NORMAL
- en: If we encounter a `1`, then we add a new `Grass` object to `ArrayList`, and
    if we encounter a `p`, we initialize the `Player` object at the location passed
    in to the constructor of this `LevelManager` class. When a new `Player` object
    is created, we also initialize our `playerIndex` and `player` object ready for
    future use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If a new object has been added to `gameObjects ArrayList`, we need to check
    if the corresponding bitmap has been added to the `bitmapsArray`. If it hasn''t,
    we add one using the `prepareBitmap` method of the current `GameObject` class
    under consideration. Here is the code to perform this check and prepare the bitmap,
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `PlatformView` class, to put all our level objects to use, we call
    `loadLevel()` just after where we initialized our `Viewport` class in the `PlatformView`
    constructor. The new code has been highlighted, and the existing code is provided
    for context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Of course, now we need to implement the `loadLevel` method within the `PlatformView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadLevel` method needs to know which level to load, so the `switch` statement
    in the `LevelManager` constructor can do its work, and it also needs the coordinates
    to spawn our hero Bob.
  prefs: []
  type: TYPE_NORMAL
- en: We initialize our `LevelManager` object by calling its constructor with the
    viewport data retrieved from `vp` and the level/player data we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `InputController` class, again passing in some data from
    `vp`. We will see exactly what we do with this data when we build our `InputController`
    class in [Chapter 6](ch06.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"),
    *Bob, Beeps, and Bumps*. Finally, we call `vp.setWorldCentre()` and pass it in
    the player's location as the coordinates. This centers the screen on Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can add some code to our `update` method that will be first to utilize a
    primary function of our new `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced update method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At last, we can use our handy `ArrayList` of game objects and our `Viewport`
    functionality to flesh out our enhanced `update` method. In the code that follows,
    we simply use an enhanced `for` loop to go through each `GameObject`. We check
    if it `isActive()`, and then send the object''s location and dimensions to `clipObjects()`
    wrapped in an `if` statement. If `clipObjects()` returns `false`, then the object
    is not clipped and the object is flagged as visible by calling `go.setVisible(true)`.
    Otherwise, it is flagged as not visible calling `go.setVisible(false)`. This is
    the only aspect of any object that is updated at the moment. We will see when
    we run the game, at the end of the chapter, that it is already useful. Enter the
    new code in the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The enhanced draw method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we can be more precise about which objects we need to draw. First, we declare
    and initialize a new `Rect` object called `toScreen2d`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we loop through our `gameObjects ArrayList` once for each layer starting
    with the lowest layer. This isn't strictly necessary at this stage because all
    our objects are, by default, currently on layer zero. We will add objects on layer
    -1 and 1 before the end of the project, and we don't want to have to rewrite code
    if we can help it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check if the object is visible and on the current layer. If it is,
    we pass the current object''s location and dimensions to the `worldToScreen` method,
    which returns the result to our previously prepared `toScreen2d Rect` object.
    Then, we call `drawBitmap()` using our `bitmapArray` to provide the appropriate
    bitmap, and pass in the coordinates of `toScreen2d`. Update the `draw` method
    as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, still in the `draw` method, we print debugging info to the screen, including
    the size of our `gameObjects ArrayList` compared to the number of objects that
    were clipped this frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we finish the `draw` method by the usual call to `unlockCanvasAndPost()`.
    Note that at the end of the `if(debugging)` block, we call `vp.resetNumClipped`
    to set the `numClipped` variable back to zero ready for the next frame. Add this
    code straight after the previous block of code in the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first time in this project, we can actually run our game and see some
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The enhanced draw method](img/B04322_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note in the image the precise layout of the grass from our `LevelCave` design.
    You can also see our squashed Bob sprite sheet and the fact that there are 28
    objects, but 10 of them have been clipped. As our levels get bigger, the ratio
    of clipped to unclipped will dramatically increase in favor of the vast majority
    being clipped.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of ground in this chapter, and now have a well fleshed-out
    game engine.
  prefs: []
  type: TYPE_NORMAL
- en: As we have done much of the setup work, from now on, most of the code we add
    will also have a visible (or audible) result and be much more satisfying, as we
    will be able to regularly run our game to see the improvements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add sound effects and input detection, thus bringing
    Bob to life. Then, we will see how dangerous his world can be, and will promptly
    add collision detection so that he can stand on a platform.
  prefs: []
  type: TYPE_NORMAL
