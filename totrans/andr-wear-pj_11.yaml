- en: More About Wear 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Wear 2.0 is a prominent update with plenty of new features bundled in,
    including Google Assistant, standalone applications, new watch faces, and support
    for third-party complications. In previous chapters, we explored how to write
    different kinds of Wear applications. Wear 2.0 offers more with the current market
    research and Google is working with partner companies to build a powerful ecosystem
    for Wear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, let''s understand how we can take our existing skills forward
    with the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curved layouts and more UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complications API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different navigations and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrist gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input method framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing Wear apps to the Play store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Wear 2.0, standalone applications are powerful feature of the wear ecosystem.
    How cool it will be using wear apps without your phone nearby! There are various
    scenarios in which Wear devices used to be phone dependent, for example, to receive
    new e-mail notifications, Wear needed to be connected to the phone for Internet
    services. Now, wear devices can independently connect to Wi-Fi and can sync all
    apps for new updates. The user can now complete more tasks with wear apps without
    a phone paired to it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying an app as a standalone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of a standalone application is a great feature of the wear platform.
    Wear 2.0 differentiates the standalone app through a metadata element in the Android
    manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the application tag `<application>`, the `</application>` metadata element
    is placed with `com.google.android.wearable.standalone` with the value true or
    false. The new metadata element indicates whether the wear app is a standalone
    app and doesn''t require the phone to be paired to operate. When the metadata
    element is set to true, the app a can also be available for wear devices working
    with iPhone. Generally, the watch app can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Completely independent of the phone app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semi-independent (without phone pairing, wear app will have limited functionality)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependent on the phone app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make a Wear app completely independent or semi-independent, set the value
    of the metadata to true, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, any platform, such as iPhone or Android phones without the Play store on
    them, can also use wear apps, downloading them directly from the Play store present
    in wear. By setting the value of the metadata to false, we tell Android Wear that
    this Wear app is dependent on a phone with the Play store app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Regardless of the possibility that the value is false, the watch
    application can be installed before the corresponding phone application is installed.
    In this way, if a watch application identifies that a companion phone does not
    have a necessary phone application, the watch application ought to incite the
    user to install the phone application.'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone apps storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use standard Android storage APIs to store data locally. For instance,
    you can use the SharedPreference API, SQLite, or internal storage. We have, up
    until now, explored how to integrate ORM libraries, such as Realm, into wear applications
    not simply to store away data, but to likewise share code between a wear application
    and a phone application. On the other hand, code that is specific to a shape component
    and form factor can be in a different module.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting wear app on another device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android wear apps and Android mobile apps can recognize support apps using the
    Capability API. Phone and wear apps can advertise to paired devices statically
    and dynamically. At the point when an application is on the node in a user's wear
    network, the **Capability API** enables another application to identify the correspond
    installed applications.
  prefs: []
  type: TYPE_NORMAL
- en: Advertise capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To launch an activity on a handheld device from a wearable device, use the
    `MessageAPI` class to send the request. Multiple wearables can be associated with
    the handheld Android device; the wearable application needs to determine that
    an associated node is fit to launch the activity from a handheld device application.
    To advertise the capability of the handheld application, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an XML configuration file in the `res/values/` directory of your project
    and name it `wear.xml`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a resource named `android_wear_capabilities` to `wear.xml`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the capabilities that the device provides
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: Capabilities are custom strings that you characterize and should be unique
    within your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to add a capability named `voice_transcription`
    to `wear.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the nodes with the required capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Initially, we can detect the capable nodes by calling the `CapabilityAPI.getCapability()`
    method. The following examples show how to manually retrieve the results of reachable
    nodes with the `voice_transcription` capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To detect the capable nodes as they connect to a wearable device, register
    a `CapabilityAPI.capabilityListner()` instance to `googleAPIclient`. The following
    example shows how to register the listener and retrieve the results of reachable
    nodes with the `voice_transcription` capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: On the off chance that you create a service that extends `WearableListenerService`
    to identify capability changes, you might need to override the `onConnectedNodes()`
    method to listen in to finer-grained connectivity details, for example, when a
    wearable device changes from Wi-Fi to a Bluetooth connection with the handset.
    For more data on the most proficient method to listen for important events, read
    **Data Layer Events**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the wake of recognizing the capable nodes, figure out where to send the message.
    You ought to pick a node that is in close proximity to your wearable device to
    limit message routing through numerous nodes. A nearby node is characterized as
    one that is directly associated with the device. To decide whether a node is nearby,
    call the `Node.isNearby()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and guiding the user to install a phone app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we know how to detect the wear and mobile applications using the Capability
    API. It's an opportunity to guide the user to install the corresponding application
    from the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `CapabilityApi` to check whether your phone application is installed
    on the paired phone. For more data, see the Google samples. In the event that
    your phone application isn't installed on the phone, use `PlayStoreAvailability.getPlayStoreAvailabilityOnPhone()`
    to check what sort of phone it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `PlayStoreAvailability.PLAY_STORE_ON_PHONE_AVAILABLE` is returned valid,
    it implies the phone is an Android phone with the Play store installed. Call `RemoteIntent.startRemoteActivity()`
    on the wear device to open the Play Store on the phone. Use the market URI for
    your telephone application (which might not be the same as your phone URI). For
    instance, use a market URI: `market://details?id=com.example.android.wearable.wear.finddevices`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the event that `PlayStoreAvailability.PLAY_STORE_ON_PHONE_UNAVAILABLE` is
    returned, it implies the phone is likely an iOS phone (with no Play Store accessible).
    Open the App Store on the iPhone by calling `RemoteIntent.startRemoteActivity()`
    on the wear device. You can indicate your application's iTunes URL, for instance,
    [https://itunes.apple.com/us/application/yourappname.](https://itunes.apple.com/us/application/yourappname.)
    Likewise, observe opening a URL from a watch. On an iPhone, from Android Wear,
    you can't programmatically determine whether your phone application is installed.
    As a best practice, give a mechanism to the user (for example, a button) to manually
    trigger the opening of the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `remoteIntent` API portrayed earlier, you can determine that any URL
    can be opened on the phone from a wear device and no phone application is required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting just the important information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most use cases, when we get data from the Internet, we just get the necessary
    information. Any more than that and we may encounter pointless idleness, memory
    use, and battery use.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point when a wear device is associated with a Bluetooth LE association,
    the Wear application may have the entrance to a data transfer capacity of just
    4 kilobytes for each second. Depending on wear, the accompanying steps are prescribed:'
  prefs: []
  type: TYPE_NORMAL
- en: Review your network requests and responses for additional information, that
    is for a phone application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shrink huge pictures before sending them over a network to a watch
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the tasks identified for notifications, applications can specifically use
    **Firebase Cloud Messaging** (**FCM**) in Wear applications; Google Cloud informing
    is not supported in wear 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no particular FCM APIs for wear applications; it takes after the
    comparative configuration for the mobile application notification: FCM functions
    admirably with wear and in doze mode. FCM is the recommended approach to send
    and receive notifications for wear devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure for receiving notifications from the server is that the application
    needs to send the device a unique Firebase `registration_id` to the server. The
    server can then distinguish the `FCM_REST` endpoint and can send the notification.
    An FCM message is in the JSON format and can incorporate either of the accompanying
    payloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notification payload**: Generic notification data; when a notification reaches
    Wear, the application can check the notification and users can launch the application
    that received the notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Payload**: The payload will have custom key-value sets. The payload
    will be conveyed as data to wear applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wear applications incorporate many concerns when we are developing applications
    specific to wear devices, acquiring high-bandwidth networks and reducing the picture
    quality particular to wear benchmarks. What's more, UI outlines and keeping up
    background services, and so on. Having this at the top of the priority list when
    we create applications will make them stand out in the crowd.
  prefs: []
  type: TYPE_NORMAL
- en: Complications API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complications are surely just the same old thing for watches. The internet says
    the first pocket watch with complications was revealed in the sixteenth century.
    Smart watches are the ideal place for all the components that we consider for
    complications. In Android wear, the watch face shows more data than just the time
    and date, such as a step counter, climate forecast, and so on. How these complications
    have functioned so far has had a major constraint. until now, each custom watch
    face application needed to execute its own rationale to get information to show.
    For instance, if two watch faces had a comparative component to get step counts
    and show relevant information, then it would be an exercise in futility. Android
    Wear 2.0 intends to take care of this issue with the new Complications API.
  prefs: []
  type: TYPE_NORMAL
- en: In the event of complications, a watch face communication data provider assumes
    the principle part. It incorporates logic to get the information. The watch face
    won't have immediate access to the data provider; it will get callbacks when there
    is other data with the selected complications. On the other hand, data providers
    won't know how the data will be utilized; that is up to the watch face.
  prefs: []
  type: TYPE_NORMAL
- en: 'The accompanying depiction discusses how watch faces get complications data
    from the data provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Complication data provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new complications API has immense potential; it has access to battery level,
    climate, step counts, and so on. The complication data provider, which is a service,
    extends `ComplicationProviderService`. This base class has a set of callbacks,
    keeping in mind the end goal, which is to know when a provider is chosen as a
    data source for the current watchface:'
  prefs: []
  type: TYPE_NORMAL
- en: '(`onComplicationActivated`): This callback method is called when complication
    is activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`onComplicationDeactivated`): This callback method is called when complication
    is deactivated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(`onComplicationUpdate`): This callback is called when the complication has
    updated information for the particular complication id.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ComplicationProviderService` class is an abstract class, which extends
    out to a service. A provider service must implement `onComplicationUpdate` (int,
    int and `ComplicationManager`) to respond to requests for updates from the complication
    system. The manifest declaration of this service must incorporate an intent filter
    for `ACTION_COMPLICATION_UPDATE_REQUEST`. Metadata to determine the supported
    types, refresh period, and config action, if required, ought to also be incorporated:
    (`METADATA_KEY_SUPPORTED_TYPES`, `METADATA_KEY_UPDATE_PERIOD_SECONDS`, and `METADATA_KEY_PROVIDER_CONFIG_ACTION`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest entry for the service ought to likewise incorporate an android:
    Icon attribute. The icon given there ought to be a single-color white icon that
    represents the provider. This icon will appear in the provider chooser interface,
    and may likewise be incorporated into `ComplicationProviderInfo`, given to watch
    faces to show in their configuration activities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The accompanying code demonstrates a builder pattern of `ComplicationsData`
    to a short text type to populate `ComplicationData` with the date of the next
    event and an optional icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding complications to a watch face
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Wear 2.0 conveys numerous new components to your smartwatch. Yet, one
    of the more discernible is the expansion of adaptable *complications* on the watch
    face. Complications are a two-part system; watch face engineers can plan their
    watch faces to have open slots for complications, and application developers can
    surface parts of their applications to incorporate them as complications. The
    Wear watch face app can receive complication data and enable users to select the
    data providers. Android wear provides a user interface for data source. We can
    add complications, or data from applications, to some watch faces. Your wear 2.0
    has complications that demonstrate your battery life and the date, and that's
    just the beginning. You can also include complications from some third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data and rendering complications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin receiving complication data, a watch face calls `setActiveComplications`
    in the `WatchFaceService.Engine` class with a list of watch face complication
    IDs. A watch face creates these IDs to remarkably identify slots on the watch
    face where complications can appear, and passes them to the `createProviderChooserIntent`
    method to enable the user to choose which complication ought to go in which slot.
    Complication data is conveyed by means of the `onComplicationDataUpdate` (of `WatchFaceService.Engine`)
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing users to choose data providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Wear gives a UI (through an activity) that enables users to pick providers
    for a specific complication. Watch faces can call the `createProviderChooserIntent`
    method to obtain an intent that can be used to demonstrate the chooser interface.
    This intent must be used with `startActivityForResult`. At the point when a watch
    face calls `createProviderChooserIntent`, the watch face supplies a watch face
    complication ID and a list of supported types.
  prefs: []
  type: TYPE_NORMAL
- en: User interactions with complications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers can specify an action that occurs if the user taps on a complication,
    so it should be possible for most complications to be tap-able. This action will
    be specified as `PendingIntent`, included in the `ComplicationData` object. The
    watch face is responsible for detecting taps on complications and should fire
    the pending intent when a tap occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions for complication data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Wear app must have the following permission to receive the complications
    data and open the provider chooser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Opening the provider chooser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A watch face that has not been granted the preceding permission will be unable
    to start the provider chooser. To make it easier to request the permission and
    start the chooser, the `ComplicationHelperActivity` class is available in the
    Wearable Support Library. This class should be used instead of `ProviderChooserIntent`
    to start the chooser in almost all cases. To use `ComplicationHelperActivity`,
    add it to the watch face in the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the provider chooser, call the `ComplicationHelperActivity.createProviderChooserHelperIntent`
    method to obtain an intent. The new intent can be used with either `startActivity`
    or `startActivityForResult` to launch the chooser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the helper activity is started, the helper activity checks whether the
    permission was granted. If the permission was not granted, the helper activity
    makes a runtime permission request. If the permission request is accepted (or
    is unneeded), the provider chooser is shown.
  prefs: []
  type: TYPE_NORMAL
- en: For watch face, there are many scenarios to be considered. Check all of them
    before you implement the complications in your watch face. How are you receiving
    complication data? Is it from the provider, remote server, or the rest service?
    Are the provider and watch face from the same app? You should also check for a
    lack of appropriate permissions and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding different navigation for wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android wear is evolving in every way. In wear 1.0, switching between screens
    used to be tedious and confusing to wear users. Now, Google has introduced material
    design and interactive drawers, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigation drawer**: The navigation drawer is a similar component to the
    mobile app navigation drawer. It will allow the user to switch between views.
    Users can reach to the navigation drawer on a Wear device by going to the top
    of the content area and scrolling down from the flings. We can allow the drawer
    to be opened anywhere within the scrolling parent''s content by setting the `setShouldOnlyOpenWhenAtTop()`
    method to false and we can restrict it by setting it to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single page navigation drawer**: A wear app can present the views to users
    on a single page and multiple pages. The new navigation drawer component allows
    content to be on a single page by setting `app:navigation_style to single_page`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action drawer**: There are common actions that every category of apps does.
    Action drawer provides an access to all such actions in a wear application. Usually,
    action drawer sits in the bottom area of the wear app and it will help to offer
    context-specific user actions, similar to the action bar on a phone application.
    It''s the developer''s choice to have the action drawer positioned at the bottom
    or top, and the action drawer can be triggered when a user is scrolling content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image is a quick look of the navigation drawer for wear 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example illustrates the action reply performed in the messenger
    app using action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have the newly introduced components in your app, declare your user interface
    with a `WearableDrawerLayout` object as the root view of your layout. Within `WearableDrawerLayout`,
    add one more view that implements `NestedScrollingChild` to contain the main content,
    as well as additional views to contain content for the drawer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following XML code illustrates the way in which we can bring life to `WearableDrawerLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Single-page navigation drawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single-page navigation drawer is faster and more streamlined to different
    views in the Wear app. To create a single page navigation drawer, apply the attribute
    `navigation_style="single_page"` to the drawer. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, the next major thing is to populate the data on drawer layout. We can do
    it in the XML layout with the help of the `app:using_menu` attribute in the drawer
    layout and by loading the XML file from the menu directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `WearableDrawerView`, we can design our own custom drawer layout. The
    following code illustrates the custom drawer layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are major drawer events, such as `onDrawerOpened()`, `onDrawerClosed()`,
    and `onDrawerStateChanged()`. We can create custom events as well; by default,
    we can use the earlier set of callbacks to listen to drawer activities.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications in wear 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wear 2.0 updates the visual style and interaction paradigm of notifications.
    Wear 2.0 introduces expandable notifications, which provide more content area
    and actions to give the best experience. The visual updates include material design,
    touch targets of notifications, dark background colors, and a horizontal swipe
    gesture for notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Inline action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inline action allows users to perform context-specific actions inside the notification
    stream card. If the notification is configured for inline action, it will display
    at the bottom section of notifications. Inline actions are optional; Google recommends
    it for different use cases wherein a user has to perform a certain action after
    checking the notification, for example, text message reply and stopping fitness
    activity. A notification can have only one inline action and, to enable it, we
    need to set `setHintDisplayActionInline()` to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add inline actions to notifications, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of `RemoteInput.Builder` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `addRemoteInput()` method, we can attach the `RemoteInput` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a hint to display action inline, and use add action method to
    the action to the notification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Expanded notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wear 2.0 introduces expandable notifications, which have the ability to show
    substantial content and actions for each notification. Expanded notifications
    follow the material design standards, and when we attach additional content pages
    to the notification, they are available within the expanded notifications and
    the user will have an in-app experience while checking the actions and content
    in the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for expanded notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When to use the expanded notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: The notifications from the paired phone should use expanded notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should not use expanded notifications when the app notification is running
    locally and just launches the app by clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bridging mode for notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bridging mode alludes to the system that wear and the companion application
    share the notification among themselves. The standalone application and companion
    application can get copied notifications. Android wear incorporates components
    to deal with the issue of copy notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can alter the behavior of notifications as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a bridging configuration in the manifest file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a bridging configuration at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a dismissal ID so notification dismissals are synced across devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bridging configuration in manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Bridging configuration at runtime (uses the `BridgingManager` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using dismissal ID to sync notification dismissals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notification is an important component to draw the attention of users to use
    your app in wear devices. Android Wear 2.0 offers more, and will continue to offer
    more, smart replies in notifications, messaging style, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Wear 2.0 input method framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the wear input mechanism in the apps we built in previous chapters.
    Wear 2.0 supports input methods beyond voice by extending the Android **Input
    Method Framework** (**IMF**) to Android Wear. IMF allows for virtual, onscreen
    keyboards and other input methods to be used for text entry. The IMF APIs used
    for wear devices are the same as other form factors, though the usage is slightly
    different due to the limited screen size. Wear 2.0 comes with the system default
    **Input Method Editor** (**IME**) and opens up the IMF APIs for third-party developers
    to create custom input methods for Wear.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking input method for wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To invoke the IMF for wear, your API level should be 23 or higher on the platform.
    In Android Wear apps that contain an EditText fields: Touching a text field places
    the cursor in the field and automatically displays the IMF on focus.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrist gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wear 2.0 supports wrist gestures. When you cannot use the touch screen of your
    wear device, you can utilize the wrist gestures for quick, one-handed interaction,
    for example, when a user is jogging and he wants to perform a certain context-specific
    operation using a wrist gesture. There are few gestures that are not available
    for apps, such as push wrist down, raise wrist up, and shaking wrist. Every wrist
    gesture is mapped to an integer constant from the key event class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Gesture | KeyEvent | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Flick wrist out | `KEYCODE_NAVIGATE_NEXT` | This key code goes to the next
    item. |'
  prefs: []
  type: TYPE_TB
- en: '| Flick wrist in | `KEYCODE_NAVIGATE_PREVIOUS` | This key code goes to the
    previous item. |'
  prefs: []
  type: TYPE_TB
- en: Best practices for using gestures in apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the best practices for using gestures in apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Review the `KeyEvent` and `KeyEvent.Callback` pages for the delivery of key
    events to your view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a touch parallel for a gesture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide visual feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't reinterpret repeated flick gestures into your own new gesture. It may
    conflict with the system's *Shaking the wrist* gesture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `requestFocus()` and `clearFocus()` carefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With standalone watches in place, wear apps can now run entirely on a watch
    without a companion app. This new capability also means that Android Wear standalone
    apps will need to manage authentication on their own when the apps need to access
    data from the cloud. Android Wear supports several authentication methods to enable
    standalone wear apps to obtain user authentication credentials. Now, wear supports
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Google sign-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass tokens via data layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom code authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these protocols follow the same standard as mobile app programming; no big
    changes in integrating Google sign-in in wear or other protocols, but these protocols
    help in authorizing users.
  prefs: []
  type: TYPE_NORMAL
- en: App distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to develop applications for wear 2.0 and, in our past experience,
    we might have published an Android app to the Play store. What does it take to
    publish a standalone wear application, or a general wear application, to the Play
    store through the Google developer console?
  prefs: []
  type: TYPE_NORMAL
- en: Wear 2.0 bundles the Play Store app; users can search for wear-specific apps
    and can install them directly on Wear devices when they are connected to the Internet.
    Generally, wear 2.0 apps in the Play store need a minimum and target an API level
    of 25 or higher in the manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Publish your first wear app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make your app appear in the on-watch Play Store, generate a signed wear apk.
    Publishing the app will be similar to publishing a mobile app if it's a wear standalone
    app. If it is not a standalone and you need to upload a multiple apk, then follow
    [https://developer.android.com/google/play/publishing/multiple-apks.html](https://developer.android.com/google/play/publishing/multiple-apks.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's publish the Wear-Note app in the Play store. It is Google's dedicated
    dashboard for developers that lets you manage your apps in the Play store. Google
    has a one-time $25 registration fee, which you need to pay before you can upload
    an app. The reason behind the fee is to keep out fake, duplicate accounts and,
    hence, keep out unnecessary and poor apps flooding the Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following steps illustrates the story of how we can publish our wear application
    to playstore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://play.google.com/apps/publish/](https://play.google.com/apps/publish/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Create application and give your app a title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thereafter, you will be shown a form to fill in the description and other details,
    which include screenshots of the app and icons and promo graphics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In store listing, fill in all the correct information about the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, upload the signed wear apk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer the questionnaire for content ratings, get a rating, and apply the rating
    to your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In pricing and distribution, you need to have a merchant account to distribute
    your app in the pricing model. Now, wear note app is a free the Wear app and it
    lets you select free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the countries on the list and choose wear device apk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Google will review the wear binary and approve to distribute it in the Wear
    Play store when it is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Congratulations! Now, your app is ready to be published:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood standalone applications and the Complications
    API. We have seen how to detect companion apps using Capability API, and we have
    a clear idea of standalone applications and publishing a wear app too.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter examined how we can reinforce the comprehension of wear 2.0 and
    its components, along with an exhaustive understanding of standalone apps, curved
    layouts and more UI components, and building Wear applications with navigation
    drawers and action drawers. It also offered a brief understanding of wrist gestures
    and using them in wear applications, using the input method framework, and distributing
    the wear application to the Google Play Store.
  prefs: []
  type: TYPE_NORMAL
