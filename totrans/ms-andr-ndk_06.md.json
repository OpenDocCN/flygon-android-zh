["```java\nusing vec2 = LVector2;\nusing vec3 = LVector3;\nusing vec4 = LVector4;\nusing mat3 = LMatrix3;\nusing mat4 = LMatrix4;\nusing quat = LQuaternion;\n```", "```java\npackage com.packtpub.ndkmastering;\nimport android.app.Activity;\nimport android.os.Bundle;\npublic class AppActivity extends org.libsdl.app.SDLActivity\n{\n  static\n  {\n    System.loadLibrary( \"NativeLib\" );\n  }\n  public static AppActivity m_Activity;\n  @Override protected void onCreate( Bundle icicle )\n  {\n    super.onCreate( icicle );\n    m_Activity = this;\n  }\n};\n```", "```java\nint main(int argc, char* argv[])\n{\n  clSDL SDLLibrary;\n```", "```java\n  g_Window = clSDLWindow::CreateSDLWindow( \"GLES3\", 1024, 768 );\n```", "```java\n  LGL3 = std::unique_ptr<sLGLAPI>( new sLGLAPI() );\n  LGL::GetAPI( LGL3.get() );\n```", "```java\n  OnStart( \"\" );\n```", "```java\n  while( g_Window && g_Window->HandleInput() )\n  {\n    OnDrawFrame();\n    g_Window->Swap();\n  }\n  g_Window = nullptr;\n  return 0;\n}\n```", "```java\nclSDL()\n{\n  SDL_Init( SDL_INIT_VIDEO );\n}\nvirtual ~clSDL()\n{\n  SDL_Quit();\n}\n```", "```java\nclass clSDLWindow: public iIntrusiveCounr\n{\nprivate:\n  SDL_Window* m_Window;\n  SDL_GLContext m_Context;\n  float m_Width;\n  float m_Height;\n  std::atomic<bool> m_Pendingit;\npublic:\n  clSDLWindow( const std::string& Title, int Width, int Height );\n  virtual ~clSDLWindow();\n  void RequestExit()\n  {\n    m_PendingExit = true;\n  }\n  void Swap();\n```", "```java\n  bool HandleInput()\n  {\n    SDL_Event Event;\n    while ( SDL_PollEvent(&Event) && !m_PendingExit )\n    {\n      if ( (Event.type == SDL_QUIT) || !this->HandleEvent( Event ) )\n      m_PendingExit = true;\n    }\n    return !m_PendingExit;\n  }\n```", "```java\n  vec2 GetNormalizedPoint( int x, int y ) const\n  {\n    return vec2(\n      static_cast<float>(x) / m_Width,\n      static_cast<float>(y) / m_Height\n    );\n  }\n```", "```java\n  float GetAspect() const\n  {\n    return m_Width / m_Height;\n  }\n```", "```java\npublic:\n  static clPtr<clSDLWindow> CreateSDLWindow(\n    const std::string& Title, int Width, int Height )\n  {\n    return make_intrusive<clSDLWindow>( Title, Width, Height );\n  }\n```", "```java\nprivate:\n  bool HandleEvent( const SDL_Event& Event );};\n```", "```java\n  bool clSDLWindow::HandleEvent( const SDL_Event& Event )\n  {\n    switch ( Event.type )\n    {\n      case SDL_WINDOWEVENT:\n        if ( Event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)\n        {\n          m_Width  = static_cast<float>( Event.window.data1 );\n          m_Height = static_cast<float>( Event.window.data2 );\n        }\n        return true;\n        case SDL_KEYDOWN:\n        case SDL_KEYUP:         OnKey( Event.key.keysym.sym, Event.type == SDL_KEYDOWN );         break;\n        case SDL_MOUSEBUTTONDOWN:\n        case SDL_MOUSEBUTTONUP:         break;\n        case SDL_MOUSEMOTION          break;\n        case SDL_MOUSEWHEEL          break;\n    }\n    return true;\n  }\n```", "```java\n  clPtr<clVertexAttribs> g_Box;\n  clPtr<clGLVertexArray> g_BoxVA;\n  clPtr<clGLSLShaderProgram> g_ShaderProgram;\n  void OnStart( const std::string& RootPath )\n  {\n    LOGI( \"Hello Android NDK!\" );\n    const char* GLVersion  = (const char*)LGL3->glGetString( GL_VERSION  );\n    const char* GLVendor   = (const char*)LGL3->glGetString( GL_VENDOR   );\n    const char* GLRenderer = (const char*)LGL3->glGetString( GL_RENDERER );\n    LOGI( \"GLVersion : %s\\n\", GLVersion );\n    LOGI( \"GLVendor  : %s\\n\", GLVendor  );\n    LOGI( \"GLRenderer: %s\\n\", GLRenderer );\n```", "```java\n    g_Box = clGeomServ::CreateAxisAlignedBox( LVector3(-1), LVector3(+1) );\n```", "```java\n    g_BoxVA = make_intrusive<clGLVertexArray>();\n    g_BoxVA->SetVertexAttribs( g_Box );\n```", "```java\n    g_ShaderProgram = make_intrusive<clGLSLShaderProgram>( g_vShaderStr, g_fShaderStr );\n    LGL3->glClearColor( 0.1f, 0.0f, 0.0f, 1.0f );\n    LGL3->glEnable( GL_DEPTH_TEST );\n  }\n```", "```java\n  static const char g_vShaderStr[] = R\"(\n    uniform mat4 in_ModelViewProjectionMatrix;\n    in vec4 in_Vertex;\n    in vec2 in_TexCoord;\n    out vec2 Coords;\n    void main()\n    {\n      Coords = in_TexCoord.xy;\n      gl_Position = in_ModelViewProjectionMatrix * in_Vertex;\n    }\n  )\";\n```", "```java\n  static const char g_fShaderStr[] = R\"(\n    in vec2 Coords;\n    out vec4 out_FragColor;\n    void main()\n    {\n      out_FragColor = vec4( Coords, 1.0, 1.0 );\n    }\n  )\";\n```", "```java\n  void OnDrawFrame()\n  {\n    static float Angle = 0;\n    Angle += 0.02f;\n    LGL3->glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );\n    mat4 Proj = Math::Perspective(\n      45.0f, g_Window->GetAspect(), 0.4f, 2000.0f );\n```", "```java\n    LMatrix4 MV = LMatrix4::GetRotateMatrixAxis( Angle,\n      vec3( 1, 1, 1 ) ) *\n      mat4::GetTranslateMatrix( vec3( 0, 0, -5 ) );\n    g_ShaderProgram->Bind();\n    g_ShaderProgram->SetUniformNameMat4Array(\n      \"in_ModelViewProjectionMatrix\", 1, MV * Proj );\n    g_BoxVA->Draw( false );\n  }\n```", "```java\n  struct sLGLAPI\n  {\n    sLGLAPI()\n    {\n      memset( this, 0, sizeof( *this ) );\n    };\n    PFNGLACTIVETEXTUREPROC        glActiveTexture;\n    PFNGLATTACHSHADERPROC         glAttachShader;\n    PFNGLBINDATTRIBLOCATIONPROC   glBindAttribLocation;\n    PFNGLBINDBUFFERPROC           glBindBuffer;\n    PFNGLBINDBUFFERBASEPROC       glBindBufferBase;\n    PFNGLBINDFRAGDATALOCATIONPROC glBindFragDataLocation;\n    ...\n  }\n```", "```java\n  void LGL::GetAPI( sLGLAPI* API )\n  {\n    API->glBlendFunc = ( PFNGLBLENDFUNCPROC )GetGLProc( API, \"glBlendFunc\" );\n    API->glBufferData = ( PFNGLBUFFERDATAPROC )GetGLProc( API, \"glBufferData\" );\n    API->glBufferSubData = ( PFNGLBUFFERSUBDATAPROC )GetGLProc( API, \"glBufferSubData\");\n    ...\n  }\n```", "```java\n  void LGL::GetAPI( sLGLAPI* API )\n  {\n    API->glActiveTexture = &glActiveTexture;\n    API->glAttachShader = &glAttachShader;\n    API->glBindAttribLocation = &glBindAttribLocation;\n    API->glBindBuffer = &glBindBuffer;\n    ...\n  }\n```", "```java\n  API->glClearDepth = &Emulate_glClearDepth;\n```", "```java\n  LGL_CALL void Emulate_glClearDepth( double Depth )\n  {\n    glClearDepthf( static_cast<float>( Depth ) );\n  }\n```", "```java\nclass clVertexAttribs: public iIntrusiveCounter\n{\npublic:\n  clVertexAttribs();\n  explicit clVertexAttribs( size_t Vertices );\n  void SetActiveVertexCount( size_t Count )\n  {FActiveVertexCount = Count; }\n  size_t GetActiveVertexCount() const\n  { return FActiveVertexCount; }\n```", "```java\n  const std::vector<const void*>& EnumerateVertexStreams() const;\n  {\n    FStreams[ L_VS_VERTEX   ] = &FVertices[0];\n    FStreams[ L_VS_TEXCOORD ] = &FTexCoords[0];\n    FStreams[ L_VS_NORMAL   ] = &FNormals[0];\n    FStreams[ L_VS_COLORS   ] = &FColors[0];\n    return FStreams;\n  }\n```", "```java\n  void Restart( size_t ReserveVertices );\n  void EmitVertexV( const vec3& Vec );\n  void SetTexCoordV( const vec2& V );\n  void SetNormalV( const vec3& Vec );\n  void SetColorV( const vec4& Vec );\n```", "```java\npublic:\n  std::vector<vec3> FVertices;\n```", "```java\n  std::vector<vec2> FTexCoords;\n```", "```java\n  std::vector<vec3> FNormals;\n```", "```java\n  std::vector<vec4> FColors;\n};\n```", "```java\nclasslGeomServ\n{\npublic:\n  static clPtr<clVertexAttribs> CreateTriangle2D( float vX, float vY, float dX, float dY, float Z );\n  static clPtr<clVertexAttribs> CreateRect2D( float X1, float Y1, float X2, float Y2, float Z,\n    bool FlipTexCoordsVertical, int Subdivide );\n  static void AddAxisAlignedBox( const clPtr<clVertexAttribs>& VA, const LVector3& Min, const LVector3& Max );\n  static clPtr<clVertexAttribs> CreateAxisAlignedBox( const LVector3& Min, const LVector3& Max );\n  static void AddPlane( const clPtr<clVertexAttribs>& VA, float SizeX, float SizeY, int SegmentsX, int SegmentsY, float Z );\n  static clPtr<clVertexAttribs> CreatePlane( float SizeX, float SizeY, int SegmentsX, int SegmentsY, float Z );\n};\n```", "```java\nclass clGLVertexArray: public iInusiveCounter\n{\npublic:\n  clGLVertexArray();\n  virtual ~clGLVertexArray();\n```", "```java\n  void Draw( bool Wireframe ) const;\n  void SetVertexAttribs(\n    const clPtr<clVertexAttrs>& Attribs );\nprivate:\n  void Bind() const;\nprivate:\n  Luint FVBOID;\n  Luint FVAOID;\n```", "```java\n  std::vector<const void*> FAttribVBOOffset;\n```", "```java\n  std::vector<const void*> FEnumeratedStreams;\n  clPtr<clVertexAttribs> FAttribs;\n};\n```", "```java\nclGLVertexArray::clGLVertexArray()\n: FVBOID( 0 ),\n  FVAOID( 0 ),\n  FAttribVBOOffset( L_VS_TOTAL_ATTRIBS ),\n  FEnumeratedStreams( L_VS_TOTAL_ATTRIBS ),\n  FAttribs( nullptr )\n{\n```", "```java\n  #if dined( _WIN32 )\n    LGL3->glGenVertexArrays( 1, &FVAOID );\n  #endif\n}\n```", "```java\nclGLVertexArray::~clGLVertexArray()\n{\n  LGL3->glDeleteBuffers( 1, &FVBOID );\n  #if defined( _WIN32 )\n    LGL3->glDeleteVertexArrays( 1, &FVAOID );\n  #endif\n}\n```", "```java\nvoid clGLVertexArray::Bind() const\n{\n  LGL3->glBindBuffer( GL_ARRAY_BUFFER, FVBOID );\n  LGL3->glVertexAttribPointer( L_VS_VERTEX, L_VS_VEC_COMPONENTS[ 0 ], GL_FLOAT, GL_FALSE, 0, FAttribVBOOffset[ 0 ] );\n  LGL3->glEnableVertexAttribArray( L_VS_VERTEX );\n```", "```java\n  for ( int i = 1; i < L_VS_TOTAL_ATTRIBS; i++ )\n  {\n    LGL3->glVertexAttribPointer( i,\n      L_VS_VEC_COMPONENTS[ i ],\n      GL_FLOAT, GL_FALSE, 0, FAttribVBOOffset[ i ] );\n    FAttribVBOOffset[ i ] ?\n      LGL3->glEnableVertexAttribArray( i ) :\n      LGL3->glDisableVertexAttribArray( i );\n  }\n}\n```", "```java\nvoid clGLVertexArray::Draw( bool Wireframe ) const\n{\n  #if defined( _WIN32 )\n    LGL3->glBindVertexArray( FVAOID );\n  #else\n    Bind();\n  #endif\n```", "```java\n  LGL3->glDrawArrays(\n    Wireframe ? GL_LINE_LOOP : GL_TRIANGLES, 0,\n    static_cast<GLsizei>( FAttribs->GetActiveVertexCount() ) );\n}\n```", "```java\nvoid clGLVertexArray::SetVertexAttribs(  const clPtr<clVertexAttribs>& Attribs )\n{\n  FAttribs = Attribs;\n```", "```java\n  FEnumeratedStreams = FAttribs->EnumerateVertexStreams();\n  LGL3->glDeleteBuffers( 1, &FVBOID );\n  size_t VertexCount = FAttribs->FVertices.size();\n  size_t DataSize = 0;\n```", "```java\n  for ( int i = 0; i != L_VS_TOTAL_ATTRIBS; i++ )\n  {\n    FAttribVBOOffset[ i ] = ( void* )DataSize;\n    DataSize += FEnumeratedStreams[i] ?\n      sizeof( float ) * L_VS_VEC_COMPONENTS[ i ] * VertexCount : 0;\n  }\n```", "```java\n  LGL3->glGenBuffers( 1, &FVBOID );\n  LGL3->glBindBuffer( GL_ARRAY_BUFFER, FVBOID );\n```", "```java\n  LGL3->glBufferData( GL_ARRAY_BUFFER, DataSize, nullptr, GL_STREAM_DRAW );\n```", "```java\n  for ( int i = 0; i != L_VS_TOTAL_ATTRIBS; i++ )\n  {\n    if ( FEnumeratedStreams[i] )\n    {\n      LGL3->glBufferSubData( GL_ARRAY_BUFFER, ( GLintptr )FAttribVBOOffset[ i ], FAttribs->GetActiveVertexCount() * sizeof( float ) * L_VS_VEC_COMPONENTS[ i ], FEnumeratedStreams[ i ] );\n    }\n  }\n```", "```java\n  #if defined( _WIN32 )\n    LGL3->glBindVertexArray( FVAOID );\n    Bind();\n    LGL3->glBindVertexArray( 0 );\n  #endif\n}\n```", "```java\nstruct sUniform\n{\npublic:\n  explicit sUniform( const std::string& e)\n  : FName( e )\n  , FLocation( -1 )\n  {};\n  sUniform( int Location, const std::string& e)  : FName( e )\n  , FLocation( Location )\n  {};\n  std::string FName;\n  Lint FLocation;\n};\n```", "```java\nclass clGLSLShaderProgram: public iIntrusiveCounr\n{\npublic:\n```", "```java\n  clGLSLShaderProgram( const std::string& VShader, const std::string& FShader );\n  virtual ~clGLSLShaderProgram();\n```", "```java\n  void Bind();\n```", "```java\n  Lint CreateUniform( const std::string& Name );\n  void SetUniformNameFloat( const std::string& Name, const float Float );\n  void SetUniformNameFloatArray( const std::string& Name, int Count, const float& Float );\n  void SetUniformNameVec3Array( const std::string& Name, int Count, const LVector3& Vector );\n  void SetUniformNameVec4Array( const std::string& Name, int Count, const LVector4& Vector );\n  void SetUniformNameMat4Array( const std::string& Name, int Count, const LMatrix4& Matr );\nprivate:\n```", "```java\n  bool RelinkShaderProgram();\n```", "```java\n  void BindDefaultLocations( Luint ProgramID )\n  {\n    LGL3->glBindAttribLocation( ProgramID, L_VS_VERTEX, \"in_Vertex\" );\n    LGL3->glBindAttribLocation( ProgramID, L_VS_TEXCOORD, \"in_TexCoord\" );\n    LGL3->glBindAttribLocation( ProgramID, L_VS_NORMAL, \"in_Normal\" );\n    LGL3->glBindAttribLocation( ProgramID, L_VS_COLORS, \"in_Color\" );\n    LGL3->glBindFragDataLocation( ProgramID, 0, \"out_FragColor\" );\n  }\n```", "```java\n  Luint AttachShaderID( Luint Target, const std::string& ShaderCode, Luint OldShaderID );\n```", "```java\n  bool CheckStatus( Luint ObjectID, Lenum Target, const std::string& Message ) const;\n```", "```java\n  void RebindAllUniforms();\nprivate:\n  std::string FVertexShader;\n  std::string FFragmentShader;\n  Luint FVertexShaderID;\n  Luint FFragmentShaderID;\n```", "```java\n  std::vector<sUniform> FUniforms;\n```", "```java\n  Luint FProgramID;\n  std::vector<Luint> FShaderID;\n};\nclGLSLShaderProgram::clGLSLShaderProgram(\n  const std::string& VShader, const std::string& FShader )\n: FVertexShader( VShader )\n, FFragmentShader( FShader )\n, FUniforms()\n, FProgramID( 0 )\n, FVertexShaderID( 0 )\n, FFragmentShaderID( 0 )\n{\n  RelinkShaderProgram();\n}\n```", "```java\nclGLSLShaderProgram::~clGLSLShaderProgram()\n{\n  LGL3->glDeleteProgram( FProgramID );\n  LGL3->glDeleteShader( FVertexShaderID );\n  LGL3->glDeleteShader( FFragmentShaderID );\n}\n```", "```java\nLuint clGLSLShaderProgram::AttachShaderID( Luint Target,\n  const std::string& ShaderCode, Luint OldShaderID )\n{\n```", "```java\n  #if defined( USE_OPENGL_4 )\n    std::string ShaderStr = \"#version 330 core\\n\";\n  #else\n    std::string ShaderStr = \"#version 300 es\\n\";\n    ShaderStr += \"precision highp float;\\n\";\n    ShaderStr += \"#define USE_OPENGL_ES_3\\n\";\n  #endif\n    ShaderStr += ShaderCode;\n```", "```java\n    Luint Shader = LGL3->glCreateShader( Target );\n    const char* Code = ShaderStr.c_str();\n    LGL3->glShaderSource( Shader, 1, &Code, nullptr );\n    LGL3->glCompileShader( Shader );\n```", "```java\n    if ( !CheckStatus( Shader, GL_COMPILE_STATUS, \"Shader wasn''t compiled:\" ) )\n    {\n      LGL3->glDeleteShader( Shader );\n      return OldShaderID;\n    }\n    if ( OldShaderID )\n    {\n      LGL3->glDeleteShader( OldShaderID );\n    }\n    return Shader;\n  }\n```", "```java\n  bool clGLSLShaderProgram::CheckStatus( Luint ObjectID, Lenum Target, const std::string& Message ) const\n  {\n    Lint   SuccessFlag = 0;\n    Lsizei Length      = 0;\n    Lsizei MaxLength   = 0;\n    if ( LGL3->glIsProgram( ObjectID ) )\n    {\n      LGL3->glGetProgramiv( ObjectID, Target, &SuccessFlag );\n      LGL3->glGetProgramiv( ObjectID, GL_INFO_LOG_LENGTH, &MaxLength );\n```", "```java\n      char* Log = ( char* )alloca( MaxLength );\n      LGL3->glGetProgramInfoLog( ObjectID, MaxLength, &Length, Log );\n      if ( *Log ) { LOGI( \"Program info:\\n%s\\n\", Log ); }\n    }\n    else if ( LGL3->glIsShader( ObjectID ) )\n    {\n      LGL3->glGetShaderiv( ObjectID, Target, &SuccessFlag );\n      LGL3->glGetShaderiv( ObjectID, GL_INFO_LOG_LENGTH, &MaxLength );\n```", "```java\n      char* Log = ( char* )alloca( MaxLength );\n      LGL3->glGetShaderInfoLog( ObjectID, MaxLength, &Length, Log );\n      if ( *Log ) { LOGI( \"Shader info:\\n%s\\n\", Log ); }\n    }\n    return SuccessFlag != 0;\n  }\n```", "```java\n  bool clGLSLShaderProgram::RelinkShaderProgram()\n  {\n    Luint ProgramID = LGL3->glCreateProgram();\n    FVertexShaderID = AttachSaderID( GL_VERTEX_SHADER, FVertexShader, FVertexShaderID );\n    if ( FVertexShaderID )\n    { LGL3->glAttachShader( ProgramID, FVertexShaderID ); }\n    FFragmentShaderID = AttachShaderID( GL_FRAGMENT_SHADER, FFragmentShader, FFragmentShaderID );\n    if ( FFragmentShaderID )\n    { LGL3->glAttachShader( ProgramID, FFragmentShaderID ); }\n```", "```java\n    BindDefaultLocations( ProgramID );\n    LGL3->glLinkProgram( ProgramID );\n    if ( !CheckStatus( ProgramID, GL_LINK_STATUS, \"Program wasn''t linked\" ) )\n    {\n      LOGI( \"INTERNAL ERROR: Error while shader relinking\" );\n      return false;\n    }\n```", "```java\n    LGL3->glDeleteProgram( FProgramID );\n    FProgramID = ProgramID;\n```", "```java\n    RebindAllUniforms();\n```", "```java\n    LGL3->glUniform1i( LGL3->glGetUniformLocation(FProgramID, \"Texture0\"), 0);\n    LGL3->glUniform1i( LGL3->glGetUniformLocation(FProgramID, \"Texture1\"), 1);\n    LGL3->glUniform1i( LGL3->glGetUniformLocation(FProgramID, \"Texture2\"), 2);\n    LGL3->glUniform1i( LGL3->glGetUniformLocation(FProgramID, \"Texture3\"), 3);\n    return true;\n  }\n```", "```java\n  void clGLSLShaderProgram::RebindAllUniforms()\n  {\n    Bind();\n    FUniforms.clear();\n    Lint ActiveUniforms;\n    char Buff[256];\n    LGL3->glGetProgramiv( FProgramID,\n      GL_ACTIVE_UNIFORMS, &ActiveUniforms );\n    for ( int i = 0; i != ActiveUniforms; ++i )\n    {\n      Lsizei Length;\n      Lint Size;\n      Lenum Type;\n      LGL3->glGetActiveUniform( FProgramID, i,\n        sizeof( Buff ), &Length, &Size, &Type, Buff );\n      std::string Name( Buff, Length );\n```", "```java\n      sUniform Uniform( Name );\n      Uniform.FLocation = LGL3->glGetUniformLocation( FProgramID, Name.c_str() );\n      FUniforms.push_back( Uniform );\n    }\n  }\n```", "```java\n  void clGLSLShaderProgram::SetUniformNameFloat( const std::string& Name, const float Float )\n  {\n    Lint Loc = CreateUniform( Name );\n    LGL3->glUniform1f( Loc, Float );\n  }\n  void clGLSLShaderProgram::SetUniformNamoatArray( const std::string& Name, int Count, const float& Float )\n  {\n    Lint Loc = CreateUniform( Name );\n    LGL3->glUniform1fv( Loc, Count, &Float );\n  }\n```", "```java\n  void void clGLSLShaderProgram::SetUniformNameec3Array(     const std::string& Name, int Count, const LVector3& Vector )\n  {\n    Lint Loc = CreateUniform( Name );\n    LGL3->glUniform3fv( Loc, Count, Vector.ToFloatPtr() );\n  }\n  void clGLSLShaderProgram::SetUniformNameVec4Array( const std::string& Name, int Count, const LVector4& Vector )\n  {\n    Lint Loc = CreateUniform( Name );\n    LGL3->glUniform4fv( Loc, Count, Vector.ToFloatPtr() );\n  }\n```", "```java\n  void clGLSLShaderProgram::SetUniformNameMat4Array( const std::string& Name, int Count, const LMatrix4& Matrix )\n  {\n    Lint Loc = CreateUniform( Name );\n    LGL3->glUniformMatrix4fv( Loc, Count, false,\n    Matrix.ToFloatPtr() );\n  }\n```", "```java\n  Lint clGLSLShaderProgram::CreateUniform( const std::string& Name )\n  {\n    for ( size_t i = 0; i != FUniforms.size(); ++i )\n    if ( FUniforms[i].FName == Name )\n    return FUniforms[i].FLocation;\n    return -1;\n  }\n```", "```java\n  void clGLSLShaderProgram::Bind()\n  {\n    LGL3->glUseProgram( FProgramID );\n  }\n```", "```java\n  class clGLTexture: public iIntrusivounter\n  {\n  public:\n    clGLTexture();\n    virtual ~clGLTexture();\n```", "```java\n    void Bind( int TextureUnit ) const;\n```", "```java\n    void LoadFromBitmap( const clPtr<clBitmap>& Bitmap );\n```", "```java\n    void SetClamping( Lenum Clamping );\n\n```", "```java\n  private:\n    void SetFormat( Lenum Target, Lenum InternalFormat, Lenum Format, int Width, int Height );\n    Luint FTexID;\n    Lenum FInternalFormat;\n    Lenum FFormat;\n  };\n```", "```java\n  clGLTexturelGLTexture()\n  : FTexID( 0 )\n  , FIntelFormat( 0 )\n  , FFormat( 0 )\n  {\n  }\n  clGLTexture::~clGLTexture()\n  {\n    if ( FTexID ) { LGL3->glDeleteTextures( 1, &FTexID ); }\n  }\n  void clGLTexture::Bind( int TextureUnit ) const\n  {\n    LGL3->glActiveTexture( GL_TEXTURE0 + TextureUnit );\n    LGL3->glBindTexture( GL_TEXTURE_2D, FTexID );\n  }\n```", "```java\n  void clGLTexture::SetFormat( Lenum Target, Lenum InternalFormat, Lenum Format, int Width, int Height )\n  {\n    if ( FTexID )\n    {\n      LGL3->glDeleteTextures( 1, &FTexID );\n    }\n    LGL3->glGenTextures( 1, &FTexID );\n    LGL3->glBindTexture( GL_TEXTURE_2D, FTexID );\n    LGL3->glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n    LGL3->glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n    LGL3->glTexImage2D( GL_TEXTURE_2D, 0, InternalFormat, Width, Height, 0, Format, GL_UNSIGNED_BYTE, nullptr );\n    LGL3->glBindTexture( GL_TEXTURE_2D, 0 );\n  }\n  void clGLTexture::SetClamping( Lenum Clamping )\n  {\n    Bind( 0 );\n```", "```java\n    LGL3->glTexParameteri( GL_TEXTURE_2D,\n      GL_TEXTURE_WRAP_S, Clamping );\n    LGL3->glTexParameteri( GL_TEXTURE_2D,\n      GL_TEXTURE_WRAP_T, Clamping );\n  }\n  void clGLTexture::LoadFromBitmap( const clPtr<clBitmap>& Bitmap )\n  {\n    if ( !Bitmap ) { return; }\n    if ( !FTexID )\n    {\n      LGL3->glGenTextures( 1, &FTexID );\n    }\n```", "```java\n    ChooseInternalFormat( Bitmap->FBitmapParams, &FFormat, &FInternalFormat );\n    Bind( 0 );\n```", "```java\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\n    LGL3->glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\n    int Width = Bitmap->GetWidth();\n    int Height = Bitmap->GetHeight();\n```", "```java\n    if ( !Width || !Height ) { return; }\n```", "```java\n    LGL3->glTexImage2D( GL_TEXTURE_2D, 0, FInternalFormat, Width, Height, 0, FFormat, GL_UNSIGNED_BYTE, Bitmap->FBitmapData );\n  }\n```", "```java\n>ndk-build -j16 -B\n>ant debug\n\n```"]