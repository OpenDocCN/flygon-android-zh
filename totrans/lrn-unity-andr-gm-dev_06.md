# 第六章. 移动设备的特性——触摸和倾斜

在上一章中，我们学习了路径查找和人工智能。我们将坦克大战游戏扩展到了包括敌方坦克。我们为它们创建了生成点，并让它们向玩家射击。此外，玩家获得了摧毁坦克的能力。一旦坦克被摧毁，玩家将获得一些分数，并且会生成新的敌方坦克。

在本章中，我们将通过探索移动设备的某些特性来开发一个新游戏。我们将创建一个**猴子球**游戏。玩家将控制一个超大仓鼠球中的猴子，尝试在时间耗尽前到达迷宫的终点，同时收集香蕉。为了移动，他们将不得不倾斜移动设备。为了收集香蕉，玩家将不得不触摸屏幕上香蕉所在的位置。

在本章中，我们将涵盖以下主题：

+   触摸控制

+   倾斜控制

+   猴子球游戏

我们将为本章创建一个新项目，因此启动 Unity，我们将开始。

# 设置开发环境

与每个项目一样，我们需要做一些准备工作以准备我们的开发环境。别担心，本章的设置简单直接。让我们按照以下步骤进行操作：

1.  第一步当然是启动 Unity 并创建一个新项目。它应该是一个 3D 项目，将其命名为`Ch6_MonkeyBall`会很合适。

1.  当 Unity 完成初始化后，这是设置我们构建设置的完美时机。打开**构建设置**窗口，从平台列表中选择**Android**，然后点击**切换平台**以改变目标平台。

1.  当你处于**构建设置**窗口时，选择**玩家设置**以在**检查器**中打开玩家设置。调整**公司名称**、**产品名称**，最重要的是**捆绑标识符**。

1.  当用户倾斜他们的设备时，当新的一边成为底部时，整个屏幕将调整其方向。由于整个游戏都是围绕倾斜设备设计的，因此在玩家游戏过程中屏幕方向可能会随时改变，从而破坏他们的游戏体验。因此，在**玩家设置**中，找到**分辨率**和**展示**部分，确保**默认方向**没有设置为**自动旋转**，这会导致 Unity 在我们玩游戏时改变游戏的方向。这里的其他任何选项都可以为我们所用。

1.  我们需要创建几个文件夹以保持项目的组织性。在**项目**窗口中应创建`Scripts`（脚本）、`Models`（模型）和`Prefabs`（预制体）文件夹。由于将来我们可能会有数十个关卡和地图，因此创建一个`Scenes`（场景）文件夹也是个好主意。

1.  最后，我们必须为本项目导入资源。我们需要一个作为玩家的猴子、一个要收集的香蕉、一个示例地图和一些围栏。幸运的是，所有这些资源都已准备就绪，并包含在本章的初始资源中。将`Monkey.blend`、`Monkey.psd`、`Ball.psd`、`Banana.blend`、`Banana.psd`、`MonkeyBallMap.blend`、`Grass.psd`、`Fence.blend`和`Wood.psd`导入到您刚才创建的`Models`文件夹中。

我们刚刚完成了本章项目的设置。再次强调，项目开始时的一点点努力将节省时间并避免后期出现挫折；随着项目规模的扩大，开始时的组织工作变得非常重要。

# 一个基本的环境

在我们深入探讨倾斜和触摸控制的乐趣之前，我们需要一个基本的测试环境。在使用新的控制方案时，最好在一个简单且易于控制的环境中工作，然后再引入真实关卡复杂性。让我们按照以下步骤创建我们的环境：

1.  在 Unity 顶部，通过导航到**GameObject** | **3D Object**选择**Cube**，创建一个新立方体，它将成为我们基本环境的基础。将其重命名为`Ground`，以便我们可以跟踪它。

1.  在**检查器**面板中将立方体的**位置**设置为每个轴上的`0`，这样我们就可以围绕世界原点进行操作。同时，将它的**X**和**Z**的**缩放**在**检查器**中设置为`10`，为我们提供足够的空间来移动并测试我们的猴子。

1.  接下来，我们需要一个名为`Fence`的第二个立方体。这个立方体的**位置**值应为**X**的`-5`，**Y**的`1`，**Z**的`0`，以及**X**和**Y**的`0.2`缩放和**Z**的`10`。

1.  在**层次结构**窗口中选择`Fence`，您可以按键盘上的*Ctrl* + *D*来创建一个副本。我们需要总共四个，沿着我们的`Ground`立方体的每一边放置：![一个基本的环境](img/4691OT_06_01.jpg)

现在我们有一个基本的测试环境，它将允许我们使用控制装置，而不必担心整个关卡的所有复杂性。一旦我们的控制装置在这个环境中按照我们想要的方式工作，我们将把我们的猴子引入到一个新的环境。

# 倾斜控制

现代移动设备提供了各种各样的内部传感器来检测并提供关于周围世界的信息。尽管你可能没有这样想过，但你一定非常熟悉用于打电话的麦克风和扬声器。还有用于连接互联网的 Wi-Fi 接收器和用于拍照的摄像头。此外，你的设备几乎肯定有一个磁力计，用于与 GPS 配合提供方向。

我们现在感兴趣的传感器是**陀螺仪**。这个传感器可以检测设备的局部旋转。一般来说，它是手机中众多传感器之一，用于确定设备在世界中的方向和移动。我们将使用它来控制我们的猴子。当用户左右倾斜设备时，猴子就会左右移动。当设备上下倾斜时，猴子就会前进和后退。通过这些步骤，我们可以创建一个脚本来让我们以这种方式控制猴子：

1.  首先，创建一个新脚本并将其命名为`MonkeyBall`。

1.  我们第一个变量将保存一个对附加到球体的**Rigidbody**组件的引用。这是让我们实际让它滚动并与世界中的物体碰撞的关键：

    ```java
    public Rigidbody body;
    ```

1.  接下来的两个变量将让我们控制设备倾斜如何影响游戏中的移动。第一个将允许我们消除任何太小的移动。这让我们避免了来自环境或可能不是完全准确的传感器的随机移动。第二个将让我们在控制感觉过于迟缓或过快时，调整倾斜输入的大小：

    ```java
    public float minTilt = 5f;
    public float sensitivity = 1f;
    ```

1.  目前最后一个变量将跟踪设备被倾斜了多少。它迫使用户如果想要朝相反方向移动，就需要来回倾斜设备，以抵消移动：

    ```java
    private Vector3 totalRotate = Vector3.zero;
    ```

1.  我们这个脚本的第一个函数非常简短。为了从陀螺仪获取输入，我们首先必须打开它。我们将在`Awake`函数中这样做，以便从游戏一开始就跟踪它：

    ```java
    public void Awake() {
      Input.gyro.enabled = true;
    }
    ```

1.  我们脚本的下一个函数是`Update`。它首先从陀螺仪获取`rotationRate`的值。这是一个每秒弧度的值，表示用户沿着每个轴倾斜设备的速度有多快。为了使它更容易理解，我们在将其存储在变量之前，将`rotationRate`的值乘以`Mathf.Rad2Deg`将其转换为每秒度数：

    ```java
    public void Update() {
      Vector3 rotation = Input.gyro.rotationRate * Mathf.Rad2Deg;
    ```

    ### 注意

    当你将设备屏幕朝向你握在手中时，设备的*x*轴指向右边。*y*轴是垂直向上的，位于设备的顶部，而*z*轴则直接从屏幕中心指向你。

1.  接下来，我们要确保每个轴上的移动足够大，以实际让我们的猴子移动。通过对每个值使用`Mathf.Abs`，我们找到轴移动的绝对值。然后，我们将其与我们寻找的最小倾斜量进行比较。如果移动太小，我们在`rotation`变量中将其归零：

    ```java
    if(Mathf.Abs(rotation.x) < minTilt) rotation.x = 0;
    if(Mathf.Abs(rotation.y) < minTilt) rotation.y = 0;
    if(Mathf.Abs(rotation.z) < minTilt) rotation.z = 0;
    ```

1.  最后，对于我们的`Update`函数，我们通过将新移动添加到我们的`totalRotate`变量来跟踪新移动。为此，我们需要重新排列这些值。玩家期望能够将设备顶部向自己倾斜以向后移动，远离以向前移动。这是*x*轴移动，但与我们需要移动猴子相比，它从我们的设备中反方向输入，因此值前有负号。接下来，我们交换*y*和*z*轴的旋转，因为玩家将期望通过左右倾斜设备来左右移动，这是*y*轴移动。如果我们将其应用于猴子的*y*轴，他只能在原地旋转。因此，移动被视为每秒的速度而不是每帧的速度；我们需要乘以`Time.deltaTime`：

    ```java
    TotalRotate += new Vector3(-rotation.x, rotation.z, -rotation.y) * Time.deltaTime;
    }
    ```

1.  目前最后一个函数是`FixedUpdate`函数。在对刚体进行修改和处理时，最好在`FixedUpdate`中进行。刚体实际上是将我们连接到 Unity 物理引擎的部分，而且它只在这个函数中更新。我们在这里所做的就是给刚体添加一些扭矩，或者说旋转力。我们使用收集到的总量乘以我们的`sensitivity`来给玩家提供他们预期的控制速度：

    ```java
    public void FixedUpdate() {
      body.AddTorque(totalRotate * sensitivity);
    }
    ```

1.  为了使用我们的新脚本，需要对球体进行一些修改。首先创建一个球体供我们操作；可以通过导航至**游戏对象** | **3D 对象** | **球体**找到。将其重命名为`MonkeyBall`，并将其位置稍微设在我们**地面**方块之上。

1.  接下来，给物体赋予`Ball.psd`材质，这样我们就能看到它旋转而不仅仅是移动。材质的双色调特性将使我们能够轻松看到它在场景中滚动。

1.  **刚体**组件可以通过在 Unity 顶部导航至**组件** | **物理** | **刚体**找到。添加一个新的**刚体**组件。

1.  此外，将我们的`MonkeyBall`脚本添加到球体上，并将新的**刚体**组件拖到**检查器**面板中的**Body**槽。

1.  在这一点上，拥有**Unity Remote**尤为重要。将设备连接并运行*Unity Remote*，你可以拿起它来控制球体。随意调整敏感度和最小倾斜度，直到找到感觉自然的控制设置。由于设备、硬件以及所用架构的多样性，不同设备之间的倾斜速率可能很容易有所不同。然而，特别是在这个阶段，你必须找到现在适合你设备的设置，并在游戏更加完善后再考虑其他设备的兼容性。

1.  如果你发现球体滚动时的视线不好，移动摄像头以获得更好的视角。但确保它继续沿着世界的*z*轴向前指。

1.  当所有设置完成后，确保保存场景。将其命名为`MonkeyBall`。![通过倾斜控制](img/4691OT_06_02.jpg)

我们利用陀螺仪为你提供了球的转向控制。通过测量玩家倾斜设备的方式，我们能够相应地给球添加运动。通过在简单地图上滚动，我们可以微调我们的控制，确保一切正常工作。

## 与相机一起跟随

为了让玩家真正感觉到他们正在控制球，相机需要跟随球移动。当地图和关卡变得比一个相机镜头能展示的更大更复杂时，这一点尤为重要。最简单的解决方案是将相机设置为球的子对象，但这会使它与球一起旋转，我们的控制也会变得混乱。所以，让我们按照以下步骤设置相机跟随球移动：

1.  我们首先需要创建一个新的脚本，并将其命名为`CameraFollow`。

1.  这个脚本非常简单。它有一个单一变量来跟踪正在跟随的对象：

    ```java
    public Transform ball;
    ```

1.  脚本中唯一的函数是`LateUpdate`函数。我们使用这个函数，因为它在所有其他内容有机会进行正常更新之后执行。脚本要做的就是移动到球的新位置：

    ```java
    public void LateUpdate() {
      transform.position = ball.position;
    }
    ```

1.  为了使用这个脚本，我们需要一个新的空**GameObject**组件。将其命名为`CameraPivot`。

1.  将其定位在（大约）球的中心。这是实际上会移动以跟随球的位置。在这一点上，创建的**GameObject**不需要完美定位；它只需要足够接近，这样更容易对齐相机。

1.  接下来，在**层次结构**窗口中找到**主相机**，并将其设置为`CameraPivot`的子对象。

1.  将**主相机**组件的**X**位置设置为`0`。只要**X**保持为零，且相机继续沿着*z*轴相对向前指向，你就可以自由移动它以找到一个观察球的好位置。**Y**位置为`2`，**Z**位置为`-2.5`，**X**旋转为`35`也效果不错。

1.  接下来，将`CameraFollow`脚本添加到`CameraPivot`对象上。

1.  最后，将场景中的`MonkeyBall`拖拽到新的**CameraFollow**脚本组件的**Ball**槽中。然后，去试试看！！与相机一起跟随

现在我们有一个滚动的球和一个跟随它的相机。相机只是更新其位置以跟上球的步伐，但它作为一个效果非常好。作为玩家，我们肯定会感觉到我们正在控制球及其运动。

## 添加猴子

现在我们离球很近并且跟随它移动，我们需要一些更有趣的东西来观察。在本节中，我们将在球上添加猴子。此外，为了确保他不会被疯狂地旋转，我们将制作一个新的脚本来保持他直立。按照以下步骤进行操作：

1.  创建一个新的空**GameObject**，并将其重命名为`MonkeyPivot`。

1.  将其设置为`MonkeyBall`脚本的子对象，并将位置归零。

1.  接下来，将猴子添加到场景中，并将其设置为`MonkeyPivot` GameObject 的子对象。

1.  为了更容易看到球内的猴子，我们需要让猴子稍微透明一些。选择`MonkeyBall`并找到材质底部上的**渲染模式**（Rendering Mode）设置。将其更改为**透明**（Transparent），我们就能进行调整。

1.  现在，点击**反照率**（Albedo）右侧的**颜色选择器**（Color Picker）框，并将**A**滑块，即 alpha 值，调整为`128`；这样我们就能透视球体内部了。

1.  缩放并移动猴子，直到他填满球体的中心。

    ### 提示

    你也可以借此机会为猴子摆个姿势。如果展开**层级**（Hierarchy）窗口中的猴子，你将能够看到构成他骨骼的所有骨头。现在给他一个酷炫的姿势，将使我们的玩家在游戏中的体验更好。

    ![添加猴子](img/4691OT_06_04.jpg)

1.  目前我们的猴子和球体看起来很酷，但当我们实际播放时，猴子在球内晕头转向地旋转。我们需要打开`MonkeyBall`脚本，修复他的旋转动作：

1.  首先，在脚本顶部我们需要两个新的变量。第一个将追踪我们刚才创建的空的**GameObject**。第二个将为我们提供更新猴子旋转的速度。我们希望看起来像是猴子在移动球体，所以他需要面向球体移动的方向。这里的速度是指他转向正确方向的速度：

    ```java
    public Transform monkeyPivot;
    public float monkeyLookSpeed = 10f;
    ```

1.  接下来，我们需要一个新的`LateUpdate`函数。这会再次检查`monkeyPivot`变量是否真的为脚本所填充。如果没有，我们就无法进行其他操作：

    ```java
    public void LateUpdate() {
      if(monkeyPivot != null) {
    ```

1.  我们首先需要弄清楚球体移动的方向。做到这一点最简单的方法是获取**刚体**（Rigidbody）组件的`velocity`，即我们的 body 变量。它是一个`Vector3`，表示我们当前移动的速度和方向。由于我们不希望猴子指向上下，所以我们为零*y*轴移动：

    ```java
    Vector3 velocity = body.velocity;
    velocity.y = 0;
    ```

1.  接下来，我们需要弄清楚猴子当前面向的方向。我们之前在使用坦克时已经使用过前进值。它只是我们在 3D 空间中面向的方向。同样，为了避免上下看，我们将*y*轴归零：

    ```java
    Vector3 forward = monkeyPivot.forward;
    forward.y = 0;
    ```

1.  为了避免移动时突然改变方向，并与帧率保持一致，我们必须计算一个`step`变量。这是基于我们的速度和自上一帧以来经过的时间，这一帧我们可以旋转多少：

    ```java
    float step = monkeyLookSpeed * Time.deltaTime;
    ```

1.  然后，我们需要通过使用`Vector3.RotateTowards`找到一个新面向的方向。它包括我们当前面向的方向，接着是我们想要面向的方向以及两个速度。第一个速度指定了这一帧中角度可以改变多少，第二个指定了向量的大小或长度可以改变多少。我们不关心向量大小的变化，所以给它赋予零值：

    ```java
    Vector3 newFacing = Vector3.RotateTowards(forward, velocity, step, 0);
    ```

1.  最后，通过将`newFacing`向量传递给`Quaternion.LookRotation`来计算新的旋转，并将结果应用到猴子旋转上。这将使猴子面向移动方向，防止它与球一起旋转：

    ```java
    monkeyPivot.rotation = Quaternion.LookRotation(newFacing);
    }
    }
    ```

1.  要使其工作，请将`MonkeyPivot`对象拖放到**MonkeyBall**脚本组件上的**Monkey Pivot**槽中。猴子将旋转以面向球的移动方向，同时保持直立：![添加猴子](img/4691OT_06_05.jpg)

我们刚刚完成了将猴子添加到球中的工作。通过给猴子一个酷炫的姿势，玩家会更多地将其作为一个角色来参与。然而，当猴子在球内疯狂旋转时，看起来有点奇怪，因此我们更新了脚本，使他能保持直立并面向球的移动方向。现在，它几乎看起来像是猴子在控制球。

# 保持猴子在板上

如果游戏中没有失败的风险，那还有什么乐趣？为了测试我们的猴子和倾斜控制，我们在基本环境周围设置了一个安全围栏，防止它们翻倒。然而，每个游戏都需要一点风险来增加刺激感。通过移除安全围栏，我们引入了翻倒和游戏失败的风险。但是，通常如果你掉落了，会有重试游戏的选择。为此，我们现在将创建一个传统上称为**kill** **volume**的区域。这只是一个在玩家掉入时重置玩家的区域。让我们按照以下步骤来创建它：

1.  首先，创建一个新脚本并将其命名为`KillVolume`。

1.  这个脚本有一个单一变量。它将跟踪猴子球掉入后放置的位置：

    ```java
    public Transform respawnPoint;
    ```

1.  这个脚本还有一个单一函数`OnTriggerEnter`。每当具有**Rigidbody**组件的对象进入触发器体积时，都会调用此函数。它接收进入的对象作为碰撞器：

    ```java
    public void OnTriggerEnter(Collider other) {
    ```

1.  该函数简单地将进入体积的物体的位置更改为我们想要重新生成它的点的位置。我们游戏中唯一会移动的是猴子球，所以我们不需要担心检查进入的是什么。我们还设置了`velocity`为`zero`，这样当玩家重新获得控制时，它就不会突然移动：

    ```java
    other.transform.position = respawnPoint.position;
    other.attachedRigidbody.velocity = Vector3.zero;
    }
    ```

1.  接下来，我们需要一个名为`RespawnPoint`的新空**GameObject**。

1.  将此对象定位在我们球开始的大致位置。这是球在掉出场地后将被放置的点。

1.  现在，创建另一个空的**GameObject**并将其命名为`KillVolume`。当玩家掉入该对象时，它将捕捉并重置游戏。

1.  将其位置设置为**Y 轴**的`-10`，**X 轴和 Z 轴**的`0`。这将使其位于玩家将要到达的位置下方。对于未来关卡来说，重要的是这个体积位于玩家通常所在位置的下方。如果不是这样，他们可能会错过它，永远下落，或者突然跳回到起点，在前往他们应该到达的区域时穿过它。

1.  我们需要给对象一个**盒子碰撞器**组件，并附加我们的`KillVolume`脚本。

1.  为了让 Unity 调用`OnTriggerEnter`函数，我们需要勾选**是触发器**的选项。否则，它将与体积碰撞，玩家看起来就像是漂浮着。

1.  接下来，我们需要使体积足够大，以便在玩家掉入时能够捕捉到他们。为此，将**盒子碰撞器**组件的**大小**设置为**X 轴和 Z 轴**的`100`。

1.  将**层次结构**窗口中的`RespawnPoint`对象拖到**检查器**中的`KillVolume`脚本组件的**重生点**槽上。如果没有它，玩家在掉出地图后将无法返回。

1.  最后，从我们的基础环境中删除`Fence`立方体，这样我们就可以测试一下了。你可以移动球体，当它从地面方块掉落时，会撞击`KillVolume`并返回到`RespawnPoint`位置。保持猴子在板上

现在我们能够在玩家掉出地图时重置他们。重要的是要检测他们何时不再在地图上，并且在应该重置时不要打断他们。这就是为什么我们做得这么大，并将其放在关卡主要区域的下方。但是，将体积放置得太远低于游戏区域是一个坏主意，否则玩家在游戏重置之前会下落很长时间。

# 赢得或失去游戏

既然我们已经具备了移动和如果掉出地图就重置的能力，我们只需要找到一种方法来赢得或输掉游戏。这种类型的游戏传统上是根据你从地图一端移动到另一端的速度来判定的。如果你在计时器耗尽之前未能到达终点，那么游戏就结束了。让我们按照以下步骤为游戏创建一个终点线和计时器：

1.  我们需要一个新的名为`VictoryVolume`的脚本。

1.  我们首先用一对变量来跟踪玩家的信息。如果玩家在限定时间内到达终点，第一个变量将被激活并展示给玩家。第二个变量只有在时间耗尽时才会显示：

    ```java
    public GameObject victoryText;
    public GameObject outOfTimeText;
    ```

1.  下一个变量将跟踪 GUI 中的`Text`对象，以显示完成关卡剩余的当前时间：

    ```java
    public Text timer;
    ```

1.  这个变量用于设置玩家完成关卡可用的时间，单位为秒。在为大型版本的游戏调整**检查器**面板时，最好让多人测试关卡，以便了解完成关卡需要多长时间：

    ```java
    public float timeLimit = 60f;
    ```

1.  脚本最后一个变量将简单地跟踪计时器是否能够倒计时。通过将其设置为`private`并默认为`true`，计时器将从关卡加载的那一刻开始计时：

    ```java
    private bool countDown = true;
    ```

1.  脚本第一个函数是`Awake`，这是初始化的最佳位置。它只做一件事，就是关闭两个消息。稍后我们会根据玩家的表现开启相应的消息：

    ```java
    public void Awake() {
      victoryText.SetActive(false);
      outOfTimeText.SetActive(false);
    }
    ```

1.  为了检测玩家是否越过终点线，我们将使用与`KillVolume`脚本相同的`OnTriggerEnter`函数。不过，首先我们会检查是否仍在为玩家计时。如果我们不再为他们计时，那么他们肯定已经用完了时间并且失败了。因此，我们不应该让他们越过终点线并获得胜利：

    ```java
    public void OnTriggerEnter(Collider other) {
      if(countDown) {
    ```

1.  接下来，我们开启告知玩家他们已经获胜的文本。我们总得让他们知道胜利了，现在就是合适的时候：

    ```java
    victoryText.SetActive(true);
    ```

1.  函数接下来要做的是本质上关闭猴子球的物理效果，防止它继续滚动。通过使用`attachedRigidbody`，我们访问到与物体连接的**Rigidbody**组件，这是连接到 Unity 物理引擎的部分。然后，我们将它的`isKinematic`属性设置为`true`，基本上告诉它将由脚本控制，而不是由物理引擎控制：

    ```java
    other.attachedRigidbody.isKinematic = true;
    ```

1.  最后，该函数停止计算玩家的剩余时间：

    ```java
    countDown = false;
    }
    }
    ```

1.  脚本的最后一个函数是`Update`函数，它首先检查以确保计时器正在运行：

    ```java
    public void Update() {
      if(countDown) {
    ```

1.  然后它从完成关卡剩余的时间中减去自上一帧以来的时间：

    ```java
    timeLimit -= Time.deltaTime;
    ```

1.  接下来，我们在屏幕上更新剩余的时间。屏幕上的文本必须是字符串形式，或者说是文字。像我们剩余的时间这样的数字并不是文字，所以我们使用`ToString`函数将其转换为正确的数据类型以便显示。如果仅此而已，那也是可以的，但它会显示一堆玩家不会关心的额外小数位。因此，我们传递`0.00`给函数。我们告诉它当数字变成文字时，我们希望它具有的格式和有多少个小数位。这使得它对玩家更有意义，也更容易阅读：

    ```java
    timer.text = timeLimit.ToString("0.00");
    ```

1.  在检查玩家是否超时后，我们开启告知他们已经失败的文本，并关闭时间显示。同时我们也停止计时。如果他们已经超时，继续计时又有什么意义呢？

    ```java
    if(timeLimit <= 0) {
      outOfTimeText.SetActive(true);
      timer.gameObject.SetActive(false);
      countDown = false;
    }
    }
    }
    ```

1.  现在，我们需要回到 Unity，让这个脚本工作。首先创建一个新的空**GameObject**，并将其命名为`VictoryPoint`。

1.  它将需要三个子立方体。记住，你可以通过导航到**GameObject** | **3D Object** | **Cube**来找到它们。

1.  第一个方块应定位在**X**为`1`，**Y**为`1`，**Z**为`0`的位置。此外，将其缩放为**X**为`0.25`，**Y**为`2`，**Z**为`0.25`。

1.  第二个方块应具有与第一个相同的所有设置，除了**X**的位置为`-1`，这会将它移动到对象的另一侧。

1.  最后一个方块需要**X**为`0`，**Y**为`2.5`，**Z**为`0`的位置。它的缩放比例需要设置为**X**为`2.25`，**Y**为`1`，**Z**为`0.25`。这这三个方块共同构成了一个基本外观的终点线，它将突出于游戏板的其他部分。

1.  接下来，我们需要为 GUI 创建一些文本对象。通过导航到**GameObject** | **UI** | **Text**来创建三个对象。

1.  第一个应命名为`Timer`；这将处理显示，显示玩家到达终点线还剩多少时间。它需要锚定在**左上角**，**Pos X**为`80`，**Pos Y**为`-20`。它还需要**宽度**为`130`，**高度**为`30`。我们可以将默认文本更改为`0.00`，以便我们更好地了解在游戏中它的样子。**字体大小**为`20`和**对齐方式**为**左中**将为我们很好地定位它。

1.  第二个文本对象应命名为`Victory`；当玩家到达终点线时，它将显示消息。它需要锚定在**居中**，**Pos X**和**Pos Y**为`0`。它需要**宽度**为`200`和**高度**为`60`，这样我们就有足够的空间绘制消息。将默认文本更改为`You Win!`，将**字体大小**增加到`50`，并选择**居中对齐**，以便我们在屏幕中央获得一个清晰的大消息。

1.  最后一个文本对象应命名为`OutOfTime`；当玩家在计时器归零前未能到达终点时，它将显示消息。除了**宽度**需要设置为`500`以适应其更大的默认文本`You Ran Out Of Time!`外，它与其他对象共享所有相同的设置。

1.  接下来，我们需要选择`VictoryPoint`并为其添加**BoxCollider**组件，以及我们的`VictoryVolume`脚本。

1.  **BoxCollider**组件需要勾选**Is Trigger**复选框。**中心**的**X**需要`0`，**Y**需要`1`，**Z**需要`0`。此外，**大小**的**X**应为`1.75`，**Y**应为`2`，**Z**应为`0.25`。

1.  最后，将我们刚刚创建的每个文本对象拖动到**VictoryVolume**脚本组件上的适当槽位。![游戏的胜利与失败](img/4691OT_06_07.jpg)

我们刚刚完成了一个设定，玩家可以通过这个设定赢得或输掉游戏。如果你现在尝试一下，你应该能在屏幕左上角看到计时器倒计时。当你及时到达终点线时，会显示一条好消息来提示你。如果你没能成功到达，则会显示另一条消息。

这是我们将为这款游戏创建的整个界面，但它仍然相当乏味。利用你在第二章中学到的技能，*看起来不错——图形界面*来设计界面。它应该看起来令人愉悦和兴奋，甚至可以是猴子主题的。为了使其更高级，你可以尝试设置它，让剩余时间接近零时改变颜色和大小，让玩家一眼就能看出完成该关卡剩余的时间。

终点线看起来也很单调，因为它只是由方块组成。尝试自己创建一个新的终点线。它可以在上面横幅上有一个终点线标志，就像比赛中的那样。也许它可以看起来更圆润一些。如果你想让它更高级，你可以考虑在终点线前面创建第二个计时器。这样玩家可以看着世界，他们的主要焦点在这里，并知道剩余的时间。

# 组装复杂的环境。

一个方块地图并不能提供很有趣的游戏体验。它非常适合我们设置控制，但玩家会觉得这并不有趣。因此，我们需要一些更好的东西。在这里，我们将设置一个更复杂的环境，包括斜坡、桥梁和弯道。我们还将使用一些围栏来帮助和引导玩家。让我们按照以下步骤进行：

1.  首先，将`MonkeyBallMap`模型添加到场景中。

1.  将其**缩放**属性在每个轴上设置为`100`，并将其**位置**属性在每个轴上设置为`0`。

1.  如果地图看起来是白色的，那么为其应用`Grass`纹理。这个地图为我们提供了一个良好的起点平台，一个半管斜坡，几个弯道，以及一座短桥。总的来说，玩家将面临许多基本挑战。

1.  为了让我们的球能够实际使用这个地图，它需要一些碰撞器来使其具有物理特性。在**层次结构**窗口中展开`MonkeyBallMap`，并选择`FlatBits`和`HalfPipe`。

1.  在这些对象上添加一个**网格碰撞器**组件，就像我们为坦克城市的某些部分所做的那样。记住，可以通过导航到**组件** | **物理** | **网格碰撞器**来找到它。

1.  接下来，我们有`Fence`模型。通过这个模型，我们可以在边缘放置护栏或者在玩家路径中设置障碍来帮助或阻碍玩家。首先将`Fence`模型拖入场景，并将其**缩放**设置为`100`，以保持与地图的比例。

1.  为了使围栏能够物理地阻挡玩家，它们需要一个碰撞器。对于两个子围栏对象，添加一个 **BoxCollider** 组件，可以通过导航到 **组件** | **物理** | **盒碰撞器** 来找到。

1.  此外，如果围栏在场景中显示为白色，请确保你将 `Wood` 文理应用到两个围栏部件上。

1.  创建一个新的空 **GameObject** 并将其命名为 `Fences`。然后，将其 **位置** 属性在每一个轴上设置为 `0`。这个对象将帮助我们保持组织有序，因为最终我们可能会有很多围栏部件。

1.  现在，在 **层次结构** 窗口中展开 `Fence` 模型，并使 `Post` 和 `PostWithSpokes` 成为 `Fences` 空的 **GameObject** 的子对象。然后，删除 `Fence` 对象。这样做，我们打破了预制体的连接，消除了重新创建它的风险。如果我们只是用 `Fence` 对象来组织，那么如果我们对原始模型文件进行更改，就有可能删除我们在场景中设置它们时所做的一切工作。

1.  我们需要将围栏放置在战略位置，以影响玩家玩游戏的方式。我们可能想要放置它们的第一个地方是起始区域周围，为玩家提供一个游戏开始的良好安全环境。记住，你可以使用 *Ctrl* + *D* 来复制围栏部件，这样你就总会有足够的围栏。![组装复杂环境](img/4691OT_06_08.jpg)

1.  放置围栏的第二个地方是在半管之后，正好在桥前。在这里，它们可以帮助玩家在尝试过小桥之前重新定位自己：![组装复杂环境](img/4691OT_06_09.jpg)

1.  我们可以放置围栏的最后一个地方可能会阻碍玩家。如果我们把它们放在最后平台的中间，我们就会迫使玩家绕行，并在到达终点前冒着跌落的危险。

1.  说到终点线，现在其他一切都已布置完毕，我们需要将其移至适当位置。将其放置在较低平台的末端。在这里，玩家必须面对地图上的所有挑战，并在最终达成胜利前多次冒着跌落的危险。![组装复杂环境](img/4691OT_06_10.jpg)

这就是设置我们复杂环境的全部内容。我们让玩家有机会在强制他们导航一系列挑战并到达终点之前先定位自己。试一试吧。我们的游戏看起来真的很不错。

这里的第一个挑战可能相当明显。尝试自己制作一个带有坡道、桥梁、滑梯和障碍的地图。你可能可以用围栏制作一个大型迷宫。否则，你可以改变关卡，使其实际上要求玩家沿着一些直线路径和坡道向上，这意味着玩家需要足够速度来完成。可能还需要进行几次跳跃。让玩家沿着坡道下滑以获得速度，然后跳到另一个平台上。无论你的新关卡变成什么样，确保`KillVolume`在它的下方，并且覆盖足够大的区域。你永远不知道玩家会如何玩，以及他们会如何卡住自己。

地图本身看起来很不错，但周围的区域还需要加工。利用你之前章节学到的技能——为世界添加一个天空盒，比默认的看起来更好。同时，调整一下光线。一个单一的**定向光**不错，但不够有趣。创建一些光源模型放置在地图周围。然后，烘焙光照贴图以产生一些高质量的阴影。

# 添加香蕉

当涉及到猴子游戏时，玩家最明显要收集的物品就是香蕉。然而，仅仅在世界上拥有可收集的物品是不够的；我们还得向玩家展示这些物品是可以被收集的。通常，这意味着物品在旋转、弹跳、发光、产生火花或展示其他特殊效果。对于我们的游戏，我们将使香蕉在原地旋转的同时上下弹跳。下面是完成这个效果的步骤：

1.  首先，我们需要一个新的脚本。创建一个并命名为`BananaBounce`。

1.  这个脚本从三个变量开始。第一个是香蕉上下移动的速度，单位是每秒米。第二个是香蕉从起始位置会移动多高。第三个是香蕉每秒在原地旋转多少度。这些变量共同使我们能够轻松控制和调整香蕉的运动：

    ```java
    public float bobSpeed = 1.5f;
    public float bobHeight = 0.75f;
    public float spinSpeed = 180f;
    ```

1.  下一个变量将跟踪实际移动的对象。通过使用两个对象来设置和控制香蕉，我们能够将位置和旋转分离，使一切变得更容易：

    ```java
    public Transform bobber;
    ```

1.  这个脚本的函数是`Update`。它首先检查以确保我们的`bobber`变量已被填充。如果没有它，我们就无法进行操作使香蕉移动：

    ```java
    public void Update() {
      if(bobber != null) {
    ```

1.  接下来，我们使用`PingPong`函数为我们的香蕉计算一个新位置。这个函数会在零和传递给它的第二个值之间反弹一个值。在这个案例中，我们使用当前时间乘以我们的速度来确定在这场游戏中香蕉可能移动了多远。通过给它一个高度，我们得到一个从零到我们最大高度来回移动的值。然后我们将其乘以一个向上向量，并将其应用到我们的`localPosition`上，使香蕉能够上下移动：

    ```java
      float newPos = Mathf.PingPong(Time.time * bobSpeed, bobHeight);
      bobber.localPosition = Vector3.up * newPos;
    }
    ```

1.  最后，我们使用之前用于旋转炮塔的同一个`Rotate`函数，让香蕉在原地旋转。它会以我们设定的任何速度不断旋转。

    ```java
    transform.Rotate(Vector3.up * Time.deltaTime * spinSpeed);
    }
    ```

1.  接下来，我们需要回到 Unity 并设置这些香蕉。为此，我们首先需要在场景中添加`Banana`模型。如果它是白色的，确保为其添加`Banana`纹理。

1.  要让新香蕉弹跳，需要添加我们的`BananaBounce`脚本，否则它就不会在那里弹跳。

1.  `Banana`的子对象需要放在我们脚本组件中的**Bobber**槽位上。

1.  然后，把它变成一个预制体，在地图上散布一些：在初始区域放几个，在终点线附近放几个，沿途也放一些。![添加香蕉](img/4691OT_06_11.jpg)

如果你现在尝试游戏，你应该会看到有几个快乐弹跳的香蕉。通过使用`Mathf.PingPong`函数，我们很容易就能创建这种效果。如果没有它，我们需要做很多额外的计算来确定我们是向上还是向下移动以及移动了多远。

收集香蕉作为收藏品很棒，但现在哪个游戏只有一种拾取物品呢？尝试制作一些其他拾取物品的模型。最明显的就是香蕉束，比如你在杂货店可以买到的那些，或者是实际长在香蕉树上的大串香蕉。不过，你还可以选择硬币、能量水晶、古老猴子图腾、检查点、分数乘数，或者任何可能吸引你注意的东西。

## 使用触摸收集香蕉

现代移动设备最明显的特点之一就是触摸屏。设备使用用户的指尖电导性和许多微小的接触点来确定被触摸的位置。为了探索我们的游戏触摸界面的可能性，我们将让玩家戳屏幕上的香蕉，而不是跑过去收集它们。Unity 为我们提供了轻松访问触摸输入的方法。通过将输入与射线投射结合，就像我们之前让坦克开火一样，我们可以确定 3D 空间中被用户触摸的物体。对于我们来说，这意味着我们可以让玩家触摸并收集那些香蕉。要做到这一点，请按照以下步骤操作：

1.  首先，我们需要一个新脚本。创建一个，并将其命名为`BananaTouch`。

1.  `Update`函数是这段脚本中唯一的函数。它首先检查玩家是否以任何方式触摸屏幕。`Input`类为我们提供了`touchCount`值，这只是一个计数器，用来记录当前触摸设备屏幕的手指数量。如果没有手指触摸，我们不想浪费时间做任何工作，所以我们会提前退出`return`：并准备好再次检查下一帧，看玩家是否触摸了屏幕。

    ```java
    public void Update() {
      if(Input.touchCount <= 0) return;
    ```

1.  接下来，我们创建一个`foreach`循环。这是一个将检查触摸列表中的每个项目的循环，但它不会跟踪触摸的索引。然后我们检查每个触摸的阶段，以判断它是否刚刚开始触摸屏幕。每个触摸都有五个可能的状态：**开始**，**移动**，**静止**，**结束**和**已取消**：

    ```java
    foreach(Touch next in Input.touches) {
      if(next.phase == TouchPhase.Began) {
    ```

    这里是每个状态的描述：

    +   **开始**：当用户首次触摸屏幕时，会进入此触摸阶段。

    +   **移动**：当用户在屏幕上移动手指时，会进入此触摸阶段。

    +   **静止**：此触摸阶段与上一个阶段相反；当用户的 finger 在屏幕上不移动时发生。

    +   **结束**：当用户的手指离开屏幕时，会进入此触摸阶段。这是触摸完成的正常方式。

    +   **已取消**：当跟踪触摸时发生错误时，会进入此触摸阶段。这种阶段通常在手指触摸屏幕但不移动一段时间后最常发生。触摸系统并不完美，所以它会假设错过了手指离开屏幕的动作，并取消该触摸。

1.  接下来，我们创建一对变量。就像我们的坦克一样，第一个变量用于保存被我们的射线投射命中的对象。第二个是一个`Ray`类型的变量，它只是一个用于存储空间中的一个点和方向向量的容器。`ScreenPointToRay`函数是相机专门提供的，用于将屏幕上 2D 空间的触摸位置转换为游戏世界中 3D 空间的位置：

    ```java
    RaycastHit hit;
    Ray touchRay = Camera.main.ScreenPointToRay(next.position);
    ```

1.  函数的最后一步是调用`Raycast`函数。我们将射线和跟踪变量传递给该函数。如果击中了对象，我们向它发送一个消息，告诉它已被触摸，就像用我们的坦克射击东西一样。此外，还需要几个花括号来结束`if`语句、循环和函数：

    ```java
          if(Physics.Raycast(touchRay, out hit)) {
            hit.transform.gameObject.SendMessage("Touched", SendMessageOptions.DontRequireReceiver);
          }
        }
      }
    }
    ```

1.  在尝试之前，我们需要更新我们的`BananaBounce`脚本，为其添加一些生命值，并在生命值耗尽时允许其被摧毁。所以，现在就打开它吧。

1.  首先，我们需要一对变量。第一个是`health`。实际上，这只是摧毁香蕉所需的触摸次数。如果我们有不同类型的香蕉，它们可以各有不同的生命值。第二个变量是香蕉移动速度的调节器。每次香蕉失去生命值，它的移动速度就会减慢，表明它还剩下多少生命值：

    ```java
    public int health = 3;
    public float divider = 2f;
    ```

1.  接下来，我们需要添加一个新函数。这个`Touched`函数将接收来自我们的`BananaTouch`脚本的消息。它的工作原理类似于我们用坦克射击的方式。它做的第一件事是减少剩余的生命值：

    ```java
    public void Touched() {
      health--;
    ```

1.  在造成一些伤害之后，我们可以通过进行一些除法运算来减慢香蕉的移动速度。这样玩家就能轻松判断他们的触摸是否成功：

    ```java
      bobSpeed /= divider;
      spinSpeed /= divider;
    ```

1.  最后，函数会检查香蕉是否已经耗尽生命值。如果是，我们使用`Destroy`函数来移除它，就像敌方坦克一样：

    ```java
      if(health <= 0) {
        Destroy(gameObject);}
    }
    ```

1.  当你回到 Unity 时，需要将我们新的`BananaTouch`脚本附加到`MonkeyBall`对象上。由于它的工作原理，它实际上可以放在任何对象上，但最好是将玩家控制脚本保持在一起，并放在它们所控制的对象上。

1.  接下来，为其中一个香蕉添加一个**球体碰撞器**组件，你可以通过导航到**组件** | **物理** | **球体碰撞器**来找到它。如果我们对一个进行更改并更新预制体，场景中的所有香蕉都将被更新。

1.  勾选**是触发器**复选框，这样香蕉就不会阻挡我们猴子的移动。它们仍然可以被触摸，同时允许我们的猴子穿过它们。

1.  碰撞器还需要被放置在玩家在击中时通常会触摸的位置。因此，将**中心**设置为**X**的`0`，**Y**的`0.375`，**Z**的`0`。此外，确保将**半径**设置为`0.5`。

1.  最后，确保点击**应用**按钮，位于**检查器**面板右上角，以更新场景中的所有香蕉。![使用触摸收集香蕉](img/4691OT_06_12.jpg)

现在尝试游戏，你应该能够触摸任何香蕉。最初，所有香蕉会像之前一样均匀地上下移动。当你触摸它们时，由于我们做的除法运算，你触摸的香蕉会移动得慢一些，然后最终消失。这让我们的玩家能够轻松地看出哪些香蕉被触摸过，哪些没有。

在游戏中拥有可收集物体之后，下一步是给玩家赋予意义。这通常是通过给它们一些积分值来实现的。在这里尝试这样做。它与我们之前摧毁敌方坦克时的积分系统非常相似。如果你之前创建了一些其他的收集物，你可以设置它们每个拥有不同的生命值。因此，它们也可以给你不同的积分。调整数字和设置，直到找到玩家互动起来会感到有趣的东西。

# 总结

在本章中，我们了解了现代移动设备的特点。我们创建了一个猴子球游戏来尝试这个功能。我们访问了设备的陀螺仪来检测它何时被旋转。这让我们的猴子能够被引导。在为玩家创建了一个更复杂、更有趣的运动环境后，我们创建了一串会原地旋转同时上下浮动的香蕉。我们还利用触摸屏让玩家能够收集香蕉。

在下一章中，我们将暂时放下我们的猴子球游戏。市场上最受欢迎的移动游戏之一，愤怒的小鸟，是一种独特且并不罕见的游戏类型。为了了解 Unity 中的物理学以及 2D 风格游戏的可能性，我们将制作一个愤怒的小鸟克隆版。我们还将探讨视差滚动，以帮助我们创建一个令人愉悦的背景。在你意识到之前，我们将创造出所有你一直希望玩到的愤怒的小鸟关卡。
