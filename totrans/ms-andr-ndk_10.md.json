["```java\nstruct sBitmapButton\n{\n  ivec4 FColour;\n  int FIndex;\n};\n```", "```java\nstruct sBitmapAxis\n{\n  float FRadius;\n  vec2 FPosition;\n  int FAxis1, FAxis2;\n  ivec4 FColour;\n};\n```", "```java\nclass ScreenJoystick: public iIntrusiveCounter\n{\npublic:\n  std::vector<sBitmapButton> FButtonDesc;\n  std::vector<sBitmapAxis> FAxisDesc;\n  std::vector<float> FAxisValue;\n  std::vector<bool> FKeyValue;\n```", "```java\n  clPtr<clBitmap> FMaskBitmap;\npublic:\n  ScreenJoystick()\n  {}\n```", "```java\n  void InitKeys()\n  {\n    FKeyValue.resize( FButtonDesc.size() );\n    if ( FKeyValue.size() > 0 )\n    {\n      for ( size_t j = 0 ; j < FKeyValue.size() ; j++ ) { FKeyValue[j] = false; }\n    }\n    FAxisValue.resize( FAxisDesc.size() * 2 );\n    if ( FAxisValue.size() > 0 )\n    {\n      memset( &FAxisValue[0], 0, FAxisValue.size() * sizeof( float ) );\n    }\n  }\n```", "```java\n  void Restart()\n  {\n    memset( &FPushedAxis[0], 0, sizeof( sBitmapAxis* ) * MAX_TOUCH_CONTACTS );\n    memset( &FPushedButtons[0], 0, sizeof( sBitmapButton* ) * MAX_TOUCH_CONTACTS );\n  }\n```", "```java\n  bool IsPressed( int KeyIdx ) const\n  {\n    return ( KeyIdx < 0 || KeyIdx >= ( int )FKeyValue.size() ) ? false : FKeyValue[KeyIdx];\n  }\n```", "```java\n  float GetAxisValue( int AxisIdx ) const\n  {\n    return ( ( AxisIdx < 0 ) || AxisIdx >= ( int )FAxisValue.size() ) ? 0.0f : FAxisValue[AxisIdx];\n  }\n```", "```java\n  void SetKeyState( int KeyIdx, bool Pressed )\n  {\n    if ( KeyIdx < 0 || KeyIdx >= ( int )FKeyValue.size() )\n    { return; }\n    FKeyValue[KeyIdx] = Pressed;\n  }\n  void SetAxisValue( int AxisIdx, float Val )\n  {\n    if ( AxisIdx < 0 || AxisIdx >= static_cast<int>( FAxisValue.size() ) )\n    { return; }\n    FAxisValue[AxisIdx] = Val;\n  }\n```", "```java\n  sBitmapButton* GetButtonForColour( const ivec4& Colour )\n  {\n    for ( size_t k = 0 ; k < FButtonDesc.size(); k++ )\n    if ( FButtonDesc[k].FColour == Colour )\n    return &FButtonDesc[k];\n    return nullptr;\n  }\n```", "```java\n  sBitmapAxis* GetAxisForColour( const ivec4& Colour )\n  {\n    for ( size_t k = 0 ; k < FAxisDesc.size(); k++ )\n    {\n      if ( FAxisDesc[k].FColour == Colour )\n      { return &FAxisDesc[k]; }\n    }\n    return nullptr;\n  }\n```", "```java\npublic:\n  sBitmapButton* FPushedButtons[MAX_TOUCH_CONTACTS];\n  sBitmapAxis* FPushedAxis[MAX_TOUCH_CONTACTS];\n  void ReadAxis( sBitmapAxis* Axis, const vec2& Pos )\n  {\n    if ( !Axis ) { return; }\n```", "```java\n    float v1 = ( Axis->FPosition - Pos ).x / Axis->FRadius;\n    float v2 = ( Pos - Axis->FPosition ).y / Axis->FRadius;\n    this->SetAxisValue( Axis->FAxis1, v1 );\n    this->SetAxisValue( Axis->FAxis2, v2 );\n  }\n};\n```", "```java\nvoid ScreenJoystick::HandleTouch( int ContactID, const vec2& Pos, bool Pressed, eMotionFlag Flag )\n{\n  if ( ContactID == L_MOTION_START )\n  {\n    for ( size_t i = 0; i != MAX_TOUCH_CONTACTS; i++ )\n    {\n      if ( FPushedButtons[i] )\n      {\n        this->SetKeyState( FPushedButtons[i]->FIndex, false );\n        FPushedButtons[i] = nullptr;\n      }\n      if ( FPushedAxis[i] )\n      {\n        this->SetAxisValue( FPushedAxis[i]->FAxis1, 0.0f );\n        this->SetAxisValue( FPushedAxis[i]->FAxis2, 0.0f );\n        FPushedAxis[i] = nullptr;\n      }\n    }\n    return;\n  }\n  if ( ContactID == L_MOTION_END )\n  { return; }\n  if ( ContactID < 0 || ContactID >= MAX_TOUCH_CONTACTS )\n  { return; }\n```", "```java\n  if ( Flag == L_MOTION_DOWN || Flag == L_MOTION_MOVE )\n  {\n    int x = (int)(Pos.x * (float)FMaskBitmap->GetWidth());\n    int y = (int)(Pos.y * (float)FMaskBitmap->GetHeight());\n    ivec4 Colour = FMaskBitmap->GetPixel(x, y);\n    sBitmapButton* Button = GetButtonForColour( Colour );\n    sBitmapAxis* Axis = GetAxisForColour( Colour );\n    if ( Button && Pressed )\n    {\n      // touchdown, set the key\n      int Idx = Button->FIndex;\n      this->SetKeyState( Idx, true );\n```", "```java\n      FPushedButtons[ContactID] = Button;\n    }\n    if ( Axis && Pressed )\n    {\n      this->ReadAxis( Axis, Pos );\n      FPushedAxis[ContactID] = Axis;\n    }\n  }\n}\n```", "```java\nstruct sParticle\n{\n  sParticle(): FPosition(),\n  FVelocity(),\n  FAcceleration(),\n  FLifeTime( 0.0f ),\n  FTTL( 0.0f ),\n  FRGBA( 1.0f, 1.0f, 1.0f, 1.0f ),\n  FSize( 0.5f )\n  {};\n  LVector3    FPosition;             // current position\n  LVector3    FVelocity;             // current velocity\n  LVector3    FAcceleration;         // current acceleration\n  float       FLifeTime;             // total life time\n  float       FTTL;                  // time to live left\n  LVector4    FRGBA;                 // overlay color\n  float       FSize;                 // particle size\n};\n```", "```java\nclass clParticleSystem: public iIntrusiveCounter\n{\nprivate:\n  clPtr<clVertexAttribs> FVertices;\n  std::vector<sParticle> FParticles;\n  sMaterial FMaterial;\n  int FCurrentMaxParticles;\n```", "```java\npublic:\n  clParticleSystem(): FCurrentMaxParticles( 100 )\n  {\n    const int VerticesPerParticle = 6;\n    FVertices = make_intrusive<clVertexAttribs>( VerticesPerParticle * FCurrentMaxParticles );\n```", "```java\n    FMaterial.m_MaterialClass = \"Particle\";\n  }\n  virtual void AddParticle( const sParticle& Particle )\n  {\n    FParticles.push_back( Particle );\n```", "```java\n    if ( FCurrentMaxParticles <\n      static_cast<int>( FParticles.size() ) )\n    {\n      SetMaxParticles(int(FCurrentMaxParticles * 1.2f));\n    }\n  }\n```", "```java\n  void SetMaxParticles( int MaxParticles );\n```", "```java\n  virtual std::vector<sParticle>& GetParticles()\n  { return FParticles; }\n  virtual clPtr<clVertexAttribs> GetVertices() const\n  { return FVertices; }\n  virtual const sMaterial& GetDefaultMaterial() const\n  { return FMaterial; }\n  virtual sMaterial& GetDefaultMaterial() { return FMaterial; }\n```", "```java\n  virtual void UpdateParticles( float DeltaSeconds );\n};\n```", "```java\nvoid clParticleSystem::SetMaxParticles( int MaxParticles )\n{\n  FCurrentMaxParticles = MaxParticles;\n```", "```java\n  const int VerticesPerParticle = 6;\n  FParticles.reserve( FCurrentMaxParticles );\n  FVertices = make_intrusive<clVertexAttribs>\n    ( VerticesPerParticle * MaxParticles );\n  vec2* Vec = FVertices->FTexCoords.data();\n```", "```java\n  for ( int i = 0; i != MaxParticles; ++i )\n  {\n    int IdxI = i * 6;\n    Vec[IdxI + 0] = vec2( 0.0f, 0.0f );\n    Vec[IdxI + 1] = vec2( 1.0f, 0.0f );\n    Vec[IdxI + 2] = vec2( 1.0f, 1.0f );\n    Vec[IdxI + 3] = vec2( 0.0f, 0.0f );\n    Vec[IdxI + 4] = vec2( 1.0f, 1.0f );\n    Vec[IdxI + 5] = vec2( 0.0f, 1.0f );\n  }\n}\n```", "```java\nvoid clParticleSystem::UpdateParticles( float DeltaSeconds )\n{\n  vec3* Vec = FVertices->FVertices.data();\n  vec3* Norm = FVertices->FNormals.data();\n  vec4* RGB = FVertices->FColors.data();\n  size_t NumParticles = FParticles.size();\n  for ( size_t i = 0; i != NumParticles; ++i )\n  {\n    sParticle& P = FParticles[i];\n    P.FTTL -= DeltaSeconds;\n```", "```java\n    if ( P.FTTL < 0 )\n    {\n      P = FParticles.back();\n      FParticles.pop_back();\n      NumParticles--;\n      i--;\n      continue;\n    }\n```", "```java\n    P.FVelocity += P.FAcceleration * DeltaSeconds;\n    P.FPosition += P.FVelocity * DeltaSeconds;\n```", "```java\n    LVector3 TTL = LVector3( P.FTTL, P.FLifeTime, P.FSize );\n```", "```java\n    float NormalizedTime = (P.FLifeTime-P.FTTL) / P.FLifeTime;\n```", "```java\n    vec4 Color = P.FRGBA * GetParticleBrightness( NormalizedTime );\n```", "```java\n    size_t IdxI = i * 6;\n    for ( int j = 0; j < 6; j++ )\n    {\n      Vec [IdxI + j] = P.FPosition;\n      Norm[IdxI + j] = TTL;\n      RGB [IdxI + j] = Color;\n    }\n  }\n```", "```java\n  FVertices->SetActiveVertexCount ( 6 * static_cast<int>( FParticles.size() ) );\n}\n```", "```java\ninline float GetParticleBrightness( float NormalizedTime )\n{\n  const float Cutoff_Lo = 0.1f;\n  const float Cutoff_Hi = 0.9f;\n  if ( NormalizedTime < Cutoff_Lo )\n  {\n    return NormalizedTime / Cutoff_Lo;\n  }\n  if ( NormalizedTime > Cutoff_Hi )\n  {\n    return 1.0f - ( ( NormalizedTime - Cutoff_Hi ) / ( 1.0f - Cutoff_Hi ) );\n  }\n  return 1.0f;\n}\n```", "```java\nclass iParticleEmitter: public iIntrusiveCounter\n{\npublic:\n  iParticleEmitter():\n  FColorMin( 0 ), FColorMax( 1 ),\n  FSizeMin( 0.5f ), FSizeMax( 1.0f ),\n  FVelMin( 0 ), FVelMax( 0 ),\n  FMaxParticles( 1000 ),\n  FEmissionRate( 100.0f ),\n  FLifetimeMin( 1.0f ), FLifetimeMax( 60.0f ),\n  FInvEmissionRate( 1.0f / FEmissionRate ),\n  FAccumulatedTime( 0.0f )\n  {}\n  virtual void EmitParticles( const clPtr<clParticleSystem>& PS, float DeltaTime ) const = 0;\n```", "```java\npublic:\n  vec4 FColorMin, FColorMax;\n  float FSizeMin, FSizeMax;\n  vec3 FVelMin, FVelMax;\n  size_t FMaxParticles;\n  float FEmissionRate;\n  float FLifetimeMin, FLifetimeMax;\nprotected:\n  float FInvEmissionRate;\n  mutable float FAccumulatedTime;\n};\n```", "```java\nclass clParticleEmitter_Box: public iParticleEmitter\n{\npublic:\n  clParticleEmitter_Box(): FPosMin( 0 ), FPosMax( 1 ) {}\n  virtual void EmitParticles( const clPtr<clParticleSystem>& PS, float DeltaTime ) const override\n  {\n    FAccumulatedTime += DeltaTime;\n```", "```java\n    while ( FAccumulatedTime > 1.0f / FEmissionRate && PS->GetParticles().size() < FMaxParticles )\n    {\n      FAccumulatedTime -= 1.0f / FEmissionRate;\n      sParticle P;\n      P.FPosition = Math::RandomVector3InRange( FPosMin, FPosMax );\n      P.FVelocity = Math::RandomVector3InRange( FVelMin, FVelMax );\n      P.FAcceleration = LVector3( 0.0f );\n      P.FTTL = Math::RandomInRange( FLifetimeMin, FLifetimeMax );\n      P.FLifeTime = P.FTTL;\n      P.FRGBA = Math::RandomVector4InRange( FColorMin, FColorMax );\n      P.FRGBA.w = 1.0f;\n      P.FSize = Math::RandomInRange(FSizeMin, FSizeMax);\n      PS->AddParticle( P );\n    }\n  }\npublic:\n  vec3 FPosMin, FPosMax;\n};\n```", "```java\nclass clParticleEmitter_Explosion: public iParticleEmitter\n{\npublic:\n  clParticleEmitter_Explosion()\n  : FEmitted( false ), FCenter( 0.0f )\n  , FRadialVelocityMin( 0.1f ), FRadialVelocityMax( 1.0f )\n  , FAcceleration( 0.0f )\n  {}\n```", "```java\n  virtual void EmitParticles( const clPtr<clParticleSystem>& PS,\n    float DeltaTime ) const override;\npublic:\n  mutable bool FEmitted;\n  vec3 FCenter;\n  float FRadialVelocityMin, FRadialVelocityMax;\n  vec3 FAcceleration;\n};\n```", "```java\nvoid clParticleEmitter_Explosion::EmitParticles( const clPtr<clParticleSystem>& PS, float DeltaTime ) const\n{\n  auto& Particles = PS->GetParticles();\n  size_t OriginalSize = Particles.size();\n```", "```java\n  for ( size_t i = 0; i != OriginalSize; i++ )\n  {\n    if ( Particles[i].FRGBA.w > 0.99f && Particles.size() < FMaxParticles )\n    {\n      sParticle P;\n      P.FPosition = Particles[i].FPosition;\n      P.FVelocity = Particles[i].FVelocity * Math::RandomVector3InRange( vec3(0.1f), vec3(1.0f) );\n      P.FAcceleration = FAcceleration;\n      P.FTTL = Particles[i].FTTL * 0.5f;\n      P.FLifeTime = P.FTTL;\n      P.FRGBA = Particles[i].FRGBA * Math::RandomVector4InRange( vec4(0.5f), vec4(0.9f) );\n      P.FRGBA.w = 0.95f;\n      P.FSize = Particles[i].FSize * Math::RandomInRange(0.1f, 0.9f);\n      PS->AddParticle( P );\n    }\n  }\n```", "```java\n  if ( FEmitted ) return;\n  FEmitted = true;\n```", "```java\n  for ( size_t i = 0; i != FEmissionRate; i++ )\n  {\n    sParticle P;\n```", "```java\n    float Theta = Math::RandomInRange( 0.0f, Math::TWOPI );\n    float Phi = Math::RandomInRange( 0.0f, Math::TWOPI );\n    float SinTheta = sin(Theta);\n    float x = SinTheta * cos(Phi);\n    float y = SinTheta * sin(Phi);\n    float z = cos(Theta);\n```", "```java\n    P.FPosition = FCenter;\n    P.FVelocity = vec3( x, y, z ).GetNormalized() * Math::RandomInRange( FRadialVelocityMin, FRadialVelocityMax );\n    P.FAcceleration = FAcceleration;\n```", "```java\n    P.FTTL = Math::RandomInRange( FLifetimeMin, FLifetimeMax );\n    P.FLifeTime = P.FTTL;\n    P.FRGBA = Math::RandomVector4InRange( FColorMin, FColorMax );\n    P.FRGBA.w = 1.0f;\n    P.FSize = Math::RandomInRange( FSizeMin, FSizeMax );\n    PS->AddParticle( P );\n  }\n}\n```", "```java\nclass clParticleSystemNode: public clMaterialNode\n{\nprivate:\n  std::vector< clPtr<iParticleEmitter> > m_Emitters;\n  clPtr<clParticleSystem> m_Particles;\n  clPtr<clGeometryNode> m_ParticlesNode;\npublic:\n  clParticleSystemNode();\n  virtual void UpdateParticles( float DeltaSeconds );\n  virtual clPtr<clParticleSystem> GetParticleSystem() const \n  { return m_Particles; };\n```", "```java\n  virtual void AddEmitter( const clPtr<iParticleEmitter>& E )\n  { m_Emitters.push_back(E); }\n  virtual void RemoveEmitter( const clPtr<iParticleEmitter>& E )\n  {\n    m_Emitters.erase( std::remove( m_Emitters.begin(), m_Emitters.end(), E ), m_Emitters.end() );\n  }\n  virtual clPtr<iParticleEmitter> GetEmitter( size_t i ) const\n  { return m_Emitters[i]; }\n  virtual void SetEmitter( size_t i, const clPtr<iParticleEmitter> E )\n  { m_Emitters[i] = E; }\n  virtual size_t GetTotalEmitters() const\n  { return m_Emitters.size(); }\n};\n```", "```java\nclParticleSystemNode::clParticleSystemNode()\n{\n  m_Particles = make_intrusive<clParticleSystem>();\n  size_t MaxParticles = 20000;\n  for ( const auto& i : m_Emitters )\n  {\n    if (i->FMaxParticles > MaxParticles)\n      MaxParticles = i->FMaxParticles;\n  }\n  m_Particles->SetMaxParticles( static_cast<int>(MaxParticles) );\n```", "```java\n  m_ParticlesNode = make_intrusive<clGeometryNode>();\n  m_ParticlesNode->SetVertexAttribs(m_Particles->GetVertices());\n  this->Add( m_ParticlesNode );\n```", "```java\n  this->SetMaterial( m_Particles->GetDefaultMaterial() );\n  UpdateParticles( 0.0f );\n}\n```", "```java\nvoid clParticleSystemNode::UpdateParticles( float DeltaSeconds )\n{\n  for ( const auto& i : m_Emitters )\n  {\n    i->EmitParticles( m_Particles, DeltaSeconds );\n  }\n  m_Particles->UpdateParticles( DeltaSeconds );\n  m_ParticlesNode->GetVA()->CommitChanges();\n}\n```", "```java\nclass clParticleMaterialSystem: public clMaterialSystem\n{\npublic:\n  clParticleMaterialSystem()\n  {\n    m_ParticleShaderPrograms[ ePass_Ambient ] = make_intrusive<clGLSLShaderProgram>( g_vShaderParticleStr, g_fShaderAmbientParticleStr );\n    m_ParticleShaderPrograms[ ePass_Light ] = make_intrusive<clGLSLShaderProgram>( g_vShaderParticleStr, g_fShaderLightParticleStr );\n    m_ParticleShaderPrograms[ ePass_Shadow ] = make_intrusive<clGLSLShaderProgram>( g_vShaderShadowParticleStr, g_fShaderShadowParticleStr );\n  }\n```", "```java\n  virtual clPtr<clGLSLShaderProgram> GetShaderProgramForPass( ePass Pass, const sMaterial& Mtl ) override\n  {\n    if ( Mtl.m_MaterialClass == \"Particle\" )\n    return m_ParticleShaderPrograms[ Pass ];\n    return clMaterialSystem::GetShaderProgramForPass( Pass, Mtl );\n  }\n```", "```java\nprivate:\n  std::map<ePass, clPtr<clGLSLShaderProgram>> m_ParticleShaderPrograms;\n};\n```", "```java\nstatic const char g_vShaderParticleStr[] = R\"(\n  uniform mat4 in_ModelViewProjectionMatrix;\n  uniform mat4 in_NormalMatrix;\n  uniform mat4 in_ModelMatrix;\n  uniform mat4 in_ModelViewMatrix;\n  uniform mat4 in_ShadowMatrix;\n  in vec4 in_Vertex;\n  in vec2 in_TexCoord;\n  in vec3 in_Normal;\n  in vec4 in_Color;\n  out vec2 v_Coords;\n  out vec3 v_Normal;\n  out vec3 v_WorldNormal;\n  out vec4 v_ProjectedVertex;\n  out vec4 v_ShadowMapCoord;\n  out vec3 v_Params;\n  out vec4 v_Color;\n```", "```java\n  mat4 GetProjScaleBiasMat()\n  {\n    // transform from -1..1 to 0..1\n    return mat4( \n      0.5, 0.0, 0.0, 0.0,\n      0.0, 0.5, 0.0, 0.0,\n      0.0, 0.0, 0.5, 0.0,\n      0.5, 0.5, 0.5, 1.0 );\n  }\n  void main()\n  {\n```", "```java\n    vec3 X = vec3( in_ModelViewMatrix[0][0], in_ModelViewMatrix[1][0], in_ModelViewMatrix[2][0] );\n    vec3 Y = vec3(in_ModelViewMatrix[0][1], in_ModelViewMatrix[1][1], in_ModelViewMatrix[2][1] );\n```", "```java\n    float SizeX = in_Normal.z;\n    float SizeY = in_Normal.z;\n```", "```java\n    vec3 XOfs = ( 2.0 * (in_TexCoord.x-0.5) * SizeX ) * X;\n    vec3 YOfs = ( 2.0 * (in_TexCoord.y-0.5) * SizeY ) * Y;\n    vec3 Position = in_Vertex.xyz + XOfs + YOfs;\n```", "```java\n    vec4 TransformedPos = in_ModelViewProjectionMatrix * vec4( Position, 1.0 );\n    gl_Position = TransformedPos;\n```", "```java\n    v_Coords = in_TexCoord.xy;\n    v_Normal = mat3(in_NormalMatrix) * in_Normal;\n    v_WorldNormal = ( in_ModelMatrix * vec4( in_Normal, 0.0 ) ).xyz;\n    v_ProjectedVertex = GetProjScaleBiasMat() * in_ModelViewProjectionMatrix * vec4(Position, 1.0);\n    v_ShadowMapCoord = in_ShadowMatrix * in_ModelMatrix * vec4(Position, 1.0);\n    v_Params = in_Normal;\n    v_Color  = in_Color;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderAmbientParticleStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Normal;\n  in vec3 v_WorldNormal;\n```", "```java\n  in vec3 v_Params;\n  in vec4 v_Color;\n  out vec4 out_FragColor;\n  uniform vec4 u_AmbientColor;\n  uniform vec4 u_DiffuseColor;\n  void main()\n  {\n    vec4 Color = v_Color * u_AmbientColor;\n    float NormalizedTime = (v_Params.y-v_Params.x) / v_Params.y;\n```", "```java\n    float Falloff = 1.0 - 2.0 * length(v_Coords-vec2(0.5, 0.5));\n    if ( NormalizedTime < 0.1 )\n    {\n      Falloff *= NormalizedTime / 0.1;\n    }\n    else if ( NormalizedTime > 0.5 )\n    {\n      Falloff *= 1.0 - (NormalizedTime-0.5) / 0.5;\n    }\n    Color.w = Falloff;\n    out_FragColor = Color;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderLightParticleStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Normal;\n  in vec3 v_WorldNormal;\n  in vec4 v_ProjectedVertex;\n  in vec4 v_ShadowMapCoord;\n  in vec3 v_Params;\n  in vec4 v_Color;\n  out vec4 out_FragColor;\n  void main()\n  {\n    discard;\n  }\n)\";\n```", "```java\nstatic const char g_fShaderShadowParticleStr[] = R\"(\n  in vec2 v_Coords;\n  in vec3 v_Params; /* TTL, LifeTime, Size */\n  out vec4 out_FragColor;\n  void main()\n  {\n    float NormalizedTime = (v_Params.y-v_Params.x) / v_Params.y;\n```", "```java\n    float Falloff = ( NormalizedTime < 0.5 ) ? NormalizedTime : 1.0-NormalizedTime;\n    if ( length(v_Coords-vec2(0.5, 0.5)) > 0.5 * Falloff ) discard;\n    out_FragColor = vec4( 1.0 );\n  }\n)\";\n```", "```java\nvoid GenerateExplosion( const clPtr<clParticleSystemNode>& ParticleNode, const vec3& Pos )\n{\n```", "```java\n  if ( ParticleNode->GetParticleSystem()->GetParticles() .size() > 8000 ) return;\n```", "```java\n  const vec4 Pal[] = {\n    vec4(0.2f, 0.30f, 0.8f, 1.0f),\n    vec4(0.7f, 0.25f, 0.3f, 1.0f),\n    vec4(0.1f, 0.80f, 0.2f, 1.0f)\n  };\n```", "```java\n  vec4 Color = Pal[ Math::RandomInRange(0, 3) ];\n```", "```java\n  auto Emitter = make_intrusive<clParticleEmitter_Explosion>();\n  Emitter->FCenter = Pos;\n  Emitter->FSizeMin = 0.02f;\n  Emitter->FSizeMax = 0.05f;\n  Emitter->FLifetimeMin = 0.1f;\n  Emitter->FLifetimeMax = 1.0f;\n  Emitter->FMaxParticles = 10000;\n  Emitter->FEmissionRate = 300;\n  Emitter->FRadialVelocityMin = 1.0f;\n  Emitter->FRadialVelocityMax = 2.0f;\n  Emitter->FColorMin = Color;\n  Emitter->FColorMax = Color;\n  Emitter->FAcceleration = vec3( 0.0f, 0.0f, -3.0f );\n  ParticleNode->AddEmitter( Emitter );\n}\n```", "```java\n  while( g_Window && g_Window->HandleInput() )\n  {\n    double NextSeconds = Env_GetSeconds();\n    float DeltaTime = static_cast<float>( NextSeconds - Seconds );\n    Seconds = NextSeconds;\n    float SlowMotionCoef = 0.5f;\n    if ( g_UpdateParticles )\n    ParticleNode->UpdateParticles( SlowMotionCoef * DeltaTime );\n```", "```java\n    bool Add = Math::RandomInRange( 0, 100 ) > 50.0f;\n```", "```java\n    if ( !ParticleNode->GetParticleSystem()-> GetParticles().size() || Add )\n    {\n      GenerateExplosion( ParticleNode, Math::RandomVector3InRange(vec3(-1), vec3(+1)) );\n    }\n    OnDrawFrame();\n    g_Window->Swap();\n  }\n```", "```java\nclass iActor: public iIntrusiveCounter\n{\npublic:\n  iActor():\n  m_Pos(0),\n  m_Vel(0),\n  m_Accel(0)\n  {}\n```", "```java\n  virtual void AttachToScene( const clPtr<clSceneNode>& Scene ) = 0;\n  virtual void DetachFromScene( const clPtr<clSceneNode>& Scene ) = 0;\n```", "```java\n  virtual void Update( float dt )\n  {\n    m_Vel += m_Accel * dt;\n    m_Pos += m_Vel * dt;\n  }\n  virtual float GetRadius() const\n  {\n    return 0.1f;\n  }\npublic:\n  vec3 m_Pos;\n  vec3 m_Vel;\n  vec3 m_Accel;\n};\n```", "```java\nclass clAsteroid: public iActor\n{\npublic:\n  clAsteroid()\n  : m_Angle( Math::RandomInRange( 0.0f, 1.0f ) )\n  {}\n  virtual void AttachToScene( const clPtr<clSceneNode>& Scene ) override;\n  virtual void DetachFromScene( const clPtr<clSceneNode>& Scene ) override;\n  virtual void Update( float dt ) override;\nprivate:\n  clPtr<clMaterialNode> m_Node;\n  float m_Angle;\n};\n```", "```java\nvoid clAsteroid::Update( float dt )\n{\n  iActor::Update( dt );\n  m_Angle += dt;\n  m_Pos = g_Game->ClampToLevel( m_Pos );\n  mat4 ScaleFix = mat4::GetScaleMatrix( vec3(0.002f ) );\n  mat4 Pos = mat4::GetTranslateMatrix( m_Pos );\n```", "```java\n  mat4 Rot = mat4::GetRotateMatrixAxis( m_Angle, vec3( 1, 1, 1 ) );\n  if ( m_Node )\n    m_Node->SetLocalTransform( ScaleFix * Rot * Pos );\n}\n```", "```java\nvoid clAsteroid::AttachToScene( const clPtr<clSceneNode>& Scene )\n{\n  if ( !m_Node )\n  {\n    auto Geometry = LoadOBJSceneNode( g_FS->CreateReader( \"deimos.obj\" ) );\n    sMaterial Material;\n    Material.m_Ambient = vec4( 0.5f, 0.5f, 0.0f, 1.0f );\n    Material.m_Diffuse = vec4( 0.5f, 0.5f, 0.0f, 1.0f );\n    m_Node = make_intrusive<clMaterialNode>();\n    m_Node->SetMaterial( Material );\n    m_Node->Add( Geometry );\n  }\n  Scene->Add( m_Node );\n}\n```", "```java\nvoid clAsteroid::DetachFromScene( const clPtr<clSceneNode>& Scene )\n{\n  Scene->Remove( m_Node );\n}\n```", "```java\nvoid clRocket::Update(float dt)\n{\n  iActor::Update( dt );\n  mat4 Pos = mat4::GetTranslateMatrix( m_Pos );\n  if ( m_Node ) m_Node->SetLocalTransform( Pos );\n```", "```java\n  if ( !g_Game->IsInsideLevel( m_Pos ) )\n  {\n    g_Game->Kill( this );\n  }\n}\n```", "```java\nvoid clExplosion::Update( float dt )\n{\n  iActor::Update( dt );\n  mat4 ScaleFix = mat4::GetScaleMatrix( vec3(1.0f ) );\n  mat4 Pos = mat4::GetTranslateMatrix(m_Pos);\n  if ( m_Node )\n  {\n```", "```java\n    const float SlowMotionCoef = 0.1f;\n    m_Node->SetLocalTransform( ScaleFix * Pos );\n    m_Node->UpdateParticles( SlowMotionCoef * dt );\n  }\n```", "```java\n  if ( !m_Node->GetParticleSystem()->GetParticles().size() )\n  {\n    g_Game->Kill( this );\n  }\n}\n```", "```java\nvoid clSpaceShip::Update( float dt )\n{\n  iActor::Update( dt );\n```", "```java\n  if ( g_Game->IsKeyPressed( SDLK_LEFT ) )\n  {\n    m_Angle += dt;\n  }\n  if ( g_Game->IsKeyPressed( SDLK_RIGHT ) )\n  {\n    m_Angle -= dt;\n  }\n  bool Accel = g_Game->IsKeyPressed( SDLK_UP );\n  bool Decel = g_Game->IsKeyPressed( SDLK_DOWN );\n  m_Accel = vec3( 0.0f );\n  if ( Accel )\n  {\n    m_Accel = GetDirection();\n  }\n  if ( Decel )\n  {\n    m_Accel += -GetDirection();\n  }\n  if ( g_Game->IsKeyPressed( SDLK_SPACE ) )\n  {\n    Fire();\n  }\n```", "```java\n  m_Pos = g_Game->ClampToLevel( m_Pos );\n```", "```java\n  m_Vel *= 0.99f;\n  const float MaxVel = 1.1f;\n  if ( m_Vel.Length() > MaxVel ) m_Vel = ( m_Vel / m_Vel.Length() ) * MaxVel;\n```", "```java\n  m_FireTime -= dt;\n  if ( m_FireTime < 0 ) m_FireTime = 0.0f;\n```", "```java\n  mat4 ScaleFix = mat4::GetScaleMatrix( vec3(0.1f ) );\n  mat4 RotFix = mat4::GetRotateMatrixAxis( 90.0f * Math::DTOR, vec3(0,0,1) );\n  mat4 Pos = mat4::GetTranslateMatrix(m_Pos);\n  mat4 Rot = mat4::GetRotateMatrixAxis( m_Angle, vec3(0,0,1) );\n```", "```java\n  if ( m_Node ) m_Node->SetLocalTransform( ScaleFix * RotFix * Rot * Pos );\n}\n```", "```java\nvoid clSpaceShip::Fire()\n{\n  if ( m_FireTime > 0.0f ) return;\n```", "```java\n  const float FireCooldown = 1.0f;\n  m_FireTime = FireCooldown;\n```", "```java\n  g_Game->FireRocket( m_Pos, m_Vel * Math::RandomInRange( 1.1f, 1.5f ) + GetDirection() );\n}\n```", "```java\nclass clGameManager: public iIntrusiveCounter\n{\npublic:\n  clGameManager();\n```", "```java\n  virtual void GenerateTicks();\n```", "```java\n  virtual void Render();\n  virtual void OnKey( int Key, bool Pressed );\n  clPtr<clSceneNode> GetSceneRoot() const { return m_Scene; };\n  virtual bool IsKeyPressed( int Code );\n```", "```java\n  virtual void FireRocket( const vec3& Pos, const vec3& Vel );\n  virtual void AddExplosion( const vec3& Pos, const vec3& Dir );\n```", "```java\n  virtual bool IsInsideLevel( const vec3& Pos );\n  virtual vec3 ClampToLevel( const vec3& Pos );\n```", "```java\n  virtual void Kill( iActor* Actor );\n```", "```java\n  virtual void PlayAudioFile( const std::string& FileName );\nprivate:\n  void PerformExecution();\n  void SpawnRandomAsteroids( size_t N );\n  void CheckCollisions();\nprivate:\n  clPtr<clSceneNode> m_Scene;\n  clPtr<clSpaceShip> m_SpaceShip;\n  std::vector< clPtr<clAsteroid> > m_Asteroids;\n  std::vector< clPtr<clRocket> > m_Rockets;\n  std::vector< clPtr<clExplosion> > m_Explosions;\n  std::unordered_map<int, bool> m_Keys;\n  vec3 m_LevelMin;\n  vec3 m_LevelMax;\n  std::vector< iActor* > m_DeathRow;\n  std::vector< clPtr<clAudioSource> > m_Sounds;\n  // file name -> blob\n  std::map< std::string, clPtr<clBlob> > m_SoundFiles;\n};\n```", "```java\nvoid clGameManager::GenerateTicks()\n{\n  const float DeltaSeconds = 0.05f;\n```", "```java\n  for ( const auto& i: m_Asteroids ) i->Update( DeltaSeconds );\n  for ( const auto& i: m_Rockets ) i->Update( DeltaSeconds );\n  for ( const auto& i: m_Explosions ) i->Update( DeltaSeconds );\n  m_SpaceShip->Update( DeltaSeconds );\n  CheckCollisions();\n  PerformExecution();\n  for ( size_t i = 0; i != m_Sounds.size(); i++ )\n  {\n    if ( !m_Sounds[i]->IsPlaying() )\n    {\n```", "```java\n      g_Audio.UnRegisterSource( m_Sounds[i].GetInternalPtr() );\n      m_Sounds[i]->Stop();\n      m_Sounds[i] = m_Sounds.back();\n      m_Sounds.pop_back();\n      break;\n    }\n  }\n}\n```", "```java\nvoid clGameManager::CheckCollisions()\n{\n  for ( size_t i = 0; i != m_Rockets.size(); i++ )\n  {\n    for ( size_t j = 0; j != m_Asteroids.size(); j++ )\n    {\n      vec3 PosR = m_Rockets[i]->m_Pos;\n      vec3 PosA = m_Asteroids[j]->m_Pos;\n      float R = m_Asteroids[j]->GetRadius();\n```", "```java\n      if ( (PosR-PosA).Length() < R )\n      {\n        this->Kill(m_Rockets[i].GetInternalPtr());\n        this->Kill(m_Asteroids[j].GetInternalPtr());\n        AddExplosion( m_Asteroids[j]->m_Pos, m_Rockets[i]->m_Vel );\n      }\n    }\n  }\n}\n```", "```java\nvoid clGameManager::PerformExecution()\n{\n  for ( const auto& i : m_DeathRow )\n  {\n    i->DetachFromScene( m_Scene );\n    Remove( m_Asteroids, i );\n    Remove( m_Explosions, i );\n    Remove( m_Rockets, i );\n  }\n  m_DeathRow.clear();\n}\n```", "```java\ntemplate <typename Container, typename Entity>\nvoid Remove( Container& c, Entity e )\n{\n  auto iter = std::remove_if( c.begin(), c.end(), [ e ]( const typename Container::value_type& Ent )\n    {\n      return Ent == e;\n    } );\n  c.erase( iter, c.end() );\n}\n```"]