- en: Chapter 2. Fragments and UI Flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter builds on the concepts introduced in the previous chapter to provide
    solutions to addressing specific differences in device layouts. The chapter explains
    the use of adaptive Activity layout definitions to create apps that automatically
    rearrange their user interface in response to differences in device form factors.
    With adaptive Activity layout definitions, applications are able to support a
    wide variety of devices using just a few properly designed fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the challenge of supporting device differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic resource selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinating fragment content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of `FragmentManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting fragments across activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to implement a user interface that
    uses fragments to automatically adapt to differences in device layouts and coordinates
    user actions across the involved fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing fragments in our user interface design provides a good foundation
    for creating applications that more easily adapt to device differences, but we
    must go a little further to create truly flexible UIs. We must design our application
    such that the fragments that make up the UI are easily rearranged in response
    to the characteristics of the device on which the app is currently running.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we must use some techniques to dynamically change the layout
    of individual fragments in response to the current device's characteristics. Once
    we employ such a technique, we must be sure that we implement our fragments in
    such a way that each fragment is able to function effectively independent of layout
    changes that might affect the behavior or even existence of other fragments within
    the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic fragment layout selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, creating a flexible UI requires that
    the layout and positioning of fragments within an activity must be able to change
    in response to differences in device characteristics. We can include code in our
    application to dynamically arrange fragments in response to the form factor of
    the device on which our app is running, but in most cases, doing so is not only
    unnecessary but also undesirable. The deeper the dependencies between the user
    interface and application code, the more difficult maintaining and enhancing an
    application becomes. Although there will always be some degree of dependency between
    our user interface and application code, we want to minimize such dependencies
    and instead do as much of our user interface layout-related work within layout
    resources as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to build flexibility into our application user interface is
    to take advantage of the Android resource system's built-in device adaptability.
    Android allows us to design different layout-related resources for our application
    with each optimized for and associated with a specific set of device characteristics.
    At runtime, the Android resource system takes care of automatically selecting
    and loading the appropriate resources for the current device. Although this feature
    can be used to dynamically modify the layout of any activity, we'll see that it
    is particularly effective when used in conjunction with fragments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see Android resource selection in action, let''s continue with our application
    from the previous chapter. As you''ll recall, the layout for our activity is in
    the `activity_main.xml` resource file and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This layout stacks our fragments, `BookListFragment` and `BookDescFragment`,
    one on top of the other. Although that layout renders well on a smartphone held
    vertically in the portrait orientation, rotating the phone so that it''s held
    horizontally in the landscape orientation creates a much less attractive appearance
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic fragment layout selection](img/3095_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The current layout is clearly not making the best use of the available screen
    space in this orientation. When the phone is orientated in landscape, the application
    would look much better if we position the two fragments side-by-side.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an alternate layout resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add support for an alternative layout to our application by creating
    a new resource file with the fragments appropriately arranged. To create the resource
    file, we first add another folder under the `res` folder of the project tree called
    `layout-land`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resource folder name creates the association between the resource file and
    the device characteristics, not any special behavior on the part of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the new folder in Android Studio, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **src** folder in the project explorer window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **main** folder under **src**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **res** folder under **main**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Android resource directory** to open the **New Resource Directory**
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **layout** as **Resource type:**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight **Orientation** under **Available qualifiers:** and click on the **>>**
    button to move it to **Chosen qualifiers:**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Landscape** under **Screen orientation:**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **New Resource Directory** dialog will appear similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an alternate layout resource](img/3095_02_02_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now copy the `activity_main.xml` resource file from the **layout** resource
    folder to the **layout-land** resource folder. We now have two copies of the `activity_main.xml`
    resource file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an alternate layout resource](img/3095_02_03_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now modify the `activity_main.xml` resource file in the `layout-land`
    folder to arrange the fragments to render properly when the phone is in landscape
    orientation. First, we switch the `LinearLayout` element from a vertical to a
    horizontal orientation. We then change the `layout_width` values for each fragment
    to `0dp` and the `layout_height` values to `match_parent`. We can leave each of
    the fragment's `layout_weight` value as `1` so that `LinearLayout` spaces them
    equally left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated resource file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done nothing more than adding this simple resource file to our project,
    the application now displays the list of titles and book description next to one
    another when run on a device held in a landscape orientation as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an alternate layout resource](img/3095_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During runtime, when the `MainActivity` class loads the `R.layout.activity_main`
    resource, the Android resource system returns the appropriate version of the `activity_main.xml`
    resource file for that orientation. When the user rotates the device to a different
    orientation, Android automatically recreates the activity and loads the appropriate
    resource for the new orientation.
  prefs: []
  type: TYPE_NORMAL
- en: The Android environment detects a wide variety of device form factor characteristics.
    By taking advantage of fragments, we are able to create an application that easily
    adapts to device differences by simply providing different layout resource files
    that shift around the location of our fragments as if they are puzzle pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Without fragments, we would've had to provide the entire layout for the activity,
    radio buttons, text views, everything, in both of the layout files. We would then
    find ourselves having to maintain two complex, almost identical files. By using
    fragments, the individual pieces are self-contained and non-duplicated. Fragments
    modify the layout in an easy manner and simplify our application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Managing fragment layout by screen size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same technique we use to adapt our user interface to device orientation
    differences can be taken much further to work with differences in screen size.
    The Android resource system has device screen size awareness and therefore supports
    creating corresponding resource folders. The resource selection can be based on
    general screen size groups or specific screen size constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in device screen size are one of the most common reasons for using
    layout resources to manage fragments. With this being the case, understanding
    how to use layout resources to deal with differences in screen size is essential
    to working effectively with fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Resource screen size groups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The configuration information of each Android device includes the screen size
    group to which the device belongs. The four screen size groups are small, normal,
    large, or xlarge.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For specific information on the size of screens in each group, see *Range of
    screens supported* in the Android documentation available at [http://developer.android.com/guide/practices/screens_support.html#range](http://developer.android.com/guide/practices/screens_support.html#range).
  prefs: []
  type: TYPE_NORMAL
- en: Just as we created a specific layout resource file for landscape orientation,
    we can create a layout resource file targeting a particular screen size group.
    We associate the resource file with the desired screen size group by placing the
    file in the appropriately named resource folder. For example, we place a layout
    resource file designed for devices with a screen size group of large in the `layout-large`
    resource folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Screen size groups date back to the early days of Android when there was little
    practical experience in dealing with the wide variety of device form factors that
    now exist. As time has gone on and the number of Android device form factors has
    grown, file size groups have turned out to be a less than ideal solution. Problems
    with screen size groups stem from two main issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The size range of the groups is not consistently applied, which results in the
    size range within the groups overlapping one another. One device with a 7-inch
    screen might be classified as large while another device with the same size screen
    might be classified as xlarge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Groups are sometimes too broad. For example, the large group includes devices
    with 5-inch screens and devices with 7-inch screens. These screen sizes tend to
    have very different layout requirements. A device with a 5-inch screen tends to
    work best with handset-style layouts like that for a smartphone, whereas a device
    with a 7-inch screen tends to work best with a tablet-style layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Size groups are still in use because they are the best option available for
    dealing with screen size differences on pre-API Level 13 devices. Fortunately,
    less than half of the Android devices in use today are pre-API Level 13, and the
    ratio is shrinking rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For information on the distribution of devices in use by API Level or by screen
    size group, see the Android developer, *Dashboards*, available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  prefs: []
  type: TYPE_NORMAL
- en: Resource screen size qualifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At API Level 13 (Android 3.2), Android introduced a substantial improvement
    over screen size groups known as resource screen size qualifiers. Resource screen
    size qualifiers allow us to associate resources with specific screen size requirements.
    With screen size qualifiers, we have a very detailed level of control over which
    layout resources are associated with each device form factor.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the complications inherent in the wide variety of screen pixel densities
    and physical screen sizes available, Android uses a canonicalized unit of measure
    called the **density independent pixel** (**dp**) when managing screen sizes.
    If you've been working with Android for any length of time, you are probably already
    familiar with density independent pixels as they are the preferred unit of measure
    when positioning and sizing views within an Android user interface.
  prefs: []
  type: TYPE_NORMAL
- en: A dp always corresponds to the physical size of a pixel on a 160 dpi device
    and therefore provides a consistent unit of measure independent of the physical
    pixel size of the device. For example, one 7-inch display device may have a physical
    pixel count of 1280x720 while another 7-inch display device has a physical pixel
    count of 1920x1080, but both devices have a dp count of approximately 1000x600\.
    The Android platform takes care of the details of mapping between density independent
    pixels and the physical pixels of a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android provides three types of screen size qualifiers: smallest width, available
    screen width, and available screen height:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smallest width screen size qualifier:** This is referred to as smallest screen
    width in the Android Studio New Directory Resource dialog. It corresponds to the
    number of device independent pixels at the screen''s narrowest point independent
    of the device orientation. Changing the device orientation does not change the
    device''s smallest width. We specify the name of a resource folder based on the
    device''s smallest width by adding `sw`, followed by the desired screen size in
    device independent pixels, followed by `dp`. For example, a layout resource folder
    containing layout resource files for devices with a smallest width of at least
    600 dp is named `layout-sw600dp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Available width screen size qualifier:** This is referred to as screen width
    in the Android Studio New Directory Resource dialog. It corresponds to the number
    of device independent pixels measured left to right at the device''s current orientation.
    Changing the device orientation changes the available width. We specify the name
    of a resource folder based on available width by adding `w`, followed by the width
    in density independent pixels, followed by `dp`. A layout resource folder containing
    resource files for a device with an available width of at least 600 dp is named
    `layout-w600dp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Available height screen size qualifier:** This is referred to as screen height
    in the Android Studio New Directory Resource dialog. It corresponds to the number
    of device independent pixels measured top to bottom, but otherwise behaves identically
    to the available width screen size qualifier, and follows the same naming pattern
    except that `h` is used instead of `w`. A layout resource folder containing resource
    files for a device with an available height of at least 600 dp is named `layout-h600dp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminating redundancy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the number of form factors our application targets grow, managing the resource
    files within the different layout resource folders can become somewhat complicated
    due to the fact that we'll likely want to use the same layout resource file for
    different qualifiers. To demonstrate this problem, let's update our application
    to use the version of the `activity_main.xml` resource file we currently use for
    landscape-oriented devices on other devices. We'll use that same resource file
    on devices in the large screen size group and on devices with a current width
    of 600 dp or greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create two additional folders under our `res` folder: `layout-large`
    and `layout-w600dp`. We then copy the `activity_main.xml` file from the `layout-land`
    folder to the two folders we just created. Doing this is easy enough but we now
    have a maintenance headache. Every time we make a change to that layout, we have
    to be sure that we make it in all three folders.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this resource file duplication, we can use layout aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: Layout aliasing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Layout aliasing allows us to have just a single copy of each layout resource
    file. We can then provide the resource system with information as to which file
    to choose for each form factor.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we'll rename the `activity_main.xml` resource file in the `layout-land`
    resource folder as `activity_main_wide.xml`. We then move the file to the `layout`
    resource folder and delete the `layout-land` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We now create a new resource folder called `values-land` under the `res` folder.
    To create the folder in Android Studio, follow the same steps as we used earlier
    to create the `layout-land` folder except set the **Resource type:** as **values**
    rather than **layout**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this folder, we create a new resource file, the name of which doesn''t
    matter, but the file containing values for aliasing is often named `refs.xml`
    because it contains a list of references to other resources, so that''s what we''ll
    use. To create the file using Android Studio, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **values-land** resource folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **values** resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify `refs.xml` as the filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `refs.xml` file, be sure that there is already a root element named
    `resources`. Within that element, add an `item` element with a `type` attribute
    value of `layout`. This indicates that we''re providing an alias entry for a layout
    resource. We set the value of the `name` attribute to be the name of the default
    layout resource, which in our case is `activity_main`. We then give the `item`
    element a value of `@layout/activity_main_wide`. The complete `refs.xml` resource
    file now appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this file in place, any call to load the layout resource `R.layout.activity_main`
    will instead load `R.layout.activity_main_wide` when the application is running
    on a device in landscape orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add support for devices in the large group and those with a current width
    of at least 600 dp, we simply create two more resource folders, `values-large`
    and `values-w600dp`, and copy the `refs.xml` file from the `values-land` folder
    to each. The `layout` and `values` resource folders now appear as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout aliasing](img/3095_02_05_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have support for all the desired form factors with no unnecessary duplication
    of layout resource files. We do have duplication of the `refs.xml` file, but it's
    a much simpler file than the `layout` resource file and is less likely to change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See *Table 2* of the Android *Providing Resources* guide for the order of precedence
    Android follows when performing layout aliasing,available at [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html).
  prefs: []
  type: TYPE_NORMAL
- en: Design fragments for flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our user interface well-partitioned and adaptable, we need to be sure that
    each fragment functions effectively, as layout differences cause the behavior
    and possibly even the existence of other fragments within the activity to change.
    When an application user interface is divided into fragments, the fragments exist
    completely independent of one another rarely. Very often a user's interaction
    with one fragment has some effect on other fragments within the same activity.
    In the case of our application, this issue arises when a user selects a book within
    `BookListFragment`. In response to the user's selection, the application is responsible
    for displaying the corresponding description in `BookDescFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding tight coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One possible solution to coordinating fragment content is to allow the fragments
    to directly communicate with one another. To coordinate content within our application,
    we could pass the `BookDescFragment` reference into `BookListFragment` when we
    first create the activity. In response to each user selection within `BookListFragment`,
    `BookListFragment` would then directly update `TextView` contained within `BookDescFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Although simple to implement, this solution is problematic because it tightly
    couples the two `Fragment` classes to each other. The `BookListFragment` fragment
    is only usable within activities that also contain the `BookDescFragment` fragment,
    and making changes to the layout of `BookDescFragment` may potentially break `BookListFragment`.
    We always want to keep in mind that a key goal of using fragments is to be well-partitioned
    and adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting fragment relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of creating direct relationships between the fragments, we can take
    advantage of the abstraction provided by interfaces. By defining a simple callback
    interface to represent the act of a user making a book selection, we can completely
    eliminate tight coupling between fragments. The `BookListFragment` class can be
    written to provide notification of a user selection through the interface. By
    implementing the interface on the activity, the activity can then handle coordinating
    the user selection within `BookListFragment` with updating the displayed description
    within `BookDeskFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the callback interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The callback interface should include methods for any interaction with the fragment
    that may be meaningful to the activity containing the fragment. At the same time,
    the interface should not burden the activity with unnecessary details. The interface
    should be focused on application-level actions such as selecting a book rather
    than implementation-level actions such as tapping on a radio button. The implementation-level
    details should be isolated within the fragment. We should also be sure to design
    the interface without any preconceived ideas of what the activity will do with
    the notification.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `BookListFragment`, the only action of interest to the activity
    is the user selecting a book. This tells us the interface needs just a single
    method; we'll call the interface method `onSelectedBookChanged`. We know in the
    case of this application, the goal is to display the selected book description,
    so one possibility is to have the `onSelectedBookChanged` method include a parameter
    for the book description. The problem with passing the book description is that
    doing so limits the use of `BookListFragment` to just this one use case, displaying
    the book description. Instead, by passing an identifier for the book, `BookListFragment`
    is available for any use case in which the user selects a book. For simplicity,
    in our example, we'll use an array index as the identifier; in a real scenario,
    the identifier would more likely be a key to locate the book information within
    a data store or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call our new interface `OnSelectedBookChangeListener`. The interface
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Making the fragment self-contained
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `BookListFragment` class needs to hide the details of user selections and
    instead translate each selection to a book identifier, which in our case is an
    array index. We first need to update the `BookListFragment` class to handle the
    radio button selections by implementing the `RadioGroup.OnCheckedChangeListener`
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `BookListFragment` class'' `onCreateView` method, we set the radio
    group''s click listener as the `BookListFragment` class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of ways to determine the book index corresponding to the
    selected radio button such as setting the tag value on each radio button or using
    a lookup table. For simplicity, we''ll create a simple method containing a switch
    statement like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Fragment notification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A fragment can always access the activity on which it is placed using the `getActivity`
    method. Within the `BookListFragment` class'' `onClick` method, we can use the
    `getActivity` method to access the activity, cast it to the `OnSelectedBookChangeListener`
    interface, and then call the `onSelectedBookChanged` method and pass it the book
    index for the selected radio button as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `BookListFragment` class now completely handles notifying the parent activity
    of each change in the user book selection.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating fragment operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the `BookDescFragment` class, we want to encapsulate any details about
    how the user interface is updated. We''ll do this by providing a simple method
    that accepts the book index and handles the details of locating and displaying
    the book description. Before we can implement that method, we first need to update
    the `BookDescFragment` class'' `onCreateView` method to retrieve the list of book
    descriptions, retrieve a reference to `TextView` identified by `R.id.bookDescription`,
    and assign both to class-level fields as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add a `setBook` method that accepts the book index, accesses the
    appropriate book description, and updates `mBookDescriptionTextView`. The `setBook`
    method appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Loosely connecting the pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Good use of interfaces and encapsulation greatly simplify using any component,
    and fragments are no different. With the work we''ve done on the `BookListFragment`
    and `BookDescFragment` classes, our activity can now coordinate user interaction
    in `BookListFragment` by updating `BookDescFragment` in three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `OnSelectedBookChangeListener` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a reference to the `BookDescFragment` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `BookDescFragment` class' `setBook` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a look at step 2 first. Unlike when working with views, an activity cannot
    directly reference the fragments contained within it. Instead, fragment handling
    is delegated to the `FragmentManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each activity has a unique instance of the `FragmentManager` class. The `FragmentManager`
    class handles access to and management of all fragments within that activity.
    An activity accesses its `FragmentManager` instance with the `getFragmentManager`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with the Android Support Library, use the `FragmentActivity` class'
    `getSupportFragmentManager` method in place of the standard `Activity` class'
    `getFragmentManager` method to access the current `FragmentManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: With `FragmentManager`, an activity can access the contained fragments by calling
    the `FragmentManager.findFragmentById` method and passing the desired fragment's
    id value from the layout resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FragmentManager` is an important class with a number of powerful capabilities.
    We''ll talk much more about `FragmentManager` in [Chapter 4](ch04.html "Chapter 4. Working
    with Fragment Transactions"), *Working with Fragment Transactions*.'
  prefs: []
  type: TYPE_NORMAL
- en: By using `FragmentManager` to access `BookDescFragment`, we can now implement
    the `BookListFragment.OnSelectedBookChangeListener` interface on our activity
    to update the displayed description for each user selection in `BookListFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Fragments protect against the unexpected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true test of user interface flexibility is in how well the user interface
    design and implementation hold up when encountering an unexpected change request.
    A well-designed fragment-based user interface allows us to create incredible dynamic
    user interfaces that can evolve and change with minimal impact on the code. As
    an example, let's make what could potentially be a major design change on our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the application always shows the book list and description on the
    same activity. The only difference is whether the fragments are positioned vertically
    or horizontally relative to one another. Imagine we receive feedback from our
    users that they don't like the way the app appears when viewed on a portrait-oriented
    handset. When viewed on a portrait-oriented handset, they would like the list
    and description to appear on separate activities. In all other cases, they want
    the app to continue to show the list and description side-by-side.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving layout resource files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first create a duplicate copy of the `activity_main.xml` resource file in
    the `layout` resource folder named `activity_book_desc.xml`. To do this in Android
    Studio, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `activity_main.xml` file in the project explorer window and
    select **Copy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `layout` folder and select **Paste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the filename to `activity_book_desc.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the fragment element for `BookListFragment` from the `activity_book_desc.xml`
    file so it now shows only `BookDescFragment` as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `activity_main.xml` resource file, remove `BookDescFragment` so that
    it now appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We now have layout resources for each of the activities. Remember that these
    changes will not affect the appearance of the app in scenarios that use the `activity_main_wide.xml`
    resource file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the book description activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display the book description, we add a simple activity named `BookDescActivity`
    that uses the `activity_book_desc.xml` layout resource. The activity relies on
    an "Intent extra" to pass the book index. Since `BookDescFragment` contains all
    the logic necessary to display a book description, we can simply get a reference
    to `BookDescFragment` and set the book index just as we did in the `MainActivity`
    class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Making the MainActivity class adaptive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MainActivity` class has some extra work to do now because the specific
    fragments contained within it will vary. When running on a device with a screen
    that is at least 600 dp wide or when running on a device in the large screen group,
    the `MainActivity` class always contains an instance of `BookDescFragment`. On
    the other hand, when running on other devices, the presence of `BookDescFragment`
    will depend upon the device's current orientation. We could add code to the `MainActivity`
    class to test for all of these various scenarios or we could take a simpler approach,
    that is, check whether the activity contains an instance of the `BookDescFragment`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach, we have the `MainActivity` class'' `onSelectedBookChanged`
    method to check the validity of `BookDescFragment` returned by `FragmentManager`.
    If `FragmentManager` returns a valid reference, the method can call `setBook`
    on `BookDescFragment` just as it has been. If the returned reference is not valid,
    the `onSelectedBookChanged` method calls `startActivity` with an `Intent` instance
    containing the information to display `BookDescActivity` that includes `bookIndex`
    as an extra as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `if` statement that checks the validity of `bookDescFragment`. In
    most cases, a simple check for whether the reference is null is all we need. The
    one exception is the case of when the app is run on a handset device on which
    the user has viewed the app in landscape orientation and then rotated the device
    to portrait. In this situation, the `BookDescFragment` instance is not visible
    but the activity's `FragmentManager` instance may be caching a reference to an
    invisible instance remaining from the landscape layout. For this reason, we check
    both for a null reference and for visibility. We'll discuss the details of fragment
    lifecycle, creation, and caching over the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have adaptability built into our app. The scenarios that use the `activity_main_wide.xml`
    resource file look as they always did. On portrait-oriented handset devices, our
    app provides the user interface with two separate activities: one for the book
    list and one for the book description. The application now appears on portrait-oriented
    handset devices as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the MainActivity class adaptive](img/3095_02_06_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fragments provide our applications with a level of user interface flexibility
    that would be difficult to achieve otherwise. By properly designing our application
    to use fragments and associating the fragment resources with the appropriate device
    characteristics, we're able to build apps that contain a rich user interface that
    automatically adapts to the wide variety of Android device form factors that exist.
    We get all of these capabilities while writing only minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we dig into the lifecycle of fragments and explore how
    we can leverage the fragment lifecycle to create more responsive user interfaces
    and leverage specialized `Fragment` classes.
  prefs: []
  type: TYPE_NORMAL
