- en: Chapter 6. Creating a Complete Interfacing Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters of this book, you interfaced with devices using GPIOs,
    I2C, and SPI. You used `AsyncTask`s to perform hardware interfacing in background
    threads, and you explored how to structure an app to interact with those threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will bring all of these concepts together to create a circuit
    that uses all three interfacing methods, and you will explore an app that uses
    all the interfaces together to make a complex system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the complete interface circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the final example app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the complete interface circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interfacing circuit used in this chapter is a combination of each of the
    circuits described in chapters 3, 4, and 5\. If you have successfully constructed
    the circuits from the previous chapters, you already have a good understanding
    of how the circuit in this chapter will be put together. Leave any previously
    constructed circuits on the breadboard to save you some effort if you have constructed
    those circuits by closely following the instructions from earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the connections between the sensor breakout board,
    FRAM breakout board, LED, pushbutton switch, resistor, and the BBB. Revisit chapters
    3, 4, and 5 for the exact details on how to construct the GPIO, FRAM, and SPI
    portions of the circuit, if you have not yet done so.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the complete interface circuit](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The complete hardware interfacing circuit that uses components which interface
    with the BBB using the GPIOs, I2C, and SPI components
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the complete example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will examine the example Android app that performs GPIO,
    I2C, and interfacing on BBB. The purpose of this application is to demonstrate
    how to use PacktHAL to perform a variety of hardware tasks from within an actual
    app using a set of interfacing functions. Unlike the previous example apps, which
    take input from the user, this app takes all of its input directly from the hardware
    itself. This requires a slightly more complex approach than that taken by the
    earlier apps.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging through the app's code, you must install the code on your development
    system and install the app on your Android system. The source code for the app
    as well as the precompiled `.apk` package is located in the `chapter6.tgz` file,
    which is available for download from the Packt website. Follow the same process
    to download and add the app to your Eclipse ADT environment, which was described
    in [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*.
  prefs: []
  type: TYPE_NORMAL
- en: The app's user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the `complete` app on the Android system to see the app's UI. If you
    are using a touchscreen cape, you can simply touch the `complete` app's icon on
    the screen to launch the app and interact with its UI. If you are using the HDMI
    for video, connect a USB mouse to the BBB's USB port and use the mouse to click
    on the sensor app icon to launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: The app uses a very simple UI that displays two text views in a single activity,
    which is `MainActivity` by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![The app''s user interface](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The complete app screen prior to receiving its first set of samples from the
    sensor
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no buttons or other UI elements in this app because the only interaction
    the user has with the app is through the circuit''s GPIO pushbutton switch. When
    the user presses the switch, the app performs a series of hardware interfacing
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The LED will turn on to notify the user that the switch has been recognized
    as pressed. The LED will remain lit until all events on the list have occurred.
    While the LED is on, any further switch input is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature and pressure samples are fetched from the sensor and written into
    the FRAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FRAM is read to retrieve the stored temperature and pressure sample values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values for the temperature and pressure samples are displayed in the app's
    UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 1-second delay will occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LED will turn off, and the switch can once again be pressed to trigger another
    sample-store-retrieve-display cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variety of actions performed by the app makes its interfacing behavior more
    complex than what you saw in the previous example apps in this book. Rather than
    focusing on interfacing with a single hardware component, this app interfaces
    with the GPIO, I2C, and SPI devices at the same time to provide a complete sensor
    solution with persistent storage. However, it is based on the same basic interfacing
    concepts that the other example apps in this book have demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding hardware polling in an app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The earlier apps either used the `onClick()` handler of a button to interface
    directly to the hardware (GPIOs) or triggered the instantiation and execution
    of `AsyncTask` (I2C and SPI) to interface with the hardware. In both of these
    cases, interfacing with the hardware is initiated by a software event, the `onClick()`
    handler's execution, within the app.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter's app, however, we want to trigger the hardware interfacing
    in response to the hardware event created by the switch being pressed. Listening
    for hardware events is an important part of interfacing because it allows the
    hardware to tell us when events of interest occur. We do not always have the luxury
    of telling the hardware to do something and expecting the hardware to do it. Sometimes,
    the hardware needs to notify us that an event has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: When interfacing with hardware from a kernel driver, the driver can register
    to be notified of a hardware event of interest by registering for notification
    of the time a hardware interrupt occurs. A hardware interrupt tells the kernel
    immediately that something noteworthy has happened with the hardware, and the
    kernel will stop what it is doing to allow the appropriate kernel driver to handle
    the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: Because our apps are performing their higher-level interfacing logic from user
    space, we are unable to register for an interrupt to notify us the time an event
    of interest occurs. This hardware event can happen asynchronously at any time,
    so the app must continually poll, or check, the state of the switch to determine
    whether it has been pressed or not. Apps typically do not poll for events because
    they rely on being notified by the Android framework when something interesting
    happens, but when an app is performing hardware interfacing without the assistance
    of a manager, polling becomes necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The faster an app polls the hardware, the lesser the chance that the app will
    miss the occurrence of the hardware event of interest. However, constantly polling
    in a tight loop is a bad idea because it will constantly consume CPU cycles (and
    battery life in mobile devices), which can be better spent elsewhere. If you include
    polling in your apps, you must find a good balance between performance and usage
    of resources.
  prefs: []
  type: TYPE_NORMAL
- en: It is a bad idea to place a polling loop inside the context of the UI thread.
    Remember that spending too much time executing within a handler method in the
    UI thread context will cause Android to trigger the ANR dialog. To avoid this
    problem, an app must instantiate `AsyncTask`, which performs the hardware polling
    in a background thread. The earlier example apps in this book used an `AsyncTask`
    thread to perform communication with hardware devices, but the `AsyncTask` thread
    was short-lived. The `AsyncTask` thread's background thread was only active while
    it was interfacing with the hardware. Once the interfacing was completed, the
    thread terminated. If the app needed to communicate with the hardware once more,
    a new `AsyncTask` thread was instantiated and started via its `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Because our app must use `AsyncTask` to continually poll the switch to check
    for user input, the `AsyncTask` thread used in the app is a long-lived thread.
    Instead of instantiating and calling `execute()` for `AsyncTask` only at the moments
    when the app needs to communicate with the hardware, the app instantiates and
    executes `AsyncTask` whenever it transitions to the **resumed state**. The `AsyncTask`
    thread continues executing in the background until the app transitions to the
    **paused state**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn the details of how Android app activities transition among the various
    lifecycle states, such as the resumed state and paused state, refer to the official
    Android developer documentation at [http://developer.android.com/training/basics/activity-lifecycle/index.html](http://developer.android.com/training/basics/activity-lifecycle/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncTask with long-lived threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used four methods in the `AsyncTask` base class in our previous
    example apps. These methods are used in `AsyncTask`s to implement both short-lived
    and long-lived threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPreExecute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doInBackground()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPostExecute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will use five additional methods of the `AsyncTask` class.
    These additional methods can be used for short-lived threads to make them more
    powerful, and they will almost always be used in long-lived background threads
    to communicate with the thread and receive feedback from it while it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cancel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCancelled()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCancelled()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publishProgress()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doPublishProgress()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cancel()`, `onCancelled()`, and `isCancelled()` methods are used to stop
    the currently executing `AsyncTask` method when the `MainActivity` class of our
    app leaves the resumed state. The `cancel()` method is called from within the
    UI thread context to notify the `AsyncTask` class that it has been canceled and
    should stop its execution. Calling `cancel()` triggers the calling of the `onCancelled()`
    method within the `AsyncTask` thread context. Then `onCancelled()` gives the `AsyncTask`
    class a chance to perform any necessary cleanup tasks. The `isCancelled()` method
    can be called at any time from within the `AsyncTask` thread context to determine
    whether `cancel()` and `onCancelled()` have been called. This method is usually
    called from within a loop inside of the `doInBackground()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `publishProgress()` and `doPublishProgress()` methods allow the `AsyncTask`
    thread to notify the UI thread of any information that should be displayed to
    the user via the app's UI. For example, if an `AsyncTask` thread is copying a
    large file from the network, these two methods notify the UI thread how much of
    the file has been copied and the estimated time remaining to transfer the remainder
    of the file. The UI thread can then update the UI with this information to keep
    the app's user informed of the `AsyncTask` thread's progress.
  prefs: []
  type: TYPE_NORMAL
- en: These five new `AsyncTask` methods were not used in the example apps in earlier
    chapters because those apps used `AsyncTask` methods that were short-lived threads
    and which updated the screen from the `onPostExecute()`method. The `onPostExecute()`
    method executed within the UI thread, so there was no need to use `publishProgress()`
    and `doPublishProgress()` in those apps. The `AsyncTask` threads in those apps
    also executed while the app was in a resumed state, and the threads were so short-lived
    that it was not necessary to use `cancel()` or `onCancelled()` to terminate the
    threads' execution. Because those apps did not use a loop within their `doInBackground()`
    methods, it was not necessary to use `isCancelled()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HardwareTask class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the example apps in previous chapters, the `complete` app uses a
    `HardwareTask` class that is derived from `AsyncTask`. All of the hardware interfacing
    is performed via the methods in `HardwareTask`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the HardwareTask class](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The thread contexts in which the HardwareTask methods and the PacktHAL functions
    are executed. The JNI functions in this image have had their function name prefixes
    shortened to HardwareTask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HardwareTask` class for the sensor app provides seven `native` methods
    that are used to call the PacktHAL JNI functions related to GPIO, FRAM, and sensor
    hardware interfacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because most of the details of the hardware interfacing are encapsulated within
    the PacktHAL functions and hidden from the `complete` app, all but one of these
    methods accept no parameters at all. They simply call their PacktHAL counterparts
    via the PacktHAL JNI wrapper functions. The exception to this is the `changeLED()`
    method, which takes a single parameter to specify whether the LED should be turned
    on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `complete` app, the `onResume()` method of the `MainActivity` class
    instantiates a new `HardwareTask` class when `MainActivity` changes to the resumed
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pollHardware()` method begins the hardware interfacing process by calling
    the base `AsyncTask` class `execution()` method to create a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onPause()` method of the `MainActivity` class halts the `AsyncTask` class''s
    execution when the `MainActivity` class changes to the paused state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cancel()` method of the `AyncTask` base class begins the process of canceling
    the executing `AsyncTask` thread by calling the `onCancelled()` method in `HardwareTask`.
    In addition to notifying the `AsyncTask` base class that the execution has been
    canceled, the `isDone` Boolean flag is set in the `HardwareTask` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `MainActivity` has transitioned to the resumed state, the `pollHardware()`
    method of `HardwareTask` begins the `AsyncTask` thread''s execution. In `onPreExecute()`,
    the `isDone` flag is reset, and the GPIO, I2C, and SPI devices are all initialized
    via the `openHardware()` method. If the hardware is successfully initialized,
    the LED is then turned off via a `changeLED()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After `onPreExecute()` has completed, the `AsyncTask` background thread begins
    running. The `doInBackground()` method begins its execution. Because this is a
    long-lived thread, there is a `while` loop inside `doInBackground()` that will
    continue to execute until the thread is canceled by the main UI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop begins by polling the state of the pushbutton switch. If the switch
    is pressed, the hardware interfacing logic will begin communicating with the FRAM
    and sensor. If the switch is not pressed, then the interfacing logic is skipped.
    In both cases, a slight delay is added via a `Thread.sleep()` method call to give
    the background thread an opportunity to sleep and allow other threads to run.
    This limits the resource consumption of the background thread and gives other
    processes and threads an opportunity to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the `pollButton()` method states that the button is pressed, the hardware
    interfacing logic begins executing. This calls the various native methods that
    invoke the PacktHAL JNI functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `changeLED()` turns on the LED to let the user know that a sample is
    about to be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the sensor sample is taken and the result is stored in the FRAM. The
    `readSensor()` native method interacts with the sensor to retrieve the sample
    data, and then stores the temperature and pressure samples in the first eight
    bytes of the memory of the FRAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The temperature data is stored as a 4-byte float in the first four bytes of
    the FRAM, and the pressure data is stored as a 4-byte float in the second four
    bytes of the FRAM. If you are interested in the details of how this is implemented
    in the native code, take a look at the `Java_com_packt_complete_HardwareTask_readSensor()`
    function in the `jni/jni_wrapper.c` file in PacktHAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the FRAM is accessed to retrieve the temperature and pressure samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the main UI thread is updated with the new sample data via the `publishProgress()`
    method. The thread sleeps for 1 second, and then the LED turns off. At this point,
    the `pollButton()` check is complete and the `while` loop begins again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `publishProgress()` method triggers the `onProgressUpdate()` method of
    `HardwareTask`, which executes in the UI thread. The `onProgressUpdate()` method
    calls the `MainActivity` class `updateSensorData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This `updateSensorData()` method in the `MainActivity` class updates the app''s
    UI and provides a `Toast` message to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The main polling `while` loop in the `HardwareTask` class'' `doInBackground()`
    method will eventually exit as a result of either the hardware interfacing failing
    to initialize or the base `AsyncTask` method being canceled by `MainActivity`.
    Once the loop has finished, `doInBackground()` will exit and the `AsyncTask` background
    thread will terminate. The `onPostExecute()` method will then perform any cleanup
    of items required, such as shutting down the hardware interfacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `HardwareTask` instance has now completed its background thread. If the
    `MainActivity` returns to the resumed state, a new `HardwareTask` instance will
    be instantiated. This `HardwareTask` instance will create another long-lived background
    thread, and the hardware interfacing process will repeat itself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you ready for a challenge?**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen all of the pieces of the complete app, why not change
    it to add some new functionality? For a challenge, try changing the app to continually
    take samples once the button has been pressed. Stop taking samples if the button
    is held down for a short period of time. We have provided one possible implementation
    of this in the `chapter6_challenge.tgz` file, which is available for download
    from the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the concept of long-lived threads for hardware
    interfacing. You constructed a circuit that connected the GPIO pushbutton switch,
    GPIO LED, FRAM device, and temperature and pressure sensors to the BBB. Unlike
    the example apps in the previous chapters, the example app in this chapter used
    polling to continually monitor the state of the hardware. You also explored using
    five additional methods of the `AsyncTask` class for communication and control
    between the background thread and the main UI thread of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned many of the basic concepts of hardware interfacing
    with Android using an app, it is time to look at the bigger picture and see how
    to turn your prototyped solution into a more permanent solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about integrating your solution with the
    Android framework, combining your solution with other capes available for the
    BBB, and other interfaces that you can use for your future interfacing projects.
  prefs: []
  type: TYPE_NORMAL
