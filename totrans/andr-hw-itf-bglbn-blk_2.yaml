- en: Chapter 2. Interfacing with Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 与 Android 交互
- en: In the last chapter, you installed Android on your BBB. You also gathered all
    of the hardware and components that you will need to try out the exercises in
    this book. Now that you have a working Android system and the hardware needed
    to explore it, it is time to dive into Android and find out how to prepare it
    to interface with custom hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你在 BBB 上安装了 Android 系统，并收集了所有需要的硬件和组件，以便尝试本书中的练习。现在你有了可用的 Android 系统和探索它所需的硬件，是时候深入了解
    Android，并找出如何为其准备与自定义硬件的接口了。
- en: Most people would not consider Android and Linux to be very similar, but the
    two have more in common than you might realize. Underneath the polished UIs and
    a wide variety of apps, Android is secretly Linux. Android's filesystem layout
    and services are quite different from those of a typical Linux system, so there
    are certainly many differences between the two in terms of user space (where apps
    and other processes execute). In terms of kernel space (where device drivers execute
    and resources are allocated to each running process), they are almost identical
    in functionality. Understanding how the BBB interacts with Linux kernel drivers
    is the key to creating Android apps that can do the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能不会认为 Android 和 Linux 非常相似，但两者之间的共同点比你想象的要多。在精美的用户界面和各种应用之下，Android 实际上是
    Linux 系统。Android 的文件系统布局和服务与典型的 Linux 系统大不相同，因此在用户空间（应用和其他进程执行的地方）肯定存在许多差异。在内核空间（设备驱动程序执行的地方，并为每个运行中的进程分配资源），它们在功能上几乎完全相同。理解
    BBB 如何与 Linux 内核驱动程序交互是创建能够执行相同操作的 Android 应用程序的关键。
- en: In this chapter, we will tell you about Android's hardware abstraction layer,
    or HAL. We will also introduce you to PacktHAL, a special library that you can
    include within your apps to interface with hardware on the BBB. We assume that
    you already have Eclipse **Android Developer Tools** (**ADT**) with the Android
    SDK, the Android **Native Development Kit** (**NDK**), and the **Android Debug
    Bridge** (**ADB**) tools installed and working on your system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍 Android 的硬件抽象层（HAL）。我们还将向您介绍 PacktHAL，这是一个特殊的库，您可以在应用中包含它，以便与 BBB
    上的硬件进行接口交互。我们假设您已经在系统上安装并运行了 Eclipse **Android 开发工具**（**ADT**）、Android **原生开发工具包**（**NDK**）和
    **Android 调试桥**（**ADB**）工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the Android HAL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Android HAL
- en: Installing PacktHAL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 PacktHAL
- en: Setting up the Android NDK for PacktHAL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 PacktHAL 设置 Android NDK
- en: Multiplexing the BBB pins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多路复用 BBB 引脚
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you missing a few tools?**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**您是否缺少一些工具？**'
- en: 'If you do not yet have the Eclipse ADT or Android NDK tools installed on your
    system, you can find installation instructions and download links at these locations:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有在系统上安装 Eclipse ADT 或 Android NDK 工具，您可以在以下位置找到安装说明和下载链接：
- en: '**Eclipse ADT**: [http://developer.android.com/sdk](http://developer.android.com/sdk)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse ADT**：[http://developer.android.com/sdk](http://developer.android.com/sdk)'
- en: '**Android NDK**: [http://developer.android.com/tools/sdk/ndk](http://developer.android.com/tools/sdk/ndk)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android NDK**：[http://developer.android.com/tools/sdk/ndk](http://developer.android.com/tools/sdk/ndk)'
- en: How to install ADB is discussed later in this chapter. This chapter assumes
    that you have installed the Eclipse ADT to the `c:\adt-bundle` directory if you
    are using Windows (we make no assumptions for Linux) and that you have installed
    the Android NDK to the `c:\android-ndk` directory (Windows) or `android-ndk` in
    your home directory (Linux). If you have installed these tools to a different
    location, you will have to make a few simple adjustments to a few instructions
    later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装 ADB 在本章后面会讨论。本章假设您已经将 Eclipse ADT 安装到 `c:\adt-bundle` 目录（如果您使用的是 Windows
    系统，我们不假设 Linux 的情况），并且您已经将 Android NDK 安装到 `c:\android-ndk` 目录（Windows）或主目录下的
    `android-ndk`（Linux）。如果您将这些工具安装到了其他位置，那么您需要对本章后面的一些指令进行一些简单的调整。
- en: Understanding the Android HAL
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Android HAL
- en: An Android kernel contains a few additional features that aren't found in a
    typical Linux kernel, such as **Binder IPC** and the low-memory killer, but otherwise
    it is still Linux. This provides you with one very big advantage when interfacing
    hardware with Android, that is, if a Linux driver already exists in the kernel
    used for an Android system, then you already have an Android driver for that device.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓内核包含一些在典型Linux内核中找不到的额外功能，如**Binder IPC**和低内存杀手，但除此之外，它仍然是Linux。这为您在与安卓硬件接口时提供了一个很大的优势，即如果安卓系统使用的内核中已经存在Linux驱动，那么您已经拥有该设备的安卓驱动。
- en: Android apps must interact with the hardware of an Android device by generating
    video and audio data, receiving button and touchscreen input events, and receiving
    sensor events from cameras, accelerometers, and other devices that gather information
    from the outside world. Leveraging existing Linux drivers for these devices makes
    Android support much easier. Unlike a traditional Linux distribution, which grants
    applications permission to directly access many different device files (by directly
    opening files in the `/dev` filesystem), Android dramatically limits the ability
    of processes to directly access hardware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓应用必须通过生成视频和音频数据、接收按钮和触摸屏输入事件以及从摄像头、加速度计等收集外部世界信息的设备接收传感器事件，与安卓设备的硬件进行交互。利用这些设备的现有Linux驱动，使得安卓支持变得更加容易。与传统的Linux发行版不同，后者允许应用程序直接访问许多不同的设备文件（直接在`/dev`文件系统中打开文件），安卓极大地限制了进程直接访问硬件的能力。
- en: Consider the number of different Android apps that use the audio functionality
    of the device to play sounds or record audio data. Underneath Android, the Linux
    kernel provides this audio functionality via an **Advanced Linux Sound Architecture**
    (**ALSA**) audio driver. In most cases, only one process at a time can open and
    control the ALSA driver resource. If individual apps were in charge of taking,
    using, and releasing the ALSA driver, it would become a huge mess to coordinate
    audio resource usage among all of the various apps. One misbehaving app can easily
    take control of audio resources and block all other apps from using them! But
    how can the allocation and control of these resources be handled? To solve this
    problem, Android uses *managers*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到有多少不同的安卓应用使用设备的音频功能来播放声音或录制音频数据。在安卓之下，Linux内核通过**高级Linux声音架构**（**ALSA**）音频驱动提供这种音频功能。在大多数情况下，一次只能有一个进程打开和控制ALSA驱动资源。如果各个应用负责获取、使用和释放ALSA驱动，那么在所有各种应用之间协调音频资源的使用将变得非常混乱。一个行为不当的应用很容易控制音频资源，并阻止所有其他应用使用它们！但是，这些资源的分配和控制如何处理呢？为了解决这个问题，安卓使用了*管理者*。
- en: Android managers
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安卓管理者
- en: Managers are the components of the system that control hardware devices on behalf
    of all apps. Every app requires some set of resources (such as audio, GPS, and
    network access) to perform its job. Managers are in charge of allocating and interfacing
    with each of these resources and determining whether an app has permission to
    use that resource.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者是系统中的组件，代表所有应用控制硬件设备。每个应用都需要一组资源（如音频、GPS和网络访问）来完成其工作。管理者负责分配和接口每个资源，并确定应用是否有权限使用该资源。
- en: Having managers deal with these low-level details makes life much easier. Android
    can be installed on a wide variety of hardware platforms that vary wildly in terms
    of physical size and input/output capabilities, and app developers can't be expected
    to have intimate knowledge of each and every platform that their app can be installed
    on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让管理者处理这些低级细节可以使生活变得轻松许多。安卓可以安装在各种硬件平台上，这些平台在物理尺寸和输入/输出能力上有很大差异，不能期望应用开发者对其应用可能安装的每个平台都有深入了解。
- en: 'To use a resource, an app must create a reference to the proper manager via
    the `getSystemService()` method of the `android.content.Context` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用资源，应用必须通过`android.content.Context`类的`getSystemService()`方法创建对适当管理者的引用：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, make information and control requests via this manager reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过这个管理者引用来发起信息和控制请求：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apps interact with managers through the Java Android API. While managers respond
    to these Java methods, they must eventually use the **Java native interface**
    (**JNI**) to call the native code that directly interacts with the hardware. This
    is where the true control of the hardware takes place. The bridge between the
    Android API and calls to the native code that control the hardware is known as
    the **hardware abstraction layer** (**HAL**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用通过Java Android API与管理者交互。虽然管理者响应这些Java方法，但它们最终必须使用**Java本地接口**（**JNI**）调用直接与硬件交互的本机代码。这才是真正控制硬件的地方。Android
    API与控制硬件的本机代码调用之间的桥梁被称为**硬件抽象层**（**HAL**）。
- en: The various pieces of the HAL are typically written in C/C++, and each device's
    vendor is responsible for implementing them. If some pieces of the HAL are missing,
    services and apps won't be able to fully utilize all aspects of the hardware platform.
    Various Android services use the HAL to communicate with the hardware, and apps
    use IPC to communicate with these services and gain access to the hardware. The
    services interact with the hardware on an app's behalf (assuming that the app
    has the proper Android permissions to access that particular hardware resource).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HAL的各个部分通常用C/C++编写，每个设备的供应商负责实现它们。如果HAL的某些部分缺失，服务和应用将无法充分利用硬件平台的所有方面。各种Android服务使用HAL与硬件通信，应用通过IPC与这些服务通信，从而访问硬件。服务代表应用与硬件交互（假设应用具有访问该特定硬件资源的适当Android权限）。
- en: The HAL development workflow
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HAL开发工作流程
- en: 'Typically, creating a complete HAL follows these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建一个完整的HAL需要遵循以下步骤：
- en: Identify or develop a Linux kernel device driver to control the hardware.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别或开发一个Linux内核设备驱动程序以控制硬件。
- en: Create a kernel Device Tree overlay that instantiates and configures the driver.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个内核设备树覆盖层，以实例化和配置驱动程序。
- en: Develop a user space library to interface with the kernel device driver.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个用户空间库以与内核设备驱动程序接口。
- en: Develop JNI bindings to the userspace library.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户空间库开发JNI绑定。
- en: Develop an Android manager using the JNI bindings to interface with the hardware.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI绑定开发一个Android管理者以与硬件接口。
- en: Sometimes, it isn't a clear decision as to where a particular piece of custom
    hardware should be properly integrated into the HAL and which manager should be
    in charge of accessing the hardware. What Android permissions control access to
    the hardware? Will the API have to be extended to offer new types of permissions?
    Will a custom service have to be created?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，很难决定特定的自定义硬件应该正确地集成到HAL的哪个位置，以及哪个管理者应该负责访问硬件。Android的哪些权限控制对硬件的访问？API是否需要扩展以提供新型权限？是否需要创建自定义服务？
- en: Implementing every aspect of a proper HAL for a piece of custom hardware is
    a bit of an overkill for hobbyists, students, and other developers interested
    in simple experimentation with hardware interfacing. While a commercial Android
    system must address all of these steps to develop a proper HAL, we take a far
    more direct approach to hardware access in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于爱好者、学生和其他对硬件接口简单实验感兴趣的开发商来说，为一块自定义硬件实现一个适当HAL的每个方面都有点过于复杂。虽然商业Android系统必须完成所有这些步骤以开发适当的HAL，但本书采取了一种更为直接的硬件访问方法。
- en: As our focus is on showing how you can interface Android apps with hardware,
    we skip steps 1 through 4 by providing you with **PacktHAL**, a native library
    that implements a very simple HAL. PacktHAL will ease you into the daunting task
    of interfacing with hardware on the BBB, and it provides a set of functions that
    are capable of interfacing with the hardware used in the examples throughout this
    book. Strictly speaking, your apps will act as the manager in charge of each hardware
    resource.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的重点是展示如何将Android应用与硬件接口，我们通过提供**PacktHAL**这一本地库来跳过步骤1至4。PacktHAL是一个实现了非常简单的HAL的本地库，它将帮助你轻松地开始BBB上与硬件接口的艰巨任务，并提供了一组能够与本书示例中使用的硬件接口的函数。严格来说，你的应用将作为每个硬件资源的管理者。
- en: Working with PacktHAL
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PacktHAL工作
- en: 'Apps communicate with the native calls of PacktHAL using JNI. PacktHAL demonstrates
    how to perform user space interfacing with hardware via three different interfacing
    methods: `GPIO`, `SPI`, and `I2C`. Using PacktHAL, you have direct access to hardware
    devices. [Chapters 3](part0024_split_000.html#page "Chapter 3. Handling Inputs
    and Outputs with GPIOs") through [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution") provide examples of how this interfacing works
    and how you can use it within your own Android app code. Each chapter will examine
    the various pieces of PacktHAL used in the app examples of that chapter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过 JNI 与 PacktHAL 的本地调用进行通信。PacktHAL 展示了如何通过三种不同的接口方法：`GPIO`、`SPI` 和 `I2C`，与硬件进行用户空间交互。使用
    PacktHAL，你可以直接访问硬件设备。[第3章](part0024_split_000.html#page "Chapter 3. Handling Inputs
    and Outputs with GPIOs")至[第6章](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution")提供了这种接口如何工作以及如何在你的 Android 应用代码中使用它的示例。每一章将检查该章节应用示例中使用的
    PacktHAL 的各个部分。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How does PacktHAL actually talk to hardware?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**PacktHAL 实际上是如何与硬件通信的？**'
- en: Generally, any method that allows you to interface with hardware under Linux
    can also be used by the HAL for interfacing. Reading, writing, and making `ioctl()`
    calls to files in the `/dev` filesystem will work, as does using `mmap()` to provide
    access to memory-mapped control registers. PacktHAL uses all of these techniques
    to interface with the hardware that you connect to your BBB.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何允许你在 Linux 下与硬件接口的方法也可以被 HAL 用于接口。读取、写入以及对 `/dev` 文件系统中的文件进行 `ioctl()`
    调用是有效的，使用 `mmap()` 提供对内存映射控制寄存器的访问也同样有效。PacktHAL 使用这些技术与你连接到 BBB 的硬件进行接口。
- en: Using PacktHAL is nowhere near as secure as a proper HAL implementation because
    we must change the permissions on the hardware's user space interfaces such that
    *any* app can access the hardware directly. This can potentially make your system
    vulnerable to malicious apps, so such an approach should never be used in a production
    device. Users that root (gain superuser access to) commercial Android phones and
    tablets often do so to lessen the strict permissions on these devices by default.
    This allows them to install and enable custom features, and it provides more flexibility
    and customization for their devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PacktHAL 远没有正确的 HAL 实现安全，因为我们必须改变硬件用户空间接口的权限，使得*任何*应用都能直接访问硬件。这可能会使你的系统容易受到恶意应用的攻击，因此这种做法绝不能在生产设备中使用。用户通常会对商业
    Android 手机和平板进行 root（获取超级用户权限），以减少这些设备默认的严格权限。这使得他们可以安装和启用自定义功能，并为他们的设备提供更多的灵活性和定制。
- en: As you are using the BBB as an Android-prototyping device, such an approach
    is the easiest way for you to interact with the hardware. This is a stepping stone
    towards developing your own custom managers and services that speak to your hardware
    on behalf of apps. Ideally, on a commercial device, only an Android manager will
    have the necessary permissions to directly interface with the hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将 BBB 作为 Android 原型设备使用，这种做法是你与硬件交互的最简单方式。这是朝着开发自己的自定义管理器和服务迈出的一步，这些管理器和服务代表应用与你的硬件通信。理想情况下，在商业设备上，只有
    Android 管理器才有必要的权限直接与硬件接口。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once you become comfortable with using PacktHAL in your apps, you can then examine
    PacktHAL's source code to better understand how native code interfaces with the
    Linux kernel. Eventually, you might find yourself integrating PacktHAL into your
    own custom managers. You might even find yourself developing custom code for the
    actual kernel!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯在应用中使用 PacktHAL，你可以检查 PacktHAL 的源代码，以更好地理解本地代码如何与 Linux 内核接口。最终，你可能会发现自己将
    PacktHAL 集成到自己的自定义管理器中。你甚至可能会发现自己为实际的内核开发自定义代码！
- en: Installing PacktHAL
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PacktHAL
- en: All of the various pieces of PacktHAL are located in the `PacktHAL.tgz` file,
    which is available for download from Packt's website ([http://www.packtpub.com/support](http://www.packtpub.com/support)).
    This is a compressed tar file that contains all of the source code and configuration
    files required to modify BBBAndroid to use PacktHAL and include PacktHAL support
    in your apps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL 的所有组成部分都位于 `PacktHAL.tgz` 文件中，该文件可在 Packt 的网站([http://www.packtpub.com/support](http://www.packtpub.com/support))下载。这是一个压缩的
    tar 文件，包含了修改 BBBAndroid 以使用 PacktHAL 并在应用中包含 PacktHAL 支持所需的所有源代码和配置文件。
- en: Preparing PacktHAL under Linux
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 下准备 PacktHAL
- en: Once you have downloaded the `PacktHAL.tgz` file, you must decompress and untar
    it. We will assume that you have copied `PacktHAL.tgz` to your home directory
    after downloading it and will decompress it from there. We will refer to your
    home directory as `$HOME`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`PacktHAL.tgz`文件后，你必须解压并展开它。我们将假设你在下载后已将`PacktHAL.tgz`复制到你的主目录并从那里解压。我们将你的主目录称为`$HOME`。
- en: 'Use the Linux `tar` command to decompress and untar the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux的`tar`命令来解压并展开文件：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A directory named `PacktHAL` now exists in your `$HOME` directory. All of the
    PacktHAL files are located in this directory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`$HOME`目录中现在存在一个名为`PacktHAL`的目录。所有PacktHAL文件都位于此目录中。
- en: Preparing PacktHAL under Windows
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下准备PacktHAL
- en: Once you have downloaded the `PacktHAL.tgz` file, decompress and untar it. We
    will assume that you have copied `PacktHAL.tgz` to the root directory of the `C:`
    drive after downloading it and will use WinRAR to decompress it from there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`PacktHAL.tgz`文件后，解压并展开它。我们将假设你在下载后已将`PacktHAL.tgz`复制到`C:`驱动器的根目录，并使用WinRAR从那里解压。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where should I unpack PacktHAL.tgz?**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该在哪里解压PacktHAL.tgz？**'
- en: You can decompress and untar `PacktHAL.tgz` on the desktop or wherever else
    you wish, but you will be performing some command-line commands to copy files
    around later. It is much simpler to perform these operations if `PacktHAL.tgz`
    is decompressed and untarred in the root directory of the `C:` drive, so we will
    assume that you are performing these operations from there.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在桌面或其他任何地方解压和展开`PacktHAL.tgz`文件，但稍后你将需要执行一些命令行命令来复制文件。如果`PacktHAL.tgz`在`C:`驱动器的根目录下解压和展开，这些操作会简单得多，因此我们将假设你从那里执行这些操作。
- en: 'Perform the following steps to extract the `PacktHAL.tgz` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以提取`PacktHAL.tgz`文件：
- en: Open a file explorer window and navigate to the root of the `C:` drive.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口，导航至`C:`驱动器的根目录。
- en: Right-click on the `PacktHAL.tgz` file in file explorer and select **Extract
    Here**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器中右键点击`PacktHAL.tgz`文件并选择**在此处解压**。
- en: A directory named `C:\PacktHAL` now exists. All of the PacktHAL files are located
    in this directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存在一个名为`C:\PacktHAL`的目录。所有PacktHAL文件都位于此目录中。
- en: The PacktHAL directory structure
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PacktHAL目录结构
- en: 'The `PacktHAL` directory has the following structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`PacktHAL`目录具有以下结构：'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `cape` subdirectory contains the source code and build script for building
    a Device Tree overlay that enables all of the hardware features that PacktHAL
    needs. You will learn more about Device Tree overlays later in this chapter. The
    `jni` subdirectory contains the source code files that implement PacktHAL. These
    source files will be added to your projects in later chapters to build PacktHAL
    support into your apps. The `prebuilt` directory contains a few premade files
    that must be added to your BBBAndroid image and Android NDK to build and use PacktHAL.
    You will install the files in the `prebuilt` directory to their required locations
    in the next few sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cape`子目录包含了构建Device Tree覆盖所需源代码和构建脚本，以启用PacktHAL所需的所有硬件功能。你将在本章后面了解更多关于Device
    Tree覆盖的内容。`jni`子目录包含了实现PacktHAL的源代码文件。这些源文件将在后面的章节中添加到你的项目中，以便在应用中构建对PacktHAL的支持。`prebuilt`目录包含一些预制的文件，这些文件必须添加到你的BBBAndroid映像和Android
    NDK中，以构建和使用PacktHAL。你将在接下来的几节中将`prebuilt`目录中的文件安装到它们所需的位置。'
- en: Preparing Android for PacktHAL
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PacktHAL准备Android
- en: Before using PacktHAL with any apps, you have to prepare your BBBAndroid installation.
    By default, Android is very restrictive on the permissions that it assigns to
    hardware devices. To use PacktHAL, you must lessen the permission restrictions
    and configure Android for the hardware that you will interface with. These actions
    require copying some prebuilt files into your Android system to make a few configuration
    changes that relax various Android permissions and configure the hardware properly
    for PacktHAL's use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用中使用PacktHAL之前，你必须准备你的BBBAndroid安装环境。默认情况下，Android对硬件设备的权限分配非常严格。要使用PacktHAL，你必须减少权限限制并为将要接口的硬件配置Android。这些操作需要将一些预构建的文件复制到你的Android系统中，进行一些配置更改，以放宽各种Android权限并正确为PacktHAL配置硬件。
- en: You will use the ADB tool to push (`push`) the necessary files over to your
    running BBB system. Prior to pushing the files, boot Android on the BBB and connect
    the BBB to your PC using the USB cable that came with your BBB. Once you have
    reached this point, continue with the instructions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 ADB 工具将必要的文件推送到正在运行的 BBB 系统。在推送文件之前，启动 BBB 上的 Android 并使用随 BBB 一起提供的 USB
    电缆将 BBB 连接到你的电脑。一旦你达到这个阶段，继续按照说明操作。
- en: Pushing PacktHAL files under Linux
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 下推送 PacktHAL 文件
- en: 'The following steps are used in order to publish PacktHAL files under Linux:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是在 Linux 下发布 PacktHAL 文件的方法：
- en: 'Before you get started, make sure that ADB can see your BBB by using the `adb
    devices` command. The BBB will report as having a serial number of `BBBAndroid`.
    Execute the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保使用 `adb devices` 命令确认 ADB 能够看到你的 BBB。BBB 将报告有一个序列号为 `BBBAndroid`。执行以下命令：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are missing the `adb` command, install the `android-tools-adb` package
    via `apt-get`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你缺少 `adb` 命令，可以通过 `apt-get` 安装 `android-tools-adb` 包：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why can''t Linux find my BBB?**'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**为什么 Linux 找不到我的 BBB？**'
- en: If `adb` is installed on your system and you are unable to see the BBB, you
    might need to add a `udev` rule to your system and perform some additional troubleshooting.
    Google provides directions for adding this rule and some troubleshooting steps
    if you run into any difficulty, and this can be found at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的系统上安装了 `adb` 但无法看到 BBB，你可能需要向系统添加一个 `udev` 规则并进行一些额外的故障排除。如果你遇到任何困难，Google
    提供了添加此规则和故障排除步骤的指导，可以在 [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)
    找到。
- en: BBBAndroid reports the USB device ID of its ADB interface as `18D1:4E23`, which
    is the device ID of a Google Nexus S, so the USB vendor ID for the BBB is 18D1
    (the device ID for Google devices).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BBBAndroid 报告其 ADB 接口的 USB 设备 ID 为 `18D1:4E23`，这是 Google Nexus S 的设备 ID，所以 BBB
    的 USB 供应商 ID 是 18D1（Google 设备的设备 ID）。
- en: 'Once you have verified that `adb` can see the BBB, change into the `PacktHAL`
    directory, shell into Android via `adb`, and remount the read-only `rootfs` filesystem
    as read-write:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你确认 `adb` 能够看到 BBB 后，切换到 `PacktHAL` 目录，通过 `adb` 进入 Android 的 shell，并将只读的 `rootfs`
    文件系统重新挂载为可读写：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将必要的文件推送到 Android 的 `rootfs` 文件系统：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，进入 Android 的 `rootfs` 文件系统以同步它，并将其重新挂载为只读：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You have now prepared your BBBAndroid image for PacktHAL under Linux. Remove
    the power supply cable and USB cable from your BBB to shut it down.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经在 Linux 下为 PacktHAL 准备好了 BBBAndroid 镜像。从你的 BBB 上拔掉电源线和 USB 电缆以关闭它。
- en: Then, power up the BBB to verify that Android boots properly with the modifications
    that you have just made.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启动 BBB 以验证你刚才所做的修改后 Android 是否能正常启动。
- en: Pushing PacktHAL files under Windows
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 下推送 PacktHAL 文件
- en: You must locate where your `adb.exe` file is located. It is part of the platform
    tools in the Android SDK. In the following instructions, we are assuming that
    you installed the Eclipse ADT in the `c:\adt-bundle` directory, making the full
    path to `adb` to be `c:\adt-bundle\sdk\platform-tools\adb.exe`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要找到你的 `adb.exe` 文件的位置。它是 Android SDK 中平台工具的一部分。在以下说明中，我们假设你将 Eclipse ADT 安装在
    `c:\adt-bundle` 目录下，那么 `adb` 的完整路径就是 `c:\adt-bundle\sdk\platform-tools\adb.exe`。
- en: 'The following steps are used in order to publish PacktHAL files under Windows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是在 Windows 下发布 PacktHAL 文件的方法：
- en: 'Before you get started, make sure that `adb` can see your BBB by using the
    `adb devices` command. The BBB will report as having a serial number of `BBBAndroid`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保使用 `adb devices` 命令确认 `adb` 能够看到你的 BBB。BBB 将报告有一个序列号为 `BBBAndroid`：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why can''t Windows find my BBB?**'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**为什么 Windows 找不到我的 BBB？**'
- en: It can be notoriously difficult to get `adb` to see Android devices under Windows.
    This is because each hardware manufacturer that creates an Android device provides
    its own Windows ADB device driver that Windows uses to talk to that device. BBBAndroid
    reports the USB device ID of its ADB interface as `18D1:4E23`, which is the device
    ID of a Google Nexus S. This device is one of the (many) USB devices that are
    supported by Koushik Dutta's excellent Universal ADB driver for Windows. If `adb`
    can't find your BBB, install the Universal ADB driver and then try again. You
    can download the driver from [http://www.koushikdutta.com/post/universal-adb-driver](http://www.koushikdutta.com/post/universal-adb-driver).
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Windows下让`adb`识别Android设备可能会非常困难。这是因为每个创建Android设备的硬件制造商都为其提供了自己的Windows ADB设备驱动程序，Windows使用该驱动程序与设备通信。BBBAndroid报告其ADB接口的USB设备ID为`18D1:4E23`，这是Google
    Nexus S的设备ID。这是Koushik Dutta为Windows提供的优秀通用ADB驱动程序支持的众多USB设备之一。如果`adb`找不到您的BBB，请安装通用ADB驱动程序，然后重试。您可以从[http://www.koushikdutta.com/post/universal-adb-driver](http://www.koushikdutta.com/post/universal-adb-driver)下载驱动程序。
- en: 'Once you have verified this, `adb` can see the BBB, shell into Android via
    `adb`, and remount the read-only `rootfs` filesystem as read-write:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证这一点后，`adb`可以看到BBB，通过`adb`进入Android的shell，并将只读的`rootfs`文件系统重新挂载为读写：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将必要的文件推送到Android的`rootfs`文件系统：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过shell进入Android的`rootfs`文件系统，将其同步并重新挂载为只读：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have now prepared your BBBAndroid image for PacktHAL under Windows. Remove
    the power supply cable and USB cable from your BBB to shut it down. Then, power
    up the BBB to verify that Android boots properly with the modifications that you
    have just made.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已经在Windows下为PacktHAL准备好了BBBAndroid映像。请将电源线和USB线从BBB上拔下以关闭它。然后，给BBB供电，以验证您刚才所做的修改后Android是否能正常启动。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why is it that the init.genericam33xx(flatteneddevicetr.rc file is named
    so oddly?**'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**为什么init.genericam33xx（flatteneddevicetr.rc文件命名如此奇怪？**'
- en: Android devices have a set of read-only properties that describe the hardware
    and software of the system to apps and managers. One of these properties is `ro.hardware`,
    which describes the hardware that the kernel is configured for. Device-specific
    `.rc` files in Android have the `init.{ro.hardware}.*rc` form.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android设备有一组只读属性，它们向应用程序和管理器描述系统的硬件和软件。其中之一是`ro.hardware`，它描述了内核配置的硬件。Android中的设备特定`.rc`文件具有`init.{ro.hardware}.*rc`的形式。
- en: In the Linux kernel source, the `arch/arm/mach-omap2/board-generic.c` file uses
    a `DT_MACHINE_START()` macro to specify the name of the BBB platform as `Generic
    AM33XX (Flattened Device Tree)`. This text string is converted to lowercase, spaces
    are removed, and the string is truncated to produce the final string that is stored
    in the `ro.hardware` property.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux内核源代码中，`arch/arm/mach-omap2/board-generic.c`文件使用`DT_MACHINE_START()`宏来指定BBB平台的名称为`Generic
    AM33XX (Flattened Device Tree)`。这个文本字符串被转换为小写，删除空格，并截断以生成存储在`ro.hardware`属性中的最终字符串。
- en: Setting up the Android NDK for PacktHAL
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PacktHAL设置Android NDK
- en: Unfortunately, the Android **Native Development Kit** (**NDK**) is missing a
    kernel header file that is needed to build PacktHAL. The missing header describes
    the interface between user space apps and the generic SPI driver (`spidev`, which
    you will use in [Chapter 5](part0035_split_000.html#page "Chapter 5. Interfacing
    with High-speed Sensors Using SPI"), *Interfacing with High-speed Sensors Using
    SPI*). It is not the fault of the NDK that this header file is missing, as usually
    apps will never need direct access to the `spidev` driver.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Android的**原生开发工具包**（**NDK**）缺少一个构建PacktHAL所需的内核头文件。这个缺失的头文件描述了用户空间应用程序与通用SPI驱动程序（`spidev`，您将在[第5章](part0035_split_000.html#page
    "第5章. 使用SPI与高速传感器接口")，*使用SPI与高速传感器接口*中使用）之间的接口。这个头文件缺失并不是NDK的错，因为通常应用程序不需要直接访问`spidev`驱动程序。
- en: As you are using an app to talk directly talk to the hardware, you will need
    to copy this missing header into your NDK installation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您是使用应用程序直接与硬件通信，因此需要将这个缺失的头文件复制到您的NDK安装中。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For your convenience, we have included a copy of this header file in the PacktHAL
    source tarball. You only need to copy the file into your NDK installation prior
    to building PacktHAL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们在PacktHAL源代码压缩包中包含了这个头文件的副本。在构建PacktHAL之前，您只需要将文件复制到您的NDK安装中。
- en: BBBAndroid is 4.4.4 KitKat, and API level 19 is the highest level supported
    by this version. You will be building all of the examples in this book for API
    level 19\. Each API level has a different set of headers in the NDK, so you must
    add the missing headers to the `include/linux` directory for API level 19\. If
    you decide to build apps at lower API levels, you can repeat the following steps
    to add the additional header file to any of the other API levels that you wish
    to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: BBBAndroid是4.4.4 KitKat版本，API级别19是此版本支持的最高级别。你将为本书的示例构建API级别19的所有内容。每个API级别在NDK中都有不同的头文件集，因此你必须向API级别19的`include/linux`目录添加缺失的头文件。如果你决定在较低的API级别构建应用，可以重复以下步骤，将附加头文件添加到你想使用的任何其他API级别中。
- en: Adding the header to the NDK under Linux
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下向NDK添加头文件
- en: 'If you are going to be building apps using Eclipse ADT under Linux, you will
    need to have the Android NDK installed on your Linux system. For these instructions,
    we will assume that you have already installed the NDK to the `android-ndk` folder
    in your `$HOME` directory. As you have already downloaded, decompressed, and untarred
    the `PacktHAL.tgz` file to your `$HOME` directory earlier in this chapter, we
    will assume that the `PacktHAL` directory that you created is still there:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在Linux下使用Eclipse ADT构建应用，你需要在你的Linux系统上安装Android NDK。对于这些说明，我们将假设你已经将NDK安装到`$HOME`目录下的`android-ndk`文件夹中。由于在本章前面你已经下载、解压并解包了`PacktHAL.tgz`文件到你的`$HOME`目录，我们将假设你创建的`PacktHAL`目录还在那里：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Linux NDK installation now has the extra header file that it
    needs to build PacktHAL.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`spi`头文件目录的内容复制到你的NDK头文件中。现在你的Linux NDK安装中有了构建PacktHAL所需的额外头文件。
- en: Adding the header to the NDK under Windows
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下向NDK添加头文件
- en: 'If you are going to be building apps using Eclipse ADT under Windows, you will
    need to have the Android NDK installed on your Windows system. For these instructions,
    we will assume that you have installed the NDK to the `c:\android-ndk` folder.
    As you have already downloaded, decompressed, and untarred the `PacktHAL.tgz`
    file to your `c:\` directory earlier in this chapter, we will assume that the
    `PacktHAL` directory that you created is still there:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在Windows下使用Eclipse ADT构建应用，你需要在你的Windows系统上安装Android NDK。对于这些说明，我们将假设你已经将NDK安装到`c:\android-ndk`文件夹中。由于在本章前面你已经下载、解压并解包了`PacktHAL.tgz`文件到你的`c:\`目录，我们将假设你创建的`PacktHAL`目录还在那里：
- en: Open a file explorer window and navigate to the `c:\android-ndk\platforms\android-19\arch-arm\usr\include\linux`
    path.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口，导航至`c:\android-ndk\platforms\android-19\arch-arm\usr\include\linux`路径。
- en: Open a second file explorer window and navigate to the `c:\PacktHAL\prebuilt`
    path. Right-click on the `spi` directory and select **Copy** from the context
    menu.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个文件资源管理器窗口，导航至`c:\PacktHAL\prebuilt`路径。右键点击`spi`目录，并在上下文菜单中选择**复制**。
- en: Change to the Android NDK window, right-click anywhere within the white space
    of the file list in the window, and select **Paste** from the context menu.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到Android NDK窗口，在窗口中的文件列表空白处右键点击，然后在上下文菜单中选择**粘贴**。
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Windows NDK installation now has the extra header file that
    it needs to build PacktHAL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`spi`头文件目录的内容复制到你的NDK头文件中。现在你的Windows NDK安装中有了构建PacktHAL所需的额外头文件。
- en: Multiplexing the BBB pins
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对BBB引脚进行复用
- en: As accessing hardware resources follows the same process under Android as it
    does under Linux, it is important to understand how the Linux kernel configures
    device drivers and allocates them to particular pieces of hardware. It is also
    necessary to understand how these kernel drivers provide user space interfaces
    that PacktHAL can interact with.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Android下访问硬件资源与在Linux下遵循相同的流程，因此了解Linux内核如何配置设备驱动程序并将它们分配给特定的硬件非常重要。也有必要了解这些内核驱动程序如何为PacktHAL提供可以与之交互的用户空间接口。
- en: The BBB's AM3359 processor offers a wide variety of signals on its hundreds
    of pins. These signals include many different, specialized interface buses and
    sensor inputs. There are far too many potential signals for the number of pins
    available to supply these signals to the outside world. To select which signals
    are available on the pins, the pins are multiplexed, or *muxed*, to specific signals.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的AM3359处理器在其数百个引脚上提供了各种各样的信号。这些信号包括许多不同的、专门的接口总线和传感器输入。潜在的信号数量远远超过了可用于将这些信号输出到外界的引脚数量。为了选择哪些信号在引脚上可用，这些引脚被复用，或称为*muxed*，到特定的信号。
- en: Several of the processor's pins are wired to the connections of the BBB's P8
    and P9 headers. The muxing of these particular pins is of great interest to BBB
    users, as the muxing determines which processor signals and features are easily
    accessible to the user for hardware interfacing. There are 46 pins on each of
    the BBB's two headers, giving you a total of 92 pins to interface with. Unfortunately,
    61 of these pins are in use by default, meaning that only 31 pins can be changed
    around for your projects without you having to disable one or more standard features
    of the BBB to make more pins available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的几个引脚被连接到BBB的P8和P9头的连接上。这些特定引脚的复用对BBB用户来说非常重要，因为复用决定了哪些处理器信号和功能可以容易被用户用于硬件接口。BBB的两个头各有46个引脚，总共有92个引脚可供接口使用。不幸的是，默认情况下有61个引脚正在使用，这意味着在不禁用BBB的一个或多个标准功能的情况下，只有31个引脚可以为你项目所变动。
- en: '![Multiplexing the BBB pins](img/00008.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![BBB引脚复用](img/00008.jpeg)'
- en: The P8 and P9 expansion headers of the BeagleBone Black
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black的P8和P9扩展头
- en: Some pins on the headers are permanently assigned, such as the pins that provide
    access to voltage (1.8, 3.3, and 5 VDC are available) and ground signals. The
    other pins though, can be muxed to meet the needs of your project. Proper muxing
    all of the P8/P9 pins to provide all of the resources that you require can sometimes
    be tricky, particularly if you are only beginning to learn about the hardware
    interfacing aspects of the BBB. Luckily, we have already determined a pinmux configuration
    for you that will provide PacktHAL with all of the hardware resources that it
    needs to run all of the exercises in this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 头上的某些引脚是永久分配的，例如提供访问电压（1.8、3.3和5 VDC可用）和地线的引脚。然而，其他引脚可以根据项目的需要进行复用。正确复用所有的P8/P9引脚以提供你所需要的所有资源有时可能很棘手，特别是如果你刚开始学习BBB的硬件接口方面。幸运的是，我们已经为你确定了一个引脚复用配置，这将提供给PacktHAL运行本书中所有练习所需的所有硬件资源。
- en: '![Multiplexing the BBB pins](img/00009.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![BBB引脚复用](img/00009.jpeg)'
- en: Default pins in use on the BeagleBone Black
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black上默认使用的引脚
- en: The kernel Device Tree and capemgr
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核Device Tree和capemgr
- en: The pins of the BBB must be muxed in a specific way to speak with custom hardware,
    but where and how is this actually done? The answer is "the kernel's **Device
    Tree**." The Device Tree is a hierarchical data structure inside the kernel that
    describes what hardware is present, which resources are used by that hardware,
    and which kernel drivers should be used to talk to each hardware device. It describes
    different facets of the hardware, such as pin muxing settings, clock speeds, and
    parameters that are passed to kernel device drivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的引脚必须以特定的方式复用以与自定义硬件通信，但实际在哪里以及如何进行呢？"答案是"内核的**Device Tree**。" Device Tree是内核中的一个层次化数据结构，描述了存在哪些硬件，这些硬件使用了哪些资源，以及应该使用哪些内核驱动程序与每个硬件设备通信。它描述了硬件的不同方面，例如引脚复用设置、时钟速度和传递给内核设备驱动程序的参数。
- en: It would be an annoying hassle if the user was required to install a new kernel
    every time the hardware changed. For a hardware platform like the BBB, the user
    can change the hardware connected to the BBB between power cycles! It would be
    very useful to be able to dynamically change the Device Tree to add or remove
    hardware on the fly. The BBB's Linux 3.8 kernel has a special subsystem, called
    the **cape manager** (**capemgr**) that allows you to do just that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要求用户在每次硬件更改时都安装新内核，这将是一件非常麻烦的事情。对于BBB这样的硬件平台，用户可以在电源周期之间更改连接到BBB的硬件！能够动态地更改Device
    Tree以即时添加或移除硬件将非常有用。BBB的Linux 3.8内核有一个特殊的子系统，称为**cape管理器**（**capemgr**），它允许你这样做。
- en: 'The capemgr dynamically adds and removes pieces or *overlays* of the Device
    Tree. It provides three important services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: capemgr动态地添加和移除设备树的片段或*覆盖层*。它提供了三项重要的服务：
- en: It recognizes any cape hardware that is connected to the BBB
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它识别任何连接到 BBB 的 Cape 硬件
- en: It loads the appropriate Device Tree overlay to enable and configure each recognized
    cape
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它加载适当的设备树覆盖层以启用和配置每个被识别的 Cape
- en: It allows arbitrary Device Tree overlays to be loaded dynamically from user
    space to configure any hardware that is not automatically discovered
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许从用户空间动态加载任意的设备树覆盖层，以配置任何未被自动发现的硬件。
- en: Defining a cape
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Cape
- en: A cape is any hardware add-on that connects to the BBB's P8/P9 connectors (similar
    to how shield boards connect to an Arduino) and contains an **electrically erasable
    programmable read-only memory** (**EEPROM**) chip that reports the cape's identity
    to the kernel's capebus. The capemgr in the kernel can then dynamically enable
    the appropriate Device Tree overlay for that particular cape. This is what allows
    you to connect a variety of different, commercially available cape boards to the
    BBB, and they all just automatically work without you having to change a single
    configuration file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Cape 是任何连接到 BBB 的 P8/P9 连接器（类似于盾板连接到 Arduino）的硬件扩展，并包含一个**电可擦可编程只读存储器**（**EEPROM**）芯片，向内核的
    capebus 报告 Cape 的身份。内核中的 capemgr 然后可以为该特定 Cape 动态启用适当的设备树覆盖层。这就是允许你将各种不同的商业 Cape
    板连接到 BBB，并且它们全部自动工作，而无需你更改任何配置文件的原因。
- en: A much looser definition of a cape is any external circuitry that interfaces
    via the P8/P9 connectors. Without including an EEPROM that tells the capemgr "I
    am a cape and my name is XYZ", the capemgr won't automatically locate and load
    the proper Device Tree overlay for the cape. This is the case for all of the examples
    in this book. You can still consider the hardware that you connect to the BBB
    to be a cape that Android is interfacing with, but the Device Tree overlay must
    be loaded manually from user space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Cape 的定义较为宽松的是指任何通过 P8/P9 连接器接口的外部电路。如果没有包含一个 EEPROM 来告诉 capemgr “我是一个名为 XYZ
    的 Cape”，capemgr 便不会自动定位并加载适合该 Cape 的正确设备树覆盖层。本书中的所有示例都是这种情况。你仍然可以将连接到 BBB 的硬件视为
    Android 正在接口的 Cape，但设备树覆盖层必须从用户空间手动加载。
- en: Earlier in this chapter, you used `adb` to push a file named `BB-PACKTPUB-00A0.dtbo`
    to your Android image. This file is the Device Tree overlay that configures the
    BBB for the hardware that you will use in the exercises throughout this book.
    The custom `init.genericam33xx(flatteneddevicetr.rc` file that you also pushed
    over to the Android image manually loads this overlay for you during Android's
    boot process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你使用了 `adb` 将一个名为 `BB-PACKTPUB-00A0.dtbo` 的文件推送到你的 Android 映像中。这个文件是配置
    BBB 以适应你将在本书练习中使用的硬件的设备树覆盖层。你同样推送过去的自定义 `init.genericam33xx(flatteneddevicetr.rc`
    文件在 Android 启动过程中为你手动加载了这个覆盖层。
- en: In the Linux filesystem, custom overlays are placed into the `/lib/firmware`
    directory. Under Android, however, there is no `/lib` directory in `rootfs`, so
    overlays are instead placed into the `/system/vendor/firmware` directory. This
    is also the location where firmware (`.fw` files) built during kernel compilation
    is installed. When using your own Device Tree overlays for your future projects,
    remember to place them into the `/system/vendor/firmware` directory so that the
    capemgr can find them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 文件系统中，自定义覆盖层被放置在 `/lib/firmware` 目录中。但在 Android 下，`rootfs` 中没有 `/lib`
    目录，因此覆盖层被放置在 `/system/vendor/firmware` 目录中。这也是在内核编译期间构建的固件（`.fw` 文件）安装的位置。在使用你未来的项目中的自定义设备树覆盖层时，请记得将它们放置到
    `/system/vendor/firmware` 目录中，以便 capemgr 能够找到它们。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where can I learn more about multiplexing the BBB''s pins, the Device Tree,
    and creating custom overlays?**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**我在哪里可以了解更多关于复用 BBB 的引脚、设备树以及创建自定义覆盖层的信息？**'
- en: 'Learning how to select the best pin muxing for custom projects and creating
    the appropriate Device Tree overlays are outside the scope of this book, but there
    are many excellent resources available that can introduce you to the process.
    Here are a few great resources we recommend that you read to learn more:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何为自定义项目选择最佳的引脚复用（pin muxing）并创建适当的设备树覆盖层超出了本书的范围，但有许多优秀的资源可以介绍你了解这个过程。以下是我们推荐你阅读的一些学习更多知识的优秀资源：
- en: 'The BeagleBone Black System reference manual: [http://www.adafruit.com/datasheets/BBB_SRM.pdf](http://www.adafruit.com/datasheets/BBB_SRM.pdf)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeagleBone Black 系统参考手册：[http://www.adafruit.com/datasheets/BBB_SRM.pdf](http://www.adafruit.com/datasheets/BBB_SRM.pdf)
- en: 'Derek Molloy''s website: [http://derekmolloy.ie/category/embedded-systems/beaglebone/](http://derekmolloy.ie/category/embedded-systems/beaglebone/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Derek Molloy 的网站：[http://derekmolloy.ie/category/embedded-systems/beaglebone/](http://derekmolloy.ie/category/embedded-systems/beaglebone/)
- en: 'AdaFruit''s Device Tree Overlay tutorial: [https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree](https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdaFruit 的 Device Tree Overlay 教程：[https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree](https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree)
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explained how Android uses a HAL to allow Android managers
    to provide hardware access to apps. We introduced you to PacktHAL that can be
    used to interface with all of the examples throughout this book. You configured
    your BBBAndroid image to use PacktHAL, and you modified your NDK installation
    to build PacktHAL into your apps.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了 Android 如何使用 HAL 让 Android 管理器向应用提供硬件访问权限。我们向你介绍了 PacktHAL，它可用于与本书中的所有示例进行接口交互。你配置了
    BBBAndroid 镜像以使用 PacktHAL，并且修改了你的 NDK 安装，以便将 PacktHAL 构建到你的应用中。
- en: We also showed which pins of the BBB's P8/P9 headers can be multiplexed, what
    the Device Tree is and how it is used to multiplex pins, and how the capemgr loads
    Device Tree overlays to dynamically mux the BBB's pins.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了 BBB 的 P8/P9 头部哪些引脚可以进行复用，Device Tree 是什么以及如何使用它来复用引脚，以及 capemgr 如何加载
    Device Tree 覆盖层以动态复用 BBB 的引脚。
- en: In the next chapter, you'll put PacktHAL to work and build your first hardware-interfacing
    app using GPIOs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始使用 PacktHAL 并构建你的第一个使用 GPIOs 的硬件接口应用。
