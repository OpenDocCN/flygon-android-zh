- en: Chapter 6. Platformer – Bob, Beeps, and Bumps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 平台游戏 - Bob、哔哔声和碰撞
- en: Now that our basic game engine is set up, we can start making some fast progress.
    In this chapter, we will quickly add a `SoundManager` class that we will use to
    make a noise wherever and whenever we please. After that, we will put some meat
    on the bones of Bob and implement the core functionality we require in the `Player`
    class. Then, we can handle the second phase (after clipping) of our multiphase
    collision detection and give Bob the useful skill of being able to stand on a
    platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 basic 游戏引擎设置好后，我们就可以开始快速进展了。在本章中，我们将快速添加一个`SoundManager`类，我们可以在任何需要的时候用它来发出声音。之后，我们将为Bob添加一些实质性的内容，并在`Player`类中实现我们所需的核心功能。然后，我们可以处理多阶段碰撞检测的第二阶段（剪辑后），让Bob具备站在平台上的有用技能。
- en: After we have achieved this significant feat, we will hand over control of Bob
    to the player by implementing the `InputController` class. Bob will at last be
    able to run around and jump. At the end of this chapter, we will animate Bob's
    sprite sheet so he actually appears to run, rather than slide everywhere.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这项重大任务后，我们将通过实现`InputController`类将Bob的控制权交给玩家。Bob终于能够到处跑和跳了。在本章结束时，我们将为Bob的精灵表制作动画，让他看起来真的在跑，而不是到处滑动。
- en: The SoundManager class
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SoundManager类
- en: Throughout the next few chapters, we will be adding sound effects for various
    events. Sometimes these sounds will be triggered directly in the main `PlatformView`
    class, but other times, they will need to be triggered in more remote corners
    of your code like the `InputController` class and even within the `GameObject`
    class themselves. We will quickly make a simple `SoundManager` class that can
    be passed around and used as needed when a beep is required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将为各种事件添加声音效果。有时这些声音将直接在主`PlatformView`类中触发，但其他时候，它们需要在代码更远的角落中触发，比如`InputController`类，甚至是在`GameObject`类内部。我们将快速制作一个简单的`SoundManager`类，当需要哔哔声时，可以传递并按需使用。
- en: 'Create a new Java class and call it `SoundManager`. This class has three main
    parts. In the first part, we simply declare a `SoundPool` object and a bunch of
    `int` variables to hold a reference to each sound effect. Enter the first part
    of the code, the declaration, and members:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Java类，将其命名为`SoundManager`。这个类有三个主要部分。在第一部分，我们简单地声明一个`SoundPool`对象和一些`int`变量，以保存每个声音效果的引用。以下是第一部分代码，声明和成员：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second part of the class is the `loadSound` method, which unsurprisingly
    loads all the sounds into memory ready for playing. We will call this once we
    have initialized a `SoundManager` object in the `PlatformView` constructor. Enter
    this code next:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类的第二部分是`loadSound`方法，它毫不意外地将所有声音加载到内存中，准备播放。我们在`PlatformView`构造函数中初始化一个`SoundManager`对象后，将调用这个方法。接下来输入这段代码：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally for our `SoundManager` class, we need to be able to play any sound
    we like. This `playSound` method simply switches on a string passed in as a parameter.
    When we have a `SoundManager` object, we can just call `playSound()` with an appropriate
    string argument:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的`SoundManager`类，我们需要能够播放任何我们喜欢的声音。这个`playSound`方法只是简单地通过一个作为参数传递的字符串来切换。当我们有一个`SoundManager`对象时，我们可以通过一个合适的字符串参数简单地调用`playSound()`。
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Declare a new object of type `SoundManager` after the `PlatformView` class declaration
    after your new game engine classes from the previous chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章你的新游戏引擎类之后，`PlatformView`类声明后声明一个类型为`SoundManager`的新对象。
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, initialize the `SoundManager` object and call `loadSound()` in the `PlatformView`
    constructor as shown:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`PlatformView`构造函数中初始化`SoundManager`对象，并调用`loadSound()`，如下所示：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can create all your own sounds using BFXR or just copy mine from the `Chapter6/assets`
    folder. Copy all the sounds to the `assets` folder in your Android Studio project.
    Create an `assets` folder in the `src/main` folder of your project in order to
    achieve this if the folder doesn't exist already.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用BFXR创建所有自己的声音，或者直接从`Chapter6/assets`文件夹复制我的。将所有声音复制到你的Android Studio项目的`assets`文件夹中。如果还不存在，请在项目的`src/main`文件夹中创建一个`assets`文件夹以实现这一点。
- en: Now, we can play sound effects wherever we like. It's time to bring our hero
    Bob to life.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何地方播放声音效果。是时候让我们的英雄Bob活灵活现了。
- en: Introducing Bob
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Bob
- en: Here, we can add the meat to the bones of your `Player` class. However, this
    section won't be the last time we revisit the `Player` class. Now, we will add
    the necessary functionality to allow Bob to move. Immediately after we have done
    this, we will add the code to allow the player to use the forthcoming collision
    detection code and the `Animation` class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以为你的`Player`类增加一些实质性的内容。不过，这不会是我们最后一次回顾`Player`类。现在，我们将添加必要的功能，让Bob能够移动。完成这一步后，我们将会添加代码，允许玩家使用即将到来的碰撞检测代码和`Animation`类。
- en: First of all, we need to add some members to the `Player` class. The `Player`
    class will need to know how fast it can move, when the player is pressing the
    left or right controls, and if it is falling or jumping. In addition, the `Player`
    class needs to know how long it has been jumping and how long it should jump for.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`Player`类中添加一些成员。`Player`类需要知道它能移动多快，玩家何时按下左右控制键，以及它是否在掉落或跳跃。此外，`Player`类还需要知道它已经跳跃了多长时间，以及它应该跳跃多久。
- en: The next block of code provides variables for us to monitor all these things.
    We will very soon see, how we use them to make Bob do what we want.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块为我们提供了监控所有这些事物的变量。我们很快就会看到，如何使用它们让Bob做出我们想要的行为。
- en: 'Now, we know what the variables are for. We can add this code right after the
    class declaration as shown:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道这些变量是干什么用的了。我们可以在类声明后直接添加这段代码，如下所示：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Furthermore, there are some other movement-related conditions we will need
    to track, but they will be useful in other classes as well. Therefore, we will
    add them as members to the `GameObject` class. We will track the current horizontal
    and vertical speed, the direction the object is facing, and whether the object
    can move at all with the following variables. Add these to the `GameObject` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些其他与移动相关的条件我们需要跟踪，但它们在其他类中也会很有用。因此，我们将它们作为成员添加到`GameObject`类中。我们将跟踪当前的水平速度和垂直速度，对象面向的方向，以及以下变量来确定对象是否可以移动。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, in the `GameObject` class, we will add a `move` method. This method simply
    checks that the velocity on either of the axes is not zero and if it is, it moves
    the object by changing its `worldLocation` object. This method uses the velocity
    (either `xVelocity` or `yVelocity`) divided by the current frames per second to
    calculate the distance to move each frame. This ensures that the movement will
    be exactly correct, regardless of the current frames per second. It doesn't matter
    if our game executes smoothly or fluctuates a bit, or how powerful or puny the
    CPU in the Android device is. We will very soon call this `move` method from within
    the `update` method of the `Player` class. Later in the project, we will call
    it from other classes as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`GameObject`类中，我们将添加一个`move`方法。这个方法简单检查下x轴或y轴上的速度是否为零，如果不是，它就会通过改变对象的`worldLocation`来移动对象。这个方法使用速度（`xVelocity`或`yVelocity`）除以当前的每秒帧数来计算每帧移动的距离。这样可以确保无论当前的每秒帧数是多少，移动都是完全正确的。无论我们的游戏运行是否流畅，或者有所波动，或者安卓设备中的CPU性能强大与否，都没有关系。我们很快就会在`Player`类的`update`方法中调用这个`move`方法。在项目的后期，我们也会从其他类中调用它。
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, in the `GameObject` class, we have a bunch of getters and setters for
    the new variables we added previously. The only part to note is that the setters
    for the two velocity variables (`setxVelocity` and `setyVelocity`) check `if(moves)`
    before actually assigning a value. Add these new getters and setters to the `GameObject`
    class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GameObject`类中，我们为之前添加的新变量准备了一堆getter和setter方法。唯一需要注意的是，两个速度变量（`setxVelocity`和`setyVelocity`）的setter在真正赋值之前会检查`if(moves)`。
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, back in the `Player` class constructor, we can use some of these new methods
    to set up the object at creation time. Add the highlighted code to the `Player`
    constructor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Player`类的构造函数中，我们可以使用其中一些新方法在对象创建时进行设置。在`Player`构造函数中添加高亮显示的代码。
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At last, we can make practical use of all this new code in the `Player` class's
    `update` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`Player`类的`update`方法中实际使用所有这些新代码。
- en: First, we handle what happens when `isPressingRight` or `isPressingLeft` is
    true. Of course, we still need to be able to set these variables via touches on
    the screen. Very simply, this next code block sets the horizontal velocity to
    `MAX_X_VELOCITY` if `isPressingRight` is true or to `-MAX_X_VELOCITY` if `isPressingLeft`
    is true. If neither is true, it sets the horizontal velocity to zero, which is
    standing still.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理当`isPressingRight`或`isPressingLeft`为真时会发生什么。当然，我们还需要能够通过屏幕触摸来设置这些变量。很简单，下一个代码块如果`isPressingRight`为真，将水平速度设置为`MAX_X_VELOCITY`；如果`isPressingLeft`为真，则设置为`-MAX_X_VELOCITY`。如果都不为真，则将水平速度设置为零，即静止不动。
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we check which way the player is moving and call `setFacing()` with either
    `RIGHT` or `LEFT` as the argument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查玩家移动的方向，并调用`setFacing()`，参数为`RIGHT`或`LEFT`。
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can handle jumping. When the player presses the jump button, if successful,
    `isJumping` will be set to true and `jumpTime` will be set to whatever the current
    system time is. So we can then enter the `if(isJumping)` block on each frame,
    test how long Bob has been jumping for, and if he has not exceeded `maxJumpTime`
    take one of two possible actions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理跳跃。当玩家按下跳跃按钮时，如果成功，`isJumping`将被设置为真，`jumpTime`将被设置为当前系统时间。这样，我们就可以在每一帧进入`if(isJumping)`块，测试鲍勃已经跳跃了多长时间，并且如果他没有超过`maxJumpTime`，就会采取两个可能动作之一。
- en: Action one is; if we are less than half way through the jump, the *y* velocity
    is set to `-gravity` (going up). Action two is; if Bob is more than half way through
    the jump, his *y* velocity is set to `gravity` (going down).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 动作一是：如果我们还没有跳到一半，*y*速度设置为`-gravity`（向上）。动作二是：如果鲍勃跳过一半了，他的*y*速度设置为`gravity`（向下）。
- en: When `maxJumpTime` is exceeded, `isJumping` is set back to false until the next
    time the player taps the jump button. The final `else` clause in the following
    code executes whenever `isJumping` is false and sets the player's `y` velocity
    to `gravity`. Note that the additional line of code that sets `isFalling` to `true`.
    As we will see, this variable is used to control what happens when the player
    initially tries to jump and also in parts of our collision detection code. It
    basically stops the player from being able to jump in mid air.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当超过`maxJumpTime`时，`isJumping`会被重新设置为假，直到下一次玩家点击跳跃按钮。以下代码中的最后一个`else`子句在`isJumping`为假时执行，并将玩家的`y`速度设置为`gravity`。注意，还有一行代码将`isFalling`设置为`true`。正如我们将要看到的，这个变量用于控制玩家初次尝试跳跃时以及我们碰撞检测代码部分会发生什么。它基本上阻止了玩家在空中跳跃。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Immediately after we handle jumping, we call `move()` to update the *x* and
    *y* coordinates, if they have changed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完跳跃之后，我们立即调用`move()`来更新*x*和*y*坐标，如果它们有变化的话。
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That was a bit of a mouthful, but apart from the actual controls, it is just
    about everything we need to allow the player to move. We just need to call the
    `update`() method from our `PlatformView` class's `update` method once each frame,
    and our player character will spring into action.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，但除了实际控制之外，它几乎包含了我们让玩家移动所需的一切。我们只需要从我们`PlatformView`类的`update`方法中每一帧调用一次`update()`方法，我们的玩家角色就会活跃起来。
- en: 'In the `update` method of the `PlatformView` class, add the following code
    as shown highlighted:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlatformView`类的`update`方法中，像这样添加以下高亮代码：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we can see what is going on. Let''s add some more text output to the
    `if(debugging)` block in the `draw` method of `PlatformView`. Add the new highlighted
    code as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到正在发生什么。在`PlatformView`类的`draw`方法的`if(debugging)`块中添加一些更多的文本输出。像这里显示的那样添加新的高亮代码：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why not run the game now? You have probably noticed the next issue is that the
    player is gone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为何不运行游戏呢？你可能已经注意到下一个问题是玩家不见了。
- en: '![Introducing Bob](img/B04322_06_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![介绍鲍勃](img/B04322_06_01.jpg)'
- en: This is because we now have gravity, and also the thread that calls `update()`
    runs immediately as the application starts, even before our level and the player
    character is finished being set up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在有了重力，而且调用`update()`的线程在应用程序启动时立即运行，甚至在我们完成关卡和玩家角色的设置之前。
- en: We need to do two things. First, we only want `update()` to run when the `LevelManager`
    class has finished its work. Secondly, we need to update the focus of the `Viewport`
    class in every frame so that even if the player is falling to his death (as he
    will frequently) the screen will be centered on him, so we can watch his demise.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做两件事。首先，我们只想在`LevelManager`类完成工作后运行`update()`。其次，我们需要在每一帧更新`Viewport`类的焦点，这样即使玩家正在掉入死亡（他经常这样做），屏幕也会以他为中心，这样我们就可以看到他的终结。
- en: 'Let''s start the game on paused mode so that the player isn''t missing. First,
    we will add a method to our `LevelManager` class that will switch the playing
    status between playing and not playing. A good name may be `switchPlayingStatus()`.
    Add the new method to `LevelManager` as shown follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从暂停模式开始游戏，这样玩家就不会错过。首先，我们将在`LevelManager`类中添加一个方法，该方法将切换游戏状态在玩与不玩之间。一个合适的名字可能是`switchPlayingStatus()`。按照如下所示，将新方法添加到`LevelManager`中：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, just delete or comment out the line of code in the `LevelManager` constructor
    that sets `playing` to `true`. Soon, this will be handled by screen touches and
    the method we just wrote:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，删除或注释掉`LevelManager`构造函数中设置`playing`为`true`的那行代码。很快，这将会通过屏幕触摸和我们刚刚编写的方法来处理：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will write a tiny bit of temporary code, just a tiny bit. We already know
    that we will eventually be delegating responsibility to monitor player input to
    our new `InputController` class. This little bit of code in the overridden `onTouchEvent`
    method is well worth the effort because we will be able to use a pause feature
    right now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一点临时代码，只是一点点。我们已经知道，我们最终会将监控玩家输入的责任委托给我们的新`InputController`类。在重写的`onTouchEvent`方法中，这点代码是值得的，因为我们可以立即使用暂停功能。
- en: This code will toggle the playing status using the method we just wrote each
    time we touch the screen. Add the overridden method to the `PlatformView` class.
    We will eventually replace some of this code later in the chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在每次触摸屏幕时使用我们刚刚编写的方法切换游戏状态。将重写的方法添加到`PlatformView`类中。我们将在本章稍后替换其中一些代码。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can set `isPressingRight` in the `Player` class to true, following which
    you can run the game and tap the screen. We will then see the player fall like
    a ghost off the bottom, while moving to the right of the screen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Player`类中将`isPressingRight`设置为`true`，然后运行游戏并点击屏幕。然后我们会看到玩家像幽灵一样从底部掉落，同时向屏幕右侧移动：
- en: '![Introducing Bob](img/B04322_06_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![介绍鲍勃](img/B04322_06_02.jpg)'
- en: 'Now, let''s update the viewport per frame to remain centered on the player.
    Add this highlighted code to the very end of the `update` method in the `PlatformView`
    class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们每帧更新视口，使其保持在玩家中心。将这段高亮代码添加到`PlatformView`类中的`update`方法的最后：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you run the game now, although the player still falls to his doom and to
    the right, at least the screen stays focused on him to watch it happen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，尽管玩家仍然向右掉入厄运，但至少屏幕会聚焦在他身上，让我们看到这一过程。
- en: We will deal with the perpetual falling problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理持续下落的问题。
- en: Multiphase collision detection
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段碰撞检测
- en: We have seen that our player character simply falls though the world and into
    oblivion. Of course we need the player to be able to stand on the platforms. Here
    is what we will do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们的玩家角色会简单地穿过世界，落入虚无。当然，我们需要玩家能够站在平台上。以下是我们要采取的措施。
- en: We will provide every object that matters with a hitbox as we can then provide
    methods in the `Player` class to test if a hitbox has made contact with the player.
    Once per frame, we will send all hitboxes that have not been clipped by the viewport
    to this new method where a collision can be tested for.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个重要的对象提供一个碰撞箱，这样我们就可以在`Player`类中提供测试碰撞箱是否与玩家接触的方法。每帧一次，我们将发送所有未被视口剪辑的碰撞箱到这个新方法，在这里可以测试是否发生碰撞。
- en: We do it like this for two main reasons. Firstly, by sending only unclipped
    hitboxes for collision testing, we drastically reduce the number of checks, as
    described in [Chapter 3](ch03.html "Chapter 3. Tappy Defender – Taking Flight"),
    *Tappy Defender – Taking Flight*, in the section *Things that go bump – collision
    detection*. Secondly, by handling the checks within the `Player` class, we can
    give the player multiple different hitboxes and respond slightly differently according
    to which one is hit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做有两个主要原因。首先，通过仅发送未剪辑的碰撞箱进行碰撞测试，我们大大减少了检查的数量，如[第3章](ch03.html "第3章. Tappy
    Defender – Taking Flight")，*Tappy Defender – Taking Flight*中的“碰撞检测”部分所述。其次，通过在`Player`类中处理检查，我们可以给玩家多个不同的碰撞箱，并根据哪个被击中稍微有不同的反应。
- en: Let's create our own class for a hitbox, so we can make it just how we want
    it. It needs to use float coordinates, it needs an `intersects` method and a bunch
    of getters and setters as well. Create a new class and call it `RectHitbox`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自己的碰撞箱类，这样我们可以按照自己的需求来定义它。它需要使用浮点坐标，还需要一个`intersects`方法和一些获取器和设置器。创建一个新类，将其命名为`RectHitbox`。
- en: 'Here, we see that `RectHitbox` simply has a bunch of self explanatory getters
    and setters. It also has the `intersects` method, which returns `true` if the
    `RectHitbox` passed into it intersects with itself. For an explanation of how
    the `intersects()` code works, see [Chapter 3](ch03.html "Chapter 3. Tappy Defender
    – Taking Flight"), *Tappy Defender – Taking Flight*. Enter the following code
    into the new class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`RectHitbox`仅有一系列的自我解释的获取器和设置器。它还具有`intersects`方法，如果传递给它的`RectHitbox`与自身相交，则返回`true`。关于`intersects()`代码如何工作的解释，请参见[第3章](ch03.html
    "第3章. Tappy Defender – Taking Flight")，*Tappy Defender – Taking Flight*。在新的类中输入以下代码：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we can add a `RectHitbox` class as a member of `GameObject`. Add it right
    after the class declaration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`RectHitbox`类作为`GameObject`的一个成员添加。在类声明后直接添加它。
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we add a method to initialize the hitbox and a method so that we can
    grab a copy of it when needed. Add these two methods to `GameObject`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个方法来初始化碰撞箱，以及一个方法，以便在我们需要时获取它的副本。将这些两个方法添加到`GameObject`中：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now for our `Grass` object, we add a call to `setRectHitbox()` and then we can
    start bumping into it. Add this one line of highlighted code at the very end of
    the `Grass` class's constructor. It is important that the call to `setRectHitbox()`
    comes after the call to `setWorldLocation()` otherwise the hitbox won't be wrapped
    around the block of grass.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的`Grass`对象，我们添加一个对`setRectHitbox()`的调用，然后我们就可以开始与之碰撞了。在`Grass`类的构造函数的最后，添加这一行高亮代码。调用`setRectHitbox()`需要在`setWorldLocation()`之后进行，否则碰撞箱将不会围绕草地块。
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we can begin to comprehend the code that will do the collision checking,
    we need the `Player` class to have its own set of hitboxes. We need to know the
    following things about the player character:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始理解进行碰撞检测的代码之前，需要让`Player`类拥有自己的碰撞箱集合。我们需要了解以下关于玩家角色的信息：
- en: When the head bumps something above it
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当头部撞到它上方的物体时
- en: When the feet land on a platform below
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当脚部落在下方的平台上时
- en: When the player walks into something either side of it
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家从两侧走进某物时
- en: To achieve this, we will create four hitboxes; one for the head, one for the
    feet, and one for each of the left and right-hand sides. As they are unique to
    the player, we will create the hitboxes within the `Player` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建四个碰撞箱；一个用于头部，一个用于脚部，还有两个用于左右两侧。由于它们是玩家独有的，我们将在`Player`类中创建碰撞箱。
- en: 'Declare the four hitboxes as members just after the `Player` class declaration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`类声明后立即声明四个碰撞箱作为成员：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now in the constructor, we call new `RectHitbox()` to prepare them. Note that
    we haven''t bothered assigning any values to the hitboxes. We will see how we
    do that soon. Add the four calls to `new()` at the end of the `Player` constructor
    like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们调用新的`RectHitbox()`来准备它们。注意我们还没有给碰撞箱赋值。我们很快就会看到如何操作。在`Player`构造函数的最后，像这样添加四个对`new()`的调用：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will see were we will initialize them properly. The hitbox values in the
    code that follows, have been manually estimated based on the space taken up by
    the actual shape of the character within the rectangle that represents each frame
    of the character. If you use a different character graphic, you will likely need
    to adjust the precise values you use.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何正确初始化它们。下面代码中的碰撞箱值是基于实际角色形状在表示每个角色帧的矩形中所占空间手动估算的。如果你使用不同的角色图形，你可能需要调整你使用的精确值。
- en: The diagram shows an approximate graphical representation of the locations that
    each hitbox will be positioned at. The apparent lack of closeness for the left
    and right hitboxes is because different frames of the animation are slightly wider
    than this one. This is a compromise.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了每个碰撞箱将定位的大致图形表示位置。左侧和右侧碰撞箱看起来距离较远，是因为动画的不同帧比这一帧稍微宽一些。这是一个折中方案。
- en: '![Multiphase collision detection](img/B04322_06_03_new.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![多阶段碰撞检测](img/B04322_06_03_new.jpg)'
- en: The code must be placed after the call to `move()` within the `update` method
    in the `Player` class. This way, the hitboxes are updated each and every time
    the player position has changed. Add the highlighted code in exactly the position
    shown, and then we are one step closer to being able to start bumping in to stuff.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须在`Player`类中的`update`方法内调用`move()`之后的位置。这样，每次玩家位置改变时都会更新碰撞箱。在显示的确切位置添加高亮代码，这样我们就更接近能够开始碰撞到各种东西了。
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next stage, we can detect some collisions and react to them. Collisions
    which only concern the player, such as falling, bumping his head, or trying to
    walk through a wall are handled directly in this next method, within the `Player`
    class. Note that the method also returns an `int` value to represent if there
    was a collision and where on the player that collision occurred so that other
    collisions with things like pickups or pits of fire can be handled outside the
    class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一阶段，我们可以检测到一些碰撞并对它们做出反应。仅涉及玩家的碰撞，比如跌落、撞头或者试图穿墙，都将在下一个方法中直接处理，该方法位于`Player`类中。请注意，该方法还返回一个`int`值来表示是否发生碰撞以及碰撞发生在玩家的哪个部位，以便处理与其他物体（如拾取物或火坑）的碰撞。
- en: The new `checkCollisions` method receives a `RectHitbox` as a parameter. This
    will be the `RectHitbox` of whichever object we are currently checking against
    for collisions. Add the `checkCollisions` method to the `Player` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`checkCollisions`方法接收一个`RectHitbox`作为参数。这将是我们当前正在检查碰撞的任何对象的`RectHitbox`。将`checkCollisions`方法添加到`Player`类中。
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As the previous code implies, we need to add some setter methods to the `GameObject`
    class so that the *x* and *y* world coordinates can be changed when a collision
    is detected. Add the following two methods to the `GameObject` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们需要向`GameObject`类中添加一些setter方法，以便在检测到碰撞时可以更改*x*和*y*世界坐标。向`GameObject`类添加以下两个方法：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final step is to select all relevant objects and test for collisions. We
    do this in the `update` method of the `PlatformView` class, following which we
    switch to take further actions based on which body part collides with what object
    type. Our switch block will only have a default case to begin with, since we have
    only one possible object type to collide with a grass platform. Note that when
    a collision with the feet is detected, we set our `isFalling` variable to `false`,
    enabling the player to jump. Enter the highlighted code where shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是选择所有相关对象并进行碰撞测试。我们在`PlatformView`类的`update`方法中进行这项操作，然后根据哪个身体部位与哪种对象类型发生碰撞来进一步采取行动。由于我们只有一个可能与草地平台发生碰撞的对象类型，因此我们的switch块最初只会有一个默认情况。请注意，当检测到脚部发生碰撞时，我们将`isFalling`变量设置为`false`，使玩家能够跳跃。在显示的位置输入高亮代码：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We will make more use of the value that gets stored in `hit` for further collision-based
    decision making, as we progress with this project.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个项目的进行，我们将更多地利用在`hit`中存储的值进行基于碰撞的决策。
- en: Let's take control of the player for real.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们真正地控制玩家。
- en: Player input
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家输入
- en: First, let's add some methods in the `Player` class that our input controller
    will be able to call, then manipulate the variables that the `Player` class's
    `update` method uses to move around.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Player`类中添加一些方法，我们的输入控制器将能够调用这些方法，然后操作`Player`类的`update`方法用来移动的变量。
- en: We already played with the `isPressingRight` variable, and also have an `isPressingLeft`
    variable. Furthermore, we want to be able to jump. If you take a look at the `Player`
    class's `update` method, we already have the code to handle these situations.
    We just need the player to be able to initiate the movements via touches to the
    screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经玩过了`isPressingRight`变量，也有一个`isPressingLeft`变量。此外，我们希望能够跳跃。如果你查看`Player`类的`update`方法，我们已经有处理这些情况的代码了。我们只需要玩家能够通过触摸屏幕来启动这些动作。
- en: Our previous button layout design and the code we have written so far, suggests
    a method for going left, a method for going right, and a method for jumping.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的按钮布局设计和到目前为止编写的代码，暗示了一种向左走的方法，一种向右走的方法，以及一种跳跃的方法。
- en: 'You will also note that we pass a copy of `SoundManager` into the `startJump`
    method, which allows us to play a neat retro jumping sound, if the jump attempt
    is successful. Add these three new methods to the `Player` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，我们将`SoundManager`的副本传递给`startJump`方法，这使得如果跳跃尝试成功，我们可以播放一个整洁的复古跳跃声音。
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can focus on the `InputController` class. Let''s pass control from
    the `onTouchEvent` method to our `InputController` class. Change the code in the
    `onTouchEvent` method to the following in the `PlatformView` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于`InputController`类。让我们从`onTouchEvent`方法中将控制权传递给我们的`InputController`类。在`PlatformView`类中更改`onTouchEvent`方法的代码如下：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have an error in our new method. This is simply because we have called the
    `handleInput` method but not implemented it yet. We will do that now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新方法中有一个错误。这仅仅是因为我们调用了`handleInput`方法，但还没有实现它。我们现在就来做这件事。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering about the check for whether `lm != null`, that is because
    the `onTouchEvent` method is triggered from the Android UI thread and is not within
    our control. If we pass in `lm` and start trying to do things with it, when it
    is not initialized, the game will crash.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇为什么需要检查`lm != null`，这是因为`onTouchEvent`方法是从Android UI线程触发的，不在我们的控制范围内。如果我们传入`lm`并尝试用它做事情，而它尚未初始化，游戏将会崩溃。
- en: We can now get everything that we need done within the `InputController` class.
    Open that class now, and we will plan what we are going to do.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`InputController`类中完成我们需要做的一切。现在打开这个类，我们将计划我们要做什么。
- en: We need a button to go left, a button to go right, a button to jump, a button
    to toggle pause, and later we will also need a button to fire a machine gun. Therefore,
    we really need to highlight different areas of the screen to represent each of
    these tasks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个向左的按钮，一个向右的按钮，一个跳跃按钮，一个切换暂停的按钮，稍后我们还需要一个发射机枪的按钮。因此，我们确实需要突出屏幕的不同区域来代表这些任务。
- en: To do this, we will declare four `Rect` objects, one for each task. Then in
    the constructor, we will define the points of these four `Rect` objects by carrying
    out some simple calculations based on the players screen resolution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将声明四个`Rect`对象，每个任务一个。然后在构造函数中，我们将通过基于玩家屏幕分辨率进行一些简单的计算来定义这四个`Rect`对象的点。
- en: 'We define some handy variables, `buttonWidth`, `buttonHeight`, and `buttonPadding`,
    based on the device''s screen resolution to help us arrange our `Rect` coordinates
    neatly. Enter the following members and the `InputController` constructor as shown
    next:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据设备屏幕分辨率定义了一些方便的变量，`buttonWidth`、`buttonHeight`和`buttonPadding`，以帮助我们整齐地排列`Rect`坐标。输入以下成员和`InputController`构造函数，如下所示：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will use the four `Rect` objects to draw buttons on the screen. The `draw`
    method is going to need a copy of them. Enter the code for the `getButtons` method
    to achieve this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这四个`Rect`对象在屏幕上绘制按钮。`draw`方法将需要它们的副本。输入`getButtons`方法的代码以实现这一点：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can now handle the actual player input. This project is different to the
    previous one because there are lots of different possible player actions that
    need to be monitored and responded to, sometimes simultaneously. As you expect,
    the Android API has the functionality to make this as easy as possible for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理实际的玩家输入。这个项目与上一个项目不同，因为有大量不同的玩家动作需要监控和响应，有时是同时进行的。正如你所期望的，Android API具有使这尽可能简单的功能。
- en: The `MotionEvent` class has a lot more data tucked away in it than we have seen
    so far. Previously, we simply checked for the `ACTION_DOWN` and `ACTION_UP` events.
    Now, we need to dig a little deeper to grab more of the event data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionEvent`类中隐藏的数据比我们目前看到的要多。之前，我们只是检查了`ACTION_DOWN`和`ACTION_UP`事件。现在，我们需要更深入地挖掘以获取更多的事件数据。'
- en: In order to record and pass on the details of multiple fingers, touching, leaving,
    and moving on the screen, the `MotionEvent` class stores them all in an array.
    When the first finger of the player touches the screen, the details, coordinates,
    and so on, are stored at position zero. Subsequent actions are then stored later
    in the array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录和传递多个手指在屏幕上触摸、离开和移动的详细信息，`MotionEvent` 类将它们都存储在一个数组中。当玩家的第一个手指触摸屏幕时，详细信息、坐标等存储在位置零。后续动作随后存储在数组的后面。
- en: The position in the array related to any such finger's activity is not consistent.
    In some situations, such as detecting specific gestures, this can be a problem
    and the programmer needs to capture, remember, and respond to the ID of a finger,
    also held in the `MotionEvent` class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何手指活动相关的数组中的位置并不一致。在某些情况下，例如检测特定的手势时，这可能是个问题，程序员需要捕获、记住并响应对应于 `MotionEvent`
    类中保存的手指ID。
- en: Fortunately in this situation, we have our clearly defined areas of the screen
    that represent our buttons, and the most we will ever need to know is if the finger
    has pressed or released the screen within one of these predefined areas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这种情况下，我们有明确定义的屏幕区域来表示我们的按钮，我们最多需要知道的是，玩家的手指是否在这些预定义的区域内按下或释放了屏幕。
- en: We just need to find out how many fingers have caused events and are therefore
    stored in the array by calling `motionEvent.getPointerCount()`. We then loop through
    each of these events while providing a `switch` block to handle them, whatever
    area of the screen, where `ACTION_DOWN` or `ACTION_UP` has occurred. It won't
    matter which position in the array our event is stored at, as long as we detect
    it and respond to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需通过调用 `motionEvent.getPointerCount()` 来找出导致事件的手指数量，进而得知它们存储在数组中的情况。然后，我们遍历这些事件，并提供一个
    `switch` 代码块来处理它们，无论在屏幕的哪个区域发生了 `ACTION_DOWN` 或 `ACTION_UP`。只要我们能够检测到事件并对其作出响应，事件存储在数组的哪个位置都无关紧要。
- en: The only other thing we need to know, before we can code our solution, is that
    the subsequent actions in the array are stored as `ACTION_POINTER_DOWN` and `ACTION_POINTER_UP`;
    therefore, with each pass through the loop, that we will shortly code, we need
    to check and handle both `ACTION_DOWN` and `ACTION_POINTER_DOWN`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写解决方案的代码之前，还需要了解的另外一点是，数组中后续的动作被存储为 `ACTION_POINTER_DOWN` 和 `ACTION_POINTER_UP`；因此，在即将编写的循环中，每次通过时，我们都需要检查并处理
    `ACTION_DOWN` 和 `ACTION_POINTER_DOWN`。
- en: 'After all this talk, here is our `handleInput` method that gets called every
    time the screen is touched or released:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些讨论之后，以下是每次屏幕被触摸或释放时调用的 `handleInput` 方法：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering why we bothered to set up two sets of control code, one
    for playing and one for not playing, it is because in [Chapter 8](ch08.html "Chapter 8. Platformer
    – Putting It All Together"), *Putting It All Together*, we will add a cool new
    feature for the game while it is paused. Of course, the `togglePlayingStatus`
    method did not need to be done like this, and it would have worked fine without
    the test for the status of playing. It just saves us making minor intricate amendments
    to our code later on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇为什么我们要设置两组控制代码，一组用于播放，一组用于不播放，那是因为在[第8章](ch08.html "第8章. 平台游戏 - 组合在一起")《组合在一起》中，我们将为游戏暂停时添加一个很酷的新功能。当然，`togglePlayingStatus`
    方法不必这样做，即使没有播放状态的检测也能正常工作。这只是为我们稍后对代码进行微小的精细修改节省时间。
- en: 'Now all we need to do is open up the `PlatformView` class, grab a copy of the
    array with all the control buttons in, and draw them to the screen. We use the
    `drawRoundRect` method to draw neat curved-corner rectangles to represent the
    areas of the screen that will respond to the player''s touches. Enter this code
    in the `draw` method right before the call to `unlockCanvasAndPost()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的就是打开 `PlatformView` 类，获取包含所有控制按钮的数组副本，并将它们绘制到屏幕上。我们使用 `drawRoundRect`
    方法绘制整洁的圆角矩形，以表示屏幕上将对玩家的触摸作出响应的区域。在 `draw` 方法的 `unlockCanvasAndPost()` 调用之前输入以下代码：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Also, right before we call `unlockCanvasAndPost()`, let's draw a simple pause
    screen so that we know when the game is paused or playing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在我们调用 `unlockCanvasAndPost()` 之前，让我们绘制一个简单的暂停屏幕，这样我们就可以知道游戏是暂停还是正在播放。
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can now jump and walk all over the place and a nice retro jumping sound
    plays as well. Why not add some more grass to the scene by editing `LevelCave`
    and replacing a few period characters (`.`) with a few more `1` characters. The
    next screenshot shows that the player has been jumping around a bit as well as
    the buttons used for controls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以到处跳跃和行走，同时还会播放一段不错的复古跳跃音效。为何不通过编辑`LevelCave`并向场景中添加更多草地，用一些`1`字符替换几个句点（`.`）字符呢？下一张截图显示了玩家已经跳跃了一段时间，以及用于控制的按钮：
- en: '![Player input](img/B04322_06_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![玩家输入](img/B04322_06_04.jpg)'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will design some real-playable levels, as well as link them together in [Chapter
    8](ch08.html "Chapter 8. Platformer – Putting It All Together"), *Putting It All
    Together*. For now, just do whatever seems like fun with `LevelCave`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一些真正可玩的游戏关卡，并在[第8章](ch08.html "第8章. 平台游戏 - 将其全部组合在一起")，*将其全部组合在一起*中链接它们。现在，只需用`LevelCave`做任何看起来有趣的事情。
- en: Now, we can get rid of that ugly squashed player graphic and make a neat little
    animation out of it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以摆脱那个难看的压缩玩家图像，并使其成为一个整洁的小动画。
- en: Animating Bob
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画鲍勃
- en: Sprite sheet animations work by quickly changing the image drawn to the screen.
    Exactly like a child may draw the phases of a stick-man moving on the corner of
    a book, and then quickly flicking through it to make it appear to move.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵表动画通过快速更改屏幕上绘制的图像来工作。这就像一个孩子在书本的角落里画出火柴人的动作阶段，然后快速翻动书本，使其看起来像是在移动。
- en: The frames of Bob's animation are already contained within the `player.png`
    file we have been using to represent him.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃的动画帧已经包含在我们一直用来表示他的`player.png`文件中。
- en: '![Animating Bob](img/B04322_06_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![动画的鲍勃](img/B04322_06_05.jpg)'
- en: All we need to do is loop through them one at a time when the player is moving.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是在玩家移动时逐个遍历这些帧。
- en: This is quite straightforward to implement. We will make a simple animation
    class that handles the function of keeping time and returning the appropriate
    part of the sprite sheet when requested. We can then initialize a new animation
    object for any `GameObject` that needs to be animated. In addition, when they
    are being drawn in the `draw` method of `PlatformView`, if the object is animated,
    we will handle it slightly differently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点非常直接。我们将制作一个简单的动画类，处理保持时间和在请求时返回精灵表适当部分的功能。然后，我们可以为任何需要动画的`GameObject`初始化一个新的动画对象。此外，当它们在`PlatformView`的`draw`方法中被绘制时，如果对象是动画的，我们将稍微不同地处理它。
- en: In this section, we will also see how to use the facing variable that tracks
    which way the player is facing. It will enable us to reverse the sprite sheet
    depending on the way the player (or any future animated objects) is headed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将了解如何使用面对变量来跟踪玩家面向的方向。它将使我们能够根据玩家（或任何未来的动画对象）前进的方向来反转精灵表。
- en: Let's start by making the animation class. Create a new Java class and call
    it `Animation`. The code that follows soon will declare variables that hold the
    bitmap to be manipulated, the name of the bitmap, and a `rect` parameter to define
    the area of the sprite sheet that is the coordinates of the currently relevant
    frame of animation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个动画类。创建一个新的Java类，将其命名为`Animation`。接下来的代码将声明用于操作位图的变量、位图名称以及一个`rect`参数，以定义精灵表当前相关动画帧的区域坐标。
- en: In addition, we have `frameCount`, `currentFrame`, `frameTicker`, and `framePeriod`
    that hold and control the number of available frames, the current frame number,
    and the timing of the change of the frames. As you would expect, we also need
    to know the width and height of a frame of animation, these are held by `frameWidth`
    and `frameHeight`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`frameCount`、`currentFrame`、`frameTicker`和`framePeriod`，它们分别保存和控制可用的帧数、当前帧编号以及帧变化的时间。如您所料，我们还需要知道动画帧的宽度和高度，这些由`frameWidth`和`frameHeight`保存。
- en: Furthermore, the `Animation` class will regularly refer to the number of pixels
    per meter; therefore, it makes sense to hold this value in a member variable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Animation`类将经常引用每米的像素数；因此，将这个值保存在成员变量中是有意义的。
- en: 'Enter these member variables that we discussed in the `Animation` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来输入在`Animation`类中讨论过的成员变量：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we have the constructor that prepares our animation object for use. We
    will see exactly how we prepare for the actual animation soon. Note that there
    are a fair few parameters in the signature indicating that the animation is quite
    configurable. Just note that FPS in this context is not referring to the frame
    rate of the game but the frame rate of the animation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数，它为我们的动画对象做好准备。我们很快就会看到如何为实际动画做准备。注意，签名中有相当多的参数，表明动画是相当可配置的。只需注意，这里的FPS不是指游戏的帧率，而是指动画的帧率。
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can deal with the real functionality of the class. The `getCurrentFrame`
    method first checks to see if the object is moving or if it is capable of moving.
    At this stage, this may seem a little odd as this method will only ever be called
    by a `GameObject` class that is animated. The odd looking check, therefore, is
    determining if a new frame is required at the moment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理类的实际功能。`getCurrentFrame`方法首先检查对象是否在移动或是否能够移动。在这个阶段，这可能看起来有点奇怪，因为该方法只会被一个已动画化的`GameObject`类调用。因此，这个奇怪的检查是确定此刻是否需要一个新帧。
- en: If an object moves, (such as Bob), but is standing still, then we don't need
    to change the frame of animation. However, if the animated object has no velocity
    ever, like a roaring fire, then we need to animate it all the time. It will never
    have any velocity so the `moves` variable will be `false`, but the method will
    proceed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象移动（比如Bob），但处于静止状态，那么我们不需要改变动画的帧。然而，如果一个动画对象从不具有速度，比如熊熊燃烧的火焰，那么我们需要一直动画它。它永远不会有任何速度，所以`moves`变量将是`false`，但方法将继续执行。
- en: The method then uses `time`, `frameTicker` and `framePeriod`, to determine if
    it is time to show the next frame of animation and if it increments the frame
    number to display. Then, if the animation is on the last frame, it goes back to
    the first frame.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法然后使用`time`、`frameTicker`和`framePeriod`来确定是否到了显示动画下一帧的时间，并递增要显示的帧号。然后，如果动画在最后一帧，它会回到第一帧。
- en: Finally, the precise left and right-hand positions that represent the portion
    of the sprite sheet that contains the needed frame, are calculated and returned
    to the calling code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，计算代表精灵表中包含所需帧的精确左右位置，并将这些位置返回给调用代码。
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we can add some members to the `GameObject` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向`GameObject`类添加一些成员。
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Some methods to interact with our `Animation` class, which set and get variables,
    make the animation work and inform the `draw` method if the object is animated
    or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与我们的`Animation`类交互的方法，设置和获取变量，使动画工作，并通知`draw`方法对象是否已动画化。
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Lastly in `GameObject`, there is a method which the objects that require animating
    can use to set up their whole animation object. Note it is this `setAnimated`
    method that calls `new()` on a new animation object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`GameObject`中，有一个方法，需要动画的对象可以使用它来设置它们的整个动画对象。注意，是`setAnimated`方法在一个新的动画对象上调用`new()`。
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next method acts as a go between for the `draw` method of the `PlatformView`
    class and the `getRectToDraw` method of the `Animation` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法作为`PlatformView`类的`draw`方法和`Animation`类的`getRectToDraw`方法之间的中介。
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we need to update the `Player` class in order to initialize its animation
    object according to its own specific required number of frames and frames per
    second. The new code in the `Player` class is highlighted:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新`Player`类，以便根据其特定的帧数和每秒帧数初始化其动画对象。`Player`类中的新代码如下所示：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can use all this new code from the `draw` method to implement our animations.
    The next block of code checks if the current `GameObject` being drawn `isAnimated()`.
    If it is, it gets the appropriate rectangle from the sprite sheet using the `getNextRect()`
    method via the `GameObject` class's `getRectToDraw` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`draw`方法中的所有新代码来实现我们的动画。下一块代码检查当前正在绘制的`GameObject`是否`isAnimated()`。如果是，它通过`GameObject`类的`getRectToDraw`方法使用`getNextRect()`方法从精灵表中获取适当的矩形。
- en: Note that, the next code listing from the `draw` method that made the original
    call to `drawBitmap()`, is now wrapped in an `else` clause at the end of the new
    code. Basically, the logic is this. If animated, execute the new code, otherwise
    just do it the usual way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从原始的`draw`方法中调用`drawBitmap()`的下一行代码，现在被包裹在新代码末尾的一个`else`子句中。基本上，逻辑是这样的：如果需要动画，执行新代码，否则按常规方式处理。
- en: In addition to the animation code we know about, we also check `if(go.getFacing()
    == 1)` and use the `Matrix` class to flip the bitmap when required by scaling
    it by -1 on the *x* axis.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已知的动画代码外，我们还检查 `if(go.getFacing() == 1)` 并使用 `Matrix` 类在必要时通过 *x* 轴缩放 -1
    来翻转位图。
- en: 'Here is all the new code, including the original `drawBitmap()` call wrapped
    in an `else` clause at the end:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有新代码，包括原始的 `drawBitmap()` 调用，在最后的 `else` 子句中进行了包装：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, you can run the game and see Bob in all his animated glory. The screenshot
    can''t show his movements, but you can see he is now perfectly formed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行游戏，并看到Bob的所有动画效果。截图无法展示他的动作，但您可以看到他现在形态完美：
- en: '![Animating Bob](img/B04322_06_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![动画Bob](img/B04322_06_06.jpg)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our game is steadily coming together. At this stage, we can build a huge level
    design in `LevelCave` and go running and jumping all over the place. However,
    we will save to postpone trying to make the game playable until we have added
    a load more neat features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏正在稳步成型。在这个阶段，我们可以在 `LevelCave` 中构建一个巨大的关卡设计，并在各处奔跑跳跃。然而，我们会推迟尝试使游戏可玩，直到我们添加了更多整洁的特性为止。
- en: These neat features will include a machine gun, which can be upgraded through
    collectible pickups and some enemies that Bob can shoot at. We will get going
    with that in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些整洁的特性将包括一挺机关枪，这挺枪可以通过收集升级物品和Bob可以射击的一些敌人来进行升级。我们将在下一章开始介绍这些内容。
