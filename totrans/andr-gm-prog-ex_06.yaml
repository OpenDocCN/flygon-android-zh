- en: Chapter 6. Platformer – Bob, Beeps, and Bumps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our basic game engine is set up, we can start making some fast progress.
    In this chapter, we will quickly add a `SoundManager` class that we will use to
    make a noise wherever and whenever we please. After that, we will put some meat
    on the bones of Bob and implement the core functionality we require in the `Player`
    class. Then, we can handle the second phase (after clipping) of our multiphase
    collision detection and give Bob the useful skill of being able to stand on a
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: After we have achieved this significant feat, we will hand over control of Bob
    to the player by implementing the `InputController` class. Bob will at last be
    able to run around and jump. At the end of this chapter, we will animate Bob's
    sprite sheet so he actually appears to run, rather than slide everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The SoundManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the next few chapters, we will be adding sound effects for various
    events. Sometimes these sounds will be triggered directly in the main `PlatformView`
    class, but other times, they will need to be triggered in more remote corners
    of your code like the `InputController` class and even within the `GameObject`
    class themselves. We will quickly make a simple `SoundManager` class that can
    be passed around and used as needed when a beep is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class and call it `SoundManager`. This class has three main
    parts. In the first part, we simply declare a `SoundPool` object and a bunch of
    `int` variables to hold a reference to each sound effect. Enter the first part
    of the code, the declaration, and members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the class is the `loadSound` method, which unsurprisingly
    loads all the sounds into memory ready for playing. We will call this once we
    have initialized a `SoundManager` object in the `PlatformView` constructor. Enter
    this code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally for our `SoundManager` class, we need to be able to play any sound
    we like. This `playSound` method simply switches on a string passed in as a parameter.
    When we have a `SoundManager` object, we can just call `playSound()` with an appropriate
    string argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Declare a new object of type `SoundManager` after the `PlatformView` class declaration
    after your new game engine classes from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize the `SoundManager` object and call `loadSound()` in the `PlatformView`
    constructor as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can create all your own sounds using BFXR or just copy mine from the `Chapter6/assets`
    folder. Copy all the sounds to the `assets` folder in your Android Studio project.
    Create an `assets` folder in the `src/main` folder of your project in order to
    achieve this if the folder doesn't exist already.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can play sound effects wherever we like. It's time to bring our hero
    Bob to life.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we can add the meat to the bones of your `Player` class. However, this
    section won't be the last time we revisit the `Player` class. Now, we will add
    the necessary functionality to allow Bob to move. Immediately after we have done
    this, we will add the code to allow the player to use the forthcoming collision
    detection code and the `Animation` class.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to add some members to the `Player` class. The `Player`
    class will need to know how fast it can move, when the player is pressing the
    left or right controls, and if it is falling or jumping. In addition, the `Player`
    class needs to know how long it has been jumping and how long it should jump for.
  prefs: []
  type: TYPE_NORMAL
- en: The next block of code provides variables for us to monitor all these things.
    We will very soon see, how we use them to make Bob do what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know what the variables are for. We can add this code right after the
    class declaration as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, there are some other movement-related conditions we will need
    to track, but they will be useful in other classes as well. Therefore, we will
    add them as members to the `GameObject` class. We will track the current horizontal
    and vertical speed, the direction the object is facing, and whether the object
    can move at all with the following variables. Add these to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `GameObject` class, we will add a `move` method. This method simply
    checks that the velocity on either of the axes is not zero and if it is, it moves
    the object by changing its `worldLocation` object. This method uses the velocity
    (either `xVelocity` or `yVelocity`) divided by the current frames per second to
    calculate the distance to move each frame. This ensures that the movement will
    be exactly correct, regardless of the current frames per second. It doesn't matter
    if our game executes smoothly or fluctuates a bit, or how powerful or puny the
    CPU in the Android device is. We will very soon call this `move` method from within
    the `update` method of the `Player` class. Later in the project, we will call
    it from other classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the `GameObject` class, we have a bunch of getters and setters for
    the new variables we added previously. The only part to note is that the setters
    for the two velocity variables (`setxVelocity` and `setyVelocity`) check `if(moves)`
    before actually assigning a value. Add these new getters and setters to the `GameObject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in the `Player` class constructor, we can use some of these new methods
    to set up the object at creation time. Add the highlighted code to the `Player`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can make practical use of all this new code in the `Player` class's
    `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we handle what happens when `isPressingRight` or `isPressingLeft` is
    true. Of course, we still need to be able to set these variables via touches on
    the screen. Very simply, this next code block sets the horizontal velocity to
    `MAX_X_VELOCITY` if `isPressingRight` is true or to `-MAX_X_VELOCITY` if `isPressingLeft`
    is true. If neither is true, it sets the horizontal velocity to zero, which is
    standing still.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we check which way the player is moving and call `setFacing()` with either
    `RIGHT` or `LEFT` as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can handle jumping. When the player presses the jump button, if successful,
    `isJumping` will be set to true and `jumpTime` will be set to whatever the current
    system time is. So we can then enter the `if(isJumping)` block on each frame,
    test how long Bob has been jumping for, and if he has not exceeded `maxJumpTime`
    take one of two possible actions.
  prefs: []
  type: TYPE_NORMAL
- en: Action one is; if we are less than half way through the jump, the *y* velocity
    is set to `-gravity` (going up). Action two is; if Bob is more than half way through
    the jump, his *y* velocity is set to `gravity` (going down).
  prefs: []
  type: TYPE_NORMAL
- en: When `maxJumpTime` is exceeded, `isJumping` is set back to false until the next
    time the player taps the jump button. The final `else` clause in the following
    code executes whenever `isJumping` is false and sets the player's `y` velocity
    to `gravity`. Note that the additional line of code that sets `isFalling` to `true`.
    As we will see, this variable is used to control what happens when the player
    initially tries to jump and also in parts of our collision detection code. It
    basically stops the player from being able to jump in mid air.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Immediately after we handle jumping, we call `move()` to update the *x* and
    *y* coordinates, if they have changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That was a bit of a mouthful, but apart from the actual controls, it is just
    about everything we need to allow the player to move. We just need to call the
    `update`() method from our `PlatformView` class's `update` method once each frame,
    and our player character will spring into action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method of the `PlatformView` class, add the following code
    as shown highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can see what is going on. Let''s add some more text output to the
    `if(debugging)` block in the `draw` method of `PlatformView`. Add the new highlighted
    code as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why not run the game now? You have probably noticed the next issue is that the
    player is gone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Bob](img/B04322_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because we now have gravity, and also the thread that calls `update()`
    runs immediately as the application starts, even before our level and the player
    character is finished being set up.
  prefs: []
  type: TYPE_NORMAL
- en: We need to do two things. First, we only want `update()` to run when the `LevelManager`
    class has finished its work. Secondly, we need to update the focus of the `Viewport`
    class in every frame so that even if the player is falling to his death (as he
    will frequently) the screen will be centered on him, so we can watch his demise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the game on paused mode so that the player isn''t missing. First,
    we will add a method to our `LevelManager` class that will switch the playing
    status between playing and not playing. A good name may be `switchPlayingStatus()`.
    Add the new method to `LevelManager` as shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just delete or comment out the line of code in the `LevelManager` constructor
    that sets `playing` to `true`. Soon, this will be handled by screen touches and
    the method we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will write a tiny bit of temporary code, just a tiny bit. We already know
    that we will eventually be delegating responsibility to monitor player input to
    our new `InputController` class. This little bit of code in the overridden `onTouchEvent`
    method is well worth the effort because we will be able to use a pause feature
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: This code will toggle the playing status using the method we just wrote each
    time we touch the screen. Add the overridden method to the `PlatformView` class.
    We will eventually replace some of this code later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set `isPressingRight` in the `Player` class to true, following which
    you can run the game and tap the screen. We will then see the player fall like
    a ghost off the bottom, while moving to the right of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Bob](img/B04322_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s update the viewport per frame to remain centered on the player.
    Add this highlighted code to the very end of the `update` method in the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, although the player still falls to his doom and to
    the right, at least the screen stays focused on him to watch it happen.
  prefs: []
  type: TYPE_NORMAL
- en: We will deal with the perpetual falling problem.
  prefs: []
  type: TYPE_NORMAL
- en: Multiphase collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that our player character simply falls though the world and into
    oblivion. Of course we need the player to be able to stand on the platforms. Here
    is what we will do.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide every object that matters with a hitbox as we can then provide
    methods in the `Player` class to test if a hitbox has made contact with the player.
    Once per frame, we will send all hitboxes that have not been clipped by the viewport
    to this new method where a collision can be tested for.
  prefs: []
  type: TYPE_NORMAL
- en: We do it like this for two main reasons. Firstly, by sending only unclipped
    hitboxes for collision testing, we drastically reduce the number of checks, as
    described in [Chapter 3](ch03.html "Chapter 3. Tappy Defender – Taking Flight"),
    *Tappy Defender – Taking Flight*, in the section *Things that go bump – collision
    detection*. Secondly, by handling the checks within the `Player` class, we can
    give the player multiple different hitboxes and respond slightly differently according
    to which one is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our own class for a hitbox, so we can make it just how we want
    it. It needs to use float coordinates, it needs an `intersects` method and a bunch
    of getters and setters as well. Create a new class and call it `RectHitbox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that `RectHitbox` simply has a bunch of self explanatory getters
    and setters. It also has the `intersects` method, which returns `true` if the
    `RectHitbox` passed into it intersects with itself. For an explanation of how
    the `intersects()` code works, see [Chapter 3](ch03.html "Chapter 3. Tappy Defender
    – Taking Flight"), *Tappy Defender – Taking Flight*. Enter the following code
    into the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add a `RectHitbox` class as a member of `GameObject`. Add it right
    after the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a method to initialize the hitbox and a method so that we can
    grab a copy of it when needed. Add these two methods to `GameObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now for our `Grass` object, we add a call to `setRectHitbox()` and then we can
    start bumping into it. Add this one line of highlighted code at the very end of
    the `Grass` class's constructor. It is important that the call to `setRectHitbox()`
    comes after the call to `setWorldLocation()` otherwise the hitbox won't be wrapped
    around the block of grass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can begin to comprehend the code that will do the collision checking,
    we need the `Player` class to have its own set of hitboxes. We need to know the
    following things about the player character:'
  prefs: []
  type: TYPE_NORMAL
- en: When the head bumps something above it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the feet land on a platform below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player walks into something either side of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this, we will create four hitboxes; one for the head, one for the
    feet, and one for each of the left and right-hand sides. As they are unique to
    the player, we will create the hitboxes within the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the four hitboxes as members just after the `Player` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the constructor, we call new `RectHitbox()` to prepare them. Note that
    we haven''t bothered assigning any values to the hitboxes. We will see how we
    do that soon. Add the four calls to `new()` at the end of the `Player` constructor
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will see were we will initialize them properly. The hitbox values in the
    code that follows, have been manually estimated based on the space taken up by
    the actual shape of the character within the rectangle that represents each frame
    of the character. If you use a different character graphic, you will likely need
    to adjust the precise values you use.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows an approximate graphical representation of the locations that
    each hitbox will be positioned at. The apparent lack of closeness for the left
    and right hitboxes is because different frames of the animation are slightly wider
    than this one. This is a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiphase collision detection](img/B04322_06_03_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code must be placed after the call to `move()` within the `update` method
    in the `Player` class. This way, the hitboxes are updated each and every time
    the player position has changed. Add the highlighted code in exactly the position
    shown, and then we are one step closer to being able to start bumping in to stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next stage, we can detect some collisions and react to them. Collisions
    which only concern the player, such as falling, bumping his head, or trying to
    walk through a wall are handled directly in this next method, within the `Player`
    class. Note that the method also returns an `int` value to represent if there
    was a collision and where on the player that collision occurred so that other
    collisions with things like pickups or pits of fire can be handled outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The new `checkCollisions` method receives a `RectHitbox` as a parameter. This
    will be the `RectHitbox` of whichever object we are currently checking against
    for collisions. Add the `checkCollisions` method to the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As the previous code implies, we need to add some setter methods to the `GameObject`
    class so that the *x* and *y* world coordinates can be changed when a collision
    is detected. Add the following two methods to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to select all relevant objects and test for collisions. We
    do this in the `update` method of the `PlatformView` class, following which we
    switch to take further actions based on which body part collides with what object
    type. Our switch block will only have a default case to begin with, since we have
    only one possible object type to collide with a grass platform. Note that when
    a collision with the feet is detected, we set our `isFalling` variable to `false`,
    enabling the player to jump. Enter the highlighted code where shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will make more use of the value that gets stored in `hit` for further collision-based
    decision making, as we progress with this project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take control of the player for real.
  prefs: []
  type: TYPE_NORMAL
- en: Player input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's add some methods in the `Player` class that our input controller
    will be able to call, then manipulate the variables that the `Player` class's
    `update` method uses to move around.
  prefs: []
  type: TYPE_NORMAL
- en: We already played with the `isPressingRight` variable, and also have an `isPressingLeft`
    variable. Furthermore, we want to be able to jump. If you take a look at the `Player`
    class's `update` method, we already have the code to handle these situations.
    We just need the player to be able to initiate the movements via touches to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous button layout design and the code we have written so far, suggests
    a method for going left, a method for going right, and a method for jumping.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also note that we pass a copy of `SoundManager` into the `startJump`
    method, which allows us to play a neat retro jumping sound, if the jump attempt
    is successful. Add these three new methods to the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can focus on the `InputController` class. Let''s pass control from
    the `onTouchEvent` method to our `InputController` class. Change the code in the
    `onTouchEvent` method to the following in the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have an error in our new method. This is simply because we have called the
    `handleInput` method but not implemented it yet. We will do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering about the check for whether `lm != null`, that is because
    the `onTouchEvent` method is triggered from the Android UI thread and is not within
    our control. If we pass in `lm` and start trying to do things with it, when it
    is not initialized, the game will crash.
  prefs: []
  type: TYPE_NORMAL
- en: We can now get everything that we need done within the `InputController` class.
    Open that class now, and we will plan what we are going to do.
  prefs: []
  type: TYPE_NORMAL
- en: We need a button to go left, a button to go right, a button to jump, a button
    to toggle pause, and later we will also need a button to fire a machine gun. Therefore,
    we really need to highlight different areas of the screen to represent each of
    these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will declare four `Rect` objects, one for each task. Then in
    the constructor, we will define the points of these four `Rect` objects by carrying
    out some simple calculations based on the players screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define some handy variables, `buttonWidth`, `buttonHeight`, and `buttonPadding`,
    based on the device''s screen resolution to help us arrange our `Rect` coordinates
    neatly. Enter the following members and the `InputController` constructor as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the four `Rect` objects to draw buttons on the screen. The `draw`
    method is going to need a copy of them. Enter the code for the `getButtons` method
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can now handle the actual player input. This project is different to the
    previous one because there are lots of different possible player actions that
    need to be monitored and responded to, sometimes simultaneously. As you expect,
    the Android API has the functionality to make this as easy as possible for us.
  prefs: []
  type: TYPE_NORMAL
- en: The `MotionEvent` class has a lot more data tucked away in it than we have seen
    so far. Previously, we simply checked for the `ACTION_DOWN` and `ACTION_UP` events.
    Now, we need to dig a little deeper to grab more of the event data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to record and pass on the details of multiple fingers, touching, leaving,
    and moving on the screen, the `MotionEvent` class stores them all in an array.
    When the first finger of the player touches the screen, the details, coordinates,
    and so on, are stored at position zero. Subsequent actions are then stored later
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: The position in the array related to any such finger's activity is not consistent.
    In some situations, such as detecting specific gestures, this can be a problem
    and the programmer needs to capture, remember, and respond to the ID of a finger,
    also held in the `MotionEvent` class.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately in this situation, we have our clearly defined areas of the screen
    that represent our buttons, and the most we will ever need to know is if the finger
    has pressed or released the screen within one of these predefined areas.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to find out how many fingers have caused events and are therefore
    stored in the array by calling `motionEvent.getPointerCount()`. We then loop through
    each of these events while providing a `switch` block to handle them, whatever
    area of the screen, where `ACTION_DOWN` or `ACTION_UP` has occurred. It won't
    matter which position in the array our event is stored at, as long as we detect
    it and respond to it.
  prefs: []
  type: TYPE_NORMAL
- en: The only other thing we need to know, before we can code our solution, is that
    the subsequent actions in the array are stored as `ACTION_POINTER_DOWN` and `ACTION_POINTER_UP`;
    therefore, with each pass through the loop, that we will shortly code, we need
    to check and handle both `ACTION_DOWN` and `ACTION_POINTER_DOWN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this talk, here is our `handleInput` method that gets called every
    time the screen is touched or released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering why we bothered to set up two sets of control code, one
    for playing and one for not playing, it is because in [Chapter 8](ch08.html "Chapter 8. Platformer
    – Putting It All Together"), *Putting It All Together*, we will add a cool new
    feature for the game while it is paused. Of course, the `togglePlayingStatus`
    method did not need to be done like this, and it would have worked fine without
    the test for the status of playing. It just saves us making minor intricate amendments
    to our code later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is open up the `PlatformView` class, grab a copy of the
    array with all the control buttons in, and draw them to the screen. We use the
    `drawRoundRect` method to draw neat curved-corner rectangles to represent the
    areas of the screen that will respond to the player''s touches. Enter this code
    in the `draw` method right before the call to `unlockCanvasAndPost()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Also, right before we call `unlockCanvasAndPost()`, let's draw a simple pause
    screen so that we know when the game is paused or playing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now jump and walk all over the place and a nice retro jumping sound
    plays as well. Why not add some more grass to the scene by editing `LevelCave`
    and replacing a few period characters (`.`) with a few more `1` characters. The
    next screenshot shows that the player has been jumping around a bit as well as
    the buttons used for controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player input](img/B04322_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will design some real-playable levels, as well as link them together in [Chapter
    8](ch08.html "Chapter 8. Platformer – Putting It All Together"), *Putting It All
    Together*. For now, just do whatever seems like fun with `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can get rid of that ugly squashed player graphic and make a neat little
    animation out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Bob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite sheet animations work by quickly changing the image drawn to the screen.
    Exactly like a child may draw the phases of a stick-man moving on the corner of
    a book, and then quickly flicking through it to make it appear to move.
  prefs: []
  type: TYPE_NORMAL
- en: The frames of Bob's animation are already contained within the `player.png`
    file we have been using to represent him.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating Bob](img/B04322_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All we need to do is loop through them one at a time when the player is moving.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite straightforward to implement. We will make a simple animation
    class that handles the function of keeping time and returning the appropriate
    part of the sprite sheet when requested. We can then initialize a new animation
    object for any `GameObject` that needs to be animated. In addition, when they
    are being drawn in the `draw` method of `PlatformView`, if the object is animated,
    we will handle it slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will also see how to use the facing variable that tracks
    which way the player is facing. It will enable us to reverse the sprite sheet
    depending on the way the player (or any future animated objects) is headed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making the animation class. Create a new Java class and call
    it `Animation`. The code that follows soon will declare variables that hold the
    bitmap to be manipulated, the name of the bitmap, and a `rect` parameter to define
    the area of the sprite sheet that is the coordinates of the currently relevant
    frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have `frameCount`, `currentFrame`, `frameTicker`, and `framePeriod`
    that hold and control the number of available frames, the current frame number,
    and the timing of the change of the frames. As you would expect, we also need
    to know the width and height of a frame of animation, these are held by `frameWidth`
    and `frameHeight`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `Animation` class will regularly refer to the number of pixels
    per meter; therefore, it makes sense to hold this value in a member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter these member variables that we discussed in the `Animation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the constructor that prepares our animation object for use. We
    will see exactly how we prepare for the actual animation soon. Note that there
    are a fair few parameters in the signature indicating that the animation is quite
    configurable. Just note that FPS in this context is not referring to the frame
    rate of the game but the frame rate of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can deal with the real functionality of the class. The `getCurrentFrame`
    method first checks to see if the object is moving or if it is capable of moving.
    At this stage, this may seem a little odd as this method will only ever be called
    by a `GameObject` class that is animated. The odd looking check, therefore, is
    determining if a new frame is required at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: If an object moves, (such as Bob), but is standing still, then we don't need
    to change the frame of animation. However, if the animated object has no velocity
    ever, like a roaring fire, then we need to animate it all the time. It will never
    have any velocity so the `moves` variable will be `false`, but the method will
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The method then uses `time`, `frameTicker` and `framePeriod`, to determine if
    it is time to show the next frame of animation and if it increments the frame
    number to display. Then, if the animation is on the last frame, it goes back to
    the first frame.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the precise left and right-hand positions that represent the portion
    of the sprite sheet that contains the needed frame, are calculated and returned
    to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can add some members to the `GameObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Some methods to interact with our `Animation` class, which set and get variables,
    make the animation work and inform the `draw` method if the object is animated
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Lastly in `GameObject`, there is a method which the objects that require animating
    can use to set up their whole animation object. Note it is this `setAnimated`
    method that calls `new()` on a new animation object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The next method acts as a go between for the `draw` method of the `PlatformView`
    class and the `getRectToDraw` method of the `Animation` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update the `Player` class in order to initialize its animation
    object according to its own specific required number of frames and frames per
    second. The new code in the `Player` class is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can use all this new code from the `draw` method to implement our animations.
    The next block of code checks if the current `GameObject` being drawn `isAnimated()`.
    If it is, it gets the appropriate rectangle from the sprite sheet using the `getNextRect()`
    method via the `GameObject` class's `getRectToDraw` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, the next code listing from the `draw` method that made the original
    call to `drawBitmap()`, is now wrapped in an `else` clause at the end of the new
    code. Basically, the logic is this. If animated, execute the new code, otherwise
    just do it the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the animation code we know about, we also check `if(go.getFacing()
    == 1)` and use the `Matrix` class to flip the bitmap when required by scaling
    it by -1 on the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all the new code, including the original `drawBitmap()` call wrapped
    in an `else` clause at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the game and see Bob in all his animated glory. The screenshot
    can''t show his movements, but you can see he is now perfectly formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating Bob](img/B04322_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game is steadily coming together. At this stage, we can build a huge level
    design in `LevelCave` and go running and jumping all over the place. However,
    we will save to postpone trying to make the game playable until we have added
    a load more neat features.
  prefs: []
  type: TYPE_NORMAL
- en: These neat features will include a machine gun, which can be upgraded through
    collectible pickups and some enemies that Bob can shoot at. We will get going
    with that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
