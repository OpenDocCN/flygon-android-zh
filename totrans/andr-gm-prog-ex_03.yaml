- en: Chapter 3. Tappy Defender – Taking Flight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to quickly add a lot of new objects and some features as well.
    By the end of this chapter, we will be really close to a playable game. We will
    detect the player touching the screen, so he can control the spaceship. We will
    add virtual boosters to our `SpaceShip` class to move the ship up and down and
    increase the speed.
  prefs: []
  type: TYPE_NORMAL
- en: We will then detect the resolution of the Android device and use it to do things
    like prevent the player boosting off the screen, and to detect when our enemies
    need to respawn.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `EnemyShip` class, which will represent the suicidal enemies.
    We will also see how we can easily spawn and then control them without changing
    any of the logic from the control part of our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a scrolling effect by adding a `SpaceDust` class and spawning dozens
    of them to make it look like the player is whizzing through space.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will learn about, and implement, collision detection so we know
    when our player has been hit by an enemy, as well as look at a graphical trick
    to help us with debugging our collision detection code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our player's spaceship floating aimlessly on the screen starting 50
    pixels from the left and 50 pixels from the top and drifting slowly to the right.
    Now, we can give the player the power to control the spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the design for the controls is a one finger tap and hold to boost,
    release to quit boosting and decelerate.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SurfaceView` class that we extended for our view is perfect for handling
    screen touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is override the `onTouchEvent` method within our `TDView`
    class. Let''s see the code in full, and then we can examine it more closely to
    make sure we understand what is going on. Enter this method in the `TDView` class
    and import the necessary classes in the usual way. I have highlighted the parts
    of the code that we will be customizing later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is how the `onTouchEvent` method works so far. The player touches the screen;
    this can be any kind of contact at all. It could be a swipe, a pinch, multiple
    fingers, and so on. A detailed message is sent to the `onTouchEvent` method.
  prefs: []
  type: TYPE_NORMAL
- en: The details of the event are contained in the `MotionEvent` class parameter,
    as we can see in our code. The `MotionEvent` class holds lots of data. It knows
    how many fingers were placed on the screen, the coordinates of each, and if any
    gestures were made as well.
  prefs: []
  type: TYPE_NORMAL
- en: As we are implementing a simple tap and hold to boost, release to stop boosting
    control scheme; we can simply switch using the `motionEvent.getAction() & MotionEvent.ACTION_MASK`
    condition and cater for just two of many possible different cases.
  prefs: []
  type: TYPE_NORMAL
- en: The case `MotionEvent.ACTION_UP:` will, as the name suggests, tell us when the
    player removes a finger from the screen. Then, perhaps unsurprisingly, case `MotionEvent.ACTION_DOWN:`
    tells us if the player places a finger on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we can find out through the `MotionEvent` class is quite vast. Why not
    take a look at the full scope of its potential here: [http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html).
    We will also explore this class further in the next project that we start to build
    in [Chapter 5](ch05.html "Chapter 5. Platformer – Upgrading the Game Engine"),
    *Platformer – Upgrading the Game Engine*.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding boosters to the spaceship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, all we need to do is think about how we will use these events to control
    the spaceship. First of all, the spaceship needs to know if it is boosting or
    not boosting. This suggests a Boolean member variable. Add this code just after
    the class declaration in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to initialize it when a `PlayerShip` object is created. So add
    this to the `PlayerShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to let the `onTouchEvent` method toggle `boosting` between true
    and false, boosting and not boosting. Add these methods to the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call these public methods from our `onTouchEvent` method to control
    the state of whether the spaceship is boosting or not. Add this new code in the
    `onTouchEvent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, our view is talking to our model; all we need to do is make the boosting
    variable do something depending on which state it is in. The logical place for
    this code will be the `PlayerShip` class's `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change the `speed` variable of our spaceship based on whether the ship
    is currently boosting. At first this seems simple, but there are a few minor issues
    with just increasing the speed based on whether the ship is boosting:'
  prefs: []
  type: TYPE_NORMAL
- en: One problem is that the `update` method is called 60 times every second. So,
    it wouldn't take much boosting to have the ship flying at ridiculous speeds. We
    need to constrain the ship's speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another problem is that our spaceship will rise up the screen when boosting,
    and there is nothing to stop it whizzing straight off the top of the screen, never
    to be seen again. We need to constrain the ship's *x* and *y* coordinates within
    the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ship is not boosting and the speed steadily returns to zero, what will
    bring the ship back down again? We will need a simple gravity physics simulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve these three problems, we can add code to our `PlayerShip` class. However,
    before we do this, a quick word about gameplay balance. The code which we will
    see very soon uses different integer values, for example, we initialize `GRAVITY`
    to `-12` and `MAX_SPEED` to `20`. These numbers have no bearing in reality!
  prefs: []
  type: TYPE_NORMAL
- en: They are simply the arbitrary numbers that make the gameplay balanced. Feel
    free to play with all these arbitrary figures to make the game harder, easier,
    or even impossible. At the end of [Chapter 4](ch04.html "Chapter 4. Tappy Defender
    – Going Home"), *Tappy Defender – Going Home*, we will look more closely at game
    iteration and look again at difficulty and balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With three of our previously stated problems in mind, add the following member
    variables just after the class declaration in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we made a start to solve our three problems, we can add code to our `PlayerShip`
    class''s `update` method. We will delete the one line of code, we put in there
    in the previous chapter. That was just there to take a quick look at our ship
    in action. Enter the new code of our `PlayerShip` class''s `update` method. We
    will take a closer look afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order from the top of the previous block of code, we are increasing and decreasing
    the speed variable by apparently arbitrary amounts, each frame of the game, based
    on if the ship is boosting or not.
  prefs: []
  type: TYPE_NORMAL
- en: We then constrain the speed of the ship to a maximum of 20 and a minimum of
    1, as specified by the variables we added earlier. With the line `y -= speed +
    GRAVITY`, we move the graphic on screen either up or down based on speed and gravity.
    The apparently arbitrary values for `GRAVITY` and `MAX_SPEED` work nicely to allow
    the player to awkwardly and precariously bounce along through space.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we stop the ship from ever disappearing off the screen by making sure
    the ship graphic is never drawn beyond `maxY` and `minY`. You have probably noticed
    that, as of yet, we haven't initialized `maxY` and `minY`. Furthermore, what will
    we initialize them to anyway as many Android devices have vastly different screen
    resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is discover the resolution of the Android device at run time
    and use the information to initialize `MaxY` and `minY`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the screen resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that we need the maximum *y* coordinate of the player's screen. Later
    in the project when we start adding backgrounds and enemy ships, we will realize
    that we also need the maximum *x* coordinate as well. With this in mind, let's
    see how we can get this information and make it available to the `PlayerShip`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most expedient time to detect the screen resolution is as the app is starting,
    and before our view and the model have been instantiated. This implies that our
    `GameActivity` class is a good place to do it. We will now add code to the `onCreate`
    method of the `GameActivity` class. Add this new code to the `onCreate` class,
    before the call to `new...` that creates our `TDView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares and initializes an object of the `Display` type using
    `getWindowManager().getDefaultDisplay();`. Then we create a new object of type
    `Point`. The `Point` object can hold two coordinates and we then pass it as an
    argument into the `getSize` method of our new `Display` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the resolution of the Android device our game is running on, neatly
    stored in `size`. Now pass this on to the parts of our code which require it.
    First, we will change the arguments we pass in the call to `new`, which initializes
    our `TDView` object. Change the call to `new` as shown next to pass in the screen
    resolution to the `TDView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, of course, we need to update the `TDView` constructor itself. In the
    `TDView.java` file, amend the `TDView` constructor''s signature so that the declaration
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, still in the constructor, change the way we initialize the player of our
    `PlayerShip` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we must now amend the constructor declaration within the `PlayerShip`
    class itself, to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we can now initialize our `maxY` and `minY` variables within the
    `PlayerShip` constructor. Before we see the code, we need to consider exactly
    how this will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of the bitmap that holds our spaceship graphic is drawn with
    the top-left corner at the *x = 0* and *y = 0* coordinates passed in to `drawBitmap()`
    in the `TDView` class''s `draw` method. This means that there are pixels off to
    the right and after the coordinates at which we begin to draw the ship. Take a
    look at this next image to visualize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the screen resolution](img/B043422_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we must set our `minY` and `maxY` values with this in mind. As the
    image illustrates, the top pixel of the bitmap is indeed drawn exactly at the
    ships *y*. We can then be confident that `minY` should be zero.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the ship, however, is drawn at *y + the height of the bitmap*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add two lines of code to our constructor to initialize these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can now run the game and test out your boosters!
  prefs: []
  type: TYPE_NORMAL
- en: Building the enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the tap controls implemented, it is time to add some enemies
    that the player can boost to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: This is going to be much easier than when we added our player's spaceship because
    most of what we need is in place already. All we have to do is code a class to
    represent our enemy, instantiate as many enemy objects as we need, call their
    `update` methods, and then draw them.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, the `update` method for our enemy will be quite different to
    that of `PlayerShip`. It will need to handle things like simple AI to fly toward
    the player. It will also need to handle respawning when it leaves the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin with, create a new Java class and call it `EnemyShip`. Add these member
    variables inside the class so your new class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add some getter and setter methods so that the `draw` method can access
    what it needs to draw, and where it needs to draw it. There is nothing new or
    unusual here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Spawning the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s implement the `EnemyShip` constructor in full. Enter the code now, and
    we will then take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constructors' signature is exactly that of the `PlayerShip` class. A `Context`
    class for manipulating your `Bitmap` object and `screenX` and `screenY` that hold
    the resolution of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with the `PlayerShip` class, we load up an image into `Bitmap`.
    Of course, we once again need to add an image file named `enemy.png` to the `drawable`
    folder of our project. There is a neat enemy graphic in the `Chapter3/drawable`
    folder of the download bundle or you can design your own. Any size between roughly
    32 x 32 and 256 x 256 will suffice for the purposes of this game. Also, like those
    supplied, your graphics do not need to be square. We will see that our game engine
    is imperfect when it comes to how it looks on different screen sizes, and we will
    address this in the next project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning the enemy](img/B043422_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we initialize `maxX`, `maxY`, `minX`, and `minY`. Although the enemies
    only move horizontally, we need the `maxY` and `minY` coordinates to make sure
    that we spawn them at a sensible height. The `maxX` coordinate will enable us
    to spawn them just off-screen horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object of type `Random` and generate a random number between
    the values of 10 and 15\. These are the maximum and minimum speeds our enemies
    can travel at. These values are fairly arbitrary, and we might adjust them when
    we do some play-testing in [Chapter 4](ch04.html "Chapter 4. Tappy Defender –
    Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering how `generator.nextInt(6)+10;` comes up with a number between
    10 and 15, it is because the `6` argument causes `nextInt()` to return a number
    between 0 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the enemy ship's *x* coordinate to screen, which spawns it on the
    far left of the screen. Actually, this spawns it off screen. However, that is
    fine because it will then emerge in to the player's view rather than just appearing
    all at once.
  prefs: []
  type: TYPE_NORMAL
- en: We now generate another random number based on `maxY`—the height of the enemy
    ship bitmap `(bitmap.getHeight())`—to create a random but sensible *y* coordinate
    for our enemy ship to spawn at.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do now is to give our enemies life by coding their update method.
  prefs: []
  type: TYPE_NORMAL
- en: Making the enemy think
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can handle the `EnemyShip` class's `update` method. For now, we just
    need to handle two things. First, fly the enemy toward the player's end of the
    screen. We need to take account of the enemy's speed and the player's speed to
    simulate this accurately. The reason we need to do this is because when the player
    boosts, he expects his speed to increase, and objects to rush toward him more
    quickly. However, the spaceship graphic is horizontally static.
  prefs: []
  type: TYPE_NORMAL
- en: We can increase the rate of travel of an enemy in proportion to both the enemy's
    static and randomly generated speed at the same time as the player's dynamically
    set speed (through boosting). This will give the player a sense of speeding up
    even though the ship graphic never moves forward.
  prefs: []
  type: TYPE_NORMAL
- en: The other issue is that the enemy ship will eventually fly off the screen, on
    the left-hand side. We need to detect when this happens and respawn it on the
    right-hand side with a new random *y* coordinate and a new random speed. This
    is just like we did in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally before we get to the actual code, let's consider something. If the enemy
    is going to take note of and use the player's speed, it will need to be able to
    get it. Note that in the next block of code, the `EnemyShip` class's `update`
    method declaration has a parameter to receive the player's speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how this is passed in when we add code to the `TDView` class''s
    `update` method soon. Enter the following code for the `EnemyShip` class''s `update`
    method to implement what we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first decreased the enemy's *x* coordinate by the player's
    speed then by the enemy's speed. As the player boosts, the enemy will fly at the
    player faster. However, if the player is not boosting then the enemy will attack
    at the speed that was previously and randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After this, we simply detected if the right-hand edge of the enemy bitmap has
    disappeared from the left-hand side of the screen. This is done by detecting if
    the `EnemyShip` class's *x* coordinate is the width of the bitmap off screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then we respawn the very same object to come at the player again. This appears
    to the player as if it is an entirely new enemy.
  prefs: []
  type: TYPE_NORMAL
- en: The last three things we must do are create a new object from `EnemyShip` by
    declaring and then initializing an object. Actually, let's make three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, were we declared our player''s ship in our `TDView.java` file, declare
    three enemy ships like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the constructor of our `TDView` class, initialize our three new enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` method of our `TDView` class, we call each of the new object's
    `update` methods in turn. Here, we also see how we pass in the player's speed
    to each of our enemies so they can use it in their `update` methods to adjust
    speed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the `TDView` class's `draw` method, we draw our new enemies to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game and give this a try now.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most obvious problem is that the player and the enemies fly right
    through each other. We will solve this problem later in this chapter, in the *Things
    that go bump – collision detection* section. But right now, we can make our player's
    sense of immersion better by drawing a star/space dust field as a background.
  prefs: []
  type: TYPE_NORMAL
- en: The thrill of flight – scrolling the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing our space dust is going to be really quick and easy. All we will
    do is create a `SpaceDust` class with very similar properties to our other game
    objects. Spawn them into the game at a random location, move them toward the player
    at a random speed, and respawn them on the far right of the screen, again with
    a random speed and *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Then in our `TDView` class, we can declare a whole array of these objects, update,
    and draw them each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `SpaceDust`. Now enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here is what is happening in the `SpaceDust` class. At the top of the previous
    block of code, we declare our usual speed and maximum and minimum variables. They
    will allow us to detect when the `SpaceDust` object leaves the left of the screen
    and needs respawning on the right, and provide sensible bounds for the height
    at which we respawn the object.
  prefs: []
  type: TYPE_NORMAL
- en: Then inside the `SpaceDust` constructor, we initialize the `speed`, `x`, and
    `y` variables with random values, but within the bounds set by the maximum and
    minimum variables we just initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Then we implement the `SpaceDust` class's `update` method, which moves the object
    to the left based on the speed of the object and the player, then checks if the
    object has flown of the left-hand edge of the screen and respawns it with random
    but appropriate values if it has.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, we provide two getter methods so that our `draw` method knows
    where to draw each speck of dust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create an `ArrayList` object to hold all our `SpaceDust` objects.
    Declare it just under the declaration of the other game objects near the top of
    the `TDView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TDView` constructor, we can initialize a whole bunch of the `SpaceDust`
    objects using a `for` loop and then stash them into the `ArrayList` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We create forty specks of dust in total. Each time through the loop, we create
    a new speck of dust and the `SpaceDust` constructor assigns it a random location
    and a random speed. We then put the `SpaceDust` object into our `ArrayList` object
    with `dustList.add(spec);`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we jump to our `TDView` class''s `update` method and use an enhanced
    `for` loop to call `update()` on each of our `SpaceDust` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we passed in the player speed so that the dust increases and decreases
    its speed relative to the player's speed.
  prefs: []
  type: TYPE_NORMAL
- en: Now to draw all our space dust, we loop through our `ArrayList` object and draw
    a speck at a time. Of course, we add the code to our `TDView` class's `draw` method,
    but we must make sure to draw the space dust first so it appears behind the other
    game objects. In addition, we have an extra line to switch pixel color to white
    before using the `drawPoint` method of our `Canvas` object to plot a single pixel
    for each `SpaceDust` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `draw` method of the `TDView` class, add this code to draw our dust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing here is the `canvas.drawpoint...` line of code. Apart from
    drawing bitmaps to the screen, the `Canvas` class allows us to draw primitives,
    like points and lines, as well as things like text and shapes. We will use these
    features when drawing a HUD for our game in [Chapter 4](ch04.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not run the app and check out how much neat stuff we have implemented?
    In this screenshot, I have temporarily increased the number of the `SpaceDust`
    objects to `200`, just for fun. You can also see that we have enemies drawn, attacking
    at a random *y* coordinate with random speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The thrill of flight – scrolling the background](img/B043422_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Things that go bump – collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collision detection is quite a broad subject. Throughout the three projects
    in this book, we will use a whole range of different ways to detect when things
    collide.
  prefs: []
  type: TYPE_NORMAL
- en: So, here is a quick look at our options for collision detection, and in which
    circumstances different methods may be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we just need to know when certain objects from our game touch other
    objects. We can then respond to that event by exploding, reducing shields, playing
    a sound, or whatever is appropriate. We need a broad understanding of our different
    options so we can make the right decisions in any particular game.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, here are a few of the different mathematical calculations we can
    utilize and when they may be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This type of collision detection is really straightforward. We draw an imaginary
    rectangle; we can call it a hitbox or bounding rectangle, around the objects we
    want to test for collision. Then, test to see if they intersect. If they do, we
    have a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rectangle intersection](img/B043422_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where the hitboxes intersect, we have a collision. As we can see from the previous
    image, this is far from perfect. However, in some situations, it is sufficient.
    To implement this method, all we need to do is test for the intersection using
    the *x* and *y* coordinates of both objects.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the following code. It is for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes we have a `getHitbox` method that returns the left
    and right *x* coordinates as well as the top and bottom *y* coordinates of the
    given object. In the aforementioned code, we first check to see if the *x* axes
    overlap. If they don't, then there is no point going any further. If they do,
    then check the *y* axes. If they don't, it could have been an enemy whizzing by
    above or below. If they overlap on the *y* axis as well, then we have a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can check the *x* and *y* axis in either order as long as we check
    them both.
  prefs: []
  type: TYPE_NORMAL
- en: Radius overlapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is also checking to see if two hitboxes intersect with each other,
    but as the title suggests, it does so using circles instead. There are obvious
    advantages and disadvantages. Mainly that this works well with shapes more circular
    in nature and less well with elongated shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Radius overlapping](img/B043422_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous image, it is easy to see how the radius overlapping method
    is inaccurate for these particular objects and not hard to imagine how for a circular
    object like a ball it would be perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we can implement this method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code is for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code again makes some assumptions. Like we have a `getHitBox` method that
    can return the radius as well as the center *x* and *y* coordinates. Furthermore,
    because the static `Math.sqrt` method takes and returns a variable of type `double`,
    we will need to start working with different types in our `SpaceShip` and `EnemyShip`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the way we initialize distance: `Math.sqrt(distanceX * distanceX + distanceY
    * distanceY);` looks a little confusing, it is simply using Pythagoras'' theorem
    to get the length of the hypotenuse of a triangle which is equal in length to
    a straight line drawn between the centers of the two circles. In the last line
    of our solution, we test if `distance < ship.getHitBox.radius + enemy.getHitBox.radius`,
    then we can be certain that we must have a collision. That is because if the center
    points of two circles are closer than the combined length of their radii, they
    must be overlapping.'
  prefs: []
  type: TYPE_NORMAL
- en: The crossing number algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is mathematically more complicated. However, as we will see in
    our third and final project, it is perfect for detecting when a point intersects
    a convex polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The crossing number algorithm](img/B043422_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is perfect for an Asteroids clone, and we will explore this method more
    as well as see it in action in our final project.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, the different collision detection methods can have at least
    two problems depending on which method you use in which situation. The problems
    are lack of accuracy and drain on CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple hitboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first problem, a lack of accuracy, can be solved by having multiple hitboxes
    per object.
  prefs: []
  type: TYPE_NORMAL
- en: We simply add the required number of hitboxes to our game object to most effectively
    *wrap* it, and then perform the same rectangle intersection code on each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Neighbor checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows us to only check objects that are in the approximate same
    area as each other. It can be achieved by checking which neighborhood of our game
    a given two objects are in, and then only performing the more CPU intensive collision
    detection if there is a realistic chance that a collision could occur.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have 10 objects that each need to be checked against each other,
    then we need to perform 10 squared (100) collision checks. If we do neighbor checking
    first, we can significantly reduce this number. In the very hypothetical situation
    in the diagram, we would only need to do an absolute maximum of 11 collision checks,
    instead of 100, for our 10 objects, if we first check to see if objects share
    the same sector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Neighbor checking](img/B043422_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing this in code can be as simple as having a sector member variable
    for each game object, then looping through the list of objects and just checking
    if they are in the same sector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use all these options and optimizations over the course of our three
    game projects.
  prefs: []
  type: TYPE_NORMAL
- en: Best options for Tappy Defender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know our collision detection options, we can decide the best course
    of action in our current game. All our ships are approximately rectangular (or
    square), there are few or no extremities on any of them, and we only have one
    object were we really care about a collision (with all the others).
  prefs: []
  type: TYPE_NORMAL
- en: This tends to suggest that we can use a single rectangular hitbox for the player
    and the enemy and perform purely corner aligned, global collision detection. If
    you're disappointed that we are going for the easy option, then you will be pleased
    to hear we will be getting into all the fancier techniques over the next two projects.
  prefs: []
  type: TYPE_NORMAL
- en: To make life even easier, the Android API has a handy the `Rect` class that
    can not only represent our hitboxes, but also has a neat `intersects` method that
    basically does the same thing as rectangle intersection collision detection. Let's
    think about how to add collision detection to our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, all of our enemies and our player ship are going to need a hitbox. Add
    this code to declare a new `Rect` member called `hitbox`. Do this in both the
    `PlayerShip` and `EnemyShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important!**'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to do the previous step and the next three blocks of code for both the
    `EnemyShip` class as well as the `PlayerShip` class. I will remind you each time
    but just thought it worth mentioning beforehand as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a getter method to the `PlayerShip` class and the `EnemyShip`
    class. Add this code to both classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And next, we need to make sure we initialize our hitboxes in both constructors.
    Make sure to enter the code right at the end of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make sure the hitboxes are kept up-to-date with the coordinates
    of our enemies and our player. The best place to do this is the `update` method
    of the enemy/player ships. The next block of code will update the hitboxes with
    the ship''s current coordinates. Be sure to add this block of code at the very
    end of the `update`() methods so that the hitbox is updated with the coordinates
    after the `update` methods have done their adjustments. Again, add it to both
    `PlayerShip` and `EnemyShip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our hitboxes have the coordinates that represent the outline of our bitmaps.
    This situation is nearly perfect, apart from the transparent bits around the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use our hitboxes from the `TDView` class's `update` method to detect
    collisions. But first, we need to decide what we are going to do when a collision
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: We need to refer to the rules of our game. We discussed them back at the beginning
    of [Chapter 2](ch02.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We know that the player has three shields but an enemy blows up
    after one hit. It makes sense to leave things like shields to a later part of
    the chapter, but we need some way to see our collision detection in action and
    make sure it is working.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the simplest way to acknowledge a collision at this stage, will be
    to make the enemy ship disappear and respawn as normal, as if it is a totally
    new enemy. We already have a mechanism in place for this. We know that when an
    enemy moves off the left of the screen it respawns as if it is a new enemy on
    the right. All we need to do is instantly transport the enemy to a location off
    of the left of the screen and the `EnemyShip` class will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to change the `EnemyShip` object''s *x* coordinate. Let''s
    add a setter method to the `EnemyShip` class so we can manipulate the *x* coordinate
    of all our enemy spaceships. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can carry out collision detection and respond when we get a hit. The
    next block of code uses the static method `Rect.intersects()` to detect a hit
    by comparing the player ship''s hitbox with each of the enemy hitboxes in turn.
    If a hit is detected, the appropriate enemy is moved off screen, ready to be respawned
    by its own `update` method in the next frame. Enter this code at the very top
    of the `TDView` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, our collisions will now work. It may be nice to be able to really
    see what is going on. For the purposes of debugging, let''s draw a rectangle around
    all our spaceships, so we can see the hitboxes. We will use the `drawRect` method
    of the `Paint` class and pass the properties of our hitboxes in as arguments to
    define the area to draw. As you will expect, this code goes in the `draw` method.
    Note that it should go before the code that draws our ships so that the rectangles
    are drawn behind them, but after we clear the screen, as shown by the highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run Tappy Defender and see the game in action complete with debugging
    mode hitboxes enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Best options for Tappy Defender](img/B043422_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can comment out this debugging code when we are done with it and then uncomment
    it should we need it again later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have all the game objects that we need for a complete game. They all
    think and represent themselves internally in the model part of our design pattern.
    Furthermore, our player can at last control his spaceship, and we can detect when
    he crashes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put the finishing touches to our game including
    adding a HUD (Heads Up Display), implementing the game rules, adding some extra
    features, and play-testing our game to get everything in balance.
  prefs: []
  type: TYPE_NORMAL
