- en: Chapter 9. Implementing Game Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shortest description of this chapter contains only two words: state machines.
    Here, we will introduce a common approach to organize interactions between the
    gaming code and the user interface part of the application. We start with an implementation
    of the Boids algorithm and then proceed with the extension of our user interface
    implemented in the previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Boids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many game applications, you can usually see moving objects that collide,
    shoot, chase each other, can be touched or avoided by other objects, or produce
    similar behaviors. The visible complex behavior of objects can usually be broken
    down into a few simple states interoperating together. For example, in an arcade
    game an enemy randomly *wanders around* until it sees a player controlled character.
    After the encounter, it switches to the *chase* state, probably switching to *shoot*
    or *attack* states when in close proximity to the target. If an enemy unit perceives
    some disadvantage, it may *flee* from the player. The *chase* state in turn might
    not only target the enemy towards the player, but also avoid collisions with the
    environment. Each object can be differently animated or have different material
    while being in different states. Let's implement the chasing and wandering algorithms
    using an established approach invented by Craig Reynolds called *Flocking behaviors*
    or *Boids* ([https://en.wikipedia.org/wiki/Boids](https://en.wikipedia.org/wiki/Boids)).
    This method is used to create an impression of a semi-conscious flock or an intelligent
    swarm of some creatures. We use the State pattern ([https://en.wikipedia.org/wiki/State_pattern](https://en.wikipedia.org/wiki/State_pattern))
    extensively throughout this chapter to define complex user interaction scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider only a two-dimensional game world and approximate each object,
    or a flockmate, as a circle with a velocity. Velocity, being a vector, has both
    magnitude and direction. Each object obeys three simple rules to calculate its
    desired velocity ([http://www.red3d.com/cwr/boids](http://www.red3d.com/cwr/boids)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoidance*: Steer away to avoid crowding local flockmates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Cohesion*: Steer towards the average heading of local flockmates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Alignment*: Steer to move toward the average position of local flockmates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional rules or behaviors that we implement are *ArriveTo* and *Wander*
    algorithms, which can be used as a basic debugging tool of our behavioral mechanics
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule, *Avoidance*, directs the velocity away from the obstacles as
    well as from the other flockmates, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boids](img/image00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second rule, *Cohesion*, steers towards the average heading of local flockmates,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boids](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The third rule, *Alignment*, tries to adjust the calculated average velocity
    of nearby objects. It affects a group of flockmates in such a way that their movement
    direction soon becomes collinear and codirectional, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boids](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The rule, *ArriveTo*, sets the velocity direction to a predefined target point
    or region in space. By allowing the target to move in space, we can create some
    intricate behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the flocking algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the above mentioned behaviors, we will consider the following
    class hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation of the flocking algorithms](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A single boid is represented by an instance of the `clBoid` class, which holds
    a pointer to an instance of `iBehaviour`. The `iBehavior` interface contains a
    single member function, `GetControl()`, which calculates the instant force acting
    on a boid. Since the force magnitude might depend on a boid''s state, we pass
    a raw non-owning pointer to `clBoid` into `GetControl()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider the `clBoid` class itself. It contains `m_Pos` and `m_Vel`
    fields, which hold the current position and velocity of the boid, respectively.
    These values are two-dimensional vectors, but the whole structure can be extended
    to 3D logic using three-component vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_Angle` field is the boid''s instant orientation, and it is calculated
    from the `m_Vel` value. The `m_MaxVel` field contains the maximum velocity of
    the boid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_Behaviour` field holds a pointer to an `iBehaviour` instance, which
    calculates the control force of the desired behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a boid moves in a swarm and relies upon positions and velocities of the
    neighboring boids to adjust its velocity, we keep a non-owning pointer to the
    parent `clSwarm` object to avoid circular references between smart pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the class initializes default values and sets an empty behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The only member function is `Update()`, which calculates a force acting on
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the force is calculated, it modifies the velocity according to Newton''s
    law, *a = F/m*, and the Euler integration method ([https://en.wikipedia.org/wiki/Euler_method](https://en.wikipedia.org/wiki/Euler_method)).
    The mass of the boid is set to a constant value of `1.0`. Feel free to introduce
    a varying parameter and observe how it changes the visual behavior of the swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things visually plausible, we restrict the maximum possible velocity
    to the `0…m_MaxVel` interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the velocity is calculated, the position of the boid is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the orientation of the boid should be evaluated as an angle between
    the `X` axis and the `m_Vel` vector. This value is used to render the boid on
    screen using a pointing arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest possible non-static behavior is random movement under the influence
    of abrupt random impulses. This is called the *Wandering* behavior and implemented
    in the `clWanderBehaviour` class. The `GetControl()` method calculates a vector
    with two random components within the -1..+1 range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful behavior of a boid is implemented in the `clGoToBehaviour` class.
    Given the target coordinates in the `m_Target` field, this behavior drives the
    controllable boid to that point. Once the boid is within the `m_TargetRadius`
    distance from `m_Target`, the movement is stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_Target` and `m_TargetRadius` fields define the location and radius of
    the target point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_VelGain` and `m_PosGain` members hold two values, that define how fast
    a boid should brake once the target is reached, and how fast the boid accelerates
    proportionally to the distance to the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets default values and non-zero gains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetControl()` routine calculates the difference between the boid position
    and the target. This difference is multiplied by `m_PosGain` and is used as the
    control force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the boid is within the `m_TargetRadius` distance, we will return a zero
    as a value of the control force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A visually interesting braking effect can be achieved by replacing the preceding
    line with the line `return -m_VelGain * Boid->m_Vel / dt;`. The braking impulse
    is applied, which decreases the velocity by some fraction which results in a smooth
    exponential decay of the velocity. Visually, the boid stops smoothly near the
    target center.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculated impulse is returned at the end of the member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Digression: helper routines'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we should describe a couple of functions used in control calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we used the `ClampVec2()` routine, which calculates
    the length of a vector `V`, compares this length to `MaxValue`, and returns either
    the same vector `V` or its clamped coaxial version of the `MaxValue` length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another bunch of methods include random number generation routines. The `RandomFloat()`
    method uses the C++11 standard library to generate uniformly distributed floating-point
    values in the 0…1 interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RandomVec2Range()` method uses the `RandomFloat()` function twice to return
    a vector with random components within a specified interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Collective behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we have defined only the `clWanderBehaviour` class. To implement flocking
    algorithms, we need to store information about all the boids at once. Such a collection
    is called a *Swarm* here. The `clSwarm` class holds a vector of `clBoid` objects
    and implements a number of routines used in boid control calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For debugging and visual demonstration purposes, the `GenerateRandom()` method
    allocates a number of `clBoid` objects with random positions and zero velocities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, each boid has a *Wandering* behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Positions are random and are also kept within the -1..+1 range for each coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Update()` method iterates the collection and updates every boid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Separation* or the *Avoidance* algorithm uses the sum of distances to
    other boids as the control force. The `clSwarm::CalculateSeparation()` method
    iterates the collection of boids and calculates the required sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For each boid, except the one passed as the parameter, we calculate the position
    delta:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the distance is beyond the safety threshold, for example, if the boid is
    in close proximity with another boid, we add a negative delta to the control force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar routine is used in the *Cohesion* algorithm to calculate an average
    position of the neighboring boids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We only sum the positions if there is more than one boid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A loop over the list of boids gives us the sum of the positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of a single boid, we use its position. This way the control force in
    the *Cohesion* algorithm will be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar procedure is applied to the velocities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The utility method `SetSingleBehaviour()` sets the behavior of each and every
    boid in a swarm to the specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `clSwarm` class, we can finally implement the flocking
    behavior. The `clFlockingBehaviour` uses information about neighboring boids and
    calculates the control force with the classic Boids algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the constructor sets default parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_SafeDistance` field defines a distance at which the collision avoidance
    algorithm does not act:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next fields contain the weights for the influence of each flocking algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is *Separation* and *Avoidance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is *Alignment*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step is *Cohesion*. Steer to the average position of the neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we sum up all three values and keep the force magnitude below `m_MaxValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The finishing touch for our behavior system is a class that implements a mixture
    of behaviors. The `clMixedBehaviour` class contains a vector of behaviors and
    respective weight factors that show how much of a behavior''s control force is
    used in the resulting behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddBehaviour()` member function adds a new weight factor and a behavior
    to the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name of the class suggests, the `GetControl()` routine calculates the
    control for each of the contained behaviors and sums all these control vectors
    multiplied by appropriate weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we can easily see, the `clFlockingBehaviour` class can be split up into *Avoidance*,
    *Cohesion*, and *Separation* parts. We decided not to complicate the structure
    of the book and implemented the flocking behavior as a single class. Feel free
    to experiment and mix these sub behaviors on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the developed swarm simulation system, we need to render individual
    boids. Since we already have an OpenGL 3D scene graph rendering system, we represent
    each boid with a triangular mesh and create scene nodes for them. Let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A single `clSceneNode` object in the `m_Root` field serves as the root scene
    node of the entire swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A pointer to the `clSwarm` object is kept to synchronize boid positions and
    angles with scene node transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Scene nodes for each boid are stored in the `m_Boids` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the class creates a scene node for each boid in the swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Visually, the boid is a triangle, so we call `clGeomServ::CreateTriangle()`
    to create a vertex array with a single triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a geometry node is initialized, we add it to `m_Root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'At each frame, we calculate the transformation for each `clSceneNode` attached
    to the boid root node. The transformation consists of a translation into the boid''s
    position followed by a rotation around the vertical `Z` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All other scene management code is similar to that from the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Boids demonstration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The demo code in `1_Boids` uses a mixture of *GoTo* and *Flocking* behaviors
    to make a swarm of boids chase a user-specified target, and at the same time,
    create an illusion of the swarm-like movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not discuss the whole source of the application here and only underline
    the most important parts. The initialization of the demo starts with the creation
    of `clSwarm` filled with randomly positioned boids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the same controller for all boids. The controller itself is a blend
    of `clFlockingBehaviour` and `clGoToBehavior` in the `g_Behaviour` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `g_Behaviour` instance holds coordinates of the target, which are initially
    set to `(1.0, 1.0)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The local `clSwarmRenderer` object is used at each frame of the rendering loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The demo uses touch input to change the coordinates of the target. When a touch
    occurs, we intersect the line passing through the touch point with the plane in
    which the boids reside. This intersection point is used as a new target point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know the touch has ended, we unproject the 2D mouse coordinates into
    the world space using perspective and view matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the camera view matrix, we calculate rotation and translation and use
    these values to intersect a ray from the mouse position with the `Z=0` plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a 3D intersection point is constructed, it can be used as a 2D target
    of the *GoTo* behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: At each iteration, we call the `Swarm::Update()` and `clSwarmRenderer::Update()`
    methods to update individual boid positions and velocities and to synchronize
    scene node transformations with the new data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go and run the `1_Boids` example to see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The page-based user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most parts of the previous chapters have laid down a foundation of a portable
    C++ application. Now, it is time to show you how to join more parts together.
    In [Chapter 7](part0065.xhtml#aid-1TVKI2 "Chapter 7. Cross-platform UI and Input
    System"), *Cross-platform UI and Input System*, we discussed how to create a simple
    custom user interface in C++ and respond to user input. In both cases, we only
    implemented a single fixed behavior without explaining how to switch to another
    one without writing spaghetti code. The first paragraphs of this chapter introduced
    the concept of *Behavior*, which we now apply to our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: We call a single fullscreen state of the user interface as *Page*. Thus, every
    different screen of the application is represented by the `clGUIPage` class, which
    we annotate hereinafter.
  prefs: []
  type: TYPE_NORMAL
- en: Three main methods of `clUIPage` are `Render()`, `Update()`, and `OnTouch()`.
    The `Render()` method renders a complete page with all child views. `Update()`
    synchronizes the view with the application state. `OnTouch()` reacts to user input.
    The `clGUIPage` class is derived from `clUIView`, so there should not be any problems
    understanding this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class contains two fields. The `FFallbackPage` field holds a pointer to
    another page, which is used as a return page, for example, when the back key is
    pressed on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The page we return to when the back key is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-owning pointer to the GUI object on this page came from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnActivation()` and `OnDeactivation()` methods are called when the GUI
    manager switches pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of pages is stored in the `clGUI` class. The `FActivePage` field indicates
    which page is currently visible. Events from user input are redirected to the
    active page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddPage()` method sets a pointer to the parent GUI object and adds this
    page to the pages container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetActivePage()` method invokes some callbacks aside from actually setting
    the page as active. If the new page matches the currently active page, no action
    is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a previously active page, we inform that page of switching to another
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new page is a non-null page, it is informed that it has been activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have mentioned before, each event is redirected to an active page stored
    in `FActivePage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `OnKey()` method is only used in Windows or OSX.
    However, a similar logic can be applied to Android if we treat the back key as
    an analogue of the Esc key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a non-null fallback page, we set it as active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `SetActive()` is put outside of the class declaration
    because it uses the then-undeclared `clGUI` class. This is used to remove the
    dependency from the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, our mini GUI page mechanism is complete and can be used to handle user
    interface logic in an actual application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement different behaviors of objects
    and use state machines as well as the design pattern to implement swarm logic.
    Let's proceed to the last chapter, so that we can combine many previous examples
    into a larger application.
  prefs: []
  type: TYPE_NORMAL
