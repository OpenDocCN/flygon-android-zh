["```java\n    android:name=\".AsteroidsActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\npackage com.gamecodeschool.c9asteroids;\n\nimport android.app.Activity;\nimport android.graphics.Point;\nimport android.opengl.GLSurfaceView;\nimport android.os.Bundle;\nimport android.view.Display;\n\npublic class AsteroidsActivity extends Activity {\n\n    private GLSurfaceView asteroidsView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // Get a Display object to access screen details\n        Display display = getWindowManager().getDefaultDisplay();\n\n        // Load the resolution into a Point object\n        Point resolution = new Point();\n        display.getSize(resolution);\n\n        asteroidsView = new AsteroidsView \n          (this, resolution.x, resolution.y); \n\n        setContentView(asteroidsView);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        asteroidsView.onPause();\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        asteroidsView.onResume();\n\n    }\n}\n```", "```java\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\n\npublic class AsteroidsView extends GLSurfaceView{\n\n    GameManager gm;\n\n    public AsteroidsView(Context context, int screenX, int screenY) {\n        super(context);\n\n        gm = new GameManager(screenX, screenY);\n\n        // Which version of OpenGl we are using\n        setEGLContextClientVersion(2);\n\n        // Attach our renderer to the GLSurfaceView\n        setRenderer(new AsteroidsRenderer(gm));\n\n    }\n\n}\n```", "```java\npublic class GameManager {\n\n    int mapWidth = 600;\n    int mapHeight = 600;\n    private boolean playing = false;\n\n    // Our first game object\n    SpaceShip ship;\n\n    int screenWidth;\n    int screenHeight;\n\n    // How many metres of our virtual world\n    // we will show on screen at any time.\n    int metresToShowX = 390;\n    int metresToShowY = 220;\n\n    public GameManager(int x, int y){\n\n        screenWidth = x;\n        screenHeight = y;\n\n    }\n\n    public void switchPlayingStatus() {\n        playing = !playing;\n\n    }\n\n    public boolean isPlaying(){\n        return playing;\n    }\n}\n```", "```java\nimport static android.opengl.GLES20.GL_FRAGMENT_SHADER;\nimport static android.opengl.GLES20.GL_VERTEX_SHADER;\nimport static android.opengl.GLES20.glAttachShader;\nimport static android.opengl.GLES20.glCompileShader;\nimport static android.opengl.GLES20.glCreateProgram;\nimport static android.opengl.GLES20.glCreateShader;\nimport static android.opengl.GLES20.glLinkProgram;\nimport static android.opengl.GLES20.glShaderSource;\n```", "```java\npublic class GLManager {\n\n     // Some constants to help count the number of bytes between\n     // elements of our vertex data arrays\n     public static final int COMPONENTS_PER_VERTEX = 3;\n     public  static final int FLOAT_SIZE = 4;\n     public static final int STRIDE =\n       (COMPONENTS_PER_VERTEX)\n        * FLOAT_SIZE;\n\n     public static final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n```", "```java\n// Some constants to represent GLSL types in our shaders\npublic static final String U_MATRIX = \"u_Matrix\";\npublic static final String A_POSITION = \"a_Position\";\npublic static final String U_COLOR = \"u_Color\";\n\n// Each of the above constants also has a matching int\n// which will represent its location in the open GL glProgram\npublic static int uMatrixLocation;\npublic static int aPositionLocation;\npublic static int uColorLocation;\n```", "```java\n// A very simple vertexShader glProgram\n// that we can define with a String\n\nprivate static String vertexShader =\n     \"uniform mat4 u_Matrix;\" +\n     \"attribute vec4 a_Position;\" +\n\n     \"void main()\" +\n     \"{\" +\n       \"gl_Position = u_Matrix * a_Position;\" +\n       \"gl_PointSize = 3.0;\"+\n  \"}\";\n```", "```java\n// A very simple vertexShader glProgram\n// that we can define with a String\n\nprivate static String vertexShader =\n    \"uniform mat4 u_Matrix;\" +\n    \"attribute vec4 a_Position;\" +\n\n    \"void main()\" +\n    \"{\" +\n        \"gl_Position = u_Matrix * a_Position;\" +\n        \"gl_PointSize = 3.0;\"+\n    \"}\";\n```", "```java\npublic static int getGLProgram(){\n  return program;\n}\n```", "```java\npublic static int buildProgram(){\n    // Compile and link our shaders into a GL glProgram object\n    return linkProgram(compileVertexShader(),compileFragmentShader());\n\n}\n\nprivate static int compileVertexShader() {\n    return compileShader(GL_VERTEX_SHADER, vertexShader);\n}\n\nprivate static int compileFragmentShader() {\n    return compileShader(GL_FRAGMENT_SHADER, fragmentShader);\n}\n```", "```java\nprivate static int compileShader(int type, String shaderCode) {\n\n    // Create a shader object and store its ID\n    final int shader = glCreateShader(type);\n\n    // Pass in the code then compile the shader\n    glShaderSource(shader, shaderCode);\n    glCompileShader(shader);\n\n    return shader;\n}\n```", "```java\nprivate static int linkProgram(int vertexShader, int fragmentShader) {\n\n  // A handle to the GL glProgram -\n  // the compiled and linked shaders\n     program = glCreateProgram();\n\n     // Attach the vertex shader to the glProgram.\n     glAttachShader(program, vertexShader);\n\n     // Attach the fragment shader to the glProgram.\n     glAttachShader(program, fragmentShader);\n\n     // Link the two shaders together into a glProgram.\n     glLinkProgram(program);\n\n     return program;\n}\n}// End GLManager\n```", "```java\nimport android.graphics.PointF;\nimport android.opengl.GLSurfaceView.Renderer;\nimport android.util.Log;\nimport javax.microedition.khronos.egl.EGLConfig;\nimport javax.microedition.khronos.opengles.GL10;\nimport static android.opengl.GLES20.GL_COLOR_BUFFER_BIT;\nimport static android.opengl.GLES20.glClear;\nimport static android.opengl.GLES20.glClearColor;\nimport static android.opengl.GLES20.glViewport;\nimport static android.opengl.Matrix.orthoM;\n```", "```java\npublic class AsteroidsRenderer implements Renderer {\n\n// Are we debugging at the moment\n\nboolean debugging = true;\n\n// For monitoring and controlling the frames per second\n\nlong frameCounter = 0;\nlong averageFPS = 0;\nprivate long fps;\n\n// For converting each game world coordinate\n// into a GL space coordinate (-1,-1 to 1,1)\n// for drawing on the screen\n\nprivate final float[] viewportMatrix = new float[16];\n\n// A class to help manage our game objects\n// current state.\n\nprivate GameManager gm;\n\n// For capturing various PointF details without\n// creating new objects in the speed critical areas\n\nPointF handyPointF;\nPointF handyPointF2;\n```", "```java\npublic AsteroidsRenderer(GameManager gameManager) {\n\n     gm = gameManager;\n\n     handyPointF = new PointF();\n     handyPointF2 = new PointF();\n\n}\n```", "```java\n@Override\npublic void onSurfaceCreated(GL10 glUnused, EGLConfig config) {\n\n   // The color that will be used to clear the\n   // screen each frame in onDrawFrame()\n   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\n   // Get GLManager to compile and link the shaders into an object\n   GLManager.buildProgram();\n\n   createObjects();\n\n}\n```", "```java\n@Override\n    public void onSurfaceChanged(GL10 glUnused, int width, int height) {\n\n        // Make full screen\n        glViewport(0, 0, width, height);\n\n        /*\n            Initialize our viewport matrix by passing in the starting\n            range of the game world that will be mapped, by OpenGL to\n            the screen. We will dynamically amend this as the player\n            moves around.\n\n            The arguments to setup the viewport matrix:\n            our array,\n            starting index in array,\n            min x, max x,\n            min y, max y,\n            min z, max z)\n        */\n\n            orthoM(viewportMatrix, 0, 0, \n        gm.metresToShowX, 0, \n        gm.metresToShowY, 0f, 1f);\n}\n```", "```java\n    private void createObjects() {\n        // Create our game objects\n\n        // First the ship in the center of the map\n        gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n    }\n```", "```java\n@Override\npublic void onDrawFrame(GL10 glUnused) {\n\n        long startFrameTime = System.currentTimeMillis();\n\n        if (gm.isPlaying()) {\n            update(fps);\n        }\n\n        draw();\n\n        // Calculate the fps this frame\n        // We can then use the result to\n        // time animations and more.\n        long timeThisFrame = System.currentTimeMillis() - startFrameTime;\n        if (timeThisFrame >= 1) {\n            fps = 1000 / timeThisFrame;\n        }\n\n        // Output the average frames per second to the console\n        if (debugging) {\n            frameCounter++;\n            averageFPS = averageFPS + fps;\n            if (frameCounter > 100) {\n                averageFPS = averageFPS / frameCounter;\n                frameCounter = 0;\n                Log.e(\"averageFPS:\", \"\" + averageFPS);\n            }\n        }\n    }\n```", "```java\n    private void update(long fps) {\n\n    }\n```", "```java\nprivate void draw() {\n\n    // Where is the ship?\n    handyPointF = gm.ship.getWorldLocation();\n\n    // Modify the viewport matrix orthographic projection\n    // based on the ship location\n    orthoM(viewportMatrix, 0,\n        handyPointF.x - gm.metresToShowX / 2,\n        handyPointF.x + gm.metresToShowX / 2,\n        handyPointF.y - gm.metresToShowY / 2,\n        handyPointF.y + gm.metresToShowY / 2,\n        0f, 1f);\n\n    // Clear the screen\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Start drawing!\n\n    // Draw the ship\n    gm.ship.draw(viewportMatrix);\n}\n}\n```", "```java\nimport android.graphics.PointF;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport static android.opengl.GLES20.GL_FLOAT;\nimport static android.opengl.GLES20.GL_LINES;\nimport static android.opengl.GLES20.GL_POINTS;\nimport static android.opengl.GLES20.GL_TRIANGLES;\nimport static android.opengl.GLES20.glDrawArrays;\nimport static android.opengl.GLES20.glEnableVertexAttribArray;\nimport static android.opengl.GLES20.glGetAttribLocation;\nimport static android.opengl.GLES20.glGetUniformLocation;\nimport static android.opengl.GLES20.glUniform4f;\nimport static android.opengl.GLES20.glUniformMatrix4fv;\nimport static android.opengl.GLES20.glUseProgram;\nimport static android.opengl.Matrix.multiplyMM;\nimport static android.opengl.Matrix.setIdentityM;\nimport static android.opengl.Matrix.setRotateM;\nimport static android.opengl.Matrix.translateM;\nimport static android.opengl.GLES20.glVertexAttribPointer;\nimport static com.gamecodeschool.c9asteroids.GLManager.*;\n```", "```java\npublic class GameObject {\n\n    boolean isActive;\n\n    public enum Type {SHIP, ASTEROID, BORDER, BULLET, STAR}\n\n    private Type type;\n\n    private static int glProgram =-1;\n\n    // How many vertices does it take to make\n    // this particular game object?\n    private int numElements;\n    private int numVertices;\n\n    // To hold the coordinates of the vertices that\n    // define our GameObject model\n    private float[] modelVertices;\n\n    // Which way is the object moving and how fast?\n    private float xVelocity = 0f;\n    private float yVelocity = 0f;\n    private float speed = 0;\n    private float maxSpeed = 200;\n\n    // Where is the object centre in the game world?\n    private PointF worldLocation = new PointF();\n```", "```java\n    // This will hold our vertex data that is\n    // passed into the openGL glProgram\n    // OPenGL likes FloatBuffer\n    private FloatBuffer vertices;\n\n    // For translating each point from the model (ship, asteroid etc)\n    // to its game world coordinates\n    private final float[] modelMatrix = new float[16];\n\n    // Some more matrices for Open GL transformations\n    float[] viewportModelMatrix = new float[16];\n    float[] rotateViewportModelMatrix = new float[16];\n\n    // Where is the GameObject facing?\n    private float facingAngle = 90f;\n\n    // How fast is it rotating?\n    private float rotationRate = 0f;\n\n    // Which direction is it heading?\n    private float travellingAngle = 0f;\n\n    // How long and wide is the GameObject?\n    private float length;\n    private float width;\n```", "```java\npublic GameObject(){\n    // Only compile shaders once\n    if (glProgram == -1){\n        setGLProgram();\n\n        // tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Now we have a glProgram we need the locations\n        // of our three GLSL variables.\n        // We will use these when we call draw on the object.\n        uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);\n        aPositionLocation = glGetAttribLocation(glProgram, A_POSITION);\n        uColorLocation = glGetUniformLocation(glProgram, U_COLOR);\n    }\n\n    // Set the object as active\n    isActive = true;\n\n}\n```", "```java\npublic boolean isActive() {\n  return isActive;\n}\n\npublic void setActive(boolean isActive) {\n  this.isActive = isActive;\n}\n\npublic void setGLProgram(){\n  glProgram = GLManager.getGLProgram();\n}\n\npublic Type getType() {\n  return type;\n}\n\npublic void setType(Type t) {\n  this.type = t;\n}\n\npublic void setSize(float w, float l){\n  width = w;\n  length = l;\n\n}\n\npublic PointF getWorldLocation() {\n  return worldLocation;\n}\n\npublic void setWorldLocation(float x, float y) {\n  this.worldLocation.x = x;\n  this.worldLocation.y = y;\n}\n```", "```java\npublic void setVertices(float[] objectVertices){\n\n    modelVertices = new float[objectVertices.length];\n    modelVertices = objectVertices;\n\n    // Store how many vertices and elements there is for future use\n    numElements = modelVertices.length;\n\n    numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n    // Initialize the vertices ByteBuffer object based on the\n    // number of vertices in the ship design and the number of\n    // bytes there are in the float type\n    vertices = ByteBuffer.allocateDirect(\n            numElements\n            * FLOAT_SIZE)\n            .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n    // Add the ship into the ByteBuffer object\n    vertices.put(modelVertices);\n\n}\n```", "```java\n    public void draw(float[] viewportMatrix){\n\n        // tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Set vertices to the first byte\n        vertices.position(0);\n\n        glVertexAttribPointer(\n              aPositionLocation,\n              COMPONENTS_PER_VERTEX,\n              GL_FLOAT,\n              false,\n              STRIDE,\n              vertices);\n\n        glEnableVertexAttribArray(aPositionLocation);\n```", "```java\n    // Translate model coordinates into world coordinates\n    // Make an identity matrix to base our future calculations on\n    // Or we will get very strange results\n    setIdentityM(modelMatrix, 0);\n    // Make a translation matrix\n\n    /*\n        Parameters:\n        m   matrix\n        mOffset index into m where the matrix starts\n        x   translation factor x\n        y   translation factor y\n        z   translation factor z\n    */\n    translateM(modelMatrix, 0, worldLocation.x, worldLocation.y, 0);\n```", "```java\n   // Combine the model with the viewport\n   // into a new matrix\n   multiplyMM(viewportModelMatrix, 0, \n      viewportMatrix, 0, modelMatrix, 0);\n```", "```java\n   /*\n        Now rotate the model - just the ship model\n\n        Parameters\n        rm  returns the result\n        rmOffset    index into rm where the result matrix starts\n        a   angle to rotate in degrees\n        x   X axis component\n        y   Y axis component\n        z   Z axis component\n    */\n    setRotateM(modelMatrix, 0, facingAngle, 0, 0, 1.0f);\n\n    // And multiply the rotation matrix into the model-viewport \n    // matrix\n    multiplyMM(rotateViewportModelMatrix, 0, \n      viewportModelMatrix, 0, modelMatrix, 0);\n```", "```java\n   // Give the matrix to OpenGL\n\n    glUniformMatrix4fv(uMatrixLocation, 1, false,                                        \n    rotateViewportModelMatrix, 0);\n\n    // Assign a color to the fragment shader\n    glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f);\n```", "```java\n   // Draw the point, lines or triangle\n    switch (type){\n        case SHIP:\n        glDrawArrays(GL_TRIANGLES, 0, numVertices);\n        break;\n\n        case ASTEROID:\n        glDrawArrays(GL_LINES, 0, numVertices);\n        break;\n\n        case BORDER:\n        glDrawArrays(GL_LINES, 0, numVertices);\n        break;\n\n       case STAR:\n        glDrawArrays(GL_POINTS, 0, numVertices);\n        break;\n\n        case BULLET:\n        glDrawArrays(GL_POINTS, 0, numVertices);\n        break;\n    }\n\n} // End draw()\n\n}// End class\n```", "```java\npublic class SpaceShip extends GameObject{\n\n  public SpaceShip(float worldLocationX, float worldLocationY){\n       super();\n\n        // Make sure we know this object is a ship\n        // So the draw() method knows what type\n        // of primitive to construct from the vertices\n\n        setType(Type.SHIP);\n\n        setWorldLocation(worldLocationX,worldLocationY);\n\n        float width = 15;\n        float length = 20;\n\n        setSize(width, length);\n\n        // It will be useful to have a copy of the\n        // length and width/2 so we don't have to keep dividing by 2\n        float halfW = width / 2;\n        float halfL = length / 2;\n\n        // Define the space ship shape\n        // as a triangle from point to point\n        // in anti clockwise order\n        float [] shipVertices = new float[]{\n\n               - halfW, - halfL, 0,\n               halfW, - halfL, 0,\n               0, 0 + halfL, 0\n\n      };\n\n       setVertices(shipVertices);\n\n     }\n\n}\n```", "```java\n    private boolean playing = false;\n\n     // Our first game object\n     SpaceShip ship;\n\n         int screenWidth;\n    ```", "```java\n    private void createObjects() {\n\n      // Create our game objects\n     // First the ship in the center of the map\n     gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n    }\n    ```", "```java\n    // Start drawing!\n    // Draw the ship\n    gm.ship.draw(viewportMatrix);\n\n    ```"]