- en: Chapter 3. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 网络功能
- en: 'In this chapter, we will learn how to deal with network-related functionality
    from the native C/C++ code. Networking tasks are asynchronous by nature and unpredictable
    in terms of timing. Even when the underlying connection is established using the
    TCP protocol, there is no guarantee on the delivery time, and nothing prevents
    the applications from freezing while waiting for the data. In the Android SDK,
    this is hidden from a developer by a myriad of classes and facilities. In Android
    NDK, *au contraire*, one has the responsibility to overcome these difficulties
    without assistance from any platform-specific helpers. To develop responsive and
    safe applications, a number of problems must be solved: we need to be in full
    control of the download process, we have to limit the downloaded data size, and
    gracefully handle the errors that occur. Without delving into the details of the
    HTTP and SSL protocols implementation, we will use the libcurl and OpenSSL libraries,
    and concentrate on higher-level tasks related to application development. However,
    we will take a closer look at implementing basic asynchronous mechanisms in a
    portable way. The first few examples of this chapter are desktop-only and their
    purpose is to show how a multiplatform synchronization primitives can be implemented.
    However, at the end of this chapter, we will see how to put all these pieces together
    into a mobile application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从本地C/C++代码处理与网络相关的功能。网络任务是异步的，就时间而言是不可预测的。即使底层连接是通过TCP协议建立的，也不能保证交付时间，应用程序在等待数据时完全有可能冻结。在Android
    SDK中，这一点被大量的类和设施所隐藏。而在Android NDK中，*相反地*，你必须自己克服这些困难，没有来自任何特定平台帮助者的协助。为了开发响应迅速且安全的应用程序，必须解决许多问题：我们需要完全控制下载过程，限制下载数据的大小，并优雅地处理发生的错误。不过，我们不会深入探讨HTTP和SSL协议实现的细节，我们将使用libcurl和OpenSSL库，专注于与应用程序开发相关的高级任务。然而，我们将会更详细地了解如何以可移植的方式实现基本异步机制。本章的前几个例子仅适用于桌面，其目的是展示如何实现跨平台同步原语。但是，在本章的最后，我们将看到如何将这些部分整合到一个移动应用程序中。
- en: Intrusive smart pointers
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侵入式智能指针
- en: Tracking all native memory allocations in a multithreaded environment is notoriously
    difficult process, especially when it comes to passing objects ownership between
    different threads. In C++, memory management can be automated using smart pointers.
    The standard `std::shared_ptr` class is a good place to start with. However, we
    want to focus on more interesting and lightweight techniques. We will not use
    the Boost library either, since we really want to stay lean when it comes to compile
    times.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中跟踪所有本地内存分配是一个出了名困难的流程，特别是在涉及在不同线程间传递对象所有权时。在C++中，可以使用智能指针自动化内存管理。标准的`std::shared_ptr`类是个不错的起点。然而，我们想要关注更有趣且轻量级的技术。我们也不会使用Boost库，因为我们在编译时间上真的想要保持精简。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The recent versions of the Android NDK support the C++ 11 Standard Library in
    full. If you feel more comfortable with `std::shared_ptr` or intrusive pointers
    from Boost, feel free to use smart pointers from those libraries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的Android NDK已完全支持C++ 11标准库。如果你对`std::shared_ptr`或Boost库中的侵入式指针感到更熟悉，可以自由使用这些库中的智能指针。
- en: 'In an intrusive smart pointer, as the name suggests, a reference counter is
    embedded into the object. The simplest way to do this is by inheriting from the
    following base class:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，侵入式智能指针中，引用计数被嵌入到对象中。实现这一点的最简单方式是通过继承以下基类：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It uses a standard atomic variable to hold the value of the counter. Before
    C++ 11 Standard Library was widely adopted, a portable implementation of an atomic
    counter required platform-specific atomic operations to be used, either POSIX
    or Windows. Nowadays, it is possible to write clean code for all platforms using
    C++ 11; for Android, Windows, Linux, OS X, iOS, and even for BlackBerry 10, if
    you wish to do so. Here is how we can increment the counter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用标准原子变量来保存计数器的值。在C++ 11标准库被广泛采用之前，实现一个可移植的原子计数器需要使用特定平台的原子操作，比如POSIX或Windows。如今，使用C++
    11可以编写适用于所有平台的干净代码；无论是Android、Windows、Linux、OS X、iOS，甚至是黑莓10，如果你愿意的话。以下是我们可以如何增加计数器的示例：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is absolutely possible to use the `++` operator instead of `fetch_add()`.
    However, incrementing an atomic integer variable this way is required by the compiler
    to be sequentially consistent and may cause redundant memory barriers to be inserted
    in the generated assembly. We do not use the incremented value for any decision
    making, hence the memory barriers here are unnecessary and memory ordering can
    be relaxed, only atomicity of the variable is required. This is what `fetch_add()`
    does with the `std::memory_order_relaxed` flag, leading to a faster code on some
    non-x86 platforms. Decrement is trickier. Indeed, we have to decide when to remove
    the object, and do so only when the reference counter is decremented to zero.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `++` 运算符替代 `fetch_add()` 是完全可行的。然而，编译器要求以这种方式递增原子整数变量需要是顺序一致的，这可能在生成的汇编代码中插入冗余的内存屏障。由于我们不对递增值进行任何决策，这里的内存屏障是不必要的，可以放宽内存排序，只要求变量的原子性。这正是
    `fetch_add()` 使用 `std::memory_order_relaxed` 标志所做的，在一些非x86平台上可以生成更快的代码。递减要更复杂一些。确实，我们需要决定何时移除对象，只有在引用计数递减到零时才这样做。
- en: 'Here is the code to do it right:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确执行操作的代码：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `std::memory_order_release` flag means an operation on a memory location
    requires all previous memory writes to become visible to all threads that do an
    acquire operation on the same location. After entering the `if` block, we will
    do the acquire operation by inserting an appropriate memory barrier:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::memory_order_release` 标志意味着对内存位置的运算需要所有先前的内存写入对所有执行相同位置获取操作的线程可见。进入 `if`
    块后，我们将通过插入适当的内存屏障来执行获取操作：'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Only after this point, we can now allow the object to commit suicide:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，我们现在可以允许对象执行自杀操作：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `delete this` idiom is explained at [https://isocpp.org/wiki/faq/freestore-mgmt#delete-this](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete this` 习惯用法在 [https://isocpp.org/wiki/faq/freestore-mgmt#delete-this](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)
    有解释。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `iIntrusiveCounter` class is the core of our reference-counting mechanism.
    The code may look very simple; however, the logic behind this implementation is
    much more complicated than it seems. Refer to the *C++ and Beyond 2012: Herb Sutter
    - atomic<> Weapons, 1 of 2* talk by Herb Sutter for all the elaborate details:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`iIntrusiveCounter` 类是我们引用计数机制的核心。代码可能看起来非常简单；然而，这个实现的背后逻辑比看起来要复杂得多。有关所有详细细节，请参考
    Herb Sutter 的 *C++ and Beyond 2012: Herb Sutter - atomic<> Weapons, 1 of 2* 演讲：'
- en: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2)'
- en: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2)'
- en: 'Now, we can implement a lightweight RAII generic smart pointer class, which
    utilizes our freshly written counter base class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个轻量级的RAII泛型智能指针类，它使用我们刚刚编写的计数器基类：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, a copy constructor does not call the `FObject->IncRefCount()` method
    directly. Instead, it invokes a helper function `LPtr::IncRef()`, which accepts
    `void*` and passes the object as a parameter to that function. This is done to
    allow usage of our intrusive smart pointer with classes that were declared but
    not yet defined:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，复制构造函数没有直接调用 `FObject->IncRefCount()` 方法。而是调用一个辅助函数 `LPtr::IncRef()`，它接受
    `void*` 并将对象作为参数传递给该函数。这样做是为了允许我们的侵入式智能指针与那些已声明但尚未定义的类一起使用：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The implicit constructor from `T*` is useful:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `T*` 的隐式构造函数很有用：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similar to the constructor, the destructor uses a helper function to decrement
    the reference counter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数类似，析构函数使用辅助函数来递减引用计数：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A couple of named helper functions can be of use to check the state of the
    smart pointer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 若干个命名辅助函数可用于检查智能指针的状态：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assignment is quite slow compared to other methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他方法相比，赋值运算相当慢：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But not the `move` assignment operator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不包括 `move` 赋值运算符：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `->` operator is essential for every smart pointer class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 运算符对于每个智能指针类都是必不可少的：'
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And here is a bit tricky one: an automatic type conversion operator to an instance
    of the private class `clProtector`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有点棘手的问题：一个自动类型转换运算符，用于将智能指针转换为私有类 `clProtector` 的实例：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This type conversion is used to allow safe null-pointer checks as in `if (
    clPtr )` to be possible. It is safe because you cannot do anything with the resulting
    pointer. The inner private class `clProtector` does not implement the `delete()`
    operator, hence, using it will produce a compilation error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型转换用于允许像`if ( clPtr )`这样的安全空指针检查。这是安全的，因为您不能对生成的指针执行任何操作。内部的私有类`clProtector`没有实现`delete()`运算符，因此使用它将产生编译错误：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The source code bundle of this book does not use the `= delete` C++ 11 notation
    for the deleted function, but just leaves it unimplemented. This is done for the
    sake of compatibility with older compilers. If you target the most recent versions
    of GCC/Clang and Visual Studio, going with `= delete` will be just fine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的源代码包没有使用C++ 11的`= delete`表示法来删除函数，只是让它未实现。这是为了与旧编译器保持兼容性。如果你针对的是最新版本的GCC/Clang和Visual
    Studio，使用`= delete`将是非常好的。
- en: 'Let''s return to our `clPtr` class. Unfortunately, the standard `dynamic_cast<>`
    operator cannot be used in the original way, so we need to make a substitution:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`clPtr`类。不幸的是，标准`dynamic_cast<>`运算符不能以原始方式使用，因此我们需要进行替换：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the only thing where our smart pointer will be different in syntax
    from raw pointers. Also, we need a set of comparison operators to make our class
    more useful within different containers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的智能指针在语法上与原始指针唯一不同的地方。此外，我们需要一组比较运算符，以使我们的类在不同的容器中更有用：
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a function to abridge the smart pointer with APIs accepting raw pointers.
    The conversion to the underling `T*` type should be explicit:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，用于简化智能指针与接受原始指针的API之间的连接。到基础`T*`类型的转换应该是显式的：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some helper functions may be useful when dealing with low-level pointer fuss.
    Drop the object, do not deallocate it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理低级指针问题时，一些辅助函数可能很有用。删除对象，不要释放它：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Clear the object, decrement the reference counter, similar to assigning `nullptr`
    to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清除对象，减少引用计数，类似于将其赋值为`nullptr`：
- en: '[PRE19]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last but not least, the pointer itself:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，指针本身：
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Henceforth, our portable intrusive smart pointer is self-contained and can
    be used in real applications. There is one more thing left to be done, a kind
    of syntactic sugar. It is typical of C++ 11 to use the `auto` keyword, so one
    can write the type name in the expression only once. However, the following instantiation
    will not work because the deduced type of `p` will be `clSomeObject*` when we
    wanted it to be `clPtr< clSomeObject>`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从此，我们可移植的侵入式智能指针是自包含的，可以用于实际应用中。还有一件事要做，那就是一种语法糖。C++ 11典型的使用`auto`关键字，这样可以在表达式中只写一次类型名称。但是，下面的实例化将不起作用，因为当我们希望`p`的类型是`clPtr<
    clSomeObject>`时，推导出的`p`的类型将是`clSomeObject*`：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With standard shared pointers, this is solved using a `std::make_shared()`
    template helper function, which returns the proper type (and does some useful
    optimization of the counter storage behind the scenes):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准共享指针时，通过使用`std::make_shared()`模板辅助函数来解决此问题，该函数返回正确的类型（并在幕后进行一些有用的计数器存储优化）：
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, the deduced type of `p` is `std::shared_ptr<clSomeObject>`, which ultimately
    matches our expectations. We can create a similar helper using the perfect forwarding
    mechanism provided by C++ 11 and the `std::forward()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`p`的推导类型是`std::shared_ptr<clSomeObject>`，最终符合我们的预期。我们可以使用C++ 11提供的完美转发机制和`std::forward()`函数创建一个类似的辅助函数：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The usage is C++11-stylish and natural:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法是C++11风格的，很自然：
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete source code for the smart pointer can be found in the `1_IntrusivePtr`
    example. Now, we can proceed further and use this class as the cornerstone of
    our multithreaded memory management.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针的完整源代码可以在`1_IntrusivePtr`示例中找到。现在，我们可以进一步使用这个类作为我们多线程内存管理的基石。
- en: Portable multithreading primitives
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植的多线程原语
- en: 'The long-awaited `std::thread` from the C++11 standard is not (yet) available
    in MinGW toolchain at the time of writing, and it does not possess capabilities
    necessary to adjust thread priorities, which is important for networking. So,
    we implement a simple class `iThread` with the virtual method `Run()` to allow
    portable multithreading in our code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，C++11标准中期待已久的`std::thread`在MinGW工具链中尚不可用，并且它不具备调整线程优先级的能力，这对于网络来说很重要。因此，我们实现了一个简单的类`iThread`，带有虚拟方法`Run()`，以允许在我们的代码中进行可移植的多线程：
- en: '[PRE25]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'An internal `LPriority` enumeration defines thread priority classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 内部`LPriority`枚举定义了线程优先级类：
- en: '[PRE26]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code for constructor and destructor is simple:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数的代码很简单：
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Start()` method creates an OS-specific thread handle and starts execution.
    In all of the samples for this book, we do not need to postpone thread execution;
    we just call `_beginthreadex()` and `pthread_create()` system routines with default
    parameters. The `EntryPoint()` method is defined later:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法创建一个特定于操作系统的线程句柄并开始执行。在这本书的所有示例中，我们不需要推迟线程执行；我们只需使用默认参数调用`_beginthreadex()`和`pthread_create()`系统例程。`EntryPoint()`方法稍后定义：'
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The system-dependent thread handle and the Boolean atomic variable, which indicates
    whether this thread should stop its execution, are declared in the private section
    of the class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 系统相关的线程句柄和布尔原子变量（指示此线程是否应停止执行）在类的私有部分中声明：
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The native threading API supports only C functions, therefore we have to declare
    a static wrapper method `EntryPoint()`, which converts its `void*` parameter to
    `iThread` and calls the `Run()` method of the class. The calling convention and
    result type for the thread function differs on POSIX and Windows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本地线程API仅支持C函数，因此我们必须声明一个静态包装方法`EntryPoint()`，该方法将`void*`参数转换为`iThread`并调用类的`Run()`方法。线程函数的调用约定和结果类型在POSIX和Windows上有所不同：
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The protected section defines the `Run()` and `NotifyExit()` virtual methods,
    which are overridden in subclasses. The `GetHandle()` method allows subclasses
    to access the platform-specific thread handle:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的部分定义了`Run()`和`NotifyExit()`虚拟方法，这些方法在子类中被重写。`GetHandle()`方法允许子类访问特定平台的线程句柄：
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To stop the thread, we will raise the `FPendingExit` flag and call the `NotifyExit()`
    method to inform the thread owner. An optional `Wait` parameter forces the method
    to wait for actual termination of the thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止线程，我们将设置`FPendingExit`标志并调用`NotifyExit()`方法通知线程所有者。可选的`Wait`参数强制该方法等待线程的实际终止：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We must ensure `Exit()` is not called from the `Run()` method of the same thread
    to avoid deadlocks, so we will call `GetCurrentThread()` and compare the result
    with our own handle:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保`Exit()`不要从同一线程的`Run()`方法中调用，以避免死锁，因此我们将调用`GetCurrentThread()`并将结果与我们的句柄进行比较：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For Windows, we will mimic the `join` operation by calling `WaitForSingleObject()`
    and then terminating the thread via `CloseHandle()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，我们将通过调用`WaitForSingleObject()`来模拟`join`操作，然后通过`CloseHandle()`终止线程：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `GetCurrentThread()` method on Android is implemented slightly different
    from a typical POSIX version. Hence, this method contains a triple `#ifdef` clause:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，`GetCurrentThread()`方法的实现与典型的POSIX版本略有不同。因此，这个方法包含了一个三重的`#ifdef`子句：
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `EntryPoint()` method is the glue that ties together our object-oriented
    `iThread` wrapper class and the platform-specific C-style threading API:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntryPoint()`方法是将我们面向对象的`iThread`包装类与特定平台的C风格线程API联系在一起的粘合剂：'
- en: '[PRE36]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The finishing touch is the `SetPriority()` method that is used to control the
    amount of CPU time given for the thread. For Windows, the main part of the method
    is the conversion of our `LPriority` enumeration to the numerical value defined
    in the `windows.h` header file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个细节是`SetPriority()`方法，该方法用于控制线程的CPU时间分配。在Windows中，该方法的主要部分是将我们的`LPriority`枚举转换为`windows.h`头文件中定义的数值：
- en: '[PRE37]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For POSIX, we rescale our priority value to the integer number between minimum
    and maximum priorities available in the OS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于POSIX，我们将我们的优先级值重新缩放到操作系统中可用的最小和最大优先级之间的整数：
- en: '[PRE38]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we can use the `iThread` class to construct more useful higher-level threading
    primitives. For cross-platform lightweight implementation of the `std::mutex`-like
    object, we will use the TinyThread library by Marcus Geelnard, which is available
    for download at [http://tinythreadpp.bitsnbites.eu](http://tinythreadpp.bitsnbites.eu).
    However, feel free to use the standard mutex if you do not have to be compatible
    with legacy compilers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`iThread`类来构建更有用的高级线程原语。为了实现类似`std::mutex`的跨平台轻量级对象，我们将使用Marcus Geelnard的TinyThread库，该库可以在[http://tinythreadpp.bitsnbites.eu](http://tinythreadpp.bitsnbites.eu)下载。但是，如果你不需要与旧编译器兼容，也可以自由使用标准互斥锁。
- en: Let's proceed with the task queues.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理任务队列。
- en: Task queues
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务队列
- en: 'To process a logical piece of work, we will declare the `iTask` class with
    the `Run()` method, which can perform a time-consuming operation. The declaration
    of the class is somewhat visually similar to `iThread`. However, its instances
    implement some reasonably short operation and may be executed in different threads:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理逻辑工作单元，我们将声明具有`Run()`方法的`iTask`类，该方法可以执行耗时的操作。类的声明在视觉上与`iThread`有些相似。然而，其实例实现了一些相对简短的操作，并且可以在不同的线程中执行：
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The pure virtual method `Run()` should be overridden in subclasses to do the
    actual work:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚方法`Run()`应该在子类中被重写以执行实际工作：
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following methods optionally cancel the task and are similar to the ones
    in the `iThread` class. Their purpose is to signal the hosting thread that this
    task should be cancelled:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的方法可选择性地取消任务，与`iThread`类中的方法类似。它们的作用是通知宿主线程应取消此任务：
- en: '[PRE41]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `GetTaskID()` and `SetTaskID()` methods access the internal unique identifier
    of the task, which is used to cancel execution:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetTaskID()`和`SetTaskID()`方法访问任务的内部唯一标识符，用于取消执行：'
- en: '[PRE42]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `GetPriority()` and `SetPriority()` methods are used by the task scheduler
    to determine the order in which the tasks are executed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPriority()`和`SetPriority()`方法由任务调度程序使用，以确定执行任务的顺序：'
- en: '[PRE43]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The private part of the class contains an atomic exit flag, the task ID value,
    and task priority:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有部分包含一个原子退出标志，任务ID值和任务优先级：
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The management of the tasks is done by the `clWorkerThread` class. Basically,
    it is a collection of `iTask` instances, which is fed using the `AddTask()` method.
    The private part of the class contains `std::list` of `iTask`s and a few synchronization
    primitives:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的管理由`clWorkerThread`类完成。基本上，它是一组`iTask`实例的集合，通过`AddTask()`方法进行输入。类的私有部分包含`iTask`的`std::list`和几个同步基元：
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `FCurrentTask` field is used internally to keep track of the task, which
    is in progress. The `FTasksMutex` field is a mutex to ensure thread-safe access
    to `FPendingTasks`. The `FCondition` conditional variable is used to signal the
    availability of tasks in the list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`FCurrentTask`字段在内部用于跟踪正在进行的任务。`FTasksMutex`字段是一个互斥锁，用于确保对`FPendingTasks`的线程安全访问。`FCondition`条件变量用于通知列表中任务的可可用性。'
- en: 'The `AddTask()` method inserts a new task to the list and notifies the `Run`
    method about the task availability:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTask()`方法将新任务插入列表中，并通知`Run`方法任务已可用：'
- en: '[PRE46]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To check whether there are unfinished tasks, we will define the `GetQueueSize()`
    method. The method uses the `std::list.size()` and increments the returned value
    if there is an active task currently running:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查是否有未完成的任务，我们将定义`GetQueueSize()`方法。该方法使用`std::list.size()`，并在当前有活动任务正在运行时增加返回的值：
- en: '[PRE47]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is the `CancelTask()` method to cancel a single task and the `CancelAll()`
    method to cancel all of the tasks at once:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`CancelTask()`方法来取消单个任务，以及一个`CancelAll()`方法来一次性取消所有任务：
- en: '[PRE48]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'First, we check whether a task is running and its ID matched with the one we
    want to cancel:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否有正在运行的任务，并且其ID与我们想要取消的ID匹配：
- en: '[PRE49]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we will iterate the list of tasks and request exit for the one with the
    given ID, removing them from the list of pending tasks. This can be done using
    a simple lambda:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历任务列表，并请求给定ID的任务退出，从待处理任务列表中移除它们。这可以通过使用简单的lambda表达式来完成：
- en: '[PRE50]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we notify everyone about the list change:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通知所有人列表已更改：
- en: '[PRE51]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `CancelAll()` method is much simpler. The task list is iterated and every
    item is requested to terminate; after this, the container is cleared and a notification
    is sent:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancelAll()`方法要简单得多。迭代任务列表，请求每个项目终止；这之后，清空容器并发送通知：'
- en: '[PRE52]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The main work is done in the `Run()` method, which waits for a next task to
    arrive and executes it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作在`Run()`方法中完成，该方法等待下一个任务到达并执行它：
- en: '[PRE53]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The outer loop checks whether we need to stop this worker thread using the
    `iThread::IsPendingExit()` routine:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环使用`iThread::IsPendingExit()`例程检查我们是否需要停止这个工作线程：
- en: '[PRE54]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `ExtractTask()` method extracts the next task from the list. It waits on
    the conditional variable until the task is actually available:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractTask()`方法从列表中提取下一个任务。它会等待条件变量直到任务实际可用：'
- en: '[PRE55]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the task is valid and its cancellation is not requested, we can start the
    task:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务有效且未请求取消，我们可以开始执行任务：
- en: '[PRE56]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After the task has completed its work, we will clear the state to ensure the
    correct `GetQueueSize()` operation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成工作后，我们将清除状态以确保正确的`GetQueueSize()`操作：
- en: '[PRE57]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `ExtractTask()` method implements a thread-safe linear search in the `FPendingTasks`
    list to select the `iTask` instance with the highest priority:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtractTask()`方法在`FPendingTasks`列表中实现了一个线程安全的线性搜索，以选择具有最高优先级的`iTask`实例：'
- en: '[PRE58]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To avoid doing spinlock and burning CPU cycles, the conditional variable is
    checked:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免进行忙等（spinlock）并耗尽CPU周期，将检查条件变量：
- en: '[PRE59]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the list is empty, the empty smartpointer is returned:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空，将返回空智能指针：
- en: '[PRE60]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Best` variable stores the selected task to be executed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Best`变量存储了要执行的选择任务：'
- en: '[PRE61]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Iterating over the `FPendingTask` list and comparing the priority value to
    the one in the `Best` variable, we will select the task:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历`FPendingTask`列表，并将优先级值与`Best`变量中的值进行比较，我们将选择任务：
- en: '[PRE62]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we will erase the selected task from the container and return the
    result. A temporary variable is needed to ensure our smartpointer does not decrement
    the reference count to zero:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从容器中删除选定的任务并返回结果。需要临时变量以确保我们的智能指针不会将引用计数减为零：
- en: '[PRE63]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, we have the class to handle asynchronous tasks. There is one more crucial
    thing to be done before we can proceed with the actual asynchronous networking—asynchronous
    callbacks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了处理异步任务的类。在我们可以继续实际的异步网络连接——异步回调之前，还有一件至关重要的事情要做。
- en: Message pumps and asynchronous callbacks
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息泵和异步回调
- en: In the previous section, we defined `clWorkerThread` and `iTask` classes that
    allow us to execute lengthy operations outside of the UI thread in C++ code. The
    final thing we need to organize a responsive interface is the ability to pass
    around events across different threads. To do this, we need a callable interface,
    which can encapsulate the parameters passed to a method, and a thread-safe mechanism
    to pass such capsules across the threads.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们定义了`clWorkerThread`和`iTask`类，它们允许我们在C++代码中在UI线程之外执行耗时操作。为了组织一个响应式界面，我们最后需要的能力是在不同线程之间传递事件。为此，我们需要一个可调用的接口，它可以封装传递给方法的参数，以及一个线程安全的机制来传递这样的胶囊。
- en: 'A nice candidate for such a capsule is `std::packaged_task`, which is not supported
    in the most recent MinGW toolchain. Therefore, we will define our own lightweight
    reference-counted abstract class `iAsyncCapsule`, which implements a single method,
    `Invoke()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的候选胶囊是`std::packaged_task`，但它在最新的MinGW工具链中不受支持。因此，我们将定义自己的轻量级引用计数抽象类`iAsyncCapsule`，它实现了一个单一的方法，`Invoke()`：
- en: '[PRE64]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We call a prioritized collection of `iAsyncCapsule` instances wrapped in `clPtr`
    an *asynchronous queue*. The `clAsyncQueue` class implements the `DemultiplexEvents()`
    method, which will be called in the thread that does the processing of incoming
    events.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包裹在`clPtr`中的`iAsyncCapsule`实例的优先级集合称为*异步队列*。`clAsyncQueue`类实现了`DemultiplexEvents()`方法，该方法将在处理传入事件的线程中调用。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is called the reactor pattern. It's documentation can be found at [http://en.wikipedia.org/wiki/Reactor_pattern](http://en.wikipedia.org/wiki/Reactor_pattern).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为反应器模式。其文档可以在[http://en.wikipedia.org/wiki/Reactor_pattern](http://en.wikipedia.org/wiki/Reactor_pattern)找到。
- en: The demultiplexing consists of invoking all the accumulated `iAsyncCapsule`s
    that are added from the other threads by the `EnqueueCapsule()` method. Both methods
    should be and are thread-safe. However, `DemultiplexEvents()` is not reentrant
    in the sense that no two threads should invoke `DemultiplexEvents()` on the same
    object. This limitation is a part of performance optimization, which we will see
    further. We use two containers of `iAsyncCapsule`s and switch between them at
    each call of `DemultiplexEvents()`. This allows faster `EnqueueCapsule()` execution
    because we don't have to copy the contents of the queue to ensure thread-safety.
    Otherwise, a copy would be necessary because we should not call `Invoke()` while
    the mutex is locked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解复用包括调用所有通过`EnqueueCapsule()`方法从其他线程添加的累积`iAsyncCapsule`。这两种方法应该是线程安全的，实际上也是。然而，`DemultiplexEvents()`在意义上不是可重入的，也就是说，两个线程不应当对同一对象调用`DemultiplexEvents()`。这一限制是性能优化的一部分，我们将在后面看到。我们使用两个`iAsyncCapsule`容器，并在每次调用`DemultiplexEvents()`时切换它们。这使得`EnqueueCapsule()`执行更快，因为我们不需要复制队列内容以确保线程安全。否则，由于在互斥锁锁定时我们不应该调用`Invoke()`，所以进行复制是必要的。
- en: 'The private section of the class contains the index of the current queue in
    use `FCurrentQueue`, two containers of `iAsyncCapsule`s, a pointer to the current
    queue, and a mutex to prevent simultaneous access to the `FAsyncQueues` array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有部分包含当前使用的队列索引`FCurrentQueue`，两个`iAsyncCapsule`容器，指向当前队列的指针以及用于防止同时访问`FAsyncQueues`数组的互斥锁：
- en: '[PRE65]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Constructor initializes the current queue pointer and the index:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化当前队列指针和索引：
- en: '[PRE66]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `EnqueueCapsule()` method is similar to `WorkerThread::AddTask()`. First,
    we create a scoped `lock_guard` object, and then call `push_back()` to enqueue
    the `iAsyncCapsule` object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnqueueCapsule()`方法与`WorkerThread::AddTask()`类似。首先，我们创建一个作用域内的`lock_guard`对象，然后调用`push_back()`以将`iAsyncCapsule`对象入队：'
- en: '[PRE67]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `DemultiplexEvents()` method saves the reference to the current queue:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemultiplexEvents()`方法保存对当前队列的引用：'
- en: '[PRE68]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`DemultiplexEvents()` is designed to run only on one thread. No locking is
    needed at this point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemultiplexEvents()`被设计为只在单个线程上运行。此时不需要加锁：'
- en: '[PRE69]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, the current queue pointer is swapped. This is an atomic operation, so
    we use lock the mutex to prevent access to the `FAsyncQueue` pointer and the index:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，交换当前队列指针。这是一个原子操作，因此我们使用互斥锁来防止访问`FAsyncQueue`指针和索引：
- en: '[PRE70]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, each and every `iAsyncCapsule` in the current queue is invoked and
    the `LocalQueue` is cleared:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当前队列中的每个`iAsyncCapsule`都会被调用，并且`LocalQueue`会被清空：
- en: '[PRE71]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The typical usage scenario is posting callbacks from one thread to another.
    A small sample considered here uses the `clResponseThread` class with an endless
    loop as the main thread:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的使用场景是在一个线程向另一个线程发布回调。这里考虑的一个小示例使用了`clResponseThread`类，该类有一个无尽循环作为主线程：
- en: '[PRE72]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The sample `clRequestThread` class is producing events twice per second:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例`clRequestThread`类每秒产生两次事件：
- en: '[PRE73]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The test call just prints out a message with the `clTestCall` ID:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试调用仅打印带有`clTestCall` ID的消息：
- en: '[PRE74]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the `main()` function, we create both threads and start an infinite loop:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们创建两个线程并开始一个无限循环：
- en: '[PRE75]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the following section, we will use a similar approach to inform the main
    thread of the download result. The `clResponseThread` class becomes the UI thread
    and `clRequestThread` is a `WorkerThread` method where each of executed download
    tasks fires an event once the download is finished.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用类似的方法通知主线程下载结果。`clResponseThread`类成为UI线程，而`clRequestThread`是一个`WorkerThread`方法，其中每个执行的下载任务一旦下载完成就会触发一个事件。
- en: Asynchronous networking with libcurl
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用libcurl进行异步网络操作
- en: The simplistic usage of libcurl was shown in [Chapter 2](part0024.xhtml#aid-MSDG2
    "Chapter 2. Native Libraries"), *Native Libraries*. Now, we extend the code using
    the previously mentioned multithreading primitives to allow asynchronous downloads.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0024.xhtml#aid-MSDG2 "第2章. 本地库") *本地库* 中展示了libcurl的简单使用。现在，我们使用之前提到的多线程原语来扩展代码，以允许异步下载。
- en: 'The `clDownloadTask` class introduced here keeps track of the download process
    and invokes a callback when the process completes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入的`clDownloadTask`类跟踪下载过程，并在过程完成时调用回调函数：
- en: '[PRE76]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The constructor accepts URL of the resource to download, a unique task identifier,
    a callback, and a pointer to the instance of the downer:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受要下载资源的URL、唯一的任务标识符、回调函数以及指向downer实例的指针：
- en: '[PRE77]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We will focus on the `Run()`, `Progress()`, and `InvokeCallback()` methods,
    as they form the main logic of this class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注`Run()`、`Progress()`和`InvokeCallback()`方法，因为它们构成了此类的主要逻辑：
- en: '[PRE78]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `Run()` method runs on the download thread; it initializes and performs
    the actual downloading of the resource using libcurl:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()`方法在下载线程上运行；它初始化并使用libcurl实际执行资源的下载：'
- en: '[PRE79]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This hard reference is required to prevent external destruction of the task
    if it is cancelled:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此硬引用是必需的，以防止任务在外部被销毁（如果任务被取消）：
- en: '[PRE80]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The initialization of libcurl goes here. All possible parameters can be found
    in the official documentation at [http://curl.haxx.se/libcurl/c/curl_easy_setopt.html](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl的初始化代码在这里。所有可能的参数可以在官方文档中找到，地址为[http://curl.haxx.se/libcurl/c/curl_easy_setopt.html](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)：
- en: '[PRE81]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following line sets the number of seconds to wait while trying to connect.
    Use the value of zero to wait indefinitely:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行设置尝试连接时要等待的秒数。使用零值表示无限期等待：
- en: '[PRE82]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here we set the maximal number of seconds to allow libcurl functions to execute:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置允许libcurl函数执行的最大秒数：
- en: '[PRE83]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Disable verification of certificates by OpenSSL, this will enable access to
    sites with self-signed certificates. However, you may want to remove this mode
    in the production code to reduce the possibility of man-in-the-middle attacks:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用OpenSSL对证书的验证，这将允许访问具有自签名证书的站点。然而，在生产代码中，你可能想要删除此模式，以减少中间人攻击的可能性：
- en: '[PRE84]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When negotiating an SSL connection, the server sends a certificate indicating
    its identity. Curl verifies whether the certificate is authentic—that is, that
    you can trust that the server is who the certificate says it is. This trust is
    based on a chain of digital signatures, rooted in certification authority (CA)
    certificates you supply.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在协商SSL连接时，服务器会发送一个证书来标识其身份。Curl验证证书是否真实——也就是说，你可以信任服务器就是证书所说的那个实体。这种信任基于一系列数字签名，根植于你提供的认证机构（CA）证书。
- en: 'You can find the documentation at the following URLs:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL找到文档：
- en: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html)'
- en: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html)'
- en: 'Perform the actual download:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 执行实际下载：
- en: '[PRE85]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let the downloader deal with the results of this task. We will follow this
    code shortly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让下载器处理此任务的结果。我们很快就会跟随这段代码：
- en: '[PRE86]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The private `InvokeCallback()` member function is accessible from the friend
    class `clDownloader`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`InvokeCallback()`成员函数可以被友类`clDownloader`访问：
- en: '[PRE87]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Per se, this is just a `FCallback->Invoke()` invocation augmented with two
    runtime checks. The first one checks whether the task is not cancelled:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这只是对`FCallback->Invoke()`的调用，并增加了两个运行时检查。第一个检查任务是是否没有被取消：
- en: '[PRE88]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The second one checks the availability of the callback and prepared all the
    parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查回调的可用性并准备所有参数：
- en: '[PRE89]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It is important to notice the callback invocation is done while the mutex is
    locked. Doing so is essential to ensure the correct cancellation behavior. However,
    `InvokeCallback()` is not called directly from `clDownloadTask`. Instead, there
    is an indirection via the `FDownloader->CompleteTask( this )` called from the
    `Run()` method. Let''s see what is inside of it and look at the guts of the `clDownloader`
    class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，回调的调用是在互斥锁锁定的情况下进行的。这样做是为了确保正确的取消行为。然而，`InvokeCallback()`并不是直接从`clDownloadTask`中调用的。相反，是通过`Run()`方法中的`FDownloader->CompleteTask(
    this )`进行间接调用。让我们看看它里面的内容，以及`clDownloader`类的核心部分：
- en: '[PRE90]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This method is the most important part of our public downloading API:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是我们公共下载API最重要的部分：
- en: '[PRE91]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And this one handles the indirection:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是处理间接调用的代码：
- en: '[PRE92]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is the thread where `clDownloadTask`s are run:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在其中运行`clDownloadTask`的线程：
- en: '[PRE93]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'An external event queue is initialized using the constructor parameter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事件队列通过构造函数参数进行初始化：
- en: '[PRE94]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Though, the `DownloadURL()` method is crucial, its implementation is surprisingly
    simple:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`DownloadURL()`方法是关键的，其实现却出奇地简单：
- en: '[PRE95]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Indeed, all the hard work is done inside the aforementioned method `clDownloadTask::Run()`.
    Here, we just enqueued a newly constructed task into the worker thread. The most
    interesting thing happens inside `CompleteTask()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有繁重的工作都是在前面提到的方法`clDownloadTask::Run()`中完成的。在这里，我们只是将新构建的任务排入工作线程队列中。最有趣的事情发生在`CompleteTask()`内部：
- en: '[PRE96]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here, a callback wrapper is inserted into the event queue:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个回调包装器被插入到事件队列中：
- en: '[PRE97]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The helper class calls the very `FTask->InvokeCallback()` method. Remember,
    the method is invoked on the right thread, it was dispatched by the event queue:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类调用了`FTask->InvokeCallback()`方法。记住，该方法是在正确的线程上被调用的，它是由事件队列分派的：
- en: '[PRE98]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The usage sample can be found in the `3_Downloader` folder of the source code
    bundle. It is as simple as this snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例可以在源代码包的`3_Downloader`文件夹中找到。它就像这段代码一样简单：
- en: '[PRE99]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This queue will handle download results:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个队列将处理下载结果：
- en: '[PRE100]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `clTestCallback` class prints downloading progress and saves results to
    a file, `.zip` in our example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`clTestCallback`类打印下载进度并将结果保存到文件中，在我们的示例中是一个`.zip`文件。'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use the `LUrlParser` library to extract the file name from a given URL, [https://github.com/corporateshark/LUrlParser](https://github.com/corporateshark/LUrlParser).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`LUrlParser`库从给定的URL中提取文件名，[https://github.com/corporateshark/LUrlParser](https://github.com/corporateshark/LUrlParser)。
- en: The sample code can be compiled using MinGW by typing `make all`. The same code
    can be run on Android without changes using the compiled Curl library from [Chapter
    2](part0024.xhtml#aid-MSDG2 "Chapter 2. Native Libraries"), *Native Libraries*.
    We suggest that you experiment with this code on Android and play with some downloads
    directly from the C++ code.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以通过输入 `make all` 使用MinGW编译。同样的代码可以在Android上运行，无需更改，使用从[第2章](part0024.xhtml#aid-MSDG2
    "第2章。原生库")，*原生库*编译的Curl库。我们建议您在Android上尝试此代码，并直接从C++代码进行一些下载操作。
- en: Android licensing in native applications
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生应用中的Android授权
- en: The major part of this chapter has been dedicated to low-level networking capabilities
    in C++, which are crucial to writing multiplatform code. However, it would not
    be fair to omit some Android-specific things from this chapter. Let's go with
    licensing mechanism and learn how to move it into the C++ code. For this one,
    we will need to interact with Java code heavily, since all the licensing facilities
    are Java-only.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容已经致力于C++中的低级网络功能，这对于编写多平台代码至关重要。然而，在本章中省略一些Android特定的事项是不公平的。让我们通过授权机制来学习如何将其移入C++代码。为此，我们将需要大量与Java代码交互，因为所有授权功能都是Java独有的。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here, we assume that you are already familiar with how to do the license checking
    in Java. The official Google documentation can be found here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设您已经熟悉如何在Java中进行授权检查。官方Google文档可以在这里找到：
- en: '[http://developer.android.com/google/play/licensing/setting-up.html](http://developer.android.com/google/play/licensing/setting-up.html)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/google/play/licensing/setting-up.html](http://developer.android.com/google/play/licensing/setting-up.html)'
- en: '[http://developer.android.com/google/play/licensing/adding-licensing.html](http://developer.android.com/google/play/licensing/adding-licensing.html)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/google/play/licensing/adding-licensing.html](http://developer.android.com/google/play/licensing/adding-licensing.html)'
- en: 'The source code of this sample is located in the `4_Licensing` folder. First,
    let''s define the basic constants, the values should match those from the Android
    SDK. See the `License.h` file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的源代码位于 `4_Licensing` 文件夹中。首先，让我们定义基本常量，这些值应该与Android SDK中的匹配。请查看 `License.h`
    文件：
- en: '[PRE101]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, `Callbacks.h` declares callbacks invoked from the license-checker:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Callbacks.h` 声明了从授权检查器调用的回调：
- en: '[PRE102]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The main source file contains the implementations of those callbacks:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 主源文件包含那些回调的实现：
- en: '[PRE103]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here, terminate the application only if we are truly unlicensed:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有当我们确实未获得授权时才终止应用程序：
- en: '[PRE104]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let''s dive deeper into JNI and Java code to see how these callbacks are invoked.
    The `LicenseChecker.cpp` file contains a one-to-one mapping of static Java methods
    to the previously mentioned callbacks:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到JNI和Java代码中，看看这些回调是如何被调用的。`LicenseChecker.cpp` 文件包含了对前面提到的回调的静态Java方法的一对一映射：
- en: '[PRE105]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We follow the code into the `AppActivity.java` file, which declares `CheckLicense()`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟随代码进入 `AppActivity.java` 文件，该文件声明了 `CheckLicense()`：
- en: '[PRE106]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Construct the `LicenseCheckerCallback` object. The Google licensing library
    invokes it once done:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 `LicenseCheckerCallback` 对象。Google授权库在完成后会调用它：
- en: '[PRE107]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Construct `LicenseChecker` with `Policy`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Policy` 构造 `LicenseChecker`：
- en: '[PRE108]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The Java side of the callbacks is right here, at the bottom of the class declaration:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的Java部分就在这里，位于类声明的底部：
- en: '[PRE109]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `AppLicenseChecker` class just calls these static methods to route the
    events to JNI code. How simple! Now, you can handle (and test) the reaction to
    license checking events in C++ code in a portable way. Build the sample for Android
    with the following commands and see for yourself:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppLicenseChecker` 类只是调用这些静态方法，将事件路由到JNI代码。多么简单！现在，您可以在C++代码中以可移植的方式处理（和测试）对授权检查事件的反应。使用以下命令为Android构建示例，亲自看看吧：'
- en: '[PRE110]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The runtime logs can be accessed via `logcat`. The desktop version is buildable
    via the `make all` command as all the samples in this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时日志可以通过 `logcat` 访问。桌面版本可以通过 `make all` 命令构建，正如本书中的所有示例一样。
- en: Flurry analytics
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flurry分析
- en: Let's touch one more Java-related thing and its binding to the native C++ code.
    Flurry.com is a popular in-app analytics service. Determination of the most used
    features in your app is accomplished by sending information to Flurry.com and
    later accessing gathered statistics on their web pages.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再接触一个与Java相关的事项及其与原生C++代码的绑定。Flurry.com是一个流行的应用内分析服务。通过向Flurry.com发送信息，可以完成对应用中最常用功能的确定，之后可以通过他们的网页访问收集到的统计数据。
- en: 'For example, you have several options in your application such as the different
    game modes: campaign, single level, or online. User selects one of the modes and
    an event is generated and sent to Flurry.com. We want to send those events from
    our C++ code.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的应用程序中有几种不同的游戏模式选项：战役、单级别或在线。用户选择其中一种模式，就会生成并发送一个事件到Flurry.com。我们希望从C++代码发送这些事件。
- en: 'Check out the sample application in the `5_Flurry` folder. The `main.cpp` file
    contains a typical usage example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 `5_Flurry` 文件夹中的示例应用程序。`main.cpp` 文件包含了一个典型的使用示例：
- en: '[PRE111]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The definition of `TrackEvent()` and the difference between Android and desktop
    implementations is located in the `Callbacks.cpp` file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrackEvent()` 的定义以及Android与桌面实现的区别位于 `Callbacks.cpp` 文件中：'
- en: '[PRE112]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Android implementation requires some JNI code to work. Have a look at the following
    `jni/JNI.c` file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Android实现需要一些JNI代码才能工作。请查看以下 `jni/JNI.c` 文件：
- en: '[PRE113]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'And `Callback_TrackEvent()` is defined in the main activity:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callback_TrackEvent()` 在主活动中定义如下：'
- en: '[PRE114]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Other parts of Flurry analytics API can be routed from C++ to Java and back
    in the similar way. We advice that you register an account on Flurry, obtain the
    application keys, and try running the sample yourself. Only the application keys
    for `FlurryAgent.init()` and `FlurryAgent.onStartSession()` should be replaced
    to run the application on Android. Building is straightforward, just use `ndk-build`
    and `ant debug`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Flurry分析API的其他部分也可以通过类似的方式从C++路由到Java，反之亦然。我们建议您在Flurry上注册一个账户，获取应用密钥，并尝试自己运行示例。只需替换
    `FlurryAgent.init()` 和 `FlurryAgent.onStartSession()` 的应用密钥，即可在Android上运行应用程序。构建过程很简单，只需使用
    `ndk-build` 和 `ant debug`。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to implement lean and portable multithreading
    primitives, such as a reference-countered intrusive smart pointer, a worker thread,
    and a message pump, and use them to create simple and portable network-accessing
    framework in C++. A little bit of Java was touched to show how to deal with licensing
    and usage analytics in the native code. In the next chapter, we will step aside
    from networking and learn how to deal with heterogeneous filesystems using a virtual
    filesystem abstraction.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何实现精简且可移植的多线程原语，例如引用计数侵入式智能指针、工作线程和消息泵，并使用它们创建简单的可移植C++网络访问框架。我们还稍微涉及了Java，以展示如何在本地代码中处理许可和用量分析。在下一章中，我们将从网络方面抽身，学习如何使用虚拟文件系统抽象来处理异构文件系统。
