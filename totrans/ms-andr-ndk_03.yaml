- en: Chapter 3. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to deal with network-related functionality
    from the native C/C++ code. Networking tasks are asynchronous by nature and unpredictable
    in terms of timing. Even when the underlying connection is established using the
    TCP protocol, there is no guarantee on the delivery time, and nothing prevents
    the applications from freezing while waiting for the data. In the Android SDK,
    this is hidden from a developer by a myriad of classes and facilities. In Android
    NDK, *au contraire*, one has the responsibility to overcome these difficulties
    without assistance from any platform-specific helpers. To develop responsive and
    safe applications, a number of problems must be solved: we need to be in full
    control of the download process, we have to limit the downloaded data size, and
    gracefully handle the errors that occur. Without delving into the details of the
    HTTP and SSL protocols implementation, we will use the libcurl and OpenSSL libraries,
    and concentrate on higher-level tasks related to application development. However,
    we will take a closer look at implementing basic asynchronous mechanisms in a
    portable way. The first few examples of this chapter are desktop-only and their
    purpose is to show how a multiplatform synchronization primitives can be implemented.
    However, at the end of this chapter, we will see how to put all these pieces together
    into a mobile application.'
  prefs: []
  type: TYPE_NORMAL
- en: Intrusive smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking all native memory allocations in a multithreaded environment is notoriously
    difficult process, especially when it comes to passing objects ownership between
    different threads. In C++, memory management can be automated using smart pointers.
    The standard `std::shared_ptr` class is a good place to start with. However, we
    want to focus on more interesting and lightweight techniques. We will not use
    the Boost library either, since we really want to stay lean when it comes to compile
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recent versions of the Android NDK support the C++ 11 Standard Library in
    full. If you feel more comfortable with `std::shared_ptr` or intrusive pointers
    from Boost, feel free to use smart pointers from those libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an intrusive smart pointer, as the name suggests, a reference counter is
    embedded into the object. The simplest way to do this is by inheriting from the
    following base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses a standard atomic variable to hold the value of the counter. Before
    C++ 11 Standard Library was widely adopted, a portable implementation of an atomic
    counter required platform-specific atomic operations to be used, either POSIX
    or Windows. Nowadays, it is possible to write clean code for all platforms using
    C++ 11; for Android, Windows, Linux, OS X, iOS, and even for BlackBerry 10, if
    you wish to do so. Here is how we can increment the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is absolutely possible to use the `++` operator instead of `fetch_add()`.
    However, incrementing an atomic integer variable this way is required by the compiler
    to be sequentially consistent and may cause redundant memory barriers to be inserted
    in the generated assembly. We do not use the incremented value for any decision
    making, hence the memory barriers here are unnecessary and memory ordering can
    be relaxed, only atomicity of the variable is required. This is what `fetch_add()`
    does with the `std::memory_order_relaxed` flag, leading to a faster code on some
    non-x86 platforms. Decrement is trickier. Indeed, we have to decide when to remove
    the object, and do so only when the reference counter is decremented to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to do it right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::memory_order_release` flag means an operation on a memory location
    requires all previous memory writes to become visible to all threads that do an
    acquire operation on the same location. After entering the `if` block, we will
    do the acquire operation by inserting an appropriate memory barrier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Only after this point, we can now allow the object to commit suicide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `delete this` idiom is explained at [https://isocpp.org/wiki/faq/freestore-mgmt#delete-this](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `iIntrusiveCounter` class is the core of our reference-counting mechanism.
    The code may look very simple; however, the logic behind this implementation is
    much more complicated than it seems. Refer to the *C++ and Beyond 2012: Herb Sutter
    - atomic<> Weapons, 1 of 2* talk by Herb Sutter for all the elaborate details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement a lightweight RAII generic smart pointer class, which
    utilizes our freshly written counter base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a copy constructor does not call the `FObject->IncRefCount()` method
    directly. Instead, it invokes a helper function `LPtr::IncRef()`, which accepts
    `void*` and passes the object as a parameter to that function. This is done to
    allow usage of our intrusive smart pointer with classes that were declared but
    not yet defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit constructor from `T*` is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the constructor, the destructor uses a helper function to decrement
    the reference counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of named helper functions can be of use to check the state of the
    smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Assignment is quite slow compared to other methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But not the `move` assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `->` operator is essential for every smart pointer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a bit tricky one: an automatic type conversion operator to an instance
    of the private class `clProtector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This type conversion is used to allow safe null-pointer checks as in `if (
    clPtr )` to be possible. It is safe because you cannot do anything with the resulting
    pointer. The inner private class `clProtector` does not implement the `delete()`
    operator, hence, using it will produce a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code bundle of this book does not use the `= delete` C++ 11 notation
    for the deleted function, but just leaves it unimplemented. This is done for the
    sake of compatibility with older compilers. If you target the most recent versions
    of GCC/Clang and Visual Studio, going with `= delete` will be just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our `clPtr` class. Unfortunately, the standard `dynamic_cast<>`
    operator cannot be used in the original way, so we need to make a substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the only thing where our smart pointer will be different in syntax
    from raw pointers. Also, we need a set of comparison operators to make our class
    more useful within different containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a function to abridge the smart pointer with APIs accepting raw pointers.
    The conversion to the underling `T*` type should be explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Some helper functions may be useful when dealing with low-level pointer fuss.
    Drop the object, do not deallocate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the object, decrement the reference counter, similar to assigning `nullptr`
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last but not least, the pointer itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Henceforth, our portable intrusive smart pointer is self-contained and can
    be used in real applications. There is one more thing left to be done, a kind
    of syntactic sugar. It is typical of C++ 11 to use the `auto` keyword, so one
    can write the type name in the expression only once. However, the following instantiation
    will not work because the deduced type of `p` will be `clSomeObject*` when we
    wanted it to be `clPtr< clSomeObject>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With standard shared pointers, this is solved using a `std::make_shared()`
    template helper function, which returns the proper type (and does some useful
    optimization of the counter storage behind the scenes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the deduced type of `p` is `std::shared_ptr<clSomeObject>`, which ultimately
    matches our expectations. We can create a similar helper using the perfect forwarding
    mechanism provided by C++ 11 and the `std::forward()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is C++11-stylish and natural:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code for the smart pointer can be found in the `1_IntrusivePtr`
    example. Now, we can proceed further and use this class as the cornerstone of
    our multithreaded memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Portable multithreading primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The long-awaited `std::thread` from the C++11 standard is not (yet) available
    in MinGW toolchain at the time of writing, and it does not possess capabilities
    necessary to adjust thread priorities, which is important for networking. So,
    we implement a simple class `iThread` with the virtual method `Run()` to allow
    portable multithreading in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An internal `LPriority` enumeration defines thread priority classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for constructor and destructor is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Start()` method creates an OS-specific thread handle and starts execution.
    In all of the samples for this book, we do not need to postpone thread execution;
    we just call `_beginthreadex()` and `pthread_create()` system routines with default
    parameters. The `EntryPoint()` method is defined later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The system-dependent thread handle and the Boolean atomic variable, which indicates
    whether this thread should stop its execution, are declared in the private section
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The native threading API supports only C functions, therefore we have to declare
    a static wrapper method `EntryPoint()`, which converts its `void*` parameter to
    `iThread` and calls the `Run()` method of the class. The calling convention and
    result type for the thread function differs on POSIX and Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The protected section defines the `Run()` and `NotifyExit()` virtual methods,
    which are overridden in subclasses. The `GetHandle()` method allows subclasses
    to access the platform-specific thread handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the thread, we will raise the `FPendingExit` flag and call the `NotifyExit()`
    method to inform the thread owner. An optional `Wait` parameter forces the method
    to wait for actual termination of the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We must ensure `Exit()` is not called from the `Run()` method of the same thread
    to avoid deadlocks, so we will call `GetCurrentThread()` and compare the result
    with our own handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, we will mimic the `join` operation by calling `WaitForSingleObject()`
    and then terminating the thread via `CloseHandle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetCurrentThread()` method on Android is implemented slightly different
    from a typical POSIX version. Hence, this method contains a triple `#ifdef` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EntryPoint()` method is the glue that ties together our object-oriented
    `iThread` wrapper class and the platform-specific C-style threading API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The finishing touch is the `SetPriority()` method that is used to control the
    amount of CPU time given for the thread. For Windows, the main part of the method
    is the conversion of our `LPriority` enumeration to the numerical value defined
    in the `windows.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For POSIX, we rescale our priority value to the integer number between minimum
    and maximum priorities available in the OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the `iThread` class to construct more useful higher-level threading
    primitives. For cross-platform lightweight implementation of the `std::mutex`-like
    object, we will use the TinyThread library by Marcus Geelnard, which is available
    for download at [http://tinythreadpp.bitsnbites.eu](http://tinythreadpp.bitsnbites.eu).
    However, feel free to use the standard mutex if you do not have to be compatible
    with legacy compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed with the task queues.
  prefs: []
  type: TYPE_NORMAL
- en: Task queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To process a logical piece of work, we will declare the `iTask` class with
    the `Run()` method, which can perform a time-consuming operation. The declaration
    of the class is somewhat visually similar to `iThread`. However, its instances
    implement some reasonably short operation and may be executed in different threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The pure virtual method `Run()` should be overridden in subclasses to do the
    actual work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods optionally cancel the task and are similar to the ones
    in the `iThread` class. Their purpose is to signal the hosting thread that this
    task should be cancelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetTaskID()` and `SetTaskID()` methods access the internal unique identifier
    of the task, which is used to cancel execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetPriority()` and `SetPriority()` methods are used by the task scheduler
    to determine the order in which the tasks are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The private part of the class contains an atomic exit flag, the task ID value,
    and task priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The management of the tasks is done by the `clWorkerThread` class. Basically,
    it is a collection of `iTask` instances, which is fed using the `AddTask()` method.
    The private part of the class contains `std::list` of `iTask`s and a few synchronization
    primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `FCurrentTask` field is used internally to keep track of the task, which
    is in progress. The `FTasksMutex` field is a mutex to ensure thread-safe access
    to `FPendingTasks`. The `FCondition` conditional variable is used to signal the
    availability of tasks in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddTask()` method inserts a new task to the list and notifies the `Run`
    method about the task availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether there are unfinished tasks, we will define the `GetQueueSize()`
    method. The method uses the `std::list.size()` and increments the returned value
    if there is an active task currently running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There is the `CancelTask()` method to cancel a single task and the `CancelAll()`
    method to cancel all of the tasks at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check whether a task is running and its ID matched with the one we
    want to cancel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will iterate the list of tasks and request exit for the one with the
    given ID, removing them from the list of pending tasks. This can be done using
    a simple lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we notify everyone about the list change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CancelAll()` method is much simpler. The task list is iterated and every
    item is requested to terminate; after this, the container is cleared and a notification
    is sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The main work is done in the `Run()` method, which waits for a next task to
    arrive and executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The outer loop checks whether we need to stop this worker thread using the
    `iThread::IsPendingExit()` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExtractTask()` method extracts the next task from the list. It waits on
    the conditional variable until the task is actually available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If the task is valid and its cancellation is not requested, we can start the
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After the task has completed its work, we will clear the state to ensure the
    correct `GetQueueSize()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExtractTask()` method implements a thread-safe linear search in the `FPendingTasks`
    list to select the `iTask` instance with the highest priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid doing spinlock and burning CPU cycles, the conditional variable is
    checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list is empty, the empty smartpointer is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Best` variable stores the selected task to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating over the `FPendingTask` list and comparing the priority value to
    the one in the `Best` variable, we will select the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will erase the selected task from the container and return the
    result. A temporary variable is needed to ensure our smartpointer does not decrement
    the reference count to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the class to handle asynchronous tasks. There is one more crucial
    thing to be done before we can proceed with the actual asynchronous networking—asynchronous
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Message pumps and asynchronous callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we defined `clWorkerThread` and `iTask` classes that
    allow us to execute lengthy operations outside of the UI thread in C++ code. The
    final thing we need to organize a responsive interface is the ability to pass
    around events across different threads. To do this, we need a callable interface,
    which can encapsulate the parameters passed to a method, and a thread-safe mechanism
    to pass such capsules across the threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice candidate for such a capsule is `std::packaged_task`, which is not supported
    in the most recent MinGW toolchain. Therefore, we will define our own lightweight
    reference-counted abstract class `iAsyncCapsule`, which implements a single method,
    `Invoke()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We call a prioritized collection of `iAsyncCapsule` instances wrapped in `clPtr`
    an *asynchronous queue*. The `clAsyncQueue` class implements the `DemultiplexEvents()`
    method, which will be called in the thread that does the processing of incoming
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is called the reactor pattern. It's documentation can be found at [http://en.wikipedia.org/wiki/Reactor_pattern](http://en.wikipedia.org/wiki/Reactor_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: The demultiplexing consists of invoking all the accumulated `iAsyncCapsule`s
    that are added from the other threads by the `EnqueueCapsule()` method. Both methods
    should be and are thread-safe. However, `DemultiplexEvents()` is not reentrant
    in the sense that no two threads should invoke `DemultiplexEvents()` on the same
    object. This limitation is a part of performance optimization, which we will see
    further. We use two containers of `iAsyncCapsule`s and switch between them at
    each call of `DemultiplexEvents()`. This allows faster `EnqueueCapsule()` execution
    because we don't have to copy the contents of the queue to ensure thread-safety.
    Otherwise, a copy would be necessary because we should not call `Invoke()` while
    the mutex is locked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private section of the class contains the index of the current queue in
    use `FCurrentQueue`, two containers of `iAsyncCapsule`s, a pointer to the current
    queue, and a mutex to prevent simultaneous access to the `FAsyncQueues` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructor initializes the current queue pointer and the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EnqueueCapsule()` method is similar to `WorkerThread::AddTask()`. First,
    we create a scoped `lock_guard` object, and then call `push_back()` to enqueue
    the `iAsyncCapsule` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DemultiplexEvents()` method saves the reference to the current queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`DemultiplexEvents()` is designed to run only on one thread. No locking is
    needed at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the current queue pointer is swapped. This is an atomic operation, so
    we use lock the mutex to prevent access to the `FAsyncQueue` pointer and the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, each and every `iAsyncCapsule` in the current queue is invoked and
    the `LocalQueue` is cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The typical usage scenario is posting callbacks from one thread to another.
    A small sample considered here uses the `clResponseThread` class with an endless
    loop as the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample `clRequestThread` class is producing events twice per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The test call just prints out a message with the `clTestCall` ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, we create both threads and start an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will use a similar approach to inform the main
    thread of the download result. The `clResponseThread` class becomes the UI thread
    and `clRequestThread` is a `WorkerThread` method where each of executed download
    tasks fires an event once the download is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous networking with libcurl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplistic usage of libcurl was shown in [Chapter 2](part0024.xhtml#aid-MSDG2
    "Chapter 2. Native Libraries"), *Native Libraries*. Now, we extend the code using
    the previously mentioned multithreading primitives to allow asynchronous downloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clDownloadTask` class introduced here keeps track of the download process
    and invokes a callback when the process completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor accepts URL of the resource to download, a unique task identifier,
    a callback, and a pointer to the instance of the downer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We will focus on the `Run()`, `Progress()`, and `InvokeCallback()` methods,
    as they form the main logic of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run()` method runs on the download thread; it initializes and performs
    the actual downloading of the resource using libcurl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This hard reference is required to prevent external destruction of the task
    if it is cancelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization of libcurl goes here. All possible parameters can be found
    in the official documentation at [http://curl.haxx.se/libcurl/c/curl_easy_setopt.html](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line sets the number of seconds to wait while trying to connect.
    Use the value of zero to wait indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we set the maximal number of seconds to allow libcurl functions to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable verification of certificates by OpenSSL, this will enable access to
    sites with self-signed certificates. However, you may want to remove this mode
    in the production code to reduce the possibility of man-in-the-middle attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When negotiating an SSL connection, the server sends a certificate indicating
    its identity. Curl verifies whether the certificate is authentic—that is, that
    you can trust that the server is who the certificate says it is. This trust is
    based on a chain of digital signatures, rooted in certification authority (CA)
    certificates you supply.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the documentation at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html](http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYHOST.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the actual download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let the downloader deal with the results of this task. We will follow this
    code shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The private `InvokeCallback()` member function is accessible from the friend
    class `clDownloader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Per se, this is just a `FCallback->Invoke()` invocation augmented with two
    runtime checks. The first one checks whether the task is not cancelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one checks the availability of the callback and prepared all the
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to notice the callback invocation is done while the mutex is
    locked. Doing so is essential to ensure the correct cancellation behavior. However,
    `InvokeCallback()` is not called directly from `clDownloadTask`. Instead, there
    is an indirection via the `FDownloader->CompleteTask( this )` called from the
    `Run()` method. Let''s see what is inside of it and look at the guts of the `clDownloader`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is the most important part of our public downloading API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And this one handles the indirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the thread where `clDownloadTask`s are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'An external event queue is initialized using the constructor parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Though, the `DownloadURL()` method is crucial, its implementation is surprisingly
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, all the hard work is done inside the aforementioned method `clDownloadTask::Run()`.
    Here, we just enqueued a newly constructed task into the worker thread. The most
    interesting thing happens inside `CompleteTask()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a callback wrapper is inserted into the event queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper class calls the very `FTask->InvokeCallback()` method. Remember,
    the method is invoked on the right thread, it was dispatched by the event queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage sample can be found in the `3_Downloader` folder of the source code
    bundle. It is as simple as this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This queue will handle download results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `clTestCallback` class prints downloading progress and saves results to
    a file, `.zip` in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `LUrlParser` library to extract the file name from a given URL, [https://github.com/corporateshark/LUrlParser](https://github.com/corporateshark/LUrlParser).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code can be compiled using MinGW by typing `make all`. The same code
    can be run on Android without changes using the compiled Curl library from [Chapter
    2](part0024.xhtml#aid-MSDG2 "Chapter 2. Native Libraries"), *Native Libraries*.
    We suggest that you experiment with this code on Android and play with some downloads
    directly from the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Android licensing in native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major part of this chapter has been dedicated to low-level networking capabilities
    in C++, which are crucial to writing multiplatform code. However, it would not
    be fair to omit some Android-specific things from this chapter. Let's go with
    licensing mechanism and learn how to move it into the C++ code. For this one,
    we will need to interact with Java code heavily, since all the licensing facilities
    are Java-only.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we assume that you are already familiar with how to do the license checking
    in Java. The official Google documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/google/play/licensing/setting-up.html](http://developer.android.com/google/play/licensing/setting-up.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/google/play/licensing/adding-licensing.html](http://developer.android.com/google/play/licensing/adding-licensing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of this sample is located in the `4_Licensing` folder. First,
    let''s define the basic constants, the values should match those from the Android
    SDK. See the `License.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `Callbacks.h` declares callbacks invoked from the license-checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The main source file contains the implementations of those callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, terminate the application only if we are truly unlicensed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dive deeper into JNI and Java code to see how these callbacks are invoked.
    The `LicenseChecker.cpp` file contains a one-to-one mapping of static Java methods
    to the previously mentioned callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We follow the code into the `AppActivity.java` file, which declares `CheckLicense()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct the `LicenseCheckerCallback` object. The Google licensing library
    invokes it once done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct `LicenseChecker` with `Policy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java side of the callbacks is right here, at the bottom of the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppLicenseChecker` class just calls these static methods to route the
    events to JNI code. How simple! Now, you can handle (and test) the reaction to
    license checking events in C++ code in a portable way. Build the sample for Android
    with the following commands and see for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The runtime logs can be accessed via `logcat`. The desktop version is buildable
    via the `make all` command as all the samples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Flurry analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's touch one more Java-related thing and its binding to the native C++ code.
    Flurry.com is a popular in-app analytics service. Determination of the most used
    features in your app is accomplished by sending information to Flurry.com and
    later accessing gathered statistics on their web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you have several options in your application such as the different
    game modes: campaign, single level, or online. User selects one of the modes and
    an event is generated and sent to Flurry.com. We want to send those events from
    our C++ code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the sample application in the `5_Flurry` folder. The `main.cpp` file
    contains a typical usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `TrackEvent()` and the difference between Android and desktop
    implementations is located in the `Callbacks.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Android implementation requires some JNI code to work. Have a look at the following
    `jni/JNI.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'And `Callback_TrackEvent()` is defined in the main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Other parts of Flurry analytics API can be routed from C++ to Java and back
    in the similar way. We advice that you register an account on Flurry, obtain the
    application keys, and try running the sample yourself. Only the application keys
    for `FlurryAgent.init()` and `FlurryAgent.onStartSession()` should be replaced
    to run the application on Android. Building is straightforward, just use `ndk-build`
    and `ant debug`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement lean and portable multithreading
    primitives, such as a reference-countered intrusive smart pointer, a worker thread,
    and a message pump, and use them to create simple and portable network-accessing
    framework in C++. A little bit of Java was touched to show how to deal with licensing
    and usage analytics in the native code. In the next chapter, we will step aside
    from networking and learn how to deal with heterogeneous filesystems using a virtual
    filesystem abstraction.
  prefs: []
  type: TYPE_NORMAL
