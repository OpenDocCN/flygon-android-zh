- en: Chapter 6. OpenGL ES 3.1 and Cross-platform Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement an abstraction layer on top
    of OpenGL 4 and OpenGL ES 3 in order to make our graphics applications runnable
    on Android and desktop machines. Let's start with some basic vector and linear
    algebra classes.
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra and transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Core/VecMath.h` file, there is a bunch of vector and matrix specific
    classes and helpers. The main classes we use are `LVector2`, `LVector3`, `LVector4`,
    `LMatrix3`, `LMatrix4`, and `LQuaternion` for which basic algebraic operations
    are defined. There are shortcuts for them to makewriting of any math-heavy codr:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This tiny math library is basically a tight squeeze of some algebra code from
    Linderdaum Engine ([http://www.linderdaum.com](http://www.linderdaum.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, there is a set of useful functions in the namespace `Math` dealing
    with different projection transformations calculation. They will be heavily used
    in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics initialization using SDL2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous book, *Android NDK Game Development Cookbook*, *Packt Publishing*,
    we learned in great detail how to initialize OpenGL ES 2 on Android and OpenGL
    3 Core Profile on desktop using our own handcrafted code. Now, we will do it using
    the SDL2 library, which is available at [https://www.libsdl.org](https://www.libsdl.org).
    Let''s take a look at the `1_GLES3` example. The Java code for this example, besides
    SDL2 internals of course, is short and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else is done in the C++ code. There is the `main()` function, which
    is redefined by SDL2 using a macro to make our application look like a desktop
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, a window and an OpenGL rendering context are created using the `clSDLWindow`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can retrieve pointers to OpenGL functions. This abstraction is superior
    to statically linking against an OpenGL library since it makes our code more portable.
    For example, you cannot statically link to core OpenGL functions on Windows without
    using third-party libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the callback we already used in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual Filesystem*,
    when dealing with virtual filesystems. We won''t need any path in this example,
    so let''s just use an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The event loop is done explicitly and contains a call to the `OnDrawFrame()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These wrapper classes (`clSDL` and `clSDLWindow`) are declared in files `SDLLibrary.h`
    and `SDLWindow.h` respectively. The `clSDL` class is a RAII wrapper on top of
    SDL and does initialization and deinitialization of the library in its constructor
    and destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clSDLWindow` class represents a window abstraction with an OpenGL context
    and a system message pump attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This member function performs one iteration of the message loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert integer coordinates into floating point normalized coordinates 0..1
    to make it easier to use screens of different resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method is useful to construct a projection matrix for the current
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A public static helper method to create an instance of `clSDLWindow` is as
    foows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandleEvent()` member function does the job of dispatching an SDL2 event
    to our callcks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `HandleEvent()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Not all of the case labels are implemented and not all SDL2 events are used.
    We will make use of this routing on an as-needed basis in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we render a rotating box using some useful OpenGL wrappers,
    which can hide the differences between mobile and desktop versions of OpenGL.
    Here is the code of `OnStart()` printing the version of OpenGL into the system
    log and initializing vertex buffer objects and shader programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an API-agnostic representation of a box mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we feed it into OpenGL to create a vertex array using vertex buffer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The shader program is constructed from two string variables containing the
    source code of vertex and fragment shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the shaders written in GLSL 3.3 Core Profile. Transform the vertices
    using the model-view-projection matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Paint the box using texture coordinates as RG color components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed the source code of the shaders does not contain `#version`
    and `precision` lines. This is because the `clGLSLShaderProgram` class does some
    manipulations on the source code to abstract the differences between different
    versions of GLSL. We will familiarize ourselves with this class in the subsequent
    paragraphs. Before that, let''s take a look at `OnDrawFrame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotate the cube around the `(1, 1, 1)` axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: OpenGL API binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, all OpenGL calls in the earlier mentioned code are done via
    the `LGL3` prefix. This is a structure called `sLGLAPI` declared in `LGLAPI.h`
    containing pointers to actual OpenGL API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields of the `sLGLAPI` structure are set in the `LGL::GetAPI()` function.
    There are two distinct implementations of this function, one is for Windows in
    `LGL_Windows.h`, and the other is in `LGL_Android.h` for everything else. The
    difference is in the dynamic linking on Windows, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All other platforms use static linking against the system-provided OpenGL library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you use vendor-specific OpenGL extensions, you can access them
    using dynamic linking and `glGetProcAddresss()` on any platform and that is where
    the `sLGLAPI` structure comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the lowest of our abstraction levels on top of OpenGL. One might say
    this so -called layer does nothing. This is not true. Just take a look how a pointer
    to `glClearDepth()` is retrieved on Android. Instead of a direct function call,
    there is a stub for some reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The stub is defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The reason is there was no `glClearDepth()` function in OpenGL ES, which accepts
    a `float` parameter but OpenGL 3 has one. This way the API difference between
    mobile and desktop OpenGL can be hidden from the client code behind a thin abstraction
    layer. Using this technique, you can transparently replace one OpenGL enums with
    the other. A tracing mechanism can be transparently implemented which can print
    the values of OpenGL function parameters into the log. This technique is crucial
    when porting existing applications to platforms where no graphics debugger is
    available (yes, we are looking at you, BlackBerry). We will leave that as an exercise
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dive deeper and find out how higher-level abstractions are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform OpenGL abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometric objects can be represented by their surfaces. In this chapter, we
    are talking only about polygonal graphics, so the data structure of fundamental
    importance is the *triangular mesh*.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the digital audio, our convenient API-agnostic data structures
    should be converted to something native for the graphics API before they can be
    rendered. Let's start with the representation of triangulated geometry in the
    3D space.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single triangle can be specified by three vertices. Each vertex stores at
    least its position in the 3D space, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-platform OpenGL abstractions](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing in implementing a portable renderer, we need to separate geometry
    storage, which in the most simple case, is just a collection of vertices with
    their attributes and the order to iterate through these vertices to construct
    graphical primitives, from any API-specific functions and data types. This kind
    of data structure is implemented in the `clVertexAttribs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns a container of pointer to the actual vertex attributes,
    positions, texture coordinates, normals, and colors, which can be fed into an
    OpenGL vertex buffer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a bunch of helper methods to generate geometry data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a set of public fields to store our data. The vertex 3D positions
    *x*, *y*, *z* are declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Texture coordinates `u` and `v`. This is a limitation of our vertex format
    since sometimes texture coordinates can contain more than two channels. However,
    for our applications, this limitation is appropriate and viable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The vertex normals are usually in the object space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'RGBA colors of the vertices. This container can be used for any custom data
    you want if you write the right shader, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is simple; however, we suggest that you take a look at the
    `Geometry.cpp` and `Geometry.h` files before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: 'To populate instances of `clVertexAttribs` with useful data, a set of static
    methods is declared within the `clGeomServ` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All `Create*()` methods create a new geometry primitive and return an instance
    of `clVertexAttribs` containing it. Methods starting with `Add` add a primitive
    to the existing instance of the `clVertexAttribs` class assuming it has enough
    capacity to store the new primitive.Implementations ofmpleare trivial and can
    be found in `Geometry.cpp`. More sophisticated geometry generation routines will
    be added in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding the geometry data to OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To render the contents of `clVertexAttribs`, we need to convert its data into
    a set of API-specific buffers and API function invocations. This is done in the
    `clGLVertexArray` class by creating **Vertex Array Object** (**VOA**) and **Vertex
    Buffer Object** (**VBO**) OpenGL objects and fetching contents from `clVertexAttribs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Draw()` method does the actual rendering and it is the lowest level possible
    with our abstraction layer to actually render anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These pointers are actually offsets of vertex data inside the vertex buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And these pointers point to the actual data from `clVertexAttribs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this class includes some book-keeping and calling the
    OpenGL functions. The constructor and destructor initialize and destroy handles
    for VOA and VBO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, we use OpenGL 4 where usage of vertex array object is mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Destruction is done in a similar platform-specific way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The private method `Bind()` sets this vertex array object as the source vertex
    stream for the OpenGL rendering pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After binding and enabling the vertex positions, we enable each additional
    non-empty attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Draw()` method binds the VOA and calls `glDrawArrays()` to render the
    geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the type of primitives. If the `Wireframe` parameter
    is `true`, we tell OpenGL to treat the data as a collection of lines, one for
    each sequential pair of points. If the parameter is `false`, each sequential point
    triple is used as three vertices of a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetVertexAttribs()` member function attaches the geometry to `GLVertexArray`
    and recreates all the required OpenGL objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After assigning a pointer, we acquire an array of pointers to individual vertex
    attribute streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Every stream is checked if it contains any data and the size of the vertex
    buffer is updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we create a new vertex buffer object that will contain the geometry
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing here is to copy the data from `clVertexAttribs` object
    to GPU memory. This is done by calling `glBufferData()` with a `nullptr` value
    as the buffer pointer to allocate the storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about `glBufferData()` at [https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are subsequent calls to `glBufferSubData()` for each non-empty attribute
    array, those are vertex positions, texture coordinates, normals, and colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Binding is somewhat specific for VAO and non-VAO versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The VAO version can be used on OpenGL ES 3\. However, unmodified code also runs
    on OpenGL ES 2.
  prefs: []
  type: TYPE_NORMAL
- en: Shader programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both desktop and mobile OpenGL versions use shader programs as parts of their
    rendering pipelines. Feeding just the geometry is not enough. However, there are
    several important differences between GLSL 3.00 ES and GLSL 3.30 Core we should
    deal with to create a portable rendering subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the declaration of a `uniform` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This class stores name and location of a uniform within a linked shader program.
    The shader program class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor takes the source code of vertex and fragment shaders as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bind()` method binds the shader program before usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A group of methods dealing with uniforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Link the program using the attached shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to bind default locations of attributes and fragment data. This is
    done in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It binds the shader variables `in_Vertex`, `in_Normal`, `in_TexCoord`, and `in_Color`
    to appropriate vertex streams. You can declare and use these `in` variables in
    your GLSL code. The `out_FragColor` output variable is associated with the single
    output of a fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and attach a shader to this shader program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Check and log any errors occurred while compiling and linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This method retrieves all uniforms from the linked shader program and stores
    them as `sUniform` structures within the `FUniforms` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A collection of active uniforms in this shader program is stored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'An OpenGL shader program and shader identifiers are stored in the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can destroy all the created OpenGL objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how a shader object is created and attached to the shader program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we use OpenGL ES 3 and OpenGL 4, the version of shaders should be specified
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting shader is submitted to OpenGL API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the compilation status and log any errors detected while compiling the
    code. This code falls back to the previously compiled shader if the new one fails
    to compile. You can implement dynamic shader program reloading as an exercise
    using filesystem classes from the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Error checking and logging is not that complicated to implement and is a must-have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A buffer for a shader program error message is allocated dynamically on the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Deal with a shader object in a similar way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Relinking of the shader program is done when both vertex and fragment shader
    objects had been successfully compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind locations of all default vertex attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we know the shader program was linked successfully, and we can
    use it as a part of our rendering pipeline. Replace the old program with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the list of active uniforms from the linked program and store them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind texture samplers to their default locations. You can add more texture
    units whenever you desire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Queuing of uniforms is done in the `RebindAllUniforms()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sUniform` object is constructed and pushed into the container for future
    access. As an improvement, the vector can be sorted or replaced with `std::map`
    to allow faster access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetUniform*()` group of methods sets the value for a named uniform in
    the GLSL shader program. These methods retrieve a handle of a uniform by calling
    `CreateUniform()`, and then use one of the `glUniform*()` OpenGL functions to
    set the new value. String names can be used for rapid prototyping of shaders.
    If you want to go for performance, retrieve the location of the uniform beforehand
    using the `CreateUniform()` member function and use that value with a corresponding
    call to `SetUniform*()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Vectors are converted to pointers. Notice the following trick, the `ToFloatPtr()`
    method returns a pointer to the `x` component of a vector. In the case when this
    vector in packed into an array of vectors, we also have the pointer to the beginning
    of the array. Thus, the `Count` parameter makes perfect sense and we may pass
    arrays of vectors to this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods for matrices differ from the previous ones only by parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateUniform()` method used in `SetUniform*()` performs a search in the
    `FUniforms` container and returns the OpenGL identifier of the uniform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This method is safe to use for any name, since the value of `-1` returned for
    uniforms not found in the shader program is accepted and ignored by OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Bind()` method binds the shader program to the current OpenGL rendering
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In a more sophisticated application, it makes sense to cache the value of the
    currently binded shader program and call the underlying API only if the value
    was changed.
  prefs: []
  type: TYPE_NORMAL
- en: Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last component we need to wrap is a texture. Textures are represented as
    instances of the `clGLTexture` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the texture to a specified OpenGL texture unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Load texture pixels from an API-independent bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the texture coordinates clamping mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Deal with the data formats and dimensions of t texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is quite compact. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the format of the texture without uploading any pixels. This is
    useful if you want to attach the texture to a frame buffer object. We will use
    this functionality in [Chapter 8](part0069.xhtml#aid-21PMQ2 "Chapter 8. Writing
    a Rendering Engine"), *Writing a Rendering Engine*, to implement render-to-texture
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `S` and `T` clamping modes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Choose an appropriate OpenGL texture format based on the bitmap parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the default filtering mode to `GL_LINEAR` to avoid building a mipmap chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Some OpenGL ES implementations does not allow zero-size textures (yes, we are
    looking at you, Vivante):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Load raw bitmap data into OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to this point, we have enough instruments at our disposal to build portable
    mobile applications using OpenGL. The example application `1_GLES` for this chapter
    renders a colored rotating cube on Windows and Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Textures](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Windows version can be compiled with `>make all -j16 -B`. An `.apk` package
    for Android can be built by calling these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to wrap raw OpenGL calls into a thin abstraction layer to hide
    many differences between OpenGL ES 3 and OpenGL 4\. Now, let's proceed to the
    next chapter and learn how to implement basic graphical user interface rendering
    using OpenGL and classes shown in this chapter.
  prefs: []
  type: TYPE_NORMAL
