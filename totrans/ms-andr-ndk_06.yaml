- en: Chapter 6. OpenGL ES 3.1 and Cross-platform Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement an abstraction layer on top
    of OpenGL 4 and OpenGL ES 3 in order to make our graphics applications runnable
    on Android and desktop machines. Let's start with some basic vector and linear
    algebra classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra and transformations
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Core/VecMath.h` file, there is a bunch of vector and matrix specific
    classes and helpers. The main classes we use are `LVector2`, `LVector3`, `LVector4`,
    `LMatrix3`, `LMatrix4`, and `LQuaternion` for which basic algebraic operations
    are defined. There are shortcuts for them to makewriting of any math-heavy codr:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tiny math library is basically a tight squeeze of some algebra code from
    Linderdaum Engine ([http://www.linderdaum.com](http://www.linderdaum.com)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, there is a set of useful functions in the namespace `Math` dealing
    with different projection transformations calculation. They will be heavily used
    in the subsequent chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Graphics initialization using SDL2
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous book, *Android NDK Game Development Cookbook*, *Packt Publishing*,
    we learned in great detail how to initialize OpenGL ES 2 on Android and OpenGL
    3 Core Profile on desktop using our own handcrafted code. Now, we will do it using
    the SDL2 library, which is available at [https://www.libsdl.org](https://www.libsdl.org).
    Let''s take a look at the `1_GLES3` example. The Java code for this example, besides
    SDL2 internals of course, is short and simple:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Everything else is done in the C++ code. There is the `main()` function, which
    is redefined by SDL2 using a macro to make our application look like a desktop
    one:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, a window and an OpenGL rendering context are created using the `clSDLWindow`
    class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we can retrieve pointers to OpenGL functions. This abstraction is superior
    to statically linking against an OpenGL library since it makes our code more portable.
    For example, you cannot statically link to core OpenGL functions on Windows without
    using third-party libraries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the callback we already used in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. Organizing a Virtual Filesystem"), *Organizing a Virtual Filesystem*,
    when dealing with virtual filesystems. We won''t need any path in this example,
    so let''s just use an empty string:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The event loop is done explicitly and contains a call to the `OnDrawFrame()`
    function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These wrapper classes (`clSDL` and `clSDLWindow`) are declared in files `SDLLibrary.h`
    and `SDLWindow.h` respectively. The `clSDL` class is a RAII wrapper on top of
    SDL and does initialization and deinitialization of the library in its constructor
    and destructor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `clSDLWindow` class represents a window abstraction with an OpenGL context
    and a system message pump attached to it:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This member function performs one iteration of the message loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Convert integer coordinates into floating point normalized coordinates 0..1
    to make it easier to use screens of different resolutions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following method is useful to construct a projection matrix for the current
    window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A public static helper method to create an instance of `clSDLWindow` is as
    foows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `HandleEvent()` member function does the job of dispatching an SDL2 event
    to our callcks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implementation of `HandleEvent()` is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Not all of the case labels are implemented and not all SDL2 events are used.
    We will make use of this routing on an as-needed basis in the subsequent chapters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we render a rotating box using some useful OpenGL wrappers,
    which can hide the differences between mobile and desktop versions of OpenGL.
    Here is the code of `OnStart()` printing the version of OpenGL into the system
    log and initializing vertex buffer objects and shader programs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we create an API-agnostic representation of a box mesh:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we feed it into OpenGL to create a vertex array using vertex buffer object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The shader program is constructed from two string variables containing the
    source code of vertex and fragment shaders:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are the shaders written in GLSL 3.3 Core Profile. Transform the vertices
    using the model-view-projection matrix:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Paint the box using texture coordinates as RG color components:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You may have noticed the source code of the shaders does not contain `#version`
    and `precision` lines. This is because the `clGLSLShaderProgram` class does some
    manipulations on the source code to abstract the differences between different
    versions of GLSL. We will familiarize ourselves with this class in the subsequent
    paragraphs. Before that, let''s take a look at `OnDrawFrame()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Rotate the cube around the `(1, 1, 1)` axis:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: OpenGL API binding
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, all OpenGL calls in the earlier mentioned code are done via
    the `LGL3` prefix. This is a structure called `sLGLAPI` declared in `LGLAPI.h`
    containing pointers to actual OpenGL API functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The fields of the `sLGLAPI` structure are set in the `LGL::GetAPI()` function.
    There are two distinct implementations of this function, one is for Windows in
    `LGL_Windows.h`, and the other is in `LGL_Android.h` for everything else. The
    difference is in the dynamic linking on Windows, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All other platforms use static linking against the system-provided OpenGL library:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, if you use vendor-specific OpenGL extensions, you can access them
    using dynamic linking and `glGetProcAddresss()` on any platform and that is where
    the `sLGLAPI` structure comes in handy:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the lowest of our abstraction levels on top of OpenGL. One might say
    this so -called layer does nothing. This is not true. Just take a look how a pointer
    to `glClearDepth()` is retrieved on Android. Instead of a direct function call,
    there is a stub for some reason:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The stub is defined in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The reason is there was no `glClearDepth()` function in OpenGL ES, which accepts
    a `float` parameter but OpenGL 3 has one. This way the API difference between
    mobile and desktop OpenGL can be hidden from the client code behind a thin abstraction
    layer. Using this technique, you can transparently replace one OpenGL enums with
    the other. A tracing mechanism can be transparently implemented which can print
    the values of OpenGL function parameters into the log. This technique is crucial
    when porting existing applications to platforms where no graphics debugger is
    available (yes, we are looking at you, BlackBerry). We will leave that as an exercise
    for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dive deeper and find out how higher-level abstractions are implemented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform OpenGL abstractions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometric objects can be represented by their surfaces. In this chapter, we
    are talking only about polygonal graphics, so the data structure of fundamental
    importance is the *triangular mesh*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the digital audio, our convenient API-agnostic data structures
    should be converted to something native for the graphics API before they can be
    rendered. Let's start with the representation of triangulated geometry in the
    3D space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'A single triangle can be specified by three vertices. Each vertex stores at
    least its position in the 3D space, as shown in the following figure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-platform OpenGL abstractions](img/image00223.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'The first thing in implementing a portable renderer, we need to separate geometry
    storage, which in the most simple case, is just a collection of vertices with
    their attributes and the order to iterate through these vertices to construct
    graphical primitives, from any API-specific functions and data types. This kind
    of data structure is implemented in the `clVertexAttribs` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method returns a container of pointer to the actual vertex attributes,
    positions, texture coordinates, normals, and colors, which can be fed into an
    OpenGL vertex buffer object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We declare a bunch of helper methods to generate geometry data:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We declare a set of public fields to store our data. The vertex 3D positions
    *x*, *y*, *z* are declared as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Texture coordinates `u` and `v`. This is a limitation of our vertex format
    since sometimes texture coordinates can contain more than two channels. However,
    for our applications, this limitation is appropriate and viable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The vertex normals are usually in the object space:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'RGBA colors of the vertices. This container can be used for any custom data
    you want if you write the right shader, of course:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The implementation is simple; however, we suggest that you take a look at the
    `Geometry.cpp` and `Geometry.h` files before proceeding further.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'To populate instances of `clVertexAttribs` with useful data, a set of static
    methods is declared within the `clGeomServ` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All `Create*()` methods create a new geometry primitive and return an instance
    of `clVertexAttribs` containing it. Methods starting with `Add` add a primitive
    to the existing instance of the `clVertexAttribs` class assuming it has enough
    capacity to store the new primitive.Implementations ofmpleare trivial and can
    be found in `Geometry.cpp`. More sophisticated geometry generation routines will
    be added in the subsequent chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Feeding the geometry data to OpenGL
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To render the contents of `clVertexAttribs`, we need to convert its data into
    a set of API-specific buffers and API function invocations. This is done in the
    `clGLVertexArray` class by creating **Vertex Array Object** (**VOA**) and **Vertex
    Buffer Object** (**VBO**) OpenGL objects and fetching contents from `clVertexAttribs`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Draw()` method does the actual rendering and it is the lowest level possible
    with our abstraction layer to actually render anything:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These pointers are actually offsets of vertex data inside the vertex buffer:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And these pointers point to the actual data from `clVertexAttribs`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation of this class includes some book-keeping and calling the
    OpenGL functions. The constructor and destructor initialize and destroy handles
    for VOA and VBO:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'On Windows, we use OpenGL 4 where usage of vertex array object is mandatory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Destruction is done in a similar platform-specific way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The private method `Bind()` sets this vertex array object as the source vertex
    stream for the OpenGL rendering pipeline:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After binding and enabling the vertex positions, we enable each additional
    non-empty attribute:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Draw()` method binds the VOA and calls `glDrawArrays()` to render the
    geometry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first parameter is the type of primitives. If the `Wireframe` parameter
    is `true`, we tell OpenGL to treat the data as a collection of lines, one for
    each sequential pair of points. If the parameter is `false`, each sequential point
    triple is used as three vertices of a triangle:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `SetVertexAttribs()` member function attaches the geometry to `GLVertexArray`
    and recreates all the required OpenGL objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After assigning a pointer, we acquire an array of pointers to individual vertex
    attribute streams:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Every stream is checked if it contains any data and the size of the vertex
    buffer is updated accordingly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After this, we create a new vertex buffer object that will contain the geometry
    data:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The most important thing here is to copy the data from `clVertexAttribs` object
    to GPU memory. This is done by calling `glBufferData()` with a `nullptr` value
    as the buffer pointer to allocate the storage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can find more information about `glBufferData()` at [https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml](https://www.khronos.org/opengles/sdk/docs/man3/html/glBufferData.xhtml).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are subsequent calls to `glBufferSubData()` for each non-empty attribute
    array, those are vertex positions, texture coordinates, normals, and colors:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Binding is somewhat specific for VAO and non-VAO versions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The VAO version can be used on OpenGL ES 3\. However, unmodified code also runs
    on OpenGL ES 2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Shader programs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both desktop and mobile OpenGL versions use shader programs as parts of their
    rendering pipelines. Feeding just the geometry is not enough. However, there are
    several important differences between GLSL 3.00 ES and GLSL 3.30 Core we should
    deal with to create a portable rendering subsystem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the declaration of a `uniform` value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This class stores name and location of a uniform within a linked shader program.
    The shader program class looks as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The constructor takes the source code of vertex and fragment shaders as parameters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `Bind()` method binds the shader program before usage:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A group of methods dealing with uniforms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Link the program using the attached shaders:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to bind default locations of attributes and fragment data. This is
    done in the following method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It binds the shader variables `in_Vertex`, `in_Normal`, `in_TexCoord`, and `in_Color`
    to appropriate vertex streams. You can declare and use these `in` variables in
    your GLSL code. The `out_FragColor` output variable is associated with the single
    output of a fragment shader.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and attach a shader to this shader program:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Check and log any errors occurred while compiling and linking:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This method retrieves all uniforms from the linked shader program and stores
    them as `sUniform` structures within the `FUniforms` container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A collection of active uniforms in this shader program is stored as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'An OpenGL shader program and shader identifiers are stored in the following
    fields:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can destroy all the created OpenGL objects as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s see how a shader object is created and attached to the shader program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since we use OpenGL ES 3 and OpenGL 4, the version of shaders should be specified
    accordingly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The resulting shader is submitted to OpenGL API functions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Check the compilation status and log any errors detected while compiling the
    code. This code falls back to the previously compiled shader if the new one fails
    to compile. You can implement dynamic shader program reloading as an exercise
    using filesystem classes from the previous chapters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Error checking and logging is not that complicated to implement and is a must-have:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A buffer for a shader program error message is allocated dynamically on the
    stack:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Deal with a shader object in a similar way as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Relinking of the shader program is done when both vertex and fragment shader
    objects had been successfully compiled:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Bind locations of all default vertex attributes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'At this point, we know the shader program was linked successfully, and we can
    use it as a part of our rendering pipeline. Replace the old program with this
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Retrieve the list of active uniforms from the linked program and store them:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Bind texture samplers to their default locations. You can add more texture
    units whenever you desire:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Queuing of uniforms is done in the `RebindAllUniforms()` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `sUniform` object is constructed and pushed into the container for future
    access. As an improvement, the vector can be sorted or replaced with `std::map`
    to allow faster access:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `SetUniform*()` group of methods sets the value for a named uniform in
    the GLSL shader program. These methods retrieve a handle of a uniform by calling
    `CreateUniform()`, and then use one of the `glUniform*()` OpenGL functions to
    set the new value. String names can be used for rapid prototyping of shaders.
    If you want to go for performance, retrieve the location of the uniform beforehand
    using the `CreateUniform()` member function and use that value with a corresponding
    call to `SetUniform*()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Vectors are converted to pointers. Notice the following trick, the `ToFloatPtr()`
    method returns a pointer to the `x` component of a vector. In the case when this
    vector in packed into an array of vectors, we also have the pointer to the beginning
    of the array. Thus, the `Count` parameter makes perfect sense and we may pass
    arrays of vectors to this method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Methods for matrices differ from the previous ones only by parameter types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `CreateUniform()` method used in `SetUniform*()` performs a search in the
    `FUniforms` container and returns the OpenGL identifier of the uniform:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This method is safe to use for any name, since the value of `-1` returned for
    uniforms not found in the shader program is accepted and ignored by OpenGL.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Bind()` method binds the shader program to the current OpenGL rendering
    context:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In a more sophisticated application, it makes sense to cache the value of the
    currently binded shader program and call the underlying API only if the value
    was changed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Textures
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last component we need to wrap is a texture. Textures are represented as
    instances of the `clGLTexture` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Bind the texture to a specified OpenGL texture unit:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Load texture pixels from an API-independent bitmap:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set the texture coordinates clamping mode:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Deal with the data formats and dimensions of t texture:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The implementation is quite compact. Here it is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can set the format of the texture without uploading any pixels. This is
    useful if you want to attach the texture to a frame buffer object. We will use
    this functionality in [Chapter 8](part0069.xhtml#aid-21PMQ2 "Chapter 8. Writing
    a Rendering Engine"), *Writing a Rendering Engine*, to implement render-to-texture
    functionality:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Update `S` and `T` clamping modes as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Choose an appropriate OpenGL texture format based on the bitmap parameters:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Set the default filtering mode to `GL_LINEAR` to avoid building a mipmap chain:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Some OpenGL ES implementations does not allow zero-size textures (yes, we are
    looking at you, Vivante):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Load raw bitmap data into OpenGL:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Up to this point, we have enough instruments at our disposal to build portable
    mobile applications using OpenGL. The example application `1_GLES` for this chapter
    renders a colored rotating cube on Windows and Android:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有足够的工具来使用OpenGL构建可移植的移动应用程序。本章的示例应用程序`1_GLES`在Windows和Android上渲染了一个彩色的旋转立方体：
- en: '![Textures](img/image00224.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![纹理](img/image00224.jpeg)'
- en: 'The Windows version can be compiled with `>make all -j16 -B`. An `.apk` package
    for Android can be built by calling these commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows版本可以通过执行`>make all -j16 -B`来编译。可以通过调用以下命令来构建Android的`.apk`包： '
- en: '[PRE98]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned how to wrap raw OpenGL calls into a thin abstraction layer to hide
    many differences between OpenGL ES 3 and OpenGL 4\. Now, let's proceed to the
    next chapter and learn how to implement basic graphical user interface rendering
    using OpenGL and classes shown in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何将原始的OpenGL调用封装在一个轻薄的抽象层中，以隐藏OpenGL ES 3和OpenGL 4之间的许多差异。现在，让我们进入下一章，学习如何使用OpenGL和本章展示的类来实现基本的图形用户界面渲染。
